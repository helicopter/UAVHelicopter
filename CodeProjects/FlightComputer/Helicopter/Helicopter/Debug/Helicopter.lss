
Helicopter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000018e  00800200  0000e30e  0000e3a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000e30e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cf2  0080038e  0080038e  0000e530  2**0
                  ALLOC
  3 .stab         00004d34  00000000  00000000  0000e530  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001555  00000000  00000000  00013264  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000147b9  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000bf8  00000000  00000000  000147e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00044c8d  00000000  00000000  000153e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000844b  00000000  00000000  0005a06d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000065eb  00000000  00000000  000624b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00002f1c  00000000  00000000  00068aa4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000c1a1  00000000  00000000  0006b9c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001fb3f  00000000  00000000  00077b61  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000ec8  00000000  00000000  000976a0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	//TODO should this be delete[]?
	delete this->records;
}

void Buffer::enqueue(Record *record)
{
       0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__dtors_end>
       4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	if (record != NULL)
       8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	{
		//Copy the record
		//TODO danger not deep copy. 
		Record *newRecord = record->Copy();
       c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      10:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		
		//Add the record to the linked list.
		if (this->records == NULL)
      14:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      18:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		{
			records = newRecord;
      1c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			firstRecord = newRecord;
      20:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			lastRecord = newRecord;
      24:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		}else
		{
			lastRecord->setNextRecord(newRecord);
      28:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
					return nextRecord;
				}
				
				void setNextRecord(Record *record)
				{
					nextRecord = record;
      2c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			newRecord->setPreviousRecord(lastRecord);
      30:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
					return previousRecord;	
				}					
				
				void setPreviousRecord(Record *record)
				{
					previousRecord = record;
      34:	0c 94 40 43 	jmp	0x8680	; 0x8680 <__vector_13>
      38:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			lastRecord = newRecord;
      3c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		}
		
		bufferSize++;
      40:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      44:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	}
}
      48:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      4c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      50:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      54:	0c 94 59 6a 	jmp	0xd4b2	; 0xd4b2 <__vector_21>
      58:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      5c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      60:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      64:	0c 94 af 0e 	jmp	0x1d5e	; 0x1d5e <__vector_25>
      68:	0c 94 db 0e 	jmp	0x1db6	; 0x1db6 <__vector_26>
      6c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      70:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      74:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      78:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      7c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      80:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      84:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      88:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      8c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      90:	0c 94 19 4c 	jmp	0x9832	; 0x9832 <__vector_36>
      94:	0c 94 1b 0f 	jmp	0x1e36	; 0x1e36 <__vector_37>
      98:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      9c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      ac:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b8:	0c 94 f1 1f 	jmp	0x3fe2	; 0x3fe2 <__vector_46>
      bc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      cc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      dc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e4:	03 6e       	ori	r16, 0xE3	; 227
      e6:	db 36       	cpi	r29, 0x6B	; 107
      e8:	3d 9a       	sbi	0x07, 5	; 7
      ea:	99 99       	sbic	0x13, 1	; 19
      ec:	99 3d       	cpi	r25, 0xD9	; 217
      ee:	ab aa       	std	Y+51, r10	; 0x33
      f0:	aa 2a       	or	r10, r26
      f2:	3e 00       	.word	0x003e	; ????
      f4:	00 00       	nop
      f6:	80 3f       	cpi	r24, 0xF0	; 240
      f8:	08 4a       	sbci	r16, 0xA8	; 168
      fa:	d7 3b       	cpi	r29, 0xB7	; 183
      fc:	3b ce       	rjmp	.-906    	; 0xfffffd74 <__eeprom_end+0xff7efd74>
      fe:	01 6e       	ori	r16, 0xE1	; 225
     100:	84 bc       	out	0x24, r8	; 36
     102:	bf fd       	.word	0xfdbf	; ????
     104:	c1 2f       	mov	r28, r17
     106:	3d 6c       	ori	r19, 0xCD	; 205
     108:	74 31       	cpi	r23, 0x14	; 20
     10a:	9a bd       	out	0x2a, r25	; 42
     10c:	56 83       	std	Z+6, r21	; 0x06
     10e:	3d da       	rcall	.-2950   	; 0xfffff58a <__eeprom_end+0xff7ef58a>
     110:	3d 00       	.word	0x003d	; ????
     112:	c7 7f       	andi	r28, 0xF7	; 247
     114:	11 be       	out	0x31, r1	; 49
     116:	d9 e4       	ldi	r29, 0x49	; 73
     118:	bb 4c       	sbci	r27, 0xCB	; 203
     11a:	3e 91       	ld	r19, -X
     11c:	6b aa       	std	Y+51, r6	; 0x33
     11e:	aa be       	out	0x3a, r10	; 58
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	3f 07       	cpc	r19, r31
     126:	2c 7a       	andi	r18, 0xAC	; 172
     128:	a5 ba       	out	0x15, r10	; 21
     12a:	6c c5       	rjmp	.+2776   	; 0xc04 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf+0x9c>
     12c:	90 da       	rcall	.-2784   	; 0xfffff64e <__eeprom_end+0xff7ef64e>
     12e:	3b 93       	.word	0x933b	; ????
     130:	65 fc       	sbrc	r6, 5
     132:	8b bc       	out	0x2b, r8	; 43
     134:	53 f8       	bld	r5, 3
     136:	10 fd       	sbrc	r17, 0
     138:	3c 56       	subi	r19, 0x6C	; 108
     13a:	92 83       	std	Z+2, r25	; 0x02
     13c:	4d bd       	out	0x2d, r20	; 45
     13e:	87 9d       	mul	r24, r7
     140:	3a b6       	in	r3, 0x3a	; 58
     142:	3d cb       	rjmp	.-2438   	; 0xfffff7be <__eeprom_end+0xff7ef7be>
     144:	c9 bf       	out	0x39, r28	; 57
     146:	5b be       	out	0x3b, r5	; 59
     148:	73 da       	rcall	.-2842   	; 0xfffff630 <__eeprom_end+0xff7ef630>
     14a:	0f c9       	rjmp	.-3554   	; 0xfffff36a <__eeprom_end+0xff7ef36a>
     14c:	3f 05       	cpc	r19, r15
     14e:	a8 4c       	sbci	r26, 0xC8	; 200
     150:	cd b2       	in	r12, 0x1d	; 29
     152:	d4 4e       	sbci	r29, 0xE4	; 228
     154:	b9 38       	cpi	r27, 0x89	; 137
     156:	36 a9       	ldd	r19, Z+54	; 0x36
     158:	02 0c       	add	r0, r2
     15a:	50 b9       	out	0x00, r21	; 0
     15c:	91 86       	std	Z+9, r9	; 0x09
     15e:	88 08       	sbc	r8, r8
     160:	3c a6       	std	Y+44, r3	; 0x2c
     162:	aa aa       	std	Y+50, r10	; 0x32
     164:	2a be       	out	0x3a, r2	; 58
     166:	00 00       	nop
     168:	00 80       	ld	r0, Z
     16a:	3f 08       	sbc	r3, r15
     16c:	00 00       	nop
     16e:	00 be       	out	0x30, r0	; 48
     170:	92 24       	eor	r9, r2
     172:	49 12       	cpse	r4, r25
     174:	3e ab       	std	Y+54, r19	; 0x36
     176:	aa aa       	std	Y+50, r10	; 0x32
     178:	2a be       	out	0x3a, r2	; 58
     17a:	cd cc       	rjmp	.-1638   	; 0xfffffb16 <__eeprom_end+0xff7efb16>
     17c:	cc 4c       	sbci	r28, 0xCC	; 204
     17e:	3e 00       	.word	0x003e	; ????
     180:	00 00       	nop
     182:	80 be       	out	0x30, r8	; 48
     184:	ab aa       	std	Y+51, r10	; 0x33
     186:	aa aa       	std	Y+50, r10	; 0x32
     188:	3e 00       	.word	0x003e	; ????
     18a:	00 00       	nop
     18c:	00 bf       	out	0x30, r16	; 48
     18e:	00 00       	nop
     190:	00 80       	ld	r0, Z
     192:	3f 00       	.word	0x003f	; ????
     194:	00 00       	nop
     196:	00 00       	nop
     198:	08 41       	sbci	r16, 0x18	; 24
     19a:	78 d3       	rcall	.+1776   	; 0x88c <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x7e>
     19c:	bb 43       	sbci	r27, 0x3B	; 59
     19e:	87 d1       	rcall	.+782    	; 0x4ae <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x20>
     1a0:	13 3d       	cpi	r17, 0xD3	; 211
     1a2:	19 0e       	add	r1, r25
     1a4:	3c c3       	rjmp	.+1656   	; 0x81e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x10>
     1a6:	bd 42       	sbci	r27, 0x2D	; 45
     1a8:	82 ad       	ldd	r24, Z+58	; 0x3a
     1aa:	2b 3e       	cpi	r18, 0xEB	; 235
     1ac:	68 ec       	ldi	r22, 0xC8	; 200
     1ae:	82 76       	andi	r24, 0x62	; 98
     1b0:	be d9       	rcall	.-3204   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     1b2:	8f e1       	ldi	r24, 0x1F	; 31
     1b4:	a9 3e       	cpi	r26, 0xE9	; 233
     1b6:	4c 80       	ldd	r4, Y+4	; 0x04
     1b8:	ef ff       	.word	0xffef	; ????
     1ba:	be 01       	movw	r22, r28
     1bc:	c4 ff       	sbrs	r28, 4
     1be:	7f 3f       	cpi	r23, 0xFF	; 255
     1c0:	00 00       	nop
     1c2:	00 00       	nop
     1c4:	00 07       	cpc	r16, r16
     1c6:	63 42       	sbci	r22, 0x23	; 35
     1c8:	36 b7       	in	r19, 0x36	; 54
     1ca:	9b d8       	rcall	.-3786   	; 0xfffff302 <__eeprom_end+0xff7ef302>
     1cc:	a7 1a       	sub	r10, r23
     1ce:	39 68       	ori	r19, 0x89	; 137
     1d0:	56 18       	sub	r5, r6
     1d2:	ae ba       	out	0x1e, r10	; 30
     1d4:	ab 55       	subi	r26, 0x5B	; 91
     1d6:	8c 1d       	adc	r24, r12
     1d8:	3c b7       	in	r19, 0x3c	; 60
     1da:	cc 57       	subi	r28, 0x7C	; 124
     1dc:	63 bd       	out	0x23, r22	; 35
     1de:	6d ed       	ldi	r22, 0xDD	; 221
     1e0:	fd 75       	andi	r31, 0x5D	; 93
     1e2:	3e f6       	brtc	.-114    	; 0x172 <__SREG__+0x133>
     1e4:	17 72       	andi	r17, 0x27	; 39
     1e6:	31 bf       	out	0x31, r19	; 49
     1e8:	00 00       	nop
     1ea:	00 80       	ld	r0, Z
     1ec:	3f 00       	.word	0x003f	; ????

000001ee <__trampolines_start>:
     1ee:	0c 94 6a 2c 	jmp	0x58d4	; 0x58d4 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>
     1f2:	0c 94 5b 0f 	jmp	0x1eb6	; 0x1eb6 <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     1f6:	0c 94 ea 29 	jmp	0x53d4	; 0x53d4 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
     1fa:	0c 94 1a 5b 	jmp	0xb634	; 0xb634 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>
     1fe:	0c 94 c2 30 	jmp	0x6184	; 0x6184 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>
     202:	0c 94 62 2c 	jmp	0x58c4	; 0x58c4 <_ZN10helicopter8messages11SyncMessageD0Ev>
     206:	0c 94 4f 56 	jmp	0xac9e	; 0xac9e <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>
     20a:	0c 94 5d 59 	jmp	0xb2ba	; 0xb2ba <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>
     20e:	0c 94 78 2c 	jmp	0x58f0	; 0x58f0 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>
     212:	0c 94 93 5a 	jmp	0xb526	; 0xb526 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>
     216:	0c 94 62 28 	jmp	0x50c4	; 0x50c4 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>
     21a:	0c 94 57 59 	jmp	0xb2ae	; 0xb2ae <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>
     21e:	0c 94 51 2c 	jmp	0x58a2	; 0x58a2 <_ZN10helicopter8messages11SyncMessage8getBytesEv>
     222:	0c 94 ca 24 	jmp	0x4994	; 0x4994 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
     226:	0c 94 99 5a 	jmp	0xb532	; 0xb532 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>
     22a:	0c 94 86 0a 	jmp	0x150c	; 0x150c <_ZN10helicopter7drivers12SerialDriver8transmitEf>
     22e:	0c 94 30 60 	jmp	0xc060	; 0xc060 <_ZN10helicopter5tasks4Task11runTaskImplEv>
     232:	0c 94 c8 0a 	jmp	0x1590	; 0x1590 <_ZN10helicopter7drivers12SerialDriver8transmitEi>
     236:	0c 94 ea 0a 	jmp	0x15d4	; 0x15d4 <_ZN10helicopter7drivers12SerialDriver8transmitEm>
     23a:	0c 94 60 60 	jmp	0xc0c0	; 0xc0c0 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>
     23e:	0c 94 31 60 	jmp	0xc062	; 0xc062 <_ZN10helicopter5tasks4TaskD1Ev>
     242:	0c 94 3f 2c 	jmp	0x587e	; 0x587e <_ZN10helicopter8messages11SyncMessageD1Ev>
     246:	0c 94 62 0f 	jmp	0x1ec4	; 0x1ec4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     24a:	0c 94 80 0a 	jmp	0x1500	; 0x1500 <_ZN10helicopter7drivers12SerialDriverD1Ev>
     24e:	0c 94 fc 59 	jmp	0xb3f8	; 0xb3f8 <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>
     252:	0c 94 8a 0c 	jmp	0x1914	; 0x1914 <_ZN10helicopter7drivers12SerialDriver7receiveERh>
     256:	0c 94 99 10 	jmp	0x2132	; 0x2132 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>
     25a:	0c 94 80 56 	jmp	0xad00	; 0xad00 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>
     25e:	0c 94 39 0b 	jmp	0x1672	; 0x1672 <_ZN10helicopter7drivers12SerialDriver8transmitEl>
     262:	0c 94 70 28 	jmp	0x50e0	; 0x50e0 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>
     266:	0c 94 65 59 	jmp	0xb2ca	; 0xb2ca <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>
     26a:	0c 94 b1 26 	jmp	0x4d62	; 0x4d62 <_ZN10helicopter8messages17SensorDataMessageD0Ev>
     26e:	0c 94 9e 26 	jmp	0x4d3c	; 0x4d3c <_ZN10helicopter8messages7Message12buildMessageEPh>
     272:	0c 94 58 60 	jmp	0xc0b0	; 0xc0b0 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>
     276:	0c 94 70 2c 	jmp	0x58e0	; 0x58e0 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>
     27a:	0c 94 7d 5b 	jmp	0xb6fa	; 0xb6fa <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>
     27e:	0c 94 52 60 	jmp	0xc0a4	; 0xc0a4 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>
     282:	0c 94 b9 26 	jmp	0x4d72	; 0x4d72 <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>
     286:	0c 94 40 23 	jmp	0x4680	; 0x4680 <_ZN10helicopter8messages14ControlMessageD0Ev>
     28a:	0c 94 15 55 	jmp	0xaa2a	; 0xaa2a <_ZN10helicopter5tasks14NavigationTaskD0Ev>
     28e:	0c 94 d2 58 	jmp	0xb1a4	; 0xb1a4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>
     292:	0c 94 9b 26 	jmp	0x4d36	; 0x4d36 <_ZN10helicopter8messages7Message8getBytesEv>
     296:	0c 94 a8 23 	jmp	0x4750	; 0x4750 <_ZN10helicopter8messages12GainsMessageD0Ev>
     29a:	0c 94 fc 0d 	jmp	0x1bf8	; 0x1bf8 <_ZN10helicopter7drivers12SerialDriverD0Ev>
     29e:	0c 94 4d 0d 	jmp	0x1a9a	; 0x1a9a <_ZN10helicopter7drivers12SerialDriver4initEv>
     2a2:	0c 94 12 5b 	jmp	0xb624	; 0xb624 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>
     2a6:	0c 94 d8 58 	jmp	0xb1b0	; 0xb1b0 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>
     2aa:	0c 94 3f 60 	jmp	0xc07e	; 0xc07e <_ZN10helicopter5tasks4TaskD0Ev>
     2ae:	0c 94 0f 55 	jmp	0xaa1e	; 0xaa1e <_ZN10helicopter5tasks14NavigationTaskD1Ev>
     2b2:	0c 94 a3 56 	jmp	0xad46	; 0xad46 <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>
     2b6:	0c 94 45 2c 	jmp	0x588a	; 0x588a <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>
     2ba:	0c 94 02 5a 	jmp	0xb404	; 0xb404 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>
     2be:	0c 94 83 5b 	jmp	0xb706	; 0xb706 <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>
     2c2:	0c 94 0c 5b 	jmp	0xb618	; 0xb618 <_ZN10helicopter5tasks16ServoControlTaskD1Ev>
     2c6:	0c 94 7a 56 	jmp	0xacf4	; 0xacf4 <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>
     2ca:	0c 94 68 28 	jmp	0x50d0	; 0x50d0 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>
     2ce:	0c 94 a9 56 	jmp	0xad52	; 0xad52 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>
     2d2:	0c 94 37 60 	jmp	0xc06e	; 0xc06e <_ZN10helicopter5tasks4Task7runTaskEv>
     2d6:	0c 94 57 56 	jmp	0xacae	; 0xacae <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>
     2da:	0c 94 4f 27 	jmp	0x4e9e	; 0x4e9e <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
     2de:	0c 94 e0 58 	jmp	0xb1c0	; 0xb1c0 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>
     2e2:	0c 94 48 23 	jmp	0x4690	; 0x4690 <_ZN10helicopter8messages14ControlMessage8getBytesEv>
     2e6:	0c 94 a1 5a 	jmp	0xb542	; 0xb542 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>
     2ea:	0c 94 95 26 	jmp	0x4d2a	; 0x4d2a <_ZN10helicopter8messages7MessageD1Ev>
     2ee:	0c 94 3a 23 	jmp	0x4674	; 0x4674 <_ZN10helicopter8messages14ControlMessageD1Ev>
     2f2:	0c 94 77 23 	jmp	0x46ee	; 0x46ee <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>
     2f6:	0c 94 b0 23 	jmp	0x4760	; 0x4760 <_ZN10helicopter8messages12GainsMessage8getBytesEv>
     2fa:	0c 94 9f 26 	jmp	0x4d3e	; 0x4d3e <_ZN10helicopter8messages7MessageD0Ev>
     2fe:	0c 94 ab 26 	jmp	0x4d56	; 0x4d56 <_ZN10helicopter8messages17SensorDataMessageD1Ev>
     302:	0c 94 1d 55 	jmp	0xaa3a	; 0xaa3a <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>
     306:	0c 94 49 56 	jmp	0xac92	; 0xac92 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>
     30a:	0c 94 a2 23 	jmp	0x4744	; 0x4744 <_ZN10helicopter8messages12GainsMessageD1Ev>
     30e:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <_ZN10helicopter7drivers12SerialDriver8transmitEx>
     312:	0c 94 8b 5b 	jmp	0xb716	; 0xb716 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>
     316:	0c 94 77 10 	jmp	0x20ee	; 0x20ee <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>
     31a:	0c 94 9f 10 	jmp	0x213e	; 0x213e <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>
     31e:	0c 94 f5 0c 	jmp	0x19ea	; 0x19ea <_ZN10helicopter7drivers12SerialDriver8transmitEh>
     322:	0c 94 6a 10 	jmp	0x20d4	; 0x20d4 <_ZN10helicopter5tasks12FlashLEDTask4initEv>
     326:	0c 94 0a 5a 	jmp	0xb414	; 0xb414 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>
     32a:	0c 94 88 56 	jmp	0xad10	; 0xad10 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>
     32e:	0c 94 b1 56 	jmp	0xad62	; 0xad62 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>
     332:	0c 94 0e 55 	jmp	0xaa1c	; 0xaa1c <_ZN10helicopter5tasks4Task4initEv>

00000336 <__ctors_start>:
     336:	5b 0f       	add	r21, r27

00000338 <__ctors_end>:
     338:	62 0f       	add	r22, r18

0000033a <__dtors_end>:
     33a:	11 24       	eor	r1, r1
     33c:	1f be       	out	0x3f, r1	; 63
     33e:	cf ef       	ldi	r28, 0xFF	; 255
     340:	d1 e2       	ldi	r29, 0x21	; 33
     342:	de bf       	out	0x3e, r29	; 62
     344:	cd bf       	out	0x3d, r28	; 61
     346:	00 e0       	ldi	r16, 0x00	; 0
     348:	0c bf       	out	0x3c, r16	; 60

0000034a <__do_copy_data>:
     34a:	13 e0       	ldi	r17, 0x03	; 3
     34c:	a0 e0       	ldi	r26, 0x00	; 0
     34e:	b2 e0       	ldi	r27, 0x02	; 2
     350:	ee e0       	ldi	r30, 0x0E	; 14
     352:	f3 ee       	ldi	r31, 0xE3	; 227
     354:	00 e0       	ldi	r16, 0x00	; 0
     356:	0b bf       	out	0x3b, r16	; 59
     358:	02 c0       	rjmp	.+4      	; 0x35e <__do_copy_data+0x14>
     35a:	07 90       	elpm	r0, Z+
     35c:	0d 92       	st	X+, r0
     35e:	ae 38       	cpi	r26, 0x8E	; 142
     360:	b1 07       	cpc	r27, r17
     362:	d9 f7       	brne	.-10     	; 0x35a <__do_copy_data+0x10>

00000364 <__do_clear_bss>:
     364:	20 e1       	ldi	r18, 0x10	; 16
     366:	ae e8       	ldi	r26, 0x8E	; 142
     368:	b3 e0       	ldi	r27, 0x03	; 3
     36a:	01 c0       	rjmp	.+2      	; 0x36e <.do_clear_bss_start>

0000036c <.do_clear_bss_loop>:
     36c:	1d 92       	st	X+, r1

0000036e <.do_clear_bss_start>:
     36e:	a0 38       	cpi	r26, 0x80	; 128
     370:	b2 07       	cpc	r27, r18
     372:	e1 f7       	brne	.-8      	; 0x36c <.do_clear_bss_loop>

00000374 <__do_global_ctors>:
     374:	13 e0       	ldi	r17, 0x03	; 3
     376:	c8 e3       	ldi	r28, 0x38	; 56
     378:	d3 e0       	ldi	r29, 0x03	; 3
     37a:	00 e0       	ldi	r16, 0x00	; 0
     37c:	06 c0       	rjmp	.+12     	; 0x38a <__do_global_ctors+0x16>
     37e:	22 97       	sbiw	r28, 0x02	; 2
     380:	01 09       	sbc	r16, r1
     382:	fe 01       	movw	r30, r28
     384:	0b bf       	out	0x3b, r16	; 59
     386:	0e 94 eb 6f 	call	0xdfd6	; 0xdfd6 <__tablejump_elpm__>
     38a:	c6 33       	cpi	r28, 0x36	; 54
     38c:	d1 07       	cpc	r29, r17
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	08 07       	cpc	r16, r24
     392:	a9 f7       	brne	.-22     	; 0x37e <__do_global_ctors+0xa>
     394:	0e 94 3b 14 	call	0x2876	; 0x2876 <main>
     398:	0c 94 75 71 	jmp	0xe2ea	; 0xe2ea <__do_global_dtors>

0000039c <__bad_interrupt>:
     39c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>:
#include <avr/interrupt.h>

using namespace helicopter::buffer;

bool CircularBuffer::enqueue(byte val)
{	
     3a0:	fc 01       	movw	r30, r24
	PORTA &= ~(1<<PA5);
}
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     3a2:	20 85       	ldd	r18, Z+8	; 0x08
     3a4:	31 85       	ldd	r19, Z+9	; 0x09
     3a6:	82 81       	ldd	r24, Z+2	; 0x02
     3a8:	93 81       	ldd	r25, Z+3	; 0x03
     3aa:	28 17       	cp	r18, r24
     3ac:	39 07       	cpc	r19, r25
     3ae:	d4 f4       	brge	.+52     	; 0x3e4 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x44>
	{
		return false;
	}
cli();		
     3b0:	f8 94       	cli
	buffer[tailIndex++] = val;
     3b2:	86 81       	ldd	r24, Z+6	; 0x06
     3b4:	97 81       	ldd	r25, Z+7	; 0x07
     3b6:	a0 81       	ld	r26, Z
     3b8:	b1 81       	ldd	r27, Z+1	; 0x01
     3ba:	a8 0f       	add	r26, r24
     3bc:	b9 1f       	adc	r27, r25
     3be:	6c 93       	st	X, r22
     3c0:	01 96       	adiw	r24, 0x01	; 1
     3c2:	97 83       	std	Z+7, r25	; 0x07
     3c4:	86 83       	std	Z+6, r24	; 0x06
	
	if (tailIndex >= bufferSize)
     3c6:	22 81       	ldd	r18, Z+2	; 0x02
     3c8:	33 81       	ldd	r19, Z+3	; 0x03
     3ca:	82 17       	cp	r24, r18
     3cc:	93 07       	cpc	r25, r19
     3ce:	14 f0       	brlt	.+4      	; 0x3d4 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x34>
	{
		tailIndex = 0;
     3d0:	17 82       	std	Z+7, r1	; 0x07
     3d2:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     3d4:	80 85       	ldd	r24, Z+8	; 0x08
     3d6:	91 85       	ldd	r25, Z+9	; 0x09
     3d8:	01 96       	adiw	r24, 0x01	; 1
     3da:	91 87       	std	Z+9, r25	; 0x09
     3dc:	80 87       	std	Z+8, r24	; 0x08
	
	
sei();
     3de:	78 94       	sei
	return true;
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	08 95       	ret
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     3e4:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	
sei();
	return true;
}
     3e6:	08 95       	ret

000003e8 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>:

bool CircularBuffer::dequeue(byte &val)
{
     3e8:	fc 01       	movw	r30, r24
if ((tailIndex == headIndex) && bytesInQueue != 0)
{
	PORTA &= ~(1<<PA5);
}
*/
	val = 0;
     3ea:	db 01       	movw	r26, r22
     3ec:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     3ee:	80 85       	ldd	r24, Z+8	; 0x08
     3f0:	91 85       	ldd	r25, Z+9	; 0x09
     3f2:	89 2b       	or	r24, r25
     3f4:	e1 f0       	breq	.+56     	; 0x42e <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x46>
	{
		return false;
	}
	cli();	
     3f6:	f8 94       	cli
	val = buffer[headIndex++];
     3f8:	84 81       	ldd	r24, Z+4	; 0x04
     3fa:	95 81       	ldd	r25, Z+5	; 0x05
     3fc:	a0 81       	ld	r26, Z
     3fe:	b1 81       	ldd	r27, Z+1	; 0x01
     400:	a8 0f       	add	r26, r24
     402:	b9 1f       	adc	r27, r25
     404:	2c 91       	ld	r18, X
     406:	db 01       	movw	r26, r22
     408:	2c 93       	st	X, r18
     40a:	01 96       	adiw	r24, 0x01	; 1
     40c:	95 83       	std	Z+5, r25	; 0x05
     40e:	84 83       	std	Z+4, r24	; 0x04
	
	if (headIndex >= bufferSize)
     410:	22 81       	ldd	r18, Z+2	; 0x02
     412:	33 81       	ldd	r19, Z+3	; 0x03
     414:	82 17       	cp	r24, r18
     416:	93 07       	cpc	r25, r19
     418:	14 f0       	brlt	.+4      	; 0x41e <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x36>
	{
		headIndex = 0;
     41a:	15 82       	std	Z+5, r1	; 0x05
     41c:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     41e:	80 85       	ldd	r24, Z+8	; 0x08
     420:	91 85       	ldd	r25, Z+9	; 0x09
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	91 87       	std	Z+9, r25	; 0x09
     426:	80 87       	std	Z+8, r24	; 0x08
	
	sei();
     428:	78 94       	sei
	return true;
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     42e:	80 e0       	ldi	r24, 0x00	; 0
	
	bytesInQueue--;
	
	sei();
	return true;
}
     430:	08 95       	ret

00000432 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>:



bool CircularBuffer::enqueueInt(byte val)
{
     432:	fc 01       	movw	r30, r24

	if ((tailIndex == headIndex) && bytesInQueue != 0)
     434:	26 81       	ldd	r18, Z+6	; 0x06
     436:	37 81       	ldd	r19, Z+7	; 0x07
     438:	84 81       	ldd	r24, Z+4	; 0x04
     43a:	95 81       	ldd	r25, Z+5	; 0x05
     43c:	28 17       	cp	r18, r24
     43e:	39 07       	cpc	r19, r25
     440:	29 f4       	brne	.+10     	; 0x44c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
     442:	80 85       	ldd	r24, Z+8	; 0x08
     444:	91 85       	ldd	r25, Z+9	; 0x09
     446:	89 2b       	or	r24, r25
     448:	09 f0       	breq	.+2      	; 0x44c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     44a:	15 98       	cbi	0x02, 5	; 2
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     44c:	20 85       	ldd	r18, Z+8	; 0x08
     44e:	31 85       	ldd	r19, Z+9	; 0x09
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
     454:	28 17       	cp	r18, r24
     456:	39 07       	cpc	r19, r25
     458:	c4 f4       	brge	.+48     	; 0x48a <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x58>
	{
		return false;
	}
	
	buffer[tailIndex++] = val;
     45a:	86 81       	ldd	r24, Z+6	; 0x06
     45c:	97 81       	ldd	r25, Z+7	; 0x07
     45e:	a0 81       	ld	r26, Z
     460:	b1 81       	ldd	r27, Z+1	; 0x01
     462:	a8 0f       	add	r26, r24
     464:	b9 1f       	adc	r27, r25
     466:	6c 93       	st	X, r22
     468:	01 96       	adiw	r24, 0x01	; 1
     46a:	97 83       	std	Z+7, r25	; 0x07
     46c:	86 83       	std	Z+6, r24	; 0x06
	
	if (tailIndex >= bufferSize)
     46e:	22 81       	ldd	r18, Z+2	; 0x02
     470:	33 81       	ldd	r19, Z+3	; 0x03
     472:	82 17       	cp	r24, r18
     474:	93 07       	cpc	r25, r19
     476:	14 f0       	brlt	.+4      	; 0x47c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x4a>
	{
		tailIndex = 0;
     478:	17 82       	std	Z+7, r1	; 0x07
     47a:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     47c:	80 85       	ldd	r24, Z+8	; 0x08
     47e:	91 85       	ldd	r25, Z+9	; 0x09
     480:	01 96       	adiw	r24, 0x01	; 1
     482:	91 87       	std	Z+9, r25	; 0x09
     484:	80 87       	std	Z+8, r24	; 0x08
	
	

	return true;
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	08 95       	ret
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     48a:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	

	return true;
}
     48c:	08 95       	ret

0000048e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>:

bool CircularBuffer::dequeueInt(byte &val)
{
     48e:	fc 01       	movw	r30, r24
	if ((tailIndex == headIndex) && bytesInQueue != 0)
     490:	26 81       	ldd	r18, Z+6	; 0x06
     492:	37 81       	ldd	r19, Z+7	; 0x07
     494:	84 81       	ldd	r24, Z+4	; 0x04
     496:	95 81       	ldd	r25, Z+5	; 0x05
     498:	28 17       	cp	r18, r24
     49a:	39 07       	cpc	r19, r25
     49c:	29 f4       	brne	.+10     	; 0x4a8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
     49e:	80 85       	ldd	r24, Z+8	; 0x08
     4a0:	91 85       	ldd	r25, Z+9	; 0x09
     4a2:	89 2b       	or	r24, r25
     4a4:	09 f0       	breq	.+2      	; 0x4a8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     4a6:	15 98       	cbi	0x02, 5	; 2
	}
	val = 0;
     4a8:	db 01       	movw	r26, r22
     4aa:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     4ac:	80 85       	ldd	r24, Z+8	; 0x08
     4ae:	91 85       	ldd	r25, Z+9	; 0x09
     4b0:	89 2b       	or	r24, r25
     4b2:	d1 f0       	breq	.+52     	; 0x4e8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x5a>
	{
		return false;
	}
	
	val = buffer[headIndex++];
     4b4:	84 81       	ldd	r24, Z+4	; 0x04
     4b6:	95 81       	ldd	r25, Z+5	; 0x05
     4b8:	a0 81       	ld	r26, Z
     4ba:	b1 81       	ldd	r27, Z+1	; 0x01
     4bc:	a8 0f       	add	r26, r24
     4be:	b9 1f       	adc	r27, r25
     4c0:	2c 91       	ld	r18, X
     4c2:	db 01       	movw	r26, r22
     4c4:	2c 93       	st	X, r18
     4c6:	01 96       	adiw	r24, 0x01	; 1
     4c8:	95 83       	std	Z+5, r25	; 0x05
     4ca:	84 83       	std	Z+4, r24	; 0x04
	
	if (headIndex >= bufferSize)
     4cc:	22 81       	ldd	r18, Z+2	; 0x02
     4ce:	33 81       	ldd	r19, Z+3	; 0x03
     4d0:	82 17       	cp	r24, r18
     4d2:	93 07       	cpc	r25, r19
     4d4:	14 f0       	brlt	.+4      	; 0x4da <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x4c>
	{
		headIndex = 0;
     4d6:	15 82       	std	Z+5, r1	; 0x05
     4d8:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     4da:	80 85       	ldd	r24, Z+8	; 0x08
     4dc:	91 85       	ldd	r25, Z+9	; 0x09
     4de:	01 97       	sbiw	r24, 0x01	; 1
     4e0:	91 87       	std	Z+9, r25	; 0x09
     4e2:	80 87       	std	Z+8, r24	; 0x08
	
	return true;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     4e8:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	bytesInQueue--;
	
	return true;
}
     4ea:	08 95       	ret

000004ec <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>:
#include "MatrixUtil.h"

using namespace helicopter::controller;
using namespace helicopter::util;

PIDController::PIDController(SystemModel *model): 
     4ec:	fc 01       	movw	r30, r24
minMainRotorServoControlValue(0),
maxMainRotorServoControlValue(0),

intervalPeriodSecs(0),
controlMaxValue(0),
controlMinValue(0)
     4ee:	71 83       	std	Z+1, r23	; 0x01
     4f0:	60 83       	st	Z, r22
     4f2:	12 82       	std	Z+2, r1	; 0x02
     4f4:	13 82       	std	Z+3, r1	; 0x03
     4f6:	14 82       	std	Z+4, r1	; 0x04
     4f8:	15 82       	std	Z+5, r1	; 0x05
     4fa:	16 82       	std	Z+6, r1	; 0x06
     4fc:	17 82       	std	Z+7, r1	; 0x07
     4fe:	10 86       	std	Z+8, r1	; 0x08
     500:	11 86       	std	Z+9, r1	; 0x09
     502:	12 86       	std	Z+10, r1	; 0x0a
     504:	13 86       	std	Z+11, r1	; 0x0b
     506:	14 86       	std	Z+12, r1	; 0x0c
     508:	15 86       	std	Z+13, r1	; 0x0d
     50a:	16 86       	std	Z+14, r1	; 0x0e
     50c:	17 86       	std	Z+15, r1	; 0x0f
     50e:	10 8a       	std	Z+16, r1	; 0x10
     510:	11 8a       	std	Z+17, r1	; 0x11
     512:	12 8a       	std	Z+18, r1	; 0x12
     514:	13 8a       	std	Z+19, r1	; 0x13
     516:	14 8a       	std	Z+20, r1	; 0x14
     518:	15 8a       	std	Z+21, r1	; 0x15
     51a:	16 8a       	std	Z+22, r1	; 0x16
     51c:	17 8a       	std	Z+23, r1	; 0x17
     51e:	10 8e       	std	Z+24, r1	; 0x18
     520:	11 8e       	std	Z+25, r1	; 0x19
     522:	12 8e       	std	Z+26, r1	; 0x1a
     524:	13 8e       	std	Z+27, r1	; 0x1b
     526:	14 8e       	std	Z+28, r1	; 0x1c
     528:	15 8e       	std	Z+29, r1	; 0x1d
     52a:	16 8e       	std	Z+30, r1	; 0x1e
     52c:	17 8e       	std	Z+31, r1	; 0x1f
     52e:	10 a2       	std	Z+32, r1	; 0x20
     530:	11 a2       	std	Z+33, r1	; 0x21
     532:	12 a2       	std	Z+34, r1	; 0x22
     534:	13 a2       	std	Z+35, r1	; 0x23
     536:	14 a2       	std	Z+36, r1	; 0x24
     538:	15 a2       	std	Z+37, r1	; 0x25
     53a:	12 a6       	std	Z+42, r1	; 0x2a
     53c:	13 a6       	std	Z+43, r1	; 0x2b
     53e:	14 a6       	std	Z+44, r1	; 0x2c
     540:	15 a6       	std	Z+45, r1	; 0x2d
     542:	16 a6       	std	Z+46, r1	; 0x2e
     544:	17 a6       	std	Z+47, r1	; 0x2f
     546:	10 aa       	std	Z+48, r1	; 0x30
     548:	11 aa       	std	Z+49, r1	; 0x31
     54a:	12 aa       	std	Z+50, r1	; 0x32
     54c:	13 aa       	std	Z+51, r1	; 0x33
     54e:	14 aa       	std	Z+52, r1	; 0x34
     550:	15 aa       	std	Z+53, r1	; 0x35
     552:	16 aa       	std	Z+54, r1	; 0x36
     554:	17 aa       	std	Z+55, r1	; 0x37
     556:	10 ae       	std	Z+56, r1	; 0x38
     558:	11 ae       	std	Z+57, r1	; 0x39
     55a:	12 ae       	std	Z+58, r1	; 0x3a
     55c:	13 ae       	std	Z+59, r1	; 0x3b
     55e:	14 ae       	std	Z+60, r1	; 0x3c
     560:	15 ae       	std	Z+61, r1	; 0x3d
     562:	dc 01       	movw	r26, r24
     564:	ae 5b       	subi	r26, 0xBE	; 190
     566:	bf 4f       	sbci	r27, 0xFF	; 255
     568:	1d 92       	st	X+, r1
     56a:	1d 92       	st	X+, r1
     56c:	1d 92       	st	X+, r1
     56e:	1c 92       	st	X, r1
     570:	13 97       	sbiw	r26, 0x03	; 3
     572:	dc 01       	movw	r26, r24
     574:	aa 5b       	subi	r26, 0xBA	; 186
     576:	bf 4f       	sbci	r27, 0xFF	; 255
     578:	1d 92       	st	X+, r1
     57a:	1d 92       	st	X+, r1
     57c:	1d 92       	st	X+, r1
     57e:	1c 92       	st	X, r1
     580:	13 97       	sbiw	r26, 0x03	; 3
     582:	dc 01       	movw	r26, r24
     584:	a6 5b       	subi	r26, 0xB6	; 182
     586:	bf 4f       	sbci	r27, 0xFF	; 255
     588:	1d 92       	st	X+, r1
     58a:	1d 92       	st	X+, r1
     58c:	1d 92       	st	X+, r1
     58e:	1c 92       	st	X, r1
     590:	13 97       	sbiw	r26, 0x03	; 3
     592:	dc 01       	movw	r26, r24
     594:	a2 5b       	subi	r26, 0xB2	; 178
     596:	bf 4f       	sbci	r27, 0xFF	; 255
     598:	1d 92       	st	X+, r1
     59a:	1d 92       	st	X+, r1
     59c:	1d 92       	st	X+, r1
     59e:	1c 92       	st	X, r1
     5a0:	13 97       	sbiw	r26, 0x03	; 3
     5a2:	dc 01       	movw	r26, r24
     5a4:	ae 5a       	subi	r26, 0xAE	; 174
     5a6:	bf 4f       	sbci	r27, 0xFF	; 255
     5a8:	1d 92       	st	X+, r1
     5aa:	1d 92       	st	X+, r1
     5ac:	1d 92       	st	X+, r1
     5ae:	1c 92       	st	X, r1
     5b0:	13 97       	sbiw	r26, 0x03	; 3
     5b2:	dc 01       	movw	r26, r24
     5b4:	aa 5a       	subi	r26, 0xAA	; 170
     5b6:	bf 4f       	sbci	r27, 0xFF	; 255
     5b8:	1d 92       	st	X+, r1
     5ba:	1d 92       	st	X+, r1
     5bc:	1d 92       	st	X+, r1
     5be:	1c 92       	st	X, r1
     5c0:	13 97       	sbiw	r26, 0x03	; 3
     5c2:	dc 01       	movw	r26, r24
     5c4:	a6 5a       	subi	r26, 0xA6	; 166
     5c6:	bf 4f       	sbci	r27, 0xFF	; 255
     5c8:	1d 92       	st	X+, r1
     5ca:	1d 92       	st	X+, r1
     5cc:	1d 92       	st	X+, r1
     5ce:	1c 92       	st	X, r1
     5d0:	13 97       	sbiw	r26, 0x03	; 3
     5d2:	dc 01       	movw	r26, r24
     5d4:	a2 5a       	subi	r26, 0xA2	; 162
     5d6:	bf 4f       	sbci	r27, 0xFF	; 255
     5d8:	1d 92       	st	X+, r1
     5da:	1d 92       	st	X+, r1
     5dc:	1d 92       	st	X+, r1
     5de:	1c 92       	st	X, r1
     5e0:	13 97       	sbiw	r26, 0x03	; 3
     5e2:	dc 01       	movw	r26, r24
     5e4:	ae 59       	subi	r26, 0x9E	; 158
     5e6:	bf 4f       	sbci	r27, 0xFF	; 255
     5e8:	1d 92       	st	X+, r1
     5ea:	1d 92       	st	X+, r1
     5ec:	1d 92       	st	X+, r1
     5ee:	1c 92       	st	X, r1
     5f0:	13 97       	sbiw	r26, 0x03	; 3
     5f2:	dc 01       	movw	r26, r24
     5f4:	aa 59       	subi	r26, 0x9A	; 154
     5f6:	bf 4f       	sbci	r27, 0xFF	; 255
     5f8:	1d 92       	st	X+, r1
     5fa:	1d 92       	st	X+, r1
     5fc:	1d 92       	st	X+, r1
     5fe:	1c 92       	st	X, r1
     600:	13 97       	sbiw	r26, 0x03	; 3
     602:	dc 01       	movw	r26, r24
     604:	a6 59       	subi	r26, 0x96	; 150
     606:	bf 4f       	sbci	r27, 0xFF	; 255
     608:	1d 92       	st	X+, r1
     60a:	1d 92       	st	X+, r1
     60c:	1d 92       	st	X+, r1
     60e:	1c 92       	st	X, r1
     610:	13 97       	sbiw	r26, 0x03	; 3
     612:	dc 01       	movw	r26, r24
     614:	a2 59       	subi	r26, 0x92	; 146
     616:	bf 4f       	sbci	r27, 0xFF	; 255
     618:	1d 92       	st	X+, r1
     61a:	1d 92       	st	X+, r1
     61c:	1d 92       	st	X+, r1
     61e:	1c 92       	st	X, r1
     620:	13 97       	sbiw	r26, 0x03	; 3
     622:	dc 01       	movw	r26, r24
     624:	ae 57       	subi	r26, 0x7E	; 126
     626:	bf 4f       	sbci	r27, 0xFF	; 255
     628:	1d 92       	st	X+, r1
     62a:	1d 92       	st	X+, r1
     62c:	1d 92       	st	X+, r1
     62e:	1c 92       	st	X, r1
     630:	13 97       	sbiw	r26, 0x03	; 3
     632:	dc 01       	movw	r26, r24
     634:	aa 57       	subi	r26, 0x7A	; 122
     636:	bf 4f       	sbci	r27, 0xFF	; 255
     638:	1d 92       	st	X+, r1
     63a:	1d 92       	st	X+, r1
     63c:	1d 92       	st	X+, r1
     63e:	1c 92       	st	X, r1
     640:	13 97       	sbiw	r26, 0x03	; 3
     642:	e6 57       	subi	r30, 0x76	; 118
     644:	ff 4f       	sbci	r31, 0xFF	; 255
     646:	10 82       	st	Z, r1
     648:	11 82       	std	Z+1, r1	; 0x01
     64a:	12 82       	std	Z+2, r1	; 0x02
     64c:	13 82       	std	Z+3, r1	; 0x03
     64e:	08 95       	ret

00000650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>:




float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
     650:	4f 92       	push	r4
     652:	5f 92       	push	r5
     654:	6f 92       	push	r6
     656:	7f 92       	push	r7
     658:	8f 92       	push	r8
     65a:	9f 92       	push	r9
     65c:	af 92       	push	r10
     65e:	bf 92       	push	r11
     660:	cf 92       	push	r12
     662:	df 92       	push	r13
     664:	ef 92       	push	r14
     666:	ff 92       	push	r15
     668:	0f 93       	push	r16
     66a:	1f 93       	push	r17
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	cd b7       	in	r28, 0x3d	; 61
     672:	de b7       	in	r29, 0x3e	; 62
     674:	28 97       	sbiw	r28, 0x08	; 8
     676:	0f b6       	in	r0, 0x3f	; 63
     678:	f8 94       	cli
     67a:	de bf       	out	0x3e, r29	; 62
     67c:	0f be       	out	0x3f, r0	; 63
     67e:	cd bf       	out	0x3d, r28	; 61
     680:	2a 01       	movw	r4, r20
     682:	3b 01       	movw	r6, r22
     684:	09 83       	std	Y+1, r16	; 0x01
     686:	1a 83       	std	Y+2, r17	; 0x02
     688:	2b 83       	std	Y+3, r18	; 0x03
     68a:	3c 83       	std	Y+4, r19	; 0x04
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     68c:	68 a1       	ldd	r22, Y+32	; 0x20
     68e:	79 a1       	ldd	r23, Y+33	; 0x21
     690:	88 27       	eor	r24, r24
     692:	77 fd       	sbrc	r23, 7
     694:	80 95       	com	r24
     696:	98 2f       	mov	r25, r24
     698:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
     69c:	6d 83       	std	Y+5, r22	; 0x05
     69e:	7e 83       	std	Y+6, r23	; 0x06
     6a0:	8f 83       	std	Y+7, r24	; 0x07
     6a2:	98 87       	std	Y+8, r25	; 0x08
     6a4:	a5 01       	movw	r20, r10
     6a6:	94 01       	movw	r18, r8
     6a8:	c3 01       	movw	r24, r6
     6aa:	b2 01       	movw	r22, r4
     6ac:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     6b0:	a7 01       	movw	r20, r14
     6b2:	96 01       	movw	r18, r12
     6b4:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     6b8:	4b 01       	movw	r8, r22
     6ba:	5c 01       	movw	r10, r24
     6bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6be:	3d 8d       	ldd	r19, Y+29	; 0x1d
     6c0:	4e 8d       	ldd	r20, Y+30	; 0x1e
     6c2:	5f 8d       	ldd	r21, Y+31	; 0x1f
     6c4:	69 81       	ldd	r22, Y+1	; 0x01
     6c6:	7a 81       	ldd	r23, Y+2	; 0x02
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	9c 81       	ldd	r25, Y+4	; 0x04
     6cc:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     6d0:	9b 01       	movw	r18, r22
     6d2:	ac 01       	movw	r20, r24
     6d4:	c5 01       	movw	r24, r10
     6d6:	b4 01       	movw	r22, r8
     6d8:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     6dc:	9b 01       	movw	r18, r22
     6de:	ac 01       	movw	r20, r24
     6e0:	6d 81       	ldd	r22, Y+5	; 0x05
     6e2:	7e 81       	ldd	r23, Y+6	; 0x06
     6e4:	8f 81       	ldd	r24, Y+7	; 0x07
     6e6:	98 85       	ldd	r25, Y+8	; 0x08
     6e8:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
	
	return controlValue;
	*/
}
     6ec:	28 96       	adiw	r28, 0x08	; 8
     6ee:	0f b6       	in	r0, 0x3f	; 63
     6f0:	f8 94       	cli
     6f2:	de bf       	out	0x3e, r29	; 62
     6f4:	0f be       	out	0x3f, r0	; 63
     6f6:	cd bf       	out	0x3d, r28	; 61
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	1f 91       	pop	r17
     6fe:	0f 91       	pop	r16
     700:	ff 90       	pop	r15
     702:	ef 90       	pop	r14
     704:	df 90       	pop	r13
     706:	cf 90       	pop	r12
     708:	bf 90       	pop	r11
     70a:	af 90       	pop	r10
     70c:	9f 90       	pop	r9
     70e:	8f 90       	pop	r8
     710:	7f 90       	pop	r7
     712:	6f 90       	pop	r6
     714:	5f 90       	pop	r5
     716:	4f 90       	pop	r4
     718:	08 95       	ret

0000071a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>:


float PIDController::adjustControlForServoLimits( float controlValueToAdjust, float minServoControlValue, float maxServoControlValue )
{
     71a:	8f 92       	push	r8
     71c:	9f 92       	push	r9
     71e:	af 92       	push	r10
     720:	bf 92       	push	r11
     722:	cf 92       	push	r12
     724:	df 92       	push	r13
     726:	ef 92       	push	r14
     728:	ff 92       	push	r15
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	a4 2e       	mov	r10, r20
     734:	b5 2e       	mov	r11, r21
     736:	d6 2f       	mov	r29, r22
     738:	c7 2f       	mov	r28, r23
     73a:	82 2e       	mov	r8, r18
     73c:	93 2e       	mov	r9, r19

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
     73e:	2c 2d       	mov	r18, r12
     740:	3d 2d       	mov	r19, r13
     742:	4e 2d       	mov	r20, r14
     744:	5f 2d       	mov	r21, r15
     746:	6a 2d       	mov	r22, r10
     748:	7b 2d       	mov	r23, r11
     74a:	8d 2f       	mov	r24, r29
     74c:	9c 2f       	mov	r25, r28
     74e:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
     752:	18 16       	cp	r1, r24
     754:	6c f0       	brlt	.+26     	; 0x770 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x56>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
     756:	20 2f       	mov	r18, r16
     758:	31 2f       	mov	r19, r17
     75a:	48 2d       	mov	r20, r8
     75c:	59 2d       	mov	r21, r9
     75e:	6a 2d       	mov	r22, r10
     760:	7b 2d       	mov	r23, r11
     762:	8d 2f       	mov	r24, r29
     764:	9c 2f       	mov	r25, r28
     766:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
     76a:	88 23       	and	r24, r24
     76c:	34 f0       	brlt	.+12     	; 0x77a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x60>
     76e:	09 c0       	rjmp	.+18     	; 0x782 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x68>
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
	{
		controlValueToAdjust = maxServoControlValue;
     770:	ac 2c       	mov	r10, r12
     772:	bd 2c       	mov	r11, r13
     774:	de 2d       	mov	r29, r14
     776:	cf 2d       	mov	r28, r15
     778:	04 c0       	rjmp	.+8      	; 0x782 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x68>
	}else if (controlValueToAdjust < minServoControlValue)
	{
		controlValueToAdjust = minServoControlValue;
     77a:	a0 2e       	mov	r10, r16
     77c:	b1 2e       	mov	r11, r17
     77e:	d8 2d       	mov	r29, r8
     780:	c9 2d       	mov	r28, r9
	}
	
	return controlValueToAdjust;
}
     782:	6a 2d       	mov	r22, r10
     784:	7b 2d       	mov	r23, r11
     786:	8d 2f       	mov	r24, r29
     788:	9c 2f       	mov	r25, r28
     78a:	df 91       	pop	r29
     78c:	cf 91       	pop	r28
     78e:	1f 91       	pop	r17
     790:	0f 91       	pop	r16
     792:	ff 90       	pop	r15
     794:	ef 90       	pop	r14
     796:	df 90       	pop	r13
     798:	cf 90       	pop	r12
     79a:	bf 90       	pop	r11
     79c:	af 90       	pop	r10
     79e:	9f 90       	pop	r9
     7a0:	8f 90       	pop	r8
     7a2:	08 95       	ret

000007a4 <_Z30calculateInnerLoopControlValuefffff>:


float calculateInnerLoopControlValue( float outerLoopSetpoint, float measuredValue, float gain, float angularVelocity, float angularVelocityGain )
{
     7a4:	4f 92       	push	r4
     7a6:	5f 92       	push	r5
     7a8:	6f 92       	push	r6
     7aa:	7f 92       	push	r7
     7ac:	af 92       	push	r10
     7ae:	bf 92       	push	r11
     7b0:	cf 92       	push	r12
     7b2:	df 92       	push	r13
     7b4:	ef 92       	push	r14
     7b6:	ff 92       	push	r15
     7b8:	0f 93       	push	r16
     7ba:	1f 93       	push	r17
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	cd b7       	in	r28, 0x3d	; 61
     7c2:	de b7       	in	r29, 0x3e	; 62
	return (gain * (outerLoopSetpoint - measuredValue)) - (angularVelocity * angularVelocityGain);
     7c4:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     7c8:	a8 01       	movw	r20, r16
     7ca:	97 01       	movw	r18, r14
     7cc:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     7d0:	2b 01       	movw	r4, r22
     7d2:	3c 01       	movw	r6, r24
     7d4:	2a 89       	ldd	r18, Y+18	; 0x12
     7d6:	3b 89       	ldd	r19, Y+19	; 0x13
     7d8:	4c 89       	ldd	r20, Y+20	; 0x14
     7da:	5d 89       	ldd	r21, Y+21	; 0x15
     7dc:	c6 01       	movw	r24, r12
     7de:	b5 01       	movw	r22, r10
     7e0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     7e4:	9b 01       	movw	r18, r22
     7e6:	ac 01       	movw	r20, r24
     7e8:	c3 01       	movw	r24, r6
     7ea:	b2 01       	movw	r22, r4
     7ec:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
	//float workingSetpoint = gain * (outerLoopSetpoint - measuredValue);
	//float multiplier = workingSetpoint < 0 ? -1.0f : 1.0f;
	//
	////Subtract the abs values to ensure that one always 'subtracts' from the other.
	//return multiplier * (fabs(workingSetpoint) - fabs(angularVelocity*angularVelocityGain));
}
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	1f 91       	pop	r17
     7f6:	0f 91       	pop	r16
     7f8:	ff 90       	pop	r15
     7fa:	ef 90       	pop	r14
     7fc:	df 90       	pop	r13
     7fe:	cf 90       	pop	r12
     800:	bf 90       	pop	r11
     802:	af 90       	pop	r10
     804:	7f 90       	pop	r7
     806:	6f 90       	pop	r6
     808:	5f 90       	pop	r5
     80a:	4f 90       	pop	r4
     80c:	08 95       	ret

0000080e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>:


float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
     80e:	8f 92       	push	r8
     810:	9f 92       	push	r9
     812:	af 92       	push	r10
     814:	bf 92       	push	r11
     816:	cf 92       	push	r12
     818:	df 92       	push	r13
     81a:	ef 92       	push	r14
     81c:	ff 92       	push	r15
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	cf 93       	push	r28
     824:	df 93       	push	r29
     826:	a4 2e       	mov	r10, r20
     828:	b5 2e       	mov	r11, r21
     82a:	d6 2f       	mov	r29, r22
     82c:	c7 2f       	mov	r28, r23
     82e:	82 2e       	mov	r8, r18
     830:	93 2e       	mov	r9, r19
	if (outerLoopControlSetpoint < minSetpointLimitRads)
     832:	20 2f       	mov	r18, r16
     834:	31 2f       	mov	r19, r17
     836:	48 2d       	mov	r20, r8
     838:	59 2d       	mov	r21, r9
     83a:	6a 2d       	mov	r22, r10
     83c:	7b 2d       	mov	r23, r11
     83e:	8d 2f       	mov	r24, r29
     840:	9c 2f       	mov	r25, r28
     842:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
     846:	88 23       	and	r24, r24
     848:	6c f0       	brlt	.+26     	; 0x864 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x56>
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
     84a:	2c 2d       	mov	r18, r12
     84c:	3d 2d       	mov	r19, r13
     84e:	4e 2d       	mov	r20, r14
     850:	5f 2d       	mov	r21, r15
     852:	6a 2d       	mov	r22, r10
     854:	7b 2d       	mov	r23, r11
     856:	8d 2f       	mov	r24, r29
     858:	9c 2f       	mov	r25, r28
     85a:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
     85e:	18 16       	cp	r1, r24
     860:	34 f0       	brlt	.+12     	; 0x86e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x60>
     862:	09 c0       	rjmp	.+18     	; 0x876 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x68>

float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
	if (outerLoopControlSetpoint < minSetpointLimitRads)
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
     864:	a0 2e       	mov	r10, r16
     866:	b1 2e       	mov	r11, r17
     868:	d8 2d       	mov	r29, r8
     86a:	c9 2d       	mov	r28, r9
     86c:	04 c0       	rjmp	.+8      	; 0x876 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x68>
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
	{
		outerLoopControlSetpoint = maxSetpointLimitRads;
     86e:	ac 2c       	mov	r10, r12
     870:	bd 2c       	mov	r11, r13
     872:	de 2d       	mov	r29, r14
     874:	cf 2d       	mov	r28, r15
	}
	
	return outerLoopControlSetpoint;
}
     876:	6a 2d       	mov	r22, r10
     878:	7b 2d       	mov	r23, r11
     87a:	8d 2f       	mov	r24, r29
     87c:	9c 2f       	mov	r25, r28
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	ff 90       	pop	r15
     888:	ef 90       	pop	r14
     88a:	df 90       	pop	r13
     88c:	cf 90       	pop	r12
     88e:	bf 90       	pop	r11
     890:	af 90       	pop	r10
     892:	9f 90       	pop	r9
     894:	8f 90       	pop	r8
     896:	08 95       	ret

00000898 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>:


//TODO WTF IS THIS DOING HERE?? THIS IS THE WRONG CONTROLLER!!
void PIDController::addBlownFrame()
{
	model->BlownFrames(model->BlownFrames() + 1);
     898:	dc 01       	movw	r26, r24
     89a:	ed 91       	ld	r30, X+
     89c:	fc 91       	ld	r31, X
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
     89e:	ea 54       	subi	r30, 0x4A	; 74
     8a0:	ff 4f       	sbci	r31, 0xFF	; 255
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	a2 81       	ldd	r26, Z+2	; 0x02
     8a8:	b3 81       	ldd	r27, Z+3	; 0x03
     8aa:	01 96       	adiw	r24, 0x01	; 1
     8ac:	a1 1d       	adc	r26, r1
     8ae:	b1 1d       	adc	r27, r1
     8b0:	80 83       	st	Z, r24
     8b2:	91 83       	std	Z+1, r25	; 0x01
     8b4:	a2 83       	std	Z+2, r26	; 0x02
     8b6:	b3 83       	std	Z+3, r27	; 0x03
     8b8:	08 95       	ret

000008ba <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>:
	}
}


void PIDController::tailRotorCollectiveOuterLoopUpdate()
{
     8ba:	2f 92       	push	r2
     8bc:	3f 92       	push	r3
     8be:	4f 92       	push	r4
     8c0:	5f 92       	push	r5
     8c2:	6f 92       	push	r6
     8c4:	7f 92       	push	r7
     8c6:	8f 92       	push	r8
     8c8:	9f 92       	push	r9
     8ca:	af 92       	push	r10
     8cc:	bf 92       	push	r11
     8ce:	cf 92       	push	r12
     8d0:	df 92       	push	r13
     8d2:	ef 92       	push	r14
     8d4:	ff 92       	push	r15
     8d6:	0f 93       	push	r16
     8d8:	1f 93       	push	r17
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	cd b7       	in	r28, 0x3d	; 61
     8e0:	de b7       	in	r29, 0x3e	; 62
     8e2:	2a 97       	sbiw	r28, 0x0a	; 10
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	de bf       	out	0x3e, r29	; 62
     8ea:	0f be       	out	0x3f, r0	; 63
     8ec:	cd bf       	out	0x3d, r28	; 61
     8ee:	9a 87       	std	Y+10, r25	; 0x0a
     8f0:	89 87       	std	Y+9, r24	; 0x09
	float yawProportional = calculateProportional(model->YawRads(), model->ReferenceMagYawRads());
     8f2:	dc 01       	movw	r26, r24
     8f4:	2d 90       	ld	r2, X+
     8f6:	3c 90       	ld	r3, X
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
     8f8:	f1 01       	movw	r30, r2
     8fa:	ea 52       	subi	r30, 0x2A	; 42
     8fc:	ff 4f       	sbci	r31, 0xFF	; 255
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
     8fe:	d1 01       	movw	r26, r2
     900:	16 96       	adiw	r26, 0x06	; 6
     902:	2d 91       	ld	r18, X+
     904:	3d 91       	ld	r19, X+
     906:	4d 91       	ld	r20, X+
     908:	5c 91       	ld	r21, X
     90a:	19 97       	sbiw	r26, 0x09	; 9
     90c:	60 81       	ld	r22, Z
     90e:	71 81       	ldd	r23, Z+1	; 0x01
     910:	82 81       	ldd	r24, Z+2	; 0x02
     912:	93 81       	ldd	r25, Z+3	; 0x03
     914:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     918:	e6 2e       	mov	r14, r22
     91a:	f7 2e       	mov	r15, r23
     91c:	08 2f       	mov	r16, r24
     91e:	19 2f       	mov	r17, r25
     920:	46 2e       	mov	r4, r22
     922:	57 2e       	mov	r5, r23
     924:	68 2e       	mov	r6, r24
     926:	79 2e       	mov	r7, r25
				/**
				 * Converts the error from 0-360, to -180 - 180 (in the equivalent of rads - i.e. yawError should be rads).
				 */
				inline float convertYawErrorFrom2PitoPlusMinusPi( float  yawErrorRads )
				{
					if (yawErrorRads >= M_PI)
     928:	2b ed       	ldi	r18, 0xDB	; 219
     92a:	3f e0       	ldi	r19, 0x0F	; 15
     92c:	49 e4       	ldi	r20, 0x49	; 73
     92e:	50 e4       	ldi	r21, 0x40	; 64
     930:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
     934:	88 23       	and	r24, r24
     936:	7c f0       	brlt	.+30     	; 0x956 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x9c>
					{
						yawErrorRads = yawErrorRads - (2 * M_PI);
     938:	2b ed       	ldi	r18, 0xDB	; 219
     93a:	3f e0       	ldi	r19, 0x0F	; 15
     93c:	49 ec       	ldi	r20, 0xC9	; 201
     93e:	50 e4       	ldi	r21, 0x40	; 64
     940:	6e 2d       	mov	r22, r14
     942:	7f 2d       	mov	r23, r15
     944:	80 2f       	mov	r24, r16
     946:	91 2f       	mov	r25, r17
     948:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     94c:	46 2e       	mov	r4, r22
     94e:	57 2e       	mov	r5, r23
     950:	68 2e       	mov	r6, r24
     952:	79 2e       	mov	r7, r25
     954:	1a c0       	rjmp	.+52     	; 0x98a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xd0>
					}
					else if (yawErrorRads < -M_PI)
     956:	2b ed       	ldi	r18, 0xDB	; 219
     958:	3f e0       	ldi	r19, 0x0F	; 15
     95a:	49 e4       	ldi	r20, 0x49	; 73
     95c:	50 ec       	ldi	r21, 0xC0	; 192
     95e:	6e 2d       	mov	r22, r14
     960:	7f 2d       	mov	r23, r15
     962:	80 2f       	mov	r24, r16
     964:	91 2f       	mov	r25, r17
     966:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
     96a:	88 23       	and	r24, r24
     96c:	74 f4       	brge	.+28     	; 0x98a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xd0>
					{
						yawErrorRads = yawErrorRads + (2 * M_PI);
     96e:	2b ed       	ldi	r18, 0xDB	; 219
     970:	3f e0       	ldi	r19, 0x0F	; 15
     972:	49 ec       	ldi	r20, 0xC9	; 201
     974:	50 e4       	ldi	r21, 0x40	; 64
     976:	6e 2d       	mov	r22, r14
     978:	7f 2d       	mov	r23, r15
     97a:	80 2f       	mov	r24, r16
     97c:	91 2f       	mov	r25, r17
     97e:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     982:	46 2e       	mov	r4, r22
     984:	57 2e       	mov	r5, r23
     986:	68 2e       	mov	r6, r24
     988:	79 2e       	mov	r7, r25
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     98a:	f1 01       	movw	r30, r2
     98c:	26 85       	ldd	r18, Z+14	; 0x0e
     98e:	37 85       	ldd	r19, Z+15	; 0x0f
     990:	40 89       	ldd	r20, Z+16	; 0x10
     992:	51 89       	ldd	r21, Z+17	; 0x11
     994:	62 85       	ldd	r22, Z+10	; 0x0a
     996:	73 85       	ldd	r23, Z+11	; 0x0b
     998:	84 85       	ldd	r24, Z+12	; 0x0c
     99a:	95 85       	ldd	r25, Z+13	; 0x0d
     99c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     9a0:	a9 85       	ldd	r26, Y+9	; 0x09
     9a2:	ba 85       	ldd	r27, Y+10	; 0x0a
     9a4:	1e 96       	adiw	r26, 0x0e	; 14
     9a6:	2d 91       	ld	r18, X+
     9a8:	3d 91       	ld	r19, X+
     9aa:	4d 91       	ld	r20, X+
     9ac:	5c 91       	ld	r21, X
     9ae:	51 97       	sbiw	r26, 0x11	; 17
     9b0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     9b4:	6b 01       	movw	r12, r22
     9b6:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     9b8:	e9 85       	ldd	r30, Y+9	; 0x09
     9ba:	fa 85       	ldd	r31, Y+10	; 0x0a
     9bc:	22 81       	ldd	r18, Z+2	; 0x02
     9be:	33 81       	ldd	r19, Z+3	; 0x03
     9c0:	44 81       	ldd	r20, Z+4	; 0x04
     9c2:	55 81       	ldd	r21, Z+5	; 0x05
     9c4:	64 2d       	mov	r22, r4
     9c6:	75 2d       	mov	r23, r5
     9c8:	86 2d       	mov	r24, r6
     9ca:	97 2d       	mov	r25, r7
     9cc:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     9d0:	9b 01       	movw	r18, r22
     9d2:	ac 01       	movw	r20, r24
     9d4:	c7 01       	movw	r24, r14
     9d6:	b6 01       	movw	r22, r12
     9d8:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     9dc:	e9 85       	ldd	r30, Y+9	; 0x09
     9de:	fa 85       	ldd	r31, Y+10	; 0x0a
     9e0:	ee 57       	subi	r30, 0x7E	; 126
     9e2:	ff 4f       	sbci	r31, 0xFF	; 255
     9e4:	20 81       	ld	r18, Z
     9e6:	31 81       	ldd	r19, Z+1	; 0x01
     9e8:	42 81       	ldd	r20, Z+2	; 0x02
     9ea:	53 81       	ldd	r21, Z+3	; 0x03
     9ec:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     9f0:	d1 01       	movw	r26, r2
     9f2:	56 96       	adiw	r26, 0x16	; 22
     9f4:	2d 91       	ld	r18, X+
     9f6:	3d 91       	ld	r19, X+
     9f8:	4d 91       	ld	r20, X+
     9fa:	5c 91       	ld	r21, X
     9fc:	59 97       	sbiw	r26, 0x19	; 25
     9fe:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     a02:	69 83       	std	Y+1, r22	; 0x01
     a04:	7a 83       	std	Y+2, r23	; 0x02
     a06:	8b 83       	std	Y+3, r24	; 0x03
     a08:	9c 83       	std	Y+4, r25	; 0x04
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
     a0a:	f1 01       	movw	r30, r2
     a0c:	ee 51       	subi	r30, 0x1E	; 30
     a0e:	ff 4f       	sbci	r31, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     a10:	d1 01       	movw	r26, r2
     a12:	52 96       	adiw	r26, 0x12	; 18
     a14:	2d 91       	ld	r18, X+
     a16:	3d 91       	ld	r19, X+
     a18:	4d 91       	ld	r20, X+
     a1a:	5c 91       	ld	r21, X
     a1c:	55 97       	sbiw	r26, 0x15	; 21
     a1e:	60 81       	ld	r22, Z
     a20:	71 81       	ldd	r23, Z+1	; 0x01
     a22:	82 81       	ldd	r24, Z+2	; 0x02
     a24:	93 81       	ldd	r25, Z+3	; 0x03
     a26:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     a2a:	6d 83       	std	Y+5, r22	; 0x05
     a2c:	7e 83       	std	Y+6, r23	; 0x06
     a2e:	8f 83       	std	Y+7, r24	; 0x07
     a30:	98 87       	std	Y+8, r25	; 0x08
	yawProportional = convertYawErrorFrom2PitoPlusMinusPi(yawProportional);
	
	float yawIntegralAntiWindup = calculateIntegralAntiWindup(model->YawControlBeforeServoLimitsAdjustment(), model->YawControl(), yawAntiWindupGain);
	float weightedYawIntegral = calculateIntegral(yawProportional, model->YawIntegral(), yawIntegralAntiWindup, yawIntegralGain);
	float yawDerivativeError = calculateVelocityError(model->YawAngularVelocityRadsPerSecond(), model->ReferenceYawVelocityRadsPerSecond());
	float yawControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(yawProportional, yawDerivativeError, weightedYawIntegral, yawProportionalGain, yawDerivativeGain, 1);
     a32:	e9 85       	ldd	r30, Y+9	; 0x09
     a34:	fa 85       	ldd	r31, Y+10	; 0x0a
     a36:	82 84       	ldd	r8, Z+10	; 0x0a
     a38:	93 84       	ldd	r9, Z+11	; 0x0b
     a3a:	a4 84       	ldd	r10, Z+12	; 0x0c
     a3c:	b5 84       	ldd	r11, Z+13	; 0x0d
     a3e:	1f 92       	push	r1
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	8f 93       	push	r24
     a44:	81 85       	ldd	r24, Z+9	; 0x09
     a46:	8f 93       	push	r24
     a48:	80 85       	ldd	r24, Z+8	; 0x08
     a4a:	8f 93       	push	r24
     a4c:	87 81       	ldd	r24, Z+7	; 0x07
     a4e:	8f 93       	push	r24
     a50:	86 81       	ldd	r24, Z+6	; 0x06
     a52:	8f 93       	push	r24
     a54:	39 81       	ldd	r19, Y+1	; 0x01
     a56:	2a 81       	ldd	r18, Y+2	; 0x02
     a58:	9b 81       	ldd	r25, Y+3	; 0x03
     a5a:	8c 81       	ldd	r24, Y+4	; 0x04
     a5c:	c3 2e       	mov	r12, r19
     a5e:	d2 2e       	mov	r13, r18
     a60:	e9 2e       	mov	r14, r25
     a62:	f8 2e       	mov	r15, r24
     a64:	5d 81       	ldd	r21, Y+5	; 0x05
     a66:	4e 81       	ldd	r20, Y+6	; 0x06
     a68:	9f 81       	ldd	r25, Y+7	; 0x07
     a6a:	88 85       	ldd	r24, Y+8	; 0x08
     a6c:	05 2f       	mov	r16, r21
     a6e:	14 2f       	mov	r17, r20
     a70:	29 2f       	mov	r18, r25
     a72:	38 2f       	mov	r19, r24
     a74:	44 2d       	mov	r20, r4
     a76:	55 2d       	mov	r21, r5
     a78:	66 2d       	mov	r22, r6
     a7a:	77 2d       	mov	r23, r7
     a7c:	89 85       	ldd	r24, Y+9	; 0x09
     a7e:	9a 85       	ldd	r25, Y+10	; 0x0a
     a80:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	0f 90       	pop	r0
     a8c:	0f 90       	pop	r0
     a8e:	0f 90       	pop	r0
     a90:	4b 01       	movw	r8, r22
     a92:	5c 01       	movw	r10, r24
	float yawControl = adjustControlForServoLimits(yawControlBeforeServoLimitsAdjustment, minYawServoControlValue, maxYawServoControlValue);
     a94:	e9 85       	ldd	r30, Y+9	; 0x09
     a96:	fa 85       	ldd	r31, Y+10	; 0x0a
     a98:	ea 5a       	subi	r30, 0xAA	; 170
     a9a:	ff 4f       	sbci	r31, 0xFF	; 255
     a9c:	c0 80       	ld	r12, Z
     a9e:	d1 80       	ldd	r13, Z+1	; 0x01
     aa0:	e2 80       	ldd	r14, Z+2	; 0x02
     aa2:	f3 80       	ldd	r15, Z+3	; 0x03
     aa4:	e9 85       	ldd	r30, Y+9	; 0x09
     aa6:	fa 85       	ldd	r31, Y+10	; 0x0a
     aa8:	ee 5a       	subi	r30, 0xAE	; 174
     aaa:	ff 4f       	sbci	r31, 0xFF	; 255
     aac:	00 81       	ld	r16, Z
     aae:	11 81       	ldd	r17, Z+1	; 0x01
     ab0:	22 81       	ldd	r18, Z+2	; 0x02
     ab2:	33 81       	ldd	r19, Z+3	; 0x03
     ab4:	ab 01       	movw	r20, r22
     ab6:	bc 01       	movw	r22, r24
     ab8:	89 85       	ldd	r24, Y+9	; 0x09
     aba:	9a 85       	ldd	r25, Y+10	; 0x0a
     abc:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
	
	//model->YawControl(yawControl);
	//Multiply by -1 because in the simulator, +1 results in counter clockwise yaw, but on the helicopter, it's a clockwise yaw. 
	model->YawControl(yawControl * -1);
     ac0:	dc 01       	movw	r26, r24
     ac2:	cb 01       	movw	r24, r22
     ac4:	b0 58       	subi	r27, 0x80	; 128
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
			void YawControl(float val) { yawControl = val;}
     ac6:	f1 01       	movw	r30, r2
     ac8:	82 87       	std	Z+10, r24	; 0x0a
     aca:	93 87       	std	Z+11, r25	; 0x0b
     acc:	a4 87       	std	Z+12, r26	; 0x0c
     ace:	b5 87       	std	Z+13, r27	; 0x0d
	model->YawControlBeforeServoLimitsAdjustment(yawControlBeforeServoLimitsAdjustment);
     ad0:	a9 85       	ldd	r26, Y+9	; 0x09
     ad2:	ba 85       	ldd	r27, Y+10	; 0x0a
     ad4:	ed 91       	ld	r30, X+
     ad6:	fc 91       	ld	r31, X
     ad8:	11 97       	sbiw	r26, 0x01	; 1
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
     ada:	86 86       	std	Z+14, r8	; 0x0e
     adc:	97 86       	std	Z+15, r9	; 0x0f
     ade:	a0 8a       	std	Z+16, r10	; 0x10
     ae0:	b1 8a       	std	Z+17, r11	; 0x11
	model->YawIntegral(weightedYawIntegral);
     ae2:	ed 91       	ld	r30, X+
     ae4:	fc 91       	ld	r31, X
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
			void YawIntegral(float val) { yawIntegral = val;}
     ae6:	59 81       	ldd	r21, Y+1	; 0x01
     ae8:	4a 81       	ldd	r20, Y+2	; 0x02
     aea:	3b 81       	ldd	r19, Y+3	; 0x03
     aec:	2c 81       	ldd	r18, Y+4	; 0x04
     aee:	85 2f       	mov	r24, r21
     af0:	94 2f       	mov	r25, r20
     af2:	a3 2f       	mov	r26, r19
     af4:	b2 2f       	mov	r27, r18
     af6:	86 8b       	std	Z+22, r24	; 0x16
     af8:	97 8b       	std	Z+23, r25	; 0x17
     afa:	a0 8f       	std	Z+24, r26	; 0x18
     afc:	b1 8f       	std	Z+25, r27	; 0x19
	model->YawProportional(yawProportional);
     afe:	a9 85       	ldd	r26, Y+9	; 0x09
     b00:	ba 85       	ldd	r27, Y+10	; 0x0a
     b02:	ed 91       	ld	r30, X+
     b04:	fc 91       	ld	r31, X

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}
     b06:	84 2d       	mov	r24, r4
     b08:	95 2d       	mov	r25, r5
     b0a:	a6 2d       	mov	r26, r6
     b0c:	b7 2d       	mov	r27, r7
     b0e:	82 8f       	std	Z+26, r24	; 0x1a
     b10:	93 8f       	std	Z+27, r25	; 0x1b
     b12:	a4 8f       	std	Z+28, r26	; 0x1c
     b14:	b5 8f       	std	Z+29, r27	; 0x1d
	model->YawDerivativeError(yawDerivativeError);
     b16:	a9 85       	ldd	r26, Y+9	; 0x09
     b18:	ba 85       	ldd	r27, Y+10	; 0x0a
     b1a:	ed 91       	ld	r30, X+
     b1c:	fc 91       	ld	r31, X

			float YawDerivativeError() const {return yawDerivativeError;}
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
     b1e:	5d 81       	ldd	r21, Y+5	; 0x05
     b20:	4e 81       	ldd	r20, Y+6	; 0x06
     b22:	3f 81       	ldd	r19, Y+7	; 0x07
     b24:	28 85       	ldd	r18, Y+8	; 0x08
     b26:	85 2f       	mov	r24, r21
     b28:	94 2f       	mov	r25, r20
     b2a:	a3 2f       	mov	r26, r19
     b2c:	b2 2f       	mov	r27, r18
     b2e:	86 8f       	std	Z+30, r24	; 0x1e
     b30:	97 8f       	std	Z+31, r25	; 0x1f
     b32:	a0 a3       	std	Z+32, r26	; 0x20
     b34:	b1 a3       	std	Z+33, r27	; 0x21
}
     b36:	2a 96       	adiw	r28, 0x0a	; 10
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	de bf       	out	0x3e, r29	; 62
     b3e:	0f be       	out	0x3f, r0	; 63
     b40:	cd bf       	out	0x3d, r28	; 61
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	1f 91       	pop	r17
     b48:	0f 91       	pop	r16
     b4a:	ff 90       	pop	r15
     b4c:	ef 90       	pop	r14
     b4e:	df 90       	pop	r13
     b50:	cf 90       	pop	r12
     b52:	bf 90       	pop	r11
     b54:	af 90       	pop	r10
     b56:	9f 90       	pop	r9
     b58:	8f 90       	pop	r8
     b5a:	7f 90       	pop	r7
     b5c:	6f 90       	pop	r6
     b5e:	5f 90       	pop	r5
     b60:	4f 90       	pop	r4
     b62:	3f 90       	pop	r3
     b64:	2f 90       	pop	r2
     b66:	08 95       	ret

00000b68 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>:

void PIDController::mainRotorCollectiveOuterLoopUpdate(float zProportional)
{
     b68:	2f 92       	push	r2
     b6a:	3f 92       	push	r3
     b6c:	4f 92       	push	r4
     b6e:	5f 92       	push	r5
     b70:	6f 92       	push	r6
     b72:	7f 92       	push	r7
     b74:	8f 92       	push	r8
     b76:	9f 92       	push	r9
     b78:	af 92       	push	r10
     b7a:	bf 92       	push	r11
     b7c:	cf 92       	push	r12
     b7e:	df 92       	push	r13
     b80:	ef 92       	push	r14
     b82:	ff 92       	push	r15
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	2a 97       	sbiw	r28, 0x0a	; 10
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	de bf       	out	0x3e, r29	; 62
     b98:	0f be       	out	0x3f, r0	; 63
     b9a:	cd bf       	out	0x3d, r28	; 61
     b9c:	9a 87       	std	Y+10, r25	; 0x0a
     b9e:	89 87       	std	Y+9, r24	; 0x09
     ba0:	2a 01       	movw	r4, r20
     ba2:	3b 01       	movw	r6, r22

	//float zProportional = calculateProportional(model->ZNEDLocalFrame(), model->ReferenceZNEDLocalFrameMeters());
	
	float zIntegralAntiWindup = calculateIntegralAntiWindup(model->MainRotorControlBeforeServoLimitsAdjustment(), model->MainRotorCollectiveControl(), zAntiWindupGain);
     ba4:	dc 01       	movw	r26, r24
     ba6:	0d 91       	ld	r16, X+
     ba8:	1c 91       	ld	r17, X
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
     baa:	78 01       	movw	r14, r16
     bac:	b6 e9       	ldi	r27, 0x96	; 150
     bae:	eb 0e       	add	r14, r27
     bb0:	f1 1c       	adc	r15, r1
     bb2:	6c 01       	movw	r12, r24
     bb4:	ee e4       	ldi	r30, 0x4E	; 78
     bb6:	ce 0e       	add	r12, r30
     bb8:	d1 1c       	adc	r13, r1

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
     bba:	c8 01       	movw	r24, r16
     bbc:	8a 57       	subi	r24, 0x7A	; 122
     bbe:	9f 4f       	sbci	r25, 0xFF	; 255
     bc0:	9a 83       	std	Y+2, r25	; 0x02
     bc2:	89 83       	std	Y+1, r24	; 0x01
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
     bc4:	f8 01       	movw	r30, r16
     bc6:	e6 57       	subi	r30, 0x76	; 118
     bc8:	ff 4f       	sbci	r31, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     bca:	20 81       	ld	r18, Z
     bcc:	31 81       	ldd	r19, Z+1	; 0x01
     bce:	42 81       	ldd	r20, Z+2	; 0x02
     bd0:	53 81       	ldd	r21, Z+3	; 0x03
     bd2:	dc 01       	movw	r26, r24
     bd4:	6d 91       	ld	r22, X+
     bd6:	7d 91       	ld	r23, X+
     bd8:	8d 91       	ld	r24, X+
     bda:	9c 91       	ld	r25, X
     bdc:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     be0:	f6 01       	movw	r30, r12
     be2:	20 81       	ld	r18, Z
     be4:	31 81       	ldd	r19, Z+1	; 0x01
     be6:	42 81       	ldd	r20, Z+2	; 0x02
     be8:	53 81       	ldd	r21, Z+3	; 0x03
     bea:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     bee:	4b 01       	movw	r8, r22
     bf0:	5c 01       	movw	r10, r24
	float weightedZIntegral = calculateIntegral(zProportional, model->ZIntegral(), zIntegralAntiWindup, zIntegralGain);
     bf2:	e9 85       	ldd	r30, Y+9	; 0x09
     bf4:	fa 85       	ldd	r31, Y+10	; 0x0a
     bf6:	ee 5b       	subi	r30, 0xBE	; 190
     bf8:	ff 4f       	sbci	r31, 0xFF	; 255
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     bfa:	20 81       	ld	r18, Z
     bfc:	31 81       	ldd	r19, Z+1	; 0x01
     bfe:	42 81       	ldd	r20, Z+2	; 0x02
     c00:	53 81       	ldd	r21, Z+3	; 0x03
     c02:	c3 01       	movw	r24, r6
     c04:	b2 01       	movw	r22, r4
     c06:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     c0a:	9b 01       	movw	r18, r22
     c0c:	ac 01       	movw	r20, r24
     c0e:	c5 01       	movw	r24, r10
     c10:	b4 01       	movw	r22, r8
     c12:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     c16:	e9 85       	ldd	r30, Y+9	; 0x09
     c18:	fa 85       	ldd	r31, Y+10	; 0x0a
     c1a:	ee 57       	subi	r30, 0x7E	; 126
     c1c:	ff 4f       	sbci	r31, 0xFF	; 255
     c1e:	20 81       	ld	r18, Z
     c20:	31 81       	ldd	r19, Z+1	; 0x01
     c22:	42 81       	ldd	r20, Z+2	; 0x02
     c24:	53 81       	ldd	r21, Z+3	; 0x03
     c26:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     c2a:	d7 01       	movw	r26, r14
     c2c:	2d 91       	ld	r18, X+
     c2e:	3d 91       	ld	r19, X+
     c30:	4d 91       	ld	r20, X+
     c32:	5c 91       	ld	r21, X
     c34:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     c38:	26 2e       	mov	r2, r22
     c3a:	37 2e       	mov	r3, r23
     c3c:	8b 83       	std	Y+3, r24	; 0x03
     c3e:	9c 83       	std	Y+4, r25	; 0x04
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
     c40:	f8 01       	movw	r30, r16
     c42:	e2 57       	subi	r30, 0x72	; 114
     c44:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
     c46:	d8 01       	movw	r26, r16
     c48:	ae 56       	subi	r26, 0x6E	; 110
     c4a:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     c4c:	2d 91       	ld	r18, X+
     c4e:	3d 91       	ld	r19, X+
     c50:	4d 91       	ld	r20, X+
     c52:	5c 91       	ld	r21, X
     c54:	60 81       	ld	r22, Z
     c56:	71 81       	ldd	r23, Z+1	; 0x01
     c58:	82 81       	ldd	r24, Z+2	; 0x02
     c5a:	93 81       	ldd	r25, Z+3	; 0x03
     c5c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     c60:	6d 83       	std	Y+5, r22	; 0x05
     c62:	7e 83       	std	Y+6, r23	; 0x06
     c64:	8f 83       	std	Y+7, r24	; 0x07
     c66:	98 87       	std	Y+8, r25	; 0x08
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
     c68:	e9 85       	ldd	r30, Y+9	; 0x09
     c6a:	fa 85       	ldd	r31, Y+10	; 0x0a
     c6c:	e6 5b       	subi	r30, 0xB6	; 182
     c6e:	ff 4f       	sbci	r31, 0xFF	; 255
     c70:	80 80       	ld	r8, Z
     c72:	91 80       	ldd	r9, Z+1	; 0x01
     c74:	a2 80       	ldd	r10, Z+2	; 0x02
     c76:	b3 80       	ldd	r11, Z+3	; 0x03
     c78:	1f 92       	push	r1
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	8f 93       	push	r24
     c7e:	e9 85       	ldd	r30, Y+9	; 0x09
     c80:	fa 85       	ldd	r31, Y+10	; 0x0a
     c82:	ea 5b       	subi	r30, 0xBA	; 186
     c84:	ff 4f       	sbci	r31, 0xFF	; 255
     c86:	83 81       	ldd	r24, Z+3	; 0x03
     c88:	8f 93       	push	r24
     c8a:	82 81       	ldd	r24, Z+2	; 0x02
     c8c:	8f 93       	push	r24
     c8e:	81 81       	ldd	r24, Z+1	; 0x01
     c90:	8f 93       	push	r24
     c92:	80 81       	ld	r24, Z
     c94:	8f 93       	push	r24
     c96:	9b 81       	ldd	r25, Y+3	; 0x03
     c98:	8c 81       	ldd	r24, Y+4	; 0x04
     c9a:	c2 2c       	mov	r12, r2
     c9c:	d3 2c       	mov	r13, r3
     c9e:	e9 2e       	mov	r14, r25
     ca0:	f8 2e       	mov	r15, r24
     ca2:	5d 81       	ldd	r21, Y+5	; 0x05
     ca4:	4e 81       	ldd	r20, Y+6	; 0x06
     ca6:	9f 81       	ldd	r25, Y+7	; 0x07
     ca8:	88 85       	ldd	r24, Y+8	; 0x08
     caa:	05 2f       	mov	r16, r21
     cac:	14 2f       	mov	r17, r20
     cae:	29 2f       	mov	r18, r25
     cb0:	38 2f       	mov	r19, r24
     cb2:	b3 01       	movw	r22, r6
     cb4:	a2 01       	movw	r20, r4
     cb6:	89 85       	ldd	r24, Y+9	; 0x09
     cb8:	9a 85       	ldd	r25, Y+10	; 0x0a
     cba:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     cbe:	0f 90       	pop	r0
     cc0:	0f 90       	pop	r0
     cc2:	0f 90       	pop	r0
     cc4:	0f 90       	pop	r0
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	4b 01       	movw	r8, r22
     ccc:	5c 01       	movw	r10, r24
	float mainRotorControl = adjustControlForServoLimits(mainRotorControlBeforeServoLimitsAdjustment, minMainRotorServoControlValue, maxMainRotorServoControlValue);
     cce:	e9 85       	ldd	r30, Y+9	; 0x09
     cd0:	fa 85       	ldd	r31, Y+10	; 0x0a
     cd2:	e2 59       	subi	r30, 0x92	; 146
     cd4:	ff 4f       	sbci	r31, 0xFF	; 255
     cd6:	c0 80       	ld	r12, Z
     cd8:	d1 80       	ldd	r13, Z+1	; 0x01
     cda:	e2 80       	ldd	r14, Z+2	; 0x02
     cdc:	f3 80       	ldd	r15, Z+3	; 0x03
     cde:	e9 85       	ldd	r30, Y+9	; 0x09
     ce0:	fa 85       	ldd	r31, Y+10	; 0x0a
     ce2:	e6 59       	subi	r30, 0x96	; 150
     ce4:	ff 4f       	sbci	r31, 0xFF	; 255
     ce6:	00 81       	ld	r16, Z
     ce8:	11 81       	ldd	r17, Z+1	; 0x01
     cea:	22 81       	ldd	r18, Z+2	; 0x02
     cec:	33 81       	ldd	r19, Z+3	; 0x03
     cee:	ab 01       	movw	r20, r22
     cf0:	bc 01       	movw	r22, r24
     cf2:	89 85       	ldd	r24, Y+9	; 0x09
     cf4:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf6:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}
     cfa:	e9 81       	ldd	r30, Y+1	; 0x01
     cfc:	fa 81       	ldd	r31, Y+2	; 0x02
     cfe:	60 83       	st	Z, r22
     d00:	71 83       	std	Z+1, r23	; 0x01
     d02:	82 83       	std	Z+2, r24	; 0x02
     d04:	93 83       	std	Z+3, r25	; 0x03
	
	model->MainRotorCollectiveControl(mainRotorControl);
	model->MainRotorControlBeforeServoLimitsAdjustment(mainRotorControlBeforeServoLimitsAdjustment);
     d06:	a9 85       	ldd	r26, Y+9	; 0x09
     d08:	ba 85       	ldd	r27, Y+10	; 0x0a
     d0a:	ed 91       	ld	r30, X+
     d0c:	fc 91       	ld	r31, X
     d0e:	11 97       	sbiw	r26, 0x01	; 1

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}
     d10:	e6 57       	subi	r30, 0x76	; 118
     d12:	ff 4f       	sbci	r31, 0xFF	; 255
     d14:	80 82       	st	Z, r8
     d16:	91 82       	std	Z+1, r9	; 0x01
     d18:	a2 82       	std	Z+2, r10	; 0x02
     d1a:	b3 82       	std	Z+3, r11	; 0x03
	model->ZIntegral(weightedZIntegral);
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
			void ZIntegral(float val) { zIntegral = val;}
     d20:	ea 56       	subi	r30, 0x6A	; 106
     d22:	ff 4f       	sbci	r31, 0xFF	; 255
     d24:	3b 81       	ldd	r19, Y+3	; 0x03
     d26:	2c 81       	ldd	r18, Y+4	; 0x04
     d28:	82 2d       	mov	r24, r2
     d2a:	93 2d       	mov	r25, r3
     d2c:	a3 2f       	mov	r26, r19
     d2e:	b2 2f       	mov	r27, r18
     d30:	80 83       	st	Z, r24
     d32:	91 83       	std	Z+1, r25	; 0x01
     d34:	a2 83       	std	Z+2, r26	; 0x02
     d36:	b3 83       	std	Z+3, r27	; 0x03
	model->ZProportional(zProportional);
     d38:	a9 85       	ldd	r26, Y+9	; 0x09
     d3a:	ba 85       	ldd	r27, Y+10	; 0x0a
     d3c:	ed 91       	ld	r30, X+
     d3e:	fc 91       	ld	r31, X
     d40:	11 97       	sbiw	r26, 0x01	; 1

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}
     d42:	e6 56       	subi	r30, 0x66	; 102
     d44:	ff 4f       	sbci	r31, 0xFF	; 255
     d46:	40 82       	st	Z, r4
     d48:	51 82       	std	Z+1, r5	; 0x01
     d4a:	62 82       	std	Z+2, r6	; 0x02
     d4c:	73 82       	std	Z+3, r7	; 0x03
	model->ZDerivativeError(zDerivativeError);
     d4e:	ed 91       	ld	r30, X+
     d50:	fc 91       	ld	r31, X

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
     d52:	e2 56       	subi	r30, 0x62	; 98
     d54:	ff 4f       	sbci	r31, 0xFF	; 255
     d56:	5d 81       	ldd	r21, Y+5	; 0x05
     d58:	4e 81       	ldd	r20, Y+6	; 0x06
     d5a:	3f 81       	ldd	r19, Y+7	; 0x07
     d5c:	28 85       	ldd	r18, Y+8	; 0x08
     d5e:	85 2f       	mov	r24, r21
     d60:	94 2f       	mov	r25, r20
     d62:	a3 2f       	mov	r26, r19
     d64:	b2 2f       	mov	r27, r18
     d66:	80 83       	st	Z, r24
     d68:	91 83       	std	Z+1, r25	; 0x01
     d6a:	a2 83       	std	Z+2, r26	; 0x02
     d6c:	b3 83       	std	Z+3, r27	; 0x03
}
     d6e:	2a 96       	adiw	r28, 0x0a	; 10
     d70:	0f b6       	in	r0, 0x3f	; 63
     d72:	f8 94       	cli
     d74:	de bf       	out	0x3e, r29	; 62
     d76:	0f be       	out	0x3f, r0	; 63
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	df 91       	pop	r29
     d7c:	cf 91       	pop	r28
     d7e:	1f 91       	pop	r17
     d80:	0f 91       	pop	r16
     d82:	ff 90       	pop	r15
     d84:	ef 90       	pop	r14
     d86:	df 90       	pop	r13
     d88:	cf 90       	pop	r12
     d8a:	bf 90       	pop	r11
     d8c:	af 90       	pop	r10
     d8e:	9f 90       	pop	r9
     d90:	8f 90       	pop	r8
     d92:	7f 90       	pop	r7
     d94:	6f 90       	pop	r6
     d96:	5f 90       	pop	r5
     d98:	4f 90       	pop	r4
     d9a:	3f 90       	pop	r3
     d9c:	2f 90       	pop	r2
     d9e:	08 95       	ret

00000da0 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>:

void PIDController::cyclicLongitudeOuterLoopUpdate(float xProportional)
{
     da0:	2f 92       	push	r2
     da2:	3f 92       	push	r3
     da4:	4f 92       	push	r4
     da6:	5f 92       	push	r5
     da8:	6f 92       	push	r6
     daa:	7f 92       	push	r7
     dac:	8f 92       	push	r8
     dae:	9f 92       	push	r9
     db0:	af 92       	push	r10
     db2:	bf 92       	push	r11
     db4:	cf 92       	push	r12
     db6:	df 92       	push	r13
     db8:	ef 92       	push	r14
     dba:	ff 92       	push	r15
     dbc:	0f 93       	push	r16
     dbe:	1f 93       	push	r17
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	cd b7       	in	r28, 0x3d	; 61
     dc6:	de b7       	in	r29, 0x3e	; 62
     dc8:	2a 97       	sbiw	r28, 0x0a	; 10
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	de bf       	out	0x3e, r29	; 62
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	cd bf       	out	0x3d, r28	; 61
     dd4:	9a 87       	std	Y+10, r25	; 0x0a
     dd6:	89 87       	std	Y+9, r24	; 0x09
     dd8:	2a 01       	movw	r4, r20
     dda:	3b 01       	movw	r6, r22
	//float xProportional = calculateProportional(model->XNEDLocalFrame(), model->ReferenceXNEDLocalFrame());
	float xIntegralAntiWindup = calculateIntegralAntiWindup(model->LongitudeControlBeforeServoLimitsAdjustment(), model->LongitudeControl(), xAntiWindupGain);
     ddc:	dc 01       	movw	r26, r24
     dde:	2d 90       	ld	r2, X+
     de0:	3c 90       	ld	r3, X
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
     de2:	81 01       	movw	r16, r2
     de4:	0e 5b       	subi	r16, 0xBE	; 190
     de6:	1f 4f       	sbci	r17, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     de8:	f1 01       	movw	r30, r2
     dea:	22 a5       	ldd	r18, Z+42	; 0x2a
     dec:	33 a5       	ldd	r19, Z+43	; 0x2b
     dee:	44 a5       	ldd	r20, Z+44	; 0x2c
     df0:	55 a5       	ldd	r21, Z+45	; 0x2d
     df2:	66 a5       	ldd	r22, Z+46	; 0x2e
     df4:	77 a5       	ldd	r23, Z+47	; 0x2f
     df6:	80 a9       	ldd	r24, Z+48	; 0x30
     df8:	91 a9       	ldd	r25, Z+49	; 0x31
     dfa:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     dfe:	a9 85       	ldd	r26, Y+9	; 0x09
     e00:	ba 85       	ldd	r27, Y+10	; 0x0a
     e02:	5e 96       	adiw	r26, 0x1e	; 30
     e04:	2d 91       	ld	r18, X+
     e06:	3d 91       	ld	r19, X+
     e08:	4d 91       	ld	r20, X+
     e0a:	5c 91       	ld	r21, X
     e0c:	91 97       	sbiw	r26, 0x21	; 33
     e0e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     e12:	6b 01       	movw	r12, r22
     e14:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     e16:	e9 85       	ldd	r30, Y+9	; 0x09
     e18:	fa 85       	ldd	r31, Y+10	; 0x0a
     e1a:	22 89       	ldd	r18, Z+18	; 0x12
     e1c:	33 89       	ldd	r19, Z+19	; 0x13
     e1e:	44 89       	ldd	r20, Z+20	; 0x14
     e20:	55 89       	ldd	r21, Z+21	; 0x15
     e22:	c3 01       	movw	r24, r6
     e24:	b2 01       	movw	r22, r4
     e26:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     e2a:	9b 01       	movw	r18, r22
     e2c:	ac 01       	movw	r20, r24
     e2e:	c7 01       	movw	r24, r14
     e30:	b6 01       	movw	r22, r12
     e32:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     e36:	e9 85       	ldd	r30, Y+9	; 0x09
     e38:	fa 85       	ldd	r31, Y+10	; 0x0a
     e3a:	ee 57       	subi	r30, 0x7E	; 126
     e3c:	ff 4f       	sbci	r31, 0xFF	; 255
     e3e:	20 81       	ld	r18, Z
     e40:	31 81       	ldd	r19, Z+1	; 0x01
     e42:	42 81       	ldd	r20, Z+2	; 0x02
     e44:	53 81       	ldd	r21, Z+3	; 0x03
     e46:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
     e4a:	d8 01       	movw	r26, r16
     e4c:	2d 91       	ld	r18, X+
     e4e:	3d 91       	ld	r19, X+
     e50:	4d 91       	ld	r20, X+
     e52:	5c 91       	ld	r21, X
     e54:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
     e58:	69 83       	std	Y+1, r22	; 0x01
     e5a:	7a 83       	std	Y+2, r23	; 0x02
     e5c:	8b 83       	std	Y+3, r24	; 0x03
     e5e:	9c 83       	std	Y+4, r25	; 0x04
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     e60:	f1 01       	movw	r30, r2
     e62:	26 a9       	ldd	r18, Z+54	; 0x36
     e64:	37 a9       	ldd	r19, Z+55	; 0x37
     e66:	40 ad       	ldd	r20, Z+56	; 0x38
     e68:	51 ad       	ldd	r21, Z+57	; 0x39
     e6a:	62 a9       	ldd	r22, Z+50	; 0x32
     e6c:	73 a9       	ldd	r23, Z+51	; 0x33
     e6e:	84 a9       	ldd	r24, Z+52	; 0x34
     e70:	95 a9       	ldd	r25, Z+53	; 0x35
     e72:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
     e76:	6d 83       	std	Y+5, r22	; 0x05
     e78:	7e 83       	std	Y+6, r23	; 0x06
     e7a:	8f 83       	std	Y+7, r24	; 0x07
     e7c:	98 87       	std	Y+8, r25	; 0x08
	float weightedXIntegral = calculateIntegral(xProportional, model->XIntegral(), xIntegralAntiWindup, xIntegralGain);
	float xDerivativeError = calculateVelocityError(model->XVelocityFRDCms(), model->ReferenceXVelocityCms());
	float xLongitudinalOuterLoopSetpoint = calculateOuterLoopControlValue(xProportional, xDerivativeError, weightedXIntegral, xProportionalGain, xDerivativeGain, 1);
     e7e:	a9 85       	ldd	r26, Y+9	; 0x09
     e80:	ba 85       	ldd	r27, Y+10	; 0x0a
     e82:	5a 96       	adiw	r26, 0x1a	; 26
     e84:	8d 90       	ld	r8, X+
     e86:	9d 90       	ld	r9, X+
     e88:	ad 90       	ld	r10, X+
     e8a:	bc 90       	ld	r11, X
     e8c:	5d 97       	sbiw	r26, 0x1d	; 29
     e8e:	1f 92       	push	r1
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	8f 93       	push	r24
     e94:	59 96       	adiw	r26, 0x19	; 25
     e96:	8c 91       	ld	r24, X
     e98:	59 97       	sbiw	r26, 0x19	; 25
     e9a:	8f 93       	push	r24
     e9c:	58 96       	adiw	r26, 0x18	; 24
     e9e:	8c 91       	ld	r24, X
     ea0:	58 97       	sbiw	r26, 0x18	; 24
     ea2:	8f 93       	push	r24
     ea4:	57 96       	adiw	r26, 0x17	; 23
     ea6:	8c 91       	ld	r24, X
     ea8:	57 97       	sbiw	r26, 0x17	; 23
     eaa:	8f 93       	push	r24
     eac:	56 96       	adiw	r26, 0x16	; 22
     eae:	8c 91       	ld	r24, X
     eb0:	8f 93       	push	r24
     eb2:	39 81       	ldd	r19, Y+1	; 0x01
     eb4:	2a 81       	ldd	r18, Y+2	; 0x02
     eb6:	9b 81       	ldd	r25, Y+3	; 0x03
     eb8:	8c 81       	ldd	r24, Y+4	; 0x04
     eba:	c3 2e       	mov	r12, r19
     ebc:	d2 2e       	mov	r13, r18
     ebe:	e9 2e       	mov	r14, r25
     ec0:	f8 2e       	mov	r15, r24
     ec2:	5d 81       	ldd	r21, Y+5	; 0x05
     ec4:	4e 81       	ldd	r20, Y+6	; 0x06
     ec6:	9f 81       	ldd	r25, Y+7	; 0x07
     ec8:	88 85       	ldd	r24, Y+8	; 0x08
     eca:	05 2f       	mov	r16, r21
     ecc:	14 2f       	mov	r17, r20
     ece:	29 2f       	mov	r18, r25
     ed0:	38 2f       	mov	r19, r24
     ed2:	b3 01       	movw	r22, r6
     ed4:	a2 01       	movw	r20, r4
     ed6:	89 85       	ldd	r24, Y+9	; 0x09
     ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
     eda:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     ede:	0f 90       	pop	r0
     ee0:	0f 90       	pop	r0
     ee2:	0f 90       	pop	r0
     ee4:	0f 90       	pop	r0
     ee6:	0f 90       	pop	r0
     ee8:	0f 90       	pop	r0
     eea:	ab 01       	movw	r20, r22
     eec:	bc 01       	movw	r22, r24

	
	
	xLongitudinalOuterLoopSetpoint = adjustForSetpointLimits(xLongitudinalOuterLoopSetpoint, minPitchSetpointRads, maxPitchSetpointRads);
     eee:	e9 85       	ldd	r30, Y+9	; 0x09
     ef0:	fa 85       	ldd	r31, Y+10	; 0x0a
     ef2:	ea 58       	subi	r30, 0x8A	; 138
     ef4:	ff 4f       	sbci	r31, 0xFF	; 255
     ef6:	c0 80       	ld	r12, Z
     ef8:	d1 80       	ldd	r13, Z+1	; 0x01
     efa:	e2 80       	ldd	r14, Z+2	; 0x02
     efc:	f3 80       	ldd	r15, Z+3	; 0x03
     efe:	e9 85       	ldd	r30, Y+9	; 0x09
     f00:	fa 85       	ldd	r31, Y+10	; 0x0a
     f02:	ee 58       	subi	r30, 0x8E	; 142
     f04:	ff 4f       	sbci	r31, 0xFF	; 255
     f06:	00 81       	ld	r16, Z
     f08:	11 81       	ldd	r17, Z+1	; 0x01
     f0a:	22 81       	ldd	r18, Z+2	; 0x02
     f0c:	33 81       	ldd	r19, Z+3	; 0x03
     f0e:	89 85       	ldd	r24, Y+9	; 0x09
     f10:	9a 85       	ldd	r25, Y+10	; 0x0a
     f12:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
     f16:	f1 01       	movw	r30, r2
     f18:	62 af       	std	Z+58, r22	; 0x3a
     f1a:	73 af       	std	Z+59, r23	; 0x3b
     f1c:	84 af       	std	Z+60, r24	; 0x3c
     f1e:	95 af       	std	Z+61, r25	; 0x3d

	model->XLongitudeOuterLoopSetpoint(xLongitudinalOuterLoopSetpoint);
	model->XIntegral(weightedXIntegral);
     f20:	a9 85       	ldd	r26, Y+9	; 0x09
     f22:	ba 85       	ldd	r27, Y+10	; 0x0a
     f24:	ed 91       	ld	r30, X+
     f26:	fc 91       	ld	r31, X
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
     f28:	ee 5b       	subi	r30, 0xBE	; 190
     f2a:	ff 4f       	sbci	r31, 0xFF	; 255
     f2c:	59 81       	ldd	r21, Y+1	; 0x01
     f2e:	4a 81       	ldd	r20, Y+2	; 0x02
     f30:	3b 81       	ldd	r19, Y+3	; 0x03
     f32:	2c 81       	ldd	r18, Y+4	; 0x04
     f34:	85 2f       	mov	r24, r21
     f36:	94 2f       	mov	r25, r20
     f38:	a3 2f       	mov	r26, r19
     f3a:	b2 2f       	mov	r27, r18
     f3c:	80 83       	st	Z, r24
     f3e:	91 83       	std	Z+1, r25	; 0x01
     f40:	a2 83       	std	Z+2, r26	; 0x02
     f42:	b3 83       	std	Z+3, r27	; 0x03
	model->XProportional(xProportional);
     f44:	a9 85       	ldd	r26, Y+9	; 0x09
     f46:	ba 85       	ldd	r27, Y+10	; 0x0a
     f48:	ed 91       	ld	r30, X+
     f4a:	fc 91       	ld	r31, X
     f4c:	11 97       	sbiw	r26, 0x01	; 1
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
     f4e:	fe 96       	adiw	r30, 0x3e	; 62
     f50:	40 82       	st	Z, r4
     f52:	51 82       	std	Z+1, r5	; 0x01
     f54:	62 82       	std	Z+2, r6	; 0x02
     f56:	73 82       	std	Z+3, r7	; 0x03
	model->XDerivativeError(xDerivativeError);
     f58:	ed 91       	ld	r30, X+
     f5a:	fc 91       	ld	r31, X
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
			void XDerivativeError(float val) { xDerivativeError = val;}
     f5c:	ea 5b       	subi	r30, 0xBA	; 186
     f5e:	ff 4f       	sbci	r31, 0xFF	; 255
     f60:	5d 81       	ldd	r21, Y+5	; 0x05
     f62:	4e 81       	ldd	r20, Y+6	; 0x06
     f64:	3f 81       	ldd	r19, Y+7	; 0x07
     f66:	28 85       	ldd	r18, Y+8	; 0x08
     f68:	85 2f       	mov	r24, r21
     f6a:	94 2f       	mov	r25, r20
     f6c:	a3 2f       	mov	r26, r19
     f6e:	b2 2f       	mov	r27, r18
     f70:	80 83       	st	Z, r24
     f72:	91 83       	std	Z+1, r25	; 0x01
     f74:	a2 83       	std	Z+2, r26	; 0x02
     f76:	b3 83       	std	Z+3, r27	; 0x03
}
     f78:	2a 96       	adiw	r28, 0x0a	; 10
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	de bf       	out	0x3e, r29	; 62
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	cd bf       	out	0x3d, r28	; 61
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	0f 91       	pop	r16
     f8c:	ff 90       	pop	r15
     f8e:	ef 90       	pop	r14
     f90:	df 90       	pop	r13
     f92:	cf 90       	pop	r12
     f94:	bf 90       	pop	r11
     f96:	af 90       	pop	r10
     f98:	9f 90       	pop	r9
     f9a:	8f 90       	pop	r8
     f9c:	7f 90       	pop	r7
     f9e:	6f 90       	pop	r6
     fa0:	5f 90       	pop	r5
     fa2:	4f 90       	pop	r4
     fa4:	3f 90       	pop	r3
     fa6:	2f 90       	pop	r2
     fa8:	08 95       	ret

00000faa <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>:

void PIDController::cyclicLateralOuterLoopUpdate(float yProportional)
{
     faa:	2f 92       	push	r2
     fac:	3f 92       	push	r3
     fae:	4f 92       	push	r4
     fb0:	5f 92       	push	r5
     fb2:	6f 92       	push	r6
     fb4:	7f 92       	push	r7
     fb6:	8f 92       	push	r8
     fb8:	9f 92       	push	r9
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
     fd2:	2a 97       	sbiw	r28, 0x0a	; 10
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	de bf       	out	0x3e, r29	; 62
     fda:	0f be       	out	0x3f, r0	; 63
     fdc:	cd bf       	out	0x3d, r28	; 61
     fde:	9a 87       	std	Y+10, r25	; 0x0a
     fe0:	89 87       	std	Y+9, r24	; 0x09
     fe2:	2a 01       	movw	r4, r20
     fe4:	3b 01       	movw	r6, r22
	//float yProportional = calculateProportional(model->YNEDLocalFrame(), model->ReferenceYNEDLocalFrame());
	float yIntegralAntiWindup = calculateIntegralAntiWindup(model->LateralControlBeforeServoLimitsAdjustment(), model->LateralControl(), yAntiWindupGain);
     fe6:	dc 01       	movw	r26, r24
     fe8:	2d 90       	ld	r2, X+
     fea:	3c 90       	ld	r3, X
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
     fec:	81 01       	movw	r16, r2
     fee:	02 59       	subi	r16, 0x92	; 146
     ff0:	1f 4f       	sbci	r17, 0xFF	; 255
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
     ff2:	f1 01       	movw	r30, r2
     ff4:	e6 5a       	subi	r30, 0xA6	; 166
     ff6:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
     ff8:	d1 01       	movw	r26, r2
     ffa:	aa 5a       	subi	r26, 0xAA	; 170
     ffc:	bf 4f       	sbci	r27, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     ffe:	2d 91       	ld	r18, X+
    1000:	3d 91       	ld	r19, X+
    1002:	4d 91       	ld	r20, X+
    1004:	5c 91       	ld	r21, X
    1006:	60 81       	ld	r22, Z
    1008:	71 81       	ldd	r23, Z+1	; 0x01
    100a:	82 81       	ldd	r24, Z+2	; 0x02
    100c:	93 81       	ldd	r25, Z+3	; 0x03
    100e:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    1012:	e9 85       	ldd	r30, Y+9	; 0x09
    1014:	fa 85       	ldd	r31, Y+10	; 0x0a
    1016:	26 a9       	ldd	r18, Z+54	; 0x36
    1018:	37 a9       	ldd	r19, Z+55	; 0x37
    101a:	40 ad       	ldd	r20, Z+56	; 0x38
    101c:	51 ad       	ldd	r21, Z+57	; 0x39
    101e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    1022:	6b 01       	movw	r12, r22
    1024:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
    1026:	a9 85       	ldd	r26, Y+9	; 0x09
    1028:	ba 85       	ldd	r27, Y+10	; 0x0a
    102a:	9a 96       	adiw	r26, 0x2a	; 42
    102c:	2d 91       	ld	r18, X+
    102e:	3d 91       	ld	r19, X+
    1030:	4d 91       	ld	r20, X+
    1032:	5c 91       	ld	r21, X
    1034:	9d 97       	sbiw	r26, 0x2d	; 45
    1036:	c3 01       	movw	r24, r6
    1038:	b2 01       	movw	r22, r4
    103a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    103e:	9b 01       	movw	r18, r22
    1040:	ac 01       	movw	r20, r24
    1042:	c7 01       	movw	r24, r14
    1044:	b6 01       	movw	r22, r12
    1046:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
    104a:	e9 85       	ldd	r30, Y+9	; 0x09
    104c:	fa 85       	ldd	r31, Y+10	; 0x0a
    104e:	ee 57       	subi	r30, 0x7E	; 126
    1050:	ff 4f       	sbci	r31, 0xFF	; 255
    1052:	20 81       	ld	r18, Z
    1054:	31 81       	ldd	r19, Z+1	; 0x01
    1056:	42 81       	ldd	r20, Z+2	; 0x02
    1058:	53 81       	ldd	r21, Z+3	; 0x03
    105a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    105e:	f8 01       	movw	r30, r16
    1060:	20 81       	ld	r18, Z
    1062:	31 81       	ldd	r19, Z+1	; 0x01
    1064:	42 81       	ldd	r20, Z+2	; 0x02
    1066:	53 81       	ldd	r21, Z+3	; 0x03
    1068:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    106c:	69 83       	std	Y+1, r22	; 0x01
    106e:	7a 83       	std	Y+2, r23	; 0x02
    1070:	8b 83       	std	Y+3, r24	; 0x03
    1072:	9c 83       	std	Y+4, r25	; 0x04
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    1074:	f1 01       	movw	r30, r2
    1076:	e2 5a       	subi	r30, 0xA2	; 162
    1078:	ff 4f       	sbci	r31, 0xFF	; 255
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
    107a:	d1 01       	movw	r26, r2
    107c:	ae 59       	subi	r26, 0x9E	; 158
    107e:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
    1080:	2d 91       	ld	r18, X+
    1082:	3d 91       	ld	r19, X+
    1084:	4d 91       	ld	r20, X+
    1086:	5c 91       	ld	r21, X
    1088:	60 81       	ld	r22, Z
    108a:	71 81       	ldd	r23, Z+1	; 0x01
    108c:	82 81       	ldd	r24, Z+2	; 0x02
    108e:	93 81       	ldd	r25, Z+3	; 0x03
    1090:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    1094:	6d 83       	std	Y+5, r22	; 0x05
    1096:	7e 83       	std	Y+6, r23	; 0x06
    1098:	8f 83       	std	Y+7, r24	; 0x07
    109a:	98 87       	std	Y+8, r25	; 0x08
	//we use a -1 direction factor because unlike other controls, if we have a positive proportional error, we actually need a 'negative' desired 
	//roll setpoint in order for the helicopter to track back towards the desired position. So if the helicopter is directly 'east' of the desired position,
	//the proportional error will correctly be positive (in a North-east-down coordinate system), but the helicopter will have to roll counter clockwise
	//to return to the desired position. This differs from if the helicopter was directly north of the desired position. The x proportional would be positive
	//(in NED), but it would take a positive pitch angle setpoint to get the helicopter to return to the desired position.
	float yLateralOuterLoopSetpoint = calculateOuterLoopControlValue(yProportional, yDerivativeError, weightedYIntegral, yProportionalGain, yDerivativeGain, -1);
    109c:	a9 85       	ldd	r26, Y+9	; 0x09
    109e:	ba 85       	ldd	r27, Y+10	; 0x0a
    10a0:	d2 96       	adiw	r26, 0x32	; 50
    10a2:	8d 90       	ld	r8, X+
    10a4:	9d 90       	ld	r9, X+
    10a6:	ad 90       	ld	r10, X+
    10a8:	bc 90       	ld	r11, X
    10aa:	d5 97       	sbiw	r26, 0x35	; 53
    10ac:	8f ef       	ldi	r24, 0xFF	; 255
    10ae:	8f 93       	push	r24
    10b0:	8f 93       	push	r24
    10b2:	d1 96       	adiw	r26, 0x31	; 49
    10b4:	8c 91       	ld	r24, X
    10b6:	d1 97       	sbiw	r26, 0x31	; 49
    10b8:	8f 93       	push	r24
    10ba:	d0 96       	adiw	r26, 0x30	; 48
    10bc:	8c 91       	ld	r24, X
    10be:	d0 97       	sbiw	r26, 0x30	; 48
    10c0:	8f 93       	push	r24
    10c2:	9f 96       	adiw	r26, 0x2f	; 47
    10c4:	8c 91       	ld	r24, X
    10c6:	9f 97       	sbiw	r26, 0x2f	; 47
    10c8:	8f 93       	push	r24
    10ca:	9e 96       	adiw	r26, 0x2e	; 46
    10cc:	8c 91       	ld	r24, X
    10ce:	8f 93       	push	r24
    10d0:	39 81       	ldd	r19, Y+1	; 0x01
    10d2:	2a 81       	ldd	r18, Y+2	; 0x02
    10d4:	9b 81       	ldd	r25, Y+3	; 0x03
    10d6:	8c 81       	ldd	r24, Y+4	; 0x04
    10d8:	c3 2e       	mov	r12, r19
    10da:	d2 2e       	mov	r13, r18
    10dc:	e9 2e       	mov	r14, r25
    10de:	f8 2e       	mov	r15, r24
    10e0:	5d 81       	ldd	r21, Y+5	; 0x05
    10e2:	4e 81       	ldd	r20, Y+6	; 0x06
    10e4:	9f 81       	ldd	r25, Y+7	; 0x07
    10e6:	88 85       	ldd	r24, Y+8	; 0x08
    10e8:	05 2f       	mov	r16, r21
    10ea:	14 2f       	mov	r17, r20
    10ec:	29 2f       	mov	r18, r25
    10ee:	38 2f       	mov	r19, r24
    10f0:	b3 01       	movw	r22, r6
    10f2:	a2 01       	movw	r20, r4
    10f4:	89 85       	ldd	r24, Y+9	; 0x09
    10f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f8:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
    10fc:	0f 90       	pop	r0
    10fe:	0f 90       	pop	r0
    1100:	0f 90       	pop	r0
    1102:	0f 90       	pop	r0
    1104:	0f 90       	pop	r0
    1106:	0f 90       	pop	r0
    1108:	ab 01       	movw	r20, r22
    110a:	bc 01       	movw	r22, r24

	yLateralOuterLoopSetpoint = adjustForSetpointLimits(yLateralOuterLoopSetpoint, minRollSetpointRads, maxRollSetpointRads);
    110c:	e9 85       	ldd	r30, Y+9	; 0x09
    110e:	fa 85       	ldd	r31, Y+10	; 0x0a
    1110:	e2 58       	subi	r30, 0x82	; 130
    1112:	ff 4f       	sbci	r31, 0xFF	; 255
    1114:	c0 80       	ld	r12, Z
    1116:	d1 80       	ldd	r13, Z+1	; 0x01
    1118:	e2 80       	ldd	r14, Z+2	; 0x02
    111a:	f3 80       	ldd	r15, Z+3	; 0x03
    111c:	e9 85       	ldd	r30, Y+9	; 0x09
    111e:	fa 85       	ldd	r31, Y+10	; 0x0a
    1120:	e6 58       	subi	r30, 0x86	; 134
    1122:	ff 4f       	sbci	r31, 0xFF	; 255
    1124:	00 81       	ld	r16, Z
    1126:	11 81       	ldd	r17, Z+1	; 0x01
    1128:	22 81       	ldd	r18, Z+2	; 0x02
    112a:	33 81       	ldd	r19, Z+3	; 0x03
    112c:	89 85       	ldd	r24, Y+9	; 0x09
    112e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1130:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}
    1134:	f1 01       	movw	r30, r2
    1136:	ea 59       	subi	r30, 0x9A	; 154
    1138:	ff 4f       	sbci	r31, 0xFF	; 255
    113a:	60 83       	st	Z, r22
    113c:	71 83       	std	Z+1, r23	; 0x01
    113e:	82 83       	std	Z+2, r24	; 0x02
    1140:	93 83       	std	Z+3, r25	; 0x03
	
	model->YLateralOuterLoopSetpoint(yLateralOuterLoopSetpoint);
	model->YIntegral(weightedYIntegral);
    1142:	a9 85       	ldd	r26, Y+9	; 0x09
    1144:	ba 85       	ldd	r27, Y+10	; 0x0a
    1146:	ed 91       	ld	r30, X+
    1148:	fc 91       	ld	r31, X

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}
    114a:	e2 59       	subi	r30, 0x92	; 146
    114c:	ff 4f       	sbci	r31, 0xFF	; 255
    114e:	59 81       	ldd	r21, Y+1	; 0x01
    1150:	4a 81       	ldd	r20, Y+2	; 0x02
    1152:	3b 81       	ldd	r19, Y+3	; 0x03
    1154:	2c 81       	ldd	r18, Y+4	; 0x04
    1156:	85 2f       	mov	r24, r21
    1158:	94 2f       	mov	r25, r20
    115a:	a3 2f       	mov	r26, r19
    115c:	b2 2f       	mov	r27, r18
    115e:	80 83       	st	Z, r24
    1160:	91 83       	std	Z+1, r25	; 0x01
    1162:	a2 83       	std	Z+2, r26	; 0x02
    1164:	b3 83       	std	Z+3, r27	; 0x03
	model->YProportional(yProportional);
    1166:	a9 85       	ldd	r26, Y+9	; 0x09
    1168:	ba 85       	ldd	r27, Y+10	; 0x0a
    116a:	ed 91       	ld	r30, X+
    116c:	fc 91       	ld	r31, X
    116e:	11 97       	sbiw	r26, 0x01	; 1

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}
    1170:	e6 59       	subi	r30, 0x96	; 150
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	40 82       	st	Z, r4
    1176:	51 82       	std	Z+1, r5	; 0x01
    1178:	62 82       	std	Z+2, r6	; 0x02
    117a:	73 82       	std	Z+3, r7	; 0x03
	model->YDerivativeError(yDerivativeError);
    117c:	ed 91       	ld	r30, X+
    117e:	fc 91       	ld	r31, X

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
			void YDerivativeError(float val) { yDerivativeError = val;}
    1180:	ee 58       	subi	r30, 0x8E	; 142
    1182:	ff 4f       	sbci	r31, 0xFF	; 255
    1184:	5d 81       	ldd	r21, Y+5	; 0x05
    1186:	4e 81       	ldd	r20, Y+6	; 0x06
    1188:	3f 81       	ldd	r19, Y+7	; 0x07
    118a:	28 85       	ldd	r18, Y+8	; 0x08
    118c:	85 2f       	mov	r24, r21
    118e:	94 2f       	mov	r25, r20
    1190:	a3 2f       	mov	r26, r19
    1192:	b2 2f       	mov	r27, r18
    1194:	80 83       	st	Z, r24
    1196:	91 83       	std	Z+1, r25	; 0x01
    1198:	a2 83       	std	Z+2, r26	; 0x02
    119a:	b3 83       	std	Z+3, r27	; 0x03
}
    119c:	2a 96       	adiw	r28, 0x0a	; 10
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	df 91       	pop	r29
    11aa:	cf 91       	pop	r28
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	df 90       	pop	r13
    11b6:	cf 90       	pop	r12
    11b8:	bf 90       	pop	r11
    11ba:	af 90       	pop	r10
    11bc:	9f 90       	pop	r9
    11be:	8f 90       	pop	r8
    11c0:	7f 90       	pop	r7
    11c2:	6f 90       	pop	r6
    11c4:	5f 90       	pop	r5
    11c6:	4f 90       	pop	r4
    11c8:	3f 90       	pop	r3
    11ca:	2f 90       	pop	r2
    11cc:	08 95       	ret

000011ce <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>:




void PIDController::outerLoopUpdate()
{
    11ce:	2f 92       	push	r2
    11d0:	3f 92       	push	r3
    11d2:	4f 92       	push	r4
    11d4:	5f 92       	push	r5
    11d6:	6f 92       	push	r6
    11d8:	7f 92       	push	r7
    11da:	8f 92       	push	r8
    11dc:	9f 92       	push	r9
    11de:	af 92       	push	r10
    11e0:	bf 92       	push	r11
    11e2:	cf 92       	push	r12
    11e4:	df 92       	push	r13
    11e6:	ef 92       	push	r14
    11e8:	ff 92       	push	r15
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	cd b7       	in	r28, 0x3d	; 61
    11f4:	de b7       	in	r29, 0x3e	; 62
    11f6:	68 97       	sbiw	r28, 0x18	; 24
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	cd bf       	out	0x3d, r28	; 61
    1202:	8c 01       	movw	r16, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1204:	fc 01       	movw	r30, r24
    1206:	a0 80       	ld	r10, Z
    1208:	b1 80       	ldd	r11, Z+1	; 0x01
    120a:	f5 01       	movw	r30, r10
    120c:	82 81       	ldd	r24, Z+2	; 0x02
    120e:	81 30       	cpi	r24, 0x01	; 1
    1210:	09 f0       	breq	.+2      	; 0x1214 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x46>
    1212:	78 c0       	rjmp	.+240    	; 0x1304 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x136>
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
    1214:	26 a1       	ldd	r18, Z+38	; 0x26
    1216:	37 a1       	ldd	r19, Z+39	; 0x27
    1218:	40 a5       	ldd	r20, Z+40	; 0x28
    121a:	51 a5       	ldd	r21, Z+41	; 0x29
    121c:	62 a1       	ldd	r22, Z+34	; 0x22
    121e:	73 a1       	ldd	r23, Z+35	; 0x23
    1220:	84 a1       	ldd	r24, Z+36	; 0x24
    1222:	95 a1       	ldd	r25, Z+37	; 0x25
    1224:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    1228:	26 2e       	mov	r2, r22
    122a:	37 2e       	mov	r3, r23
    122c:	48 2e       	mov	r4, r24
    122e:	59 2e       	mov	r5, r25
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    1230:	f5 01       	movw	r30, r10
    1232:	e2 5b       	subi	r30, 0xB2	; 178
    1234:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    1236:	d5 01       	movw	r26, r10
    1238:	ae 5a       	subi	r26, 0xAE	; 174
    123a:	bf 4f       	sbci	r27, 0xFF	; 255
    123c:	2d 91       	ld	r18, X+
    123e:	3d 91       	ld	r19, X+
    1240:	4d 91       	ld	r20, X+
    1242:	5c 91       	ld	r21, X
    1244:	60 81       	ld	r22, Z
    1246:	71 81       	ldd	r23, Z+1	; 0x01
    1248:	82 81       	ldd	r24, Z+2	; 0x02
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    1250:	c6 2e       	mov	r12, r22
    1252:	d7 2e       	mov	r13, r23
    1254:	e8 2e       	mov	r14, r24
    1256:	f9 2e       	mov	r15, r25
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    1258:	f5 01       	movw	r30, r10
    125a:	e2 58       	subi	r30, 0x82	; 130
    125c:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    125e:	d5 01       	movw	r26, r10
    1260:	ae 57       	subi	r26, 0x7E	; 126
    1262:	bf 4f       	sbci	r27, 0xFF	; 255
    1264:	2d 91       	ld	r18, X+
    1266:	3d 91       	ld	r19, X+
    1268:	4d 91       	ld	r20, X+
    126a:	5c 91       	ld	r21, X
    126c:	60 81       	ld	r22, Z
    126e:	71 81       	ldd	r23, Z+1	; 0x01
    1270:	82 81       	ldd	r24, Z+2	; 0x02
    1272:	93 81       	ldd	r25, Z+3	; 0x03
    1274:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    1278:	66 2e       	mov	r6, r22
    127a:	77 2e       	mov	r7, r23
    127c:	88 2e       	mov	r8, r24
    127e:	99 2e       	mov	r9, r25
		float yErrorNED = calculateProportional(model->YNEDLocalFrameCm(), model->ReferenceYNEDLocalFrameCm());
		float zErrorNED = calculateProportional(model->ZNEDLocalFrameCm(), model->ReferenceZNEDLocalFrameCm());
	
	
		//convert position error from NED to FRD Body frame.
		float bodyFrameErrors[3] = {};
    1280:	ae 01       	movw	r20, r28
    1282:	43 5f       	subi	r20, 0xF3	; 243
    1284:	5f 4f       	sbci	r21, 0xFF	; 255
    1286:	8c e0       	ldi	r24, 0x0C	; 12
    1288:	fa 01       	movw	r30, r20
    128a:	11 92       	st	Z+, r1
    128c:	8a 95       	dec	r24
    128e:	e9 f7       	brne	.-6      	; 0x128a <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0xbc>
		float nedToBodyFrameRotationMatrix[3][3] = {};
		float positionErrorsLocalNED[3] = {xErrorNED, yErrorNED, zErrorNED};
    1290:	82 2d       	mov	r24, r2
    1292:	93 2d       	mov	r25, r3
    1294:	a4 2d       	mov	r26, r4
    1296:	b5 2d       	mov	r27, r5
    1298:	89 83       	std	Y+1, r24	; 0x01
    129a:	9a 83       	std	Y+2, r25	; 0x02
    129c:	ab 83       	std	Y+3, r26	; 0x03
    129e:	bc 83       	std	Y+4, r27	; 0x04
    12a0:	8c 2d       	mov	r24, r12
    12a2:	9d 2d       	mov	r25, r13
    12a4:	ae 2d       	mov	r26, r14
    12a6:	bf 2d       	mov	r27, r15
    12a8:	8d 83       	std	Y+5, r24	; 0x05
    12aa:	9e 83       	std	Y+6, r25	; 0x06
    12ac:	af 83       	std	Y+7, r26	; 0x07
    12ae:	b8 87       	std	Y+8, r27	; 0x08
    12b0:	c6 2c       	mov	r12, r6
    12b2:	d7 2c       	mov	r13, r7
    12b4:	e8 2c       	mov	r14, r8
    12b6:	f9 2c       	mov	r15, r9
    12b8:	c9 86       	std	Y+9, r12	; 0x09
    12ba:	da 86       	std	Y+10, r13	; 0x0a
    12bc:	eb 86       	std	Y+11, r14	; 0x0b
    12be:	fc 86       	std	Y+12, r15	; 0x0c
	
		//MatrixUtil::CreateRotationMatrixTransposed(model->RollRads(), model->PitchRads(), model->YawRads(), nedToBodyFrameRotationMatrix);
		//MatrixUtil::RotateMatrix(nedToBodyFrameRotationMatrix, positionErrorsLocalNED, bodyFrameErrors);
	
	
		MatrixUtil::RotateMatrixT(model->Ahrs()->dcm, positionErrorsLocalNED, bodyFrameErrors);
    12c0:	f5 01       	movw	r30, r10
    12c2:	80 81       	ld	r24, Z
    12c4:	91 81       	ldd	r25, Z+1	; 0x01
    12c6:	be 01       	movw	r22, r28
    12c8:	6f 5f       	subi	r22, 0xFF	; 255
    12ca:	7f 4f       	sbci	r23, 0xFF	; 255
    12cc:	80 5c       	subi	r24, 0xC0	; 192
    12ce:	9f 4f       	sbci	r25, 0xFF	; 255
    12d0:	0e 94 5d 68 	call	0xd0ba	; 0xd0ba <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	

		this->cyclicLongitudeOuterLoopUpdate(bodyFrameErrors[0]);
    12d4:	4d 85       	ldd	r20, Y+13	; 0x0d
    12d6:	5e 85       	ldd	r21, Y+14	; 0x0e
    12d8:	6f 85       	ldd	r22, Y+15	; 0x0f
    12da:	78 89       	ldd	r23, Y+16	; 0x10
    12dc:	c8 01       	movw	r24, r16
    12de:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>
		this->cyclicLateralOuterLoopUpdate(bodyFrameErrors[1]);	
    12e2:	49 89       	ldd	r20, Y+17	; 0x11
    12e4:	5a 89       	ldd	r21, Y+18	; 0x12
    12e6:	6b 89       	ldd	r22, Y+19	; 0x13
    12e8:	7c 89       	ldd	r23, Y+20	; 0x14
    12ea:	c8 01       	movw	r24, r16
    12ec:	0e 94 d5 07 	call	0xfaa	; 0xfaa <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>
//		this->mainRotorCollectiveOuterLoopUpdate(bodyFrameErrors[2]);	
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
    12f0:	46 2d       	mov	r20, r6
    12f2:	57 2d       	mov	r21, r7
    12f4:	68 2d       	mov	r22, r8
    12f6:	79 2d       	mov	r23, r9
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 b4 05 	call	0xb68	; 0xb68 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>
		this->tailRotorCollectiveOuterLoopUpdate();
    12fe:	c8 01       	movw	r24, r16
    1300:	0e 94 5d 04 	call	0x8ba	; 0x8ba <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>
		this->cyclicLongitudeOuterLoopUpdate(xErrorNED);
		this->cyclicLateralOuterLoopUpdate(yErrorNED);
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
		this->tailRotorCollectiveOuterLoopUpdate();*/
	}
}
    1304:	68 96       	adiw	r28, 0x18	; 24
    1306:	0f b6       	in	r0, 0x3f	; 63
    1308:	f8 94       	cli
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	0f be       	out	0x3f, r0	; 63
    130e:	cd bf       	out	0x3d, r28	; 61
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	9f 90       	pop	r9
    1326:	8f 90       	pop	r8
    1328:	7f 90       	pop	r7
    132a:	6f 90       	pop	r6
    132c:	5f 90       	pop	r5
    132e:	4f 90       	pop	r4
    1330:	3f 90       	pop	r3
    1332:	2f 90       	pop	r2
    1334:	08 95       	ret

00001336 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>:
	model->YProportional(yProportional);
	model->YDerivativeError(yDerivativeError);
}

void PIDController::cyclicLongitudeInnerLoopUpdate()
{
    1336:	4f 92       	push	r4
    1338:	5f 92       	push	r5
    133a:	6f 92       	push	r6
    133c:	7f 92       	push	r7
    133e:	8f 92       	push	r8
    1340:	9f 92       	push	r9
    1342:	af 92       	push	r10
    1344:	bf 92       	push	r11
    1346:	cf 92       	push	r12
    1348:	df 92       	push	r13
    134a:	ef 92       	push	r14
    134c:	ff 92       	push	r15
    134e:	0f 93       	push	r16
    1350:	1f 93       	push	r17
    1352:	cf 93       	push	r28
    1354:	df 93       	push	r29
    1356:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1358:	88 80       	ld	r8, Y
    135a:	99 80       	ldd	r9, Y+1	; 0x01
    135c:	f4 01       	movw	r30, r8
    135e:	82 81       	ldd	r24, Z+2	; 0x02
    1360:	81 30       	cpi	r24, 0x01	; 1
    1362:	09 f0       	breq	.+2      	; 0x1366 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0x30>
    1364:	47 c0       	rjmp	.+142    	; 0x13f4 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0xbe>
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    1366:	e6 52       	subi	r30, 0x26	; 38
    1368:	ff 4f       	sbci	r31, 0xFF	; 255
	{
		float xLongitudinalInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->XLongitudeOuterLoopSetpoint(), model->PitchRads(), longitudeInnerLoopGain, model->PitchAngularVelocityRadsPerSecond(), pitchAngularVelocityGain);
    136a:	a0 80       	ld	r10, Z
    136c:	b1 80       	ldd	r11, Z+1	; 0x01
    136e:	c2 80       	ldd	r12, Z+2	; 0x02
    1370:	d3 80       	ldd	r13, Z+3	; 0x03
    1372:	ea a0       	ldd	r14, Y+34	; 0x22
    1374:	fb a0       	ldd	r15, Y+35	; 0x23
    1376:	0c a1       	ldd	r16, Y+36	; 0x24
    1378:	1d a1       	ldd	r17, Y+37	; 0x25
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    137a:	f4 01       	movw	r30, r8
    137c:	ee 52       	subi	r30, 0x2E	; 46
    137e:	ff 4f       	sbci	r31, 0xFF	; 255
    1380:	20 81       	ld	r18, Z
    1382:	31 81       	ldd	r19, Z+1	; 0x01
    1384:	42 81       	ldd	r20, Z+2	; 0x02
    1386:	53 81       	ldd	r21, Z+3	; 0x03
    1388:	f4 01       	movw	r30, r8
    138a:	62 ad       	ldd	r22, Z+58	; 0x3a
    138c:	73 ad       	ldd	r23, Z+59	; 0x3b
    138e:	84 ad       	ldd	r24, Z+60	; 0x3c
    1390:	95 ad       	ldd	r25, Z+61	; 0x3d
    1392:	e9 a5       	ldd	r30, Y+41	; 0x29
    1394:	ef 93       	push	r30
    1396:	e8 a5       	ldd	r30, Y+40	; 0x28
    1398:	ef 93       	push	r30
    139a:	ef a1       	ldd	r30, Y+39	; 0x27
    139c:	ef 93       	push	r30
    139e:	ee a1       	ldd	r30, Y+38	; 0x26
    13a0:	ef 93       	push	r30
    13a2:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <_Z30calculateInnerLoopControlValuefffff>
    13a6:	0f 90       	pop	r0
    13a8:	0f 90       	pop	r0
    13aa:	0f 90       	pop	r0
    13ac:	0f 90       	pop	r0
    13ae:	2b 01       	movw	r4, r22
    13b0:	3c 01       	movw	r6, r24
		
		float xLongitudinalInnerLoopControl = adjustControlForServoLimits(xLongitudinalInnerLoopControlBeforeServoLimits, minLongitudeServoControlValue, maxLongitudeServoControlValue);
    13b2:	fe 01       	movw	r30, r28
    13b4:	e2 5a       	subi	r30, 0xA2	; 162
    13b6:	ff 4f       	sbci	r31, 0xFF	; 255
    13b8:	c0 80       	ld	r12, Z
    13ba:	d1 80       	ldd	r13, Z+1	; 0x01
    13bc:	e2 80       	ldd	r14, Z+2	; 0x02
    13be:	f3 80       	ldd	r15, Z+3	; 0x03
    13c0:	fe 01       	movw	r30, r28
    13c2:	e6 5a       	subi	r30, 0xA6	; 166
    13c4:	ff 4f       	sbci	r31, 0xFF	; 255
    13c6:	00 81       	ld	r16, Z
    13c8:	11 81       	ldd	r17, Z+1	; 0x01
    13ca:	22 81       	ldd	r18, Z+2	; 0x02
    13cc:	33 81       	ldd	r19, Z+3	; 0x03
    13ce:	ab 01       	movw	r20, r22
    13d0:	bc 01       	movw	r22, r24
    13d2:	ce 01       	movw	r24, r28
    13d4:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}
    13d8:	f4 01       	movw	r30, r8
    13da:	42 a6       	std	Z+42, r4	; 0x2a
    13dc:	53 a6       	std	Z+43, r5	; 0x2b
    13de:	64 a6       	std	Z+44, r6	; 0x2c
    13e0:	75 a6       	std	Z+45, r7	; 0x2d
		model->LongitudeControlBeforeServoLimitsAdjustment(xLongitudinalInnerLoopControlBeforeServoLimits);
	
//		model->LongitudeControl(xLongitudinalInnerLoopControl);

		//Multiply by -1 because in the simulator, a control value of +1 results in the helicopter pitching up, but the real helicopter pitches down.
		model->LongitudeControl(xLongitudinalInnerLoopControl * -1);
    13e2:	e8 81       	ld	r30, Y
    13e4:	f9 81       	ldd	r31, Y+1	; 0x01
    13e6:	dc 01       	movw	r26, r24
    13e8:	cb 01       	movw	r24, r22
    13ea:	b0 58       	subi	r27, 0x80	; 128

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
    13ec:	86 a7       	std	Z+46, r24	; 0x2e
    13ee:	97 a7       	std	Z+47, r25	; 0x2f
    13f0:	a0 ab       	std	Z+48, r26	; 0x30
    13f2:	b1 ab       	std	Z+49, r27	; 0x31
	}
}
    13f4:	df 91       	pop	r29
    13f6:	cf 91       	pop	r28
    13f8:	1f 91       	pop	r17
    13fa:	0f 91       	pop	r16
    13fc:	ff 90       	pop	r15
    13fe:	ef 90       	pop	r14
    1400:	df 90       	pop	r13
    1402:	cf 90       	pop	r12
    1404:	bf 90       	pop	r11
    1406:	af 90       	pop	r10
    1408:	9f 90       	pop	r9
    140a:	8f 90       	pop	r8
    140c:	7f 90       	pop	r7
    140e:	6f 90       	pop	r6
    1410:	5f 90       	pop	r5
    1412:	4f 90       	pop	r4
    1414:	08 95       	ret

00001416 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>:

void PIDController::cyclicLateralInnerLoopUpdate()
{
    1416:	4f 92       	push	r4
    1418:	5f 92       	push	r5
    141a:	6f 92       	push	r6
    141c:	7f 92       	push	r7
    141e:	8f 92       	push	r8
    1420:	9f 92       	push	r9
    1422:	af 92       	push	r10
    1424:	bf 92       	push	r11
    1426:	cf 92       	push	r12
    1428:	df 92       	push	r13
    142a:	ef 92       	push	r14
    142c:	ff 92       	push	r15
    142e:	0f 93       	push	r16
    1430:	1f 93       	push	r17
    1432:	cf 93       	push	r28
    1434:	df 93       	push	r29
    1436:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1438:	88 80       	ld	r8, Y
    143a:	99 80       	ldd	r9, Y+1	; 0x01
    143c:	f4 01       	movw	r30, r8
    143e:	82 81       	ldd	r24, Z+2	; 0x02
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	09 f0       	breq	.+2      	; 0x1446 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0x30>
    1444:	4c c0       	rjmp	.+152    	; 0x14de <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0xc8>
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    1446:	e2 52       	subi	r30, 0x22	; 34
    1448:	ff 4f       	sbci	r31, 0xFF	; 255
	{
		float yLateralInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->YLateralOuterLoopSetpoint(), model->RollRads(), lateralInnerLoopGain, model->RollAngularVelocityRadsPerSecond(), rollAngularVelocityGain);
    144a:	a0 80       	ld	r10, Z
    144c:	b1 80       	ldd	r11, Z+1	; 0x01
    144e:	c2 80       	ldd	r12, Z+2	; 0x02
    1450:	d3 80       	ldd	r13, Z+3	; 0x03
    1452:	ea ac       	ldd	r14, Y+58	; 0x3a
    1454:	fb ac       	ldd	r15, Y+59	; 0x3b
    1456:	0c ad       	ldd	r16, Y+60	; 0x3c
    1458:	1d ad       	ldd	r17, Y+61	; 0x3d
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    145a:	f4 01       	movw	r30, r8
    145c:	e2 53       	subi	r30, 0x32	; 50
    145e:	ff 4f       	sbci	r31, 0xFF	; 255
    1460:	20 81       	ld	r18, Z
    1462:	31 81       	ldd	r19, Z+1	; 0x01
    1464:	42 81       	ldd	r20, Z+2	; 0x02
    1466:	53 81       	ldd	r21, Z+3	; 0x03
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
    1468:	f4 01       	movw	r30, r8
    146a:	ea 59       	subi	r30, 0x9A	; 154
    146c:	ff 4f       	sbci	r31, 0xFF	; 255
    146e:	60 81       	ld	r22, Z
    1470:	71 81       	ldd	r23, Z+1	; 0x01
    1472:	82 81       	ldd	r24, Z+2	; 0x02
    1474:	93 81       	ldd	r25, Z+3	; 0x03
    1476:	fe 01       	movw	r30, r28
    1478:	fe 96       	adiw	r30, 0x3e	; 62
    147a:	a3 81       	ldd	r26, Z+3	; 0x03
    147c:	af 93       	push	r26
    147e:	a2 81       	ldd	r26, Z+2	; 0x02
    1480:	af 93       	push	r26
    1482:	a1 81       	ldd	r26, Z+1	; 0x01
    1484:	af 93       	push	r26
    1486:	e0 81       	ld	r30, Z
    1488:	ef 93       	push	r30
    148a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <_Z30calculateInnerLoopControlValuefffff>
    148e:	0f 90       	pop	r0
    1490:	0f 90       	pop	r0
    1492:	0f 90       	pop	r0
    1494:	0f 90       	pop	r0
    1496:	2b 01       	movw	r4, r22
    1498:	3c 01       	movw	r6, r24
		
		float yLateralInnerLoopControl = adjustControlForServoLimits(yLateralInnerLoopControlBeforeServoLimits, minLateralServoControlValue, maxLateralServoControlValue);
    149a:	fe 01       	movw	r30, r28
    149c:	ea 59       	subi	r30, 0x9A	; 154
    149e:	ff 4f       	sbci	r31, 0xFF	; 255
    14a0:	c0 80       	ld	r12, Z
    14a2:	d1 80       	ldd	r13, Z+1	; 0x01
    14a4:	e2 80       	ldd	r14, Z+2	; 0x02
    14a6:	f3 80       	ldd	r15, Z+3	; 0x03
    14a8:	fe 01       	movw	r30, r28
    14aa:	ee 59       	subi	r30, 0x9E	; 158
    14ac:	ff 4f       	sbci	r31, 0xFF	; 255
    14ae:	00 81       	ld	r16, Z
    14b0:	11 81       	ldd	r17, Z+1	; 0x01
    14b2:	22 81       	ldd	r18, Z+2	; 0x02
    14b4:	33 81       	ldd	r19, Z+3	; 0x03
    14b6:	ab 01       	movw	r20, r22
    14b8:	bc 01       	movw	r22, r24
    14ba:	ce 01       	movw	r24, r28
    14bc:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}
    14c0:	f4 01       	movw	r30, r8
    14c2:	ea 5a       	subi	r30, 0xAA	; 170
    14c4:	ff 4f       	sbci	r31, 0xFF	; 255
    14c6:	40 82       	st	Z, r4
    14c8:	51 82       	std	Z+1, r5	; 0x01
    14ca:	62 82       	std	Z+2, r6	; 0x02
    14cc:	73 82       	std	Z+3, r7	; 0x03
		
		model->LateralControlBeforeServoLimitsAdjustment(yLateralInnerLoopControlBeforeServoLimits);
		
		model->LateralControl(yLateralInnerLoopControl);		
    14ce:	e8 81       	ld	r30, Y
    14d0:	f9 81       	ldd	r31, Y+1	; 0x01

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}
    14d2:	e6 5a       	subi	r30, 0xA6	; 166
    14d4:	ff 4f       	sbci	r31, 0xFF	; 255
    14d6:	60 83       	st	Z, r22
    14d8:	71 83       	std	Z+1, r23	; 0x01
    14da:	82 83       	std	Z+2, r24	; 0x02
    14dc:	93 83       	std	Z+3, r25	; 0x03
	}
}
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	df 90       	pop	r13
    14ec:	cf 90       	pop	r12
    14ee:	bf 90       	pop	r11
    14f0:	af 90       	pop	r10
    14f2:	9f 90       	pop	r9
    14f4:	8f 90       	pop	r8
    14f6:	7f 90       	pop	r7
    14f8:	6f 90       	pop	r6
    14fa:	5f 90       	pop	r5
    14fc:	4f 90       	pop	r4
    14fe:	08 95       	ret

00001500 <_ZN10helicopter7drivers12SerialDriverD1Ev>:
				{

				}
						
				virtual ~SerialDriver()
				{
    1500:	22 e1       	ldi	r18, 0x12	; 18
    1502:	32 e0       	ldi	r19, 0x02	; 2
    1504:	fc 01       	movw	r30, r24
    1506:	31 83       	std	Z+1, r19	; 0x01
    1508:	20 83       	st	Z, r18
    150a:	08 95       	ret

0000150c <_ZN10helicopter7drivers12SerialDriver8transmitEf>:
		sei();
	}
}

int SerialDriver::transmit(float valueToSend)
{
    150c:	bf 92       	push	r11
    150e:	cf 92       	push	r12
    1510:	df 92       	push	r13
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	ec 01       	movw	r28, r24
    1520:	05 2f       	mov	r16, r21
    1522:	16 2f       	mov	r17, r22
    1524:	b7 2e       	mov	r11, r23
	
	//Memcpy the float into an array of bytes because the compiler doesn't like
	//bit shifting floats. 
	memcpy(bytes, (void*) &valueToSend, 4);
	
	status1 = transmit(bytes[0]);
    1526:	e8 81       	ld	r30, Y
    1528:	f9 81       	ldd	r31, Y+1	; 0x01
    152a:	06 80       	ldd	r0, Z+6	; 0x06
    152c:	f7 81       	ldd	r31, Z+7	; 0x07
    152e:	e0 2d       	mov	r30, r0
    1530:	64 2f       	mov	r22, r20
    1532:	19 95       	eicall
    1534:	7c 01       	movw	r14, r24
	status2 = transmit(bytes[1]);
    1536:	e8 81       	ld	r30, Y
    1538:	f9 81       	ldd	r31, Y+1	; 0x01
    153a:	06 80       	ldd	r0, Z+6	; 0x06
    153c:	f7 81       	ldd	r31, Z+7	; 0x07
    153e:	e0 2d       	mov	r30, r0
    1540:	60 2f       	mov	r22, r16
    1542:	ce 01       	movw	r24, r28
    1544:	19 95       	eicall
    1546:	6c 01       	movw	r12, r24
	status3 = transmit(bytes[2]);
    1548:	e8 81       	ld	r30, Y
    154a:	f9 81       	ldd	r31, Y+1	; 0x01
    154c:	06 80       	ldd	r0, Z+6	; 0x06
    154e:	f7 81       	ldd	r31, Z+7	; 0x07
    1550:	e0 2d       	mov	r30, r0
    1552:	61 2f       	mov	r22, r17
    1554:	ce 01       	movw	r24, r28
    1556:	19 95       	eicall
    1558:	8c 01       	movw	r16, r24
	status4 = transmit(bytes[3]);
    155a:	e8 81       	ld	r30, Y
    155c:	f9 81       	ldd	r31, Y+1	; 0x01
    155e:	06 80       	ldd	r0, Z+6	; 0x06
    1560:	f7 81       	ldd	r31, Z+7	; 0x07
    1562:	e0 2d       	mov	r30, r0
    1564:	6b 2d       	mov	r22, r11
    1566:	ce 01       	movw	r24, r28
    1568:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    156a:	96 01       	movw	r18, r12
    156c:	2e 29       	or	r18, r14
    156e:	3f 29       	or	r19, r15
    1570:	20 2b       	or	r18, r16
    1572:	31 2b       	or	r19, r17
    1574:	28 2b       	or	r18, r24
    1576:	39 2b       	or	r19, r25
}
    1578:	82 2f       	mov	r24, r18
    157a:	93 2f       	mov	r25, r19
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	df 90       	pop	r13
    158a:	cf 90       	pop	r12
    158c:	bf 90       	pop	r11
    158e:	08 95       	ret

00001590 <_ZN10helicopter7drivers12SerialDriver8transmitEi>:

int SerialDriver::transmit(int valueToSend)
{
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	ec 01       	movw	r28, r24
    159c:	f6 2e       	mov	r15, r22
    159e:	67 2f       	mov	r22, r23
	int status1 = 0;
	int status2 = 0;
	
	status1 = transmit((byte)((valueToSend >> 8) & 0xFF));
    15a0:	e8 81       	ld	r30, Y
    15a2:	f9 81       	ldd	r31, Y+1	; 0x01
    15a4:	06 80       	ldd	r0, Z+6	; 0x06
    15a6:	f7 81       	ldd	r31, Z+7	; 0x07
    15a8:	e0 2d       	mov	r30, r0
    15aa:	19 95       	eicall
    15ac:	8c 01       	movw	r16, r24
	status2 = transmit((byte)valueToSend);	
    15ae:	e8 81       	ld	r30, Y
    15b0:	f9 81       	ldd	r31, Y+1	; 0x01
    15b2:	06 80       	ldd	r0, Z+6	; 0x06
    15b4:	f7 81       	ldd	r31, Z+7	; 0x07
    15b6:	e0 2d       	mov	r30, r0
    15b8:	6f 2d       	mov	r22, r15
    15ba:	ce 01       	movw	r24, r28
    15bc:	19 95       	eicall
	
	return status1 | status2;
    15be:	9c 01       	movw	r18, r24
    15c0:	20 2b       	or	r18, r16
    15c2:	31 2b       	or	r19, r17
}
    15c4:	82 2f       	mov	r24, r18
    15c6:	93 2f       	mov	r25, r19
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	08 95       	ret

000015d4 <_ZN10helicopter7drivers12SerialDriver8transmitEm>:

int SerialDriver::transmit(unsigned long valueToSend)
{
    15d4:	8f 92       	push	r8
    15d6:	9f 92       	push	r9
    15d8:	af 92       	push	r10
    15da:	bf 92       	push	r11
    15dc:	cf 92       	push	r12
    15de:	df 92       	push	r13
    15e0:	ef 92       	push	r14
    15e2:	ff 92       	push	r15
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	ec 01       	movw	r28, r24
    15ee:	4a 01       	movw	r8, r20
    15f0:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    15f2:	e8 81       	ld	r30, Y
    15f4:	f9 81       	ldd	r31, Y+1	; 0x01
    15f6:	67 2f       	mov	r22, r23
    15f8:	77 27       	eor	r23, r23
    15fa:	88 27       	eor	r24, r24
    15fc:	99 27       	eor	r25, r25
    15fe:	06 80       	ldd	r0, Z+6	; 0x06
    1600:	f7 81       	ldd	r31, Z+7	; 0x07
    1602:	e0 2d       	mov	r30, r0
    1604:	ce 01       	movw	r24, r28
    1606:	19 95       	eicall
    1608:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    160a:	e8 81       	ld	r30, Y
    160c:	f9 81       	ldd	r31, Y+1	; 0x01
    160e:	b5 01       	movw	r22, r10
    1610:	88 27       	eor	r24, r24
    1612:	99 27       	eor	r25, r25
    1614:	06 80       	ldd	r0, Z+6	; 0x06
    1616:	f7 81       	ldd	r31, Z+7	; 0x07
    1618:	e0 2d       	mov	r30, r0
    161a:	ce 01       	movw	r24, r28
    161c:	19 95       	eicall
    161e:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1620:	e8 81       	ld	r30, Y
    1622:	f9 81       	ldd	r31, Y+1	; 0x01
    1624:	99 27       	eor	r25, r25
    1626:	8b 2d       	mov	r24, r11
    1628:	7a 2d       	mov	r23, r10
    162a:	69 2d       	mov	r22, r9
    162c:	06 80       	ldd	r0, Z+6	; 0x06
    162e:	f7 81       	ldd	r31, Z+7	; 0x07
    1630:	e0 2d       	mov	r30, r0
    1632:	ce 01       	movw	r24, r28
    1634:	19 95       	eicall
    1636:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    1638:	e8 81       	ld	r30, Y
    163a:	f9 81       	ldd	r31, Y+1	; 0x01
    163c:	06 80       	ldd	r0, Z+6	; 0x06
    163e:	f7 81       	ldd	r31, Z+7	; 0x07
    1640:	e0 2d       	mov	r30, r0
    1642:	68 2d       	mov	r22, r8
    1644:	ce 01       	movw	r24, r28
    1646:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    1648:	ec 28       	or	r14, r12
    164a:	fd 28       	or	r15, r13
    164c:	0e 29       	or	r16, r14
    164e:	1f 29       	or	r17, r15
    1650:	08 2b       	or	r16, r24
    1652:	19 2b       	or	r17, r25
}
    1654:	80 2f       	mov	r24, r16
    1656:	91 2f       	mov	r25, r17
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	1f 91       	pop	r17
    165e:	0f 91       	pop	r16
    1660:	ff 90       	pop	r15
    1662:	ef 90       	pop	r14
    1664:	df 90       	pop	r13
    1666:	cf 90       	pop	r12
    1668:	bf 90       	pop	r11
    166a:	af 90       	pop	r10
    166c:	9f 90       	pop	r9
    166e:	8f 90       	pop	r8
    1670:	08 95       	ret

00001672 <_ZN10helicopter7drivers12SerialDriver8transmitEl>:

int SerialDriver::transmit(long valueToSend)
{
    1672:	8f 92       	push	r8
    1674:	9f 92       	push	r9
    1676:	af 92       	push	r10
    1678:	bf 92       	push	r11
    167a:	cf 92       	push	r12
    167c:	df 92       	push	r13
    167e:	ef 92       	push	r14
    1680:	ff 92       	push	r15
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	ec 01       	movw	r28, r24
    168c:	4a 01       	movw	r8, r20
    168e:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    1690:	e8 81       	ld	r30, Y
    1692:	f9 81       	ldd	r31, Y+1	; 0x01
    1694:	67 2f       	mov	r22, r23
    1696:	77 27       	eor	r23, r23
    1698:	88 27       	eor	r24, r24
    169a:	99 27       	eor	r25, r25
    169c:	06 80       	ldd	r0, Z+6	; 0x06
    169e:	f7 81       	ldd	r31, Z+7	; 0x07
    16a0:	e0 2d       	mov	r30, r0
    16a2:	ce 01       	movw	r24, r28
    16a4:	19 95       	eicall
    16a6:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    16a8:	e8 81       	ld	r30, Y
    16aa:	f9 81       	ldd	r31, Y+1	; 0x01
    16ac:	b5 01       	movw	r22, r10
    16ae:	99 27       	eor	r25, r25
    16b0:	77 fd       	sbrc	r23, 7
    16b2:	90 95       	com	r25
    16b4:	89 2f       	mov	r24, r25
    16b6:	06 80       	ldd	r0, Z+6	; 0x06
    16b8:	f7 81       	ldd	r31, Z+7	; 0x07
    16ba:	e0 2d       	mov	r30, r0
    16bc:	ce 01       	movw	r24, r28
    16be:	19 95       	eicall
    16c0:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    16c2:	e8 81       	ld	r30, Y
    16c4:	f9 81       	ldd	r31, Y+1	; 0x01
    16c6:	99 27       	eor	r25, r25
    16c8:	b7 fc       	sbrc	r11, 7
    16ca:	9a 95       	dec	r25
    16cc:	8b 2d       	mov	r24, r11
    16ce:	7a 2d       	mov	r23, r10
    16d0:	69 2d       	mov	r22, r9
    16d2:	06 80       	ldd	r0, Z+6	; 0x06
    16d4:	f7 81       	ldd	r31, Z+7	; 0x07
    16d6:	e0 2d       	mov	r30, r0
    16d8:	ce 01       	movw	r24, r28
    16da:	19 95       	eicall
    16dc:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    16de:	e8 81       	ld	r30, Y
    16e0:	f9 81       	ldd	r31, Y+1	; 0x01
    16e2:	06 80       	ldd	r0, Z+6	; 0x06
    16e4:	f7 81       	ldd	r31, Z+7	; 0x07
    16e6:	e0 2d       	mov	r30, r0
    16e8:	68 2d       	mov	r22, r8
    16ea:	ce 01       	movw	r24, r28
    16ec:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    16ee:	ec 28       	or	r14, r12
    16f0:	fd 28       	or	r15, r13
    16f2:	0e 29       	or	r16, r14
    16f4:	1f 29       	or	r17, r15
    16f6:	08 2b       	or	r16, r24
    16f8:	19 2b       	or	r17, r25
}
    16fa:	80 2f       	mov	r24, r16
    16fc:	91 2f       	mov	r25, r17
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	ff 90       	pop	r15
    1708:	ef 90       	pop	r14
    170a:	df 90       	pop	r13
    170c:	cf 90       	pop	r12
    170e:	bf 90       	pop	r11
    1710:	af 90       	pop	r10
    1712:	9f 90       	pop	r9
    1714:	8f 90       	pop	r8
    1716:	08 95       	ret

00001718 <_ZN10helicopter7drivers12SerialDriver8transmitEx>:

int SerialDriver::transmit(int64_t valueToSend)
{
    1718:	3f 92       	push	r3
    171a:	4f 92       	push	r4
    171c:	5f 92       	push	r5
    171e:	6f 92       	push	r6
    1720:	7f 92       	push	r7
    1722:	8f 92       	push	r8
    1724:	9f 92       	push	r9
    1726:	af 92       	push	r10
    1728:	bf 92       	push	r11
    172a:	cf 92       	push	r12
    172c:	df 92       	push	r13
    172e:	ef 92       	push	r14
    1730:	ff 92       	push	r15
    1732:	0f 93       	push	r16
    1734:	1f 93       	push	r17
    1736:	cf 93       	push	r28
    1738:	df 93       	push	r29
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
    173e:	28 97       	sbiw	r28, 0x08	; 8
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	cd bf       	out	0x3d, r28	; 61
    174a:	98 87       	std	Y+8, r25	; 0x08
    174c:	8f 83       	std	Y+7, r24	; 0x07
    174e:	70 2e       	mov	r7, r16
    1750:	32 2e       	mov	r3, r18
    1752:	43 2e       	mov	r4, r19
    1754:	54 2e       	mov	r5, r20
    1756:	65 2e       	mov	r6, r21
    1758:	e6 2e       	mov	r14, r22
    175a:	f7 2e       	mov	r15, r23
	int status5 = 0;
	int status6 = 0;
	int status7 = 0;
	int status8 = 0;	

	status1 = transmit((byte)((valueToSend >> 56) & 0xFF));
    175c:	dc 01       	movw	r26, r24
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	11 97       	sbiw	r26, 0x01	; 1
    1764:	20 2f       	mov	r18, r16
    1766:	31 2f       	mov	r19, r17
    1768:	43 2d       	mov	r20, r3
    176a:	54 2d       	mov	r21, r4
    176c:	65 2d       	mov	r22, r5
    176e:	76 2d       	mov	r23, r6
    1770:	8e 2d       	mov	r24, r14
    1772:	9f 2d       	mov	r25, r15
    1774:	08 e3       	ldi	r16, 0x38	; 56
    1776:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    177a:	06 80       	ldd	r0, Z+6	; 0x06
    177c:	f7 81       	ldd	r31, Z+7	; 0x07
    177e:	e0 2d       	mov	r30, r0
    1780:	62 2f       	mov	r22, r18
    1782:	cd 01       	movw	r24, r26
    1784:	19 95       	eicall
    1786:	5c 01       	movw	r10, r24
	status2 = transmit((byte)((valueToSend >> 48) & 0xFF));
    1788:	af 81       	ldd	r26, Y+7	; 0x07
    178a:	b8 85       	ldd	r27, Y+8	; 0x08
    178c:	ed 91       	ld	r30, X+
    178e:	fc 91       	ld	r31, X
    1790:	11 97       	sbiw	r26, 0x01	; 1
    1792:	27 2d       	mov	r18, r7
    1794:	31 2f       	mov	r19, r17
    1796:	43 2d       	mov	r20, r3
    1798:	54 2d       	mov	r21, r4
    179a:	65 2d       	mov	r22, r5
    179c:	76 2d       	mov	r23, r6
    179e:	8e 2d       	mov	r24, r14
    17a0:	9f 2d       	mov	r25, r15
    17a2:	00 e3       	ldi	r16, 0x30	; 48
    17a4:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    17a8:	06 80       	ldd	r0, Z+6	; 0x06
    17aa:	f7 81       	ldd	r31, Z+7	; 0x07
    17ac:	e0 2d       	mov	r30, r0
    17ae:	62 2f       	mov	r22, r18
    17b0:	cd 01       	movw	r24, r26
    17b2:	19 95       	eicall
    17b4:	4c 01       	movw	r8, r24
	status3 = transmit((byte)((valueToSend >> 40) & 0xFF));
    17b6:	af 81       	ldd	r26, Y+7	; 0x07
    17b8:	b8 85       	ldd	r27, Y+8	; 0x08
    17ba:	ed 91       	ld	r30, X+
    17bc:	fc 91       	ld	r31, X
    17be:	11 97       	sbiw	r26, 0x01	; 1
    17c0:	27 2d       	mov	r18, r7
    17c2:	31 2f       	mov	r19, r17
    17c4:	43 2d       	mov	r20, r3
    17c6:	54 2d       	mov	r21, r4
    17c8:	65 2d       	mov	r22, r5
    17ca:	76 2d       	mov	r23, r6
    17cc:	8e 2d       	mov	r24, r14
    17ce:	9f 2d       	mov	r25, r15
    17d0:	08 e2       	ldi	r16, 0x28	; 40
    17d2:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    17d6:	06 80       	ldd	r0, Z+6	; 0x06
    17d8:	f7 81       	ldd	r31, Z+7	; 0x07
    17da:	e0 2d       	mov	r30, r0
    17dc:	62 2f       	mov	r22, r18
    17de:	cd 01       	movw	r24, r26
    17e0:	19 95       	eicall
    17e2:	9a 83       	std	Y+2, r25	; 0x02
    17e4:	89 83       	std	Y+1, r24	; 0x01
	status4 = transmit((byte)((valueToSend >> 32) & 0xFF));
    17e6:	af 81       	ldd	r26, Y+7	; 0x07
    17e8:	b8 85       	ldd	r27, Y+8	; 0x08
    17ea:	ed 91       	ld	r30, X+
    17ec:	fc 91       	ld	r31, X
    17ee:	11 97       	sbiw	r26, 0x01	; 1
    17f0:	27 2d       	mov	r18, r7
    17f2:	31 2f       	mov	r19, r17
    17f4:	43 2d       	mov	r20, r3
    17f6:	54 2d       	mov	r21, r4
    17f8:	65 2d       	mov	r22, r5
    17fa:	76 2d       	mov	r23, r6
    17fc:	8e 2d       	mov	r24, r14
    17fe:	9f 2d       	mov	r25, r15
    1800:	00 e2       	ldi	r16, 0x20	; 32
    1802:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    1806:	06 80       	ldd	r0, Z+6	; 0x06
    1808:	f7 81       	ldd	r31, Z+7	; 0x07
    180a:	e0 2d       	mov	r30, r0
    180c:	62 2f       	mov	r22, r18
    180e:	cd 01       	movw	r24, r26
    1810:	19 95       	eicall
    1812:	9c 83       	std	Y+4, r25	; 0x04
    1814:	8b 83       	std	Y+3, r24	; 0x03
	status5 = transmit((byte)((valueToSend >> 24) & 0xFF));
    1816:	af 81       	ldd	r26, Y+7	; 0x07
    1818:	b8 85       	ldd	r27, Y+8	; 0x08
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	11 97       	sbiw	r26, 0x01	; 1
    1820:	27 2d       	mov	r18, r7
    1822:	31 2f       	mov	r19, r17
    1824:	43 2d       	mov	r20, r3
    1826:	54 2d       	mov	r21, r4
    1828:	65 2d       	mov	r22, r5
    182a:	76 2d       	mov	r23, r6
    182c:	8e 2d       	mov	r24, r14
    182e:	9f 2d       	mov	r25, r15
    1830:	08 e1       	ldi	r16, 0x18	; 24
    1832:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    1836:	06 80       	ldd	r0, Z+6	; 0x06
    1838:	f7 81       	ldd	r31, Z+7	; 0x07
    183a:	e0 2d       	mov	r30, r0
    183c:	62 2f       	mov	r22, r18
    183e:	cd 01       	movw	r24, r26
    1840:	19 95       	eicall
    1842:	9e 83       	std	Y+6, r25	; 0x06
    1844:	8d 83       	std	Y+5, r24	; 0x05
	status6 = transmit((byte)((valueToSend >> 16) & 0xFF));
    1846:	af 81       	ldd	r26, Y+7	; 0x07
    1848:	b8 85       	ldd	r27, Y+8	; 0x08
    184a:	ed 91       	ld	r30, X+
    184c:	fc 91       	ld	r31, X
    184e:	11 97       	sbiw	r26, 0x01	; 1
    1850:	27 2d       	mov	r18, r7
    1852:	31 2f       	mov	r19, r17
    1854:	43 2d       	mov	r20, r3
    1856:	54 2d       	mov	r21, r4
    1858:	65 2d       	mov	r22, r5
    185a:	76 2d       	mov	r23, r6
    185c:	8e 2d       	mov	r24, r14
    185e:	9f 2d       	mov	r25, r15
    1860:	00 e1       	ldi	r16, 0x10	; 16
    1862:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    1866:	06 80       	ldd	r0, Z+6	; 0x06
    1868:	f7 81       	ldd	r31, Z+7	; 0x07
    186a:	e0 2d       	mov	r30, r0
    186c:	62 2f       	mov	r22, r18
    186e:	cd 01       	movw	r24, r26
    1870:	19 95       	eicall
    1872:	6c 01       	movw	r12, r24
	status7 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1874:	af 81       	ldd	r26, Y+7	; 0x07
    1876:	b8 85       	ldd	r27, Y+8	; 0x08
    1878:	ed 91       	ld	r30, X+
    187a:	fc 91       	ld	r31, X
    187c:	11 97       	sbiw	r26, 0x01	; 1
    187e:	27 2d       	mov	r18, r7
    1880:	31 2f       	mov	r19, r17
    1882:	43 2d       	mov	r20, r3
    1884:	54 2d       	mov	r21, r4
    1886:	65 2d       	mov	r22, r5
    1888:	76 2d       	mov	r23, r6
    188a:	8e 2d       	mov	r24, r14
    188c:	9f 2d       	mov	r25, r15
    188e:	08 e0       	ldi	r16, 0x08	; 8
    1890:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    1894:	06 80       	ldd	r0, Z+6	; 0x06
    1896:	f7 81       	ldd	r31, Z+7	; 0x07
    1898:	e0 2d       	mov	r30, r0
    189a:	62 2f       	mov	r22, r18
    189c:	cd 01       	movw	r24, r26
    189e:	19 95       	eicall
    18a0:	7c 01       	movw	r14, r24
	status8 = transmit((byte)(valueToSend & 0xFF));
    18a2:	af 81       	ldd	r26, Y+7	; 0x07
    18a4:	b8 85       	ldd	r27, Y+8	; 0x08
    18a6:	ed 91       	ld	r30, X+
    18a8:	fc 91       	ld	r31, X
    18aa:	11 97       	sbiw	r26, 0x01	; 1
    18ac:	06 80       	ldd	r0, Z+6	; 0x06
    18ae:	f7 81       	ldd	r31, Z+7	; 0x07
    18b0:	e0 2d       	mov	r30, r0
    18b2:	67 2d       	mov	r22, r7
    18b4:	cd 01       	movw	r24, r26
    18b6:	19 95       	eicall
	
	return status1 | status2 | status3 | status4 | status5 | status6 | status7 | status8;
    18b8:	a8 28       	or	r10, r8
    18ba:	b9 28       	or	r11, r9
    18bc:	e9 81       	ldd	r30, Y+1	; 0x01
    18be:	fa 81       	ldd	r31, Y+2	; 0x02
    18c0:	ae 2a       	or	r10, r30
    18c2:	bf 2a       	or	r11, r31
    18c4:	2b 81       	ldd	r18, Y+3	; 0x03
    18c6:	3c 81       	ldd	r19, Y+4	; 0x04
    18c8:	a2 2a       	or	r10, r18
    18ca:	b3 2a       	or	r11, r19
    18cc:	ad 81       	ldd	r26, Y+5	; 0x05
    18ce:	be 81       	ldd	r27, Y+6	; 0x06
    18d0:	aa 2a       	or	r10, r26
    18d2:	bb 2a       	or	r11, r27
    18d4:	ca 28       	or	r12, r10
    18d6:	db 28       	or	r13, r11
    18d8:	ec 28       	or	r14, r12
    18da:	fd 28       	or	r15, r13
    18dc:	e8 2a       	or	r14, r24
    18de:	f9 2a       	or	r15, r25
}
    18e0:	8e 2d       	mov	r24, r14
    18e2:	9f 2d       	mov	r25, r15
    18e4:	28 96       	adiw	r28, 0x08	; 8
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	de bf       	out	0x3e, r29	; 62
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	cd bf       	out	0x3d, r28	; 61
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	ff 90       	pop	r15
    18fa:	ef 90       	pop	r14
    18fc:	df 90       	pop	r13
    18fe:	cf 90       	pop	r12
    1900:	bf 90       	pop	r11
    1902:	af 90       	pop	r10
    1904:	9f 90       	pop	r9
    1906:	8f 90       	pop	r8
    1908:	7f 90       	pop	r7
    190a:	6f 90       	pop	r6
    190c:	5f 90       	pop	r5
    190e:	4f 90       	pop	r4
    1910:	3f 90       	pop	r3
    1912:	08 95       	ret

00001914 <_ZN10helicopter7drivers12SerialDriver7receiveERh>:

	return status;
}

int SerialDriver::receive(byte &receivedByte)
{
    1914:	ef 92       	push	r14
    1916:	ff 92       	push	r15
    1918:	0f 93       	push	r16
    191a:	1f 93       	push	r17
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	ec 01       	movw	r28, r24
    1922:	7b 01       	movw	r14, r22
	int status = 0;
	
	if (asyncReceiveTransmitData)
    1924:	88 85       	ldd	r24, Y+8	; 0x08
    1926:	88 23       	and	r24, r24
    1928:	49 f0       	breq	.+18     	; 0x193c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x28>
	{
		bool status = receiveBuffer.dequeue(receivedByte);
    192a:	88 e9       	ldi	r24, 0x98	; 152
    192c:	93 e0       	ldi	r25, 0x03	; 3
    192e:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>
		
		if (!status)
    1932:	81 11       	cpse	r24, r1
    1934:	3a c0       	rjmp	.+116    	; 0x19aa <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x96>
		{
			return -1;
    1936:	2f ef       	ldi	r18, 0xFF	; 255
    1938:	3f ef       	ldi	r19, 0xFF	; 255
    193a:	3f c0       	rjmp	.+126    	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		}
		
		return 0;
	}
	
	if (uartPort == Zero)
    193c:	8e 81       	ldd	r24, Y+6	; 0x06
    193e:	88 23       	and	r24, r24
    1940:	51 f0       	breq	.+20     	; 0x1956 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x42>
    1942:	17 c0       	rjmp	.+46     	; 0x1972 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x5e>
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
		{
			if (timer != NULL && timer->hasTimedout())
    1944:	89 85       	ldd	r24, Y+9	; 0x09
    1946:	9a 85       	ldd	r25, Y+10	; 0x0a
    1948:	00 97       	sbiw	r24, 0x00	; 0
    194a:	39 f0       	breq	.+14     	; 0x195a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x46>
    194c:	0e 94 e9 69 	call	0xd3d2	; 0xd3d2 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1950:	88 23       	and	r24, r24
    1952:	19 f0       	breq	.+6      	; 0x195a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x46>
    1954:	2d c0       	rjmp	.+90     	; 0x19b0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x9c>
		
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
    1956:	00 ec       	ldi	r16, 0xC0	; 192
    1958:	10 e0       	ldi	r17, 0x00	; 0
    195a:	f8 01       	movw	r30, r16
    195c:	80 81       	ld	r24, Z
    195e:	88 23       	and	r24, r24
    1960:	8c f7       	brge	.-30     	; 0x1944 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x30>
    1962:	2e c0       	rjmp	.+92     	; 0x19c0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xac>
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
			{
				status = -2;
    1964:	2e ef       	ldi	r18, 0xFE	; 254
    1966:	3f ef       	ldi	r19, 0xFF	; 255

			//// Stop interrupts
			//cli();
		
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR0;
    1968:	80 91 c6 00 	lds	r24, 0x00C6
    196c:	f7 01       	movw	r30, r14
    196e:	80 83       	st	Z, r24
    1970:	24 c0       	rjmp	.+72     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
			
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;			
		}
	} else if (uartPort == One)
    1972:	81 30       	cpi	r24, 0x01	; 1
    1974:	61 f0       	breq	.+24     	; 0x198e <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7a>
	return status;
}

int SerialDriver::receive(byte &receivedByte)
{
	int status = 0;
    1976:	20 e0       	ldi	r18, 0x00	; 0
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	1f c0       	rjmp	.+62     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
		{
			if (timer != NULL && timer->hasTimedout())
    197c:	89 85       	ldd	r24, Y+9	; 0x09
    197e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1980:	00 97       	sbiw	r24, 0x00	; 0
    1982:	39 f0       	breq	.+14     	; 0x1992 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
    1984:	0e 94 e9 69 	call	0xd3d2	; 0xd3d2 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1988:	88 23       	and	r24, r24
    198a:	19 f0       	breq	.+6      	; 0x1992 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
    198c:	14 c0       	rjmp	.+40     	; 0x19b6 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa2>
			
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
    198e:	08 ec       	ldi	r16, 0xC8	; 200
    1990:	10 e0       	ldi	r17, 0x00	; 0
    1992:	f8 01       	movw	r30, r16
    1994:	80 81       	ld	r24, Z
    1996:	88 23       	and	r24, r24
    1998:	8c f7       	brge	.-30     	; 0x197c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x68>
    199a:	19 c0       	rjmp	.+50     	; 0x19ce <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xba>
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
			{
				status = -2;
    199c:	2e ef       	ldi	r18, 0xFE	; 254
    199e:	3f ef       	ldi	r19, 0xFF	; 255
			//// Stop interrupts
			//cli();
						
				
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR1;
    19a0:	80 91 ce 00 	lds	r24, 0x00CE
    19a4:	f7 01       	movw	r30, r14
    19a6:	80 83       	st	Z, r24
    19a8:	08 c0       	rjmp	.+16     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		if (!status)
		{
			return -1;
		}
		
		return 0;
    19aa:	20 e0       	ldi	r18, 0x00	; 0
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	05 c0       	rjmp	.+10     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		*/
		while ( !(UCSR0A & (1<<RXC0)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    19b0:	2f ef       	ldi	r18, 0xFF	; 255
    19b2:	3f ef       	ldi	r19, 0xFF	; 255
    19b4:	02 c0       	rjmp	.+4      	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		*/
		while ( !(UCSR1A & (1<<RXC1)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    19b6:	2f ef       	ldi	r18, 0xFF	; 255
    19b8:	3f ef       	ldi	r19, 0xFF	; 255
    19ba:	82 2f       	mov	r24, r18
    19bc:	93 2f       	mov	r25, r19
    19be:	0e c0       	rjmp	.+28     	; 0x19dc <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
			* Determine if there has been:
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
    19c0:	80 91 c0 00 	lds	r24, 0x00C0
    19c4:	8c 71       	andi	r24, 0x1C	; 28
    19c6:	71 f6       	brne	.-100    	; 0x1964 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x50>
    19c8:	20 e0       	ldi	r18, 0x00	; 0
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	cd cf       	rjmp	.-102    	; 0x1968 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x54>
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
    19ce:	80 91 c8 00 	lds	r24, 0x00C8
    19d2:	8c 71       	andi	r24, 0x1C	; 28
    19d4:	19 f7       	brne	.-58     	; 0x199c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x88>
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0
    19da:	e2 cf       	rjmp	.-60     	; 0x19a0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x8c>
			//SREG = SREG_tmp;			
		}
	}

	return status;
}
    19dc:	df 91       	pop	r29
    19de:	cf 91       	pop	r28
    19e0:	1f 91       	pop	r17
    19e2:	0f 91       	pop	r16
    19e4:	ff 90       	pop	r15
    19e6:	ef 90       	pop	r14
    19e8:	08 95       	ret

000019ea <_ZN10helicopter7drivers12SerialDriver8transmitEh>:
	
	return status;
}

int SerialDriver::transmit(byte valueToSend)
{
    19ea:	ff 92       	push	r15
    19ec:	0f 93       	push	r16
    19ee:	1f 93       	push	r17
    19f0:	cf 93       	push	r28
    19f2:	df 93       	push	r29
    19f4:	ec 01       	movw	r28, r24
    19f6:	f6 2e       	mov	r15, r22
	
	if (asyncReceiveTransmitData)
    19f8:	88 85       	ldd	r24, Y+8	; 0x08
    19fa:	88 23       	and	r24, r24
    19fc:	39 f0       	breq	.+14     	; 0x1a0c <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x22>
	{
		bool status = transmitBuffer.enqueue(valueToSend);
    19fe:	8e e8       	ldi	r24, 0x8E	; 142
    1a00:	93 e0       	ldi	r25, 0x03	; 3
    1a02:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>

		if (!status)
    1a06:	81 11       	cpse	r24, r1
    1a08:	2d c0       	rjmp	.+90     	; 0x1a64 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x7a>
    1a0a:	29 c0       	rjmp	.+82     	; 0x1a5e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x74>
		
	
	int status = 0;

	
	if (uartPort == Zero)
    1a0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0e:	88 23       	and	r24, r24
    1a10:	51 f0       	breq	.+20     	; 0x1a26 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x3c>
    1a12:	10 c0       	rjmp	.+32     	; 0x1a34 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x4a>

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    1a14:	89 85       	ldd	r24, Y+9	; 0x09
    1a16:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a18:	00 97       	sbiw	r24, 0x00	; 0
    1a1a:	39 f0       	breq	.+14     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x40>
    1a1c:	0e 94 e9 69 	call	0xd3d2	; 0xd3d2 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1a20:	88 23       	and	r24, r24
    1a22:	19 f0       	breq	.+6      	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x40>
    1a24:	22 c0       	rjmp	.+68     	; 0x1a6a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x80>
	
	if (uartPort == Zero)
	{

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    1a26:	00 ec       	ldi	r16, 0xC0	; 192
    1a28:	10 e0       	ldi	r17, 0x00	; 0
    1a2a:	f8 01       	movw	r30, r16
    1a2c:	80 81       	ld	r24, Z
    1a2e:	85 ff       	sbrs	r24, 5
    1a30:	f1 cf       	rjmp	.-30     	; 0x1a14 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x2a>
    1a32:	23 c0       	rjmp	.+70     	; 0x1a7a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x90>
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;
		}

	}else if (uartPort == One)
    1a34:	81 30       	cpi	r24, 0x01	; 1
    1a36:	61 f0       	breq	.+24     	; 0x1a50 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x66>
		return 0;
	}
	
		
	
	int status = 0;
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	1b c0       	rjmp	.+54     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    1a3e:	89 85       	ldd	r24, Y+9	; 0x09
    1a40:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	39 f0       	breq	.+14     	; 0x1a54 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
    1a46:	0e 94 e9 69 	call	0xd3d2	; 0xd3d2 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1a4a:	88 23       	and	r24, r24
    1a4c:	19 f0       	breq	.+6      	; 0x1a54 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
    1a4e:	10 c0       	rjmp	.+32     	; 0x1a70 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x86>
		}

	}else if (uartPort == One)
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
    1a50:	08 ec       	ldi	r16, 0xC8	; 200
    1a52:	10 e0       	ldi	r17, 0x00	; 0
    1a54:	f8 01       	movw	r30, r16
    1a56:	80 81       	ld	r24, Z
    1a58:	85 ff       	sbrs	r24, 5
    1a5a:	f1 cf       	rjmp	.-30     	; 0x1a3e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x54>
    1a5c:	13 c0       	rjmp	.+38     	; 0x1a84 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x9a>
	{
		bool status = transmitBuffer.enqueue(valueToSend);

		if (!status)
		{
			return -1;
    1a5e:	2f ef       	ldi	r18, 0xFF	; 255
    1a60:	3f ef       	ldi	r19, 0xFF	; 255
    1a62:	08 c0       	rjmp	.+16     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		{
			UCSR1B |= (1<<UDRIE1);
		}
		*/
		
		return 0;
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	05 c0       	rjmp	.+10     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		while ( !( UCSR0A & (1<<UDRE0)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1a6a:	2f ef       	ldi	r18, 0xFF	; 255
    1a6c:	3f ef       	ldi	r19, 0xFF	; 255
    1a6e:	02 c0       	rjmp	.+4      	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		while ( !( UCSR1A & (1<<UDRE1)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1a70:	2f ef       	ldi	r18, 0xFF	; 255
    1a72:	3f ef       	ldi	r19, 0xFF	; 255
    1a74:	82 2f       	mov	r24, r18
    1a76:	93 2f       	mov	r25, r19
    1a78:	0a c0       	rjmp	.+20     	; 0x1a8e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0xa4>
//
			//// Stop interrupts
			//cli();
			
			/* Put data into buffer, sends the data */
			UDR0 = valueToSend;			
    1a7a:	f0 92 c6 00 	sts	0x00C6, r15
    1a7e:	20 e0       	ldi	r18, 0x00	; 0
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	f8 cf       	rjmp	.-16     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
//
			//// Stop interrupts
			//cli();
						
			/* Put data into buffer, sends the data */
			UDR1 = valueToSend;
    1a84:	f0 92 ce 00 	sts	0x00CE, r15
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	f3 cf       	rjmp	.-26     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		}		
	}
	

	return status;
}
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	1f 91       	pop	r17
    1a94:	0f 91       	pop	r16
    1a96:	ff 90       	pop	r15
    1a98:	08 95       	ret

00001a9a <_ZN10helicopter7drivers12SerialDriver4initEv>:
		timer->stopTimer();
	}
}

void SerialDriver::init()
{
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	ec 01       	movw	r28, r24
	unsigned int baudPrescaller = 0;
	
	if (useDoubleSpeedMode)
    1aa0:	8f 81       	ldd	r24, Y+7	; 0x07
    1aa2:	88 23       	and	r24, r24
    1aa4:	29 f1       	breq	.+74     	; 0x1af0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x56>
	{
		baudPrescaller = floor((((F_CPU / (baudRate * 8UL))) - 1UL));
    1aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aaa:	ac 81       	ldd	r26, Y+4	; 0x04
    1aac:	bd 81       	ldd	r27, Y+5	; 0x05
    1aae:	88 0f       	add	r24, r24
    1ab0:	99 1f       	adc	r25, r25
    1ab2:	aa 1f       	adc	r26, r26
    1ab4:	bb 1f       	adc	r27, r27
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	aa 1f       	adc	r26, r26
    1abc:	bb 1f       	adc	r27, r27
    1abe:	9c 01       	movw	r18, r24
    1ac0:	ad 01       	movw	r20, r26
    1ac2:	22 0f       	add	r18, r18
    1ac4:	33 1f       	adc	r19, r19
    1ac6:	44 1f       	adc	r20, r20
    1ac8:	55 1f       	adc	r21, r21
    1aca:	60 e0       	ldi	r22, 0x00	; 0
    1acc:	74 e2       	ldi	r23, 0x24	; 36
    1ace:	84 ef       	ldi	r24, 0xF4	; 244
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    1ad6:	ca 01       	movw	r24, r20
    1ad8:	b9 01       	movw	r22, r18
    1ada:	61 50       	subi	r22, 0x01	; 1
    1adc:	71 09       	sbc	r23, r1
    1ade:	81 09       	sbc	r24, r1
    1ae0:	91 09       	sbc	r25, r1
    1ae2:	0e 94 ee 6b 	call	0xd7dc	; 0xd7dc <__floatunsisf>
    1ae6:	0e 94 2b 6c 	call	0xd856	; 0xd856 <floor>
    1aea:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    1aee:	28 c0       	rjmp	.+80     	; 0x1b40 <_ZN10helicopter7drivers12SerialDriver4initEv+0xa6>
	}else
	{
		//Calculation for the baud prescaller 
		baudPrescaller = floor((((F_CPU / (baudRate * 16UL))) - 1UL));
    1af0:	8a 81       	ldd	r24, Y+2	; 0x02
    1af2:	9b 81       	ldd	r25, Y+3	; 0x03
    1af4:	ac 81       	ldd	r26, Y+4	; 0x04
    1af6:	bd 81       	ldd	r27, Y+5	; 0x05
    1af8:	88 0f       	add	r24, r24
    1afa:	99 1f       	adc	r25, r25
    1afc:	aa 1f       	adc	r26, r26
    1afe:	bb 1f       	adc	r27, r27
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	aa 1f       	adc	r26, r26
    1b06:	bb 1f       	adc	r27, r27
    1b08:	9c 01       	movw	r18, r24
    1b0a:	ad 01       	movw	r20, r26
    1b0c:	22 0f       	add	r18, r18
    1b0e:	33 1f       	adc	r19, r19
    1b10:	44 1f       	adc	r20, r20
    1b12:	55 1f       	adc	r21, r21
    1b14:	22 0f       	add	r18, r18
    1b16:	33 1f       	adc	r19, r19
    1b18:	44 1f       	adc	r20, r20
    1b1a:	55 1f       	adc	r21, r21
    1b1c:	60 e0       	ldi	r22, 0x00	; 0
    1b1e:	74 e2       	ldi	r23, 0x24	; 36
    1b20:	84 ef       	ldi	r24, 0xF4	; 244
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    1b28:	ca 01       	movw	r24, r20
    1b2a:	b9 01       	movw	r22, r18
    1b2c:	61 50       	subi	r22, 0x01	; 1
    1b2e:	71 09       	sbc	r23, r1
    1b30:	81 09       	sbc	r24, r1
    1b32:	91 09       	sbc	r25, r1
    1b34:	0e 94 ee 6b 	call	0xd7dc	; 0xd7dc <__floatunsisf>
    1b38:	0e 94 2b 6c 	call	0xd856	; 0xd856 <floor>
    1b3c:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
	}
	
	
	if (uartPort == Zero)
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
    1b42:	81 11       	cpse	r24, r1
    1b44:	20 c0       	rjmp	.+64     	; 0x1b86 <_ZN10helicopter7drivers12SerialDriver4initEv+0xec>
	{
		/* Set baud rate */
		UBRR0 = baudPrescaller;
    1b46:	70 93 c5 00 	sts	0x00C5, r23
    1b4a:	60 93 c4 00 	sts	0x00C4, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);
    1b4e:	e2 ec       	ldi	r30, 0xC2	; 194
    1b50:	f0 e0       	ldi	r31, 0x00	; 0
    1b52:	80 81       	ld	r24, Z
    1b54:	86 60       	ori	r24, 0x06	; 6
    1b56:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    1b58:	8f 81       	ldd	r24, Y+7	; 0x07
    1b5a:	88 23       	and	r24, r24
    1b5c:	31 f0       	breq	.+12     	; 0x1b6a <_ZN10helicopter7drivers12SerialDriver4initEv+0xd0>
		{
			UCSR0A |= (1<<U2X0);
    1b5e:	e0 ec       	ldi	r30, 0xC0	; 192
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	80 81       	ld	r24, Z
    1b64:	82 60       	ori	r24, 0x02	; 2
    1b66:	80 83       	st	Z, r24
    1b68:	05 c0       	rjmp	.+10     	; 0x1b74 <_ZN10helicopter7drivers12SerialDriver4initEv+0xda>
		}else
		{
			UCSR0A &= ~(1<<U2X0);
    1b6a:	e0 ec       	ldi	r30, 0xC0	; 192
    1b6c:	f0 e0       	ldi	r31, 0x00	; 0
    1b6e:	80 81       	ld	r24, Z
    1b70:	8d 7f       	andi	r24, 0xFD	; 253
    1b72:	80 83       	st	Z, r24
		}
		
		//The spec says to set this flag to 0 whenever UCSR0A is set if you are going to be using it.  
		UCSR0B &= ~(1<<UDRIE0);
    1b74:	e1 ec       	ldi	r30, 0xC1	; 193
    1b76:	f0 e0       	ldi	r31, 0x00	; 0
    1b78:	80 81       	ld	r24, Z
    1b7a:	8f 7d       	andi	r24, 0xDF	; 223
    1b7c:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR0B |= (1<<RXEN0) | (1<<TXEN0);
    1b7e:	80 81       	ld	r24, Z
    1b80:	88 61       	ori	r24, 0x18	; 24
    1b82:	80 83       	st	Z, r24
    1b84:	21 c0       	rjmp	.+66     	; 0x1bc8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	} else if (uartPort == One)
    1b86:	81 30       	cpi	r24, 0x01	; 1
    1b88:	f9 f4       	brne	.+62     	; 0x1bc8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	{	
		
				
		/* Set baud rate */
		UBRR1 = baudPrescaller;
    1b8a:	70 93 cd 00 	sts	0x00CD, r23
    1b8e:	60 93 cc 00 	sts	0x00CC, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR1C |= (1<<UCSZ11)|(1<<UCSZ10);
    1b92:	ea ec       	ldi	r30, 0xCA	; 202
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	80 81       	ld	r24, Z
    1b98:	86 60       	ori	r24, 0x06	; 6
    1b9a:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    1b9c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b9e:	88 23       	and	r24, r24
    1ba0:	31 f0       	breq	.+12     	; 0x1bae <_ZN10helicopter7drivers12SerialDriver4initEv+0x114>
		{
			UCSR1A |= (1<<U2X1);
    1ba2:	e8 ec       	ldi	r30, 0xC8	; 200
    1ba4:	f0 e0       	ldi	r31, 0x00	; 0
    1ba6:	80 81       	ld	r24, Z
    1ba8:	82 60       	ori	r24, 0x02	; 2
    1baa:	80 83       	st	Z, r24
    1bac:	05 c0       	rjmp	.+10     	; 0x1bb8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x11e>
		}else
		{
			UCSR1A &= ~(1<<U2X1);
    1bae:	e8 ec       	ldi	r30, 0xC8	; 200
    1bb0:	f0 e0       	ldi	r31, 0x00	; 0
    1bb2:	80 81       	ld	r24, Z
    1bb4:	8d 7f       	andi	r24, 0xFD	; 253
    1bb6:	80 83       	st	Z, r24
		}
		
		UCSR1B &= ~(1<<UDRIE1);
    1bb8:	e9 ec       	ldi	r30, 0xC9	; 201
    1bba:	f0 e0       	ldi	r31, 0x00	; 0
    1bbc:	80 81       	ld	r24, Z
    1bbe:	8f 7d       	andi	r24, 0xDF	; 223
    1bc0:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR1B |= (1<<RXEN1) | (1<<TXEN1);		
    1bc2:	80 81       	ld	r24, Z
    1bc4:	88 61       	ori	r24, 0x18	; 24
    1bc6:	80 83       	st	Z, r24
	}
	
	
	if (asyncReceiveTransmitData)
    1bc8:	88 85       	ldd	r24, Y+8	; 0x08
    1bca:	88 23       	and	r24, r24
    1bcc:	91 f0       	breq	.+36     	; 0x1bf2 <_ZN10helicopter7drivers12SerialDriver4initEv+0x158>
	{
		cli();
    1bce:	f8 94       	cli
		//enable interrupts for asynchronously receiving/transmitting data. 
		if (uartPort == Zero)
    1bd0:	8e 81       	ldd	r24, Y+6	; 0x06
    1bd2:	81 11       	cpse	r24, r1
    1bd4:	06 c0       	rjmp	.+12     	; 0x1be2 <_ZN10helicopter7drivers12SerialDriver4initEv+0x148>
		{
			UCSR0B |= (1<<RXCIE0);
    1bd6:	e1 ec       	ldi	r30, 0xC1	; 193
    1bd8:	f0 e0       	ldi	r31, 0x00	; 0
    1bda:	80 81       	ld	r24, Z
    1bdc:	80 68       	ori	r24, 0x80	; 128
    1bde:	80 83       	st	Z, r24
    1be0:	07 c0       	rjmp	.+14     	; 0x1bf0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		}
		else if (uartPort == One)
    1be2:	81 30       	cpi	r24, 0x01	; 1
    1be4:	29 f4       	brne	.+10     	; 0x1bf0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		{
			UCSR1B |= (1<<RXCIE1);
    1be6:	e9 ec       	ldi	r30, 0xC9	; 201
    1be8:	f0 e0       	ldi	r31, 0x00	; 0
    1bea:	80 81       	ld	r24, Z
    1bec:	80 68       	ori	r24, 0x80	; 128
    1bee:	80 83       	st	Z, r24
		}
		
		sei();
    1bf0:	78 94       	sei
	}
}
    1bf2:	df 91       	pop	r29
    1bf4:	cf 91       	pop	r28
    1bf6:	08 95       	ret

00001bf8 <_ZN10helicopter7drivers12SerialDriverD0Ev>:
    1bf8:	22 e1       	ldi	r18, 0x12	; 18
    1bfa:	32 e0       	ldi	r19, 0x02	; 2
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	31 83       	std	Z+1, r19	; 0x01
    1c00:	20 83       	st	Z, r18
					
				}
    1c02:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    1c06:	08 95       	ret

00001c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>:
				int headIndex;
				int tailIndex;
				int bytesInQueue;
			
			public:
				CircularBuffer(int bufferSize) :  buffer(NULL), bufferSize(bufferSize), headIndex(0), tailIndex(0), bytesInQueue(0)
    1c08:	0f 93       	push	r16
    1c0a:	1f 93       	push	r17
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24
    1c12:	06 2f       	mov	r16, r22
    1c14:	17 2f       	mov	r17, r23
    1c16:	19 82       	std	Y+1, r1	; 0x01
    1c18:	18 82       	st	Y, r1
    1c1a:	6a 83       	std	Y+2, r22	; 0x02
    1c1c:	7b 83       	std	Y+3, r23	; 0x03
    1c1e:	1d 82       	std	Y+5, r1	; 0x05
    1c20:	1c 82       	std	Y+4, r1	; 0x04
    1c22:	1f 82       	std	Y+7, r1	; 0x07
    1c24:	1e 82       	std	Y+6, r1	; 0x06
    1c26:	19 86       	std	Y+9, r1	; 0x09
    1c28:	18 86       	std	Y+8, r1	; 0x08
				{
					buffer = new byte[bufferSize];
    1c2a:	86 2f       	mov	r24, r22
    1c2c:	97 2f       	mov	r25, r23
    1c2e:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    1c32:	88 83       	st	Y, r24
    1c34:	99 83       	std	Y+1, r25	; 0x01
					
					memset(buffer, 0, bufferSize);
    1c36:	40 2f       	mov	r20, r16
    1c38:	51 2f       	mov	r21, r17
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	70 e0       	ldi	r23, 0x00	; 0
    1c3e:	0e 94 6e 71 	call	0xe2dc	; 0xe2dc <memset>
				}
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	1f 91       	pop	r17
    1c48:	0f 91       	pop	r16
    1c4a:	08 95       	ret

00001c4c <_Z41__static_initialization_and_destruction_0ii>:
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR1B &= ~(1<<UDRIE1);
	}	
    1c4c:	81 30       	cpi	r24, 0x01	; 1
    1c4e:	91 05       	cpc	r25, r1
    1c50:	81 f4       	brne	.+32     	; 0x1c72 <_Z41__static_initialization_and_destruction_0ii+0x26>
    1c52:	6f 3f       	cpi	r22, 0xFF	; 255
    1c54:	7f 4f       	sbci	r23, 0xFF	; 255
    1c56:	11 f5       	brne	.+68     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
#include "SerialDriver.h"
#include "CommonHeader.h"

using namespace helicopter::drivers;

CircularBuffer SerialDriver::receiveBuffer(1000);
    1c58:	68 ee       	ldi	r22, 0xE8	; 232
    1c5a:	73 e0       	ldi	r23, 0x03	; 3
    1c5c:	88 e9       	ldi	r24, 0x98	; 152
    1c5e:	93 e0       	ldi	r25, 0x03	; 3
    1c60:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>
CircularBuffer SerialDriver::transmitBuffer(1000);
    1c64:	68 ee       	ldi	r22, 0xE8	; 232
    1c66:	73 e0       	ldi	r23, 0x03	; 3
    1c68:	8e e8       	ldi	r24, 0x8E	; 142
    1c6a:	93 e0       	ldi	r25, 0x03	; 3
    1c6c:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>
    1c70:	08 95       	ret
    1c72:	89 2b       	or	r24, r25
    1c74:	99 f4       	brne	.+38     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
    1c76:	6f 3f       	cpi	r22, 0xFF	; 255
    1c78:	7f 4f       	sbci	r23, 0xFF	; 255
    1c7a:	81 f4       	brne	.+32     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
				~CircularBuffer()
				{
					delete [] buffer;
    1c7c:	80 91 8e 03 	lds	r24, 0x038E
    1c80:	90 91 8f 03 	lds	r25, 0x038F
    1c84:	00 97       	sbiw	r24, 0x00	; 0
    1c86:	11 f0       	breq	.+4      	; 0x1c8c <_Z41__static_initialization_and_destruction_0ii+0x40>
    1c88:	0e 94 8d 64 	call	0xc91a	; 0xc91a <_ZdaPv>
    1c8c:	80 91 98 03 	lds	r24, 0x0398
    1c90:	90 91 99 03 	lds	r25, 0x0399
    1c94:	00 97       	sbiw	r24, 0x00	; 0
    1c96:	11 f0       	breq	.+4      	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
    1c98:	0e 94 8d 64 	call	0xc91a	; 0xc91a <_ZdaPv>
    1c9c:	08 95       	ret

00001c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>:

void SerialDriver::startTimer()
{
	if (timer != NULL)
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	81 85       	ldd	r24, Z+9	; 0x09
    1ca2:	92 85       	ldd	r25, Z+10	; 0x0a
    1ca4:	00 97       	sbiw	r24, 0x00	; 0
    1ca6:	11 f0       	breq	.+4      	; 0x1cac <_ZN10helicopter7drivers12SerialDriver10startTimerEv+0xe>
	{
		timer->startTimer();
    1ca8:	0e 94 04 6a 	call	0xd408	; 0xd408 <_ZN10helicopter4util5Timer10startTimerEv>
    1cac:	08 95       	ret

00001cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>:
	
}

void SerialDriver::stopTimer()
{
	if (timer != NULL)
    1cae:	fc 01       	movw	r30, r24
    1cb0:	81 85       	ldd	r24, Z+9	; 0x09
    1cb2:	92 85       	ldd	r25, Z+10	; 0x0a
    1cb4:	00 97       	sbiw	r24, 0x00	; 0
    1cb6:	11 f0       	breq	.+4      	; 0x1cbc <_ZN10helicopter7drivers12SerialDriver9stopTimerEv+0xe>
	{
		timer->stopTimer();
    1cb8:	0e 94 f7 69 	call	0xd3ee	; 0xd3ee <_ZN10helicopter4util5Timer9stopTimerEv>
    1cbc:	08 95       	ret

00001cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>:
	
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
    1cbe:	cf 92       	push	r12
    1cc0:	df 92       	push	r13
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	6c 01       	movw	r12, r24
    1cd0:	8a 01       	movw	r16, r20
    1cd2:	e6 2e       	mov	r14, r22
    1cd4:	f7 2e       	mov	r15, r23
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1cd6:	c0 e0       	ldi	r28, 0x00	; 0
    1cd8:	d0 e0       	ldi	r29, 0x00	; 0
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;
    1cda:	20 e0       	ldi	r18, 0x00	; 0
    1cdc:	30 e0       	ldi	r19, 0x00	; 0

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1cde:	c0 17       	cp	r28, r16
    1ce0:	d1 07       	cpc	r29, r17
    1ce2:	1c f4       	brge	.+6      	; 0x1cea <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x2c>
    1ce4:	21 15       	cp	r18, r1
    1ce6:	31 05       	cpc	r19, r1
    1ce8:	19 f0       	breq	.+6      	; 0x1cf0 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x32>
	{
		status = transmit((byte) buffer[i]);
	}
	
	return status;
    1cea:	82 2f       	mov	r24, r18
    1cec:	93 2f       	mov	r25, r19
    1cee:	0e c0       	rjmp	.+28     	; 0x1d0c <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x4e>
{
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
	{
		status = transmit((byte) buffer[i]);
    1cf0:	d7 01       	movw	r26, r14
    1cf2:	6d 91       	ld	r22, X+
    1cf4:	7d 01       	movw	r14, r26
    1cf6:	d6 01       	movw	r26, r12
    1cf8:	ed 91       	ld	r30, X+
    1cfa:	fc 91       	ld	r31, X
    1cfc:	06 80       	ldd	r0, Z+6	; 0x06
    1cfe:	f7 81       	ldd	r31, Z+7	; 0x07
    1d00:	e0 2d       	mov	r30, r0
    1d02:	c6 01       	movw	r24, r12
    1d04:	19 95       	eicall
    1d06:	9c 01       	movw	r18, r24

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1d08:	21 96       	adiw	r28, 0x01	; 1
    1d0a:	e9 cf       	rjmp	.-46     	; 0x1cde <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x20>
	{
		status = transmit((byte) buffer[i]);
	}
	
	return status;
}
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	1f 91       	pop	r17
    1d12:	0f 91       	pop	r16
    1d14:	ff 90       	pop	r15
    1d16:	ef 90       	pop	r14
    1d18:	df 90       	pop	r13
    1d1a:	cf 90       	pop	r12
    1d1c:	08 95       	ret

00001d1e <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>:

void SerialDriver::clearBuffer()
{
	byte dummy = 0;
	
	if (uartPort == Zero)
    1d1e:	fc 01       	movw	r30, r24
    1d20:	86 81       	ldd	r24, Z+6	; 0x06
    1d22:	81 11       	cpse	r24, r1
    1d24:	0d c0       	rjmp	.+26     	; 0x1d40 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x22>
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d26:	80 91 c0 00 	lds	r24, 0x00C0
    1d2a:	88 23       	and	r24, r24
    1d2c:	bc f4       	brge	.+46     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR0;
    1d2e:	a6 ec       	ldi	r26, 0xC6	; 198
    1d30:	b0 e0       	ldi	r27, 0x00	; 0
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d32:	e0 ec       	ldi	r30, 0xC0	; 192
    1d34:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR0;
    1d36:	8c 91       	ld	r24, X
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d38:	80 81       	ld	r24, Z
    1d3a:	88 23       	and	r24, r24
    1d3c:	e4 f3       	brlt	.-8      	; 0x1d36 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x18>
    1d3e:	08 95       	ret
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
    1d40:	81 30       	cpi	r24, 0x01	; 1
    1d42:	61 f4       	brne	.+24     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
	{
		while (UCSR1A & (1<<RXC1) )
    1d44:	80 91 c8 00 	lds	r24, 0x00C8
    1d48:	88 23       	and	r24, r24
    1d4a:	44 f4       	brge	.+16     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR1;
    1d4c:	ae ec       	ldi	r26, 0xCE	; 206
    1d4e:	b0 e0       	ldi	r27, 0x00	; 0
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1d50:	e8 ec       	ldi	r30, 0xC8	; 200
    1d52:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR1;
    1d54:	8c 91       	ld	r24, X
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1d56:	80 81       	ld	r24, Z
    1d58:	88 23       	and	r24, r24
    1d5a:	e4 f3       	brlt	.-8      	; 0x1d54 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x36>
    1d5c:	08 95       	ret

00001d5e <__vector_25>:
}


//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART0_RX_vect)
{
    1d5e:	1f 92       	push	r1
    1d60:	0f 92       	push	r0
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	0f 92       	push	r0
    1d66:	11 24       	eor	r1, r1
    1d68:	0b b6       	in	r0, 0x3b	; 59
    1d6a:	0f 92       	push	r0
    1d6c:	2f 93       	push	r18
    1d6e:	3f 93       	push	r19
    1d70:	4f 93       	push	r20
    1d72:	5f 93       	push	r21
    1d74:	6f 93       	push	r22
    1d76:	7f 93       	push	r23
    1d78:	8f 93       	push	r24
    1d7a:	9f 93       	push	r25
    1d7c:	af 93       	push	r26
    1d7e:	bf 93       	push	r27
    1d80:	ef 93       	push	r30
    1d82:	ff 93       	push	r31
{
	PORTA &= ~(1<<PA5);
}	
*/		
			
	byte b = UDR0;
    1d84:	60 91 c6 00 	lds	r22, 0x00C6
	SerialDriver::receiveBuffer.enqueueInt(b);
    1d88:	88 e9       	ldi	r24, 0x98	; 152
    1d8a:	93 e0       	ldi	r25, 0x03	; 3
    1d8c:	0e 94 19 02 	call	0x432	; 0x432 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>
}
    1d90:	ff 91       	pop	r31
    1d92:	ef 91       	pop	r30
    1d94:	bf 91       	pop	r27
    1d96:	af 91       	pop	r26
    1d98:	9f 91       	pop	r25
    1d9a:	8f 91       	pop	r24
    1d9c:	7f 91       	pop	r23
    1d9e:	6f 91       	pop	r22
    1da0:	5f 91       	pop	r21
    1da2:	4f 91       	pop	r20
    1da4:	3f 91       	pop	r19
    1da6:	2f 91       	pop	r18
    1da8:	0f 90       	pop	r0
    1daa:	0b be       	out	0x3b, r0	; 59
    1dac:	0f 90       	pop	r0
    1dae:	0f be       	out	0x3f, r0	; 63
    1db0:	0f 90       	pop	r0
    1db2:	1f 90       	pop	r1
    1db4:	18 95       	reti

00001db6 <__vector_26>:

ISR(USART0_UDRE_vect)
{
    1db6:	1f 92       	push	r1
    1db8:	0f 92       	push	r0
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	0f 92       	push	r0
    1dbe:	11 24       	eor	r1, r1
    1dc0:	0b b6       	in	r0, 0x3b	; 59
    1dc2:	0f 92       	push	r0
    1dc4:	2f 93       	push	r18
    1dc6:	3f 93       	push	r19
    1dc8:	4f 93       	push	r20
    1dca:	5f 93       	push	r21
    1dcc:	6f 93       	push	r22
    1dce:	7f 93       	push	r23
    1dd0:	8f 93       	push	r24
    1dd2:	9f 93       	push	r25
    1dd4:	af 93       	push	r26
    1dd6:	bf 93       	push	r27
    1dd8:	ef 93       	push	r30
    1dda:	ff 93       	push	r31
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    1de0:	1f 92       	push	r1
    1de2:	cd b7       	in	r28, 0x3d	; 61
    1de4:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1de6:	be 01       	movw	r22, r28
    1de8:	6f 5f       	subi	r22, 0xFF	; 255
    1dea:	7f 4f       	sbci	r23, 0xFF	; 255
    1dec:	8e e8       	ldi	r24, 0x8E	; 142
    1dee:	93 e0       	ldi	r25, 0x03	; 3
    1df0:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1df4:	88 23       	and	r24, r24
    1df6:	21 f0       	breq	.+8      	; 0x1e00 <__vector_26+0x4a>
	{
		UDR0 = val;
    1df8:	89 81       	ldd	r24, Y+1	; 0x01
    1dfa:	80 93 c6 00 	sts	0x00C6, r24
    1dfe:	05 c0       	rjmp	.+10     	; 0x1e0a <__vector_26+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR0B &= ~(1<<UDRIE0);
    1e00:	e1 ec       	ldi	r30, 0xC1	; 193
    1e02:	f0 e0       	ldi	r31, 0x00	; 0
    1e04:	80 81       	ld	r24, Z
    1e06:	8f 7d       	andi	r24, 0xDF	; 223
    1e08:	80 83       	st	Z, r24
	}
}
    1e0a:	0f 90       	pop	r0
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	ff 91       	pop	r31
    1e12:	ef 91       	pop	r30
    1e14:	bf 91       	pop	r27
    1e16:	af 91       	pop	r26
    1e18:	9f 91       	pop	r25
    1e1a:	8f 91       	pop	r24
    1e1c:	7f 91       	pop	r23
    1e1e:	6f 91       	pop	r22
    1e20:	5f 91       	pop	r21
    1e22:	4f 91       	pop	r20
    1e24:	3f 91       	pop	r19
    1e26:	2f 91       	pop	r18
    1e28:	0f 90       	pop	r0
    1e2a:	0b be       	out	0x3b, r0	; 59
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	0f 90       	pop	r0
    1e32:	1f 90       	pop	r1
    1e34:	18 95       	reti

00001e36 <__vector_37>:
ISR(USART1_UDRE_vect)
{
    1e36:	1f 92       	push	r1
    1e38:	0f 92       	push	r0
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	0f 92       	push	r0
    1e3e:	11 24       	eor	r1, r1
    1e40:	0b b6       	in	r0, 0x3b	; 59
    1e42:	0f 92       	push	r0
    1e44:	2f 93       	push	r18
    1e46:	3f 93       	push	r19
    1e48:	4f 93       	push	r20
    1e4a:	5f 93       	push	r21
    1e4c:	6f 93       	push	r22
    1e4e:	7f 93       	push	r23
    1e50:	8f 93       	push	r24
    1e52:	9f 93       	push	r25
    1e54:	af 93       	push	r26
    1e56:	bf 93       	push	r27
    1e58:	ef 93       	push	r30
    1e5a:	ff 93       	push	r31
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	1f 92       	push	r1
    1e62:	cd b7       	in	r28, 0x3d	; 61
    1e64:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1e66:	be 01       	movw	r22, r28
    1e68:	6f 5f       	subi	r22, 0xFF	; 255
    1e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e6c:	8e e8       	ldi	r24, 0x8E	; 142
    1e6e:	93 e0       	ldi	r25, 0x03	; 3
    1e70:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1e74:	88 23       	and	r24, r24
    1e76:	21 f0       	breq	.+8      	; 0x1e80 <__vector_37+0x4a>
	{
		UDR1 = val;
    1e78:	89 81       	ldd	r24, Y+1	; 0x01
    1e7a:	80 93 ce 00 	sts	0x00CE, r24
    1e7e:	05 c0       	rjmp	.+10     	; 0x1e8a <__vector_37+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR1B &= ~(1<<UDRIE1);
    1e80:	e9 ec       	ldi	r30, 0xC9	; 201
    1e82:	f0 e0       	ldi	r31, 0x00	; 0
    1e84:	80 81       	ld	r24, Z
    1e86:	8f 7d       	andi	r24, 0xDF	; 223
    1e88:	80 83       	st	Z, r24
	}	
    1e8a:	0f 90       	pop	r0
    1e8c:	df 91       	pop	r29
    1e8e:	cf 91       	pop	r28
    1e90:	ff 91       	pop	r31
    1e92:	ef 91       	pop	r30
    1e94:	bf 91       	pop	r27
    1e96:	af 91       	pop	r26
    1e98:	9f 91       	pop	r25
    1e9a:	8f 91       	pop	r24
    1e9c:	7f 91       	pop	r23
    1e9e:	6f 91       	pop	r22
    1ea0:	5f 91       	pop	r21
    1ea2:	4f 91       	pop	r20
    1ea4:	3f 91       	pop	r19
    1ea6:	2f 91       	pop	r18
    1ea8:	0f 90       	pop	r0
    1eaa:	0b be       	out	0x3b, r0	; 59
    1eac:	0f 90       	pop	r0
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	0f 90       	pop	r0
    1eb2:	1f 90       	pop	r1
    1eb4:	18 95       	reti

00001eb6 <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
    1eb6:	6f ef       	ldi	r22, 0xFF	; 255
    1eb8:	7f ef       	ldi	r23, 0xFF	; 255
    1eba:	81 e0       	ldi	r24, 0x01	; 1
    1ebc:	90 e0       	ldi	r25, 0x00	; 0
    1ebe:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <_Z41__static_initialization_and_destruction_0ii>
    1ec2:	08 95       	ret

00001ec4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
    1ec4:	6f ef       	ldi	r22, 0xFF	; 255
    1ec6:	7f ef       	ldi	r23, 0xFF	; 255
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <_Z41__static_initialization_and_destruction_0ii>
    1ed0:	08 95       	ret

00001ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>:
{
	/**
	* Configure the MOSI (DDB2) pin, SCK (DDB1), and SS (DDB0) pin (the SS pin for the accelerometer/IMU)
	* as output
	*/
	DDRB = (1<<DDB2) | (1<<DDB1) | (1<<DDB0);
    1ed2:	87 e0       	ldi	r24, 0x07	; 7
    1ed4:	84 b9       	out	0x04, r24	; 4
	
	/**
	 * Configure the SS pin for the barometer as output
	 */
	DDRG |= (1<<DDG1);
    1ed6:	99 9a       	sbi	0x13, 1	; 19
	//Set the slave select lines 'high', therefore freeing up the SPI line. (This would otherwise default to 0, making this device
	//hold onto the SPI line). This turns the line 'off' to 'end' any current transactions. These lines
	//default to low (active) so they have to be pulled high in order to free up the SS lines so a device
	//can communicate on the line.
	//Note: Slave Select for the IMU (accelerometer, etc) is PB0, while slave select for the barometer is PG1.
	PORTB |= (1<<PB0);
    1ed8:	28 9a       	sbi	0x05, 0	; 5
	PORTG |= (1<<PG1);
    1eda:	a1 9a       	sbi	0x14, 1	; 20
	 * SPI Control Register (SPCR)
	 * Enable SPI (1<<SPE)
	 * Set this device as the master device on the SPI line (1<<MSTR)
	 * Set clock frequency to Fosc / 16 (1<<SPR0) (clock speed divided by 16)
	 */
	SPCR |= (1<<SPE) | (1<<MSTR) | (1<<SPR0);
    1edc:	8c b5       	in	r24, 0x2c	; 44
    1ede:	81 65       	ori	r24, 0x51	; 81
    1ee0:	8c bd       	out	0x2c, r24	; 44
    1ee2:	08 95       	ret

00001ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>:
{
	/**
	* Set the Slave Select to 0 indicating that the master will be sending
	* data across the SPI line.
	*/
	if (ssLine == SPIDriver::SS_B)
    1ee4:	fc 01       	movw	r30, r24
    1ee6:	80 81       	ld	r24, Z
    1ee8:	81 30       	cpi	r24, 0x01	; 1
    1eea:	11 f4       	brne	.+4      	; 0x1ef0 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0xc>
	{	
		PORTB &= ~(1<<PB0);
    1eec:	28 98       	cbi	0x05, 0	; 5
    1eee:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1ef0:	82 30       	cpi	r24, 0x02	; 2
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0x12>
	{
		PORTG &= ~(1<<PG1);
    1ef4:	a1 98       	cbi	0x14, 1	; 20
    1ef6:	08 95       	ret

00001ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>:
{
	/**
	 * Set the Slave Select line to 1 indicating that the master
	 * is finished communicating (release the SPI line)
	 */
	if (ssLine == SPIDriver::SS_B)
    1ef8:	fc 01       	movw	r30, r24
    1efa:	80 81       	ld	r24, Z
    1efc:	81 30       	cpi	r24, 0x01	; 1
    1efe:	11 f4       	brne	.+4      	; 0x1f04 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0xc>
	{	
		PORTB |= (1<<PB0);	
    1f00:	28 9a       	sbi	0x05, 0	; 5
    1f02:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1f04:	82 30       	cpi	r24, 0x02	; 2
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0x12>
	{
		PORTG |= (1<<PG1);	
    1f08:	a1 9a       	sbi	0x14, 1	; 20
    1f0a:	08 95       	ret

00001f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>:
	 * we are communicating with, uses the same clock cycles that are used
	 * to push each bit in the message we put into the register, to send
	 * this device data. 1 clock cycle used to push data to the device
	 * is also used to push data to THIS device.
	 */
	SPDR = 0;
    1f0c:	1e bc       	out	0x2e, r1	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1f0e:	0d b4       	in	r0, 0x2d	; 45
    1f10:	07 fe       	sbrs	r0, 7
    1f12:	fd cf       	rjmp	.-6      	; 0x1f0e <_ZN10helicopter7drivers9SPIDriver8readByteEv+0x2>
	
	/**
	 * Return the value of SPDR because now the data register
	 * contains the data that was sent to us by the device.
	 */
	return SPDR;
    1f14:	8e b5       	in	r24, 0x2e	; 46
}
    1f16:	08 95       	ret

00001f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>:
	
	return  ((int) highByte<<8) | lowByte;
}

unsigned int SPIDriver::readUInt()
{
    1f18:	1f 93       	push	r17
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1f20:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1f24:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1f26:	ce 01       	movw	r24, r28
    1f28:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	//
	//return hb | lb;
	
	unsigned int returnValue = 0;
	
	returnValue = (highByte << 8) | lowByte;
    1f2c:	20 e0       	ldi	r18, 0x00	; 0
    1f2e:	28 2b       	or	r18, r24
	
	return returnValue;
	
	
//	return  (((unsigned int) highByte)<<8) | lowByte;
}
    1f30:	82 2f       	mov	r24, r18
    1f32:	91 2f       	mov	r25, r17
    1f34:	df 91       	pop	r29
    1f36:	cf 91       	pop	r28
    1f38:	1f 91       	pop	r17
    1f3a:	08 95       	ret

00001f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>:
		PORTG |= (1<<PG1);	
	}
}

int SPIDriver::readInt()
{
    1f3c:	1f 93       	push	r17
    1f3e:	cf 93       	push	r28
    1f40:	df 93       	push	r29
    1f42:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1f44:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1f48:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	
	return  ((int) highByte<<8) | lowByte;
    1f50:	20 e0       	ldi	r18, 0x00	; 0
    1f52:	28 2b       	or	r18, r24
}
    1f54:	82 2f       	mov	r24, r18
    1f56:	91 2f       	mov	r25, r17
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	1f 91       	pop	r17
    1f5e:	08 95       	ret

00001f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>:
void SPIDriver::write( byte data )
{
	/**
	 * Write the byte to SPI Data Register
	 */
	SPDR = data;
    1f60:	6e bd       	out	0x2e, r22	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1f62:	0d b4       	in	r0, 0x2d	; 45
    1f64:	07 fe       	sbrs	r0, 7
    1f66:	fd cf       	rjmp	.-6      	; 0x1f62 <_ZN10helicopter7drivers9SPIDriver5writeEh+0x2>
}
    1f68:	08 95       	ret

00001f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>:

void SPIDriver::transactionWrite( byte data )
{
    1f6a:	1f 93       	push	r17
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
    1f70:	ec 01       	movw	r28, r24
    1f72:	16 2f       	mov	r17, r22
	beginTransaction();
    1f74:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(data);
    1f78:	61 2f       	mov	r22, r17
    1f7a:	ce 01       	movw	r24, r28
    1f7c:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1f80:	ce 01       	movw	r24, r28
    1f82:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	1f 91       	pop	r17
    1f8c:	08 95       	ret

00001f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>:
	write(commandAddress);
	write(commandValue);
}

void SPIDriver::transactionWrite( byte commandAddress, byte commandValue )
{
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	cf 93       	push	r28
    1f94:	df 93       	push	r29
    1f96:	ec 01       	movw	r28, r24
    1f98:	06 2f       	mov	r16, r22
    1f9a:	14 2f       	mov	r17, r20
	beginTransaction();
    1f9c:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(commandAddress);
    1fa0:	60 2f       	mov	r22, r16
    1fa2:	ce 01       	movw	r24, r28
    1fa4:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	write(commandValue);
    1fa8:	61 2f       	mov	r22, r17
    1faa:	ce 01       	movw	r24, r28
    1fac:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1fb0:	ce 01       	movw	r24, r28
    1fb2:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	08 95       	ret

00001fc0 <_ZN10helicopter7drivers9TWIDriver4initEv>:
	 * because if you run it in conjunction with the servo radio controller, it'll cause the wait for twint to wait forever
	 * if you don't set up the bit rate.
	 */	
	
	//Set the data line and clock line to output. 
	DDRD |= (1<<PD0);
    1fc0:	50 9a       	sbi	0x0a, 0	; 10
	DDRD |= (1<<PD1);
    1fc2:	51 9a       	sbi	0x0a, 1	; 10

	//Set the prescaler for twi to 1
	TWSR &= ~(1<<TWPS0);
    1fc4:	e9 eb       	ldi	r30, 0xB9	; 185
    1fc6:	f0 e0       	ldi	r31, 0x00	; 0
    1fc8:	80 81       	ld	r24, Z
    1fca:	8e 7f       	andi	r24, 0xFE	; 254
    1fcc:	80 83       	st	Z, r24
	TWSR &= ~(1<<TWPS1);
    1fce:	80 81       	ld	r24, Z
    1fd0:	8d 7f       	andi	r24, 0xFD	; 253
    1fd2:	80 83       	st	Z, r24

	//set the bit rate (page 248 of atmega2560 data sheet)
	//this is 200khz clock rate. 
	//equation is here http://www.ermicro.com/blog/?p=744
	//SCL freq = cpu clock freq / (16 + 2(TWBR) * prescaler)
	TWBR = ((16000000UL / 400000UL) - 16UL) / 2UL;
    1fd4:	8c e0       	ldi	r24, 0x0C	; 12
    1fd6:	80 93 b8 00 	sts	0x00B8, r24
    1fda:	08 95       	ret

00001fdc <_ZN10helicopter7drivers9TWIDriver5startEv>:
}

bool TWIDriver::start()
{
	//Send the Start condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    1fdc:	84 ea       	ldi	r24, 0xA4	; 164
    1fde:	80 93 bc 00 	sts	0x00BC, r24
    1fe2:	84 e6       	ldi	r24, 0x64	; 100
    1fe4:	90 e0       	ldi	r25, 0x00	; 0

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1fe6:	ec eb       	ldi	r30, 0xBC	; 188
    1fe8:	f0 e0       	ldi	r31, 0x00	; 0
    1fea:	20 81       	ld	r18, Z
    1fec:	22 23       	and	r18, r18
    1fee:	bc f4       	brge	.+46     	; 0x201e <_ZN10helicopter7drivers9TWIDriver5startEv+0x42>
    1ff0:	11 c0       	rjmp	.+34     	; 0x2014 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
	}
	
	
	
	//Verify that start condition was successfully sent.
	int status = TWSR & 0xF8;
    1ff2:	20 91 b9 00 	lds	r18, 0x00B9
    1ff6:	28 7f       	andi	r18, 0xF8	; 248
    1ff8:	30 e0       	ldi	r19, 0x00	; 0
	
	if (status == START ||
    1ffa:	28 30       	cpi	r18, 0x08	; 8
    1ffc:	31 05       	cpc	r19, r1
    1ffe:	31 f0       	breq	.+12     	; 0x200c <_ZN10helicopter7drivers9TWIDriver5startEv+0x30>
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	20 31       	cpi	r18, 0x10	; 16
    2004:	31 05       	cpc	r19, r1
    2006:	71 f0       	breq	.+28     	; 0x2024 <_ZN10helicopter7drivers9TWIDriver5startEv+0x48>
    2008:	80 e0       	ldi	r24, 0x00	; 0
    200a:	08 95       	ret
	 status == REPEATED_START)
	{	
		return true;
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    2010:	80 e0       	ldi	r24, 0x00	; 0
    2012:	08 95       	ret
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    2014:	80 91 bc 00 	lds	r24, 0x00BC
    2018:	88 23       	and	r24, r24
    201a:	d4 f7       	brge	.-12     	; 0x2010 <_ZN10helicopter7drivers9TWIDriver5startEv+0x34>
    201c:	ea cf       	rjmp	.-44     	; 0x1ff2 <_ZN10helicopter7drivers9TWIDriver5startEv+0x16>
    201e:	01 97       	sbiw	r24, 0x01	; 1

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    2020:	c9 f3       	breq	.-14     	; 0x2014 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
    2022:	e3 cf       	rjmp	.-58     	; 0x1fea <_ZN10helicopter7drivers9TWIDriver5startEv+0xe>
		return true;
	}

	
	return false;
}
    2024:	08 95       	ret

00002026 <_ZN10helicopter7drivers9TWIDriver4stopEv>:


void TWIDriver::stop()
{
	//Send the stop condition.
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    2026:	84 e9       	ldi	r24, 0x94	; 148
    2028:	80 93 bc 00 	sts	0x00BC, r24
    202c:	08 95       	ret

0000202e <_ZN10helicopter7drivers9TWIDriver5resetEv>:

using namespace helicopter::drivers;

void TWIDriver::reset()
{
	this->stop();
    202e:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	TWCR &= ~(1<<TWEN);
    2032:	ec eb       	ldi	r30, 0xBC	; 188
    2034:	f0 e0       	ldi	r31, 0x00	; 0
    2036:	80 81       	ld	r24, Z
    2038:	8b 7f       	andi	r24, 0xFB	; 251
    203a:	80 83       	st	Z, r24
    203c:	08 95       	ret

0000203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>:
}

bool TWIDriver::write( byte data, byte acknowledgeValue)
{
	//Place data onto the Two Wire Data Register
	TWDR = data; 
    203e:	60 93 bb 00 	sts	0x00BB, r22

	//Start the transmission of the data.
	//Writing 1 to TWINT clears TWINT. Otherwise, TWINT could hold the SCL line low so that other transmissions
	//arn't allowed. Writing 1 clears it so transmissions are allowed. 
	//Setting TWEN free's up the pin so that the clock can take control of it for managing clock cycles between the two devices. 
	TWCR = (1<<TWINT) | (1<<TWEN); 
    2042:	84 e8       	ldi	r24, 0x84	; 132
    2044:	80 93 bc 00 	sts	0x00BC, r24
    2048:	84 e6       	ldi	r24, 0x64	; 100
    204a:	90 e0       	ldi	r25, 0x00	; 0
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    204c:	ec eb       	ldi	r30, 0xBC	; 188
    204e:	f0 e0       	ldi	r31, 0x00	; 0
    2050:	20 81       	ld	r18, Z
    2052:	22 23       	and	r18, r18
    2054:	cc f4       	brge	.+50     	; 0x2088 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x4a>
    2056:	13 c0       	rjmp	.+38     	; 0x207e <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>

	
	//If an acknowledgment value was given,
	//check to ensure that the ack value received from TW matched
	//the parameter
	if (acknowledgeValue != 0 && 
    2058:	44 23       	and	r20, r20
    205a:	59 f0       	breq	.+22     	; 0x2072 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x34>
    205c:	20 91 b9 00 	lds	r18, 0x00B9
    2060:	28 7f       	andi	r18, 0xF8	; 248
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	50 e0       	ldi	r21, 0x00	; 0
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	24 17       	cp	r18, r20
    206a:	35 07       	cpc	r19, r21
    206c:	19 f4       	brne	.+6      	; 0x2074 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    206e:	80 e0       	ldi	r24, 0x00	; 0
    2070:	01 c0       	rjmp	.+2      	; 0x2074 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    2072:	80 e0       	ldi	r24, 0x00	; 0
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	89 27       	eor	r24, r25
    2078:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	08 95       	ret
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    207e:	80 91 bc 00 	lds	r24, 0x00BC
    2082:	88 23       	and	r24, r24
    2084:	d4 f7       	brge	.-12     	; 0x207a <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x3c>
    2086:	e8 cf       	rjmp	.-48     	; 0x2058 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x1a>
    2088:	01 97       	sbiw	r24, 0x01	; 1
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    208a:	c9 f3       	breq	.-14     	; 0x207e <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>
    208c:	e1 cf       	rjmp	.-62     	; 0x2050 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x12>

0000208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>:

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
	//Clear the interrupt to start receiving data (why acknowledge?)*** clocks out data??
	//TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
	if (acknowledge)
    208e:	66 23       	and	r22, r22
    2090:	21 f0       	breq	.+8      	; 0x209a <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0xc>
	{
		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
    2092:	84 ec       	ldi	r24, 0xC4	; 196
    2094:	80 93 bc 00 	sts	0x00BC, r24
    2098:	03 c0       	rjmp	.+6      	; 0x20a0 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x12>
	}else
	{
		TWCR = (1<<TWINT) | (1<<TWEN);
    209a:	84 e8       	ldi	r24, 0x84	; 132
    209c:	80 93 bc 00 	sts	0x00BC, r24
	
	return true;
}

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
    20a0:	84 e6       	ldi	r24, 0x64	; 100
    20a2:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    20a4:	ec eb       	ldi	r30, 0xBC	; 188
    20a6:	f0 e0       	ldi	r31, 0x00	; 0
    20a8:	20 81       	ld	r18, Z
    20aa:	22 23       	and	r18, r18
    20ac:	84 f4       	brge	.+32     	; 0x20ce <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x40>
    20ae:	0a c0       	rjmp	.+20     	; 0x20c4 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
	{
		val = 0;
    20b0:	fa 01       	movw	r30, r20
    20b2:	10 82       	st	Z, r1
		return false;
    20b4:	80 e0       	ldi	r24, 0x00	; 0
    20b6:	08 95       	ret
	}

	
	//Read the data.
	//byte receivedValue = TWDR;
	val = TWDR;
    20b8:	80 91 bb 00 	lds	r24, 0x00BB
    20bc:	fa 01       	movw	r30, r20
    20be:	80 83       	st	Z, r24
	
	//return receivedValue;
	return true;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	08 95       	ret
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
    20c4:	80 91 bc 00 	lds	r24, 0x00BC
    20c8:	88 23       	and	r24, r24
    20ca:	94 f7       	brge	.-28     	; 0x20b0 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x22>
    20cc:	f5 cf       	rjmp	.-22     	; 0x20b8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x2a>
    20ce:	01 97       	sbiw	r24, 0x01	; 1
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    20d0:	c9 f3       	breq	.-14     	; 0x20c4 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
    20d2:	ea cf       	rjmp	.-44     	; 0x20a8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x1a>

000020d4 <_ZN10helicopter5tasks12FlashLEDTask4initEv>:
					
			}
	
			void init()
			{
				DDRA |= (1<<ledToBlink);
    20d4:	41 b1       	in	r20, 0x01	; 1
    20d6:	21 e0       	ldi	r18, 0x01	; 1
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	fc 01       	movw	r30, r24
    20dc:	00 84       	ldd	r0, Z+8	; 0x08
    20de:	02 c0       	rjmp	.+4      	; 0x20e4 <_ZN10helicopter5tasks12FlashLEDTask4initEv+0x10>
    20e0:	22 0f       	add	r18, r18
    20e2:	33 1f       	adc	r19, r19
    20e4:	0a 94       	dec	r0
    20e6:	e2 f7       	brpl	.-8      	; 0x20e0 <_ZN10helicopter5tasks12FlashLEDTask4initEv+0xc>
    20e8:	24 2b       	or	r18, r20
    20ea:	21 b9       	out	0x01, r18	; 1
    20ec:	08 95       	ret

000020ee <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>:
			}
	
			/**
				* Flashes the LED
				*/
			void runTaskImpl() {
    20ee:	fc 01       	movw	r30, r24
				if (isOff)
    20f0:	87 81       	ldd	r24, Z+7	; 0x07
    20f2:	88 23       	and	r24, r24
    20f4:	79 f0       	breq	.+30     	; 0x2114 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x26>
				{
					//Turn On the LED
					PORTA &= ~(1<<ledToBlink);
    20f6:	42 b1       	in	r20, 0x02	; 2
    20f8:	21 e0       	ldi	r18, 0x01	; 1
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	c9 01       	movw	r24, r18
    20fe:	00 84       	ldd	r0, Z+8	; 0x08
    2100:	02 c0       	rjmp	.+4      	; 0x2106 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x18>
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	0a 94       	dec	r0
    2108:	e2 f7       	brpl	.-8      	; 0x2102 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x14>
    210a:	80 95       	com	r24
    210c:	84 23       	and	r24, r20
    210e:	82 b9       	out	0x02, r24	; 2
					isOff = false;
    2110:	17 82       	std	Z+7, r1	; 0x07
    2112:	08 95       	ret
				}else
				{
					//Turn Off the LED
					PORTA |= (1<<ledToBlink);
    2114:	42 b1       	in	r20, 0x02	; 2
    2116:	21 e0       	ldi	r18, 0x01	; 1
    2118:	30 e0       	ldi	r19, 0x00	; 0
    211a:	c9 01       	movw	r24, r18
    211c:	00 84       	ldd	r0, Z+8	; 0x08
    211e:	02 c0       	rjmp	.+4      	; 0x2124 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x36>
    2120:	88 0f       	add	r24, r24
    2122:	99 1f       	adc	r25, r25
    2124:	0a 94       	dec	r0
    2126:	e2 f7       	brpl	.-8      	; 0x2120 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x32>
    2128:	84 2b       	or	r24, r20
    212a:	82 b9       	out	0x02, r24	; 2
					isOff = true;
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	87 83       	std	Z+7, r24	; 0x07
    2130:	08 95       	ret

00002132 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    2132:	26 e7       	ldi	r18, 0x76	; 118
    2134:	33 e0       	ldi	r19, 0x03	; 3
    2136:	fc 01       	movw	r30, r24
    2138:	31 83       	std	Z+1, r19	; 0x01
    213a:	20 83       	st	Z, r18
    213c:	08 95       	ret

0000213e <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>:
    213e:	26 e7       	ldi	r18, 0x76	; 118
    2140:	33 e0       	ldi	r19, 0x03	; 3
    2142:	fc 01       	movw	r30, r24
    2144:	31 83       	std	Z+1, r19	; 0x01
    2146:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
			* This task is used to periodically flash an LED on the flight computer.
			*/
		class FlashLEDTask : public Task
    2148:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    214c:	08 95       	ret

0000214e <_ZN10helicopter5model11SystemModelC1Ev>:
			
			float EcefToLocalNEDRotationMatrix[3][3];
			
			bool HasNewPressureReading;
			
			SystemModel():
    214e:	fc 01       	movw	r30, r24
				xVEcefCms(0),
				yVEcefCms(0),
				zVEcefCms(0),
				pressureMillibars(0),
				auxChannelValue(0),
				HasNewPressureReading(false)				
    2150:	11 82       	std	Z+1, r1	; 0x01
    2152:	10 82       	st	Z, r1
    2154:	12 82       	std	Z+2, r1	; 0x02
    2156:	13 82       	std	Z+3, r1	; 0x03
    2158:	14 82       	std	Z+4, r1	; 0x04
    215a:	15 82       	std	Z+5, r1	; 0x05
    215c:	16 82       	std	Z+6, r1	; 0x06
    215e:	17 82       	std	Z+7, r1	; 0x07
    2160:	10 86       	std	Z+8, r1	; 0x08
    2162:	11 86       	std	Z+9, r1	; 0x09
    2164:	12 86       	std	Z+10, r1	; 0x0a
    2166:	13 86       	std	Z+11, r1	; 0x0b
    2168:	14 86       	std	Z+12, r1	; 0x0c
    216a:	15 86       	std	Z+13, r1	; 0x0d
    216c:	16 86       	std	Z+14, r1	; 0x0e
    216e:	17 86       	std	Z+15, r1	; 0x0f
    2170:	10 8a       	std	Z+16, r1	; 0x10
    2172:	11 8a       	std	Z+17, r1	; 0x11
    2174:	12 8a       	std	Z+18, r1	; 0x12
    2176:	13 8a       	std	Z+19, r1	; 0x13
    2178:	14 8a       	std	Z+20, r1	; 0x14
    217a:	15 8a       	std	Z+21, r1	; 0x15
    217c:	16 8a       	std	Z+22, r1	; 0x16
    217e:	17 8a       	std	Z+23, r1	; 0x17
    2180:	10 8e       	std	Z+24, r1	; 0x18
    2182:	11 8e       	std	Z+25, r1	; 0x19
    2184:	12 8e       	std	Z+26, r1	; 0x1a
    2186:	13 8e       	std	Z+27, r1	; 0x1b
    2188:	14 8e       	std	Z+28, r1	; 0x1c
    218a:	15 8e       	std	Z+29, r1	; 0x1d
    218c:	16 8e       	std	Z+30, r1	; 0x1e
    218e:	17 8e       	std	Z+31, r1	; 0x1f
    2190:	10 a2       	std	Z+32, r1	; 0x20
    2192:	11 a2       	std	Z+33, r1	; 0x21
    2194:	12 a2       	std	Z+34, r1	; 0x22
    2196:	13 a2       	std	Z+35, r1	; 0x23
    2198:	14 a2       	std	Z+36, r1	; 0x24
    219a:	15 a2       	std	Z+37, r1	; 0x25
    219c:	16 a2       	std	Z+38, r1	; 0x26
    219e:	17 a2       	std	Z+39, r1	; 0x27
    21a0:	10 a6       	std	Z+40, r1	; 0x28
    21a2:	11 a6       	std	Z+41, r1	; 0x29
    21a4:	12 a6       	std	Z+42, r1	; 0x2a
    21a6:	13 a6       	std	Z+43, r1	; 0x2b
    21a8:	14 a6       	std	Z+44, r1	; 0x2c
    21aa:	15 a6       	std	Z+45, r1	; 0x2d
    21ac:	16 a6       	std	Z+46, r1	; 0x2e
    21ae:	17 a6       	std	Z+47, r1	; 0x2f
    21b0:	10 aa       	std	Z+48, r1	; 0x30
    21b2:	11 aa       	std	Z+49, r1	; 0x31
    21b4:	12 aa       	std	Z+50, r1	; 0x32
    21b6:	13 aa       	std	Z+51, r1	; 0x33
    21b8:	14 aa       	std	Z+52, r1	; 0x34
    21ba:	15 aa       	std	Z+53, r1	; 0x35
    21bc:	16 aa       	std	Z+54, r1	; 0x36
    21be:	17 aa       	std	Z+55, r1	; 0x37
    21c0:	10 ae       	std	Z+56, r1	; 0x38
    21c2:	11 ae       	std	Z+57, r1	; 0x39
    21c4:	12 ae       	std	Z+58, r1	; 0x3a
    21c6:	13 ae       	std	Z+59, r1	; 0x3b
    21c8:	14 ae       	std	Z+60, r1	; 0x3c
    21ca:	15 ae       	std	Z+61, r1	; 0x3d
    21cc:	dc 01       	movw	r26, r24
    21ce:	de 96       	adiw	r26, 0x3e	; 62
    21d0:	1d 92       	st	X+, r1
    21d2:	1d 92       	st	X+, r1
    21d4:	1d 92       	st	X+, r1
    21d6:	1c 92       	st	X, r1
    21d8:	13 97       	sbiw	r26, 0x03	; 3
    21da:	dc 01       	movw	r26, r24
    21dc:	ae 5b       	subi	r26, 0xBE	; 190
    21de:	bf 4f       	sbci	r27, 0xFF	; 255
    21e0:	1d 92       	st	X+, r1
    21e2:	1d 92       	st	X+, r1
    21e4:	1d 92       	st	X+, r1
    21e6:	1c 92       	st	X, r1
    21e8:	13 97       	sbiw	r26, 0x03	; 3
    21ea:	dc 01       	movw	r26, r24
    21ec:	aa 5b       	subi	r26, 0xBA	; 186
    21ee:	bf 4f       	sbci	r27, 0xFF	; 255
    21f0:	1d 92       	st	X+, r1
    21f2:	1d 92       	st	X+, r1
    21f4:	1d 92       	st	X+, r1
    21f6:	1c 92       	st	X, r1
    21f8:	13 97       	sbiw	r26, 0x03	; 3
    21fa:	dc 01       	movw	r26, r24
    21fc:	a6 5b       	subi	r26, 0xB6	; 182
    21fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2200:	1d 92       	st	X+, r1
    2202:	1d 92       	st	X+, r1
    2204:	1d 92       	st	X+, r1
    2206:	1c 92       	st	X, r1
    2208:	13 97       	sbiw	r26, 0x03	; 3
    220a:	dc 01       	movw	r26, r24
    220c:	a2 5b       	subi	r26, 0xB2	; 178
    220e:	bf 4f       	sbci	r27, 0xFF	; 255
    2210:	1d 92       	st	X+, r1
    2212:	1d 92       	st	X+, r1
    2214:	1d 92       	st	X+, r1
    2216:	1c 92       	st	X, r1
    2218:	13 97       	sbiw	r26, 0x03	; 3
    221a:	dc 01       	movw	r26, r24
    221c:	ae 5a       	subi	r26, 0xAE	; 174
    221e:	bf 4f       	sbci	r27, 0xFF	; 255
    2220:	1d 92       	st	X+, r1
    2222:	1d 92       	st	X+, r1
    2224:	1d 92       	st	X+, r1
    2226:	1c 92       	st	X, r1
    2228:	13 97       	sbiw	r26, 0x03	; 3
    222a:	dc 01       	movw	r26, r24
    222c:	aa 5a       	subi	r26, 0xAA	; 170
    222e:	bf 4f       	sbci	r27, 0xFF	; 255
    2230:	1d 92       	st	X+, r1
    2232:	1d 92       	st	X+, r1
    2234:	1d 92       	st	X+, r1
    2236:	1c 92       	st	X, r1
    2238:	13 97       	sbiw	r26, 0x03	; 3
    223a:	dc 01       	movw	r26, r24
    223c:	a6 5a       	subi	r26, 0xA6	; 166
    223e:	bf 4f       	sbci	r27, 0xFF	; 255
    2240:	1d 92       	st	X+, r1
    2242:	1d 92       	st	X+, r1
    2244:	1d 92       	st	X+, r1
    2246:	1c 92       	st	X, r1
    2248:	13 97       	sbiw	r26, 0x03	; 3
    224a:	dc 01       	movw	r26, r24
    224c:	a2 5a       	subi	r26, 0xA2	; 162
    224e:	bf 4f       	sbci	r27, 0xFF	; 255
    2250:	1d 92       	st	X+, r1
    2252:	1d 92       	st	X+, r1
    2254:	1d 92       	st	X+, r1
    2256:	1c 92       	st	X, r1
    2258:	13 97       	sbiw	r26, 0x03	; 3
    225a:	dc 01       	movw	r26, r24
    225c:	ae 59       	subi	r26, 0x9E	; 158
    225e:	bf 4f       	sbci	r27, 0xFF	; 255
    2260:	1d 92       	st	X+, r1
    2262:	1d 92       	st	X+, r1
    2264:	1d 92       	st	X+, r1
    2266:	1c 92       	st	X, r1
    2268:	13 97       	sbiw	r26, 0x03	; 3
    226a:	dc 01       	movw	r26, r24
    226c:	aa 59       	subi	r26, 0x9A	; 154
    226e:	bf 4f       	sbci	r27, 0xFF	; 255
    2270:	1d 92       	st	X+, r1
    2272:	1d 92       	st	X+, r1
    2274:	1d 92       	st	X+, r1
    2276:	1c 92       	st	X, r1
    2278:	13 97       	sbiw	r26, 0x03	; 3
    227a:	dc 01       	movw	r26, r24
    227c:	a6 59       	subi	r26, 0x96	; 150
    227e:	bf 4f       	sbci	r27, 0xFF	; 255
    2280:	1d 92       	st	X+, r1
    2282:	1d 92       	st	X+, r1
    2284:	1d 92       	st	X+, r1
    2286:	1c 92       	st	X, r1
    2288:	13 97       	sbiw	r26, 0x03	; 3
    228a:	dc 01       	movw	r26, r24
    228c:	a2 59       	subi	r26, 0x92	; 146
    228e:	bf 4f       	sbci	r27, 0xFF	; 255
    2290:	1d 92       	st	X+, r1
    2292:	1d 92       	st	X+, r1
    2294:	1d 92       	st	X+, r1
    2296:	1c 92       	st	X, r1
    2298:	13 97       	sbiw	r26, 0x03	; 3
    229a:	dc 01       	movw	r26, r24
    229c:	ae 58       	subi	r26, 0x8E	; 142
    229e:	bf 4f       	sbci	r27, 0xFF	; 255
    22a0:	1d 92       	st	X+, r1
    22a2:	1d 92       	st	X+, r1
    22a4:	1d 92       	st	X+, r1
    22a6:	1c 92       	st	X, r1
    22a8:	13 97       	sbiw	r26, 0x03	; 3
    22aa:	dc 01       	movw	r26, r24
    22ac:	aa 58       	subi	r26, 0x8A	; 138
    22ae:	bf 4f       	sbci	r27, 0xFF	; 255
    22b0:	1d 92       	st	X+, r1
    22b2:	1d 92       	st	X+, r1
    22b4:	1d 92       	st	X+, r1
    22b6:	1c 92       	st	X, r1
    22b8:	13 97       	sbiw	r26, 0x03	; 3
    22ba:	dc 01       	movw	r26, r24
    22bc:	a6 58       	subi	r26, 0x86	; 134
    22be:	bf 4f       	sbci	r27, 0xFF	; 255
    22c0:	1d 92       	st	X+, r1
    22c2:	1d 92       	st	X+, r1
    22c4:	1d 92       	st	X+, r1
    22c6:	1c 92       	st	X, r1
    22c8:	13 97       	sbiw	r26, 0x03	; 3
    22ca:	dc 01       	movw	r26, r24
    22cc:	a2 58       	subi	r26, 0x82	; 130
    22ce:	bf 4f       	sbci	r27, 0xFF	; 255
    22d0:	1d 92       	st	X+, r1
    22d2:	1d 92       	st	X+, r1
    22d4:	1d 92       	st	X+, r1
    22d6:	1c 92       	st	X, r1
    22d8:	13 97       	sbiw	r26, 0x03	; 3
    22da:	dc 01       	movw	r26, r24
    22dc:	ae 57       	subi	r26, 0x7E	; 126
    22de:	bf 4f       	sbci	r27, 0xFF	; 255
    22e0:	1d 92       	st	X+, r1
    22e2:	1d 92       	st	X+, r1
    22e4:	1d 92       	st	X+, r1
    22e6:	1c 92       	st	X, r1
    22e8:	13 97       	sbiw	r26, 0x03	; 3
    22ea:	dc 01       	movw	r26, r24
    22ec:	aa 57       	subi	r26, 0x7A	; 122
    22ee:	bf 4f       	sbci	r27, 0xFF	; 255
    22f0:	1d 92       	st	X+, r1
    22f2:	1d 92       	st	X+, r1
    22f4:	1d 92       	st	X+, r1
    22f6:	1c 92       	st	X, r1
    22f8:	13 97       	sbiw	r26, 0x03	; 3
    22fa:	dc 01       	movw	r26, r24
    22fc:	a6 57       	subi	r26, 0x76	; 118
    22fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2300:	1d 92       	st	X+, r1
    2302:	1d 92       	st	X+, r1
    2304:	1d 92       	st	X+, r1
    2306:	1c 92       	st	X, r1
    2308:	13 97       	sbiw	r26, 0x03	; 3
    230a:	dc 01       	movw	r26, r24
    230c:	a2 57       	subi	r26, 0x72	; 114
    230e:	bf 4f       	sbci	r27, 0xFF	; 255
    2310:	1d 92       	st	X+, r1
    2312:	1d 92       	st	X+, r1
    2314:	1d 92       	st	X+, r1
    2316:	1c 92       	st	X, r1
    2318:	13 97       	sbiw	r26, 0x03	; 3
    231a:	dc 01       	movw	r26, r24
    231c:	ae 56       	subi	r26, 0x6E	; 110
    231e:	bf 4f       	sbci	r27, 0xFF	; 255
    2320:	1d 92       	st	X+, r1
    2322:	1d 92       	st	X+, r1
    2324:	1d 92       	st	X+, r1
    2326:	1c 92       	st	X, r1
    2328:	13 97       	sbiw	r26, 0x03	; 3
    232a:	dc 01       	movw	r26, r24
    232c:	aa 56       	subi	r26, 0x6A	; 106
    232e:	bf 4f       	sbci	r27, 0xFF	; 255
    2330:	1d 92       	st	X+, r1
    2332:	1d 92       	st	X+, r1
    2334:	1d 92       	st	X+, r1
    2336:	1c 92       	st	X, r1
    2338:	13 97       	sbiw	r26, 0x03	; 3
    233a:	dc 01       	movw	r26, r24
    233c:	a6 56       	subi	r26, 0x66	; 102
    233e:	bf 4f       	sbci	r27, 0xFF	; 255
    2340:	1d 92       	st	X+, r1
    2342:	1d 92       	st	X+, r1
    2344:	1d 92       	st	X+, r1
    2346:	1c 92       	st	X, r1
    2348:	13 97       	sbiw	r26, 0x03	; 3
    234a:	dc 01       	movw	r26, r24
    234c:	a2 56       	subi	r26, 0x62	; 98
    234e:	bf 4f       	sbci	r27, 0xFF	; 255
    2350:	1d 92       	st	X+, r1
    2352:	1d 92       	st	X+, r1
    2354:	1d 92       	st	X+, r1
    2356:	1c 92       	st	X, r1
    2358:	13 97       	sbiw	r26, 0x03	; 3
    235a:	dc 01       	movw	r26, r24
    235c:	ae 55       	subi	r26, 0x5E	; 94
    235e:	bf 4f       	sbci	r27, 0xFF	; 255
    2360:	1d 92       	st	X+, r1
    2362:	1d 92       	st	X+, r1
    2364:	1d 92       	st	X+, r1
    2366:	1c 92       	st	X, r1
    2368:	13 97       	sbiw	r26, 0x03	; 3
    236a:	dc 01       	movw	r26, r24
    236c:	aa 55       	subi	r26, 0x5A	; 90
    236e:	bf 4f       	sbci	r27, 0xFF	; 255
    2370:	1d 92       	st	X+, r1
    2372:	1d 92       	st	X+, r1
    2374:	1d 92       	st	X+, r1
    2376:	1c 92       	st	X, r1
    2378:	13 97       	sbiw	r26, 0x03	; 3
    237a:	dc 01       	movw	r26, r24
    237c:	a6 55       	subi	r26, 0x56	; 86
    237e:	bf 4f       	sbci	r27, 0xFF	; 255
    2380:	1d 92       	st	X+, r1
    2382:	1d 92       	st	X+, r1
    2384:	1d 92       	st	X+, r1
    2386:	1c 92       	st	X, r1
    2388:	13 97       	sbiw	r26, 0x03	; 3
    238a:	dc 01       	movw	r26, r24
    238c:	a2 55       	subi	r26, 0x52	; 82
    238e:	bf 4f       	sbci	r27, 0xFF	; 255
    2390:	1d 92       	st	X+, r1
    2392:	1d 92       	st	X+, r1
    2394:	1d 92       	st	X+, r1
    2396:	1c 92       	st	X, r1
    2398:	13 97       	sbiw	r26, 0x03	; 3
    239a:	dc 01       	movw	r26, r24
    239c:	ae 54       	subi	r26, 0x4E	; 78
    239e:	bf 4f       	sbci	r27, 0xFF	; 255
    23a0:	1d 92       	st	X+, r1
    23a2:	1d 92       	st	X+, r1
    23a4:	1d 92       	st	X+, r1
    23a6:	1c 92       	st	X, r1
    23a8:	13 97       	sbiw	r26, 0x03	; 3
    23aa:	dc 01       	movw	r26, r24
    23ac:	aa 54       	subi	r26, 0x4A	; 74
    23ae:	bf 4f       	sbci	r27, 0xFF	; 255
    23b0:	1d 92       	st	X+, r1
    23b2:	1d 92       	st	X+, r1
    23b4:	1d 92       	st	X+, r1
    23b6:	1c 92       	st	X, r1
    23b8:	13 97       	sbiw	r26, 0x03	; 3
    23ba:	dc 01       	movw	r26, r24
    23bc:	a6 54       	subi	r26, 0x46	; 70
    23be:	bf 4f       	sbci	r27, 0xFF	; 255
    23c0:	1d 92       	st	X+, r1
    23c2:	1d 92       	st	X+, r1
    23c4:	1d 92       	st	X+, r1
    23c6:	1c 92       	st	X, r1
    23c8:	13 97       	sbiw	r26, 0x03	; 3
    23ca:	dc 01       	movw	r26, r24
    23cc:	a2 54       	subi	r26, 0x42	; 66
    23ce:	bf 4f       	sbci	r27, 0xFF	; 255
    23d0:	1d 92       	st	X+, r1
    23d2:	1d 92       	st	X+, r1
    23d4:	1d 92       	st	X+, r1
    23d6:	1c 92       	st	X, r1
    23d8:	13 97       	sbiw	r26, 0x03	; 3
    23da:	dc 01       	movw	r26, r24
    23dc:	ae 53       	subi	r26, 0x3E	; 62
    23de:	bf 4f       	sbci	r27, 0xFF	; 255
    23e0:	1d 92       	st	X+, r1
    23e2:	1d 92       	st	X+, r1
    23e4:	1d 92       	st	X+, r1
    23e6:	1c 92       	st	X, r1
    23e8:	13 97       	sbiw	r26, 0x03	; 3
    23ea:	dc 01       	movw	r26, r24
    23ec:	aa 53       	subi	r26, 0x3A	; 58
    23ee:	bf 4f       	sbci	r27, 0xFF	; 255
    23f0:	1d 92       	st	X+, r1
    23f2:	1d 92       	st	X+, r1
    23f4:	1d 92       	st	X+, r1
    23f6:	1c 92       	st	X, r1
    23f8:	13 97       	sbiw	r26, 0x03	; 3
    23fa:	dc 01       	movw	r26, r24
    23fc:	a2 53       	subi	r26, 0x32	; 50
    23fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2400:	1d 92       	st	X+, r1
    2402:	1d 92       	st	X+, r1
    2404:	1d 92       	st	X+, r1
    2406:	1c 92       	st	X, r1
    2408:	13 97       	sbiw	r26, 0x03	; 3
    240a:	dc 01       	movw	r26, r24
    240c:	ae 52       	subi	r26, 0x2E	; 46
    240e:	bf 4f       	sbci	r27, 0xFF	; 255
    2410:	1d 92       	st	X+, r1
    2412:	1d 92       	st	X+, r1
    2414:	1d 92       	st	X+, r1
    2416:	1c 92       	st	X, r1
    2418:	13 97       	sbiw	r26, 0x03	; 3
    241a:	dc 01       	movw	r26, r24
    241c:	aa 52       	subi	r26, 0x2A	; 42
    241e:	bf 4f       	sbci	r27, 0xFF	; 255
    2420:	1d 92       	st	X+, r1
    2422:	1d 92       	st	X+, r1
    2424:	1d 92       	st	X+, r1
    2426:	1c 92       	st	X, r1
    2428:	13 97       	sbiw	r26, 0x03	; 3
    242a:	dc 01       	movw	r26, r24
    242c:	a6 52       	subi	r26, 0x26	; 38
    242e:	bf 4f       	sbci	r27, 0xFF	; 255
    2430:	1d 92       	st	X+, r1
    2432:	1d 92       	st	X+, r1
    2434:	1d 92       	st	X+, r1
    2436:	1c 92       	st	X, r1
    2438:	13 97       	sbiw	r26, 0x03	; 3
    243a:	dc 01       	movw	r26, r24
    243c:	a2 52       	subi	r26, 0x22	; 34
    243e:	bf 4f       	sbci	r27, 0xFF	; 255
    2440:	1d 92       	st	X+, r1
    2442:	1d 92       	st	X+, r1
    2444:	1d 92       	st	X+, r1
    2446:	1c 92       	st	X, r1
    2448:	13 97       	sbiw	r26, 0x03	; 3
    244a:	dc 01       	movw	r26, r24
    244c:	ae 51       	subi	r26, 0x1E	; 30
    244e:	bf 4f       	sbci	r27, 0xFF	; 255
    2450:	1d 92       	st	X+, r1
    2452:	1d 92       	st	X+, r1
    2454:	1d 92       	st	X+, r1
    2456:	1c 92       	st	X, r1
    2458:	13 97       	sbiw	r26, 0x03	; 3
    245a:	dc 01       	movw	r26, r24
    245c:	aa 51       	subi	r26, 0x1A	; 26
    245e:	bf 4f       	sbci	r27, 0xFF	; 255
    2460:	1d 92       	st	X+, r1
    2462:	1d 92       	st	X+, r1
    2464:	1d 92       	st	X+, r1
    2466:	1c 92       	st	X, r1
    2468:	13 97       	sbiw	r26, 0x03	; 3
    246a:	dc 01       	movw	r26, r24
    246c:	a6 51       	subi	r26, 0x16	; 22
    246e:	bf 4f       	sbci	r27, 0xFF	; 255
    2470:	1d 92       	st	X+, r1
    2472:	1d 92       	st	X+, r1
    2474:	1d 92       	st	X+, r1
    2476:	1c 92       	st	X, r1
    2478:	13 97       	sbiw	r26, 0x03	; 3
    247a:	dc 01       	movw	r26, r24
    247c:	a2 51       	subi	r26, 0x12	; 18
    247e:	bf 4f       	sbci	r27, 0xFF	; 255
    2480:	1d 92       	st	X+, r1
    2482:	1d 92       	st	X+, r1
    2484:	1d 92       	st	X+, r1
    2486:	1c 92       	st	X, r1
    2488:	13 97       	sbiw	r26, 0x03	; 3
    248a:	dc 01       	movw	r26, r24
    248c:	ae 50       	subi	r26, 0x0E	; 14
    248e:	bf 4f       	sbci	r27, 0xFF	; 255
    2490:	1d 92       	st	X+, r1
    2492:	1d 92       	st	X+, r1
    2494:	1d 92       	st	X+, r1
    2496:	1c 92       	st	X, r1
    2498:	13 97       	sbiw	r26, 0x03	; 3
    249a:	dc 01       	movw	r26, r24
    249c:	aa 50       	subi	r26, 0x0A	; 10
    249e:	bf 4f       	sbci	r27, 0xFF	; 255
    24a0:	1d 92       	st	X+, r1
    24a2:	1d 92       	st	X+, r1
    24a4:	1d 92       	st	X+, r1
    24a6:	1c 92       	st	X, r1
    24a8:	13 97       	sbiw	r26, 0x03	; 3
    24aa:	dc 01       	movw	r26, r24
    24ac:	a6 50       	subi	r26, 0x06	; 6
    24ae:	bf 4f       	sbci	r27, 0xFF	; 255
    24b0:	1d 92       	st	X+, r1
    24b2:	1d 92       	st	X+, r1
    24b4:	1d 92       	st	X+, r1
    24b6:	1c 92       	st	X, r1
    24b8:	13 97       	sbiw	r26, 0x03	; 3
    24ba:	dc 01       	movw	r26, r24
    24bc:	a2 50       	subi	r26, 0x02	; 2
    24be:	bf 4f       	sbci	r27, 0xFF	; 255
    24c0:	1d 92       	st	X+, r1
    24c2:	1d 92       	st	X+, r1
    24c4:	1d 92       	st	X+, r1
    24c6:	1c 92       	st	X, r1
    24c8:	13 97       	sbiw	r26, 0x03	; 3
    24ca:	dc 01       	movw	r26, r24
    24cc:	ae 5f       	subi	r26, 0xFE	; 254
    24ce:	be 4f       	sbci	r27, 0xFE	; 254
    24d0:	1d 92       	st	X+, r1
    24d2:	1d 92       	st	X+, r1
    24d4:	1d 92       	st	X+, r1
    24d6:	1c 92       	st	X, r1
    24d8:	13 97       	sbiw	r26, 0x03	; 3
    24da:	dc 01       	movw	r26, r24
    24dc:	aa 5f       	subi	r26, 0xFA	; 250
    24de:	be 4f       	sbci	r27, 0xFE	; 254
    24e0:	1d 92       	st	X+, r1
    24e2:	1d 92       	st	X+, r1
    24e4:	1d 92       	st	X+, r1
    24e6:	1c 92       	st	X, r1
    24e8:	13 97       	sbiw	r26, 0x03	; 3
    24ea:	dc 01       	movw	r26, r24
    24ec:	a6 5f       	subi	r26, 0xF6	; 246
    24ee:	be 4f       	sbci	r27, 0xFE	; 254
    24f0:	1d 92       	st	X+, r1
    24f2:	1d 92       	st	X+, r1
    24f4:	1d 92       	st	X+, r1
    24f6:	1c 92       	st	X, r1
    24f8:	13 97       	sbiw	r26, 0x03	; 3
    24fa:	dc 01       	movw	r26, r24
    24fc:	a2 5f       	subi	r26, 0xF2	; 242
    24fe:	be 4f       	sbci	r27, 0xFE	; 254
    2500:	1d 92       	st	X+, r1
    2502:	1d 92       	st	X+, r1
    2504:	1d 92       	st	X+, r1
    2506:	1c 92       	st	X, r1
    2508:	13 97       	sbiw	r26, 0x03	; 3
    250a:	dc 01       	movw	r26, r24
    250c:	ae 5e       	subi	r26, 0xEE	; 238
    250e:	be 4f       	sbci	r27, 0xFE	; 254
    2510:	1d 92       	st	X+, r1
    2512:	1d 92       	st	X+, r1
    2514:	1d 92       	st	X+, r1
    2516:	1c 92       	st	X, r1
    2518:	13 97       	sbiw	r26, 0x03	; 3
    251a:	dc 01       	movw	r26, r24
    251c:	aa 5e       	subi	r26, 0xEA	; 234
    251e:	be 4f       	sbci	r27, 0xFE	; 254
    2520:	1d 92       	st	X+, r1
    2522:	1d 92       	st	X+, r1
    2524:	1d 92       	st	X+, r1
    2526:	1c 92       	st	X, r1
    2528:	13 97       	sbiw	r26, 0x03	; 3
    252a:	dc 01       	movw	r26, r24
    252c:	a6 5e       	subi	r26, 0xE6	; 230
    252e:	be 4f       	sbci	r27, 0xFE	; 254
    2530:	1d 92       	st	X+, r1
    2532:	1d 92       	st	X+, r1
    2534:	1d 92       	st	X+, r1
    2536:	1c 92       	st	X, r1
    2538:	13 97       	sbiw	r26, 0x03	; 3
    253a:	dc 01       	movw	r26, r24
    253c:	ae 5b       	subi	r26, 0xBE	; 190
    253e:	be 4f       	sbci	r27, 0xFE	; 254
    2540:	1c 92       	st	X, r1
			{
				EcefToLocalNEDRotationMatrix[0][0] = 0;
    2542:	dc 01       	movw	r26, r24
    2544:	a2 5e       	subi	r26, 0xE2	; 226
    2546:	be 4f       	sbci	r27, 0xFE	; 254
    2548:	1d 92       	st	X+, r1
    254a:	1d 92       	st	X+, r1
    254c:	1d 92       	st	X+, r1
    254e:	1c 92       	st	X, r1
    2550:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][1] = 0;
    2552:	dc 01       	movw	r26, r24
    2554:	ae 5d       	subi	r26, 0xDE	; 222
    2556:	be 4f       	sbci	r27, 0xFE	; 254
    2558:	1d 92       	st	X+, r1
    255a:	1d 92       	st	X+, r1
    255c:	1d 92       	st	X+, r1
    255e:	1c 92       	st	X, r1
    2560:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][2] = 0;
    2562:	dc 01       	movw	r26, r24
    2564:	aa 5d       	subi	r26, 0xDA	; 218
    2566:	be 4f       	sbci	r27, 0xFE	; 254
    2568:	1d 92       	st	X+, r1
    256a:	1d 92       	st	X+, r1
    256c:	1d 92       	st	X+, r1
    256e:	1c 92       	st	X, r1
    2570:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][0] = 0;
    2572:	dc 01       	movw	r26, r24
    2574:	a6 5d       	subi	r26, 0xD6	; 214
    2576:	be 4f       	sbci	r27, 0xFE	; 254
    2578:	1d 92       	st	X+, r1
    257a:	1d 92       	st	X+, r1
    257c:	1d 92       	st	X+, r1
    257e:	1c 92       	st	X, r1
    2580:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][1] = 0;
    2582:	dc 01       	movw	r26, r24
    2584:	a2 5d       	subi	r26, 0xD2	; 210
    2586:	be 4f       	sbci	r27, 0xFE	; 254
    2588:	1d 92       	st	X+, r1
    258a:	1d 92       	st	X+, r1
    258c:	1d 92       	st	X+, r1
    258e:	1c 92       	st	X, r1
    2590:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][2] = 0;
    2592:	dc 01       	movw	r26, r24
    2594:	ae 5c       	subi	r26, 0xCE	; 206
    2596:	be 4f       	sbci	r27, 0xFE	; 254
    2598:	1d 92       	st	X+, r1
    259a:	1d 92       	st	X+, r1
    259c:	1d 92       	st	X+, r1
    259e:	1c 92       	st	X, r1
    25a0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
    25a2:	dc 01       	movw	r26, r24
    25a4:	aa 5c       	subi	r26, 0xCA	; 202
    25a6:	be 4f       	sbci	r27, 0xFE	; 254
    25a8:	1d 92       	st	X+, r1
    25aa:	1d 92       	st	X+, r1
    25ac:	1d 92       	st	X+, r1
    25ae:	1c 92       	st	X, r1
    25b0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][1] = 0;
    25b2:	dc 01       	movw	r26, r24
    25b4:	a6 5c       	subi	r26, 0xC6	; 198
    25b6:	be 4f       	sbci	r27, 0xFE	; 254
    25b8:	1d 92       	st	X+, r1
    25ba:	1d 92       	st	X+, r1
    25bc:	1d 92       	st	X+, r1
    25be:	1c 92       	st	X, r1
    25c0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
    25c2:	e2 5c       	subi	r30, 0xC2	; 194
    25c4:	fe 4f       	sbci	r31, 0xFE	; 254
    25c6:	10 82       	st	Z, r1
    25c8:	11 82       	std	Z+1, r1	; 0x01
    25ca:	12 82       	std	Z+2, r1	; 0x02
    25cc:	13 82       	std	Z+3, r1	; 0x03
    25ce:	08 95       	ret

000025d0 <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>:
using namespace helicopter::util;
using namespace helicopter::sensors;
using namespace helicopter::navigation;

void setupDefaultsandReferencePosition(SystemModel *model, PIDController *pidController)
{	
    25d0:	0f 93       	push	r16
    25d2:	1f 93       	push	r17
    25d4:	cf 93       	push	r28
    25d6:	df 93       	push	r29
    25d8:	dc 01       	movw	r26, r24
    25da:	fb 01       	movw	r30, r22
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    25dc:	16 96       	adiw	r26, 0x06	; 6
    25de:	1d 92       	st	X+, r1
    25e0:	1d 92       	st	X+, r1
    25e2:	1d 92       	st	X+, r1
    25e4:	1c 92       	st	X, r1
    25e6:	19 97       	sbiw	r26, 0x09	; 9
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
    25e8:	52 96       	adiw	r26, 0x12	; 18
    25ea:	1d 92       	st	X+, r1
    25ec:	1d 92       	st	X+, r1
    25ee:	1d 92       	st	X+, r1
    25f0:	1c 92       	st	X, r1
    25f2:	55 97       	sbiw	r26, 0x15	; 21
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    25f4:	ec 01       	movw	r28, r24
    25f6:	ce 57       	subi	r28, 0x7E	; 126
    25f8:	df 4f       	sbci	r29, 0xFF	; 255
    25fa:	4a e9       	ldi	r20, 0x9A	; 154
    25fc:	59 e9       	ldi	r21, 0x99	; 153
    25fe:	64 e6       	ldi	r22, 0x64	; 100
    2600:	74 ec       	ldi	r23, 0xC4	; 196
    2602:	48 83       	st	Y, r20
    2604:	59 83       	std	Y+1, r21	; 0x01
    2606:	6a 83       	std	Y+2, r22	; 0x02
    2608:	7b 83       	std	Y+3, r23	; 0x03

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}
    260a:	ec 01       	movw	r28, r24
    260c:	ce 56       	subi	r28, 0x6E	; 110
    260e:	df 4f       	sbci	r29, 0xFF	; 255
    2610:	18 82       	st	Y, r1
    2612:	19 82       	std	Y+1, r1	; 0x01
    2614:	1a 82       	std	Y+2, r1	; 0x02
    2616:	1b 82       	std	Y+3, r1	; 0x03
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    2618:	96 96       	adiw	r26, 0x26	; 38
    261a:	1d 92       	st	X+, r1
    261c:	1d 92       	st	X+, r1
    261e:	1d 92       	st	X+, r1
    2620:	1c 92       	st	X, r1
    2622:	99 97       	sbiw	r26, 0x29	; 41
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
    2624:	d6 96       	adiw	r26, 0x36	; 54
    2626:	1d 92       	st	X+, r1
    2628:	1d 92       	st	X+, r1
    262a:	1d 92       	st	X+, r1
    262c:	1c 92       	st	X, r1
    262e:	d9 97       	sbiw	r26, 0x39	; 57

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    2630:	ec 01       	movw	r28, r24
    2632:	ce 5a       	subi	r28, 0xAE	; 174
    2634:	df 4f       	sbci	r29, 0xFF	; 255
    2636:	18 82       	st	Y, r1
    2638:	19 82       	std	Y+1, r1	; 0x01
    263a:	1a 82       	std	Y+2, r1	; 0x02
    263c:	1b 82       	std	Y+3, r1	; 0x03

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}
    263e:	ae 59       	subi	r26, 0x9E	; 158
    2640:	bf 4f       	sbci	r27, 0xFF	; 255
    2642:	1d 92       	st	X+, r1
    2644:	1d 92       	st	X+, r1
    2646:	1d 92       	st	X+, r1
    2648:	1c 92       	st	X, r1
    264a:	13 97       	sbiw	r26, 0x03	; 3
					xDerivativeGain = val;
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    264c:	82 e7       	ldi	r24, 0x72	; 114
    264e:	93 e3       	ldi	r25, 0x33	; 51
    2650:	ac e5       	ldi	r26, 0x5C	; 92
    2652:	b9 e3       	ldi	r27, 0x39	; 57
    2654:	82 8f       	std	Z+26, r24	; 0x1a
    2656:	93 8f       	std	Z+27, r25	; 0x1b
    2658:	a4 8f       	std	Z+28, r26	; 0x1c
    265a:	b5 8f       	std	Z+29, r27	; 0x1d
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    265c:	12 8a       	std	Z+18, r1	; 0x12
    265e:	13 8a       	std	Z+19, r1	; 0x13
    2660:	14 8a       	std	Z+20, r1	; 0x14
    2662:	15 8a       	std	Z+21, r1	; 0x15
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    2664:	85 e4       	ldi	r24, 0x45	; 69
    2666:	95 ef       	ldi	r25, 0xF5	; 245
    2668:	a6 ed       	ldi	r26, 0xD6	; 214
    266a:	b9 e3       	ldi	r27, 0x39	; 57
    266c:	86 8b       	std	Z+22, r24	; 0x16
    266e:	97 8b       	std	Z+23, r25	; 0x17
    2670:	a0 8f       	std	Z+24, r26	; 0x18
    2672:	b1 8f       	std	Z+25, r27	; 0x19
					xProportionalGain = val;
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    2674:	16 8e       	std	Z+30, r1	; 0x1e
    2676:	17 8e       	std	Z+31, r1	; 0x1f
    2678:	10 a2       	std	Z+32, r1	; 0x20
    267a:	11 a2       	std	Z+33, r1	; 0x21
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    267c:	80 e0       	ldi	r24, 0x00	; 0
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	a0 e8       	ldi	r26, 0x80	; 128
    2682:	bf e3       	ldi	r27, 0x3F	; 63
    2684:	82 a3       	std	Z+34, r24	; 0x22
    2686:	93 a3       	std	Z+35, r25	; 0x23
    2688:	a4 a3       	std	Z+36, r26	; 0x24
    268a:	b5 a3       	std	Z+37, r27	; 0x25
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    268c:	16 a2       	std	Z+38, r1	; 0x26
    268e:	17 a2       	std	Z+39, r1	; 0x27
    2690:	10 a6       	std	Z+40, r1	; 0x28
    2692:	11 a6       	std	Z+41, r1	; 0x29
					yDerivativeGain = val;
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    2694:	4f e6       	ldi	r20, 0x6F	; 111
    2696:	52 e1       	ldi	r21, 0x12	; 18
    2698:	63 e8       	ldi	r22, 0x83	; 131
    269a:	79 e3       	ldi	r23, 0x39	; 57
    269c:	42 ab       	std	Z+50, r20	; 0x32
    269e:	53 ab       	std	Z+51, r21	; 0x33
    26a0:	64 ab       	std	Z+52, r22	; 0x34
    26a2:	75 ab       	std	Z+53, r23	; 0x35
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    26a4:	12 a6       	std	Z+42, r1	; 0x2a
    26a6:	13 a6       	std	Z+43, r1	; 0x2b
    26a8:	14 a6       	std	Z+44, r1	; 0x2c
    26aa:	15 a6       	std	Z+45, r1	; 0x2d
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    26ac:	4a e8       	ldi	r20, 0x8A	; 138
    26ae:	55 e5       	ldi	r21, 0x55	; 85
    26b0:	63 e0       	ldi	r22, 0x03	; 3
    26b2:	7a e3       	ldi	r23, 0x3A	; 58
    26b4:	46 a7       	std	Z+46, r20	; 0x2e
    26b6:	57 a7       	std	Z+47, r21	; 0x2f
    26b8:	60 ab       	std	Z+48, r22	; 0x30
    26ba:	71 ab       	std	Z+49, r23	; 0x31
					yProportionalGain = val;
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    26bc:	16 aa       	std	Z+54, r1	; 0x36
    26be:	17 aa       	std	Z+55, r1	; 0x37
    26c0:	10 ae       	std	Z+56, r1	; 0x38
    26c2:	11 ae       	std	Z+57, r1	; 0x39
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    26c4:	82 af       	std	Z+58, r24	; 0x3a
    26c6:	93 af       	std	Z+59, r25	; 0x3b
    26c8:	a4 af       	std	Z+60, r26	; 0x3c
    26ca:	b5 af       	std	Z+61, r27	; 0x3d
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    26cc:	ef 01       	movw	r28, r30
    26ce:	ee 96       	adiw	r28, 0x3e	; 62
    26d0:	18 82       	st	Y, r1
    26d2:	19 82       	std	Y+1, r1	; 0x01
    26d4:	1a 82       	std	Y+2, r1	; 0x02
    26d6:	1b 82       	std	Y+3, r1	; 0x03
					zDerivativeGain = val;
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    26d8:	ef 01       	movw	r28, r30
    26da:	c6 5b       	subi	r28, 0xB6	; 182
    26dc:	df 4f       	sbci	r29, 0xFF	; 255
    26de:	4f e6       	ldi	r20, 0x6F	; 111
    26e0:	52 e1       	ldi	r21, 0x12	; 18
    26e2:	63 e0       	ldi	r22, 0x03	; 3
    26e4:	7b e3       	ldi	r23, 0x3B	; 59
    26e6:	48 83       	st	Y, r20
    26e8:	59 83       	std	Y+1, r21	; 0x01
    26ea:	6a 83       	std	Y+2, r22	; 0x02
    26ec:	7b 83       	std	Y+3, r23	; 0x03
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    26ee:	ef 01       	movw	r28, r30
    26f0:	ce 5b       	subi	r28, 0xBE	; 190
    26f2:	df 4f       	sbci	r29, 0xFF	; 255
    26f4:	18 82       	st	Y, r1
    26f6:	19 82       	std	Y+1, r1	; 0x01
    26f8:	1a 82       	std	Y+2, r1	; 0x02
    26fa:	1b 82       	std	Y+3, r1	; 0x03
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    26fc:	ef 01       	movw	r28, r30
    26fe:	ca 5b       	subi	r28, 0xBA	; 186
    2700:	df 4f       	sbci	r29, 0xFF	; 255
    2702:	46 ea       	ldi	r20, 0xA6	; 166
    2704:	5b e9       	ldi	r21, 0x9B	; 155
    2706:	64 ec       	ldi	r22, 0xC4	; 196
    2708:	7a e3       	ldi	r23, 0x3A	; 58
    270a:	48 83       	st	Y, r20
    270c:	59 83       	std	Y+1, r21	; 0x01
    270e:	6a 83       	std	Y+2, r22	; 0x02
    2710:	7b 83       	std	Y+3, r23	; 0x03
					zProportionalGain = val;
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    2712:	ef 01       	movw	r28, r30
    2714:	c2 5b       	subi	r28, 0xB2	; 178
    2716:	df 4f       	sbci	r29, 0xFF	; 255
    2718:	18 82       	st	Y, r1
    271a:	19 82       	std	Y+1, r1	; 0x01
    271c:	1a 82       	std	Y+2, r1	; 0x02
    271e:	1b 82       	std	Y+3, r1	; 0x03
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    2720:	4a e9       	ldi	r20, 0x9A	; 154
    2722:	59 e9       	ldi	r21, 0x99	; 153
    2724:	69 e9       	ldi	r22, 0x99	; 153
    2726:	7f e3       	ldi	r23, 0x3F	; 63
    2728:	42 87       	std	Z+10, r20	; 0x0a
    272a:	53 87       	std	Z+11, r21	; 0x0b
    272c:	64 87       	std	Z+12, r22	; 0x0c
    272e:	75 87       	std	Z+13, r23	; 0x0d
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    2730:	12 82       	std	Z+2, r1	; 0x02
    2732:	13 82       	std	Z+3, r1	; 0x03
    2734:	14 82       	std	Z+4, r1	; 0x04
    2736:	15 82       	std	Z+5, r1	; 0x05
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    2738:	4d ec       	ldi	r20, 0xCD	; 205
    273a:	5c ec       	ldi	r21, 0xCC	; 204
    273c:	6c e8       	ldi	r22, 0x8C	; 140
    273e:	7e e3       	ldi	r23, 0x3E	; 62
    2740:	46 83       	std	Z+6, r20	; 0x06
    2742:	57 83       	std	Z+7, r21	; 0x07
    2744:	60 87       	std	Z+8, r22	; 0x08
    2746:	71 87       	std	Z+9, r23	; 0x09
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    2748:	16 86       	std	Z+14, r1	; 0x0e
    274a:	17 86       	std	Z+15, r1	; 0x0f
    274c:	10 8a       	std	Z+16, r1	; 0x10
    274e:	11 8a       	std	Z+17, r1	; 0x11
				 * The number of seconds between pid controller updates. This number
				 * should generally be less than 1. Like .05 for a 20 hz rate.
				 */
				void setIntervalPeriodSecs(float intervalPeriodSecs)
				{
					this->intervalPeriodSecs = intervalPeriodSecs;
    2750:	ef 01       	movw	r28, r30
    2752:	ce 57       	subi	r28, 0x7E	; 126
    2754:	df 4f       	sbci	r29, 0xFF	; 255
    2756:	4d ec       	ldi	r20, 0xCD	; 205
    2758:	5c ec       	ldi	r21, 0xCC	; 204
    275a:	6c e4       	ldi	r22, 0x4C	; 76
    275c:	7d e3       	ldi	r23, 0x3D	; 61
    275e:	48 83       	st	Y, r20
    2760:	59 83       	std	Y+1, r21	; 0x01
    2762:	6a 83       	std	Y+2, r22	; 0x02
    2764:	7b 83       	std	Y+3, r23	; 0x03
				 * This is the maximum possible output value for a control signal.
				 * Generally, this should be set to 1.
				 */
				void setControlMaxValue(float controlMaxValue)
				{
					this->controlMaxValue = controlMaxValue;
    2766:	ef 01       	movw	r28, r30
    2768:	ca 57       	subi	r28, 0x7A	; 122
    276a:	df 4f       	sbci	r29, 0xFF	; 255
    276c:	88 83       	st	Y, r24
    276e:	99 83       	std	Y+1, r25	; 0x01
    2770:	aa 83       	std	Y+2, r26	; 0x02
    2772:	bb 83       	std	Y+3, r27	; 0x03
				 * This is the minimum possible value for a control signal.
				 * Generally, this should be set to -1.
				 */
				void setControlMinValue(float controlMinValue)
				{
					this->controlMinValue = controlMinValue;
    2774:	ef 01       	movw	r28, r30
    2776:	c6 57       	subi	r28, 0x76	; 118
    2778:	df 4f       	sbci	r29, 0xFF	; 255
    277a:	40 e0       	ldi	r20, 0x00	; 0
    277c:	50 e0       	ldi	r21, 0x00	; 0
    277e:	60 e8       	ldi	r22, 0x80	; 128
    2780:	7f eb       	ldi	r23, 0xBF	; 191
    2782:	48 83       	st	Y, r20
    2784:	59 83       	std	Y+1, r21	; 0x01
    2786:	6a 83       	std	Y+2, r22	; 0x02
    2788:	7b 83       	std	Y+3, r23	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no smaller than the controlMinValue (e.g. no less than -1)
				 */
				void setMinYawServoControl(float minYawServoControlValue)
				{
					this->minYawServoControlValue = minYawServoControlValue;
    278a:	ef 01       	movw	r28, r30
    278c:	ce 5a       	subi	r28, 0xAE	; 174
    278e:	df 4f       	sbci	r29, 0xFF	; 255
    2790:	0f e8       	ldi	r16, 0x8F	; 143
    2792:	12 ec       	ldi	r17, 0xC2	; 194
    2794:	25 e7       	ldi	r18, 0x75	; 117
    2796:	3f eb       	ldi	r19, 0xBF	; 191
    2798:	08 83       	st	Y, r16
    279a:	19 83       	std	Y+1, r17	; 0x01
    279c:	2a 83       	std	Y+2, r18	; 0x02
    279e:	3b 83       	std	Y+3, r19	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no larger than the controlMaxValue (e.g. no greater than 1)
				 */
				void setMaxYawServoControl(float maxYawServoControlValue)
				{
					this->maxYawServoControlValue = maxYawServoControlValue;
    27a0:	ef 01       	movw	r28, r30
    27a2:	ca 5a       	subi	r28, 0xAA	; 170
    27a4:	df 4f       	sbci	r29, 0xFF	; 255
    27a6:	0f e8       	ldi	r16, 0x8F	; 143
    27a8:	12 ec       	ldi	r17, 0xC2	; 194
    27aa:	25 e7       	ldi	r18, 0x75	; 117
    27ac:	3f e3       	ldi	r19, 0x3F	; 63
    27ae:	08 83       	st	Y, r16
    27b0:	19 83       	std	Y+1, r17	; 0x01
    27b2:	2a 83       	std	Y+2, r18	; 0x02
    27b4:	3b 83       	std	Y+3, r19	; 0x03
					minLongitudeServoControlValue = val;
				}
				
				void setMaxLongitudeServoControlValue(float val)
				{
					maxLongitudeServoControlValue = val;
    27b6:	ef 01       	movw	r28, r30
    27b8:	c2 5a       	subi	r28, 0xA2	; 162
    27ba:	df 4f       	sbci	r29, 0xFF	; 255
    27bc:	88 83       	st	Y, r24
    27be:	99 83       	std	Y+1, r25	; 0x01
    27c0:	aa 83       	std	Y+2, r26	; 0x02
    27c2:	bb 83       	std	Y+3, r27	; 0x03
					pitchAngularVelocityGain = val;
				}
				
				void setMinLongitudeServoControlValue(float val)
				{
					minLongitudeServoControlValue = val;
    27c4:	ef 01       	movw	r28, r30
    27c6:	c6 5a       	subi	r28, 0xA6	; 166
    27c8:	df 4f       	sbci	r29, 0xFF	; 255
    27ca:	48 83       	st	Y, r20
    27cc:	59 83       	std	Y+1, r21	; 0x01
    27ce:	6a 83       	std	Y+2, r22	; 0x02
    27d0:	7b 83       	std	Y+3, r23	; 0x03
					minLateralServoControlValue = val;
				}
				
				void setMaxLateralServoControlValue(float val)
				{
					maxLateralServoControlValue = val;
    27d2:	ef 01       	movw	r28, r30
    27d4:	ca 59       	subi	r28, 0x9A	; 154
    27d6:	df 4f       	sbci	r29, 0xFF	; 255
    27d8:	88 83       	st	Y, r24
    27da:	99 83       	std	Y+1, r25	; 0x01
    27dc:	aa 83       	std	Y+2, r26	; 0x02
    27de:	bb 83       	std	Y+3, r27	; 0x03
					rollAngularVelocityGain = val;
				}
				
				void setMinLateralServoControlValue(float val)
				{
					minLateralServoControlValue = val;
    27e0:	df 01       	movw	r26, r30
    27e2:	ae 59       	subi	r26, 0x9E	; 158
    27e4:	bf 4f       	sbci	r27, 0xFF	; 255
    27e6:	4d 93       	st	X+, r20
    27e8:	5d 93       	st	X+, r21
    27ea:	6d 93       	st	X+, r22
    27ec:	7c 93       	st	X, r23
    27ee:	13 97       	sbiw	r26, 0x03	; 3
					minMainRotorServoControlValue = val;
				}
				
				void setMaxMainRotorServoControlValue(float val)
				{
					maxMainRotorServoControlValue = val;
    27f0:	ef 01       	movw	r28, r30
    27f2:	c2 59       	subi	r28, 0x92	; 146
    27f4:	df 4f       	sbci	r29, 0xFF	; 255
    27f6:	80 e0       	ldi	r24, 0x00	; 0
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	a0 e0       	ldi	r26, 0x00	; 0
    27fc:	bf e3       	ldi	r27, 0x3F	; 63
    27fe:	88 83       	st	Y, r24
    2800:	99 83       	std	Y+1, r25	; 0x01
    2802:	aa 83       	std	Y+2, r26	; 0x02
    2804:	bb 83       	std	Y+3, r27	; 0x03
					zAntiWindupGain = val;
				}
				
				void setMinMainRotorServoControlValue(float val)
				{
					minMainRotorServoControlValue = val;
    2806:	df 01       	movw	r26, r30
    2808:	a6 59       	subi	r26, 0x96	; 150
    280a:	bf 4f       	sbci	r27, 0xFF	; 255
    280c:	1d 92       	st	X+, r1
    280e:	1d 92       	st	X+, r1
    2810:	1d 92       	st	X+, r1
    2812:	1c 92       	st	X, r1
    2814:	13 97       	sbiw	r26, 0x03	; 3
				}


				void setMaxRollSetpointRads(float val)
				{
					maxRollSetpointRads = val;
    2816:	ef 01       	movw	r28, r30
    2818:	c2 58       	subi	r28, 0x82	; 130
    281a:	df 4f       	sbci	r29, 0xFF	; 255
    281c:	82 ec       	ldi	r24, 0xC2	; 194
    281e:	98 eb       	ldi	r25, 0xB8	; 184
    2820:	a2 eb       	ldi	r26, 0xB2	; 178
    2822:	bd e3       	ldi	r27, 0x3D	; 61
    2824:	88 83       	st	Y, r24
    2826:	99 83       	std	Y+1, r25	; 0x01
    2828:	aa 83       	std	Y+2, r26	; 0x02
    282a:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinRollSetpointRads(float val)
				{
					minRollSetpointRads = val;
    282c:	ef 01       	movw	r28, r30
    282e:	c6 58       	subi	r28, 0x86	; 134
    2830:	df 4f       	sbci	r29, 0xFF	; 255
    2832:	82 ec       	ldi	r24, 0xC2	; 194
    2834:	98 eb       	ldi	r25, 0xB8	; 184
    2836:	a2 eb       	ldi	r26, 0xB2	; 178
    2838:	bd eb       	ldi	r27, 0xBD	; 189
    283a:	88 83       	st	Y, r24
    283c:	99 83       	std	Y+1, r25	; 0x01
    283e:	aa 83       	std	Y+2, r26	; 0x02
    2840:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMaxPitchSetpointRads(float val)
				{
					maxPitchSetpointRads = val;
    2842:	ef 01       	movw	r28, r30
    2844:	ca 58       	subi	r28, 0x8A	; 138
    2846:	df 4f       	sbci	r29, 0xFF	; 255
    2848:	86 e9       	ldi	r24, 0x96	; 150
    284a:	96 e5       	ldi	r25, 0x56	; 86
    284c:	a8 e6       	ldi	r26, 0x68	; 104
    284e:	be e3       	ldi	r27, 0x3E	; 62
    2850:	88 83       	st	Y, r24
    2852:	99 83       	std	Y+1, r25	; 0x01
    2854:	aa 83       	std	Y+2, r26	; 0x02
    2856:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinPitchSetpointRads(float val)
				{	
					minPitchSetpointRads = val;
    2858:	ee 58       	subi	r30, 0x8E	; 142
    285a:	ff 4f       	sbci	r31, 0xFF	; 255
    285c:	86 e9       	ldi	r24, 0x96	; 150
    285e:	96 e5       	ldi	r25, 0x56	; 86
    2860:	a8 e6       	ldi	r26, 0x68	; 104
    2862:	be eb       	ldi	r27, 0xBE	; 190
    2864:	80 83       	st	Z, r24
    2866:	91 83       	std	Z+1, r25	; 0x01
    2868:	a2 83       	std	Z+2, r26	; 0x02
    286a:	b3 83       	std	Z+3, r27	; 0x03
	pidController->setMaxPitchSetpointRads(0.226892803);
	pidController->setMinPitchSetpointRads(-0.226892803);	
	
	
	
}
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	1f 91       	pop	r17
    2872:	0f 91       	pop	r16
    2874:	08 95       	ret

00002876 <main>:

//SystemModel *publicModel = NULL;
//static SystemModel *publicModel = new SystemModel();

int main(void)
{	
    2876:	cf 93       	push	r28
    2878:	df 93       	push	r29
    287a:	cd b7       	in	r28, 0x3d	; 61
    287c:	de b7       	in	r29, 0x3e	; 62
    287e:	a8 97       	sbiw	r28, 0x28	; 40
    2880:	0f b6       	in	r0, 0x3f	; 63
    2882:	f8 94       	cli
    2884:	de bf       	out	0x3e, r29	; 62
    2886:	0f be       	out	0x3f, r0	; 63
    2888:	cd bf       	out	0x3d, r28	; 61
	
	
	DDRA |= (1<<PA4);
    288a:	0c 9a       	sbi	0x01, 4	; 1
	PORTA &= ~(1<<PA4);
    288c:	14 98       	cbi	0x02, 4	; 2
	
	MatrixUtil::createLookupTables();
    288e:	0e 94 df 65 	call	0xcbbe	; 0xcbbe <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>

	
	bool sendControlToServos = false;
	bool receiveGains = false;
	
	Scheduler *scheduler = Scheduler::getScheduler();
    2892:	0e 94 4a 42 	call	0x8494	; 0x8494 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    2896:	98 a7       	std	Y+40, r25	; 0x28
    2898:	8f a3       	std	Y+39, r24	; 0x27
	
	SystemModel *model = new SystemModel();
    289a:	8f e4       	ldi	r24, 0x4F	; 79
    289c:	91 e0       	ldi	r25, 0x01	; 1
    289e:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    28a2:	4c 01       	movw	r8, r24
    28a4:	0e 94 a7 10 	call	0x214e	; 0x214e <_ZN10helicopter5model11SystemModelC1Ev>
	SystemModel::publicModel = model;
    28a8:	90 92 a5 03 	sts	0x03A5, r9
    28ac:	80 92 a4 03 	sts	0x03A4, r8
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
			void FlightMode( FlightModes val ) { flightMode = val;}
    28b0:	d4 01       	movw	r26, r8
    28b2:	13 96       	adiw	r26, 0x03	; 3
    28b4:	1c 92       	st	X, r1
    28b6:	13 97       	sbiw	r26, 0x03	; 3
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
    28b8:	14 96       	adiw	r26, 0x04	; 4
    28ba:	1c 92       	st	X, r1
    28bc:	14 97       	sbiw	r26, 0x04	; 4
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
    28be:	15 96       	adiw	r26, 0x05	; 5
    28c0:	1c 92       	st	X, r1
	}
	
	

	
	PIDController *pidController = new PIDController(model);
    28c2:	8e e8       	ldi	r24, 0x8E	; 142
    28c4:	90 e0       	ldi	r25, 0x00	; 0
    28c6:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    28ca:	3c 01       	movw	r6, r24
    28cc:	b4 01       	movw	r22, r8
    28ce:	0e 94 76 02 	call	0x4ec	; 0x4ec <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>
	
	setupDefaultsandReferencePosition(model, pidController);
    28d2:	b3 01       	movw	r22, r6
    28d4:	c4 01       	movw	r24, r8
    28d6:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>
			void FlightMode( FlightModes val ) { flightMode = val;}
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
    28da:	f4 01       	movw	r30, r8
    28dc:	85 81       	ldd	r24, Z+5	; 0x05
	Timer *timer = NULL;
	
	unsigned long serialDriverBaudRate = 0;
	
		
	if (model->CommunicationMethod() == SystemModel::USB)
    28de:	81 11       	cpse	r24, r1
    28e0:	34 c0       	rjmp	.+104    	; 0x294a <main+0xd4>
	{
		serialDriverBaudRate = 250000;
		
		//Timer *timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 100); //Good timeout when using the USB
		timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 50); //Good timeout when using the USB
    28e2:	8a e0       	ldi	r24, 0x0A	; 10
    28e4:	90 e0       	ldi	r25, 0x00	; 0
    28e6:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    28ea:	8c 01       	movw	r16, r24
				 * Now that this is using an 8 bit timer, prescaler has to be 1024, and timeout millizeconds
				 * has to be divisible by 10 and greater than 10. E.g. 10, 20, 30, 200, etc. 
				 */
				Timer (unsigned long cpuSpeed, PRESCALER timerPrescaler, unsigned long timeoutMilliseconds):
					cpuSpeed(cpuSpeed), timerPrescaler(timerPrescaler), timeoutMilliseconds(timeoutMilliseconds),
					numberOfTimeouts(timeoutMilliseconds / 10)
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	94 e2       	ldi	r25, 0x24	; 36
    28f0:	a4 ef       	ldi	r26, 0xF4	; 244
    28f2:	b0 e0       	ldi	r27, 0x00	; 0
    28f4:	f8 01       	movw	r30, r16
    28f6:	80 83       	st	Z, r24
    28f8:	91 83       	std	Z+1, r25	; 0x01
    28fa:	a2 83       	std	Z+2, r26	; 0x02
    28fc:	b3 83       	std	Z+3, r27	; 0x03
    28fe:	80 e0       	ldi	r24, 0x00	; 0
    2900:	94 e0       	ldi	r25, 0x04	; 4
    2902:	95 83       	std	Z+5, r25	; 0x05
    2904:	84 83       	std	Z+4, r24	; 0x04
    2906:	82 e3       	ldi	r24, 0x32	; 50
    2908:	90 e0       	ldi	r25, 0x00	; 0
    290a:	97 83       	std	Z+7, r25	; 0x07
    290c:	86 83       	std	Z+6, r24	; 0x06
    290e:	85 e0       	ldi	r24, 0x05	; 5
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	91 87       	std	Z+9, r25	; 0x09
    2914:	80 87       	std	Z+8, r24	; 0x08
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, timer);//MOSTRECENT
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, true, timer); //latest 12/3/2014
    2916:	8b e0       	ldi	r24, 0x0B	; 11
    2918:	90 e0       	ldi	r25, 0x00	; 0
    291a:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    291e:	5c 01       	movw	r10, r24
					Timer *timer = NULL) :
				baudRate(baudRate),
				uartPort(uartPort),
				useDoubleSpeedMode(useDoubleSpeedMode),
				asyncReceiveTransmitData(asyncReceiveTransmitData),
				timer(timer)
    2920:	82 e1       	ldi	r24, 0x12	; 18
    2922:	92 e0       	ldi	r25, 0x02	; 2
    2924:	d5 01       	movw	r26, r10
    2926:	8d 93       	st	X+, r24
    2928:	9c 93       	st	X, r25
    292a:	80 e9       	ldi	r24, 0x90	; 144
    292c:	90 ed       	ldi	r25, 0xD0	; 208
    292e:	a3 e0       	ldi	r26, 0x03	; 3
    2930:	b0 e0       	ldi	r27, 0x00	; 0
    2932:	f5 01       	movw	r30, r10
    2934:	82 83       	std	Z+2, r24	; 0x02
    2936:	93 83       	std	Z+3, r25	; 0x03
    2938:	a4 83       	std	Z+4, r26	; 0x04
    293a:	b5 83       	std	Z+5, r27	; 0x05
    293c:	16 82       	std	Z+6, r1	; 0x06
    293e:	17 82       	std	Z+7, r1	; 0x07
    2940:	81 e0       	ldi	r24, 0x01	; 1
    2942:	80 87       	std	Z+8, r24	; 0x08
    2944:	12 87       	std	Z+10, r17	; 0x0a
    2946:	01 87       	std	Z+9, r16	; 0x09
    2948:	38 c0       	rjmp	.+112    	; 0x29ba <main+0x144>
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, false, timer);
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, NULL);
	}else if (model->CommunicationMethod() == SystemModel::Radio)
    294a:	81 30       	cpi	r24, 0x01	; 1
    294c:	a1 f5       	brne	.+104    	; 0x29b6 <main+0x140>
	{
		//serialDriverBaudRate = 57600;
		serialDriverBaudRate = 115200;
		//timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,75); //Good timeout when using the radio
		
		timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,200);//unfortunately for radio, the initial setup is a huge amount of data which takes a long time.
    294e:	8a e0       	ldi	r24, 0x0A	; 10
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2956:	8c 01       	movw	r16, r24
    2958:	80 e0       	ldi	r24, 0x00	; 0
    295a:	94 e2       	ldi	r25, 0x24	; 36
    295c:	a4 ef       	ldi	r26, 0xF4	; 244
    295e:	b0 e0       	ldi	r27, 0x00	; 0
    2960:	f8 01       	movw	r30, r16
    2962:	80 83       	st	Z, r24
    2964:	91 83       	std	Z+1, r25	; 0x01
    2966:	a2 83       	std	Z+2, r26	; 0x02
    2968:	b3 83       	std	Z+3, r27	; 0x03
    296a:	80 e0       	ldi	r24, 0x00	; 0
    296c:	94 e0       	ldi	r25, 0x04	; 4
    296e:	95 83       	std	Z+5, r25	; 0x05
    2970:	84 83       	std	Z+4, r24	; 0x04
    2972:	88 ec       	ldi	r24, 0xC8	; 200
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	97 83       	std	Z+7, r25	; 0x07
    2978:	86 83       	std	Z+6, r24	; 0x06
    297a:	84 e1       	ldi	r24, 0x14	; 20
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	91 87       	std	Z+9, r25	; 0x09
    2980:	80 87       	std	Z+8, r24	; 0x08
			
		//Use a slower baud rate because the real helicopter uses the radio for communication
		//which is slower than USB.
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
    2982:	8b e0       	ldi	r24, 0x0B	; 11
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    298a:	5c 01       	movw	r10, r24
    298c:	82 e1       	ldi	r24, 0x12	; 18
    298e:	92 e0       	ldi	r25, 0x02	; 2
    2990:	d5 01       	movw	r26, r10
    2992:	8d 93       	st	X+, r24
    2994:	9c 93       	st	X, r25
    2996:	80 e0       	ldi	r24, 0x00	; 0
    2998:	92 ec       	ldi	r25, 0xC2	; 194
    299a:	a1 e0       	ldi	r26, 0x01	; 1
    299c:	b0 e0       	ldi	r27, 0x00	; 0
    299e:	f5 01       	movw	r30, r10
    29a0:	82 83       	std	Z+2, r24	; 0x02
    29a2:	93 83       	std	Z+3, r25	; 0x03
    29a4:	a4 83       	std	Z+4, r26	; 0x04
    29a6:	b5 83       	std	Z+5, r27	; 0x05
    29a8:	16 82       	std	Z+6, r1	; 0x06
    29aa:	81 e0       	ldi	r24, 0x01	; 1
    29ac:	87 83       	std	Z+7, r24	; 0x07
    29ae:	80 87       	std	Z+8, r24	; 0x08
    29b0:	12 87       	std	Z+10, r17	; 0x0a
    29b2:	01 87       	std	Z+9, r16	; 0x09
    29b4:	02 c0       	rjmp	.+4      	; 0x29ba <main+0x144>
	setupDefaultsandReferencePosition(model, pidController);
	
	//Create a driver for communicating with the Ground Control Station (GCS).
	//SerialDriver *serialDriver = new SerialDriver(57600, SerialDriver::Zero, timer, true, true);
	//SerialDriver *serialDriver = new SerialDriver(76800, SerialDriver::Zero, true);
	SerialDriver *serialDriver = NULL;
    29b6:	a1 2c       	mov	r10, r1
    29b8:	b1 2c       	mov	r11, r1
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
		
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, false, timer);
	}
	
	serialDriver->init();
    29ba:	d5 01       	movw	r26, r10
    29bc:	ed 91       	ld	r30, X+
    29be:	fc 91       	ld	r31, X
    29c0:	04 80       	ldd	r0, Z+4	; 0x04
    29c2:	f5 81       	ldd	r31, Z+5	; 0x05
    29c4:	e0 2d       	mov	r30, r0
    29c6:	c5 01       	movw	r24, r10
    29c8:	19 95       	eicall
	//SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, false, gpsTimer);
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, gpsTimer);//LATEST
	
	//Don't care about gps timer anymore since it's only used on initialization. 
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, NULL);
	SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, true, false, NULL);
    29ca:	8b e0       	ldi	r24, 0x0B	; 11
    29cc:	90 e0       	ldi	r25, 0x00	; 0
    29ce:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    29d2:	9a 87       	std	Y+10, r25	; 0x0a
    29d4:	89 87       	std	Y+9, r24	; 0x09
    29d6:	82 e1       	ldi	r24, 0x12	; 18
    29d8:	92 e0       	ldi	r25, 0x02	; 2
    29da:	e9 85       	ldd	r30, Y+9	; 0x09
    29dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    29de:	91 83       	std	Z+1, r25	; 0x01
    29e0:	80 83       	st	Z, r24
    29e2:	80 e0       	ldi	r24, 0x00	; 0
    29e4:	96 e9       	ldi	r25, 0x96	; 150
    29e6:	a0 e0       	ldi	r26, 0x00	; 0
    29e8:	b0 e0       	ldi	r27, 0x00	; 0
    29ea:	82 83       	std	Z+2, r24	; 0x02
    29ec:	93 83       	std	Z+3, r25	; 0x03
    29ee:	a4 83       	std	Z+4, r26	; 0x04
    29f0:	b5 83       	std	Z+5, r27	; 0x05
    29f2:	81 e0       	ldi	r24, 0x01	; 1
    29f4:	86 83       	std	Z+6, r24	; 0x06
    29f6:	87 83       	std	Z+7, r24	; 0x07
    29f8:	10 86       	std	Z+8, r1	; 0x08
    29fa:	12 86       	std	Z+10, r1	; 0x0a
    29fc:	11 86       	std	Z+9, r1	; 0x09
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, false, gpsTimer);
	gpsSerialDriver->init();
    29fe:	cf 01       	movw	r24, r30
    2a00:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <_ZN10helicopter7drivers12SerialDriver4initEv>

	
	
	
	
	TWIDriver *twiDriver = new TWIDriver();
    2a04:	81 e0       	ldi	r24, 0x01	; 1
    2a06:	90 e0       	ldi	r25, 0x00	; 0
    2a08:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2a0c:	9a a3       	std	Y+34, r25	; 0x22
    2a0e:	89 a3       	std	Y+33, r24	; 0x21
	twiDriver->init();
    2a10:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <_ZN10helicopter7drivers9TWIDriver4initEv>

	
	
	GroundControlStationInterface *gcsInterface = new GroundControlStationInterface(serialDriver);
    2a14:	82 e0       	ldi	r24, 0x02	; 2
    2a16:	90 e0       	ldi	r25, 0x00	; 0
    2a18:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2a1c:	2c 01       	movw	r4, r24
				 * as receiving a byte.
				 * @param serialDriver the driver used to communicate with the serial port
				 * which is used to communicate with the Ground Control Station.
				 */
				GroundControlStationInterface(SerialDriver *serialDriver):
					serialDriver(serialDriver)
    2a1e:	dc 01       	movw	r26, r24
    2a20:	ad 92       	st	X+, r10
    2a22:	bc 92       	st	X, r11
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
    2a24:	f4 01       	movw	r30, r8
    2a26:	83 81       	ldd	r24, Z+3	; 0x03
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 5;

	if (model->FlightMode() == SystemModel::RealFlightTest)
    2a28:	81 30       	cpi	r24, 0x01	; 1
    2a2a:	b1 f5       	brne	.+108    	; 0x2a98 <main+0x222>
		barometerInitReadings = 1300;
		sensorInitReadings = 100;
		*/
		
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2a2c:	8c e0       	ldi	r24, 0x0C	; 12
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
    2a30:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2a34:	9e 83       	std	Y+6, r25	; 0x06
    2a36:	8d 83       	std	Y+5, r24	; 0x05
    2a38:	0f 2e       	mov	r0, r31
    2a3a:	f4 e6       	ldi	r31, 0x64	; 100
    2a3c:	ef 2e       	mov	r14, r31
    2a3e:	f1 2c       	mov	r15, r1
    2a40:	f0 2d       	mov	r31, r0
    2a42:	01 e0       	ldi	r16, 0x01	; 1
    2a44:	10 e0       	ldi	r17, 0x00	; 0
    2a46:	22 e0       	ldi	r18, 0x02	; 2
    2a48:	a4 01       	movw	r20, r8
    2a4a:	b2 01       	movw	r22, r4
    2a4c:	0e 94 5a 64 	call	0xc8b4	; 0xc8b4 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2a50:	8e e0       	ldi	r24, 0x0E	; 14
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2a58:	9a 83       	std	Y+2, r25	; 0x02
    2a5a:	89 83       	std	Y+1, r24	; 0x01
    2a5c:	0f 2e       	mov	r0, r31
    2a5e:	f4 e6       	ldi	r31, 0x64	; 100
    2a60:	cf 2e       	mov	r12, r31
    2a62:	d1 2c       	mov	r13, r1
    2a64:	f0 2d       	mov	r31, r0
    2a66:	e1 2c       	mov	r14, r1
    2a68:	f1 2c       	mov	r15, r1
    2a6a:	01 e0       	ldi	r16, 0x01	; 1
    2a6c:	93 01       	movw	r18, r6
    2a6e:	a4 01       	movw	r20, r8
    2a70:	b2 01       	movw	r22, r4
    2a72:	0e 94 02 60 	call	0xc004	; 0xc004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 5;
    2a76:	25 e0       	ldi	r18, 0x05	; 5
    2a78:	30 e0       	ldi	r19, 0x00	; 0
    2a7a:	3a 8f       	std	Y+26, r19	; 0x1a
    2a7c:	29 8f       	std	Y+25, r18	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2a7e:	45 e0       	ldi	r20, 0x05	; 5
    2a80:	50 e0       	ldi	r21, 0x00	; 0
    2a82:	58 8b       	std	Y+16, r21	; 0x10
    2a84:	4f 87       	std	Y+15, r20	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2a86:	80 e2       	ldi	r24, 0x20	; 32
    2a88:	9e e4       	ldi	r25, 0x4E	; 78
    2a8a:	a0 e0       	ldi	r26, 0x00	; 0
    2a8c:	b0 e0       	ldi	r27, 0x00	; 0
    2a8e:	8d 8b       	std	Y+21, r24	; 0x15
    2a90:	9e 8b       	std	Y+22, r25	; 0x16
    2a92:	af 8b       	std	Y+23, r26	; 0x17
    2a94:	b8 8f       	std	Y+24, r27	; 0x18
    2a96:	bc c0       	rjmp	.+376    	; 0x2c10 <main+0x39a>
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
    2a98:	83 30       	cpi	r24, 0x03	; 3
    2a9a:	b1 f5       	brne	.+108    	; 0x2b08 <main+0x292>
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
		
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2a9c:	8c e0       	ldi	r24, 0x0C	; 12
    2a9e:	90 e0       	ldi	r25, 0x00	; 0
    2aa0:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2aa4:	9e 83       	std	Y+6, r25	; 0x06
    2aa6:	8d 83       	std	Y+5, r24	; 0x05
    2aa8:	0f 2e       	mov	r0, r31
    2aaa:	f4 e6       	ldi	r31, 0x64	; 100
    2aac:	ef 2e       	mov	r14, r31
    2aae:	f1 2c       	mov	r15, r1
    2ab0:	f0 2d       	mov	r31, r0
    2ab2:	01 e0       	ldi	r16, 0x01	; 1
    2ab4:	10 e0       	ldi	r17, 0x00	; 0
    2ab6:	22 e0       	ldi	r18, 0x02	; 2
    2ab8:	a4 01       	movw	r20, r8
    2aba:	b2 01       	movw	r22, r4
    2abc:	0e 94 5a 64 	call	0xc8b4	; 0xc8b4 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2ac0:	8e e0       	ldi	r24, 0x0E	; 14
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2ac8:	9a 83       	std	Y+2, r25	; 0x02
    2aca:	89 83       	std	Y+1, r24	; 0x01
    2acc:	0f 2e       	mov	r0, r31
    2ace:	f4 e6       	ldi	r31, 0x64	; 100
    2ad0:	cf 2e       	mov	r12, r31
    2ad2:	d1 2c       	mov	r13, r1
    2ad4:	f0 2d       	mov	r31, r0
    2ad6:	e1 2c       	mov	r14, r1
    2ad8:	f1 2c       	mov	r15, r1
    2ada:	01 e0       	ldi	r16, 0x01	; 1
    2adc:	93 01       	movw	r18, r6
    2ade:	a4 01       	movw	r20, r8
    2ae0:	b2 01       	movw	r22, r4
    2ae2:	0e 94 02 60 	call	0xc004	; 0xc004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
    2ae6:	a4 ef       	ldi	r26, 0xF4	; 244
    2ae8:	b1 e0       	ldi	r27, 0x01	; 1
    2aea:	ba 8f       	std	Y+26, r27	; 0x1a
    2aec:	a9 8f       	std	Y+25, r26	; 0x19
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
    2aee:	e8 ee       	ldi	r30, 0xE8	; 232
    2af0:	f3 e0       	ldi	r31, 0x03	; 3
    2af2:	f8 8b       	std	Y+16, r31	; 0x10
    2af4:	ef 87       	std	Y+15, r30	; 0x0f
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
    2af6:	24 e8       	ldi	r18, 0x84	; 132
    2af8:	33 e0       	ldi	r19, 0x03	; 3
    2afa:	40 e0       	ldi	r20, 0x00	; 0
    2afc:	50 e0       	ldi	r21, 0x00	; 0
    2afe:	2d 8b       	std	Y+21, r18	; 0x15
    2b00:	3e 8b       	std	Y+22, r19	; 0x16
    2b02:	4f 8b       	std	Y+23, r20	; 0x17
    2b04:	58 8f       	std	Y+24, r21	; 0x18
    2b06:	84 c0       	rjmp	.+264    	; 0x2c10 <main+0x39a>
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
	}else if (model->FlightMode() == SystemModel::SimulatedFlight)
    2b08:	81 11       	cpse	r24, r1
    2b0a:	36 c0       	rjmp	.+108    	; 0x2b78 <main+0x302>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05)); //latest 12/3/2014
    2b0c:	8c e0       	ldi	r24, 0x0C	; 12
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2b14:	9e 83       	std	Y+6, r25	; 0x06
    2b16:	8d 83       	std	Y+5, r24	; 0x05
    2b18:	0f 2e       	mov	r0, r31
    2b1a:	fa e0       	ldi	r31, 0x0A	; 10
    2b1c:	ef 2e       	mov	r14, r31
    2b1e:	f1 2c       	mov	r15, r1
    2b20:	f0 2d       	mov	r31, r0
    2b22:	01 e0       	ldi	r16, 0x01	; 1
    2b24:	10 e0       	ldi	r17, 0x00	; 0
    2b26:	20 e0       	ldi	r18, 0x00	; 0
    2b28:	a4 01       	movw	r20, r8
    2b2a:	b2 01       	movw	r22, r4
    2b2c:	0e 94 5a 64 	call	0xc8b4	; 0xc8b4 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    2b30:	8e e0       	ldi	r24, 0x0E	; 14
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2b38:	9a 83       	std	Y+2, r25	; 0x02
    2b3a:	89 83       	std	Y+1, r24	; 0x01
    2b3c:	0f 2e       	mov	r0, r31
    2b3e:	fa e0       	ldi	r31, 0x0A	; 10
    2b40:	cf 2e       	mov	r12, r31
    2b42:	d1 2c       	mov	r13, r1
    2b44:	f0 2d       	mov	r31, r0
    2b46:	e1 2c       	mov	r14, r1
    2b48:	f1 2c       	mov	r15, r1
    2b4a:	00 e0       	ldi	r16, 0x00	; 0
    2b4c:	93 01       	movw	r18, r6
    2b4e:	a4 01       	movw	r20, r8
    2b50:	b2 01       	movw	r22, r4
    2b52:	0e 94 02 60 	call	0xc004	; 0xc004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 5;
    2b56:	45 e0       	ldi	r20, 0x05	; 5
    2b58:	50 e0       	ldi	r21, 0x00	; 0
    2b5a:	5a 8f       	std	Y+26, r21	; 0x1a
    2b5c:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2b5e:	85 e0       	ldi	r24, 0x05	; 5
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	98 8b       	std	Y+16, r25	; 0x10
    2b64:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2b66:	20 e2       	ldi	r18, 0x20	; 32
    2b68:	3e e4       	ldi	r19, 0x4E	; 78
    2b6a:	40 e0       	ldi	r20, 0x00	; 0
    2b6c:	50 e0       	ldi	r21, 0x00	; 0
    2b6e:	2d 8b       	std	Y+21, r18	; 0x15
    2b70:	3e 8b       	std	Y+22, r19	; 0x16
    2b72:	4f 8b       	std	Y+23, r20	; 0x17
    2b74:	58 8f       	std	Y+24, r21	; 0x18
    2b76:	4c c0       	rjmp	.+152    	; 0x2c10 <main+0x39a>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
		//simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
	}else if (model->FlightMode() == SystemModel::HardwareInLoopSimulatedFlight)
    2b78:	82 30       	cpi	r24, 0x02	; 2
    2b7a:	b1 f5       	brne	.+108    	; 0x2be8 <main+0x372>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
    2b7c:	8c e0       	ldi	r24, 0x0C	; 12
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2b84:	9e 83       	std	Y+6, r25	; 0x06
    2b86:	8d 83       	std	Y+5, r24	; 0x05
    2b88:	0f 2e       	mov	r0, r31
    2b8a:	fa e0       	ldi	r31, 0x0A	; 10
    2b8c:	ef 2e       	mov	r14, r31
    2b8e:	f1 2c       	mov	r15, r1
    2b90:	f0 2d       	mov	r31, r0
    2b92:	01 e0       	ldi	r16, 0x01	; 1
    2b94:	10 e0       	ldi	r17, 0x00	; 0
    2b96:	21 e0       	ldi	r18, 0x01	; 1
    2b98:	a4 01       	movw	r20, r8
    2b9a:	b2 01       	movw	r22, r4
    2b9c:	0e 94 5a 64 	call	0xc8b4	; 0xc8b4 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    2ba0:	8e e0       	ldi	r24, 0x0E	; 14
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2ba8:	9a 83       	std	Y+2, r25	; 0x02
    2baa:	89 83       	std	Y+1, r24	; 0x01
    2bac:	0f 2e       	mov	r0, r31
    2bae:	fa e0       	ldi	r31, 0x0A	; 10
    2bb0:	cf 2e       	mov	r12, r31
    2bb2:	d1 2c       	mov	r13, r1
    2bb4:	f0 2d       	mov	r31, r0
    2bb6:	e1 2c       	mov	r14, r1
    2bb8:	f1 2c       	mov	r15, r1
    2bba:	01 e0       	ldi	r16, 0x01	; 1
    2bbc:	93 01       	movw	r18, r6
    2bbe:	a4 01       	movw	r20, r8
    2bc0:	b2 01       	movw	r22, r4
    2bc2:	0e 94 02 60 	call	0xc004	; 0xc004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 5;
    2bc6:	45 e0       	ldi	r20, 0x05	; 5
    2bc8:	50 e0       	ldi	r21, 0x00	; 0
    2bca:	5a 8f       	std	Y+26, r21	; 0x1a
    2bcc:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2bce:	85 e0       	ldi	r24, 0x05	; 5
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	98 8b       	std	Y+16, r25	; 0x10
    2bd4:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2bd6:	20 e2       	ldi	r18, 0x20	; 32
    2bd8:	3e e4       	ldi	r19, 0x4E	; 78
    2bda:	40 e0       	ldi	r20, 0x00	; 0
    2bdc:	50 e0       	ldi	r21, 0x00	; 0
    2bde:	2d 8b       	std	Y+21, r18	; 0x15
    2be0:	3e 8b       	std	Y+22, r19	; 0x16
    2be2:	4f 8b       	std	Y+23, r20	; 0x17
    2be4:	58 8f       	std	Y+24, r21	; 0x18
    2be6:	14 c0       	rjmp	.+40     	; 0x2c10 <main+0x39a>
	int barometerInitReadings = 5;
	int sensorInitReadings = 5;
    2be8:	45 e0       	ldi	r20, 0x05	; 5
    2bea:	50 e0       	ldi	r21, 0x00	; 0
    2bec:	5a 8f       	std	Y+26, r21	; 0x1a
    2bee:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2bf0:	85 e0       	ldi	r24, 0x05	; 5
    2bf2:	90 e0       	ldi	r25, 0x00	; 0
    2bf4:	98 8b       	std	Y+16, r25	; 0x10
    2bf6:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2bf8:	20 e2       	ldi	r18, 0x20	; 32
    2bfa:	3e e4       	ldi	r19, 0x4E	; 78
    2bfc:	40 e0       	ldi	r20, 0x00	; 0
    2bfe:	50 e0       	ldi	r21, 0x00	; 0
    2c00:	2d 8b       	std	Y+21, r18	; 0x15
    2c02:	3e 8b       	std	Y+22, r19	; 0x16
    2c04:	4f 8b       	std	Y+23, r20	; 0x17
    2c06:	58 8f       	std	Y+24, r21	; 0x18
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
    2c08:	1e 82       	std	Y+6, r1	; 0x06
    2c0a:	1d 82       	std	Y+5, r1	; 0x05
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
    2c0c:	1a 82       	std	Y+2, r1	; 0x02
    2c0e:	19 82       	std	Y+1, r1	; 0x01
SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,0, SCHEDULER_TICK_FREQUENCY_HZ);//execute 1 hz
TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, 0, SCHEDULER_TICK_FREQUENCY_HZ);
*/
	
	
	FlashLEDTask *flashTask = new FlashLEDTask(2, SCHEDULER_TICK_FREQUENCY_HZ);//starting at tick 2, execute once a second
    2c10:	8a e0       	ldi	r24, 0x0A	; 10
    2c12:	90 e0       	ldi	r25, 0x00	; 0
    2c14:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2c18:	9c 8f       	std	Y+28, r25	; 0x1c
    2c1a:	8b 8f       	std	Y+27, r24	; 0x1b
			public:

			FlashLEDTask (int delay, int period, int ledToBlink = BLUELED) : 
				Task(delay, period),
				isOff(false),
				ledToBlink(ledToBlink)
    2c1c:	48 ec       	ldi	r20, 0xC8	; 200
    2c1e:	50 e0       	ldi	r21, 0x00	; 0
    2c20:	62 e0       	ldi	r22, 0x02	; 2
    2c22:	70 e0       	ldi	r23, 0x00	; 0
    2c24:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    2c28:	8a e2       	ldi	r24, 0x2A	; 42
    2c2a:	92 e0       	ldi	r25, 0x02	; 2
    2c2c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    2c2e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    2c30:	11 96       	adiw	r26, 0x01	; 1
    2c32:	9c 93       	st	X, r25
    2c34:	8e 93       	st	-X, r24
    2c36:	17 96       	adiw	r26, 0x07	; 7
    2c38:	1c 92       	st	X, r1
    2c3a:	17 97       	sbiw	r26, 0x07	; 7
    2c3c:	83 e0       	ldi	r24, 0x03	; 3
    2c3e:	90 e0       	ldi	r25, 0x00	; 0
    2c40:	19 96       	adiw	r26, 0x09	; 9
    2c42:	9c 93       	st	X, r25
    2c44:	8e 93       	st	-X, r24
    2c46:	18 97       	sbiw	r26, 0x08	; 8
		
//	SensorProcessingTask *sensorProcessingTask = new SensorProcessingTask(model, 5, 4);
		
	//execute the pid outer loop at the PID_OUTER_LOOP_PERIOD rate. The division is to convert the period into ticks for the scheduler.

	PIDOuterLoopTask *pidOuterLoop = new PIDOuterLoopTask(pidController, 3, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_OUTER_LOOP_PERIOD));
    2c48:	89 e0       	ldi	r24, 0x09	; 9
    2c4a:	90 e0       	ldi	r25, 0x00	; 0
    2c4c:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2c50:	9c a3       	std	Y+36, r25	; 0x24
    2c52:	8b a3       	std	Y+35, r24	; 0x23
    2c54:	2a e0       	ldi	r18, 0x0A	; 10
    2c56:	30 e0       	ldi	r19, 0x00	; 0
    2c58:	43 e0       	ldi	r20, 0x03	; 3
    2c5a:	50 e0       	ldi	r21, 0x00	; 0
    2c5c:	b3 01       	movw	r22, r6
    2c5e:	0e 94 8e 56 	call	0xad1c	; 0xad1c <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
    2c62:	89 e0       	ldi	r24, 0x09	; 9
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2c6a:	9e a3       	std	Y+38, r25	; 0x26
    2c6c:	8d a3       	std	Y+37, r24	; 0x25
    2c6e:	24 e0       	ldi	r18, 0x04	; 4
    2c70:	30 e0       	ldi	r19, 0x00	; 0
    2c72:	44 e0       	ldi	r20, 0x04	; 4
    2c74:	50 e0       	ldi	r21, 0x00	; 0
    2c76:	b3 01       	movw	r22, r6
    2c78:	0e 94 65 56 	call	0xacca	; 0xacca <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>
	//float barometerSensorReadPeriod = 1/50.0f;
	float simulatorSensorReadPeriod = barometerSensorReadPeriod;
	
	float sensorReadPeriod = 0;
		
	if (model->SensorInput() == SystemModel::SimulatedSensors)
    2c7c:	f4 01       	movw	r30, r8
    2c7e:	84 81       	ldd	r24, Z+4	; 0x04
    2c80:	81 11       	cpse	r24, r1
    2c82:	13 c0       	rjmp	.+38     	; 0x2caa <main+0x434>
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
    2c84:	0f 2e       	mov	r0, r31
    2c86:	fd ec       	ldi	r31, 0xCD	; 205
    2c88:	cf 2e       	mov	r12, r31
    2c8a:	fc ec       	ldi	r31, 0xCC	; 204
    2c8c:	df 2e       	mov	r13, r31
    2c8e:	fc e4       	ldi	r31, 0x4C	; 76
    2c90:	ef 2e       	mov	r14, r31
    2c92:	fd e3       	ldi	r31, 0x3D	; 61
    2c94:	ff 2e       	mov	r15, r31
    2c96:	f0 2d       	mov	r31, r0
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
	float newBarometerSensorReadPeriod = barometerSensorReadPeriod;// how frequently NEW barometer sensor data is received. 
    2c98:	c9 8a       	std	Y+17, r12	; 0x11
    2c9a:	da 8a       	std	Y+18, r13	; 0x12
    2c9c:	eb 8a       	std	Y+19, r14	; 0x13
    2c9e:	fc 8a       	std	Y+20, r15	; 0x14
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
    2ca0:	cb 86       	std	Y+11, r12	; 0x0b
    2ca2:	dc 86       	std	Y+12, r13	; 0x0c
    2ca4:	ed 86       	std	Y+13, r14	; 0x0d
    2ca6:	fe 86       	std	Y+14, r15	; 0x0e
    2ca8:	1a c0       	rjmp	.+52     	; 0x2cde <main+0x468>
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
		sensorReadPeriod = GYRO_SENSOR_READ_PERIOD;
    2caa:	0f 2e       	mov	r0, r31
    2cac:	f5 e0       	ldi	r31, 0x05	; 5
    2cae:	cf 2e       	mov	r12, r31
    2cb0:	ff e2       	ldi	r31, 0x2F	; 47
    2cb2:	df 2e       	mov	r13, r31
    2cb4:	f7 e2       	ldi	r31, 0x27	; 39
    2cb6:	ef 2e       	mov	r14, r31
    2cb8:	fc e3       	ldi	r31, 0x3C	; 60
    2cba:	ff 2e       	mov	r15, r31
    2cbc:	f0 2d       	mov	r31, r0
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
    2cbe:	20 e9       	ldi	r18, 0x90	; 144
    2cc0:	32 ec       	ldi	r19, 0xC2	; 194
    2cc2:	45 e7       	ldi	r20, 0x75	; 117
    2cc4:	5d e3       	ldi	r21, 0x3D	; 61
    2cc6:	29 8b       	std	Y+17, r18	; 0x11
    2cc8:	3a 8b       	std	Y+18, r19	; 0x12
    2cca:	4b 8b       	std	Y+19, r20	; 0x13
    2ccc:	5c 8b       	std	Y+20, r21	; 0x14
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    2cce:	8a e0       	ldi	r24, 0x0A	; 10
    2cd0:	97 ed       	ldi	r25, 0xD7	; 215
    2cd2:	a3 ea       	ldi	r26, 0xA3	; 163
    2cd4:	bc e3       	ldi	r27, 0x3C	; 60
    2cd6:	8b 87       	std	Y+11, r24	; 0x0b
    2cd8:	9c 87       	std	Y+12, r25	; 0x0c
    2cda:	ad 87       	std	Y+13, r26	; 0x0d
    2cdc:	be 87       	std	Y+14, r27	; 0x0e
	}
	
		
	//AHRS *ahrs = new AHRS(GYRO_SENSOR_READ_PERIOD);
	//AHRS *ahrs = new AHRS(simulatorSensorReadPeriod); //for simulator angular velocity reads.
	AHRS *ahrs = new AHRS(sensorReadPeriod);
    2cde:	80 e7       	ldi	r24, 0x70	; 112
    2ce0:	90 e0       	ldi	r25, 0x00	; 0
    2ce2:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2ce6:	2c 01       	movw	r4, r24
					yawRads(0),
					pitchRads(0),
					rollRads(0),
					linearAccelerationXMss(0),
					linearAccelerationYMss(0),
					linearAccelerationZMss(0)	
    2ce8:	dc 01       	movw	r26, r24
    2cea:	cd 92       	st	X+, r12
    2cec:	dd 92       	st	X+, r13
    2cee:	ed 92       	st	X+, r14
    2cf0:	fc 92       	st	X, r15
    2cf2:	13 97       	sbiw	r26, 0x03	; 3
    2cf4:	fc 01       	movw	r30, r24
    2cf6:	14 82       	std	Z+4, r1	; 0x04
    2cf8:	15 82       	std	Z+5, r1	; 0x05
    2cfa:	16 82       	std	Z+6, r1	; 0x06
    2cfc:	17 82       	std	Z+7, r1	; 0x07
    2cfe:	18 96       	adiw	r26, 0x08	; 8
    2d00:	1d 92       	st	X+, r1
    2d02:	1d 92       	st	X+, r1
    2d04:	1d 92       	st	X+, r1
    2d06:	1c 92       	st	X, r1
    2d08:	1b 97       	sbiw	r26, 0x0b	; 11
    2d0a:	14 86       	std	Z+12, r1	; 0x0c
    2d0c:	15 86       	std	Z+13, r1	; 0x0d
    2d0e:	16 86       	std	Z+14, r1	; 0x0e
    2d10:	17 86       	std	Z+15, r1	; 0x0f
    2d12:	50 96       	adiw	r26, 0x10	; 16
    2d14:	1d 92       	st	X+, r1
    2d16:	1d 92       	st	X+, r1
    2d18:	1d 92       	st	X+, r1
    2d1a:	1c 92       	st	X, r1
    2d1c:	53 97       	sbiw	r26, 0x13	; 19
    2d1e:	14 8a       	std	Z+20, r1	; 0x14
    2d20:	15 8a       	std	Z+21, r1	; 0x15
    2d22:	16 8a       	std	Z+22, r1	; 0x16
    2d24:	17 8a       	std	Z+23, r1	; 0x17
    2d26:	58 96       	adiw	r26, 0x18	; 24
    2d28:	1d 92       	st	X+, r1
    2d2a:	1d 92       	st	X+, r1
    2d2c:	1d 92       	st	X+, r1
    2d2e:	1c 92       	st	X, r1
    2d30:	5b 97       	sbiw	r26, 0x1b	; 27
    2d32:	14 8e       	std	Z+28, r1	; 0x1c
    2d34:	15 8e       	std	Z+29, r1	; 0x1d
    2d36:	16 8e       	std	Z+30, r1	; 0x1e
    2d38:	17 8e       	std	Z+31, r1	; 0x1f
    2d3a:	90 96       	adiw	r26, 0x20	; 32
    2d3c:	1d 92       	st	X+, r1
    2d3e:	1d 92       	st	X+, r1
    2d40:	1d 92       	st	X+, r1
    2d42:	1c 92       	st	X, r1
    2d44:	93 97       	sbiw	r26, 0x23	; 35
    2d46:	14 a2       	std	Z+36, r1	; 0x24
    2d48:	15 a2       	std	Z+37, r1	; 0x25
    2d4a:	16 a2       	std	Z+38, r1	; 0x26
    2d4c:	17 a2       	std	Z+39, r1	; 0x27
    2d4e:	98 96       	adiw	r26, 0x28	; 40
    2d50:	1d 92       	st	X+, r1
    2d52:	1d 92       	st	X+, r1
    2d54:	1d 92       	st	X+, r1
    2d56:	1c 92       	st	X, r1
    2d58:	9b 97       	sbiw	r26, 0x2b	; 43
    2d5a:	14 a6       	std	Z+44, r1	; 0x2c
    2d5c:	15 a6       	std	Z+45, r1	; 0x2d
    2d5e:	16 a6       	std	Z+46, r1	; 0x2e
    2d60:	17 a6       	std	Z+47, r1	; 0x2f
    2d62:	d0 96       	adiw	r26, 0x30	; 48
    2d64:	1d 92       	st	X+, r1
    2d66:	1d 92       	st	X+, r1
    2d68:	1d 92       	st	X+, r1
    2d6a:	1c 92       	st	X, r1
    2d6c:	d3 97       	sbiw	r26, 0x33	; 51
    2d6e:	14 aa       	std	Z+52, r1	; 0x34
    2d70:	15 aa       	std	Z+53, r1	; 0x35
    2d72:	16 aa       	std	Z+54, r1	; 0x36
    2d74:	17 aa       	std	Z+55, r1	; 0x37
    2d76:	d8 96       	adiw	r26, 0x38	; 56
    2d78:	1d 92       	st	X+, r1
    2d7a:	1d 92       	st	X+, r1
    2d7c:	1d 92       	st	X+, r1
    2d7e:	1c 92       	st	X, r1
    2d80:	db 97       	sbiw	r26, 0x3b	; 59
    2d82:	14 ae       	std	Z+60, r1	; 0x3c
    2d84:	15 ae       	std	Z+61, r1	; 0x3d
    2d86:	16 ae       	std	Z+62, r1	; 0x3e
    2d88:	17 ae       	std	Z+63, r1	; 0x3f
				{
					/**
					 * Setup initial state of the DCM matrix with initial unit vectors
					 * {{1,0,0},{0,1,0},{0,0,-1}}
					 */
					dcm[0][0] = 1;
    2d8a:	e0 5c       	subi	r30, 0xC0	; 192
    2d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    2d8e:	80 e0       	ldi	r24, 0x00	; 0
    2d90:	90 e0       	ldi	r25, 0x00	; 0
    2d92:	a0 e8       	ldi	r26, 0x80	; 128
    2d94:	bf e3       	ldi	r27, 0x3F	; 63
    2d96:	80 83       	st	Z, r24
    2d98:	91 83       	std	Z+1, r25	; 0x01
    2d9a:	a2 83       	std	Z+2, r26	; 0x02
    2d9c:	b3 83       	std	Z+3, r27	; 0x03
					dcm[0][1] = 0;
    2d9e:	f2 01       	movw	r30, r4
    2da0:	ec 5b       	subi	r30, 0xBC	; 188
    2da2:	ff 4f       	sbci	r31, 0xFF	; 255
    2da4:	10 82       	st	Z, r1
    2da6:	11 82       	std	Z+1, r1	; 0x01
    2da8:	12 82       	std	Z+2, r1	; 0x02
    2daa:	13 82       	std	Z+3, r1	; 0x03
					dcm[0][2] = 0;
    2dac:	f2 01       	movw	r30, r4
    2dae:	e8 5b       	subi	r30, 0xB8	; 184
    2db0:	ff 4f       	sbci	r31, 0xFF	; 255
    2db2:	10 82       	st	Z, r1
    2db4:	11 82       	std	Z+1, r1	; 0x01
    2db6:	12 82       	std	Z+2, r1	; 0x02
    2db8:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][0] = 0;
    2dba:	f2 01       	movw	r30, r4
    2dbc:	e4 5b       	subi	r30, 0xB4	; 180
    2dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    2dc0:	10 82       	st	Z, r1
    2dc2:	11 82       	std	Z+1, r1	; 0x01
    2dc4:	12 82       	std	Z+2, r1	; 0x02
    2dc6:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][1] = 1;
    2dc8:	f2 01       	movw	r30, r4
    2dca:	e0 5b       	subi	r30, 0xB0	; 176
    2dcc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dce:	80 83       	st	Z, r24
    2dd0:	91 83       	std	Z+1, r25	; 0x01
    2dd2:	a2 83       	std	Z+2, r26	; 0x02
    2dd4:	b3 83       	std	Z+3, r27	; 0x03
					dcm[1][2] = 0;
    2dd6:	f2 01       	movw	r30, r4
    2dd8:	ec 5a       	subi	r30, 0xAC	; 172
    2dda:	ff 4f       	sbci	r31, 0xFF	; 255
    2ddc:	10 82       	st	Z, r1
    2dde:	11 82       	std	Z+1, r1	; 0x01
    2de0:	12 82       	std	Z+2, r1	; 0x02
    2de2:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][0] = 0;
    2de4:	f2 01       	movw	r30, r4
    2de6:	e8 5a       	subi	r30, 0xA8	; 168
    2de8:	ff 4f       	sbci	r31, 0xFF	; 255
    2dea:	10 82       	st	Z, r1
    2dec:	11 82       	std	Z+1, r1	; 0x01
    2dee:	12 82       	std	Z+2, r1	; 0x02
    2df0:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][1] = 0;
    2df2:	f2 01       	movw	r30, r4
    2df4:	e4 5a       	subi	r30, 0xA4	; 164
    2df6:	ff 4f       	sbci	r31, 0xFF	; 255
    2df8:	10 82       	st	Z, r1
    2dfa:	11 82       	std	Z+1, r1	; 0x01
    2dfc:	12 82       	std	Z+2, r1	; 0x02
    2dfe:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][2] = 1;
    2e00:	f2 01       	movw	r30, r4
    2e02:	e0 5a       	subi	r30, 0xA0	; 160
    2e04:	ff 4f       	sbci	r31, 0xFF	; 255
    2e06:	80 83       	st	Z, r24
    2e08:	91 83       	std	Z+1, r25	; 0x01
    2e0a:	a2 83       	std	Z+2, r26	; 0x02
    2e0c:	b3 83       	std	Z+3, r27	; 0x03
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
			void Ahrs(AHRS *val) {ahrs = val;}
    2e0e:	d4 01       	movw	r26, r8
    2e10:	4d 92       	st	X+, r4
    2e12:	5c 92       	st	X, r5
	NavigationTask *navTask = NULL;
	PVNavigationTask *pvNavTask = NULL;
	

	//navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * sensorReadPeriod)); //run at 98 hz.
	navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * .01f)); //run at 100 hz.
    2e14:	8b e1       	ldi	r24, 0x1B	; 27
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2e1c:	9e 8f       	std	Y+30, r25	; 0x1e
    2e1e:	8d 8f       	std	Y+29, r24	; 0x1d
    2e20:	68 94       	set
    2e22:	cc 24       	eor	r12, r12
    2e24:	c1 f8       	bld	r12, 1
    2e26:	d1 2c       	mov	r13, r1
    2e28:	0f 2e       	mov	r0, r31
    2e2a:	f5 e0       	ldi	r31, 0x05	; 5
    2e2c:	ef 2e       	mov	r14, r31
    2e2e:	f1 2c       	mov	r15, r1
    2e30:	f0 2d       	mov	r31, r0
    2e32:	84 01       	movw	r16, r8
    2e34:	92 01       	movw	r18, r4
    2e36:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e38:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e3a:	6d 85       	ldd	r22, Y+13	; 0x0d
    2e3c:	7e 85       	ldd	r23, Y+14	; 0x0e
    2e3e:	0e 94 0c 56 	call	0xac18	; 0xac18 <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>
	pvNavTask = new PVNavigationTask(newBarometerSensorReadPeriod, ahrs, model, 6, (SCHEDULER_TICK_FREQUENCY_HZ * barometerSensorReadPeriod)); //run at 50 hz
    2e42:	8f e0       	ldi	r24, 0x0F	; 15
    2e44:	90 e0       	ldi	r25, 0x00	; 0
    2e46:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2e4a:	98 a3       	std	Y+32, r25	; 0x20
    2e4c:	8f 8f       	std	Y+31, r24	; 0x1f
    2e4e:	20 e0       	ldi	r18, 0x00	; 0
    2e50:	30 e0       	ldi	r19, 0x00	; 0
    2e52:	48 e4       	ldi	r20, 0x48	; 72
    2e54:	53 e4       	ldi	r21, 0x43	; 67
    2e56:	6b 85       	ldd	r22, Y+11	; 0x0b
    2e58:	7c 85       	ldd	r23, Y+12	; 0x0c
    2e5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e5c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e5e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    2e62:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    2e66:	6b 01       	movw	r12, r22
    2e68:	0f 2e       	mov	r0, r31
    2e6a:	f6 e0       	ldi	r31, 0x06	; 6
    2e6c:	ef 2e       	mov	r14, r31
    2e6e:	f1 2c       	mov	r15, r1
    2e70:	f0 2d       	mov	r31, r0
    2e72:	92 01       	movw	r18, r4
    2e74:	49 89       	ldd	r20, Y+17	; 0x11
    2e76:	5a 89       	ldd	r21, Y+18	; 0x12
    2e78:	6b 89       	ldd	r22, Y+19	; 0x13
    2e7a:	7c 89       	ldd	r23, Y+20	; 0x14
    2e7c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e7e:	98 a1       	ldd	r25, Y+32	; 0x20
    2e80:	0e 94 a1 58 	call	0xb142	; 0xb142 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>



	SPIDriver *spiDriver = new SPIDriver();
    2e84:	81 e0       	ldi	r24, 0x01	; 1
    2e86:	90 e0       	ldi	r25, 0x00	; 0
    2e88:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2e8c:	8c 01       	movw	r16, r24
				SLAVE_SELECT_LINE ssLine;
			
			public: 
			
				SPIDriver(SLAVE_SELECT_LINE ssLine = SS_B):
					ssLine(ssLine)
    2e8e:	21 e0       	ldi	r18, 0x01	; 1
    2e90:	fc 01       	movw	r30, r24
    2e92:	20 83       	st	Z, r18
	spiDriver->init();
    2e94:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	SPIDriver *baroSpiDriver = new SPIDriver(SPIDriver::SS_G);
    2e98:	81 e0       	ldi	r24, 0x01	; 1
    2e9a:	90 e0       	ldi	r25, 0x00	; 0
    2e9c:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2ea0:	9c 87       	std	Y+12, r25	; 0x0c
    2ea2:	8b 87       	std	Y+11, r24	; 0x0b
    2ea4:	82 e0       	ldi	r24, 0x02	; 2
    2ea6:	ab 85       	ldd	r26, Y+11	; 0x0b
    2ea8:	bc 85       	ldd	r27, Y+12	; 0x0c
    2eaa:	8c 93       	st	X, r24
	baroSpiDriver->init();
    2eac:	cd 01       	movw	r24, r26
    2eae:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	IMUSensor *imuSensor = new IMUSensor(spiDriver);
    2eb2:	88 e5       	ldi	r24, 0x58	; 88
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2eba:	1c 01       	movw	r2, r24
					frdAccZMss(0),
					frdGyroXRs(0),
					frdGyroYRs(0),
					frdGyroZRs(0),
					hasBeenRead(true),
					missedRead(false)
    2ebc:	fc 01       	movw	r30, r24
    2ebe:	15 a3       	std	Z+37, r17	; 0x25
    2ec0:	04 a3       	std	Z+36, r16	; 0x24
    2ec2:	17 a2       	std	Z+39, r1	; 0x27
    2ec4:	16 a2       	std	Z+38, r1	; 0x26
    2ec6:	11 a6       	std	Z+41, r1	; 0x29
    2ec8:	10 a6       	std	Z+40, r1	; 0x28
    2eca:	13 a6       	std	Z+43, r1	; 0x2b
    2ecc:	12 a6       	std	Z+42, r1	; 0x2a
    2ece:	15 a6       	std	Z+45, r1	; 0x2d
    2ed0:	14 a6       	std	Z+44, r1	; 0x2c
    2ed2:	17 a6       	std	Z+47, r1	; 0x2f
    2ed4:	16 a6       	std	Z+46, r1	; 0x2e
    2ed6:	11 aa       	std	Z+49, r1	; 0x31
    2ed8:	10 aa       	std	Z+48, r1	; 0x30
    2eda:	12 aa       	std	Z+50, r1	; 0x32
    2edc:	13 aa       	std	Z+51, r1	; 0x33
    2ede:	14 aa       	std	Z+52, r1	; 0x34
    2ee0:	15 aa       	std	Z+53, r1	; 0x35
    2ee2:	16 aa       	std	Z+54, r1	; 0x36
    2ee4:	17 aa       	std	Z+55, r1	; 0x37
    2ee6:	10 ae       	std	Z+56, r1	; 0x38
    2ee8:	11 ae       	std	Z+57, r1	; 0x39
    2eea:	12 ae       	std	Z+58, r1	; 0x3a
    2eec:	13 ae       	std	Z+59, r1	; 0x3b
    2eee:	14 ae       	std	Z+60, r1	; 0x3c
    2ef0:	15 ae       	std	Z+61, r1	; 0x3d
    2ef2:	fe 96       	adiw	r30, 0x3e	; 62
    2ef4:	10 82       	st	Z, r1
    2ef6:	11 82       	std	Z+1, r1	; 0x01
    2ef8:	12 82       	std	Z+2, r1	; 0x02
    2efa:	13 82       	std	Z+3, r1	; 0x03
    2efc:	fc 01       	movw	r30, r24
    2efe:	ee 5b       	subi	r30, 0xBE	; 190
    2f00:	ff 4f       	sbci	r31, 0xFF	; 255
    2f02:	10 82       	st	Z, r1
    2f04:	11 82       	std	Z+1, r1	; 0x01
    2f06:	12 82       	std	Z+2, r1	; 0x02
    2f08:	13 82       	std	Z+3, r1	; 0x03
    2f0a:	fc 01       	movw	r30, r24
    2f0c:	ea 5b       	subi	r30, 0xBA	; 186
    2f0e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f10:	10 82       	st	Z, r1
    2f12:	11 82       	std	Z+1, r1	; 0x01
    2f14:	12 82       	std	Z+2, r1	; 0x02
    2f16:	13 82       	std	Z+3, r1	; 0x03
    2f18:	fc 01       	movw	r30, r24
    2f1a:	e6 5b       	subi	r30, 0xB6	; 182
    2f1c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f1e:	b1 e0       	ldi	r27, 0x01	; 1
    2f20:	b0 83       	st	Z, r27
    2f22:	fc 01       	movw	r30, r24
    2f24:	e5 5b       	subi	r30, 0xB5	; 181
    2f26:	ff 4f       	sbci	r31, 0xFF	; 255
    2f28:	10 82       	st	Z, r1
					/**
					 * Create a rotation matrix to rotate the accelerometer sensor data by
					 * 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
					 * clockwise on the Z axis.
					 */
					memset(imuRFUToFRDRotationMatrix,0,sizeof(imuRFUToFRDRotationMatrix));
    2f2a:	e8 2f       	mov	r30, r24
    2f2c:	f3 2d       	mov	r31, r3
    2f2e:	84 e2       	ldi	r24, 0x24	; 36
    2f30:	df 01       	movw	r26, r30
    2f32:	1d 92       	st	X+, r1
    2f34:	8a 95       	dec	r24
    2f36:	e9 f7       	brne	.-6      	; 0x2f32 <main+0x6bc>
					
					MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, (M_PI/2), imuRFUToFRDRotationMatrix);
    2f38:	c2 2c       	mov	r12, r2
    2f3a:	d3 2c       	mov	r13, r3
    2f3c:	1b ed       	ldi	r17, 0xDB	; 219
    2f3e:	e1 2e       	mov	r14, r17
    2f40:	1f e0       	ldi	r17, 0x0F	; 15
    2f42:	f1 2e       	mov	r15, r17
    2f44:	09 ec       	ldi	r16, 0xC9	; 201
    2f46:	1f e3       	ldi	r17, 0x3F	; 63
    2f48:	20 e0       	ldi	r18, 0x00	; 0
    2f4a:	30 e0       	ldi	r19, 0x00	; 0
    2f4c:	a9 01       	movw	r20, r18
    2f4e:	6b ed       	ldi	r22, 0xDB	; 219
    2f50:	7f e0       	ldi	r23, 0x0F	; 15
    2f52:	89 e4       	ldi	r24, 0x49	; 73
    2f54:	90 e4       	ldi	r25, 0x40	; 64
    2f56:	0e 94 1d 67 	call	0xce3a	; 0xce3a <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
					
					gyroOffsets[0] = 0;
    2f5a:	f1 01       	movw	r30, r2
    2f5c:	e4 5b       	subi	r30, 0xB4	; 180
    2f5e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f60:	10 82       	st	Z, r1
    2f62:	11 82       	std	Z+1, r1	; 0x01
    2f64:	12 82       	std	Z+2, r1	; 0x02
    2f66:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[1] = 0;
    2f68:	f1 01       	movw	r30, r2
    2f6a:	e0 5b       	subi	r30, 0xB0	; 176
    2f6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f6e:	10 82       	st	Z, r1
    2f70:	11 82       	std	Z+1, r1	; 0x01
    2f72:	12 82       	std	Z+2, r1	; 0x02
    2f74:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[2] = 0;
    2f76:	f1 01       	movw	r30, r2
    2f78:	ec 5a       	subi	r30, 0xAC	; 172
    2f7a:	ff 4f       	sbci	r31, 0xFF	; 255
    2f7c:	10 82       	st	Z, r1
    2f7e:	11 82       	std	Z+1, r1	; 0x01
    2f80:	12 82       	std	Z+2, r1	; 0x02
    2f82:	13 82       	std	Z+3, r1	; 0x03
	imuSensor->init();
    2f84:	c1 01       	movw	r24, r2
    2f86:	0e 94 c6 4d 	call	0x9b8c	; 0x9b8c <_ZN10helicopter7sensors9IMUSensor4initEv>

	GPSSensor *gpsSensor = new GPSSensor(gpsSerialDriver);
    2f8a:	8b e2       	ldi	r24, 0x2B	; 43
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2f92:	2c 01       	movw	r4, r24
					positionAccuracyEstimateEcefCm (0),
					xVEcefCms(0),
					yVEcefCms(0),
					zVEcefCms(0),
					velocityAccuracyEstimateEcefCms (0),
					positionFixStatus(INVALID)
    2f94:	29 85       	ldd	r18, Y+9	; 0x09
    2f96:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f98:	fc 01       	movw	r30, r24
    2f9a:	31 83       	std	Z+1, r19	; 0x01
    2f9c:	20 83       	st	Z, r18
    2f9e:	12 82       	std	Z+2, r1	; 0x02
    2fa0:	13 82       	std	Z+3, r1	; 0x03
    2fa2:	14 82       	std	Z+4, r1	; 0x04
    2fa4:	15 82       	std	Z+5, r1	; 0x05
    2fa6:	16 82       	std	Z+6, r1	; 0x06
    2fa8:	17 82       	std	Z+7, r1	; 0x07
    2faa:	10 86       	std	Z+8, r1	; 0x08
    2fac:	11 86       	std	Z+9, r1	; 0x09
    2fae:	12 86       	std	Z+10, r1	; 0x0a
    2fb0:	13 86       	std	Z+11, r1	; 0x0b
    2fb2:	14 86       	std	Z+12, r1	; 0x0c
    2fb4:	15 86       	std	Z+13, r1	; 0x0d
    2fb6:	16 86       	std	Z+14, r1	; 0x0e
    2fb8:	17 86       	std	Z+15, r1	; 0x0f
    2fba:	10 8a       	std	Z+16, r1	; 0x10
    2fbc:	11 8a       	std	Z+17, r1	; 0x11
    2fbe:	12 8a       	std	Z+18, r1	; 0x12
    2fc0:	13 8a       	std	Z+19, r1	; 0x13
    2fc2:	14 8a       	std	Z+20, r1	; 0x14
    2fc4:	15 8a       	std	Z+21, r1	; 0x15
    2fc6:	16 8a       	std	Z+22, r1	; 0x16
    2fc8:	17 8a       	std	Z+23, r1	; 0x17
    2fca:	10 8e       	std	Z+24, r1	; 0x18
    2fcc:	11 8e       	std	Z+25, r1	; 0x19
    2fce:	12 8e       	std	Z+26, r1	; 0x1a
    2fd0:	13 8e       	std	Z+27, r1	; 0x1b
    2fd2:	14 8e       	std	Z+28, r1	; 0x1c
    2fd4:	15 8e       	std	Z+29, r1	; 0x1d
    2fd6:	16 8e       	std	Z+30, r1	; 0x1e
    2fd8:	17 8e       	std	Z+31, r1	; 0x1f
    2fda:	10 a2       	std	Z+32, r1	; 0x20
    2fdc:	11 a2       	std	Z+33, r1	; 0x21
    2fde:	12 a2       	std	Z+34, r1	; 0x22
    2fe0:	13 a2       	std	Z+35, r1	; 0x23
    2fe2:	14 a2       	std	Z+36, r1	; 0x24
    2fe4:	15 a2       	std	Z+37, r1	; 0x25
    2fe6:	16 a2       	std	Z+38, r1	; 0x26
    2fe8:	17 a2       	std	Z+39, r1	; 0x27
    2fea:	10 a6       	std	Z+40, r1	; 0x28
    2fec:	11 a6       	std	Z+41, r1	; 0x29
    2fee:	21 e0       	ldi	r18, 0x01	; 1
    2ff0:	22 a7       	std	Z+42, r18	; 0x2a
	gpsSensor->init();
    2ff2:	0e 94 77 4b 	call	0x96ee	; 0x96ee <_ZN10helicopter7sensors9GPSSensor4initEv>

	BarometerSensor *baroSensor = new BarometerSensor(baroSpiDriver);
    2ff6:	82 e4       	ldi	r24, 0x42	; 66
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    2ffe:	7c 01       	movw	r14, r24
					pressureSensitivity_SENSt1_C1(0),
					pressureSensitivityOffset_OFFt1_C2(0),
					temperatureCoefficientOfPressureSensitivity_TCS_C3(0),
					temperatureCoefficientOfPressureOffset_TCO_C4(0),
					referenceTemperature_Tref_C5(0),
					temperatureCoefficientOfTheTemperature_TEMPSENS_C6(0)
    3000:	eb 85       	ldd	r30, Y+11	; 0x0b
    3002:	fc 85       	ldd	r31, Y+12	; 0x0c
    3004:	dc 01       	movw	r26, r24
    3006:	11 96       	adiw	r26, 0x01	; 1
    3008:	fc 93       	st	X, r31
    300a:	ee 93       	st	-X, r30
    300c:	12 96       	adiw	r26, 0x02	; 2
    300e:	1d 92       	st	X+, r1
    3010:	1d 92       	st	X+, r1
    3012:	1d 92       	st	X+, r1
    3014:	1c 92       	st	X, r1
    3016:	15 97       	sbiw	r26, 0x05	; 5
    3018:	fc 01       	movw	r30, r24
    301a:	16 82       	std	Z+6, r1	; 0x06
    301c:	17 82       	std	Z+7, r1	; 0x07
    301e:	10 86       	std	Z+8, r1	; 0x08
    3020:	11 86       	std	Z+9, r1	; 0x09
    3022:	1a 96       	adiw	r26, 0x0a	; 10
    3024:	1d 92       	st	X+, r1
    3026:	1d 92       	st	X+, r1
    3028:	1d 92       	st	X+, r1
    302a:	1c 92       	st	X, r1
    302c:	1d 97       	sbiw	r26, 0x0d	; 13
    302e:	16 86       	std	Z+14, r1	; 0x0e
    3030:	17 86       	std	Z+15, r1	; 0x0f
    3032:	10 8a       	std	Z+16, r1	; 0x10
    3034:	11 8a       	std	Z+17, r1	; 0x11
    3036:	12 8a       	std	Z+18, r1	; 0x12
    3038:	13 8a       	std	Z+19, r1	; 0x13
    303a:	14 8a       	std	Z+20, r1	; 0x14
    303c:	15 8a       	std	Z+21, r1	; 0x15
    303e:	16 8a       	std	Z+22, r1	; 0x16
    3040:	17 8a       	std	Z+23, r1	; 0x17
    3042:	10 8e       	std	Z+24, r1	; 0x18
    3044:	11 8e       	std	Z+25, r1	; 0x19
    3046:	12 8e       	std	Z+26, r1	; 0x1a
    3048:	13 8e       	std	Z+27, r1	; 0x1b
    304a:	14 8e       	std	Z+28, r1	; 0x1c
    304c:	15 8e       	std	Z+29, r1	; 0x1d
    304e:	16 8e       	std	Z+30, r1	; 0x1e
    3050:	17 8e       	std	Z+31, r1	; 0x1f
    3052:	10 a2       	std	Z+32, r1	; 0x20
    3054:	11 a2       	std	Z+33, r1	; 0x21
    3056:	12 a2       	std	Z+34, r1	; 0x22
    3058:	13 a2       	std	Z+35, r1	; 0x23
    305a:	14 a2       	std	Z+36, r1	; 0x24
    305c:	15 a2       	std	Z+37, r1	; 0x25
    305e:	16 a2       	std	Z+38, r1	; 0x26
    3060:	17 a2       	std	Z+39, r1	; 0x27
    3062:	10 a6       	std	Z+40, r1	; 0x28
    3064:	11 a6       	std	Z+41, r1	; 0x29
    3066:	12 a6       	std	Z+42, r1	; 0x2a
    3068:	13 a6       	std	Z+43, r1	; 0x2b
    306a:	14 a6       	std	Z+44, r1	; 0x2c
    306c:	15 a6       	std	Z+45, r1	; 0x2d
    306e:	16 a6       	std	Z+46, r1	; 0x2e
    3070:	17 a6       	std	Z+47, r1	; 0x2f
    3072:	10 aa       	std	Z+48, r1	; 0x30
    3074:	11 aa       	std	Z+49, r1	; 0x31
    3076:	12 aa       	std	Z+50, r1	; 0x32
    3078:	13 aa       	std	Z+51, r1	; 0x33
    307a:	14 aa       	std	Z+52, r1	; 0x34
    307c:	15 aa       	std	Z+53, r1	; 0x35
    307e:	16 aa       	std	Z+54, r1	; 0x36
    3080:	17 aa       	std	Z+55, r1	; 0x37
    3082:	10 ae       	std	Z+56, r1	; 0x38
    3084:	11 ae       	std	Z+57, r1	; 0x39
    3086:	fa 96       	adiw	r30, 0x3a	; 58
    3088:	da 96       	adiw	r26, 0x3a	; 58
    308a:	1c 92       	st	X, r1
    308c:	11 82       	std	Z+1, r1	; 0x01
    308e:	12 82       	std	Z+2, r1	; 0x02
    3090:	13 82       	std	Z+3, r1	; 0x03
    3092:	14 82       	std	Z+4, r1	; 0x04
    3094:	15 82       	std	Z+5, r1	; 0x05
    3096:	16 82       	std	Z+6, r1	; 0x06
    3098:	17 82       	std	Z+7, r1	; 0x07
	baroSensor->init();
    309a:	0e 94 a3 43 	call	0x8746	; 0x8746 <_ZN10helicopter7sensors15BarometerSensor4initEv>
	
	MagnetometerSensor *magSensor = new MagnetometerSensor(twiDriver);
    309e:	88 e3       	ldi	r24, 0x38	; 56
    30a0:	90 e0       	ldi	r25, 0x00	; 0
    30a2:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    30a6:	9a 8b       	std	Y+18, r25	; 0x12
    30a8:	89 8b       	std	Y+17, r24	; 0x11
    30aa:	69 a1       	ldd	r22, Y+33	; 0x21
    30ac:	7a a1       	ldd	r23, Y+34	; 0x22
    30ae:	0e 94 64 50 	call	0xa0c8	; 0xa0c8 <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>
	magSensor->init();
    30b2:	89 89       	ldd	r24, Y+17	; 0x11
    30b4:	9a 89       	ldd	r25, Y+18	; 0x12
    30b6:	0e 94 26 52 	call	0xa44c	; 0xa44c <_ZN10helicopter7sensors18MagnetometerSensor4initEv>
	_delay_ms(200);
	*/

	
	//ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .25); //run at 4 hz
	ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .1); //run at 10 hz
    30ba:	8c e0       	ldi	r24, 0x0C	; 12
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    30c2:	9a 87       	std	Y+10, r25	; 0x0a
    30c4:	89 87       	std	Y+9, r24	; 0x09
    30c6:	04 e1       	ldi	r16, 0x14	; 20
    30c8:	10 e0       	ldi	r17, 0x00	; 0
    30ca:	27 e0       	ldi	r18, 0x07	; 7
    30cc:	30 e0       	ldi	r19, 0x00	; 0
    30ce:	a2 01       	movw	r20, r4
    30d0:	b4 01       	movw	r22, r8
    30d2:	0e 94 da 59 	call	0xb3b4	; 0xb3b4 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
	ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz.
    30d6:	8b e0       	ldi	r24, 0x0B	; 11
    30d8:	90 e0       	ldi	r25, 0x00	; 0
    30da:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    30de:	9c 87       	std	Y+12, r25	; 0x0c
    30e0:	8b 87       	std	Y+11, r24	; 0x0b
    30e2:	02 e0       	ldi	r16, 0x02	; 2
    30e4:	10 e0       	ldi	r17, 0x00	; 0
    30e6:	28 e0       	ldi	r18, 0x08	; 8
    30e8:	30 e0       	ldi	r19, 0x00	; 0
    30ea:	a1 01       	movw	r20, r2
    30ec:	b4 01       	movw	r22, r8
    30ee:	0e 94 73 5a 	call	0xb4e6	; 0xb4e6 <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  2); //run at 100 hz.
	ReadBarometerSensorTask *barometerSensorTask = new ReadBarometerSensorTask(model, baroSensor, 9, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz. needs to run so that at least 10 ms is between each operation. since it's a 3 step process, this is really only executes hz/3 for a complete cycle (*** this will probably cause huge timeouts since it takes like 8ms to complete.)
    30f2:	8d e0       	ldi	r24, 0x0D	; 13
    30f4:	90 e0       	ldi	r25, 0x00	; 0
    30f6:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    30fa:	6c 01       	movw	r12, r24
    30fc:	04 e0       	ldi	r16, 0x04	; 4
    30fe:	10 e0       	ldi	r17, 0x00	; 0
    3100:	29 e0       	ldi	r18, 0x09	; 9
    3102:	30 e0       	ldi	r19, 0x00	; 0
    3104:	a7 01       	movw	r20, r14
    3106:	b4 01       	movw	r22, r8
    3108:	0e 94 35 59 	call	0xb26a	; 0xb26a <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>
	//ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz, although the sensor is reading at 75 hz.
	ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz, although the sensor is reading at 75 hz.
    310c:	8b e0       	ldi	r24, 0x0B	; 11
    310e:	90 e0       	ldi	r25, 0x00	; 0
    3110:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    3114:	7c 01       	movw	r14, r24
    3116:	02 e0       	ldi	r16, 0x02	; 2
    3118:	10 e0       	ldi	r17, 0x00	; 0
    311a:	2a e0       	ldi	r18, 0x0A	; 10
    311c:	30 e0       	ldi	r19, 0x00	; 0
    311e:	49 89       	ldd	r20, Y+17	; 0x11
    3120:	5a 89       	ldd	r21, Y+18	; 0x12
    3122:	b4 01       	movw	r22, r8
    3124:	0e 94 ec 5a 	call	0xb5d8	; 0xb5d8 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>
	

	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    3128:	0e 94 8e 1f 	call	0x3f1c	; 0x3f1c <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    312c:	1c 01       	movw	r2, r24
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
				void SetSystemModel(SystemModel *val) { systemModel = val; }
    312e:	fc 01       	movw	r30, r24
    3130:	e9 5a       	subi	r30, 0xA9	; 169
    3132:	ff 4f       	sbci	r31, 0xFF	; 255
    3134:	91 82       	std	Z+1, r9	; 0x01
    3136:	80 82       	st	Z, r8
	
	rcInterface->SetSystemModel(model);

	ServoControlTask *servoControlTask = new ServoControlTask(model, rcInterface, 11,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
    3138:	8b e0       	ldi	r24, 0x0B	; 11
    313a:	90 e0       	ldi	r25, 0x00	; 0
    313c:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    3140:	04 e0       	ldi	r16, 0x04	; 4
    3142:	10 e0       	ldi	r17, 0x00	; 0
    3144:	2b e0       	ldi	r18, 0x0B	; 11
    3146:	30 e0       	ldi	r19, 0x00	; 0
    3148:	a1 01       	movw	r20, r2
    314a:	b4 01       	movw	r22, r8
    314c:	0e 94 5d 5b 	call	0xb6ba	; 0xb6ba <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>
	
	
	scheduler->addTask(flashTask);
    3150:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3152:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3154:	8f a1       	ldd	r24, Y+39	; 0x27
    3156:	98 a5       	ldd	r25, Y+40	; 0x28
    3158:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(gpsSensorTask);
    315c:	69 85       	ldd	r22, Y+9	; 0x09
    315e:	7a 85       	ldd	r23, Y+10	; 0x0a
    3160:	8f a1       	ldd	r24, Y+39	; 0x27
    3162:	98 a5       	ldd	r25, Y+40	; 0x28
    3164:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(imuSensorTask);
    3168:	6b 85       	ldd	r22, Y+11	; 0x0b
    316a:	7c 85       	ldd	r23, Y+12	; 0x0c
    316c:	8f a1       	ldd	r24, Y+39	; 0x27
    316e:	98 a5       	ldd	r25, Y+40	; 0x28
    3170:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(barometerSensorTask);
    3174:	b6 01       	movw	r22, r12
    3176:	8f a1       	ldd	r24, Y+39	; 0x27
    3178:	98 a5       	ldd	r25, Y+40	; 0x28
    317a:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(magSensorTask);
    317e:	b7 01       	movw	r22, r14
    3180:	8f a1       	ldd	r24, Y+39	; 0x27
    3182:	98 a5       	ldd	r25, Y+40	; 0x28
    3184:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>


	if (model->SensorInput() == SystemModel::SimulatedSensors || receiveGains == true)
    3188:	f4 01       	movw	r30, r8
    318a:	84 81       	ldd	r24, Z+4	; 0x04
    318c:	81 11       	cpse	r24, r1
    318e:	06 c0       	rjmp	.+12     	; 0x319c <main+0x926>
	//if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		//Add a task to read simulator data if setup to receive sensor data from the simulator.
		scheduler->addTask(simTelemTask);
    3190:	69 81       	ldd	r22, Y+1	; 0x01
    3192:	7a 81       	ldd	r23, Y+2	; 0x02
    3194:	8f a1       	ldd	r24, Y+39	; 0x27
    3196:	98 a5       	ldd	r25, Y+40	; 0x28
    3198:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	}
	*/
	
	
	
	scheduler->addTask(transTelemTask);
    319c:	6d 81       	ldd	r22, Y+5	; 0x05
    319e:	7e 81       	ldd	r23, Y+6	; 0x06
    31a0:	8f a1       	ldd	r24, Y+39	; 0x27
    31a2:	98 a5       	ldd	r25, Y+40	; 0x28
    31a4:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidOuterLoop);
    31a8:	6b a1       	ldd	r22, Y+35	; 0x23
    31aa:	7c a1       	ldd	r23, Y+36	; 0x24
    31ac:	8f a1       	ldd	r24, Y+39	; 0x27
    31ae:	98 a5       	ldd	r25, Y+40	; 0x28
    31b0:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidInnerLoop);
    31b4:	6d a1       	ldd	r22, Y+37	; 0x25
    31b6:	7e a1       	ldd	r23, Y+38	; 0x26
    31b8:	8f a1       	ldd	r24, Y+39	; 0x27
    31ba:	98 a5       	ldd	r25, Y+40	; 0x28
    31bc:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(navTask);
    31c0:	6d 8d       	ldd	r22, Y+29	; 0x1d
    31c2:	7e 8d       	ldd	r23, Y+30	; 0x1e
    31c4:	8f a1       	ldd	r24, Y+39	; 0x27
    31c6:	98 a5       	ldd	r25, Y+40	; 0x28
    31c8:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(pvNavTask);
    31cc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    31ce:	78 a1       	ldd	r23, Y+32	; 0x20
    31d0:	8f a1       	ldd	r24, Y+39	; 0x27
    31d2:	98 a5       	ldd	r25, Y+40	; 0x28
    31d4:	0e 94 70 42 	call	0x84e0	; 0x84e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	d4 01       	movw	r26, r8
    31dc:	12 96       	adiw	r26, 0x02	; 2
    31de:	8c 93       	st	X, r24
    31e0:	12 97       	sbiw	r26, 0x02	; 2
		model->OperationalState(SystemModel::AutoPilot);
	}
	
	

	PORTA |= (1<<PA4);
    31e2:	14 9a       	sbi	0x02, 4	; 2
	
	//Set the red led to 'on' to indicate the system is initializing. I have this down here because there is a bug which might lock up the system when the GPS initializes, so
	//we turn on the red led after that bug can take place so we know we past that point in the init sequence. 
	DDRA |= (1<<PA5);
    31e4:	0d 9a       	sbi	0x01, 5	; 1
	PORTA &= ~(1<<PA5);
    31e6:	15 98       	cbi	0x02, 5	; 2
	
	
	/**
	 * Set initial position.
	 */
	if (model->SensorInput() == SystemModel::RealSensors)
    31e8:	14 96       	adiw	r26, 0x04	; 4
    31ea:	8c 91       	ld	r24, X
    31ec:	81 30       	cpi	r24, 0x01	; 1
    31ee:	09 f0       	breq	.+2      	; 0x31f2 <main+0x97c>
    31f0:	45 c2       	rjmp	.+1162   	; 0x367c <main+0xe06>
    31f2:	0f a1       	ldd	r16, Y+39	; 0x27
    31f4:	18 a5       	ldd	r17, Y+40	; 0x28
    31f6:	15 01       	movw	r2, r10
    31f8:	80 c0       	rjmp	.+256    	; 0x32fa <main+0xa84>
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
    31fa:	c2 01       	movw	r24, r4
    31fc:	0e 94 22 4b 	call	0x9644	; 0x9644 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
			gpsSensor->readSensorNavStatus();
    3200:	c2 01       	movw	r24, r4
    3202:	0e 94 e8 4a 	call	0x95d0	; 0x95d0 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>
			long status = gpsSensor->readSensorSolution();
    3206:	c2 01       	movw	r24, r4
    3208:	0e 94 25 4a 	call	0x944a	; 0x944a <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>
    320c:	5c 01       	movw	r10, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    320e:	bf ef       	ldi	r27, 0xFF	; 255
    3210:	e4 e3       	ldi	r30, 0x34	; 52
    3212:	fc e0       	ldi	r31, 0x0C	; 12
    3214:	b1 50       	subi	r27, 0x01	; 1
    3216:	e0 40       	sbci	r30, 0x00	; 0
    3218:	f0 40       	sbci	r31, 0x00	; 0
    321a:	e1 f7       	brne	.-8      	; 0x3214 <main+0x99e>
    321c:	00 c0       	rjmp	.+0      	; 0x321e <main+0x9a8>
    321e:	00 00       	nop
					//long status = gpsSensor->readSensorNavStatus();
					long status = gpsSensor->readSensorSolution();*/
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
    3220:	d1 01       	movw	r26, r2
    3222:	ed 91       	ld	r30, X+
    3224:	fc 91       	ld	r31, X
    3226:	06 80       	ldd	r0, Z+6	; 0x06
    3228:	f7 81       	ldd	r31, Z+7	; 0x07
    322a:	e0 2d       	mov	r30, r0
    322c:	64 e5       	ldi	r22, 0x54	; 84
    322e:	c1 01       	movw	r24, r2
    3230:	19 95       	eicall
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    3232:	d1 01       	movw	r26, r2
    3234:	ed 91       	ld	r30, X+
    3236:	fc 91       	ld	r31, X
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
			gpsSensor->readSensorNavStatus();
			long status = gpsSensor->readSensorSolution();
    3238:	a5 01       	movw	r20, r10
    323a:	66 27       	eor	r22, r22
    323c:	57 fd       	sbrc	r21, 7
    323e:	60 95       	com	r22
    3240:	76 2f       	mov	r23, r22
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    3242:	04 84       	ldd	r0, Z+12	; 0x0c
    3244:	f5 85       	ldd	r31, Z+13	; 0x0d
    3246:	e0 2d       	mov	r30, r0
    3248:	c1 01       	movw	r24, r2
    324a:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getLongitudeDegE7());
    324c:	d1 01       	movw	r26, r2
    324e:	ed 91       	ld	r30, X+
    3250:	fc 91       	ld	r31, X
    3252:	d2 01       	movw	r26, r4
    3254:	16 96       	adiw	r26, 0x06	; 6
    3256:	4d 91       	ld	r20, X+
    3258:	5d 91       	ld	r21, X+
    325a:	6d 91       	ld	r22, X+
    325c:	7c 91       	ld	r23, X
    325e:	19 97       	sbiw	r26, 0x09	; 9
    3260:	04 84       	ldd	r0, Z+12	; 0x0c
    3262:	f5 85       	ldd	r31, Z+13	; 0x0d
    3264:	e0 2d       	mov	r30, r0
    3266:	c1 01       	movw	r24, r2
    3268:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionAccuracyEstimateEcefCm());
    326a:	d1 01       	movw	r26, r2
    326c:	ed 91       	ld	r30, X+
    326e:	fc 91       	ld	r31, X
    3270:	d2 01       	movw	r26, r4
    3272:	56 96       	adiw	r26, 0x16	; 22
    3274:	4d 91       	ld	r20, X+
    3276:	5d 91       	ld	r21, X+
    3278:	6d 91       	ld	r22, X+
    327a:	7c 91       	ld	r23, X
    327c:	59 97       	sbiw	r26, 0x19	; 25
    327e:	02 84       	ldd	r0, Z+10	; 0x0a
    3280:	f3 85       	ldd	r31, Z+11	; 0x0b
    3282:	e0 2d       	mov	r30, r0
    3284:	c1 01       	movw	r24, r2
    3286:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionFixStatus());
    3288:	d1 01       	movw	r26, r2
    328a:	ed 91       	ld	r30, X+
    328c:	fc 91       	ld	r31, X
    328e:	d2 01       	movw	r26, r4
    3290:	9a 96       	adiw	r26, 0x2a	; 42
    3292:	6c 91       	ld	r22, X
    3294:	00 84       	ldd	r0, Z+8	; 0x08
    3296:	f1 85       	ldd	r31, Z+9	; 0x09
    3298:	e0 2d       	mov	r30, r0
    329a:	70 e0       	ldi	r23, 0x00	; 0
    329c:	c1 01       	movw	r24, r2
    329e:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getXEcefCm());
    32a0:	d1 01       	movw	r26, r2
    32a2:	ed 91       	ld	r30, X+
    32a4:	fc 91       	ld	r31, X
    32a6:	d2 01       	movw	r26, r4
    32a8:	1a 96       	adiw	r26, 0x0a	; 10
    32aa:	4d 91       	ld	r20, X+
    32ac:	5d 91       	ld	r21, X+
    32ae:	6d 91       	ld	r22, X+
    32b0:	7c 91       	ld	r23, X
    32b2:	1d 97       	sbiw	r26, 0x0d	; 13
    32b4:	04 84       	ldd	r0, Z+12	; 0x0c
    32b6:	f5 85       	ldd	r31, Z+13	; 0x0d
    32b8:	e0 2d       	mov	r30, r0
    32ba:	c1 01       	movw	r24, r2
    32bc:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getYEcefCm());
    32be:	d1 01       	movw	r26, r2
    32c0:	ed 91       	ld	r30, X+
    32c2:	fc 91       	ld	r31, X
    32c4:	d2 01       	movw	r26, r4
    32c6:	1e 96       	adiw	r26, 0x0e	; 14
    32c8:	4d 91       	ld	r20, X+
    32ca:	5d 91       	ld	r21, X+
    32cc:	6d 91       	ld	r22, X+
    32ce:	7c 91       	ld	r23, X
    32d0:	51 97       	sbiw	r26, 0x11	; 17
    32d2:	04 84       	ldd	r0, Z+12	; 0x0c
    32d4:	f5 85       	ldd	r31, Z+13	; 0x0d
    32d6:	e0 2d       	mov	r30, r0
    32d8:	c1 01       	movw	r24, r2
    32da:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getZEcefCm());
    32dc:	d1 01       	movw	r26, r2
    32de:	ed 91       	ld	r30, X+
    32e0:	fc 91       	ld	r31, X
    32e2:	d2 01       	movw	r26, r4
    32e4:	52 96       	adiw	r26, 0x12	; 18
    32e6:	4d 91       	ld	r20, X+
    32e8:	5d 91       	ld	r21, X+
    32ea:	6d 91       	ld	r22, X+
    32ec:	7c 91       	ld	r23, X
    32ee:	55 97       	sbiw	r26, 0x15	; 21
    32f0:	04 84       	ldd	r0, Z+12	; 0x0c
    32f2:	f5 85       	ldd	r31, Z+13	; 0x0d
    32f4:	e0 2d       	mov	r30, r0
    32f6:	c1 01       	movw	r24, r2
    32f8:	19 95       	eicall
	if (model->SensorInput() == SystemModel::RealSensors)
	{		
	
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
    32fa:	c2 01       	movw	r24, r4
    32fc:	0e 94 11 4c 	call	0x9822	; 0x9822 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>
    3300:	88 23       	and	r24, r24
    3302:	09 f4       	brne	.+2      	; 0x3306 <main+0xa90>
    3304:	7a cf       	rjmp	.-268    	; 0x31fa <main+0x984>
    3306:	f2 01       	movw	r30, r4
    3308:	86 89       	ldd	r24, Z+22	; 0x16
    330a:	97 89       	ldd	r25, Z+23	; 0x17
    330c:	a0 8d       	ldd	r26, Z+24	; 0x18
    330e:	b1 8d       	ldd	r27, Z+25	; 0x19
    3310:	2d 89       	ldd	r18, Y+21	; 0x15
    3312:	3e 89       	ldd	r19, Y+22	; 0x16
    3314:	4f 89       	ldd	r20, Y+23	; 0x17
    3316:	58 8d       	ldd	r21, Y+24	; 0x18
    3318:	28 17       	cp	r18, r24
    331a:	39 07       	cpc	r19, r25
    331c:	4a 07       	cpc	r20, r26
    331e:	5b 07       	cpc	r21, r27
    3320:	68 f4       	brcc	.+26     	; 0x333c <main+0xac6>
    3322:	6b cf       	rjmp	.-298    	; 0x31fa <main+0x984>
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
		{
			gpsSensor->readSensorLLH();
    3324:	c2 01       	movw	r24, r4
    3326:	0e 94 22 4b 	call	0x9644	; 0x9644 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
    332a:	3f ef       	ldi	r19, 0xFF	; 255
    332c:	44 e3       	ldi	r20, 0x34	; 52
    332e:	5c e0       	ldi	r21, 0x0C	; 12
    3330:	31 50       	subi	r19, 0x01	; 1
    3332:	40 40       	sbci	r20, 0x00	; 0
    3334:	50 40       	sbci	r21, 0x00	; 0
    3336:	e1 f7       	brne	.-8      	; 0x3330 <main+0xaba>
    3338:	00 c0       	rjmp	.+0      	; 0x333a <main+0xac4>
    333a:	00 00       	nop
		
		//Turn off interrupts so that the gps sensor doesn't auto receive gps data which would
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
    333c:	f2 01       	movw	r30, r4
    333e:	82 81       	ldd	r24, Z+2	; 0x02
    3340:	93 81       	ldd	r25, Z+3	; 0x03
    3342:	a4 81       	ldd	r26, Z+4	; 0x04
    3344:	b5 81       	ldd	r27, Z+5	; 0x05
    3346:	89 2b       	or	r24, r25
    3348:	8a 2b       	or	r24, r26
    334a:	8b 2b       	or	r24, r27
    334c:	59 f3       	breq	.-42     	; 0x3324 <main+0xaae>
    334e:	86 81       	ldd	r24, Z+6	; 0x06
    3350:	97 81       	ldd	r25, Z+7	; 0x07
    3352:	a0 85       	ldd	r26, Z+8	; 0x08
    3354:	b1 85       	ldd	r27, Z+9	; 0x09
    3356:	89 2b       	or	r24, r25
    3358:	8a 2b       	or	r24, r26
    335a:	8b 2b       	or	r24, r27
    335c:	19 f3       	breq	.-58     	; 0x3324 <main+0xaae>
    335e:	18 a7       	std	Y+40, r17	; 0x28
    3360:	0f a3       	std	Y+39, r16	; 0x27
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    3362:	84 01       	movw	r16, r8
    3364:	02 54       	subi	r16, 0x42	; 66
    3366:	1f 4f       	sbci	r17, 0xFF	; 255
    3368:	62 85       	ldd	r22, Z+10	; 0x0a
    336a:	73 85       	ldd	r23, Z+11	; 0x0b
    336c:	84 85       	ldd	r24, Z+12	; 0x0c
    336e:	95 85       	ldd	r25, Z+13	; 0x0d
    3370:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    3374:	f8 01       	movw	r30, r16
    3376:	60 83       	st	Z, r22
    3378:	71 83       	std	Z+1, r23	; 0x01
    337a:	82 83       	std	Z+2, r24	; 0x02
    337c:	93 83       	std	Z+3, r25	; 0x03

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    337e:	84 01       	movw	r16, r8
    3380:	0e 53       	subi	r16, 0x3E	; 62
    3382:	1f 4f       	sbci	r17, 0xFF	; 255
    3384:	d2 01       	movw	r26, r4
    3386:	1e 96       	adiw	r26, 0x0e	; 14
    3388:	6d 91       	ld	r22, X+
    338a:	7d 91       	ld	r23, X+
    338c:	8d 91       	ld	r24, X+
    338e:	9c 91       	ld	r25, X
    3390:	51 97       	sbiw	r26, 0x11	; 17
    3392:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    3396:	f8 01       	movw	r30, r16
    3398:	60 83       	st	Z, r22
    339a:	71 83       	std	Z+1, r23	; 0x01
    339c:	82 83       	std	Z+2, r24	; 0x02
    339e:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    33a0:	84 01       	movw	r16, r8
    33a2:	0a 53       	subi	r16, 0x3A	; 58
    33a4:	1f 4f       	sbci	r17, 0xFF	; 255
    33a6:	d2 01       	movw	r26, r4
    33a8:	52 96       	adiw	r26, 0x12	; 18
    33aa:	6d 91       	ld	r22, X+
    33ac:	7d 91       	ld	r23, X+
    33ae:	8d 91       	ld	r24, X+
    33b0:	9c 91       	ld	r25, X
    33b2:	55 97       	sbiw	r26, 0x15	; 21
    33b4:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    33b8:	f8 01       	movw	r30, r16
    33ba:	60 83       	st	Z, r22
    33bc:	71 83       	std	Z+1, r23	; 0x01
    33be:	82 83       	std	Z+2, r24	; 0x02
    33c0:	93 83       	std	Z+3, r25	; 0x03
		model->InitialXPositionEcef(gpsSensor->getXEcefCm());
		model->InitialYPositionEcef(gpsSensor->getYEcefCm());
		model->InitialZPositionEcef(gpsSensor->getZEcefCm());
		
		//generate ecef to ned rotation matrix based on current lat/long			
		CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    33c2:	84 01       	movw	r16, r8
    33c4:	02 5e       	subi	r16, 0xE2	; 226
    33c6:	1e 4f       	sbci	r17, 0xFE	; 254
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    33c8:	f4 01       	movw	r30, r8
    33ca:	ea 55       	subi	r30, 0x5A	; 90
    33cc:	ff 4f       	sbci	r31, 0xFF	; 255
    33ce:	20 81       	ld	r18, Z
    33d0:	31 81       	ldd	r19, Z+1	; 0x01
    33d2:	42 81       	ldd	r20, Z+2	; 0x02
    33d4:	53 81       	ldd	r21, Z+3	; 0x03

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    33d6:	f4 01       	movw	r30, r8
    33d8:	ee 55       	subi	r30, 0x5E	; 94
    33da:	ff 4f       	sbci	r31, 0xFF	; 255
    33dc:	60 81       	ld	r22, Z
    33de:	71 81       	ldd	r23, Z+1	; 0x01
    33e0:	82 81       	ldd	r24, Z+2	; 0x02
    33e2:	93 81       	ldd	r25, Z+3	; 0x03
    33e4:	0e 94 92 64 	call	0xc924	; 0xc924 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
    33e8:	ff ef       	ldi	r31, 0xFF	; 255
    33ea:	29 e6       	ldi	r18, 0x69	; 105
    33ec:	38 e1       	ldi	r19, 0x18	; 24
    33ee:	f1 50       	subi	r31, 0x01	; 1
    33f0:	20 40       	sbci	r18, 0x00	; 0
    33f2:	30 40       	sbci	r19, 0x00	; 0
    33f4:	e1 f7       	brne	.-8      	; 0x33ee <main+0xb78>
    33f6:	00 c0       	rjmp	.+0      	; 0x33f8 <main+0xb82>
    33f8:	00 00       	nop
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    33fa:	4f 85       	ldd	r20, Y+15	; 0x0f
    33fc:	58 89       	ldd	r21, Y+16	; 0x10
    33fe:	14 16       	cp	r1, r20
    3400:	15 06       	cpc	r1, r21
    3402:	14 f1       	brlt	.+68     	; 0x3448 <main+0xbd2>
    3404:	a7 c1       	rjmp	.+846    	; 0x3754 <main+0xede>
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    3406:	d6 01       	movw	r26, r12
    3408:	ed 91       	ld	r30, X+
    340a:	fc 91       	ld	r31, X
    340c:	01 90       	ld	r0, Z+
    340e:	f0 81       	ld	r31, Z
    3410:	e0 2d       	mov	r30, r0
    3412:	c6 01       	movw	r24, r12
    3414:	19 95       	eicall
    3416:	ef e3       	ldi	r30, 0x3F	; 63
    3418:	fc e9       	ldi	r31, 0x9C	; 156
    341a:	31 97       	sbiw	r30, 0x01	; 1
    341c:	f1 f7       	brne	.-4      	; 0x341a <main+0xba4>
    341e:	00 c0       	rjmp	.+0      	; 0x3420 <main+0xbaa>
    3420:	00 00       	nop
    3422:	29 81       	ldd	r18, Y+1	; 0x01
    3424:	3a 81       	ldd	r19, Y+2	; 0x02
    3426:	21 50       	subi	r18, 0x01	; 1
    3428:	31 09       	sbc	r19, r1
    342a:	3a 83       	std	Y+2, r19	; 0x02
    342c:	29 83       	std	Y+1, r18	; 0x01
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    342e:	23 2b       	or	r18, r19
    3430:	51 f7       	brne	.-44     	; 0x3406 <main+0xb90>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3432:	3f ef       	ldi	r19, 0xFF	; 255
    3434:	a3 1a       	sub	r10, r19
    3436:	b3 0a       	sbc	r11, r19
    3438:	4f 85       	ldd	r20, Y+15	; 0x0f
    343a:	58 89       	ldd	r21, Y+16	; 0x10
    343c:	a4 16       	cp	r10, r20
    343e:	b5 06       	cpc	r11, r21
    3440:	49 f4       	brne	.+18     	; 0x3454 <main+0xbde>
    3442:	38 a6       	std	Y+40, r3	; 0x28
    3444:	2f a2       	std	Y+39, r2	; 0x27
    3446:	86 c1       	rjmp	.+780    	; 0x3754 <main+0xede>
    3448:	a1 2c       	mov	r10, r1
    344a:	b1 2c       	mov	r11, r1
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    344c:	03 e0       	ldi	r16, 0x03	; 3
    344e:	10 e0       	ldi	r17, 0x00	; 0
    3450:	2f a0       	ldd	r2, Y+39	; 0x27
    3452:	38 a4       	ldd	r3, Y+40	; 0x28
    3454:	1a 83       	std	Y+2, r17	; 0x02
    3456:	09 83       	std	Y+1, r16	; 0x01
    3458:	d6 cf       	rjmp	.-84     	; 0x3406 <main+0xb90>
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    345a:	d6 01       	movw	r26, r12
    345c:	ed 91       	ld	r30, X+
    345e:	fc 91       	ld	r31, X
    3460:	01 90       	ld	r0, Z+
    3462:	f0 81       	ld	r31, Z
    3464:	e0 2d       	mov	r30, r0
    3466:	c6 01       	movw	r24, r12
    3468:	19 95       	eicall
    346a:	ef e3       	ldi	r30, 0x3F	; 63
    346c:	fc e9       	ldi	r31, 0x9C	; 156
    346e:	31 97       	sbiw	r30, 0x01	; 1
    3470:	f1 f7       	brne	.-4      	; 0x346e <main+0xbf8>
    3472:	00 c0       	rjmp	.+0      	; 0x3474 <main+0xbfe>
    3474:	00 00       	nop
    3476:	29 89       	ldd	r18, Y+17	; 0x11
    3478:	3a 89       	ldd	r19, Y+18	; 0x12
    347a:	21 50       	subi	r18, 0x01	; 1
    347c:	31 09       	sbc	r19, r1
    347e:	3a 8b       	std	Y+18, r19	; 0x12
    3480:	29 8b       	std	Y+17, r18	; 0x11
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    3482:	23 2b       	or	r18, r19
    3484:	51 f7       	brne	.-44     	; 0x345a <main+0xbe4>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			average +=model->PressureMillibars();
    3486:	af 85       	ldd	r26, Y+15	; 0x0f
    3488:	b8 89       	ldd	r27, Y+16	; 0x10
    348a:	2d 91       	ld	r18, X+
    348c:	3d 91       	ld	r19, X+
    348e:	4d 91       	ld	r20, X+
    3490:	5c 91       	ld	r21, X
    3492:	e9 81       	ldd	r30, Y+1	; 0x01
    3494:	fd 81       	ldd	r31, Y+5	; 0x05
    3496:	61 2f       	mov	r22, r17
    3498:	70 2f       	mov	r23, r16
    349a:	8e 2f       	mov	r24, r30
    349c:	9f 2f       	mov	r25, r31
    349e:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    34a2:	16 2f       	mov	r17, r22
    34a4:	07 2f       	mov	r16, r23
    34a6:	89 83       	std	Y+1, r24	; 0x01
    34a8:	9d 83       	std	Y+5, r25	; 0x05
    34aa:	b1 e0       	ldi	r27, 0x01	; 1
    34ac:	ab 1a       	sub	r10, r27
    34ae:	b1 08       	sbc	r11, r1
		}
		
		
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
    34b0:	29 f0       	breq	.+10     	; 0x34bc <main+0xc46>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    34b2:	e3 e0       	ldi	r30, 0x03	; 3
    34b4:	f0 e0       	ldi	r31, 0x00	; 0
    34b6:	fa 8b       	std	Y+18, r31	; 0x12
    34b8:	e9 8b       	std	Y+17, r30	; 0x11
    34ba:	cf cf       	rjmp	.-98     	; 0x345a <main+0xbe4>
    34bc:	38 a6       	std	Y+40, r3	; 0x28
    34be:	2f a2       	std	Y+39, r2	; 0x27
			}
			average +=model->PressureMillibars();
			
		}
		
		model->PressureMillibars((float)average/((float)iterations));
    34c0:	20 e0       	ldi	r18, 0x00	; 0
    34c2:	30 e0       	ldi	r19, 0x00	; 0
    34c4:	40 e2       	ldi	r20, 0x20	; 32
    34c6:	51 e4       	ldi	r21, 0x41	; 65
    34c8:	a9 81       	ldd	r26, Y+1	; 0x01
    34ca:	ad 80       	ldd	r10, Y+5	; 0x05
    34cc:	8a 2f       	mov	r24, r26
    34ce:	9a 2d       	mov	r25, r10
    34d0:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    34d4:	f4 01       	movw	r30, r8
    34d6:	ea 5e       	subi	r30, 0xEA	; 234
    34d8:	fe 4f       	sbci	r31, 0xFE	; 254
    34da:	06 2f       	mov	r16, r22
    34dc:	17 2f       	mov	r17, r23
    34de:	28 2f       	mov	r18, r24
    34e0:	39 2f       	mov	r19, r25
    34e2:	00 83       	st	Z, r16
    34e4:	11 83       	std	Z+1, r17	; 0x01
    34e6:	22 83       	std	Z+2, r18	; 0x02
    34e8:	33 83       	std	Z+3, r19	; 0x03
		
		//set the initial altitude based on sensor readings.
		//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
		model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    34ea:	20 e0       	ldi	r18, 0x00	; 0
    34ec:	30 e5       	ldi	r19, 0x50	; 80
    34ee:	4d e7       	ldi	r20, 0x7D	; 125
    34f0:	54 e4       	ldi	r21, 0x44	; 68
    34f2:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    34f6:	0e 94 88 6d 	call	0xdb10	; 0xdb10 <log10>
    34fa:	2b e2       	ldi	r18, 0x2B	; 43
    34fc:	30 e3       	ldi	r19, 0x30	; 48
    34fe:	48 ea       	ldi	r20, 0xA8	; 168
    3500:	50 e4       	ldi	r21, 0x40	; 64
    3502:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    3506:	9b 01       	movw	r18, r22
    3508:	ac 01       	movw	r20, r24
    350a:	60 e0       	ldi	r22, 0x00	; 0
    350c:	70 e0       	ldi	r23, 0x00	; 0
    350e:	80 e2       	ldi	r24, 0x20	; 32
    3510:	91 e4       	ldi	r25, 0x41	; 65
    3512:	0e 94 36 6e 	call	0xdc6c	; 0xdc6c <pow>
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    3516:	84 01       	movw	r16, r8
    3518:	06 53       	subi	r16, 0x36	; 54
    351a:	1f 4f       	sbci	r17, 0xFF	; 255
    351c:	20 e0       	ldi	r18, 0x00	; 0
    351e:	30 e0       	ldi	r19, 0x00	; 0
    3520:	40 e8       	ldi	r20, 0x80	; 128
    3522:	5f e3       	ldi	r21, 0x3F	; 63
    3524:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    3528:	29 e9       	ldi	r18, 0x99	; 153
    352a:	3a e4       	ldi	r19, 0x4A	; 74
    352c:	47 e8       	ldi	r20, 0x87	; 135
    352e:	5a e4       	ldi	r21, 0x4A	; 74
    3530:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    3534:	d8 01       	movw	r26, r16
    3536:	6d 93       	st	X+, r22
    3538:	7d 93       	st	X+, r23
    353a:	8d 93       	st	X+, r24
    353c:	9c 93       	st	X, r25
    353e:	13 97       	sbiw	r26, 0x03	; 3
		
		
		float accelGain = ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT;
    3540:	20 91 0a 02 	lds	r18, 0x020A
    3544:	30 91 0b 02 	lds	r19, 0x020B
    3548:	40 91 0c 02 	lds	r20, 0x020C
    354c:	50 91 0d 02 	lds	r21, 0x020D
    3550:	29 83       	std	Y+1, r18	; 0x01
    3552:	3a 83       	std	Y+2, r19	; 0x02
    3554:	4b 83       	std	Y+3, r20	; 0x03
    3556:	5c 83       	std	Y+4, r21	; 0x04
		float magGain = ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT;
    3558:	80 91 06 02 	lds	r24, 0x0206
    355c:	90 91 07 02 	lds	r25, 0x0207
    3560:	a0 91 08 02 	lds	r26, 0x0208
    3564:	b0 91 09 02 	lds	r27, 0x0209
    3568:	8d 83       	std	Y+5, r24	; 0x05
    356a:	9e 83       	std	Y+6, r25	; 0x06
    356c:	af 83       	std	Y+7, r26	; 0x07
    356e:	b8 87       	std	Y+8, r27	; 0x08
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    3570:	8d ec       	ldi	r24, 0xCD	; 205
    3572:	9c ec       	ldi	r25, 0xCC	; 204
    3574:	ac ec       	ldi	r26, 0xCC	; 204
    3576:	bd e3       	ldi	r27, 0x3D	; 61
    3578:	80 93 0a 02 	sts	0x020A, r24
    357c:	90 93 0b 02 	sts	0x020B, r25
    3580:	a0 93 0c 02 	sts	0x020C, r26
    3584:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    3588:	80 93 06 02 	sts	0x0206, r24
    358c:	90 93 07 02 	sts	0x0207, r25
    3590:	a0 93 08 02 	sts	0x0208, r26
    3594:	b0 93 09 02 	sts	0x0209, r27
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    3598:	a1 2c       	mov	r10, r1
    359a:	b1 2c       	mov	r11, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
    359c:	03 e0       	ldi	r16, 0x03	; 3
    359e:	10 e0       	ldi	r17, 0x00	; 0
    35a0:	41 01       	movw	r8, r2
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
		{
			magSensorTask->runTaskImpl();
    35a2:	d7 01       	movw	r26, r14
    35a4:	ed 91       	ld	r30, X+
    35a6:	fc 91       	ld	r31, X
    35a8:	01 90       	ld	r0, Z+
    35aa:	f0 81       	ld	r31, Z
    35ac:	e0 2d       	mov	r30, r0
    35ae:	c7 01       	movw	r24, r14
    35b0:	19 95       	eicall
			gpsSensorTask->runTaskImpl();
    35b2:	a9 85       	ldd	r26, Y+9	; 0x09
    35b4:	ba 85       	ldd	r27, Y+10	; 0x0a
    35b6:	ed 91       	ld	r30, X+
    35b8:	fc 91       	ld	r31, X
    35ba:	11 97       	sbiw	r26, 0x01	; 1
    35bc:	01 90       	ld	r0, Z+
    35be:	f0 81       	ld	r31, Z
    35c0:	e0 2d       	mov	r30, r0
    35c2:	cd 01       	movw	r24, r26
    35c4:	19 95       	eicall
    35c6:	18 01       	movw	r2, r16
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    35c8:	d6 01       	movw	r26, r12
    35ca:	ed 91       	ld	r30, X+
    35cc:	fc 91       	ld	r31, X
    35ce:	01 90       	ld	r0, Z+
    35d0:	f0 81       	ld	r31, Z
    35d2:	e0 2d       	mov	r30, r0
    35d4:	c6 01       	movw	r24, r12
    35d6:	19 95       	eicall
    35d8:	ef e3       	ldi	r30, 0x3F	; 63
    35da:	fc e9       	ldi	r31, 0x9C	; 156
    35dc:	31 97       	sbiw	r30, 0x01	; 1
    35de:	f1 f7       	brne	.-4      	; 0x35dc <main+0xd66>
    35e0:	00 c0       	rjmp	.+0      	; 0x35e2 <main+0xd6c>
    35e2:	00 00       	nop
    35e4:	f1 e0       	ldi	r31, 0x01	; 1
    35e6:	2f 1a       	sub	r2, r31
    35e8:	31 08       	sbc	r3, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    35ea:	71 f7       	brne	.-36     	; 0x35c8 <main+0xd52>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			
			imuSensorTask->runTaskImpl();
    35ec:	ab 85       	ldd	r26, Y+11	; 0x0b
    35ee:	bc 85       	ldd	r27, Y+12	; 0x0c
    35f0:	ed 91       	ld	r30, X+
    35f2:	fc 91       	ld	r31, X
    35f4:	11 97       	sbiw	r26, 0x01	; 1
    35f6:	01 90       	ld	r0, Z+
    35f8:	f0 81       	ld	r31, Z
    35fa:	e0 2d       	mov	r30, r0
    35fc:	cd 01       	movw	r24, r26
    35fe:	19 95       	eicall
			
			navTask->runTaskImpl();
    3600:	ad 8d       	ldd	r26, Y+29	; 0x1d
    3602:	be 8d       	ldd	r27, Y+30	; 0x1e
    3604:	ed 91       	ld	r30, X+
    3606:	fc 91       	ld	r31, X
    3608:	11 97       	sbiw	r26, 0x01	; 1
    360a:	01 90       	ld	r0, Z+
    360c:	f0 81       	ld	r31, Z
    360e:	e0 2d       	mov	r30, r0
    3610:	cd 01       	movw	r24, r26
    3612:	19 95       	eicall
			pvNavTask->runTaskImpl();
    3614:	af 8d       	ldd	r26, Y+31	; 0x1f
    3616:	b8 a1       	ldd	r27, Y+32	; 0x20
    3618:	ed 91       	ld	r30, X+
    361a:	fc 91       	ld	r31, X
    361c:	11 97       	sbiw	r26, 0x01	; 1
    361e:	01 90       	ld	r0, Z+
    3620:	f0 81       	ld	r31, Z
    3622:	e0 2d       	mov	r30, r0
    3624:	cd 01       	movw	r24, r26
    3626:	19 95       	eicall
    3628:	ef e3       	ldi	r30, 0x3F	; 63
    362a:	fc e9       	ldi	r31, 0x9C	; 156
    362c:	31 97       	sbiw	r30, 0x01	; 1
    362e:	f1 f7       	brne	.-4      	; 0x362c <main+0xdb6>
    3630:	00 c0       	rjmp	.+0      	; 0x3632 <main+0xdbc>
    3632:	00 00       	nop
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    3634:	ff ef       	ldi	r31, 0xFF	; 255
    3636:	af 1a       	sub	r10, r31
    3638:	bf 0a       	sbc	r11, r31
    363a:	29 8d       	ldd	r18, Y+25	; 0x19
    363c:	3a 8d       	ldd	r19, Y+26	; 0x1a
    363e:	a2 16       	cp	r10, r18
    3640:	b3 06       	cpc	r11, r19
    3642:	0c f4       	brge	.+2      	; 0x3646 <main+0xdd0>
    3644:	ae cf       	rjmp	.-164    	; 0x35a2 <main+0xd2c>
    3646:	98 a6       	std	Y+40, r9	; 0x28
    3648:	8f a2       	std	Y+39, r8	; 0x27
			pvNavTask->runTaskImpl();
			
			_delay_ms(10);
		}
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = accelGain;
    364a:	89 81       	ldd	r24, Y+1	; 0x01
    364c:	9a 81       	ldd	r25, Y+2	; 0x02
    364e:	ab 81       	ldd	r26, Y+3	; 0x03
    3650:	bc 81       	ldd	r27, Y+4	; 0x04
    3652:	80 93 0a 02 	sts	0x020A, r24
    3656:	90 93 0b 02 	sts	0x020B, r25
    365a:	a0 93 0c 02 	sts	0x020C, r26
    365e:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = magGain;
    3662:	2d 81       	ldd	r18, Y+5	; 0x05
    3664:	3e 81       	ldd	r19, Y+6	; 0x06
    3666:	4f 81       	ldd	r20, Y+7	; 0x07
    3668:	58 85       	ldd	r21, Y+8	; 0x08
    366a:	20 93 06 02 	sts	0x0206, r18
    366e:	30 93 07 02 	sts	0x0207, r19
    3672:	40 93 08 02 	sts	0x0208, r20
    3676:	50 93 09 02 	sts	0x0209, r21
    367a:	ff c0       	rjmp	.+510    	; 0x387a <main+0x1004>
	}else
	{

		//SerialDriver *initSerialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, NULL);
		//GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(initSerialDriver);
		GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(serialDriver);
    367c:	82 e0       	ldi	r24, 0x02	; 2
    367e:	90 e0       	ldi	r25, 0x00	; 0
    3680:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    3684:	9a 83       	std	Y+2, r25	; 0x02
    3686:	89 83       	std	Y+1, r24	; 0x01
    3688:	dc 01       	movw	r26, r24
    368a:	ad 92       	st	X+, r10
    368c:	bc 92       	st	X, r11
		SimTelemetryTask *initSimTelemTask = new SimTelemetryTask(initGcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    368e:	8e e0       	ldi	r24, 0x0E	; 14
    3690:	90 e0       	ldi	r25, 0x00	; 0
    3692:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    3696:	5c 01       	movw	r10, r24
    3698:	0f 2e       	mov	r0, r31
    369a:	fa e0       	ldi	r31, 0x0A	; 10
    369c:	cf 2e       	mov	r12, r31
    369e:	d1 2c       	mov	r13, r1
    36a0:	f0 2d       	mov	r31, r0
    36a2:	e1 2c       	mov	r14, r1
    36a4:	f1 2c       	mov	r15, r1
    36a6:	00 e0       	ldi	r16, 0x00	; 0
    36a8:	93 01       	movw	r18, r6
    36aa:	a4 01       	movw	r20, r8
    36ac:	69 81       	ldd	r22, Y+1	; 0x01
    36ae:	7a 81       	ldd	r23, Y+2	; 0x02
    36b0:	0e 94 02 60 	call	0xc004	; 0xc004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    36b4:	14 01       	movw	r2, r8
    36b6:	b2 ea       	ldi	r27, 0xA2	; 162
    36b8:	2b 0e       	add	r2, r27
    36ba:	31 1c       	adc	r3, r1
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    36bc:	84 01       	movw	r16, r8
    36be:	0a 55       	subi	r16, 0x5A	; 90
    36c0:	1f 4f       	sbci	r17, 0xFF	; 255
	
		while (!isInitialized)
		{
			initSimTelemTask->runTaskImpl();
    36c2:	d5 01       	movw	r26, r10
    36c4:	ed 91       	ld	r30, X+
    36c6:	fc 91       	ld	r31, X
    36c8:	01 90       	ld	r0, Z+
    36ca:	f0 81       	ld	r31, Z
    36cc:	e0 2d       	mov	r30, r0
    36ce:	c5 01       	movw	r24, r10
    36d0:	19 95       	eicall

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    36d2:	f1 01       	movw	r30, r2
    36d4:	c0 80       	ld	r12, Z
    36d6:	d1 80       	ldd	r13, Z+1	; 0x01
    36d8:	e2 80       	ldd	r14, Z+2	; 0x02
    36da:	f3 80       	ldd	r15, Z+3	; 0x03
		
			if (model->LatitudeDegrees() != 0 && model->LongitudeDegrees() != 0)
    36dc:	20 e0       	ldi	r18, 0x00	; 0
    36de:	30 e0       	ldi	r19, 0x00	; 0
    36e0:	a9 01       	movw	r20, r18
    36e2:	c7 01       	movw	r24, r14
    36e4:	b6 01       	movw	r22, r12
    36e6:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    36ea:	88 23       	and	r24, r24
    36ec:	61 f0       	breq	.+24     	; 0x3706 <main+0xe90>
    36ee:	20 e0       	ldi	r18, 0x00	; 0
    36f0:	30 e0       	ldi	r19, 0x00	; 0
    36f2:	a9 01       	movw	r20, r18
    36f4:	d8 01       	movw	r26, r16
    36f6:	6d 91       	ld	r22, X+
    36f8:	7d 91       	ld	r23, X+
    36fa:	8d 91       	ld	r24, X+
    36fc:	9c 91       	ld	r25, X
    36fe:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    3702:	81 11       	cpse	r24, r1
    3704:	38 c0       	rjmp	.+112    	; 0x3776 <main+0xf00>
    3706:	bf ef       	ldi	r27, 0xFF	; 255
    3708:	e1 ee       	ldi	r30, 0xE1	; 225
    370a:	f4 e0       	ldi	r31, 0x04	; 4
    370c:	b1 50       	subi	r27, 0x01	; 1
    370e:	e0 40       	sbci	r30, 0x00	; 0
    3710:	f0 40       	sbci	r31, 0x00	; 0
    3712:	e1 f7       	brne	.-8      	; 0x370c <main+0xe96>
    3714:	00 c0       	rjmp	.+0      	; 0x3716 <main+0xea0>
    3716:	00 00       	nop
    3718:	d4 cf       	rjmp	.-88     	; 0x36c2 <main+0xe4c>
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    371a:	d5 01       	movw	r26, r10
    371c:	ed 91       	ld	r30, X+
    371e:	fc 91       	ld	r31, X
    3720:	04 80       	ldd	r0, Z+4	; 0x04
    3722:	f5 81       	ldd	r31, Z+5	; 0x05
    3724:	e0 2d       	mov	r30, r0
    3726:	c5 01       	movw	r24, r10
    3728:	19 95       	eicall
		delete initGcsInterface;
    372a:	e9 81       	ldd	r30, Y+1	; 0x01
    372c:	fa 81       	ldd	r31, Y+2	; 0x02
    372e:	30 97       	sbiw	r30, 0x00	; 0
    3730:	09 f4       	brne	.+2      	; 0x3734 <main+0xebe>
    3732:	a3 c0       	rjmp	.+326    	; 0x387a <main+0x1004>
    3734:	cf 01       	movw	r24, r30
    3736:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    373a:	9f c0       	rjmp	.+318    	; 0x387a <main+0x1004>
	{

	
		//Checks to see if any tasks are ready to run an executes them.
		//goes to sleep (until the next timer tick) after processing all available tasks.
		scheduler->dispatch();
    373c:	c8 01       	movw	r24, r16
    373e:	0e 94 c6 42 	call	0x858c	; 0x858c <_ZN10helicopter9scheduler9Scheduler8dispatchEv>
		
		/**
		 * Determine if the last processing frame was blown.
		 */
		if (scheduler->hasBlownFrame())
    3742:	d8 01       	movw	r26, r16
    3744:	d8 96       	adiw	r26, 0x38	; 56
    3746:	8c 91       	ld	r24, X
    3748:	88 23       	and	r24, r24
    374a:	c1 f3       	breq	.-16     	; 0x373c <main+0xec6>
		{
			pidController->addBlownFrame();
    374c:	c3 01       	movw	r24, r6
    374e:	0e 94 4c 04 	call	0x898	; 0x898 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>
    3752:	f4 cf       	rjmp	.-24     	; 0x373c <main+0xec6>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3754:	0f 2e       	mov	r0, r31
    3756:	fa e0       	ldi	r31, 0x0A	; 10
    3758:	af 2e       	mov	r10, r31
    375a:	b1 2c       	mov	r11, r1
    375c:	f0 2d       	mov	r31, r0
    375e:	10 e0       	ldi	r17, 0x00	; 0
    3760:	00 e0       	ldi	r16, 0x00	; 0
    3762:	19 82       	std	Y+1, r1	; 0x01
    3764:	1d 82       	std	Y+5, r1	; 0x05
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    3766:	f4 01       	movw	r30, r8
    3768:	ea 5e       	subi	r30, 0xEA	; 234
    376a:	fe 4f       	sbci	r31, 0xFE	; 254
    376c:	f8 8b       	std	Y+16, r31	; 0x10
    376e:	ef 87       	std	Y+15, r30	; 0x0f
    3770:	2f a0       	ldd	r2, Y+39	; 0x27
    3772:	38 a4       	ldd	r3, Y+40	; 0x28
    3774:	9e ce       	rjmp	.-708    	; 0x34b2 <main+0xc3c>
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    3776:	84 01       	movw	r16, r8
    3778:	02 54       	subi	r16, 0x42	; 66
    377a:	1f 4f       	sbci	r17, 0xFF	; 255
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    377c:	f4 01       	movw	r30, r8
    377e:	e2 50       	subi	r30, 0x02	; 2
    3780:	ff 4f       	sbci	r31, 0xFF	; 255
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    3782:	60 81       	ld	r22, Z
    3784:	71 81       	ldd	r23, Z+1	; 0x01
    3786:	82 81       	ldd	r24, Z+2	; 0x02
    3788:	93 81       	ldd	r25, Z+3	; 0x03
    378a:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    378e:	d8 01       	movw	r26, r16
    3790:	6d 93       	st	X+, r22
    3792:	7d 93       	st	X+, r23
    3794:	8d 93       	st	X+, r24
    3796:	9c 93       	st	X, r25
    3798:	13 97       	sbiw	r26, 0x03	; 3

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    379a:	84 01       	movw	r16, r8
    379c:	0e 53       	subi	r16, 0x3E	; 62
    379e:	1f 4f       	sbci	r17, 0xFF	; 255
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    37a0:	f4 01       	movw	r30, r8
    37a2:	ee 5f       	subi	r30, 0xFE	; 254
    37a4:	fe 4f       	sbci	r31, 0xFE	; 254

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    37a6:	60 81       	ld	r22, Z
    37a8:	71 81       	ldd	r23, Z+1	; 0x01
    37aa:	82 81       	ldd	r24, Z+2	; 0x02
    37ac:	93 81       	ldd	r25, Z+3	; 0x03
    37ae:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    37b2:	f8 01       	movw	r30, r16
    37b4:	60 83       	st	Z, r22
    37b6:	71 83       	std	Z+1, r23	; 0x01
    37b8:	82 83       	std	Z+2, r24	; 0x02
    37ba:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    37bc:	84 01       	movw	r16, r8
    37be:	0a 53       	subi	r16, 0x3A	; 58
    37c0:	1f 4f       	sbci	r17, 0xFF	; 255
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    37c2:	f4 01       	movw	r30, r8
    37c4:	ea 5f       	subi	r30, 0xFA	; 250
    37c6:	fe 4f       	sbci	r31, 0xFE	; 254

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    37c8:	60 81       	ld	r22, Z
    37ca:	71 81       	ldd	r23, Z+1	; 0x01
    37cc:	82 81       	ldd	r24, Z+2	; 0x02
    37ce:	93 81       	ldd	r25, Z+3	; 0x03
    37d0:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    37d4:	d8 01       	movw	r26, r16
    37d6:	6d 93       	st	X+, r22
    37d8:	7d 93       	st	X+, r23
    37da:	8d 93       	st	X+, r24
    37dc:	9c 93       	st	X, r25
    37de:	13 97       	sbiw	r26, 0x03	; 3
				model->InitialYPositionEcef(model->YEcefCm());
				model->InitialZPositionEcef(model->ZEcefCm());
			
			
				////ecefReferenceX, ecefReferenceY, ecefReferenceZ,ecefToLocalNEDRotationMatrix,
				CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    37e0:	84 01       	movw	r16, r8
    37e2:	02 5e       	subi	r16, 0xE2	; 226
    37e4:	1e 4f       	sbci	r17, 0xFE	; 254
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    37e6:	f4 01       	movw	r30, r8
    37e8:	ea 55       	subi	r30, 0x5A	; 90
    37ea:	ff 4f       	sbci	r31, 0xFF	; 255
    37ec:	20 81       	ld	r18, Z
    37ee:	31 81       	ldd	r19, Z+1	; 0x01
    37f0:	42 81       	ldd	r20, Z+2	; 0x02
    37f2:	53 81       	ldd	r21, Z+3	; 0x03
    37f4:	c7 01       	movw	r24, r14
    37f6:	b6 01       	movw	r22, r12
    37f8:	0e 94 92 64 	call	0xc924	; 0xc924 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    37fc:	f4 01       	movw	r30, r8
    37fe:	ea 5e       	subi	r30, 0xEA	; 234
    3800:	fe 4f       	sbci	r31, 0xFE	; 254
				//multiply by -1 because in NED/FRD frame, down is positive. 
				//model->InitialAltitudeMeters(((288.15/(6.5/1000.0))*(1-(pow((model->PressureMillibars()/101325.0),(6.5/1000.0)*(287.052/9.78))))) * -1);
			
				//https://www.brisbanehotairballooning.com.au/faqs/education/113-pressure-altitude-conversion.html
				//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    3802:	20 e0       	ldi	r18, 0x00	; 0
    3804:	30 e5       	ldi	r19, 0x50	; 80
    3806:	4d e7       	ldi	r20, 0x7D	; 125
    3808:	54 e4       	ldi	r21, 0x44	; 68
    380a:	60 81       	ld	r22, Z
    380c:	71 81       	ldd	r23, Z+1	; 0x01
    380e:	82 81       	ldd	r24, Z+2	; 0x02
    3810:	93 81       	ldd	r25, Z+3	; 0x03
    3812:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    3816:	0e 94 88 6d 	call	0xdb10	; 0xdb10 <log10>
    381a:	2b e2       	ldi	r18, 0x2B	; 43
    381c:	30 e3       	ldi	r19, 0x30	; 48
    381e:	48 ea       	ldi	r20, 0xA8	; 168
    3820:	50 e4       	ldi	r21, 0x40	; 64
    3822:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    3826:	9b 01       	movw	r18, r22
    3828:	ac 01       	movw	r20, r24
    382a:	60 e0       	ldi	r22, 0x00	; 0
    382c:	70 e0       	ldi	r23, 0x00	; 0
    382e:	80 e2       	ldi	r24, 0x20	; 32
    3830:	91 e4       	ldi	r25, 0x41	; 65
    3832:	0e 94 36 6e 	call	0xdc6c	; 0xdc6c <pow>
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    3836:	84 01       	movw	r16, r8
    3838:	06 53       	subi	r16, 0x36	; 54
    383a:	1f 4f       	sbci	r17, 0xFF	; 255
    383c:	20 e0       	ldi	r18, 0x00	; 0
    383e:	30 e0       	ldi	r19, 0x00	; 0
    3840:	40 e8       	ldi	r20, 0x80	; 128
    3842:	5f e3       	ldi	r21, 0x3F	; 63
    3844:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    3848:	29 e9       	ldi	r18, 0x99	; 153
    384a:	3a e4       	ldi	r19, 0x4A	; 74
    384c:	47 e8       	ldi	r20, 0x87	; 135
    384e:	5a e4       	ldi	r21, 0x4A	; 74
    3850:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    3854:	f8 01       	movw	r30, r16
    3856:	60 83       	st	Z, r22
    3858:	71 83       	std	Z+1, r23	; 0x01
    385a:	82 83       	std	Z+2, r24	; 0x02
    385c:	93 83       	std	Z+3, r25	; 0x03
    385e:	ff ef       	ldi	r31, 0xFF	; 255
    3860:	21 ee       	ldi	r18, 0xE1	; 225
    3862:	34 e0       	ldi	r19, 0x04	; 4
    3864:	f1 50       	subi	r31, 0x01	; 1
    3866:	20 40       	sbci	r18, 0x00	; 0
    3868:	30 40       	sbci	r19, 0x00	; 0
    386a:	e1 f7       	brne	.-8      	; 0x3864 <main+0xfee>
    386c:	00 c0       	rjmp	.+0      	; 0x386e <main+0xff8>
    386e:	00 00       	nop
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    3870:	a1 14       	cp	r10, r1
    3872:	b1 04       	cpc	r11, r1
    3874:	09 f0       	breq	.+2      	; 0x3878 <main+0x1002>
    3876:	51 cf       	rjmp	.-350    	; 0x371a <main+0xea4>
    3878:	58 cf       	rjmp	.-336    	; 0x372a <main+0xeb4>
	
	
	if (isInitialized)
	{
		//turn red LED off to indicate initialized.
		PORTA |= (1<<PA5);
    387a:	15 9a       	sbi	0x02, 5	; 2
	}
	
	gpsSensor->start();
    387c:	c2 01       	movw	r24, r4
    387e:	0e 94 e3 4b 	call	0x97c6	; 0x97c6 <_ZN10helicopter7sensors9GPSSensor5startEv>

	scheduler->init(); //Sets up the timer registers, inits all tasks,
    3882:	8f a1       	ldd	r24, Y+39	; 0x27
    3884:	98 a5       	ldd	r25, Y+40	; 0x28
    3886:	0e 94 8a 42 	call	0x8514	; 0x8514 <_ZN10helicopter9scheduler9Scheduler4initEv>
	
	scheduler->start();
    388a:	8f a1       	ldd	r24, Y+39	; 0x27
    388c:	98 a5       	ldd	r25, Y+40	; 0x28
    388e:	0e 94 07 43 	call	0x860e	; 0x860e <_ZN10helicopter9scheduler9Scheduler5startEv>
    3892:	0f a1       	ldd	r16, Y+39	; 0x27
    3894:	18 a5       	ldd	r17, Y+40	; 0x28
    3896:	52 cf       	rjmp	.-348    	; 0x373c <main+0xec6>

00003898 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>:

using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
    3898:	0f 93       	push	r16
    389a:	1f 93       	push	r17
    389c:	cf 93       	push	r28
    389e:	df 93       	push	r29
    38a0:	d9 01       	movw	r26, r18
    38a2:	e8 01       	movw	r28, r16
	for (int i = 0; i < payloadSize; i++)
    38a4:	14 16       	cp	r1, r20
    38a6:	15 06       	cpc	r1, r21
    38a8:	74 f4       	brge	.+28     	; 0x38c6 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x2e>
    38aa:	e6 2f       	mov	r30, r22
    38ac:	f7 2f       	mov	r31, r23
#include "GainsMessage.h"

using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
    38ae:	4e 0f       	add	r20, r30
    38b0:	5f 1f       	adc	r21, r31
{
	for (int i = 0; i < payloadSize; i++)
	{
		byte b = msgPayload[i];
    38b2:	91 91       	ld	r25, Z+
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
    38b4:	8c 91       	ld	r24, X
    38b6:	89 0f       	add	r24, r25
    38b8:	8c 93       	st	X, r24
		checksumB = (byte) (checksumB + checksumA);
    38ba:	98 81       	ld	r25, Y
    38bc:	89 0f       	add	r24, r25
    38be:	88 83       	st	Y, r24
using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
	for (int i = 0; i < payloadSize; i++)
    38c0:	e4 17       	cp	r30, r20
    38c2:	f5 07       	cpc	r31, r21
    38c4:	b1 f7       	brne	.-20     	; 0x38b2 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x1a>
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
		checksumB = (byte) (checksumB + checksumA);
	}
}
    38c6:	df 91       	pop	r29
    38c8:	cf 91       	pop	r28
    38ca:	1f 91       	pop	r17
    38cc:	0f 91       	pop	r16
    38ce:	08 95       	ret

000038d0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>:

int GroundControlStationInterface::transmit(Message *msgToSend)
{
    38d0:	2f 92       	push	r2
    38d2:	3f 92       	push	r3
    38d4:	4f 92       	push	r4
    38d6:	5f 92       	push	r5
    38d8:	6f 92       	push	r6
    38da:	7f 92       	push	r7
    38dc:	8f 92       	push	r8
    38de:	9f 92       	push	r9
    38e0:	af 92       	push	r10
    38e2:	bf 92       	push	r11
    38e4:	cf 92       	push	r12
    38e6:	df 92       	push	r13
    38e8:	ef 92       	push	r14
    38ea:	ff 92       	push	r15
    38ec:	0f 93       	push	r16
    38ee:	1f 93       	push	r17
    38f0:	cf 93       	push	r28
    38f2:	df 93       	push	r29
    38f4:	00 d0       	rcall	.+0      	; 0x38f6 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x26>
    38f6:	1f 92       	push	r1
    38f8:	cd b7       	in	r28, 0x3d	; 61
    38fa:	de b7       	in	r29, 0x3e	; 62
    38fc:	7c 01       	movw	r14, r24
    38fe:	8b 01       	movw	r16, r22
		}
	
	}
	
	return status;
}
    3900:	4d b6       	in	r4, 0x3d	; 61
    3902:	5e b6       	in	r5, 0x3e	; 62

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
	
	if (msgToSend != NULL)
    3904:	61 15       	cp	r22, r1
    3906:	71 05       	cpc	r23, r1
    3908:	09 f4       	brne	.+2      	; 0x390c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x3c>
    390a:	89 c0       	rjmp	.+274    	; 0x3a1e <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x14e>
	{
		byte *msgPayload = msgToSend->getBytes();
    390c:	db 01       	movw	r26, r22
    390e:	ed 91       	ld	r30, X+
    3910:	fc 91       	ld	r31, X
    3912:	04 80       	ldd	r0, Z+4	; 0x04
    3914:	f5 81       	ldd	r31, Z+5	; 0x05
    3916:	e0 2d       	mov	r30, r0
    3918:	cb 01       	movw	r24, r22
    391a:	19 95       	eicall
    391c:	5c 01       	movw	r10, r24
    391e:	bd b7       	in	r27, 0x3d	; 61
    3920:	bb 83       	std	Y+3, r27	; 0x03
    3922:	ee b7       	in	r30, 0x3e	; 62
    3924:	ec 83       	std	Y+4, r30	; 0x04
		//check for out of memory. (shouldn't be necessary).
		//if (msgPayload != NULL)
		{
			
		
			int payloadSize = msgToSend->getMessageSize();
    3926:	c8 01       	movw	r24, r16
    3928:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <_ZN10helicopter8messages7Message14getMessageSizeEv>
    392c:	4c 01       	movw	r8, r24
		
			int completeMsgSize = payloadSize + MsgHeaderFooterSize;;
    392e:	6c 01       	movw	r12, r24
    3930:	f5 e0       	ldi	r31, 0x05	; 5
    3932:	cf 0e       	add	r12, r31
    3934:	d1 1c       	adc	r13, r1

			byte completeMsg[completeMsgSize];
    3936:	1c 01       	movw	r2, r24
    3938:	84 e0       	ldi	r24, 0x04	; 4
    393a:	28 0e       	add	r2, r24
    393c:	31 1c       	adc	r3, r1
    393e:	ad b7       	in	r26, 0x3d	; 61
    3940:	be b7       	in	r27, 0x3e	; 62
    3942:	ac 19       	sub	r26, r12
    3944:	bd 09       	sbc	r27, r13
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	f8 94       	cli
    394a:	be bf       	out	0x3e, r27	; 62
    394c:	0f be       	out	0x3f, r0	; 63
    394e:	ad bf       	out	0x3d, r26	; 61
    3950:	6d b6       	in	r6, 0x3d	; 61
    3952:	7e b6       	in	r7, 0x3e	; 62
    3954:	e1 e0       	ldi	r30, 0x01	; 1
    3956:	f0 e0       	ldi	r31, 0x00	; 0
    3958:	6e 0e       	add	r6, r30
    395a:	7f 1e       	adc	r7, r31
		
			completeMsg[0] = GroundControlStationInterface::SyncByte1;
    395c:	85 eb       	ldi	r24, 0xB5	; 181
    395e:	11 96       	adiw	r26, 0x01	; 1
    3960:	8c 93       	st	X, r24
			completeMsg[1] = GroundControlStationInterface::SyncByte2;
    3962:	82 e6       	ldi	r24, 0x62	; 98
    3964:	d3 01       	movw	r26, r6
    3966:	11 96       	adiw	r26, 0x01	; 1
    3968:	8c 93       	st	X, r24
    396a:	11 97       	sbiw	r26, 0x01	; 1
			completeMsg[2] = GroundControlStationInterface::SyncByte3;
    396c:	87 ed       	ldi	r24, 0xD7	; 215
    396e:	12 96       	adiw	r26, 0x02	; 2
    3970:	8c 93       	st	X, r24
		
			memcpy(&completeMsg[3], msgPayload, payloadSize);
    3972:	2d b7       	in	r18, 0x3d	; 61
    3974:	3e b7       	in	r19, 0x3e	; 62
    3976:	2c 5f       	subi	r18, 0xFC	; 252
    3978:	3f 4f       	sbci	r19, 0xFF	; 255
    397a:	48 2d       	mov	r20, r8
    397c:	59 2d       	mov	r21, r9
    397e:	6a 2d       	mov	r22, r10
    3980:	7b 2d       	mov	r23, r11
    3982:	82 2f       	mov	r24, r18
    3984:	93 2f       	mov	r25, r19
    3986:	0e 94 65 71 	call	0xe2ca	; 0xe2ca <memcpy>
		
			byte checksumA = 0;
    398a:	1a 82       	std	Y+2, r1	; 0x02
			byte checksumB = 0;
    398c:	19 82       	std	Y+1, r1	; 0x01
		
			calculateChecksum(msgPayload, payloadSize, checksumA, checksumB);
    398e:	8e 01       	movw	r16, r28
    3990:	0f 5f       	subi	r16, 0xFF	; 255
    3992:	1f 4f       	sbci	r17, 0xFF	; 255
    3994:	9e 01       	movw	r18, r28
    3996:	2e 5f       	subi	r18, 0xFE	; 254
    3998:	3f 4f       	sbci	r19, 0xFF	; 255
    399a:	a4 01       	movw	r20, r8
    399c:	b5 01       	movw	r22, r10
    399e:	c7 01       	movw	r24, r14
    39a0:	0e 94 4c 1c 	call	0x3898	; 0x3898 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
		
			completeMsg[completeMsgSize - 2] = checksumA;
    39a4:	f3 01       	movw	r30, r6
    39a6:	e8 0d       	add	r30, r8
    39a8:	f9 1d       	adc	r31, r9
    39aa:	8a 81       	ldd	r24, Y+2	; 0x02
    39ac:	83 83       	std	Z+3, r24	; 0x03
			completeMsg[completeMsgSize - 1] = checksumB;
    39ae:	f3 01       	movw	r30, r6
    39b0:	e2 0d       	add	r30, r2
    39b2:	f3 1d       	adc	r31, r3
    39b4:	89 81       	ldd	r24, Y+1	; 0x01
    39b6:	80 83       	st	Z, r24
		
			serialDriver->startTimer();
    39b8:	f7 01       	movw	r30, r14
    39ba:	80 81       	ld	r24, Z
    39bc:	91 81       	ldd	r25, Z+1	; 0x01
    39be:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    39c2:	00 e0       	ldi	r16, 0x00	; 0
    39c4:	10 e0       	ldi	r17, 0x00	; 0
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    39c6:	81 2c       	mov	r8, r1
    39c8:	91 2c       	mov	r9, r1
			completeMsg[completeMsgSize - 1] = checksumB;
		
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    39ca:	0c 15       	cp	r16, r12
    39cc:	1d 05       	cpc	r17, r13
    39ce:	54 f5       	brge	.+84     	; 0x3a24 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x154>
    39d0:	81 14       	cp	r8, r1
    39d2:	91 04       	cpc	r9, r1
    39d4:	81 f1       	breq	.+96     	; 0x3a36 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x166>
    39d6:	26 c0       	rjmp	.+76     	; 0x3a24 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x154>
				status = serialDriver->transmit(completeMsg[i]);
			}
		
			serialDriver->stopTimer();
		
			delete [] msgPayload;
    39d8:	c5 01       	movw	r24, r10
    39da:	0e 94 8d 64 	call	0xc91a	; 0xc91a <_ZdaPv>
			msgPayload = NULL;
		
			
			if (serialDriver->asyncReceiveTransmitData)
    39de:	d7 01       	movw	r26, r14
    39e0:	ed 91       	ld	r30, X+
    39e2:	fc 91       	ld	r31, X
    39e4:	80 85       	ldd	r24, Z+8	; 0x08
    39e6:	88 23       	and	r24, r24
    39e8:	81 f0       	breq	.+32     	; 0x3a0a <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
			{
				//Enable data register empty interrupt so the next byte will be transmitted.
				//I added this code here because enabling interrupts after every byte caused it to not transmit all the data. the system didn't like rapidly enabling interrupts.
				if (serialDriver->uartPort == SerialDriver::Zero)
    39ea:	86 81       	ldd	r24, Z+6	; 0x06
    39ec:	81 11       	cpse	r24, r1
    39ee:	06 c0       	rjmp	.+12     	; 0x39fc <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x12c>
				{
					UCSR0B |= (1<<UDRIE0);
    39f0:	e1 ec       	ldi	r30, 0xC1	; 193
    39f2:	f0 e0       	ldi	r31, 0x00	; 0
    39f4:	80 81       	ld	r24, Z
    39f6:	80 62       	ori	r24, 0x20	; 32
    39f8:	80 83       	st	Z, r24
    39fa:	07 c0       	rjmp	.+14     	; 0x3a0a <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
				}else if (serialDriver->uartPort == SerialDriver::One)
    39fc:	81 30       	cpi	r24, 0x01	; 1
    39fe:	29 f4       	brne	.+10     	; 0x3a0a <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
				{
					UCSR1B |= (1<<UDRIE1);
    3a00:	e9 ec       	ldi	r30, 0xC9	; 201
    3a02:	f0 e0       	ldi	r31, 0x00	; 0
    3a04:	80 81       	ld	r24, Z
    3a06:	80 62       	ori	r24, 0x20	; 32
    3a08:	80 83       	st	Z, r24
    3a0a:	3b 81       	ldd	r19, Y+3	; 0x03
    3a0c:	2c 81       	ldd	r18, Y+4	; 0x04
    3a0e:	83 2f       	mov	r24, r19
    3a10:	92 2f       	mov	r25, r18
    3a12:	0f b6       	in	r0, 0x3f	; 63
    3a14:	f8 94       	cli
    3a16:	9e bf       	out	0x3e, r25	; 62
    3a18:	0f be       	out	0x3f, r0	; 63
    3a1a:	8d bf       	out	0x3d, r24	; 61
    3a1c:	1d c0       	rjmp	.+58     	; 0x3a58 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x188>
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    3a1e:	81 2c       	mov	r8, r1
    3a20:	91 2c       	mov	r9, r1
    3a22:	1a c0       	rjmp	.+52     	; 0x3a58 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x188>
			for (int i = 0; i < completeMsgSize && status == 0; i++)
			{
				status = serialDriver->transmit(completeMsg[i]);
			}
		
			serialDriver->stopTimer();
    3a24:	f7 01       	movw	r30, r14
    3a26:	80 81       	ld	r24, Z
    3a28:	91 81       	ldd	r25, Z+1	; 0x01
    3a2a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
		
			delete [] msgPayload;
    3a2e:	a1 14       	cp	r10, r1
    3a30:	b1 04       	cpc	r11, r1
    3a32:	91 f6       	brne	.-92     	; 0x39d8 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x108>
    3a34:	d4 cf       	rjmp	.-88     	; 0x39de <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x10e>
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
			{
				status = serialDriver->transmit(completeMsg[i]);
    3a36:	d7 01       	movw	r26, r14
    3a38:	8d 91       	ld	r24, X+
    3a3a:	9c 91       	ld	r25, X
    3a3c:	f3 01       	movw	r30, r6
    3a3e:	61 91       	ld	r22, Z+
    3a40:	3f 01       	movw	r6, r30
    3a42:	dc 01       	movw	r26, r24
    3a44:	ed 91       	ld	r30, X+
    3a46:	fc 91       	ld	r31, X
    3a48:	06 80       	ldd	r0, Z+6	; 0x06
    3a4a:	f7 81       	ldd	r31, Z+7	; 0x07
    3a4c:	e0 2d       	mov	r30, r0
    3a4e:	19 95       	eicall
    3a50:	4c 01       	movw	r8, r24
			completeMsg[completeMsgSize - 1] = checksumB;
		
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    3a52:	0f 5f       	subi	r16, 0xFF	; 255
    3a54:	1f 4f       	sbci	r17, 0xFF	; 255
    3a56:	b9 cf       	rjmp	.-142    	; 0x39ca <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0xfa>
		
		}
	
	}
	
	return status;
    3a58:	88 2d       	mov	r24, r8
    3a5a:	99 2d       	mov	r25, r9
}
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	f8 94       	cli
    3a60:	5e be       	out	0x3e, r5	; 62
    3a62:	0f be       	out	0x3f, r0	; 63
    3a64:	4d be       	out	0x3d, r4	; 61
    3a66:	0f 90       	pop	r0
    3a68:	0f 90       	pop	r0
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	df 91       	pop	r29
    3a70:	cf 91       	pop	r28
    3a72:	1f 91       	pop	r17
    3a74:	0f 91       	pop	r16
    3a76:	ff 90       	pop	r15
    3a78:	ef 90       	pop	r14
    3a7a:	df 90       	pop	r13
    3a7c:	cf 90       	pop	r12
    3a7e:	bf 90       	pop	r11
    3a80:	af 90       	pop	r10
    3a82:	9f 90       	pop	r9
    3a84:	8f 90       	pop	r8
    3a86:	7f 90       	pop	r7
    3a88:	6f 90       	pop	r6
    3a8a:	5f 90       	pop	r5
    3a8c:	4f 90       	pop	r4
    3a8e:	3f 90       	pop	r3
    3a90:	2f 90       	pop	r2
    3a92:	08 95       	ret

00003a94 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>:
 * a lot of data is constantly received before that timeout, and none of the data
 * is a sync byte, then this method will never stop receiving bytes and will
 * lock up the rest of the system. So the helicopter would crash waiting for data.
 */
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
    3a94:	2f 92       	push	r2
    3a96:	3f 92       	push	r3
    3a98:	4f 92       	push	r4
    3a9a:	5f 92       	push	r5
    3a9c:	6f 92       	push	r6
    3a9e:	7f 92       	push	r7
    3aa0:	8f 92       	push	r8
    3aa2:	9f 92       	push	r9
    3aa4:	af 92       	push	r10
    3aa6:	bf 92       	push	r11
    3aa8:	cf 92       	push	r12
    3aaa:	df 92       	push	r13
    3aac:	ef 92       	push	r14
    3aae:	ff 92       	push	r15
    3ab0:	0f 93       	push	r16
    3ab2:	1f 93       	push	r17
    3ab4:	cf 93       	push	r28
    3ab6:	df 93       	push	r29
    3ab8:	cd b7       	in	r28, 0x3d	; 61
    3aba:	de b7       	in	r29, 0x3e	; 62
    3abc:	28 97       	sbiw	r28, 0x08	; 8
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	f8 94       	cli
    3ac2:	de bf       	out	0x3e, r29	; 62
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	cd bf       	out	0x3d, r28	; 61
    3ac8:	6c 01       	movw	r12, r24
    3aca:	4b 01       	movw	r8, r22
	}
	
	serialDriver->stopTimer();
	
	return status;
    3acc:	ad b6       	in	r10, 0x3d	; 61
    3ace:	be b6       	in	r11, 0x3e	; 62
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    byte thirdSyncByte = 0;
    3ad0:	1e 82       	std	Y+6, r1	; 0x06
	
	/**
	 * Start the timer to prevent the system from waiting indefinitely
	 * while it receives data (thus causing the helicopter to crash)
	 */
	serialDriver->startTimer();
    3ad2:	dc 01       	movw	r26, r24
    3ad4:	8d 91       	ld	r24, X+
    3ad6:	9c 91       	ld	r25, X
    3ad8:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    3adc:	00 e0       	ldi	r16, 0x00	; 0
    3ade:	ed c0       	rjmp	.+474    	; 0x3cba <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x226>
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3ae0:	12 36       	cpi	r17, 0x62	; 98
    3ae2:	21 f4       	brne	.+8      	; 0x3aec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3ae4:	8e 81       	ldd	r24, Y+6	; 0x06
    3ae6:	87 3d       	cpi	r24, 0xD7	; 215
    3ae8:	09 f4       	brne	.+2      	; 0x3aec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3aea:	fa c0       	rjmp	.+500    	; 0x3ce0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24c>
    3aec:	bf ef       	ldi	r27, 0xFF	; 255
    3aee:	eb 16       	cp	r14, r27
    3af0:	fb 06       	cpc	r15, r27
    3af2:	09 f0       	breq	.+2      	; 0x3af6 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x62>
    3af4:	e1 c0       	rjmp	.+450    	; 0x3cb8 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x224>
    3af6:	dc c0       	rjmp	.+440    	; 0x3cb0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
	}
	
	if (status == 0)
	{
		//once we have found a valid message, get the message ID
		byte msgType = 0;
    3af8:	1d 82       	std	Y+5, r1	; 0x05
		
		status = serialDriver->receive(msgType);
    3afa:	f6 01       	movw	r30, r12
    3afc:	80 81       	ld	r24, Z
    3afe:	91 81       	ldd	r25, Z+1	; 0x01
    3b00:	dc 01       	movw	r26, r24
    3b02:	ed 91       	ld	r30, X+
    3b04:	fc 91       	ld	r31, X
    3b06:	02 88       	ldd	r0, Z+18	; 0x12
    3b08:	f3 89       	ldd	r31, Z+19	; 0x13
    3b0a:	e0 2d       	mov	r30, r0
    3b0c:	be 01       	movw	r22, r28
    3b0e:	6b 5f       	subi	r22, 0xFB	; 251
    3b10:	7f 4f       	sbci	r23, 0xFF	; 255
    3b12:	19 95       	eicall
    3b14:	7c 01       	movw	r14, r24
		
		if (status == 0)
    3b16:	00 97       	sbiw	r24, 0x00	; 0
    3b18:	09 f0       	breq	.+2      	; 0x3b1c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x88>
    3b1a:	ca c0       	rjmp	.+404    	; 0x3cb0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
		{
			int msgSize = 0;
			
			switch(msgType)
    3b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b1e:	84 30       	cpi	r24, 0x04	; 4
    3b20:	09 f4       	brne	.+2      	; 0x3b24 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x90>
    3b22:	e3 c0       	rjmp	.+454    	; 0x3cea <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x256>
    3b24:	20 f4       	brcc	.+8      	; 0x3b2e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x9a>
    3b26:	82 30       	cpi	r24, 0x02	; 2
    3b28:	09 f0       	breq	.+2      	; 0x3b2c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x98>
    3b2a:	b9 c0       	rjmp	.+370    	; 0x3c9e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x20a>
    3b2c:	0c c0       	rjmp	.+24     	; 0x3b46 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xb2>
    3b2e:	86 30       	cpi	r24, 0x06	; 6
    3b30:	09 f4       	brne	.+2      	; 0x3b34 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xa0>
    3b32:	e1 c0       	rjmp	.+450    	; 0x3cf6 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x262>
    3b34:	87 30       	cpi	r24, 0x07	; 7
    3b36:	09 f0       	breq	.+2      	; 0x3b3a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xa6>
    3b38:	b2 c0       	rjmp	.+356    	; 0x3c9e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x20a>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
					break;
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
    3b3a:	0f 2e       	mov	r0, r31
    3b3c:	f1 e6       	ldi	r31, 0x61	; 97
    3b3e:	6f 2e       	mov	r6, r31
    3b40:	71 2c       	mov	r7, r1
    3b42:	f0 2d       	mov	r31, r0
					break;					
    3b44:	06 c0       	rjmp	.+12     	; 0x3b52 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
			int msgSize = 0;
			
			switch(msgType)
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
    3b46:	0f 2e       	mov	r0, r31
    3b48:	fd e2       	ldi	r31, 0x2D	; 45
    3b4a:	6f 2e       	mov	r6, r31
    3b4c:	77 24       	eor	r7, r7
    3b4e:	73 94       	inc	r7
    3b50:	f0 2d       	mov	r31, r0
    3b52:	bd b7       	in	r27, 0x3d	; 61
    3b54:	bf 83       	std	Y+7, r27	; 0x07
    3b56:	ee b7       	in	r30, 0x3e	; 62
    3b58:	e8 87       	std	Y+8, r30	; 0x08
					break;
			}
			
			if (status == 0)
			{
				byte messagePayload[msgSize];
    3b5a:	2d b7       	in	r18, 0x3d	; 61
    3b5c:	3e b7       	in	r19, 0x3e	; 62
    3b5e:	26 19       	sub	r18, r6
    3b60:	37 09       	sbc	r19, r7
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	3e bf       	out	0x3e, r19	; 62
    3b68:	0f be       	out	0x3f, r0	; 63
    3b6a:	2d bf       	out	0x3d, r18	; 61
    3b6c:	2d b6       	in	r2, 0x3d	; 61
    3b6e:	3e b6       	in	r3, 0x3e	; 62
    3b70:	a1 e0       	ldi	r26, 0x01	; 1
    3b72:	b0 e0       	ldi	r27, 0x00	; 0
    3b74:	2a 0e       	add	r2, r26
    3b76:	3b 1e       	adc	r3, r27
    3b78:	21 01       	movw	r4, r2
							
				messagePayload[0] = msgType;
    3b7a:	ed b7       	in	r30, 0x3d	; 61
    3b7c:	fe b7       	in	r31, 0x3e	; 62
    3b7e:	81 83       	std	Z+1, r24	; 0x01
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    3b80:	01 e0       	ldi	r16, 0x01	; 1
    3b82:	10 e0       	ldi	r17, 0x00	; 0
    3b84:	06 15       	cp	r16, r6
    3b86:	17 05       	cpc	r17, r7
    3b88:	0c f0       	brlt	.+2      	; 0x3b8c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xf8>
    3b8a:	bb c0       	rjmp	.+374    	; 0x3d02 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x26e>
    3b8c:	e1 14       	cp	r14, r1
    3b8e:	f1 04       	cpc	r15, r1
    3b90:	09 f4       	brne	.+2      	; 0x3b94 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x100>
    3b92:	bb c0       	rjmp	.+374    	; 0x3d0a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x276>
    3b94:	7a c0       	rjmp	.+244    	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
				}
							
				if (status == 0)
				{
					//Read the two checksum bytes
					byte messageChecksumA = 0;
    3b96:	1c 82       	std	Y+4, r1	; 0x04
					byte messageChecksumB = 0;
    3b98:	1b 82       	std	Y+3, r1	; 0x03
					byte calculatedChecksumA = 0;
    3b9a:	1a 82       	std	Y+2, r1	; 0x02
					byte calculatedChecksumB = 0;
    3b9c:	19 82       	std	Y+1, r1	; 0x01
								
					status = serialDriver->receive(messageChecksumA);
    3b9e:	d6 01       	movw	r26, r12
    3ba0:	8d 91       	ld	r24, X+
    3ba2:	9c 91       	ld	r25, X
    3ba4:	dc 01       	movw	r26, r24
    3ba6:	ed 91       	ld	r30, X+
    3ba8:	fc 91       	ld	r31, X
    3baa:	02 88       	ldd	r0, Z+18	; 0x12
    3bac:	f3 89       	ldd	r31, Z+19	; 0x13
    3bae:	e0 2d       	mov	r30, r0
    3bb0:	be 01       	movw	r22, r28
    3bb2:	6c 5f       	subi	r22, 0xFC	; 252
    3bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    3bb6:	19 95       	eicall
    3bb8:	7c 01       	movw	r14, r24
					
					if (status == 0)
    3bba:	00 97       	sbiw	r24, 0x00	; 0
    3bbc:	09 f0       	breq	.+2      	; 0x3bc0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x12c>
    3bbe:	65 c0       	rjmp	.+202    	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
					{
						status = serialDriver->receive(messageChecksumB);
    3bc0:	f6 01       	movw	r30, r12
    3bc2:	80 81       	ld	r24, Z
    3bc4:	91 81       	ldd	r25, Z+1	; 0x01
    3bc6:	dc 01       	movw	r26, r24
    3bc8:	ed 91       	ld	r30, X+
    3bca:	fc 91       	ld	r31, X
    3bcc:	02 88       	ldd	r0, Z+18	; 0x12
    3bce:	f3 89       	ldd	r31, Z+19	; 0x13
    3bd0:	e0 2d       	mov	r30, r0
    3bd2:	be 01       	movw	r22, r28
    3bd4:	6d 5f       	subi	r22, 0xFD	; 253
    3bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3bd8:	19 95       	eicall
    3bda:	7c 01       	movw	r14, r24
						
						if (status == 0)
    3bdc:	00 97       	sbiw	r24, 0x00	; 0
    3bde:	09 f0       	breq	.+2      	; 0x3be2 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x14e>
    3be0:	54 c0       	rjmp	.+168    	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
						{
							//Generate checksum for the message
							calculateChecksum(messagePayload, msgSize, calculatedChecksumA, calculatedChecksumB);
    3be2:	8e 01       	movw	r16, r28
    3be4:	0f 5f       	subi	r16, 0xFF	; 255
    3be6:	1f 4f       	sbci	r17, 0xFF	; 255
    3be8:	9e 01       	movw	r18, r28
    3bea:	2e 5f       	subi	r18, 0xFE	; 254
    3bec:	3f 4f       	sbci	r19, 0xFF	; 255
    3bee:	a3 01       	movw	r20, r6
    3bf0:	62 2d       	mov	r22, r2
    3bf2:	73 2d       	mov	r23, r3
    3bf4:	c6 01       	movw	r24, r12
    3bf6:	0e 94 4c 1c 	call	0x3898	; 0x3898 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
						
							//verify that the checksum is correct
							if (calculatedChecksumA == messageChecksumA && calculatedChecksumB == messageChecksumB)
    3bfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3bfc:	8c 81       	ldd	r24, Y+4	; 0x04
    3bfe:	98 13       	cpse	r25, r24
    3c00:	30 c0       	rjmp	.+96     	; 0x3c62 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ce>
    3c02:	99 81       	ldd	r25, Y+1	; 0x01
    3c04:	8b 81       	ldd	r24, Y+3	; 0x03
    3c06:	98 13       	cpse	r25, r24
    3c08:	33 c0       	rjmp	.+102    	; 0x3c70 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1dc>
							{
								//build the message
								switch(msgType)
    3c0a:	8d 81       	ldd	r24, Y+5	; 0x05
    3c0c:	84 30       	cpi	r24, 0x04	; 4
    3c0e:	89 f0       	breq	.+34     	; 0x3c32 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x19e>
    3c10:	18 f4       	brcc	.+6      	; 0x3c18 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x184>
    3c12:	82 30       	cpi	r24, 0x02	; 2
    3c14:	a1 f5       	brne	.+104    	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ea>
    3c16:	05 c0       	rjmp	.+10     	; 0x3c22 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x18e>
    3c18:	86 30       	cpi	r24, 0x06	; 6
    3c1a:	99 f0       	breq	.+38     	; 0x3c42 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ae>
    3c1c:	87 30       	cpi	r24, 0x07	; 7
    3c1e:	79 f5       	brne	.+94     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ea>
    3c20:	18 c0       	rjmp	.+48     	; 0x3c52 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1be>
								{
									case SystemTelemetryMessage::MessageType:
									receivedMessage = SystemTelemetryMessage::buildMessageSt(messagePayload);
    3c22:	82 2d       	mov	r24, r2
    3c24:	93 2d       	mov	r25, r3
    3c26:	0e 94 21 35 	call	0x6a42	; 0x6a42 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>
    3c2a:	f4 01       	movw	r30, r8
    3c2c:	91 83       	std	Z+1, r25	; 0x01
    3c2e:	80 83       	st	Z, r24
									break;
    3c30:	2c c0       	rjmp	.+88     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case SensorDataMessage::MessageType:
									receivedMessage = SensorDataMessage::buildMessageSt(messagePayload);
    3c32:	82 2d       	mov	r24, r2
    3c34:	93 2d       	mov	r25, r3
    3c36:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>
    3c3a:	d4 01       	movw	r26, r8
    3c3c:	8d 93       	st	X+, r24
    3c3e:	9c 93       	st	X, r25
									break;
    3c40:	24 c0       	rjmp	.+72     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case SimpleTelemetryMessage::MessageType:
									receivedMessage = SimpleTelemetryMessage::buildMessageSt(messagePayload);
    3c42:	82 2d       	mov	r24, r2
    3c44:	93 2d       	mov	r25, r3
    3c46:	0e 94 79 2b 	call	0x56f2	; 0x56f2 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>
    3c4a:	f4 01       	movw	r30, r8
    3c4c:	91 83       	std	Z+1, r25	; 0x01
    3c4e:	80 83       	st	Z, r24
									break;
    3c50:	1c c0       	rjmp	.+56     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
    3c52:	82 2d       	mov	r24, r2
    3c54:	93 2d       	mov	r25, r3
    3c56:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>
    3c5a:	d4 01       	movw	r26, r8
    3c5c:	8d 93       	st	X+, r24
    3c5e:	9c 93       	st	X, r25
									break;
    3c60:	14 c0       	rjmp	.+40     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									break;
								}
							}else
							{
								//checksum mismatch
								status = -4;
    3c62:	0f 2e       	mov	r0, r31
    3c64:	fc ef       	ldi	r31, 0xFC	; 252
    3c66:	ef 2e       	mov	r14, r31
    3c68:	ff 24       	eor	r15, r15
    3c6a:	fa 94       	dec	r15
    3c6c:	f0 2d       	mov	r31, r0
    3c6e:	0d c0       	rjmp	.+26     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
    3c70:	0f 2e       	mov	r0, r31
    3c72:	fc ef       	ldi	r31, 0xFC	; 252
    3c74:	ef 2e       	mov	r14, r31
    3c76:	ff 24       	eor	r15, r15
    3c78:	fa 94       	dec	r15
    3c7a:	f0 2d       	mov	r31, r0
    3c7c:	06 c0       	rjmp	.+12     	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
									break;
									default:
									//unrecognized message type.
									status = -3;
    3c7e:	0f 2e       	mov	r0, r31
    3c80:	fd ef       	ldi	r31, 0xFD	; 253
    3c82:	ef 2e       	mov	r14, r31
    3c84:	ff 24       	eor	r15, r15
    3c86:	fa 94       	dec	r15
    3c88:	f0 2d       	mov	r31, r0
    3c8a:	3f 81       	ldd	r19, Y+7	; 0x07
    3c8c:	28 85       	ldd	r18, Y+8	; 0x08
    3c8e:	83 2f       	mov	r24, r19
    3c90:	92 2f       	mov	r25, r18
    3c92:	0f b6       	in	r0, 0x3f	; 63
    3c94:	f8 94       	cli
    3c96:	9e bf       	out	0x3e, r25	; 62
    3c98:	0f be       	out	0x3f, r0	; 63
    3c9a:	8d bf       	out	0x3d, r24	; 61
    3c9c:	06 c0       	rjmp	.+12     	; 0x3caa <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x216>
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
					break;					
				default:
					//unrecognized message type.
					status = -3;
    3c9e:	0f 2e       	mov	r0, r31
    3ca0:	fd ef       	ldi	r31, 0xFD	; 253
    3ca2:	ef 2e       	mov	r14, r31
    3ca4:	ff 24       	eor	r15, r15
    3ca6:	fa 94       	dec	r15
    3ca8:	f0 2d       	mov	r31, r0
				}
			}
		}
	}
	
	if (status != 0)
    3caa:	e1 14       	cp	r14, r1
    3cac:	f1 04       	cpc	r15, r1
    3cae:	f1 f1       	breq	.+124    	; 0x3d2c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x298>
	{
		receivedMessage = NULL;
    3cb0:	f4 01       	movw	r30, r8
    3cb2:	11 82       	std	Z+1, r1	; 0x01
    3cb4:	10 82       	st	Z, r1
    3cb6:	3a c0       	rjmp	.+116    	; 0x3d2c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x298>
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3cb8:	01 2f       	mov	r16, r17
	{
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
    3cba:	1e 81       	ldd	r17, Y+6	; 0x06
		status = serialDriver->receive(thirdSyncByte);
    3cbc:	f6 01       	movw	r30, r12
    3cbe:	80 81       	ld	r24, Z
    3cc0:	91 81       	ldd	r25, Z+1	; 0x01
    3cc2:	dc 01       	movw	r26, r24
    3cc4:	ed 91       	ld	r30, X+
    3cc6:	fc 91       	ld	r31, X
    3cc8:	02 88       	ldd	r0, Z+18	; 0x12
    3cca:	f3 89       	ldd	r31, Z+19	; 0x13
    3ccc:	e0 2d       	mov	r30, r0
    3cce:	be 01       	movw	r22, r28
    3cd0:	6a 5f       	subi	r22, 0xFA	; 250
    3cd2:	7f 4f       	sbci	r23, 0xFF	; 255
    3cd4:	19 95       	eicall
    3cd6:	7c 01       	movw	r14, r24
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3cd8:	05 3b       	cpi	r16, 0xB5	; 181
    3cda:	09 f0       	breq	.+2      	; 0x3cde <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24a>
    3cdc:	07 cf       	rjmp	.-498    	; 0x3aec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3cde:	00 cf       	rjmp	.-512    	; 0x3ae0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x4c>
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
		status = serialDriver->receive(thirdSyncByte);
	}
	
	if (status == 0)
    3ce0:	e1 14       	cp	r14, r1
    3ce2:	f1 04       	cpc	r15, r1
    3ce4:	09 f4       	brne	.+2      	; 0x3ce8 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x254>
    3ce6:	08 cf       	rjmp	.-496    	; 0x3af8 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x64>
    3ce8:	e3 cf       	rjmp	.-58     	; 0x3cb0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
					break;
				case SensorDataMessage::MessageType:
					msgSize = SensorDataMessage::MessageSize;
    3cea:	0f 2e       	mov	r0, r31
    3cec:	f1 e4       	ldi	r31, 0x41	; 65
    3cee:	6f 2e       	mov	r6, r31
    3cf0:	71 2c       	mov	r7, r1
    3cf2:	f0 2d       	mov	r31, r0
    3cf4:	2e cf       	rjmp	.-420    	; 0x3b52 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
    3cf6:	0f 2e       	mov	r0, r31
    3cf8:	f9 e7       	ldi	r31, 0x79	; 121
    3cfa:	6f 2e       	mov	r6, r31
    3cfc:	71 2c       	mov	r7, r1
    3cfe:	f0 2d       	mov	r31, r0
    3d00:	28 cf       	rjmp	.-432    	; 0x3b52 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
				for (int i = 1; i < msgSize && status == 0; i++)
				{
					status = serialDriver->receive(messagePayload[i]);
				}
							
				if (status == 0)
    3d02:	e1 14       	cp	r14, r1
    3d04:	f1 04       	cpc	r15, r1
    3d06:	09 f6       	brne	.-126    	; 0x3c8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
    3d08:	46 cf       	rjmp	.-372    	; 0x3b96 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x102>
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
				{
					status = serialDriver->receive(messagePayload[i]);
    3d0a:	f6 01       	movw	r30, r12
    3d0c:	80 81       	ld	r24, Z
    3d0e:	91 81       	ldd	r25, Z+1	; 0x01
    3d10:	dc 01       	movw	r26, r24
    3d12:	ed 91       	ld	r30, X+
    3d14:	fc 91       	ld	r31, X
    3d16:	b2 01       	movw	r22, r4
    3d18:	60 0f       	add	r22, r16
    3d1a:	71 1f       	adc	r23, r17
    3d1c:	02 88       	ldd	r0, Z+18	; 0x12
    3d1e:	f3 89       	ldd	r31, Z+19	; 0x13
    3d20:	e0 2d       	mov	r30, r0
    3d22:	19 95       	eicall
    3d24:	7c 01       	movw	r14, r24
							
				messagePayload[0] = msgType;
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    3d26:	0f 5f       	subi	r16, 0xFF	; 255
    3d28:	1f 4f       	sbci	r17, 0xFF	; 255
    3d2a:	2c cf       	rjmp	.-424    	; 0x3b84 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xf0>
	if (status != 0)
	{
		receivedMessage = NULL;
	}
	
	serialDriver->stopTimer();
    3d2c:	d6 01       	movw	r26, r12
    3d2e:	8d 91       	ld	r24, X+
    3d30:	9c 91       	ld	r25, X
    3d32:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
    3d36:	8e 2d       	mov	r24, r14
    3d38:	9f 2d       	mov	r25, r15
    3d3a:	0f b6       	in	r0, 0x3f	; 63
    3d3c:	f8 94       	cli
    3d3e:	be be       	out	0x3e, r11	; 62
    3d40:	0f be       	out	0x3f, r0	; 63
    3d42:	ad be       	out	0x3d, r10	; 61
    3d44:	28 96       	adiw	r28, 0x08	; 8
    3d46:	0f b6       	in	r0, 0x3f	; 63
    3d48:	f8 94       	cli
    3d4a:	de bf       	out	0x3e, r29	; 62
    3d4c:	0f be       	out	0x3f, r0	; 63
    3d4e:	cd bf       	out	0x3d, r28	; 61
    3d50:	df 91       	pop	r29
    3d52:	cf 91       	pop	r28
    3d54:	1f 91       	pop	r17
    3d56:	0f 91       	pop	r16
    3d58:	ff 90       	pop	r15
    3d5a:	ef 90       	pop	r14
    3d5c:	df 90       	pop	r13
    3d5e:	cf 90       	pop	r12
    3d60:	bf 90       	pop	r11
    3d62:	af 90       	pop	r10
    3d64:	9f 90       	pop	r9
    3d66:	8f 90       	pop	r8
    3d68:	7f 90       	pop	r7
    3d6a:	6f 90       	pop	r6
    3d6c:	5f 90       	pop	r5
    3d6e:	4f 90       	pop	r4
    3d70:	3f 90       	pop	r3
    3d72:	2f 90       	pop	r2
    3d74:	08 95       	ret

00003d76 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>:
const float RadioControllerInterface::SWASHOFFSETELEVATORMULTIPLYER = 2.0f;
const float RadioControllerInterface::SWASHOFFSETELEVATORELEVATORMULTIPLYER = 4.0f;
const float RadioControllerInterface::SWASHOFFSETSAILERONMULTIPLIER = 3.37209302325581;

float RadioControllerInterface::calculatePWMCompareMatchFromControlValue(float controlValue)
{
    3d76:	cf 92       	push	r12
    3d78:	df 92       	push	r13
    3d7a:	ef 92       	push	r14
    3d7c:	ff 92       	push	r15
    3d7e:	0f 93       	push	r16
    3d80:	1f 93       	push	r17
    3d82:	cf 93       	push	r28
    3d84:	df 93       	push	r29
    3d86:	cb 01       	movw	r24, r22
    3d88:	ba 01       	movw	r22, r20
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
    3d8a:	20 e0       	ldi	r18, 0x00	; 0
    3d8c:	30 e0       	ldi	r19, 0x00	; 0
    3d8e:	40 e8       	ldi	r20, 0x80	; 128
    3d90:	5f e3       	ldi	r21, 0x3F	; 63
    3d92:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    3d96:	20 e0       	ldi	r18, 0x00	; 0
    3d98:	30 e0       	ldi	r19, 0x00	; 0
    3d9a:	4a ef       	ldi	r20, 0xFA	; 250
    3d9c:	53 ec       	ldi	r21, 0xC3	; 195
    3d9e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    3da2:	20 e0       	ldi	r18, 0x00	; 0
    3da4:	30 e7       	ldi	r19, 0x70	; 112
    3da6:	44 e9       	ldi	r20, 0x94	; 148
    3da8:	56 e4       	ldi	r21, 0x46	; 70
    3daa:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    3dae:	06 2f       	mov	r16, r22
    3db0:	17 2f       	mov	r17, r23
    3db2:	d8 2f       	mov	r29, r24
    3db4:	c9 2f       	mov	r28, r25
    3db6:	c6 2e       	mov	r12, r22
    3db8:	d7 2e       	mov	r13, r23
    3dba:	e8 2e       	mov	r14, r24
    3dbc:	f9 2e       	mov	r15, r25
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
    3dbe:	20 e0       	ldi	r18, 0x00	; 0
    3dc0:	30 e7       	ldi	r19, 0x70	; 112
    3dc2:	44 e9       	ldi	r20, 0x94	; 148
    3dc4:	56 e4       	ldi	r21, 0x46	; 70
    3dc6:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    3dca:	18 16       	cp	r1, r24
    3dcc:	6c f0       	brlt	.+26     	; 0x3de8 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0x72>
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
    3dce:	20 e0       	ldi	r18, 0x00	; 0
    3dd0:	30 ea       	ldi	r19, 0xA0	; 160
    3dd2:	4c e8       	ldi	r20, 0x8C	; 140
    3dd4:	56 e4       	ldi	r21, 0x46	; 70
    3dd6:	60 2f       	mov	r22, r16
    3dd8:	71 2f       	mov	r23, r17
    3dda:	8d 2f       	mov	r24, r29
    3ddc:	9c 2f       	mov	r25, r28
    3dde:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    3de2:	88 23       	and	r24, r24
    3de4:	7c f0       	brlt	.+30     	; 0x3e04 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0x8e>
    3de6:	1b c0       	rjmp	.+54     	; 0x3e1e <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0xa8>
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
    3de8:	c1 2c       	mov	r12, r1
    3dea:	0f 2e       	mov	r0, r31
    3dec:	f0 e7       	ldi	r31, 0x70	; 112
    3dee:	df 2e       	mov	r13, r31
    3df0:	f0 2d       	mov	r31, r0
    3df2:	0f 2e       	mov	r0, r31
    3df4:	f4 e9       	ldi	r31, 0x94	; 148
    3df6:	ef 2e       	mov	r14, r31
    3df8:	f0 2d       	mov	r31, r0
    3dfa:	0f 2e       	mov	r0, r31
    3dfc:	f6 e4       	ldi	r31, 0x46	; 70
    3dfe:	ff 2e       	mov	r15, r31
    3e00:	f0 2d       	mov	r31, r0
    3e02:	0d c0       	rjmp	.+26     	; 0x3e1e <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0xa8>
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MAX_TICKS;
    3e04:	c1 2c       	mov	r12, r1
    3e06:	0f 2e       	mov	r0, r31
    3e08:	f0 ea       	ldi	r31, 0xA0	; 160
    3e0a:	df 2e       	mov	r13, r31
    3e0c:	f0 2d       	mov	r31, r0
    3e0e:	0f 2e       	mov	r0, r31
    3e10:	fc e8       	ldi	r31, 0x8C	; 140
    3e12:	ef 2e       	mov	r14, r31
    3e14:	f0 2d       	mov	r31, r0
    3e16:	0f 2e       	mov	r0, r31
    3e18:	f6 e4       	ldi	r31, 0x46	; 70
    3e1a:	ff 2e       	mov	r15, r31
    3e1c:	f0 2d       	mov	r31, r0
	}
	
	return scaledValue;	
	
}
    3e1e:	6c 2d       	mov	r22, r12
    3e20:	7d 2d       	mov	r23, r13
    3e22:	8e 2d       	mov	r24, r14
    3e24:	9f 2d       	mov	r25, r15
    3e26:	df 91       	pop	r29
    3e28:	cf 91       	pop	r28
    3e2a:	1f 91       	pop	r17
    3e2c:	0f 91       	pop	r16
    3e2e:	ff 90       	pop	r15
    3e30:	ef 90       	pop	r14
    3e32:	df 90       	pop	r13
    3e34:	cf 90       	pop	r12
    3e36:	08 95       	ret

00003e38 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>:

/**
 * Equation for scaling values new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
 */
float RadioControllerInterface::ScaleValue(long servoChannelPulseWidth) 
{
    3e38:	cf 92       	push	r12
    3e3a:	df 92       	push	r13
    3e3c:	ef 92       	push	r14
    3e3e:	ff 92       	push	r15
    3e40:	0f 93       	push	r16
    3e42:	1f 93       	push	r17
    3e44:	cf 93       	push	r28
    3e46:	df 93       	push	r29
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
    3e48:	cb 01       	movw	r24, r22
    3e4a:	ba 01       	movw	r22, r20
    3e4c:	60 5d       	subi	r22, 0xD0	; 208
    3e4e:	77 40       	sbci	r23, 0x07	; 7
    3e50:	81 09       	sbc	r24, r1
    3e52:	91 09       	sbc	r25, r1
    3e54:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    3e58:	2f e6       	ldi	r18, 0x6F	; 111
    3e5a:	32 e1       	ldi	r19, 0x12	; 18
    3e5c:	43 e8       	ldi	r20, 0x83	; 131
    3e5e:	5a e3       	ldi	r21, 0x3A	; 58
    3e60:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    3e64:	20 e0       	ldi	r18, 0x00	; 0
    3e66:	30 e0       	ldi	r19, 0x00	; 0
    3e68:	40 e8       	ldi	r20, 0x80	; 128
    3e6a:	5f e3       	ldi	r21, 0x3F	; 63
    3e6c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    3e70:	06 2f       	mov	r16, r22
    3e72:	17 2f       	mov	r17, r23
    3e74:	d8 2f       	mov	r29, r24
    3e76:	c9 2f       	mov	r28, r25
    3e78:	c6 2e       	mov	r12, r22
    3e7a:	d7 2e       	mov	r13, r23
    3e7c:	e8 2e       	mov	r14, r24
    3e7e:	f9 2e       	mov	r15, r25
			
	if (scaledValue > 1.0f)
    3e80:	20 e0       	ldi	r18, 0x00	; 0
    3e82:	30 e0       	ldi	r19, 0x00	; 0
    3e84:	40 e8       	ldi	r20, 0x80	; 128
    3e86:	5f e3       	ldi	r21, 0x3F	; 63
    3e88:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    3e8c:	18 16       	cp	r1, r24
    3e8e:	6c f0       	brlt	.+26     	; 0x3eaa <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x72>
	{
		scaledValue = 1.0f;
	}else if (scaledValue < -1.0f)
    3e90:	20 e0       	ldi	r18, 0x00	; 0
    3e92:	30 e0       	ldi	r19, 0x00	; 0
    3e94:	40 e8       	ldi	r20, 0x80	; 128
    3e96:	5f eb       	ldi	r21, 0xBF	; 191
    3e98:	60 2f       	mov	r22, r16
    3e9a:	71 2f       	mov	r23, r17
    3e9c:	8d 2f       	mov	r24, r29
    3e9e:	9c 2f       	mov	r25, r28
    3ea0:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    3ea4:	88 23       	and	r24, r24
    3ea6:	a4 f4       	brge	.+40     	; 0x3ed0 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x98>
    3ea8:	0a c0       	rjmp	.+20     	; 0x3ebe <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x86>
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
			
	if (scaledValue > 1.0f)
	{
		scaledValue = 1.0f;
    3eaa:	c1 2c       	mov	r12, r1
    3eac:	d1 2c       	mov	r13, r1
    3eae:	68 94       	set
    3eb0:	ee 24       	eor	r14, r14
    3eb2:	e7 f8       	bld	r14, 7
    3eb4:	0f 2e       	mov	r0, r31
    3eb6:	ff e3       	ldi	r31, 0x3F	; 63
    3eb8:	ff 2e       	mov	r15, r31
    3eba:	f0 2d       	mov	r31, r0
    3ebc:	09 c0       	rjmp	.+18     	; 0x3ed0 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x98>
	}else if (scaledValue < -1.0f)
	{
		scaledValue = -1.0f;
    3ebe:	c1 2c       	mov	r12, r1
    3ec0:	d1 2c       	mov	r13, r1
    3ec2:	68 94       	set
    3ec4:	ee 24       	eor	r14, r14
    3ec6:	e7 f8       	bld	r14, 7
    3ec8:	0f 2e       	mov	r0, r31
    3eca:	ff eb       	ldi	r31, 0xBF	; 191
    3ecc:	ff 2e       	mov	r15, r31
    3ece:	f0 2d       	mov	r31, r0
	}
	
	return scaledValue;
}
    3ed0:	6c 2d       	mov	r22, r12
    3ed2:	7d 2d       	mov	r23, r13
    3ed4:	8e 2d       	mov	r24, r14
    3ed6:	9f 2d       	mov	r25, r15
    3ed8:	df 91       	pop	r29
    3eda:	cf 91       	pop	r28
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	08 95       	ret

00003eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>:

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
    3eea:	0f 93       	push	r16
    3eec:	1f 93       	push	r17
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3eee:	80 e4       	ldi	r24, 0x40	; 64
    3ef0:	9c e9       	ldi	r25, 0x9C	; 156
    3ef2:	a0 e0       	ldi	r26, 0x00	; 0
    3ef4:	b0 e0       	ldi	r27, 0x00	; 0
    3ef6:	8c 01       	movw	r16, r24
    3ef8:	9d 01       	movw	r18, r26
    3efa:	04 1b       	sub	r16, r20
    3efc:	15 0b       	sbc	r17, r21
    3efe:	26 0b       	sbc	r18, r22
    3f00:	37 0b       	sbc	r19, r23
    3f02:	c9 01       	movw	r24, r18
    3f04:	b8 01       	movw	r22, r16
    3f06:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    3f0a:	20 e0       	ldi	r18, 0x00	; 0
    3f0c:	30 e0       	ldi	r19, 0x00	; 0
    3f0e:	40 e0       	ldi	r20, 0x00	; 0
    3f10:	5f e3       	ldi	r21, 0x3F	; 63
    3f12:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
}
    3f16:	1f 91       	pop	r17
    3f18:	0f 91       	pop	r16
    3f1a:	08 95       	ret

00003f1c <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>:



RadioControllerInterface* RadioControllerInterface::getRadioControllerInterface()
{
	if (radioControllerInterface == NULL)
    3f1c:	80 91 a2 03 	lds	r24, 0x03A2
    3f20:	90 91 a3 03 	lds	r25, 0x03A3
    3f24:	89 2b       	or	r24, r25
    3f26:	09 f0       	breq	.+2      	; 0x3f2a <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0xe>
    3f28:	57 c0       	rjmp	.+174    	; 0x3fd8 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0xbc>
	{
		radioControllerInterface = new RadioControllerInterface();
    3f2a:	89 e5       	ldi	r24, 0x59	; 89
    3f2c:	90 e0       	ldi	r25, 0x00	; 0
    3f2e:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>


				static RadioControllerInterface *radioControllerInterface;
			
				RadioControllerInterface():
				systemModel (NULL)
    3f32:	fc 01       	movw	r30, r24
    3f34:	e9 5a       	subi	r30, 0xA9	; 169
    3f36:	ff 4f       	sbci	r31, 0xFF	; 255
    3f38:	11 82       	std	Z+1, r1	; 0x01
    3f3a:	10 82       	st	Z, r1
				{
					memset(workingServoChannelPulseWidths, 0, sizeof(workingServoChannelPulseWidths));
    3f3c:	9c 01       	movw	r18, r24
    3f3e:	2f 5f       	subi	r18, 0xFF	; 255
    3f40:	3f 4f       	sbci	r19, 0xFF	; 255
    3f42:	40 e2       	ldi	r20, 0x20	; 32
    3f44:	e2 2f       	mov	r30, r18
    3f46:	f3 2f       	mov	r31, r19
    3f48:	df 01       	movw	r26, r30
    3f4a:	24 2f       	mov	r18, r20
    3f4c:	1d 92       	st	X+, r1
    3f4e:	2a 95       	dec	r18
    3f50:	e9 f7       	brne	.-6      	; 0x3f4c <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x30>
					memset(servoChannelPulseWidths, 0, sizeof(servoChannelPulseWidths));
    3f52:	9c 01       	movw	r18, r24
    3f54:	2f 5d       	subi	r18, 0xDF	; 223
    3f56:	3f 4f       	sbci	r19, 0xFF	; 255
    3f58:	e2 2f       	mov	r30, r18
    3f5a:	f3 2f       	mov	r31, r19
    3f5c:	df 01       	movw	r26, r30
    3f5e:	1d 92       	st	X+, r1
    3f60:	4a 95       	dec	r20
    3f62:	e9 f7       	brne	.-6      	; 0x3f5e <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x42>
					
					previousInputCaptureRegisterValue = 0;
    3f64:	fc 01       	movw	r30, r24
    3f66:	ef 5b       	subi	r30, 0xBF	; 191
    3f68:	ff 4f       	sbci	r31, 0xFF	; 255
    3f6a:	10 82       	st	Z, r1
    3f6c:	11 82       	std	Z+1, r1	; 0x01
    3f6e:	12 82       	std	Z+2, r1	; 0x02
    3f70:	13 82       	std	Z+3, r1	; 0x03
					
					servoChannelIndex = 0;
    3f72:	fc 01       	movw	r30, r24
    3f74:	eb 5b       	subi	r30, 0xBB	; 187
    3f76:	ff 4f       	sbci	r31, 0xFF	; 255
    3f78:	11 82       	std	Z+1, r1	; 0x01
    3f7a:	10 82       	st	Z, r1
					
					channel1Offset = 0;
    3f7c:	fc 01       	movw	r30, r24
    3f7e:	e9 5b       	subi	r30, 0xB9	; 185
    3f80:	ff 4f       	sbci	r31, 0xFF	; 255
    3f82:	11 82       	std	Z+1, r1	; 0x01
    3f84:	10 82       	st	Z, r1
					channel2Offset = 0;
    3f86:	fc 01       	movw	r30, r24
    3f88:	e7 5b       	subi	r30, 0xB7	; 183
    3f8a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f8c:	11 82       	std	Z+1, r1	; 0x01
    3f8e:	10 82       	st	Z, r1
					channel3Offset = 0;
    3f90:	fc 01       	movw	r30, r24
    3f92:	e5 5b       	subi	r30, 0xB5	; 181
    3f94:	ff 4f       	sbci	r31, 0xFF	; 255
    3f96:	11 82       	std	Z+1, r1	; 0x01
    3f98:	10 82       	st	Z, r1
					channel4Offset = 0;
    3f9a:	fc 01       	movw	r30, r24
    3f9c:	e3 5b       	subi	r30, 0xB3	; 179
    3f9e:	ff 4f       	sbci	r31, 0xFF	; 255
    3fa0:	11 82       	std	Z+1, r1	; 0x01
    3fa2:	10 82       	st	Z, r1
					channel5Offset = 0;
    3fa4:	fc 01       	movw	r30, r24
    3fa6:	e1 5b       	subi	r30, 0xB1	; 177
    3fa8:	ff 4f       	sbci	r31, 0xFF	; 255
    3faa:	11 82       	std	Z+1, r1	; 0x01
    3fac:	10 82       	st	Z, r1
					channel6Offset = 0;
    3fae:	fc 01       	movw	r30, r24
    3fb0:	ef 5a       	subi	r30, 0xAF	; 175
    3fb2:	ff 4f       	sbci	r31, 0xFF	; 255
    3fb4:	11 82       	std	Z+1, r1	; 0x01
    3fb6:	10 82       	st	Z, r1
					channel7Offset = 0;
    3fb8:	fc 01       	movw	r30, r24
    3fba:	ed 5a       	subi	r30, 0xAD	; 173
    3fbc:	ff 4f       	sbci	r31, 0xFF	; 255
    3fbe:	11 82       	std	Z+1, r1	; 0x01
    3fc0:	10 82       	st	Z, r1
					channel8Offset = 0;		
    3fc2:	fc 01       	movw	r30, r24
    3fc4:	eb 5a       	subi	r30, 0xAB	; 171
    3fc6:	ff 4f       	sbci	r31, 0xFF	; 255
    3fc8:	11 82       	std	Z+1, r1	; 0x01
    3fca:	10 82       	st	Z, r1
					
					ARRAYLOCK = false;		
    3fcc:	fc 01       	movw	r30, r24
    3fce:	10 82       	st	Z, r1
    3fd0:	90 93 a3 03 	sts	0x03A3, r25
    3fd4:	80 93 a2 03 	sts	0x03A2, r24
	}

	return radioControllerInterface;
}
    3fd8:	80 91 a2 03 	lds	r24, 0x03A2
    3fdc:	90 91 a3 03 	lds	r25, 0x03A3
    3fe0:	08 95       	ret

00003fe2 <__vector_46>:
/**
 * Interrupt service routine which is called when a PPM signal's rising edge is detected
 * on the PL1 pin.
 */
ISR(TIMER5_CAPT_vect)
{
    3fe2:	1f 92       	push	r1
    3fe4:	0f 92       	push	r0
    3fe6:	0f b6       	in	r0, 0x3f	; 63
    3fe8:	0f 92       	push	r0
    3fea:	11 24       	eor	r1, r1
    3fec:	0b b6       	in	r0, 0x3b	; 59
    3fee:	0f 92       	push	r0
    3ff0:	cf 92       	push	r12
    3ff2:	df 92       	push	r13
    3ff4:	ef 92       	push	r14
    3ff6:	ff 92       	push	r15
    3ff8:	0f 93       	push	r16
    3ffa:	1f 93       	push	r17
    3ffc:	2f 93       	push	r18
    3ffe:	3f 93       	push	r19
    4000:	4f 93       	push	r20
    4002:	5f 93       	push	r21
    4004:	6f 93       	push	r22
    4006:	7f 93       	push	r23
    4008:	8f 93       	push	r24
    400a:	9f 93       	push	r25
    400c:	af 93       	push	r26
    400e:	bf 93       	push	r27
    4010:	cf 93       	push	r28
    4012:	df 93       	push	r29
    4014:	ef 93       	push	r30
    4016:	ff 93       	push	r31
	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    4018:	0e 94 8e 1f 	call	0x3f1c	; 0x3f1c <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    401c:	ec 01       	movw	r28, r24
	//an interrupt happening inbetween reading the two bytes. 
	//cli(); //not necessary because intterupts are already disabled within an ISR.
	
	//The Input Capture Register is set to the value of the timer when the
	//input signal was received.
	long currentInputCaptureRegisterValue = ICR5;
    401e:	40 91 26 01 	lds	r20, 0x0126
    4022:	50 91 27 01 	lds	r21, 0x0127
    4026:	60 e0       	ldi	r22, 0x00	; 0
    4028:	70 e0       	ldi	r23, 0x00	; 0
				 * the scope of this class, so the handlers need a static reference to
				 * this class.
				 */
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
    402a:	fc 01       	movw	r30, r24
    402c:	ef 5b       	subi	r30, 0xBF	; 191
    402e:	ff 4f       	sbci	r31, 0xFF	; 255
    4030:	00 81       	ld	r16, Z
    4032:	11 81       	ldd	r17, Z+1	; 0x01
    4034:	22 81       	ldd	r18, Z+2	; 0x02
    4036:	33 81       	ldd	r19, Z+3	; 0x03
	
	long previousInputCaptureRegisterValue = rcInterface->PreviousInputCaptureRegisterValue();
	
	//If the current value was less, then the timer has overflowed since the last
	//time we received a pulse
	if (currentInputCaptureRegisterValue < previousInputCaptureRegisterValue)
    4038:	40 17       	cp	r20, r16
    403a:	51 07       	cpc	r21, r17
    403c:	62 07       	cpc	r22, r18
    403e:	73 07       	cpc	r23, r19
    4040:	5c f4       	brge	.+22     	; 0x4058 <__vector_46+0x76>
	{
		servoChannelPulseWidth = (currentInputCaptureRegisterValue + RadioControllerInterface::MAX_PPM_TIMER_VALUE) - previousInputCaptureRegisterValue;
    4042:	db 01       	movw	r26, r22
    4044:	ca 01       	movw	r24, r20
    4046:	80 5c       	subi	r24, 0xC0	; 192
    4048:	93 46       	sbci	r25, 0x63	; 99
    404a:	af 4f       	sbci	r26, 0xFF	; 255
    404c:	bf 4f       	sbci	r27, 0xFF	; 255
    404e:	80 1b       	sub	r24, r16
    4050:	91 0b       	sbc	r25, r17
    4052:	a2 0b       	sbc	r26, r18
    4054:	b3 0b       	sbc	r27, r19
    4056:	06 c0       	rjmp	.+12     	; 0x4064 <__vector_46+0x82>
	}else
	{
		//Calculate the width of the pulse.
		servoChannelPulseWidth = currentInputCaptureRegisterValue - previousInputCaptureRegisterValue;
    4058:	db 01       	movw	r26, r22
    405a:	ca 01       	movw	r24, r20
    405c:	80 1b       	sub	r24, r16
    405e:	91 0b       	sbc	r25, r17
    4060:	a2 0b       	sbc	r26, r18
    4062:	b3 0b       	sbc	r27, r19
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
    4064:	fe 01       	movw	r30, r28
    4066:	ef 5b       	subi	r30, 0xBF	; 191
    4068:	ff 4f       	sbci	r31, 0xFF	; 255
    406a:	40 83       	st	Z, r20
    406c:	51 83       	std	Z+1, r21	; 0x01
    406e:	62 83       	std	Z+2, r22	; 0x02
    4070:	73 83       	std	Z+3, r23	; 0x03
	rcInterface->PreviousInputCaptureRegisterValue(currentInputCaptureRegisterValue);
	
	//Once all the servo channels values have been sent, a sync pulse is sent indicating
	//a restart back to the first channel.
	//Detect if it's a sync pulse and rest as appropriate
	if (servoChannelPulseWidth > RadioControllerInterface::SYNCH_PULSE_WIDTH)
    4072:	81 34       	cpi	r24, 0x41	; 65
    4074:	2f e1       	ldi	r18, 0x1F	; 31
    4076:	92 07       	cpc	r25, r18
    4078:	a1 05       	cpc	r26, r1
    407a:	b1 05       	cpc	r27, r1
    407c:	2c f0       	brlt	.+10     	; 0x4088 <__vector_46+0xa6>
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    407e:	cb 5b       	subi	r28, 0xBB	; 187
    4080:	df 4f       	sbci	r29, 0xFF	; 255
    4082:	19 82       	std	Y+1, r1	; 0x01
    4084:	18 82       	st	Y, r1
    4086:	68 c0       	rjmp	.+208    	; 0x4158 <__vector_46+0x176>
	{
		rcInterface->ServoChannelIndex(0);
	}else
	{
		if (servoChannelPulseWidth < RadioControllerInterface::MAX_USEABLE_PULSE_WIDTH && 
    4088:	ac 01       	movw	r20, r24
    408a:	bd 01       	movw	r22, r26
    408c:	47 5c       	subi	r20, 0xC7	; 199
    408e:	57 40       	sbci	r21, 0x07	; 7
    4090:	61 09       	sbc	r22, r1
    4092:	71 09       	sbc	r23, r1
    4094:	43 3e       	cpi	r20, 0xE3	; 227
    4096:	57 40       	sbci	r21, 0x07	; 7
    4098:	61 05       	cpc	r22, r1
    409a:	71 05       	cpc	r23, r1
    409c:	08 f0       	brcs	.+2      	; 0x40a0 <__vector_46+0xbe>
    409e:	55 c0       	rjmp	.+170    	; 0x414a <__vector_46+0x168>
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
    40a0:	fe 01       	movw	r30, r28
    40a2:	eb 5b       	subi	r30, 0xBB	; 187
    40a4:	ff 4f       	sbci	r31, 0xFF	; 255
    40a6:	20 81       	ld	r18, Z
    40a8:	31 81       	ldd	r19, Z+1	; 0x01
			
			
			
			//since throttle is mechanically bypassed, set throttle to -1 (no throttle) in the array of control values, and 
			//then continue processing the received signal for the next channel (channel 1)
			if (servoChannelIndex == 0)
    40aa:	21 15       	cp	r18, r1
    40ac:	31 05       	cpc	r19, r1
    40ae:	69 f4       	brne	.+26     	; 0x40ca <__vector_46+0xe8>
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    40b0:	40 ed       	ldi	r20, 0xD0	; 208
    40b2:	57 e0       	ldi	r21, 0x07	; 7
    40b4:	60 e0       	ldi	r22, 0x00	; 0
    40b6:	70 e0       	ldi	r23, 0x00	; 0
    40b8:	49 83       	std	Y+1, r20	; 0x01
    40ba:	5a 83       	std	Y+2, r21	; 0x02
    40bc:	6b 83       	std	Y+3, r22	; 0x03
    40be:	7c 83       	std	Y+4, r23	; 0x04
    40c0:	8d 83       	std	Y+5, r24	; 0x05
    40c2:	9e 83       	std	Y+6, r25	; 0x06
    40c4:	af 83       	std	Y+7, r26	; 0x07
    40c6:	b8 87       	std	Y+8, r27	; 0x08
    40c8:	40 c0       	rjmp	.+128    	; 0x414a <__vector_46+0x168>
		
		
		
		
		
			if (servoChannelIndex < RadioControllerInterface::MAX_CHANNELS)
    40ca:	28 30       	cpi	r18, 0x08	; 8
    40cc:	31 05       	cpc	r19, r1
    40ce:	ec f5       	brge	.+122    	; 0x414a <__vector_46+0x168>
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
    40d0:	fe 01       	movw	r30, r28
    40d2:	e9 5a       	subi	r30, 0xA9	; 169
    40d4:	ff 4f       	sbci	r31, 0xFF	; 255
    40d6:	00 81       	ld	r16, Z
    40d8:	11 81       	ldd	r17, Z+1	; 0x01
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    40da:	f9 01       	movw	r30, r18
    40dc:	ee 0f       	add	r30, r30
    40de:	ff 1f       	adc	r31, r31
    40e0:	ee 0f       	add	r30, r30
    40e2:	ff 1f       	adc	r31, r31
    40e4:	ec 0f       	add	r30, r28
    40e6:	fd 1f       	adc	r31, r29
    40e8:	81 83       	std	Z+1, r24	; 0x01
    40ea:	92 83       	std	Z+2, r25	; 0x02
    40ec:	a3 83       	std	Z+3, r26	; 0x03
    40ee:	b4 83       	std	Z+4, r27	; 0x04
				 * servo channel index to reset back to 0, and re-write the
				 * existing servo value. This could cause a servo control value
				 * to get sent to the wrong servo. 
				 */
				//if (servoChannelIndex >= RadioControllerInterface::MIN_RECEIVED_CHANNELS)
				if (servoChannelIndex == RadioControllerInterface::MIN_RECEIVED_CHANNELS)
    40f0:	27 30       	cpi	r18, 0x07	; 7
    40f2:	31 05       	cpc	r19, r1
    40f4:	51 f5       	brne	.+84     	; 0x414a <__vector_46+0x168>
				{
					//Manual mode
					float auxChannelValue = rcInterface->ScaleValue(rcInterface->GetServoChannelPulseWidth(RadioControllerInterface::FLIGHT_MODE_AUX_CHANNEL));
    40f6:	49 8d       	ldd	r20, Y+25	; 0x19
    40f8:	5a 8d       	ldd	r21, Y+26	; 0x1a
    40fa:	6b 8d       	ldd	r22, Y+27	; 0x1b
    40fc:	7c 8d       	ldd	r23, Y+28	; 0x1c
    40fe:	ce 01       	movw	r24, r28
    4100:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>
    4104:	6b 01       	movw	r12, r22
    4106:	7c 01       	movw	r14, r24
					
					if (auxChannelValue
    4108:	23 e3       	ldi	r18, 0x33	; 51
    410a:	33 e3       	ldi	r19, 0x33	; 51
    410c:	43 e3       	ldi	r20, 0x33	; 51
    410e:	5f e3       	ldi	r21, 0x3F	; 63
    4110:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    4114:	18 16       	cp	r1, r24
    4116:	1c f0       	brlt	.+6      	; 0x411e <__vector_46+0x13c>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    4118:	f8 01       	movw	r30, r16
    411a:	12 82       	std	Z+2, r1	; 0x02
    411c:	03 c0       	rjmp	.+6      	; 0x4124 <__vector_46+0x142>
    411e:	81 e0       	ldi	r24, 0x01	; 1
    4120:	f8 01       	movw	r30, r16
    4122:	82 83       	std	Z+2, r24	; 0x02
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}
    4124:	f8 01       	movw	r30, r16
    4126:	e6 5e       	subi	r30, 0xE6	; 230
    4128:	fe 4f       	sbci	r31, 0xFE	; 254
    412a:	c0 82       	st	Z, r12
    412c:	d1 82       	std	Z+1, r13	; 0x01
    412e:	e2 82       	std	Z+2, r14	; 0x02
    4130:	f3 82       	std	Z+3, r15	; 0x03
						model->OperationalState(SystemModel::AutoPilot);
					}
					
					model->AuxChannelValue(auxChannelValue);
					
					if (!rcInterface->ARRAYLOCK)
    4132:	88 81       	ld	r24, Y
    4134:	81 11       	cpse	r24, r1
    4136:	09 c0       	rjmp	.+18     	; 0x414a <__vector_46+0x168>
					
				void controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue );
				
				void copyPulseWidthArrays()
				{
					memcpy(servoChannelPulseWidths, workingServoChannelPulseWidths, sizeof(servoChannelPulseWidths));
    4138:	de 01       	movw	r26, r28
    413a:	91 96       	adiw	r26, 0x21	; 33
    413c:	fe 01       	movw	r30, r28
    413e:	31 96       	adiw	r30, 0x01	; 1
    4140:	80 e2       	ldi	r24, 0x20	; 32
    4142:	01 90       	ld	r0, Z+
    4144:	0d 92       	st	X+, r0
    4146:	8a 95       	dec	r24
    4148:	e1 f7       	brne	.-8      	; 0x4142 <__vector_46+0x160>
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    414a:	cb 5b       	subi	r28, 0xBB	; 187
    414c:	df 4f       	sbci	r29, 0xFF	; 255
					//rcInterface->ServoChannelIndex(0);
				}			
			}
		} 

		rcInterface->ServoChannelIndex(rcInterface->ServoChannelIndex() + 1);
    414e:	88 81       	ld	r24, Y
    4150:	99 81       	ldd	r25, Y+1	; 0x01
    4152:	01 96       	adiw	r24, 0x01	; 1
    4154:	99 83       	std	Y+1, r25	; 0x01
    4156:	88 83       	st	Y, r24
	}

}
    4158:	ff 91       	pop	r31
    415a:	ef 91       	pop	r30
    415c:	df 91       	pop	r29
    415e:	cf 91       	pop	r28
    4160:	bf 91       	pop	r27
    4162:	af 91       	pop	r26
    4164:	9f 91       	pop	r25
    4166:	8f 91       	pop	r24
    4168:	7f 91       	pop	r23
    416a:	6f 91       	pop	r22
    416c:	5f 91       	pop	r21
    416e:	4f 91       	pop	r20
    4170:	3f 91       	pop	r19
    4172:	2f 91       	pop	r18
    4174:	1f 91       	pop	r17
    4176:	0f 91       	pop	r16
    4178:	ff 90       	pop	r15
    417a:	ef 90       	pop	r14
    417c:	df 90       	pop	r13
    417e:	cf 90       	pop	r12
    4180:	0f 90       	pop	r0
    4182:	0b be       	out	0x3b, r0	; 59
    4184:	0f 90       	pop	r0
    4186:	0f be       	out	0x3f, r0	; 63
    4188:	0f 90       	pop	r0
    418a:	1f 90       	pop	r1
    418c:	18 95       	reti

0000418e <_ZN10helicopter10interfaces24RadioControllerInterface4CCPMEfffRfS2_S2_>:

}


void RadioControllerInterface::CCPM(float inAileron, float inElevator, float inCollective, float &outAileron, float &outElevator, float &outPitch)
{
    418e:	2f 92       	push	r2
    4190:	3f 92       	push	r3
    4192:	4f 92       	push	r4
    4194:	5f 92       	push	r5
    4196:	6f 92       	push	r6
    4198:	7f 92       	push	r7
    419a:	8f 92       	push	r8
    419c:	9f 92       	push	r9
    419e:	af 92       	push	r10
    41a0:	bf 92       	push	r11
    41a2:	cf 92       	push	r12
    41a4:	df 92       	push	r13
    41a6:	ef 92       	push	r14
    41a8:	ff 92       	push	r15
    41aa:	0f 93       	push	r16
    41ac:	1f 93       	push	r17
    41ae:	cf 93       	push	r28
    41b0:	df 93       	push	r29
    41b2:	cd b7       	in	r28, 0x3d	; 61
    41b4:	de b7       	in	r29, 0x3e	; 62
    41b6:	2c 97       	sbiw	r28, 0x0c	; 12
    41b8:	0f b6       	in	r0, 0x3f	; 63
    41ba:	f8 94       	cli
    41bc:	de bf       	out	0x3e, r29	; 62
    41be:	0f be       	out	0x3f, r0	; 63
    41c0:	cd bf       	out	0x3d, r28	; 61
    41c2:	4d 83       	std	Y+5, r20	; 0x05
    41c4:	5e 83       	std	Y+6, r21	; 0x06
    41c6:	6f 83       	std	Y+7, r22	; 0x07
    41c8:	78 87       	std	Y+8, r23	; 0x08
    41ca:	28 01       	movw	r4, r16
    41cc:	39 01       	movw	r6, r18
    41ce:	ba 86       	std	Y+10, r11	; 0x0a
    41d0:	a9 86       	std	Y+9, r10	; 0x09
    41d2:	9c 86       	std	Y+12, r9	; 0x0c
    41d4:	8b 86       	std	Y+11, r8	; 0x0b
	outAileron = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective+ELEVATOR_SCALER*SWASHOFFSETELEVATORMULTIPLYER*inElevator*-1+AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
	outElevator = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective*-1 + ELEVATOR_SCALER*SWASHOFFSETELEVATORELEVATORMULTIPLYER*inElevator*-1;
	*/	
	
	
	float scaledCollectiveWithOffsets = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective;
    41d6:	20 e0       	ldi	r18, 0x00	; 0
    41d8:	30 e0       	ldi	r19, 0x00	; 0
    41da:	44 e1       	ldi	r20, 0x14	; 20
    41dc:	53 e4       	ldi	r21, 0x43	; 67
    41de:	c7 01       	movw	r24, r14
    41e0:	b6 01       	movw	r22, r12
    41e2:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    41e6:	20 e0       	ldi	r18, 0x00	; 0
    41e8:	38 e8       	ldi	r19, 0x88	; 136
    41ea:	40 e9       	ldi	r20, 0x90	; 144
    41ec:	56 e4       	ldi	r21, 0x46	; 70
    41ee:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    41f2:	e6 2e       	mov	r14, r22
    41f4:	f7 2e       	mov	r15, r23
    41f6:	08 2f       	mov	r16, r24
    41f8:	19 2f       	mov	r17, r25
    41fa:	86 2f       	mov	r24, r22
    41fc:	9f 2d       	mov	r25, r15
    41fe:	a0 2f       	mov	r26, r16
    4200:	b1 2f       	mov	r27, r17
    4202:	89 83       	std	Y+1, r24	; 0x01
    4204:	9a 83       	std	Y+2, r25	; 0x02
    4206:	ab 83       	std	Y+3, r26	; 0x03
    4208:	bc 83       	std	Y+4, r27	; 0x04
	float scaledElevator = ELEVATOR_SCALER*inElevator;
    420a:	20 e0       	ldi	r18, 0x00	; 0
    420c:	30 e0       	ldi	r19, 0x00	; 0
    420e:	4c e2       	ldi	r20, 0x2C	; 44
    4210:	52 e4       	ldi	r21, 0x42	; 66
    4212:	c3 01       	movw	r24, r6
    4214:	b2 01       	movw	r22, r4
    4216:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    421a:	46 2e       	mov	r4, r22
    421c:	57 2e       	mov	r5, r23
    421e:	68 2e       	mov	r6, r24
    4220:	79 2e       	mov	r7, r25
	float scaledElevatorWithOffsets = scaledElevator*SWASHOFFSETELEVATORMULTIPLYER;
    4222:	76 2f       	mov	r23, r22
    4224:	27 2f       	mov	r18, r23
    4226:	35 2d       	mov	r19, r5
    4228:	46 2d       	mov	r20, r6
    422a:	57 2d       	mov	r21, r7
    422c:	64 2d       	mov	r22, r4
    422e:	75 2d       	mov	r23, r5
    4230:	86 2d       	mov	r24, r6
    4232:	97 2d       	mov	r25, r7
    4234:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    4238:	a6 2e       	mov	r10, r22
    423a:	b7 2e       	mov	r11, r23
    423c:	c8 2e       	mov	r12, r24
    423e:	d9 2e       	mov	r13, r25
	float negativeScaledAileronWithOffsets = AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
    4240:	20 e0       	ldi	r18, 0x00	; 0
    4242:	30 e0       	ldi	r19, 0x00	; 0
    4244:	41 e1       	ldi	r20, 0x11	; 17
    4246:	53 e4       	ldi	r21, 0x43	; 67
    4248:	6d 81       	ldd	r22, Y+5	; 0x05
    424a:	7e 81       	ldd	r23, Y+6	; 0x06
    424c:	8f 81       	ldd	r24, Y+7	; 0x07
    424e:	98 85       	ldd	r25, Y+8	; 0x08
    4250:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    4254:	26 2e       	mov	r2, r22
    4256:	37 2e       	mov	r3, r23
    4258:	88 2e       	mov	r8, r24
    425a:	99 2e       	mov	r9, r25
	
	outPitch = scaledCollectiveWithOffsets*-1 + scaledElevatorWithOffsets+negativeScaledAileronWithOffsets;
    425c:	2e 2d       	mov	r18, r14
    425e:	3f 2d       	mov	r19, r15
    4260:	40 2f       	mov	r20, r16
    4262:	51 2f       	mov	r21, r17
    4264:	6a 2d       	mov	r22, r10
    4266:	7b 2d       	mov	r23, r11
    4268:	8c 2d       	mov	r24, r12
    426a:	9d 2d       	mov	r25, r13
    426c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4270:	22 2d       	mov	r18, r2
    4272:	33 2d       	mov	r19, r3
    4274:	48 2d       	mov	r20, r8
    4276:	59 2d       	mov	r21, r9
    4278:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    427c:	ea a1       	ldd	r30, Y+34	; 0x22
    427e:	fb a1       	ldd	r31, Y+35	; 0x23
    4280:	60 83       	st	Z, r22
    4282:	71 83       	std	Z+1, r23	; 0x01
    4284:	82 83       	std	Z+2, r24	; 0x02
    4286:	93 83       	std	Z+3, r25	; 0x03
	outAileron = scaledCollectiveWithOffsets+scaledElevatorWithOffsets*-1+negativeScaledAileronWithOffsets;
    4288:	2a 2d       	mov	r18, r10
    428a:	3b 2d       	mov	r19, r11
    428c:	4c 2d       	mov	r20, r12
    428e:	5d 2d       	mov	r21, r13
    4290:	6e 2d       	mov	r22, r14
    4292:	7f 2d       	mov	r23, r15
    4294:	80 2f       	mov	r24, r16
    4296:	91 2f       	mov	r25, r17
    4298:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    429c:	22 2d       	mov	r18, r2
    429e:	33 2d       	mov	r19, r3
    42a0:	48 2d       	mov	r20, r8
    42a2:	59 2d       	mov	r21, r9
    42a4:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    42a8:	e9 85       	ldd	r30, Y+9	; 0x09
    42aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ac:	60 83       	st	Z, r22
    42ae:	71 83       	std	Z+1, r23	; 0x01
    42b0:	82 83       	std	Z+2, r24	; 0x02
    42b2:	93 83       	std	Z+3, r25	; 0x03
	outElevator = scaledCollectiveWithOffsets*-1 + scaledElevator*SWASHOFFSETELEVATORELEVATORMULTIPLYER*-1;
    42b4:	c9 80       	ldd	r12, Y+1	; 0x01
    42b6:	da 80       	ldd	r13, Y+2	; 0x02
    42b8:	eb 80       	ldd	r14, Y+3	; 0x03
    42ba:	fc 80       	ldd	r15, Y+4	; 0x04
    42bc:	f7 fa       	bst	r15, 7
    42be:	f0 94       	com	r15
    42c0:	f7 f8       	bld	r15, 7
    42c2:	f0 94       	com	r15
    42c4:	20 e0       	ldi	r18, 0x00	; 0
    42c6:	30 e0       	ldi	r19, 0x00	; 0
    42c8:	40 e8       	ldi	r20, 0x80	; 128
    42ca:	50 e4       	ldi	r21, 0x40	; 64
    42cc:	64 2d       	mov	r22, r4
    42ce:	75 2d       	mov	r23, r5
    42d0:	86 2d       	mov	r24, r6
    42d2:	97 2d       	mov	r25, r7
    42d4:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    42d8:	9b 01       	movw	r18, r22
    42da:	ac 01       	movw	r20, r24
    42dc:	c7 01       	movw	r24, r14
    42de:	b6 01       	movw	r22, r12
    42e0:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    42e4:	eb 85       	ldd	r30, Y+11	; 0x0b
    42e6:	fc 85       	ldd	r31, Y+12	; 0x0c
    42e8:	60 83       	st	Z, r22
    42ea:	71 83       	std	Z+1, r23	; 0x01
    42ec:	82 83       	std	Z+2, r24	; 0x02
    42ee:	93 83       	std	Z+3, r25	; 0x03
	outPitch = outPitch + PITCH_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	outAileron = outAileron + AILERON_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	outElevator =  outElevator + ELEVATOR_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	*/
	
}
    42f0:	2c 96       	adiw	r28, 0x0c	; 12
    42f2:	0f b6       	in	r0, 0x3f	; 63
    42f4:	f8 94       	cli
    42f6:	de bf       	out	0x3e, r29	; 62
    42f8:	0f be       	out	0x3f, r0	; 63
    42fa:	cd bf       	out	0x3d, r28	; 61
    42fc:	df 91       	pop	r29
    42fe:	cf 91       	pop	r28
    4300:	1f 91       	pop	r17
    4302:	0f 91       	pop	r16
    4304:	ff 90       	pop	r15
    4306:	ef 90       	pop	r14
    4308:	df 90       	pop	r13
    430a:	cf 90       	pop	r12
    430c:	bf 90       	pop	r11
    430e:	af 90       	pop	r10
    4310:	9f 90       	pop	r9
    4312:	8f 90       	pop	r8
    4314:	7f 90       	pop	r7
    4316:	6f 90       	pop	r6
    4318:	5f 90       	pop	r5
    431a:	4f 90       	pop	r4
    431c:	3f 90       	pop	r3
    431e:	2f 90       	pop	r2
    4320:	08 95       	ret

00004322 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>:

void RadioControllerInterface::controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue )
{
    4322:	2f 92       	push	r2
    4324:	3f 92       	push	r3
    4326:	4f 92       	push	r4
    4328:	5f 92       	push	r5
    432a:	6f 92       	push	r6
    432c:	7f 92       	push	r7
    432e:	8f 92       	push	r8
    4330:	9f 92       	push	r9
    4332:	af 92       	push	r10
    4334:	bf 92       	push	r11
    4336:	cf 92       	push	r12
    4338:	df 92       	push	r13
    433a:	ef 92       	push	r14
    433c:	ff 92       	push	r15
    433e:	0f 93       	push	r16
    4340:	1f 93       	push	r17
    4342:	cf 93       	push	r28
    4344:	df 93       	push	r29
    4346:	cd b7       	in	r28, 0x3d	; 61
    4348:	de b7       	in	r29, 0x3e	; 62
    434a:	2c 97       	sbiw	r28, 0x0c	; 12
    434c:	0f b6       	in	r0, 0x3f	; 63
    434e:	f8 94       	cli
    4350:	de bf       	out	0x3e, r29	; 62
    4352:	0f be       	out	0x3f, r0	; 63
    4354:	cd bf       	out	0x3d, r28	; 61
    4356:	3c 01       	movw	r6, r24
    4358:	14 01       	movw	r2, r8
    435a:	25 01       	movw	r4, r10
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
    435c:	fc 01       	movw	r30, r24
    435e:	e9 5a       	subi	r30, 0xA9	; 169
    4360:	ff 4f       	sbci	r31, 0xFF	; 255
    4362:	01 90       	ld	r0, Z+
    4364:	f0 81       	ld	r31, Z
    4366:	e0 2d       	mov	r30, r0
    4368:	82 81       	ldd	r24, Z+2	; 0x02

	
	//If in manual control, just forward the pulse width values from the input pins to the output pins.
	if (systemModel->OperationalState() == SystemModel::ManualControl)
    436a:	81 11       	cpse	r24, r1
    436c:	76 c0       	rjmp	.+236    	; 0x445a <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x138>
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
		*/
		
		ARRAYLOCK = true;
    436e:	81 e0       	ldi	r24, 0x01	; 1
    4370:	f3 01       	movw	r30, r6
    4372:	80 83       	st	Z, r24
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    4374:	41 a1       	ldd	r20, Z+33	; 0x21
    4376:	52 a1       	ldd	r21, Z+34	; 0x22
    4378:	63 a1       	ldd	r22, Z+35	; 0x23
    437a:	74 a1       	ldd	r23, Z+36	; 0x24
    437c:	c3 01       	movw	r24, r6
    437e:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    4382:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4386:	70 93 8b 00 	sts	0x008B, r23
    438a:	60 93 8a 00 	sts	0x008A, r22
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
    438e:	f3 01       	movw	r30, r6
    4390:	45 a1       	ldd	r20, Z+37	; 0x25
    4392:	56 a1       	ldd	r21, Z+38	; 0x26
    4394:	67 a1       	ldd	r22, Z+39	; 0x27
    4396:	70 a5       	ldd	r23, Z+40	; 0x28
    4398:	c3 01       	movw	r24, r6
    439a:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    439e:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    43a2:	70 93 89 00 	sts	0x0089, r23
    43a6:	60 93 88 00 	sts	0x0088, r22
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
    43aa:	f3 01       	movw	r30, r6
    43ac:	41 a5       	ldd	r20, Z+41	; 0x29
    43ae:	52 a5       	ldd	r21, Z+42	; 0x2a
    43b0:	63 a5       	ldd	r22, Z+43	; 0x2b
    43b2:	74 a5       	ldd	r23, Z+44	; 0x2c
    43b4:	c3 01       	movw	r24, r6
    43b6:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43ba:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    43be:	70 93 ad 00 	sts	0x00AD, r23
    43c2:	60 93 ac 00 	sts	0x00AC, r22
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
    43c6:	f3 01       	movw	r30, r6
    43c8:	45 a5       	ldd	r20, Z+45	; 0x2d
    43ca:	56 a5       	ldd	r21, Z+46	; 0x2e
    43cc:	67 a5       	ldd	r22, Z+47	; 0x2f
    43ce:	70 a9       	ldd	r23, Z+48	; 0x30
    43d0:	c3 01       	movw	r24, r6
    43d2:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43d6:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    43da:	70 93 ab 00 	sts	0x00AB, r23
    43de:	60 93 aa 00 	sts	0x00AA, r22
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
    43e2:	f3 01       	movw	r30, r6
    43e4:	41 a9       	ldd	r20, Z+49	; 0x31
    43e6:	52 a9       	ldd	r21, Z+50	; 0x32
    43e8:	63 a9       	ldd	r22, Z+51	; 0x33
    43ea:	74 a9       	ldd	r23, Z+52	; 0x34
    43ec:	c3 01       	movw	r24, r6
    43ee:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43f2:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    43f6:	70 93 a9 00 	sts	0x00A9, r23
    43fa:	60 93 a8 00 	sts	0x00A8, r22
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
    43fe:	f3 01       	movw	r30, r6
    4400:	45 a9       	ldd	r20, Z+53	; 0x35
    4402:	56 a9       	ldd	r21, Z+54	; 0x36
    4404:	67 a9       	ldd	r22, Z+55	; 0x37
    4406:	70 ad       	ldd	r23, Z+56	; 0x38
    4408:	c3 01       	movw	r24, r6
    440a:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    440e:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4412:	70 93 9d 00 	sts	0x009D, r23
    4416:	60 93 9c 00 	sts	0x009C, r22
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
    441a:	f3 01       	movw	r30, r6
    441c:	41 ad       	ldd	r20, Z+57	; 0x39
    441e:	52 ad       	ldd	r21, Z+58	; 0x3a
    4420:	63 ad       	ldd	r22, Z+59	; 0x3b
    4422:	74 ad       	ldd	r23, Z+60	; 0x3c
    4424:	c3 01       	movw	r24, r6
    4426:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    442a:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    442e:	70 93 9b 00 	sts	0x009B, r23
    4432:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    4436:	f3 01       	movw	r30, r6
    4438:	fd 96       	adiw	r30, 0x3d	; 61
    443a:	40 81       	ld	r20, Z
    443c:	51 81       	ldd	r21, Z+1	; 0x01
    443e:	62 81       	ldd	r22, Z+2	; 0x02
    4440:	73 81       	ldd	r23, Z+3	; 0x03
    4442:	c3 01       	movw	r24, r6
    4444:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    4448:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    444c:	70 93 99 00 	sts	0x0099, r23
    4450:	60 93 98 00 	sts	0x0098, r22
		ARRAYLOCK = false;
    4454:	f3 01       	movw	r30, r6
    4456:	10 82       	st	Z, r1
    4458:	f4 c0       	rjmp	.+488    	; 0x4642 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x320>
		OCR4B = (servoChannelPulseWidths[3]);
		OCR4A = (servoChannelPulseWidths[4]);
		OCR3C = (servoChannelPulseWidths[5]);
		OCR3B = (servoChannelPulseWidths[6]);
		OCR3A = (servoChannelPulseWidths[7]);*/
	} else if (systemModel->OperationalState() == SystemModel::AutoPilot)
    445a:	81 30       	cpi	r24, 0x01	; 1
    445c:	09 f0       	breq	.+2      	; 0x4460 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x13e>
    445e:	f1 c0       	rjmp	.+482    	; 0x4642 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x320>
	{
		//TODO - nonccpm-ccpm this stuff. 

		float outPitch = 0;
    4460:	19 86       	std	Y+9, r1	; 0x09
    4462:	1a 86       	std	Y+10, r1	; 0x0a
    4464:	1b 86       	std	Y+11, r1	; 0x0b
    4466:	1c 86       	std	Y+12, r1	; 0x0c
		float outAileron = 0;
    4468:	1d 82       	std	Y+5, r1	; 0x05
    446a:	1e 82       	std	Y+6, r1	; 0x06
    446c:	1f 82       	std	Y+7, r1	; 0x07
    446e:	18 86       	std	Y+8, r1	; 0x08
		float outElevator = 0;
    4470:	19 82       	std	Y+1, r1	; 0x01
    4472:	1a 82       	std	Y+2, r1	; 0x02
    4474:	1b 82       	std	Y+3, r1	; 0x03
    4476:	1c 82       	std	Y+4, r1	; 0x04
			* PE3      | OC3A               | Aux 3						| 8
			*/			
		
		
		
		CCPM(lateralControl, longitudeControl, mainRotorControl, outAileron, outElevator, outPitch);
    4478:	ce 01       	movw	r24, r28
    447a:	09 96       	adiw	r24, 0x09	; 9
    447c:	9f 93       	push	r25
    447e:	8f 93       	push	r24
    4480:	88 24       	eor	r8, r8
    4482:	83 94       	inc	r8
    4484:	91 2c       	mov	r9, r1
    4486:	8c 0e       	add	r8, r28
    4488:	9d 1e       	adc	r9, r29
    448a:	0f 2e       	mov	r0, r31
    448c:	f5 e0       	ldi	r31, 0x05	; 5
    448e:	af 2e       	mov	r10, r31
    4490:	b1 2c       	mov	r11, r1
    4492:	f0 2d       	mov	r31, r0
    4494:	ac 0e       	add	r10, r28
    4496:	bd 1e       	adc	r11, r29
    4498:	c3 01       	movw	r24, r6
    449a:	0e 94 c7 20 	call	0x418e	; 0x418e <_ZN10helicopter10interfaces24RadioControllerInterface4CCPMEfffRfS2_S2_>
		
		
		//OCR1B = calculatePWMCompareMatchFromControlValue(THROTTLE_VALUE) - channel1Offset;
		
		ARRAYLOCK = true;
    449e:	81 e0       	ldi	r24, 0x01	; 1
    44a0:	f3 01       	movw	r30, r6
    44a2:	80 83       	st	Z, r24
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    44a4:	41 a1       	ldd	r20, Z+33	; 0x21
    44a6:	52 a1       	ldd	r21, Z+34	; 0x22
    44a8:	63 a1       	ldd	r22, Z+35	; 0x23
    44aa:	74 a1       	ldd	r23, Z+36	; 0x24
    44ac:	c3 01       	movw	r24, r6
    44ae:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    44b2:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    44b6:	70 93 8b 00 	sts	0x008B, r23
    44ba:	60 93 8a 00 	sts	0x008A, r22
		ARRAYLOCK = false;
    44be:	f3 01       	movw	r30, r6
    44c0:	10 82       	st	Z, r1
		
		OCR1A = outAileron - channel2Offset;
    44c2:	e7 5b       	subi	r30, 0xB7	; 183
    44c4:	ff 4f       	sbci	r31, 0xFF	; 255
    44c6:	60 81       	ld	r22, Z
    44c8:	71 81       	ldd	r23, Z+1	; 0x01
    44ca:	88 27       	eor	r24, r24
    44cc:	77 fd       	sbrc	r23, 7
    44ce:	80 95       	com	r24
    44d0:	98 2f       	mov	r25, r24
    44d2:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    44d6:	9b 01       	movw	r18, r22
    44d8:	ac 01       	movw	r20, r24
    44da:	6d 81       	ldd	r22, Y+5	; 0x05
    44dc:	7e 81       	ldd	r23, Y+6	; 0x06
    44de:	8f 81       	ldd	r24, Y+7	; 0x07
    44e0:	98 85       	ldd	r25, Y+8	; 0x08
    44e2:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    44e6:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    44ea:	70 93 89 00 	sts	0x0089, r23
    44ee:	60 93 88 00 	sts	0x0088, r22
		OCR4C = outElevator - channel3Offset;
    44f2:	f3 01       	movw	r30, r6
    44f4:	e5 5b       	subi	r30, 0xB5	; 181
    44f6:	ff 4f       	sbci	r31, 0xFF	; 255
    44f8:	60 81       	ld	r22, Z
    44fa:	71 81       	ldd	r23, Z+1	; 0x01
    44fc:	88 27       	eor	r24, r24
    44fe:	77 fd       	sbrc	r23, 7
    4500:	80 95       	com	r24
    4502:	98 2f       	mov	r25, r24
    4504:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    4508:	9b 01       	movw	r18, r22
    450a:	ac 01       	movw	r20, r24
    450c:	69 81       	ldd	r22, Y+1	; 0x01
    450e:	7a 81       	ldd	r23, Y+2	; 0x02
    4510:	8b 81       	ldd	r24, Y+3	; 0x03
    4512:	9c 81       	ldd	r25, Y+4	; 0x04
    4514:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4518:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    451c:	70 93 ad 00 	sts	0x00AD, r23
    4520:	60 93 ac 00 	sts	0x00AC, r22
		OCR4B = calculatePWMCompareMatchFromControlValue(yawControl) - channel4Offset;
    4524:	b2 01       	movw	r22, r4
    4526:	a1 01       	movw	r20, r2
    4528:	c3 01       	movw	r24, r6
    452a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    452e:	6b 01       	movw	r12, r22
    4530:	7c 01       	movw	r14, r24
    4532:	f3 01       	movw	r30, r6
    4534:	e3 5b       	subi	r30, 0xB3	; 179
    4536:	ff 4f       	sbci	r31, 0xFF	; 255
    4538:	60 81       	ld	r22, Z
    453a:	71 81       	ldd	r23, Z+1	; 0x01
    453c:	88 27       	eor	r24, r24
    453e:	77 fd       	sbrc	r23, 7
    4540:	80 95       	com	r24
    4542:	98 2f       	mov	r25, r24
    4544:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    4548:	9b 01       	movw	r18, r22
    454a:	ac 01       	movw	r20, r24
    454c:	c7 01       	movw	r24, r14
    454e:	b6 01       	movw	r22, r12
    4550:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4554:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4558:	70 93 ab 00 	sts	0x00AB, r23
    455c:	60 93 aa 00 	sts	0x00AA, r22
		OCR4A = calculatePWMCompareMatchFromControlValue(GEAR_VALUE) - channel5Offset;
    4560:	40 e0       	ldi	r20, 0x00	; 0
    4562:	50 e0       	ldi	r21, 0x00	; 0
    4564:	ba 01       	movw	r22, r20
    4566:	c3 01       	movw	r24, r6
    4568:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    456c:	6b 01       	movw	r12, r22
    456e:	7c 01       	movw	r14, r24
    4570:	f3 01       	movw	r30, r6
    4572:	e1 5b       	subi	r30, 0xB1	; 177
    4574:	ff 4f       	sbci	r31, 0xFF	; 255
    4576:	60 81       	ld	r22, Z
    4578:	71 81       	ldd	r23, Z+1	; 0x01
    457a:	88 27       	eor	r24, r24
    457c:	77 fd       	sbrc	r23, 7
    457e:	80 95       	com	r24
    4580:	98 2f       	mov	r25, r24
    4582:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    4586:	9b 01       	movw	r18, r22
    4588:	ac 01       	movw	r20, r24
    458a:	c7 01       	movw	r24, r14
    458c:	b6 01       	movw	r22, r12
    458e:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4592:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4596:	70 93 a9 00 	sts	0x00A9, r23
    459a:	60 93 a8 00 	sts	0x00A8, r22
		OCR3C = outPitch - channel6Offset;
    459e:	f3 01       	movw	r30, r6
    45a0:	ef 5a       	subi	r30, 0xAF	; 175
    45a2:	ff 4f       	sbci	r31, 0xFF	; 255
    45a4:	60 81       	ld	r22, Z
    45a6:	71 81       	ldd	r23, Z+1	; 0x01
    45a8:	88 27       	eor	r24, r24
    45aa:	77 fd       	sbrc	r23, 7
    45ac:	80 95       	com	r24
    45ae:	98 2f       	mov	r25, r24
    45b0:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    45b4:	9b 01       	movw	r18, r22
    45b6:	ac 01       	movw	r20, r24
    45b8:	69 85       	ldd	r22, Y+9	; 0x09
    45ba:	7a 85       	ldd	r23, Y+10	; 0x0a
    45bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    45be:	9c 85       	ldd	r25, Y+12	; 0x0c
    45c0:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    45c4:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    45c8:	70 93 9d 00 	sts	0x009D, r23
    45cc:	60 93 9c 00 	sts	0x009C, r22
		OCR3B = calculatePWMCompareMatchFromControlValue(auxChannelValue) - channel7Offset;
    45d0:	4a a1       	ldd	r20, Y+34	; 0x22
    45d2:	5b a1       	ldd	r21, Y+35	; 0x23
    45d4:	6c a1       	ldd	r22, Y+36	; 0x24
    45d6:	7d a1       	ldd	r23, Y+37	; 0x25
    45d8:	c3 01       	movw	r24, r6
    45da:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    45de:	4b 01       	movw	r8, r22
    45e0:	5c 01       	movw	r10, r24
    45e2:	f3 01       	movw	r30, r6
    45e4:	ed 5a       	subi	r30, 0xAD	; 173
    45e6:	ff 4f       	sbci	r31, 0xFF	; 255
    45e8:	60 81       	ld	r22, Z
    45ea:	71 81       	ldd	r23, Z+1	; 0x01
    45ec:	88 27       	eor	r24, r24
    45ee:	77 fd       	sbrc	r23, 7
    45f0:	80 95       	com	r24
    45f2:	98 2f       	mov	r25, r24
    45f4:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    45f8:	9b 01       	movw	r18, r22
    45fa:	ac 01       	movw	r20, r24
    45fc:	c5 01       	movw	r24, r10
    45fe:	b4 01       	movw	r22, r8
    4600:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4604:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4608:	70 93 9b 00 	sts	0x009B, r23
    460c:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = calculatePWMCompareMatchFromControlValue(AUX3_VALUE) - channel8Offset;
    4610:	f3 01       	movw	r30, r6
    4612:	eb 5a       	subi	r30, 0xAB	; 171
    4614:	ff 4f       	sbci	r31, 0xFF	; 255
    4616:	60 81       	ld	r22, Z
    4618:	71 81       	ldd	r23, Z+1	; 0x01
    461a:	88 27       	eor	r24, r24
    461c:	77 fd       	sbrc	r23, 7
    461e:	80 95       	com	r24
    4620:	98 2f       	mov	r25, r24
    4622:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    4626:	9b 01       	movw	r18, r22
    4628:	ac 01       	movw	r20, r24
    462a:	c7 01       	movw	r24, r14
    462c:	b6 01       	movw	r22, r12
    462e:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    4632:	0e 94 c2 6b 	call	0xd784	; 0xd784 <__fixunssfsi>
    4636:	70 93 99 00 	sts	0x0099, r23
    463a:	60 93 98 00 	sts	0x0098, r22
    463e:	0f 90       	pop	r0
    4640:	0f 90       	pop	r0
		OCR3B = calculatePWMCompareMatchFromControlValue(-.8f);
		OCR3A = calculatePWMCompareMatchFromControlValue(-.8f);*/

	}

}
    4642:	2c 96       	adiw	r28, 0x0c	; 12
    4644:	0f b6       	in	r0, 0x3f	; 63
    4646:	f8 94       	cli
    4648:	de bf       	out	0x3e, r29	; 62
    464a:	0f be       	out	0x3f, r0	; 63
    464c:	cd bf       	out	0x3d, r28	; 61
    464e:	df 91       	pop	r29
    4650:	cf 91       	pop	r28
    4652:	1f 91       	pop	r17
    4654:	0f 91       	pop	r16
    4656:	ff 90       	pop	r15
    4658:	ef 90       	pop	r14
    465a:	df 90       	pop	r13
    465c:	cf 90       	pop	r12
    465e:	bf 90       	pop	r11
    4660:	af 90       	pop	r10
    4662:	9f 90       	pop	r9
    4664:	8f 90       	pop	r8
    4666:	7f 90       	pop	r7
    4668:	6f 90       	pop	r6
    466a:	5f 90       	pop	r5
    466c:	4f 90       	pop	r4
    466e:	3f 90       	pop	r3
    4670:	2f 90       	pop	r2
    4672:	08 95       	ret

00004674 <_ZN10helicopter8messages14ControlMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4674:	20 e5       	ldi	r18, 0x50	; 80
    4676:	32 e0       	ldi	r19, 0x02	; 2
    4678:	fc 01       	movw	r30, r24
    467a:	31 83       	std	Z+1, r19	; 0x01
    467c:	20 83       	st	Z, r18
    467e:	08 95       	ret

00004680 <_ZN10helicopter8messages14ControlMessageD0Ev>:
    4680:	20 e5       	ldi	r18, 0x50	; 80
    4682:	32 e0       	ldi	r19, 0x02	; 2
    4684:	fc 01       	movw	r30, r24
    4686:	31 83       	std	Z+1, r19	; 0x01
    4688:	20 83       	st	Z, r18
					LateralControl(0)
				{
					
				}
				
				~ControlMessage() {}
    468a:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    468e:	08 95       	ret

00004690 <_ZN10helicopter8messages14ControlMessage8getBytesEv>:
#include "ControlMessage.h"

using namespace helicopter::messages;

byte *ControlMessage::getBytes()
{
    4690:	cf 93       	push	r28
    4692:	df 93       	push	r29
    4694:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4696:	81 e1       	ldi	r24, 0x11	; 17
    4698:	90 e0       	ldi	r25, 0x00	; 0
    469a:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    469e:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    46a0:	8a 81       	ldd	r24, Y+2	; 0x02
    46a2:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    46a4:	8d 81       	ldd	r24, Y+5	; 0x05
    46a6:	9e 81       	ldd	r25, Y+6	; 0x06
    46a8:	af 81       	ldd	r26, Y+7	; 0x07
    46aa:	b8 85       	ldd	r27, Y+8	; 0x08
    46ac:	81 83       	std	Z+1, r24	; 0x01
    46ae:	92 83       	std	Z+2, r25	; 0x02
    46b0:	a3 83       	std	Z+3, r26	; 0x03
    46b2:	b4 83       	std	Z+4, r27	; 0x04
    46b4:	49 85       	ldd	r20, Y+9	; 0x09
    46b6:	5a 85       	ldd	r21, Y+10	; 0x0a
    46b8:	6b 85       	ldd	r22, Y+11	; 0x0b
    46ba:	7c 85       	ldd	r23, Y+12	; 0x0c
    46bc:	45 83       	std	Z+5, r20	; 0x05
    46be:	56 83       	std	Z+6, r21	; 0x06
    46c0:	67 83       	std	Z+7, r22	; 0x07
    46c2:	70 87       	std	Z+8, r23	; 0x08
    46c4:	4d 85       	ldd	r20, Y+13	; 0x0d
    46c6:	5e 85       	ldd	r21, Y+14	; 0x0e
    46c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    46ca:	78 89       	ldd	r23, Y+16	; 0x10
    46cc:	41 87       	std	Z+9, r20	; 0x09
    46ce:	52 87       	std	Z+10, r21	; 0x0a
    46d0:	63 87       	std	Z+11, r22	; 0x0b
    46d2:	74 87       	std	Z+12, r23	; 0x0c
    46d4:	49 89       	ldd	r20, Y+17	; 0x11
    46d6:	5a 89       	ldd	r21, Y+18	; 0x12
    46d8:	6b 89       	ldd	r22, Y+19	; 0x13
    46da:	7c 89       	ldd	r23, Y+20	; 0x14
    46dc:	45 87       	std	Z+13, r20	; 0x0d
    46de:	56 87       	std	Z+14, r21	; 0x0e
    46e0:	67 87       	std	Z+15, r22	; 0x0f
    46e2:	70 8b       	std	Z+16, r23	; 0x10
	encode (msgPtr, LongitudeControl);
	encode (msgPtr, LateralControl);
	
	
	return msg;
}
    46e4:	8e 2f       	mov	r24, r30
    46e6:	9f 2f       	mov	r25, r31
    46e8:	df 91       	pop	r29
    46ea:	cf 91       	pop	r28
    46ec:	08 95       	ret

000046ee <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>:

void ControlMessage::buildMessage(byte *message)
{
    46ee:	cf 93       	push	r28
    46f0:	df 93       	push	r29
    46f2:	fc 01       	movw	r30, r24
    46f4:	eb 01       	movw	r28, r22
	if (message != NULL)
    46f6:	20 97       	sbiw	r28, 0x00	; 0
    46f8:	11 f1       	breq	.+68     	; 0x473e <_ZN10helicopter8messages14ControlMessage12buildMessageEPh+0x50>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    46fa:	88 81       	ld	r24, Y
    46fc:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    46fe:	89 81       	ldd	r24, Y+1	; 0x01
    4700:	9a 81       	ldd	r25, Y+2	; 0x02
    4702:	ab 81       	ldd	r26, Y+3	; 0x03
    4704:	bc 81       	ldd	r27, Y+4	; 0x04
    4706:	85 83       	std	Z+5, r24	; 0x05
    4708:	96 83       	std	Z+6, r25	; 0x06
    470a:	a7 83       	std	Z+7, r26	; 0x07
    470c:	b0 87       	std	Z+8, r27	; 0x08
    470e:	4d 81       	ldd	r20, Y+5	; 0x05
    4710:	5e 81       	ldd	r21, Y+6	; 0x06
    4712:	6f 81       	ldd	r22, Y+7	; 0x07
    4714:	78 85       	ldd	r23, Y+8	; 0x08
    4716:	41 87       	std	Z+9, r20	; 0x09
    4718:	52 87       	std	Z+10, r21	; 0x0a
    471a:	63 87       	std	Z+11, r22	; 0x0b
    471c:	74 87       	std	Z+12, r23	; 0x0c
    471e:	49 85       	ldd	r20, Y+9	; 0x09
    4720:	5a 85       	ldd	r21, Y+10	; 0x0a
    4722:	6b 85       	ldd	r22, Y+11	; 0x0b
    4724:	7c 85       	ldd	r23, Y+12	; 0x0c
    4726:	45 87       	std	Z+13, r20	; 0x0d
    4728:	56 87       	std	Z+14, r21	; 0x0e
    472a:	67 87       	std	Z+15, r22	; 0x0f
    472c:	70 8b       	std	Z+16, r23	; 0x10
    472e:	4d 85       	ldd	r20, Y+13	; 0x0d
    4730:	5e 85       	ldd	r21, Y+14	; 0x0e
    4732:	6f 85       	ldd	r22, Y+15	; 0x0f
    4734:	78 89       	ldd	r23, Y+16	; 0x10
    4736:	41 8b       	std	Z+17, r20	; 0x11
    4738:	52 8b       	std	Z+18, r21	; 0x12
    473a:	63 8b       	std	Z+19, r22	; 0x13
    473c:	74 8b       	std	Z+20, r23	; 0x14
		decode (message, MainRotorCollectiveControl);
		decode (message, YawControl);
		decode (message, LongitudeControl);
		decode (message, LateralControl);
	}
}
    473e:	df 91       	pop	r29
    4740:	cf 91       	pop	r28
    4742:	08 95       	ret

00004744 <_ZN10helicopter8messages12GainsMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4744:	20 e5       	ldi	r18, 0x50	; 80
    4746:	32 e0       	ldi	r19, 0x02	; 2
    4748:	fc 01       	movw	r30, r24
    474a:	31 83       	std	Z+1, r19	; 0x01
    474c:	20 83       	st	Z, r18
    474e:	08 95       	ret

00004750 <_ZN10helicopter8messages12GainsMessageD0Ev>:
    4750:	20 e5       	ldi	r18, 0x50	; 80
    4752:	32 e0       	ldi	r19, 0x02	; 2
    4754:	fc 01       	movw	r30, r24
    4756:	31 83       	std	Z+1, r19	; 0x01
    4758:	20 83       	st	Z, r18
					YawRefSetpoint(0)
				{
				
				}
			
				~GainsMessage() {}
    475a:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    475e:	08 95       	ret

00004760 <_ZN10helicopter8messages12GainsMessage8getBytesEv>:

using namespace helicopter::messages;


byte *GainsMessage::getBytes()
{
    4760:	cf 93       	push	r28
    4762:	df 93       	push	r29
    4764:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4766:	81 e6       	ldi	r24, 0x61	; 97
    4768:	90 e0       	ldi	r25, 0x00	; 0
    476a:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    476e:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4770:	8a 81       	ldd	r24, Y+2	; 0x02
    4772:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4774:	8d 81       	ldd	r24, Y+5	; 0x05
    4776:	9e 81       	ldd	r25, Y+6	; 0x06
    4778:	af 81       	ldd	r26, Y+7	; 0x07
    477a:	b8 85       	ldd	r27, Y+8	; 0x08
    477c:	81 83       	std	Z+1, r24	; 0x01
    477e:	92 83       	std	Z+2, r25	; 0x02
    4780:	a3 83       	std	Z+3, r26	; 0x03
    4782:	b4 83       	std	Z+4, r27	; 0x04
    4784:	89 85       	ldd	r24, Y+9	; 0x09
    4786:	9a 85       	ldd	r25, Y+10	; 0x0a
    4788:	ab 85       	ldd	r26, Y+11	; 0x0b
    478a:	bc 85       	ldd	r27, Y+12	; 0x0c
    478c:	85 83       	std	Z+5, r24	; 0x05
    478e:	96 83       	std	Z+6, r25	; 0x06
    4790:	a7 83       	std	Z+7, r26	; 0x07
    4792:	b0 87       	std	Z+8, r27	; 0x08
    4794:	8d 85       	ldd	r24, Y+13	; 0x0d
    4796:	9e 85       	ldd	r25, Y+14	; 0x0e
    4798:	af 85       	ldd	r26, Y+15	; 0x0f
    479a:	b8 89       	ldd	r27, Y+16	; 0x10
    479c:	81 87       	std	Z+9, r24	; 0x09
    479e:	92 87       	std	Z+10, r25	; 0x0a
    47a0:	a3 87       	std	Z+11, r26	; 0x0b
    47a2:	b4 87       	std	Z+12, r27	; 0x0c
    47a4:	89 89       	ldd	r24, Y+17	; 0x11
    47a6:	9a 89       	ldd	r25, Y+18	; 0x12
    47a8:	ab 89       	ldd	r26, Y+19	; 0x13
    47aa:	bc 89       	ldd	r27, Y+20	; 0x14
    47ac:	85 87       	std	Z+13, r24	; 0x0d
    47ae:	96 87       	std	Z+14, r25	; 0x0e
    47b0:	a7 87       	std	Z+15, r26	; 0x0f
    47b2:	b0 8b       	std	Z+16, r27	; 0x10
    47b4:	8d 89       	ldd	r24, Y+21	; 0x15
    47b6:	9e 89       	ldd	r25, Y+22	; 0x16
    47b8:	af 89       	ldd	r26, Y+23	; 0x17
    47ba:	b8 8d       	ldd	r27, Y+24	; 0x18
    47bc:	81 8b       	std	Z+17, r24	; 0x11
    47be:	92 8b       	std	Z+18, r25	; 0x12
    47c0:	a3 8b       	std	Z+19, r26	; 0x13
    47c2:	b4 8b       	std	Z+20, r27	; 0x14
    47c4:	89 8d       	ldd	r24, Y+25	; 0x19
    47c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    47c8:	ab 8d       	ldd	r26, Y+27	; 0x1b
    47ca:	bc 8d       	ldd	r27, Y+28	; 0x1c
    47cc:	85 8b       	std	Z+21, r24	; 0x15
    47ce:	96 8b       	std	Z+22, r25	; 0x16
    47d0:	a7 8b       	std	Z+23, r26	; 0x17
    47d2:	b0 8f       	std	Z+24, r27	; 0x18
    47d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    47d6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    47d8:	af 8d       	ldd	r26, Y+31	; 0x1f
    47da:	b8 a1       	ldd	r27, Y+32	; 0x20
    47dc:	81 8f       	std	Z+25, r24	; 0x19
    47de:	92 8f       	std	Z+26, r25	; 0x1a
    47e0:	a3 8f       	std	Z+27, r26	; 0x1b
    47e2:	b4 8f       	std	Z+28, r27	; 0x1c
    47e4:	89 a1       	ldd	r24, Y+33	; 0x21
    47e6:	9a a1       	ldd	r25, Y+34	; 0x22
    47e8:	ab a1       	ldd	r26, Y+35	; 0x23
    47ea:	bc a1       	ldd	r27, Y+36	; 0x24
    47ec:	85 8f       	std	Z+29, r24	; 0x1d
    47ee:	96 8f       	std	Z+30, r25	; 0x1e
    47f0:	a7 8f       	std	Z+31, r26	; 0x1f
    47f2:	b0 a3       	std	Z+32, r27	; 0x20
    47f4:	8d a1       	ldd	r24, Y+37	; 0x25
    47f6:	9e a1       	ldd	r25, Y+38	; 0x26
    47f8:	af a1       	ldd	r26, Y+39	; 0x27
    47fa:	b8 a5       	ldd	r27, Y+40	; 0x28
    47fc:	81 a3       	std	Z+33, r24	; 0x21
    47fe:	92 a3       	std	Z+34, r25	; 0x22
    4800:	a3 a3       	std	Z+35, r26	; 0x23
    4802:	b4 a3       	std	Z+36, r27	; 0x24
    4804:	89 a5       	ldd	r24, Y+41	; 0x29
    4806:	9a a5       	ldd	r25, Y+42	; 0x2a
    4808:	ab a5       	ldd	r26, Y+43	; 0x2b
    480a:	bc a5       	ldd	r27, Y+44	; 0x2c
    480c:	85 a3       	std	Z+37, r24	; 0x25
    480e:	96 a3       	std	Z+38, r25	; 0x26
    4810:	a7 a3       	std	Z+39, r26	; 0x27
    4812:	b0 a7       	std	Z+40, r27	; 0x28
    4814:	8d a5       	ldd	r24, Y+45	; 0x2d
    4816:	9e a5       	ldd	r25, Y+46	; 0x2e
    4818:	af a5       	ldd	r26, Y+47	; 0x2f
    481a:	b8 a9       	ldd	r27, Y+48	; 0x30
    481c:	81 a7       	std	Z+41, r24	; 0x29
    481e:	92 a7       	std	Z+42, r25	; 0x2a
    4820:	a3 a7       	std	Z+43, r26	; 0x2b
    4822:	b4 a7       	std	Z+44, r27	; 0x2c
    4824:	89 a9       	ldd	r24, Y+49	; 0x31
    4826:	9a a9       	ldd	r25, Y+50	; 0x32
    4828:	ab a9       	ldd	r26, Y+51	; 0x33
    482a:	bc a9       	ldd	r27, Y+52	; 0x34
    482c:	85 a7       	std	Z+45, r24	; 0x2d
    482e:	96 a7       	std	Z+46, r25	; 0x2e
    4830:	a7 a7       	std	Z+47, r26	; 0x2f
    4832:	b0 ab       	std	Z+48, r27	; 0x30
    4834:	8d a9       	ldd	r24, Y+53	; 0x35
    4836:	9e a9       	ldd	r25, Y+54	; 0x36
    4838:	af a9       	ldd	r26, Y+55	; 0x37
    483a:	b8 ad       	ldd	r27, Y+56	; 0x38
    483c:	81 ab       	std	Z+49, r24	; 0x31
    483e:	92 ab       	std	Z+50, r25	; 0x32
    4840:	a3 ab       	std	Z+51, r26	; 0x33
    4842:	b4 ab       	std	Z+52, r27	; 0x34
    4844:	89 ad       	ldd	r24, Y+57	; 0x39
    4846:	9a ad       	ldd	r25, Y+58	; 0x3a
    4848:	ab ad       	ldd	r26, Y+59	; 0x3b
    484a:	bc ad       	ldd	r27, Y+60	; 0x3c
    484c:	85 ab       	std	Z+53, r24	; 0x35
    484e:	96 ab       	std	Z+54, r25	; 0x36
    4850:	a7 ab       	std	Z+55, r26	; 0x37
    4852:	b0 af       	std	Z+56, r27	; 0x38
    4854:	de 01       	movw	r26, r28
    4856:	dd 96       	adiw	r26, 0x3d	; 61
    4858:	8d 91       	ld	r24, X+
    485a:	9d 91       	ld	r25, X+
    485c:	0d 90       	ld	r0, X+
    485e:	bc 91       	ld	r27, X
    4860:	a0 2d       	mov	r26, r0
    4862:	81 af       	std	Z+57, r24	; 0x39
    4864:	92 af       	std	Z+58, r25	; 0x3a
    4866:	a3 af       	std	Z+59, r26	; 0x3b
    4868:	b4 af       	std	Z+60, r27	; 0x3c
    486a:	9f 01       	movw	r18, r30
    486c:	23 5c       	subi	r18, 0xC3	; 195
    486e:	3f 4f       	sbci	r19, 0xFF	; 255
    4870:	de 01       	movw	r26, r28
    4872:	af 5b       	subi	r26, 0xBF	; 191
    4874:	bf 4f       	sbci	r27, 0xFF	; 255
    4876:	4d 91       	ld	r20, X+
    4878:	5d 91       	ld	r21, X+
    487a:	6d 91       	ld	r22, X+
    487c:	7c 91       	ld	r23, X
    487e:	d9 01       	movw	r26, r18
    4880:	4d 93       	st	X+, r20
    4882:	5d 93       	st	X+, r21
    4884:	6d 93       	st	X+, r22
    4886:	7c 93       	st	X, r23
    4888:	13 97       	sbiw	r26, 0x03	; 3
    488a:	9f 01       	movw	r18, r30
    488c:	2f 5b       	subi	r18, 0xBF	; 191
    488e:	3f 4f       	sbci	r19, 0xFF	; 255
    4890:	de 01       	movw	r26, r28
    4892:	ab 5b       	subi	r26, 0xBB	; 187
    4894:	bf 4f       	sbci	r27, 0xFF	; 255
    4896:	4d 91       	ld	r20, X+
    4898:	5d 91       	ld	r21, X+
    489a:	6d 91       	ld	r22, X+
    489c:	7c 91       	ld	r23, X
    489e:	d9 01       	movw	r26, r18
    48a0:	4d 93       	st	X+, r20
    48a2:	5d 93       	st	X+, r21
    48a4:	6d 93       	st	X+, r22
    48a6:	7c 93       	st	X, r23
    48a8:	13 97       	sbiw	r26, 0x03	; 3
    48aa:	9f 01       	movw	r18, r30
    48ac:	2b 5b       	subi	r18, 0xBB	; 187
    48ae:	3f 4f       	sbci	r19, 0xFF	; 255
    48b0:	de 01       	movw	r26, r28
    48b2:	a7 5b       	subi	r26, 0xB7	; 183
    48b4:	bf 4f       	sbci	r27, 0xFF	; 255
    48b6:	4d 91       	ld	r20, X+
    48b8:	5d 91       	ld	r21, X+
    48ba:	6d 91       	ld	r22, X+
    48bc:	7c 91       	ld	r23, X
    48be:	d9 01       	movw	r26, r18
    48c0:	4d 93       	st	X+, r20
    48c2:	5d 93       	st	X+, r21
    48c4:	6d 93       	st	X+, r22
    48c6:	7c 93       	st	X, r23
    48c8:	13 97       	sbiw	r26, 0x03	; 3
    48ca:	9f 01       	movw	r18, r30
    48cc:	27 5b       	subi	r18, 0xB7	; 183
    48ce:	3f 4f       	sbci	r19, 0xFF	; 255
    48d0:	de 01       	movw	r26, r28
    48d2:	a3 5b       	subi	r26, 0xB3	; 179
    48d4:	bf 4f       	sbci	r27, 0xFF	; 255
    48d6:	4d 91       	ld	r20, X+
    48d8:	5d 91       	ld	r21, X+
    48da:	6d 91       	ld	r22, X+
    48dc:	7c 91       	ld	r23, X
    48de:	d9 01       	movw	r26, r18
    48e0:	4d 93       	st	X+, r20
    48e2:	5d 93       	st	X+, r21
    48e4:	6d 93       	st	X+, r22
    48e6:	7c 93       	st	X, r23
    48e8:	13 97       	sbiw	r26, 0x03	; 3
    48ea:	9f 01       	movw	r18, r30
    48ec:	23 5b       	subi	r18, 0xB3	; 179
    48ee:	3f 4f       	sbci	r19, 0xFF	; 255
    48f0:	de 01       	movw	r26, r28
    48f2:	af 5a       	subi	r26, 0xAF	; 175
    48f4:	bf 4f       	sbci	r27, 0xFF	; 255
    48f6:	4d 91       	ld	r20, X+
    48f8:	5d 91       	ld	r21, X+
    48fa:	6d 91       	ld	r22, X+
    48fc:	7c 91       	ld	r23, X
    48fe:	d9 01       	movw	r26, r18
    4900:	4d 93       	st	X+, r20
    4902:	5d 93       	st	X+, r21
    4904:	6d 93       	st	X+, r22
    4906:	7c 93       	st	X, r23
    4908:	13 97       	sbiw	r26, 0x03	; 3
    490a:	9f 01       	movw	r18, r30
    490c:	2f 5a       	subi	r18, 0xAF	; 175
    490e:	3f 4f       	sbci	r19, 0xFF	; 255
    4910:	de 01       	movw	r26, r28
    4912:	ab 5a       	subi	r26, 0xAB	; 171
    4914:	bf 4f       	sbci	r27, 0xFF	; 255
    4916:	4d 91       	ld	r20, X+
    4918:	5d 91       	ld	r21, X+
    491a:	6d 91       	ld	r22, X+
    491c:	7c 91       	ld	r23, X
    491e:	d9 01       	movw	r26, r18
    4920:	4d 93       	st	X+, r20
    4922:	5d 93       	st	X+, r21
    4924:	6d 93       	st	X+, r22
    4926:	7c 93       	st	X, r23
    4928:	13 97       	sbiw	r26, 0x03	; 3
    492a:	9f 01       	movw	r18, r30
    492c:	2b 5a       	subi	r18, 0xAB	; 171
    492e:	3f 4f       	sbci	r19, 0xFF	; 255
    4930:	ce 01       	movw	r24, r28
    4932:	87 5a       	subi	r24, 0xA7	; 167
    4934:	9f 4f       	sbci	r25, 0xFF	; 255
    4936:	dc 01       	movw	r26, r24
    4938:	4d 91       	ld	r20, X+
    493a:	5d 91       	ld	r21, X+
    493c:	6d 91       	ld	r22, X+
    493e:	7c 91       	ld	r23, X
    4940:	d9 01       	movw	r26, r18
    4942:	4d 93       	st	X+, r20
    4944:	5d 93       	st	X+, r21
    4946:	6d 93       	st	X+, r22
    4948:	7c 93       	st	X, r23
    494a:	13 97       	sbiw	r26, 0x03	; 3
    494c:	9f 01       	movw	r18, r30
    494e:	27 5a       	subi	r18, 0xA7	; 167
    4950:	3f 4f       	sbci	r19, 0xFF	; 255
    4952:	ce 01       	movw	r24, r28
    4954:	83 5a       	subi	r24, 0xA3	; 163
    4956:	9f 4f       	sbci	r25, 0xFF	; 255
    4958:	dc 01       	movw	r26, r24
    495a:	4d 91       	ld	r20, X+
    495c:	5d 91       	ld	r21, X+
    495e:	6d 91       	ld	r22, X+
    4960:	7c 91       	ld	r23, X
    4962:	d9 01       	movw	r26, r18
    4964:	4d 93       	st	X+, r20
    4966:	5d 93       	st	X+, r21
    4968:	6d 93       	st	X+, r22
    496a:	7c 93       	st	X, r23
    496c:	13 97       	sbiw	r26, 0x03	; 3
    496e:	df 01       	movw	r26, r30
    4970:	a3 5a       	subi	r26, 0xA3	; 163
    4972:	bf 4f       	sbci	r27, 0xFF	; 255
    4974:	cf 59       	subi	r28, 0x9F	; 159
    4976:	df 4f       	sbci	r29, 0xFF	; 255
    4978:	48 81       	ld	r20, Y
    497a:	59 81       	ldd	r21, Y+1	; 0x01
    497c:	6a 81       	ldd	r22, Y+2	; 0x02
    497e:	7b 81       	ldd	r23, Y+3	; 0x03
    4980:	4d 93       	st	X+, r20
    4982:	5d 93       	st	X+, r21
    4984:	6d 93       	st	X+, r22
    4986:	7c 93       	st	X, r23
    4988:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, YRefSetpoint);
	encode (msgPtr, ZRefSetpoint);	
	encode (msgPtr, YawRefSetpoint);
	
	return msg;
}
    498a:	8e 2f       	mov	r24, r30
    498c:	9f 2f       	mov	r25, r31
    498e:	df 91       	pop	r29
    4990:	cf 91       	pop	r28
    4992:	08 95       	ret

00004994 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>:

void GainsMessage::buildMessage(byte *message)
{
    4994:	cf 93       	push	r28
    4996:	df 93       	push	r29
    4998:	fc 01       	movw	r30, r24
    499a:	db 01       	movw	r26, r22
	if (message != NULL)
    499c:	10 97       	sbiw	r26, 0x00	; 0
    499e:	09 f4       	brne	.+2      	; 0x49a2 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0xe>
    49a0:	25 c1       	rjmp	.+586    	; 0x4bec <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0x258>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    49a2:	8c 91       	ld	r24, X
    49a4:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    49a6:	11 96       	adiw	r26, 0x01	; 1
    49a8:	4d 91       	ld	r20, X+
    49aa:	5d 91       	ld	r21, X+
    49ac:	6d 91       	ld	r22, X+
    49ae:	7c 91       	ld	r23, X
    49b0:	14 97       	sbiw	r26, 0x04	; 4
    49b2:	45 83       	std	Z+5, r20	; 0x05
    49b4:	56 83       	std	Z+6, r21	; 0x06
    49b6:	67 83       	std	Z+7, r22	; 0x07
    49b8:	70 87       	std	Z+8, r23	; 0x08
    49ba:	15 96       	adiw	r26, 0x05	; 5
    49bc:	4d 91       	ld	r20, X+
    49be:	5d 91       	ld	r21, X+
    49c0:	6d 91       	ld	r22, X+
    49c2:	7c 91       	ld	r23, X
    49c4:	18 97       	sbiw	r26, 0x08	; 8
    49c6:	41 87       	std	Z+9, r20	; 0x09
    49c8:	52 87       	std	Z+10, r21	; 0x0a
    49ca:	63 87       	std	Z+11, r22	; 0x0b
    49cc:	74 87       	std	Z+12, r23	; 0x0c
    49ce:	19 96       	adiw	r26, 0x09	; 9
    49d0:	4d 91       	ld	r20, X+
    49d2:	5d 91       	ld	r21, X+
    49d4:	6d 91       	ld	r22, X+
    49d6:	7c 91       	ld	r23, X
    49d8:	1c 97       	sbiw	r26, 0x0c	; 12
    49da:	45 87       	std	Z+13, r20	; 0x0d
    49dc:	56 87       	std	Z+14, r21	; 0x0e
    49de:	67 87       	std	Z+15, r22	; 0x0f
    49e0:	70 8b       	std	Z+16, r23	; 0x10
    49e2:	1d 96       	adiw	r26, 0x0d	; 13
    49e4:	4d 91       	ld	r20, X+
    49e6:	5d 91       	ld	r21, X+
    49e8:	6d 91       	ld	r22, X+
    49ea:	7c 91       	ld	r23, X
    49ec:	50 97       	sbiw	r26, 0x10	; 16
    49ee:	41 8b       	std	Z+17, r20	; 0x11
    49f0:	52 8b       	std	Z+18, r21	; 0x12
    49f2:	63 8b       	std	Z+19, r22	; 0x13
    49f4:	74 8b       	std	Z+20, r23	; 0x14
    49f6:	51 96       	adiw	r26, 0x11	; 17
    49f8:	4d 91       	ld	r20, X+
    49fa:	5d 91       	ld	r21, X+
    49fc:	6d 91       	ld	r22, X+
    49fe:	7c 91       	ld	r23, X
    4a00:	54 97       	sbiw	r26, 0x14	; 20
    4a02:	45 8b       	std	Z+21, r20	; 0x15
    4a04:	56 8b       	std	Z+22, r21	; 0x16
    4a06:	67 8b       	std	Z+23, r22	; 0x17
    4a08:	70 8f       	std	Z+24, r23	; 0x18
    4a0a:	55 96       	adiw	r26, 0x15	; 21
    4a0c:	4d 91       	ld	r20, X+
    4a0e:	5d 91       	ld	r21, X+
    4a10:	6d 91       	ld	r22, X+
    4a12:	7c 91       	ld	r23, X
    4a14:	58 97       	sbiw	r26, 0x18	; 24
    4a16:	41 8f       	std	Z+25, r20	; 0x19
    4a18:	52 8f       	std	Z+26, r21	; 0x1a
    4a1a:	63 8f       	std	Z+27, r22	; 0x1b
    4a1c:	74 8f       	std	Z+28, r23	; 0x1c
    4a1e:	59 96       	adiw	r26, 0x19	; 25
    4a20:	4d 91       	ld	r20, X+
    4a22:	5d 91       	ld	r21, X+
    4a24:	6d 91       	ld	r22, X+
    4a26:	7c 91       	ld	r23, X
    4a28:	5c 97       	sbiw	r26, 0x1c	; 28
    4a2a:	45 8f       	std	Z+29, r20	; 0x1d
    4a2c:	56 8f       	std	Z+30, r21	; 0x1e
    4a2e:	67 8f       	std	Z+31, r22	; 0x1f
    4a30:	70 a3       	std	Z+32, r23	; 0x20
    4a32:	5d 96       	adiw	r26, 0x1d	; 29
    4a34:	4d 91       	ld	r20, X+
    4a36:	5d 91       	ld	r21, X+
    4a38:	6d 91       	ld	r22, X+
    4a3a:	7c 91       	ld	r23, X
    4a3c:	90 97       	sbiw	r26, 0x20	; 32
    4a3e:	41 a3       	std	Z+33, r20	; 0x21
    4a40:	52 a3       	std	Z+34, r21	; 0x22
    4a42:	63 a3       	std	Z+35, r22	; 0x23
    4a44:	74 a3       	std	Z+36, r23	; 0x24
    4a46:	91 96       	adiw	r26, 0x21	; 33
    4a48:	4d 91       	ld	r20, X+
    4a4a:	5d 91       	ld	r21, X+
    4a4c:	6d 91       	ld	r22, X+
    4a4e:	7c 91       	ld	r23, X
    4a50:	94 97       	sbiw	r26, 0x24	; 36
    4a52:	45 a3       	std	Z+37, r20	; 0x25
    4a54:	56 a3       	std	Z+38, r21	; 0x26
    4a56:	67 a3       	std	Z+39, r22	; 0x27
    4a58:	70 a7       	std	Z+40, r23	; 0x28
    4a5a:	95 96       	adiw	r26, 0x25	; 37
    4a5c:	4d 91       	ld	r20, X+
    4a5e:	5d 91       	ld	r21, X+
    4a60:	6d 91       	ld	r22, X+
    4a62:	7c 91       	ld	r23, X
    4a64:	98 97       	sbiw	r26, 0x28	; 40
    4a66:	41 a7       	std	Z+41, r20	; 0x29
    4a68:	52 a7       	std	Z+42, r21	; 0x2a
    4a6a:	63 a7       	std	Z+43, r22	; 0x2b
    4a6c:	74 a7       	std	Z+44, r23	; 0x2c
    4a6e:	99 96       	adiw	r26, 0x29	; 41
    4a70:	4d 91       	ld	r20, X+
    4a72:	5d 91       	ld	r21, X+
    4a74:	6d 91       	ld	r22, X+
    4a76:	7c 91       	ld	r23, X
    4a78:	9c 97       	sbiw	r26, 0x2c	; 44
    4a7a:	45 a7       	std	Z+45, r20	; 0x2d
    4a7c:	56 a7       	std	Z+46, r21	; 0x2e
    4a7e:	67 a7       	std	Z+47, r22	; 0x2f
    4a80:	70 ab       	std	Z+48, r23	; 0x30
    4a82:	9d 96       	adiw	r26, 0x2d	; 45
    4a84:	4d 91       	ld	r20, X+
    4a86:	5d 91       	ld	r21, X+
    4a88:	6d 91       	ld	r22, X+
    4a8a:	7c 91       	ld	r23, X
    4a8c:	d0 97       	sbiw	r26, 0x30	; 48
    4a8e:	41 ab       	std	Z+49, r20	; 0x31
    4a90:	52 ab       	std	Z+50, r21	; 0x32
    4a92:	63 ab       	std	Z+51, r22	; 0x33
    4a94:	74 ab       	std	Z+52, r23	; 0x34
    4a96:	d1 96       	adiw	r26, 0x31	; 49
    4a98:	4d 91       	ld	r20, X+
    4a9a:	5d 91       	ld	r21, X+
    4a9c:	6d 91       	ld	r22, X+
    4a9e:	7c 91       	ld	r23, X
    4aa0:	d4 97       	sbiw	r26, 0x34	; 52
    4aa2:	45 ab       	std	Z+53, r20	; 0x35
    4aa4:	56 ab       	std	Z+54, r21	; 0x36
    4aa6:	67 ab       	std	Z+55, r22	; 0x37
    4aa8:	70 af       	std	Z+56, r23	; 0x38
    4aaa:	d5 96       	adiw	r26, 0x35	; 53
    4aac:	4d 91       	ld	r20, X+
    4aae:	5d 91       	ld	r21, X+
    4ab0:	6d 91       	ld	r22, X+
    4ab2:	7c 91       	ld	r23, X
    4ab4:	d8 97       	sbiw	r26, 0x38	; 56
    4ab6:	41 af       	std	Z+57, r20	; 0x39
    4ab8:	52 af       	std	Z+58, r21	; 0x3a
    4aba:	63 af       	std	Z+59, r22	; 0x3b
    4abc:	74 af       	std	Z+60, r23	; 0x3c
    4abe:	ef 01       	movw	r28, r30
    4ac0:	ed 96       	adiw	r28, 0x3d	; 61
    4ac2:	d9 96       	adiw	r26, 0x39	; 57
    4ac4:	4d 91       	ld	r20, X+
    4ac6:	5d 91       	ld	r21, X+
    4ac8:	6d 91       	ld	r22, X+
    4aca:	7c 91       	ld	r23, X
    4acc:	dc 97       	sbiw	r26, 0x3c	; 60
    4ace:	48 83       	st	Y, r20
    4ad0:	59 83       	std	Y+1, r21	; 0x01
    4ad2:	6a 83       	std	Y+2, r22	; 0x02
    4ad4:	7b 83       	std	Y+3, r23	; 0x03
    4ad6:	9f 01       	movw	r18, r30
    4ad8:	2f 5b       	subi	r18, 0xBF	; 191
    4ada:	3f 4f       	sbci	r19, 0xFF	; 255
    4adc:	cd 01       	movw	r24, r26
    4ade:	cd 96       	adiw	r24, 0x3d	; 61
    4ae0:	ec 01       	movw	r28, r24
    4ae2:	48 81       	ld	r20, Y
    4ae4:	59 81       	ldd	r21, Y+1	; 0x01
    4ae6:	6a 81       	ldd	r22, Y+2	; 0x02
    4ae8:	7b 81       	ldd	r23, Y+3	; 0x03
    4aea:	e9 01       	movw	r28, r18
    4aec:	48 83       	st	Y, r20
    4aee:	59 83       	std	Y+1, r21	; 0x01
    4af0:	6a 83       	std	Y+2, r22	; 0x02
    4af2:	7b 83       	std	Y+3, r23	; 0x03
    4af4:	9f 01       	movw	r18, r30
    4af6:	2b 5b       	subi	r18, 0xBB	; 187
    4af8:	3f 4f       	sbci	r19, 0xFF	; 255
    4afa:	cd 01       	movw	r24, r26
    4afc:	8f 5b       	subi	r24, 0xBF	; 191
    4afe:	9f 4f       	sbci	r25, 0xFF	; 255
    4b00:	ec 01       	movw	r28, r24
    4b02:	48 81       	ld	r20, Y
    4b04:	59 81       	ldd	r21, Y+1	; 0x01
    4b06:	6a 81       	ldd	r22, Y+2	; 0x02
    4b08:	7b 81       	ldd	r23, Y+3	; 0x03
    4b0a:	e9 01       	movw	r28, r18
    4b0c:	48 83       	st	Y, r20
    4b0e:	59 83       	std	Y+1, r21	; 0x01
    4b10:	6a 83       	std	Y+2, r22	; 0x02
    4b12:	7b 83       	std	Y+3, r23	; 0x03
    4b14:	9f 01       	movw	r18, r30
    4b16:	27 5b       	subi	r18, 0xB7	; 183
    4b18:	3f 4f       	sbci	r19, 0xFF	; 255
    4b1a:	cd 01       	movw	r24, r26
    4b1c:	8b 5b       	subi	r24, 0xBB	; 187
    4b1e:	9f 4f       	sbci	r25, 0xFF	; 255
    4b20:	ec 01       	movw	r28, r24
    4b22:	48 81       	ld	r20, Y
    4b24:	59 81       	ldd	r21, Y+1	; 0x01
    4b26:	6a 81       	ldd	r22, Y+2	; 0x02
    4b28:	7b 81       	ldd	r23, Y+3	; 0x03
    4b2a:	e9 01       	movw	r28, r18
    4b2c:	48 83       	st	Y, r20
    4b2e:	59 83       	std	Y+1, r21	; 0x01
    4b30:	6a 83       	std	Y+2, r22	; 0x02
    4b32:	7b 83       	std	Y+3, r23	; 0x03
    4b34:	9f 01       	movw	r18, r30
    4b36:	23 5b       	subi	r18, 0xB3	; 179
    4b38:	3f 4f       	sbci	r19, 0xFF	; 255
    4b3a:	cd 01       	movw	r24, r26
    4b3c:	87 5b       	subi	r24, 0xB7	; 183
    4b3e:	9f 4f       	sbci	r25, 0xFF	; 255
    4b40:	ec 01       	movw	r28, r24
    4b42:	48 81       	ld	r20, Y
    4b44:	59 81       	ldd	r21, Y+1	; 0x01
    4b46:	6a 81       	ldd	r22, Y+2	; 0x02
    4b48:	7b 81       	ldd	r23, Y+3	; 0x03
    4b4a:	e9 01       	movw	r28, r18
    4b4c:	48 83       	st	Y, r20
    4b4e:	59 83       	std	Y+1, r21	; 0x01
    4b50:	6a 83       	std	Y+2, r22	; 0x02
    4b52:	7b 83       	std	Y+3, r23	; 0x03
    4b54:	9f 01       	movw	r18, r30
    4b56:	2f 5a       	subi	r18, 0xAF	; 175
    4b58:	3f 4f       	sbci	r19, 0xFF	; 255
    4b5a:	cd 01       	movw	r24, r26
    4b5c:	83 5b       	subi	r24, 0xB3	; 179
    4b5e:	9f 4f       	sbci	r25, 0xFF	; 255
    4b60:	ec 01       	movw	r28, r24
    4b62:	48 81       	ld	r20, Y
    4b64:	59 81       	ldd	r21, Y+1	; 0x01
    4b66:	6a 81       	ldd	r22, Y+2	; 0x02
    4b68:	7b 81       	ldd	r23, Y+3	; 0x03
    4b6a:	e9 01       	movw	r28, r18
    4b6c:	48 83       	st	Y, r20
    4b6e:	59 83       	std	Y+1, r21	; 0x01
    4b70:	6a 83       	std	Y+2, r22	; 0x02
    4b72:	7b 83       	std	Y+3, r23	; 0x03
    4b74:	9f 01       	movw	r18, r30
    4b76:	2b 5a       	subi	r18, 0xAB	; 171
    4b78:	3f 4f       	sbci	r19, 0xFF	; 255
    4b7a:	cd 01       	movw	r24, r26
    4b7c:	8f 5a       	subi	r24, 0xAF	; 175
    4b7e:	9f 4f       	sbci	r25, 0xFF	; 255
    4b80:	ec 01       	movw	r28, r24
    4b82:	48 81       	ld	r20, Y
    4b84:	59 81       	ldd	r21, Y+1	; 0x01
    4b86:	6a 81       	ldd	r22, Y+2	; 0x02
    4b88:	7b 81       	ldd	r23, Y+3	; 0x03
    4b8a:	e9 01       	movw	r28, r18
    4b8c:	48 83       	st	Y, r20
    4b8e:	59 83       	std	Y+1, r21	; 0x01
    4b90:	6a 83       	std	Y+2, r22	; 0x02
    4b92:	7b 83       	std	Y+3, r23	; 0x03
    4b94:	9f 01       	movw	r18, r30
    4b96:	27 5a       	subi	r18, 0xA7	; 167
    4b98:	3f 4f       	sbci	r19, 0xFF	; 255
    4b9a:	cd 01       	movw	r24, r26
    4b9c:	8b 5a       	subi	r24, 0xAB	; 171
    4b9e:	9f 4f       	sbci	r25, 0xFF	; 255
    4ba0:	ec 01       	movw	r28, r24
    4ba2:	48 81       	ld	r20, Y
    4ba4:	59 81       	ldd	r21, Y+1	; 0x01
    4ba6:	6a 81       	ldd	r22, Y+2	; 0x02
    4ba8:	7b 81       	ldd	r23, Y+3	; 0x03
    4baa:	e9 01       	movw	r28, r18
    4bac:	48 83       	st	Y, r20
    4bae:	59 83       	std	Y+1, r21	; 0x01
    4bb0:	6a 83       	std	Y+2, r22	; 0x02
    4bb2:	7b 83       	std	Y+3, r23	; 0x03
    4bb4:	9f 01       	movw	r18, r30
    4bb6:	23 5a       	subi	r18, 0xA3	; 163
    4bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    4bba:	cd 01       	movw	r24, r26
    4bbc:	87 5a       	subi	r24, 0xA7	; 167
    4bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    4bc0:	ec 01       	movw	r28, r24
    4bc2:	48 81       	ld	r20, Y
    4bc4:	59 81       	ldd	r21, Y+1	; 0x01
    4bc6:	6a 81       	ldd	r22, Y+2	; 0x02
    4bc8:	7b 81       	ldd	r23, Y+3	; 0x03
    4bca:	e9 01       	movw	r28, r18
    4bcc:	48 83       	st	Y, r20
    4bce:	59 83       	std	Y+1, r21	; 0x01
    4bd0:	6a 83       	std	Y+2, r22	; 0x02
    4bd2:	7b 83       	std	Y+3, r23	; 0x03
    4bd4:	ef 59       	subi	r30, 0x9F	; 159
    4bd6:	ff 4f       	sbci	r31, 0xFF	; 255
    4bd8:	a3 5a       	subi	r26, 0xA3	; 163
    4bda:	bf 4f       	sbci	r27, 0xFF	; 255
    4bdc:	4d 91       	ld	r20, X+
    4bde:	5d 91       	ld	r21, X+
    4be0:	6d 91       	ld	r22, X+
    4be2:	7c 91       	ld	r23, X
    4be4:	40 83       	st	Z, r20
    4be6:	51 83       	std	Z+1, r21	; 0x01
    4be8:	62 83       	std	Z+2, r22	; 0x02
    4bea:	73 83       	std	Z+3, r23	; 0x03
		decode (message, YRefSetpoint);
		decode (message, ZRefSetpoint);
		decode (message, YawRefSetpoint);
			
	}
}
    4bec:	df 91       	pop	r29
    4bee:	cf 91       	pop	r28
    4bf0:	08 95       	ret

00004bf2 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>:

GainsMessage* GainsMessage::buildMessageSt(byte *message)
{
    4bf2:	0f 93       	push	r16
    4bf4:	1f 93       	push	r17
    4bf6:	cf 93       	push	r28
    4bf8:	df 93       	push	r29
    4bfa:	8c 01       	movw	r16, r24
	GainsMessage *msg = new GainsMessage();
    4bfc:	85 e6       	ldi	r24, 0x65	; 101
    4bfe:	90 e0       	ldi	r25, 0x00	; 0
    4c00:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    4c04:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    4c06:	87 e0       	ldi	r24, 0x07	; 7
    4c08:	8a 83       	std	Y+2, r24	; 0x02
    4c0a:	81 e6       	ldi	r24, 0x61	; 97
    4c0c:	90 e0       	ldi	r25, 0x00	; 0
    4c0e:	9c 83       	std	Y+4, r25	; 0x04
    4c10:	8b 83       	std	Y+3, r24	; 0x03
					ZAntiWindupGain(0),
					
					XRefSetpoint(0),
					YRefSetpoint(0),
					ZRefSetpoint(0),
					YawRefSetpoint(0)
    4c12:	84 e4       	ldi	r24, 0x44	; 68
    4c14:	92 e0       	ldi	r25, 0x02	; 2
    4c16:	99 83       	std	Y+1, r25	; 0x01
    4c18:	88 83       	st	Y, r24
    4c1a:	1d 82       	std	Y+5, r1	; 0x05
    4c1c:	1e 82       	std	Y+6, r1	; 0x06
    4c1e:	1f 82       	std	Y+7, r1	; 0x07
    4c20:	18 86       	std	Y+8, r1	; 0x08
    4c22:	19 86       	std	Y+9, r1	; 0x09
    4c24:	1a 86       	std	Y+10, r1	; 0x0a
    4c26:	1b 86       	std	Y+11, r1	; 0x0b
    4c28:	1c 86       	std	Y+12, r1	; 0x0c
    4c2a:	1d 86       	std	Y+13, r1	; 0x0d
    4c2c:	1e 86       	std	Y+14, r1	; 0x0e
    4c2e:	1f 86       	std	Y+15, r1	; 0x0f
    4c30:	18 8a       	std	Y+16, r1	; 0x10
    4c32:	19 8a       	std	Y+17, r1	; 0x11
    4c34:	1a 8a       	std	Y+18, r1	; 0x12
    4c36:	1b 8a       	std	Y+19, r1	; 0x13
    4c38:	1c 8a       	std	Y+20, r1	; 0x14
    4c3a:	1d 8a       	std	Y+21, r1	; 0x15
    4c3c:	1e 8a       	std	Y+22, r1	; 0x16
    4c3e:	1f 8a       	std	Y+23, r1	; 0x17
    4c40:	18 8e       	std	Y+24, r1	; 0x18
    4c42:	19 8e       	std	Y+25, r1	; 0x19
    4c44:	1a 8e       	std	Y+26, r1	; 0x1a
    4c46:	1b 8e       	std	Y+27, r1	; 0x1b
    4c48:	1c 8e       	std	Y+28, r1	; 0x1c
    4c4a:	1d 8e       	std	Y+29, r1	; 0x1d
    4c4c:	1e 8e       	std	Y+30, r1	; 0x1e
    4c4e:	1f 8e       	std	Y+31, r1	; 0x1f
    4c50:	18 a2       	std	Y+32, r1	; 0x20
    4c52:	19 a2       	std	Y+33, r1	; 0x21
    4c54:	1a a2       	std	Y+34, r1	; 0x22
    4c56:	1b a2       	std	Y+35, r1	; 0x23
    4c58:	1c a2       	std	Y+36, r1	; 0x24
    4c5a:	1d a2       	std	Y+37, r1	; 0x25
    4c5c:	1e a2       	std	Y+38, r1	; 0x26
    4c5e:	1f a2       	std	Y+39, r1	; 0x27
    4c60:	18 a6       	std	Y+40, r1	; 0x28
    4c62:	19 a6       	std	Y+41, r1	; 0x29
    4c64:	1a a6       	std	Y+42, r1	; 0x2a
    4c66:	1b a6       	std	Y+43, r1	; 0x2b
    4c68:	1c a6       	std	Y+44, r1	; 0x2c
    4c6a:	1d a6       	std	Y+45, r1	; 0x2d
    4c6c:	1e a6       	std	Y+46, r1	; 0x2e
    4c6e:	1f a6       	std	Y+47, r1	; 0x2f
    4c70:	18 aa       	std	Y+48, r1	; 0x30
    4c72:	19 aa       	std	Y+49, r1	; 0x31
    4c74:	1a aa       	std	Y+50, r1	; 0x32
    4c76:	1b aa       	std	Y+51, r1	; 0x33
    4c78:	1c aa       	std	Y+52, r1	; 0x34
    4c7a:	1d aa       	std	Y+53, r1	; 0x35
    4c7c:	1e aa       	std	Y+54, r1	; 0x36
    4c7e:	1f aa       	std	Y+55, r1	; 0x37
    4c80:	18 ae       	std	Y+56, r1	; 0x38
    4c82:	19 ae       	std	Y+57, r1	; 0x39
    4c84:	1a ae       	std	Y+58, r1	; 0x3a
    4c86:	1b ae       	std	Y+59, r1	; 0x3b
    4c88:	1c ae       	std	Y+60, r1	; 0x3c
    4c8a:	fe 01       	movw	r30, r28
    4c8c:	fd 96       	adiw	r30, 0x3d	; 61
    4c8e:	10 82       	st	Z, r1
    4c90:	11 82       	std	Z+1, r1	; 0x01
    4c92:	12 82       	std	Z+2, r1	; 0x02
    4c94:	13 82       	std	Z+3, r1	; 0x03
    4c96:	fe 01       	movw	r30, r28
    4c98:	ef 5b       	subi	r30, 0xBF	; 191
    4c9a:	ff 4f       	sbci	r31, 0xFF	; 255
    4c9c:	10 82       	st	Z, r1
    4c9e:	11 82       	std	Z+1, r1	; 0x01
    4ca0:	12 82       	std	Z+2, r1	; 0x02
    4ca2:	13 82       	std	Z+3, r1	; 0x03
    4ca4:	fe 01       	movw	r30, r28
    4ca6:	eb 5b       	subi	r30, 0xBB	; 187
    4ca8:	ff 4f       	sbci	r31, 0xFF	; 255
    4caa:	10 82       	st	Z, r1
    4cac:	11 82       	std	Z+1, r1	; 0x01
    4cae:	12 82       	std	Z+2, r1	; 0x02
    4cb0:	13 82       	std	Z+3, r1	; 0x03
    4cb2:	fe 01       	movw	r30, r28
    4cb4:	e7 5b       	subi	r30, 0xB7	; 183
    4cb6:	ff 4f       	sbci	r31, 0xFF	; 255
    4cb8:	10 82       	st	Z, r1
    4cba:	11 82       	std	Z+1, r1	; 0x01
    4cbc:	12 82       	std	Z+2, r1	; 0x02
    4cbe:	13 82       	std	Z+3, r1	; 0x03
    4cc0:	fe 01       	movw	r30, r28
    4cc2:	e3 5b       	subi	r30, 0xB3	; 179
    4cc4:	ff 4f       	sbci	r31, 0xFF	; 255
    4cc6:	10 82       	st	Z, r1
    4cc8:	11 82       	std	Z+1, r1	; 0x01
    4cca:	12 82       	std	Z+2, r1	; 0x02
    4ccc:	13 82       	std	Z+3, r1	; 0x03
    4cce:	fe 01       	movw	r30, r28
    4cd0:	ef 5a       	subi	r30, 0xAF	; 175
    4cd2:	ff 4f       	sbci	r31, 0xFF	; 255
    4cd4:	10 82       	st	Z, r1
    4cd6:	11 82       	std	Z+1, r1	; 0x01
    4cd8:	12 82       	std	Z+2, r1	; 0x02
    4cda:	13 82       	std	Z+3, r1	; 0x03
    4cdc:	fe 01       	movw	r30, r28
    4cde:	eb 5a       	subi	r30, 0xAB	; 171
    4ce0:	ff 4f       	sbci	r31, 0xFF	; 255
    4ce2:	10 82       	st	Z, r1
    4ce4:	11 82       	std	Z+1, r1	; 0x01
    4ce6:	12 82       	std	Z+2, r1	; 0x02
    4ce8:	13 82       	std	Z+3, r1	; 0x03
    4cea:	fe 01       	movw	r30, r28
    4cec:	e7 5a       	subi	r30, 0xA7	; 167
    4cee:	ff 4f       	sbci	r31, 0xFF	; 255
    4cf0:	10 82       	st	Z, r1
    4cf2:	11 82       	std	Z+1, r1	; 0x01
    4cf4:	12 82       	std	Z+2, r1	; 0x02
    4cf6:	13 82       	std	Z+3, r1	; 0x03
    4cf8:	fe 01       	movw	r30, r28
    4cfa:	e3 5a       	subi	r30, 0xA3	; 163
    4cfc:	ff 4f       	sbci	r31, 0xFF	; 255
    4cfe:	10 82       	st	Z, r1
    4d00:	11 82       	std	Z+1, r1	; 0x01
    4d02:	12 82       	std	Z+2, r1	; 0x02
    4d04:	13 82       	std	Z+3, r1	; 0x03
    4d06:	fe 01       	movw	r30, r28
    4d08:	ef 59       	subi	r30, 0x9F	; 159
    4d0a:	ff 4f       	sbci	r31, 0xFF	; 255
    4d0c:	10 82       	st	Z, r1
    4d0e:	11 82       	std	Z+1, r1	; 0x01
    4d10:	12 82       	std	Z+2, r1	; 0x02
    4d12:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    4d14:	b8 01       	movw	r22, r16
    4d16:	ce 01       	movw	r24, r28
    4d18:	0e 94 ca 24 	call	0x4994	; 0x4994 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
	
	return msg;
}
    4d1c:	8c 2f       	mov	r24, r28
    4d1e:	9d 2f       	mov	r25, r29
    4d20:	df 91       	pop	r29
    4d22:	cf 91       	pop	r28
    4d24:	1f 91       	pop	r17
    4d26:	0f 91       	pop	r16
    4d28:	08 95       	ret

00004d2a <_ZN10helicopter8messages7MessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4d2a:	20 e5       	ldi	r18, 0x50	; 80
    4d2c:	32 e0       	ldi	r19, 0x02	; 2
    4d2e:	fc 01       	movw	r30, r24
    4d30:	31 83       	std	Z+1, r19	; 0x01
    4d32:	20 83       	st	Z, r18
    4d34:	08 95       	ret

00004d36 <_ZN10helicopter8messages7Message8getBytesEv>:
	* Returns the data in this message in raw byte format for transmission.
	*/
byte *Message::getBytes()
{
	return NULL;
}
    4d36:	80 e0       	ldi	r24, 0x00	; 0
    4d38:	90 e0       	ldi	r25, 0x00	; 0
    4d3a:	08 95       	ret

00004d3c <_ZN10helicopter8messages7Message12buildMessageEPh>:
	* for creating a message object given a stream of bytes.
	* @param message The bytes in the payload of the message which should be used
	* to construct a message object.
	*/
void Message::buildMessage(byte *message)
{
    4d3c:	08 95       	ret

00004d3e <_ZN10helicopter8messages7MessageD0Ev>:
    4d3e:	20 e5       	ldi	r18, 0x50	; 80
    4d40:	32 e0       	ldi	r19, 0x02	; 2
    4d42:	fc 01       	movw	r30, r24
    4d44:	31 83       	std	Z+1, r19	; 0x01
    4d46:	20 83       	st	Z, r18
					
				}
    4d48:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    4d4c:	08 95       	ret

00004d4e <_ZN10helicopter8messages7Message14getMessageSizeEv>:
	* Returns the number of bytes in this message. This should
	* be the payload of the message, and not underlying protocol
	* information (sync bytes and checksum bytes)
	*/
int Message::getMessageSize()
{
    4d4e:	fc 01       	movw	r30, r24
	return msgSize;
}
    4d50:	83 81       	ldd	r24, Z+3	; 0x03
    4d52:	94 81       	ldd	r25, Z+4	; 0x04
    4d54:	08 95       	ret

00004d56 <_ZN10helicopter8messages17SensorDataMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4d56:	20 e5       	ldi	r18, 0x50	; 80
    4d58:	32 e0       	ldi	r19, 0x02	; 2
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	31 83       	std	Z+1, r19	; 0x01
    4d5e:	20 83       	st	Z, r18
    4d60:	08 95       	ret

00004d62 <_ZN10helicopter8messages17SensorDataMessageD0Ev>:
    4d62:	20 e5       	ldi	r18, 0x50	; 80
    4d64:	32 e0       	ldi	r19, 0x02	; 2
    4d66:	fc 01       	movw	r30, r24
    4d68:	31 83       	std	Z+1, r19	; 0x01
    4d6a:	20 83       	st	Z, r18
					PressureMillibars(0)
				{
					
				}
				
				~SensorDataMessage() {}
    4d6c:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    4d70:	08 95       	ret

00004d72 <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>:
#include "SensorDataMessage.h"

using namespace helicopter::messages;

byte *SensorDataMessage::getBytes()
{
    4d72:	cf 93       	push	r28
    4d74:	df 93       	push	r29
    4d76:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4d78:	81 e4       	ldi	r24, 0x41	; 65
    4d7a:	90 e0       	ldi	r25, 0x00	; 0
    4d7c:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    4d80:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4d82:	8a 81       	ldd	r24, Y+2	; 0x02
    4d84:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4d86:	8d 81       	ldd	r24, Y+5	; 0x05
    4d88:	9e 81       	ldd	r25, Y+6	; 0x06
    4d8a:	af 81       	ldd	r26, Y+7	; 0x07
    4d8c:	b8 85       	ldd	r27, Y+8	; 0x08
    4d8e:	81 83       	std	Z+1, r24	; 0x01
    4d90:	92 83       	std	Z+2, r25	; 0x02
    4d92:	a3 83       	std	Z+3, r26	; 0x03
    4d94:	b4 83       	std	Z+4, r27	; 0x04
    4d96:	89 85       	ldd	r24, Y+9	; 0x09
    4d98:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d9a:	ab 85       	ldd	r26, Y+11	; 0x0b
    4d9c:	bc 85       	ldd	r27, Y+12	; 0x0c
    4d9e:	85 83       	std	Z+5, r24	; 0x05
    4da0:	96 83       	std	Z+6, r25	; 0x06
    4da2:	a7 83       	std	Z+7, r26	; 0x07
    4da4:	b0 87       	std	Z+8, r27	; 0x08
    4da6:	8d 85       	ldd	r24, Y+13	; 0x0d
    4da8:	9e 85       	ldd	r25, Y+14	; 0x0e
    4daa:	af 85       	ldd	r26, Y+15	; 0x0f
    4dac:	b8 89       	ldd	r27, Y+16	; 0x10
    4dae:	81 87       	std	Z+9, r24	; 0x09
    4db0:	92 87       	std	Z+10, r25	; 0x0a
    4db2:	a3 87       	std	Z+11, r26	; 0x0b
    4db4:	b4 87       	std	Z+12, r27	; 0x0c
    4db6:	89 89       	ldd	r24, Y+17	; 0x11
    4db8:	9a 89       	ldd	r25, Y+18	; 0x12
    4dba:	ab 89       	ldd	r26, Y+19	; 0x13
    4dbc:	bc 89       	ldd	r27, Y+20	; 0x14
    4dbe:	85 87       	std	Z+13, r24	; 0x0d
    4dc0:	96 87       	std	Z+14, r25	; 0x0e
    4dc2:	a7 87       	std	Z+15, r26	; 0x0f
    4dc4:	b0 8b       	std	Z+16, r27	; 0x10
    4dc6:	8d 89       	ldd	r24, Y+21	; 0x15
    4dc8:	9e 89       	ldd	r25, Y+22	; 0x16
    4dca:	af 89       	ldd	r26, Y+23	; 0x17
    4dcc:	b8 8d       	ldd	r27, Y+24	; 0x18
    4dce:	81 8b       	std	Z+17, r24	; 0x11
    4dd0:	92 8b       	std	Z+18, r25	; 0x12
    4dd2:	a3 8b       	std	Z+19, r26	; 0x13
    4dd4:	b4 8b       	std	Z+20, r27	; 0x14
    4dd6:	89 8d       	ldd	r24, Y+25	; 0x19
    4dd8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4dda:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4ddc:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4dde:	85 8b       	std	Z+21, r24	; 0x15
    4de0:	96 8b       	std	Z+22, r25	; 0x16
    4de2:	a7 8b       	std	Z+23, r26	; 0x17
    4de4:	b0 8f       	std	Z+24, r27	; 0x18
    4de6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4de8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4dea:	af 8d       	ldd	r26, Y+31	; 0x1f
    4dec:	b8 a1       	ldd	r27, Y+32	; 0x20
    4dee:	81 8f       	std	Z+25, r24	; 0x19
    4df0:	92 8f       	std	Z+26, r25	; 0x1a
    4df2:	a3 8f       	std	Z+27, r26	; 0x1b
    4df4:	b4 8f       	std	Z+28, r27	; 0x1c
    4df6:	89 a1       	ldd	r24, Y+33	; 0x21
    4df8:	9a a1       	ldd	r25, Y+34	; 0x22
    4dfa:	ab a1       	ldd	r26, Y+35	; 0x23
    4dfc:	bc a1       	ldd	r27, Y+36	; 0x24
    4dfe:	85 8f       	std	Z+29, r24	; 0x1d
    4e00:	96 8f       	std	Z+30, r25	; 0x1e
    4e02:	a7 8f       	std	Z+31, r26	; 0x1f
    4e04:	b0 a3       	std	Z+32, r27	; 0x20
    4e06:	8d a1       	ldd	r24, Y+37	; 0x25
    4e08:	9e a1       	ldd	r25, Y+38	; 0x26
    4e0a:	af a1       	ldd	r26, Y+39	; 0x27
    4e0c:	b8 a5       	ldd	r27, Y+40	; 0x28
    4e0e:	81 a3       	std	Z+33, r24	; 0x21
    4e10:	92 a3       	std	Z+34, r25	; 0x22
    4e12:	a3 a3       	std	Z+35, r26	; 0x23
    4e14:	b4 a3       	std	Z+36, r27	; 0x24
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4e16:	89 a5       	ldd	r24, Y+41	; 0x29
    4e18:	9a a5       	ldd	r25, Y+42	; 0x2a
    4e1a:	ab a5       	ldd	r26, Y+43	; 0x2b
    4e1c:	bc a5       	ldd	r27, Y+44	; 0x2c
    4e1e:	85 a3       	std	Z+37, r24	; 0x25
    4e20:	96 a3       	std	Z+38, r25	; 0x26
    4e22:	a7 a3       	std	Z+39, r26	; 0x27
    4e24:	b0 a7       	std	Z+40, r27	; 0x28
    4e26:	8d a5       	ldd	r24, Y+45	; 0x2d
    4e28:	9e a5       	ldd	r25, Y+46	; 0x2e
    4e2a:	af a5       	ldd	r26, Y+47	; 0x2f
    4e2c:	b8 a9       	ldd	r27, Y+48	; 0x30
    4e2e:	81 a7       	std	Z+41, r24	; 0x29
    4e30:	92 a7       	std	Z+42, r25	; 0x2a
    4e32:	a3 a7       	std	Z+43, r26	; 0x2b
    4e34:	b4 a7       	std	Z+44, r27	; 0x2c
    4e36:	89 a9       	ldd	r24, Y+49	; 0x31
    4e38:	9a a9       	ldd	r25, Y+50	; 0x32
    4e3a:	ab a9       	ldd	r26, Y+51	; 0x33
    4e3c:	bc a9       	ldd	r27, Y+52	; 0x34
    4e3e:	85 a7       	std	Z+45, r24	; 0x2d
    4e40:	96 a7       	std	Z+46, r25	; 0x2e
    4e42:	a7 a7       	std	Z+47, r26	; 0x2f
    4e44:	b0 ab       	std	Z+48, r27	; 0x30
    4e46:	8d a9       	ldd	r24, Y+53	; 0x35
    4e48:	9e a9       	ldd	r25, Y+54	; 0x36
    4e4a:	af a9       	ldd	r26, Y+55	; 0x37
    4e4c:	b8 ad       	ldd	r27, Y+56	; 0x38
    4e4e:	81 ab       	std	Z+49, r24	; 0x31
    4e50:	92 ab       	std	Z+50, r25	; 0x32
    4e52:	a3 ab       	std	Z+51, r26	; 0x33
    4e54:	b4 ab       	std	Z+52, r27	; 0x34
    4e56:	49 ad       	ldd	r20, Y+57	; 0x39
    4e58:	5a ad       	ldd	r21, Y+58	; 0x3a
    4e5a:	6b ad       	ldd	r22, Y+59	; 0x3b
    4e5c:	7c ad       	ldd	r23, Y+60	; 0x3c
    4e5e:	45 ab       	std	Z+53, r20	; 0x35
    4e60:	56 ab       	std	Z+54, r21	; 0x36
    4e62:	67 ab       	std	Z+55, r22	; 0x37
    4e64:	70 af       	std	Z+56, r23	; 0x38
    4e66:	de 01       	movw	r26, r28
    4e68:	dd 96       	adiw	r26, 0x3d	; 61
    4e6a:	4d 91       	ld	r20, X+
    4e6c:	5d 91       	ld	r21, X+
    4e6e:	6d 91       	ld	r22, X+
    4e70:	7c 91       	ld	r23, X
    4e72:	41 af       	std	Z+57, r20	; 0x39
    4e74:	52 af       	std	Z+58, r21	; 0x3a
    4e76:	63 af       	std	Z+59, r22	; 0x3b
    4e78:	74 af       	std	Z+60, r23	; 0x3c
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4e7a:	df 01       	movw	r26, r30
    4e7c:	dd 96       	adiw	r26, 0x3d	; 61
    4e7e:	cf 5b       	subi	r28, 0xBF	; 191
    4e80:	df 4f       	sbci	r29, 0xFF	; 255
    4e82:	48 81       	ld	r20, Y
    4e84:	59 81       	ldd	r21, Y+1	; 0x01
    4e86:	6a 81       	ldd	r22, Y+2	; 0x02
    4e88:	7b 81       	ldd	r23, Y+3	; 0x03
    4e8a:	4d 93       	st	X+, r20
    4e8c:	5d 93       	st	X+, r21
    4e8e:	6d 93       	st	X+, r22
    4e90:	7c 93       	st	X, r23
    4e92:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ZVEcefCms);
	encode (msgPtr, PressureMillibars);
	
	
	return msg;
}
    4e94:	8e 2f       	mov	r24, r30
    4e96:	9f 2f       	mov	r25, r31
    4e98:	df 91       	pop	r29
    4e9a:	cf 91       	pop	r28
    4e9c:	08 95       	ret

00004e9e <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>:

void SensorDataMessage::buildMessage(byte *message)
{
    4e9e:	cf 93       	push	r28
    4ea0:	df 93       	push	r29
    4ea2:	fc 01       	movw	r30, r24
    4ea4:	db 01       	movw	r26, r22
	if (message != NULL)
    4ea6:	10 97       	sbiw	r26, 0x00	; 0
    4ea8:	09 f4       	brne	.+2      	; 0x4eac <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0xe>
    4eaa:	a5 c0       	rjmp	.+330    	; 0x4ff6 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0x158>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    4eac:	8c 91       	ld	r24, X
    4eae:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4eb0:	11 96       	adiw	r26, 0x01	; 1
    4eb2:	4d 91       	ld	r20, X+
    4eb4:	5d 91       	ld	r21, X+
    4eb6:	6d 91       	ld	r22, X+
    4eb8:	7c 91       	ld	r23, X
    4eba:	14 97       	sbiw	r26, 0x04	; 4
    4ebc:	45 83       	std	Z+5, r20	; 0x05
    4ebe:	56 83       	std	Z+6, r21	; 0x06
    4ec0:	67 83       	std	Z+7, r22	; 0x07
    4ec2:	70 87       	std	Z+8, r23	; 0x08
    4ec4:	15 96       	adiw	r26, 0x05	; 5
    4ec6:	4d 91       	ld	r20, X+
    4ec8:	5d 91       	ld	r21, X+
    4eca:	6d 91       	ld	r22, X+
    4ecc:	7c 91       	ld	r23, X
    4ece:	18 97       	sbiw	r26, 0x08	; 8
    4ed0:	41 87       	std	Z+9, r20	; 0x09
    4ed2:	52 87       	std	Z+10, r21	; 0x0a
    4ed4:	63 87       	std	Z+11, r22	; 0x0b
    4ed6:	74 87       	std	Z+12, r23	; 0x0c
    4ed8:	19 96       	adiw	r26, 0x09	; 9
    4eda:	4d 91       	ld	r20, X+
    4edc:	5d 91       	ld	r21, X+
    4ede:	6d 91       	ld	r22, X+
    4ee0:	7c 91       	ld	r23, X
    4ee2:	1c 97       	sbiw	r26, 0x0c	; 12
    4ee4:	45 87       	std	Z+13, r20	; 0x0d
    4ee6:	56 87       	std	Z+14, r21	; 0x0e
    4ee8:	67 87       	std	Z+15, r22	; 0x0f
    4eea:	70 8b       	std	Z+16, r23	; 0x10
    4eec:	1d 96       	adiw	r26, 0x0d	; 13
    4eee:	4d 91       	ld	r20, X+
    4ef0:	5d 91       	ld	r21, X+
    4ef2:	6d 91       	ld	r22, X+
    4ef4:	7c 91       	ld	r23, X
    4ef6:	50 97       	sbiw	r26, 0x10	; 16
    4ef8:	41 8b       	std	Z+17, r20	; 0x11
    4efa:	52 8b       	std	Z+18, r21	; 0x12
    4efc:	63 8b       	std	Z+19, r22	; 0x13
    4efe:	74 8b       	std	Z+20, r23	; 0x14
    4f00:	51 96       	adiw	r26, 0x11	; 17
    4f02:	4d 91       	ld	r20, X+
    4f04:	5d 91       	ld	r21, X+
    4f06:	6d 91       	ld	r22, X+
    4f08:	7c 91       	ld	r23, X
    4f0a:	54 97       	sbiw	r26, 0x14	; 20
    4f0c:	45 8b       	std	Z+21, r20	; 0x15
    4f0e:	56 8b       	std	Z+22, r21	; 0x16
    4f10:	67 8b       	std	Z+23, r22	; 0x17
    4f12:	70 8f       	std	Z+24, r23	; 0x18
    4f14:	55 96       	adiw	r26, 0x15	; 21
    4f16:	4d 91       	ld	r20, X+
    4f18:	5d 91       	ld	r21, X+
    4f1a:	6d 91       	ld	r22, X+
    4f1c:	7c 91       	ld	r23, X
    4f1e:	58 97       	sbiw	r26, 0x18	; 24
    4f20:	41 8f       	std	Z+25, r20	; 0x19
    4f22:	52 8f       	std	Z+26, r21	; 0x1a
    4f24:	63 8f       	std	Z+27, r22	; 0x1b
    4f26:	74 8f       	std	Z+28, r23	; 0x1c
    4f28:	59 96       	adiw	r26, 0x19	; 25
    4f2a:	4d 91       	ld	r20, X+
    4f2c:	5d 91       	ld	r21, X+
    4f2e:	6d 91       	ld	r22, X+
    4f30:	7c 91       	ld	r23, X
    4f32:	5c 97       	sbiw	r26, 0x1c	; 28
    4f34:	45 8f       	std	Z+29, r20	; 0x1d
    4f36:	56 8f       	std	Z+30, r21	; 0x1e
    4f38:	67 8f       	std	Z+31, r22	; 0x1f
    4f3a:	70 a3       	std	Z+32, r23	; 0x20
    4f3c:	5d 96       	adiw	r26, 0x1d	; 29
    4f3e:	4d 91       	ld	r20, X+
    4f40:	5d 91       	ld	r21, X+
    4f42:	6d 91       	ld	r22, X+
    4f44:	7c 91       	ld	r23, X
    4f46:	90 97       	sbiw	r26, 0x20	; 32
    4f48:	41 a3       	std	Z+33, r20	; 0x21
    4f4a:	52 a3       	std	Z+34, r21	; 0x22
    4f4c:	63 a3       	std	Z+35, r22	; 0x23
    4f4e:	74 a3       	std	Z+36, r23	; 0x24
    4f50:	91 96       	adiw	r26, 0x21	; 33
    4f52:	4d 91       	ld	r20, X+
    4f54:	5d 91       	ld	r21, X+
    4f56:	6d 91       	ld	r22, X+
    4f58:	7c 91       	ld	r23, X
    4f5a:	94 97       	sbiw	r26, 0x24	; 36
    4f5c:	45 a3       	std	Z+37, r20	; 0x25
    4f5e:	56 a3       	std	Z+38, r21	; 0x26
    4f60:	67 a3       	std	Z+39, r22	; 0x27
    4f62:	70 a7       	std	Z+40, r23	; 0x28
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4f64:	95 96       	adiw	r26, 0x25	; 37
    4f66:	4d 91       	ld	r20, X+
    4f68:	5d 91       	ld	r21, X+
    4f6a:	6d 91       	ld	r22, X+
    4f6c:	7c 91       	ld	r23, X
    4f6e:	98 97       	sbiw	r26, 0x28	; 40
    4f70:	41 a7       	std	Z+41, r20	; 0x29
    4f72:	52 a7       	std	Z+42, r21	; 0x2a
    4f74:	63 a7       	std	Z+43, r22	; 0x2b
    4f76:	74 a7       	std	Z+44, r23	; 0x2c
    4f78:	99 96       	adiw	r26, 0x29	; 41
    4f7a:	4d 91       	ld	r20, X+
    4f7c:	5d 91       	ld	r21, X+
    4f7e:	6d 91       	ld	r22, X+
    4f80:	7c 91       	ld	r23, X
    4f82:	9c 97       	sbiw	r26, 0x2c	; 44
    4f84:	45 a7       	std	Z+45, r20	; 0x2d
    4f86:	56 a7       	std	Z+46, r21	; 0x2e
    4f88:	67 a7       	std	Z+47, r22	; 0x2f
    4f8a:	70 ab       	std	Z+48, r23	; 0x30
    4f8c:	9d 96       	adiw	r26, 0x2d	; 45
    4f8e:	4d 91       	ld	r20, X+
    4f90:	5d 91       	ld	r21, X+
    4f92:	6d 91       	ld	r22, X+
    4f94:	7c 91       	ld	r23, X
    4f96:	d0 97       	sbiw	r26, 0x30	; 48
    4f98:	41 ab       	std	Z+49, r20	; 0x31
    4f9a:	52 ab       	std	Z+50, r21	; 0x32
    4f9c:	63 ab       	std	Z+51, r22	; 0x33
    4f9e:	74 ab       	std	Z+52, r23	; 0x34
    4fa0:	d1 96       	adiw	r26, 0x31	; 49
    4fa2:	4d 91       	ld	r20, X+
    4fa4:	5d 91       	ld	r21, X+
    4fa6:	6d 91       	ld	r22, X+
    4fa8:	7c 91       	ld	r23, X
    4faa:	d4 97       	sbiw	r26, 0x34	; 52
    4fac:	45 ab       	std	Z+53, r20	; 0x35
    4fae:	56 ab       	std	Z+54, r21	; 0x36
    4fb0:	67 ab       	std	Z+55, r22	; 0x37
    4fb2:	70 af       	std	Z+56, r23	; 0x38
    4fb4:	d5 96       	adiw	r26, 0x35	; 53
    4fb6:	4d 91       	ld	r20, X+
    4fb8:	5d 91       	ld	r21, X+
    4fba:	6d 91       	ld	r22, X+
    4fbc:	7c 91       	ld	r23, X
    4fbe:	d8 97       	sbiw	r26, 0x38	; 56
    4fc0:	41 af       	std	Z+57, r20	; 0x39
    4fc2:	52 af       	std	Z+58, r21	; 0x3a
    4fc4:	63 af       	std	Z+59, r22	; 0x3b
    4fc6:	74 af       	std	Z+60, r23	; 0x3c
    4fc8:	ef 01       	movw	r28, r30
    4fca:	ed 96       	adiw	r28, 0x3d	; 61
    4fcc:	d9 96       	adiw	r26, 0x39	; 57
    4fce:	4d 91       	ld	r20, X+
    4fd0:	5d 91       	ld	r21, X+
    4fd2:	6d 91       	ld	r22, X+
    4fd4:	7c 91       	ld	r23, X
    4fd6:	dc 97       	sbiw	r26, 0x3c	; 60
    4fd8:	48 83       	st	Y, r20
    4fda:	59 83       	std	Y+1, r21	; 0x01
    4fdc:	6a 83       	std	Y+2, r22	; 0x02
    4fde:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4fe0:	ef 5b       	subi	r30, 0xBF	; 191
    4fe2:	ff 4f       	sbci	r31, 0xFF	; 255
    4fe4:	dd 96       	adiw	r26, 0x3d	; 61
    4fe6:	4d 91       	ld	r20, X+
    4fe8:	5d 91       	ld	r21, X+
    4fea:	6d 91       	ld	r22, X+
    4fec:	7c 91       	ld	r23, X
    4fee:	40 83       	st	Z, r20
    4ff0:	51 83       	std	Z+1, r21	; 0x01
    4ff2:	62 83       	std	Z+2, r22	; 0x02
    4ff4:	73 83       	std	Z+3, r23	; 0x03
		decode (message, XVEcefCms);
		decode (message, YVEcefCms);
		decode (message, ZVEcefCms);
		decode (message, PressureMillibars);
	}
}
    4ff6:	df 91       	pop	r29
    4ff8:	cf 91       	pop	r28
    4ffa:	08 95       	ret

00004ffc <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>:

SensorDataMessage* SensorDataMessage::buildMessageSt(byte *message)
{
    4ffc:	0f 93       	push	r16
    4ffe:	1f 93       	push	r17
    5000:	cf 93       	push	r28
    5002:	df 93       	push	r29
    5004:	8c 01       	movw	r16, r24
	SensorDataMessage *msg = new SensorDataMessage();
    5006:	85 e4       	ldi	r24, 0x45	; 69
    5008:	90 e0       	ldi	r25, 0x00	; 0
    500a:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    500e:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    5010:	84 e0       	ldi	r24, 0x04	; 4
    5012:	8a 83       	std	Y+2, r24	; 0x02
    5014:	81 e4       	ldi	r24, 0x41	; 65
    5016:	90 e0       	ldi	r25, 0x00	; 0
    5018:	9c 83       	std	Y+4, r25	; 0x04
    501a:	8b 83       	std	Y+3, r24	; 0x03
					YEcefCm(0),
					ZEcefCm(0),
					XVEcefCms(0),
					YVEcefCms(0),
					ZVEcefCms(0),
					PressureMillibars(0)
    501c:	8c e5       	ldi	r24, 0x5C	; 92
    501e:	92 e0       	ldi	r25, 0x02	; 2
    5020:	99 83       	std	Y+1, r25	; 0x01
    5022:	88 83       	st	Y, r24
    5024:	1d 82       	std	Y+5, r1	; 0x05
    5026:	1e 82       	std	Y+6, r1	; 0x06
    5028:	1f 82       	std	Y+7, r1	; 0x07
    502a:	18 86       	std	Y+8, r1	; 0x08
    502c:	19 86       	std	Y+9, r1	; 0x09
    502e:	1a 86       	std	Y+10, r1	; 0x0a
    5030:	1b 86       	std	Y+11, r1	; 0x0b
    5032:	1c 86       	std	Y+12, r1	; 0x0c
    5034:	1d 86       	std	Y+13, r1	; 0x0d
    5036:	1e 86       	std	Y+14, r1	; 0x0e
    5038:	1f 86       	std	Y+15, r1	; 0x0f
    503a:	18 8a       	std	Y+16, r1	; 0x10
    503c:	19 8a       	std	Y+17, r1	; 0x11
    503e:	1a 8a       	std	Y+18, r1	; 0x12
    5040:	1b 8a       	std	Y+19, r1	; 0x13
    5042:	1c 8a       	std	Y+20, r1	; 0x14
    5044:	1d 8a       	std	Y+21, r1	; 0x15
    5046:	1e 8a       	std	Y+22, r1	; 0x16
    5048:	1f 8a       	std	Y+23, r1	; 0x17
    504a:	18 8e       	std	Y+24, r1	; 0x18
    504c:	19 8e       	std	Y+25, r1	; 0x19
    504e:	1a 8e       	std	Y+26, r1	; 0x1a
    5050:	1b 8e       	std	Y+27, r1	; 0x1b
    5052:	1c 8e       	std	Y+28, r1	; 0x1c
    5054:	1d 8e       	std	Y+29, r1	; 0x1d
    5056:	1e 8e       	std	Y+30, r1	; 0x1e
    5058:	1f 8e       	std	Y+31, r1	; 0x1f
    505a:	18 a2       	std	Y+32, r1	; 0x20
    505c:	19 a2       	std	Y+33, r1	; 0x21
    505e:	1a a2       	std	Y+34, r1	; 0x22
    5060:	1b a2       	std	Y+35, r1	; 0x23
    5062:	1c a2       	std	Y+36, r1	; 0x24
    5064:	1d a2       	std	Y+37, r1	; 0x25
    5066:	1e a2       	std	Y+38, r1	; 0x26
    5068:	1f a2       	std	Y+39, r1	; 0x27
    506a:	18 a6       	std	Y+40, r1	; 0x28
    506c:	19 a6       	std	Y+41, r1	; 0x29
    506e:	1a a6       	std	Y+42, r1	; 0x2a
    5070:	1b a6       	std	Y+43, r1	; 0x2b
    5072:	1c a6       	std	Y+44, r1	; 0x2c
    5074:	1d a6       	std	Y+45, r1	; 0x2d
    5076:	1e a6       	std	Y+46, r1	; 0x2e
    5078:	1f a6       	std	Y+47, r1	; 0x2f
    507a:	18 aa       	std	Y+48, r1	; 0x30
    507c:	19 aa       	std	Y+49, r1	; 0x31
    507e:	1a aa       	std	Y+50, r1	; 0x32
    5080:	1b aa       	std	Y+51, r1	; 0x33
    5082:	1c aa       	std	Y+52, r1	; 0x34
    5084:	1d aa       	std	Y+53, r1	; 0x35
    5086:	1e aa       	std	Y+54, r1	; 0x36
    5088:	1f aa       	std	Y+55, r1	; 0x37
    508a:	18 ae       	std	Y+56, r1	; 0x38
    508c:	19 ae       	std	Y+57, r1	; 0x39
    508e:	1a ae       	std	Y+58, r1	; 0x3a
    5090:	1b ae       	std	Y+59, r1	; 0x3b
    5092:	1c ae       	std	Y+60, r1	; 0x3c
    5094:	fe 01       	movw	r30, r28
    5096:	fd 96       	adiw	r30, 0x3d	; 61
    5098:	10 82       	st	Z, r1
    509a:	11 82       	std	Z+1, r1	; 0x01
    509c:	12 82       	std	Z+2, r1	; 0x02
    509e:	13 82       	std	Z+3, r1	; 0x03
    50a0:	fe 01       	movw	r30, r28
    50a2:	ef 5b       	subi	r30, 0xBF	; 191
    50a4:	ff 4f       	sbci	r31, 0xFF	; 255
    50a6:	10 82       	st	Z, r1
    50a8:	11 82       	std	Z+1, r1	; 0x01
    50aa:	12 82       	std	Z+2, r1	; 0x02
    50ac:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    50ae:	b8 01       	movw	r22, r16
    50b0:	ce 01       	movw	r24, r28
    50b2:	0e 94 4f 27 	call	0x4e9e	; 0x4e9e <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
	
	return msg;
    50b6:	8c 2f       	mov	r24, r28
    50b8:	9d 2f       	mov	r25, r29
    50ba:	df 91       	pop	r29
    50bc:	cf 91       	pop	r28
    50be:	1f 91       	pop	r17
    50c0:	0f 91       	pop	r16
    50c2:	08 95       	ret

000050c4 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    50c4:	20 e5       	ldi	r18, 0x50	; 80
    50c6:	32 e0       	ldi	r19, 0x02	; 2
    50c8:	fc 01       	movw	r30, r24
    50ca:	31 83       	std	Z+1, r19	; 0x01
    50cc:	20 83       	st	Z, r18
    50ce:	08 95       	ret

000050d0 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>:
    50d0:	20 e5       	ldi	r18, 0x50	; 80
    50d2:	32 e0       	ldi	r19, 0x02	; 2
    50d4:	fc 01       	movw	r30, r24
    50d6:	31 83       	std	Z+1, r19	; 0x01
    50d8:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SimpleTelemetryMessage() {}
    50da:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    50de:	08 95       	ret

000050e0 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SimpleTelemetryMessage::getBytes()
{
    50e0:	cf 93       	push	r28
    50e2:	df 93       	push	r29
    50e4:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    50e6:	89 e7       	ldi	r24, 0x79	; 121
    50e8:	90 e0       	ldi	r25, 0x00	; 0
    50ea:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    50ee:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    50f0:	8a 81       	ldd	r24, Y+2	; 0x02
    50f2:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    50f4:	8d 81       	ldd	r24, Y+5	; 0x05
    50f6:	9e 81       	ldd	r25, Y+6	; 0x06
    50f8:	af 81       	ldd	r26, Y+7	; 0x07
    50fa:	b8 85       	ldd	r27, Y+8	; 0x08
    50fc:	81 83       	std	Z+1, r24	; 0x01
    50fe:	92 83       	std	Z+2, r25	; 0x02
    5100:	a3 83       	std	Z+3, r26	; 0x03
    5102:	b4 83       	std	Z+4, r27	; 0x04
    5104:	89 85       	ldd	r24, Y+9	; 0x09
    5106:	9a 85       	ldd	r25, Y+10	; 0x0a
    5108:	ab 85       	ldd	r26, Y+11	; 0x0b
    510a:	bc 85       	ldd	r27, Y+12	; 0x0c
    510c:	85 83       	std	Z+5, r24	; 0x05
    510e:	96 83       	std	Z+6, r25	; 0x06
    5110:	a7 83       	std	Z+7, r26	; 0x07
    5112:	b0 87       	std	Z+8, r27	; 0x08
    5114:	8d 85       	ldd	r24, Y+13	; 0x0d
    5116:	9e 85       	ldd	r25, Y+14	; 0x0e
    5118:	af 85       	ldd	r26, Y+15	; 0x0f
    511a:	b8 89       	ldd	r27, Y+16	; 0x10
    511c:	81 87       	std	Z+9, r24	; 0x09
    511e:	92 87       	std	Z+10, r25	; 0x0a
    5120:	a3 87       	std	Z+11, r26	; 0x0b
    5122:	b4 87       	std	Z+12, r27	; 0x0c
    5124:	89 89       	ldd	r24, Y+17	; 0x11
    5126:	9a 89       	ldd	r25, Y+18	; 0x12
    5128:	ab 89       	ldd	r26, Y+19	; 0x13
    512a:	bc 89       	ldd	r27, Y+20	; 0x14
    512c:	85 87       	std	Z+13, r24	; 0x0d
    512e:	96 87       	std	Z+14, r25	; 0x0e
    5130:	a7 87       	std	Z+15, r26	; 0x0f
    5132:	b0 8b       	std	Z+16, r27	; 0x10
    5134:	8d 89       	ldd	r24, Y+21	; 0x15
    5136:	9e 89       	ldd	r25, Y+22	; 0x16
    5138:	af 89       	ldd	r26, Y+23	; 0x17
    513a:	b8 8d       	ldd	r27, Y+24	; 0x18
    513c:	81 8b       	std	Z+17, r24	; 0x11
    513e:	92 8b       	std	Z+18, r25	; 0x12
    5140:	a3 8b       	std	Z+19, r26	; 0x13
    5142:	b4 8b       	std	Z+20, r27	; 0x14
    5144:	89 8d       	ldd	r24, Y+25	; 0x19
    5146:	9a 8d       	ldd	r25, Y+26	; 0x1a
    5148:	ab 8d       	ldd	r26, Y+27	; 0x1b
    514a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    514c:	85 8b       	std	Z+21, r24	; 0x15
    514e:	96 8b       	std	Z+22, r25	; 0x16
    5150:	a7 8b       	std	Z+23, r26	; 0x17
    5152:	b0 8f       	std	Z+24, r27	; 0x18
    5154:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5156:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5158:	af 8d       	ldd	r26, Y+31	; 0x1f
    515a:	b8 a1       	ldd	r27, Y+32	; 0x20
    515c:	81 8f       	std	Z+25, r24	; 0x19
    515e:	92 8f       	std	Z+26, r25	; 0x1a
    5160:	a3 8f       	std	Z+27, r26	; 0x1b
    5162:	b4 8f       	std	Z+28, r27	; 0x1c
    5164:	89 a1       	ldd	r24, Y+33	; 0x21
    5166:	9a a1       	ldd	r25, Y+34	; 0x22
    5168:	ab a1       	ldd	r26, Y+35	; 0x23
    516a:	bc a1       	ldd	r27, Y+36	; 0x24
    516c:	85 8f       	std	Z+29, r24	; 0x1d
    516e:	96 8f       	std	Z+30, r25	; 0x1e
    5170:	a7 8f       	std	Z+31, r26	; 0x1f
    5172:	b0 a3       	std	Z+32, r27	; 0x20
    5174:	8d a1       	ldd	r24, Y+37	; 0x25
    5176:	9e a1       	ldd	r25, Y+38	; 0x26
    5178:	af a1       	ldd	r26, Y+39	; 0x27
    517a:	b8 a5       	ldd	r27, Y+40	; 0x28
    517c:	81 a3       	std	Z+33, r24	; 0x21
    517e:	92 a3       	std	Z+34, r25	; 0x22
    5180:	a3 a3       	std	Z+35, r26	; 0x23
    5182:	b4 a3       	std	Z+36, r27	; 0x24
    5184:	89 a5       	ldd	r24, Y+41	; 0x29
    5186:	9a a5       	ldd	r25, Y+42	; 0x2a
    5188:	ab a5       	ldd	r26, Y+43	; 0x2b
    518a:	bc a5       	ldd	r27, Y+44	; 0x2c
    518c:	85 a3       	std	Z+37, r24	; 0x25
    518e:	96 a3       	std	Z+38, r25	; 0x26
    5190:	a7 a3       	std	Z+39, r26	; 0x27
    5192:	b0 a7       	std	Z+40, r27	; 0x28
    5194:	8d a5       	ldd	r24, Y+45	; 0x2d
    5196:	9e a5       	ldd	r25, Y+46	; 0x2e
    5198:	af a5       	ldd	r26, Y+47	; 0x2f
    519a:	b8 a9       	ldd	r27, Y+48	; 0x30
    519c:	81 a7       	std	Z+41, r24	; 0x29
    519e:	92 a7       	std	Z+42, r25	; 0x2a
    51a0:	a3 a7       	std	Z+43, r26	; 0x2b
    51a2:	b4 a7       	std	Z+44, r27	; 0x2c
    51a4:	89 a9       	ldd	r24, Y+49	; 0x31
    51a6:	9a a9       	ldd	r25, Y+50	; 0x32
    51a8:	ab a9       	ldd	r26, Y+51	; 0x33
    51aa:	bc a9       	ldd	r27, Y+52	; 0x34
    51ac:	85 a7       	std	Z+45, r24	; 0x2d
    51ae:	96 a7       	std	Z+46, r25	; 0x2e
    51b0:	a7 a7       	std	Z+47, r26	; 0x2f
    51b2:	b0 ab       	std	Z+48, r27	; 0x30
    51b4:	8d a9       	ldd	r24, Y+53	; 0x35
    51b6:	9e a9       	ldd	r25, Y+54	; 0x36
    51b8:	af a9       	ldd	r26, Y+55	; 0x37
    51ba:	b8 ad       	ldd	r27, Y+56	; 0x38
    51bc:	81 ab       	std	Z+49, r24	; 0x31
    51be:	92 ab       	std	Z+50, r25	; 0x32
    51c0:	a3 ab       	std	Z+51, r26	; 0x33
    51c2:	b4 ab       	std	Z+52, r27	; 0x34
    51c4:	89 ad       	ldd	r24, Y+57	; 0x39
    51c6:	9a ad       	ldd	r25, Y+58	; 0x3a
    51c8:	ab ad       	ldd	r26, Y+59	; 0x3b
    51ca:	bc ad       	ldd	r27, Y+60	; 0x3c
    51cc:	85 ab       	std	Z+53, r24	; 0x35
    51ce:	96 ab       	std	Z+54, r25	; 0x36
    51d0:	a7 ab       	std	Z+55, r26	; 0x37
    51d2:	b0 af       	std	Z+56, r27	; 0x38
    51d4:	de 01       	movw	r26, r28
    51d6:	dd 96       	adiw	r26, 0x3d	; 61
    51d8:	8d 91       	ld	r24, X+
    51da:	9d 91       	ld	r25, X+
    51dc:	0d 90       	ld	r0, X+
    51de:	bc 91       	ld	r27, X
    51e0:	a0 2d       	mov	r26, r0
    51e2:	81 af       	std	Z+57, r24	; 0x39
    51e4:	92 af       	std	Z+58, r25	; 0x3a
    51e6:	a3 af       	std	Z+59, r26	; 0x3b
    51e8:	b4 af       	std	Z+60, r27	; 0x3c
    51ea:	9f 01       	movw	r18, r30
    51ec:	23 5c       	subi	r18, 0xC3	; 195
    51ee:	3f 4f       	sbci	r19, 0xFF	; 255
    51f0:	de 01       	movw	r26, r28
    51f2:	af 5b       	subi	r26, 0xBF	; 191
    51f4:	bf 4f       	sbci	r27, 0xFF	; 255
    51f6:	4d 91       	ld	r20, X+
    51f8:	5d 91       	ld	r21, X+
    51fa:	6d 91       	ld	r22, X+
    51fc:	7c 91       	ld	r23, X
    51fe:	d9 01       	movw	r26, r18
    5200:	4d 93       	st	X+, r20
    5202:	5d 93       	st	X+, r21
    5204:	6d 93       	st	X+, r22
    5206:	7c 93       	st	X, r23
    5208:	13 97       	sbiw	r26, 0x03	; 3
    520a:	9f 01       	movw	r18, r30
    520c:	2f 5b       	subi	r18, 0xBF	; 191
    520e:	3f 4f       	sbci	r19, 0xFF	; 255
    5210:	de 01       	movw	r26, r28
    5212:	ab 5b       	subi	r26, 0xBB	; 187
    5214:	bf 4f       	sbci	r27, 0xFF	; 255
    5216:	4d 91       	ld	r20, X+
    5218:	5d 91       	ld	r21, X+
    521a:	6d 91       	ld	r22, X+
    521c:	7c 91       	ld	r23, X
    521e:	d9 01       	movw	r26, r18
    5220:	4d 93       	st	X+, r20
    5222:	5d 93       	st	X+, r21
    5224:	6d 93       	st	X+, r22
    5226:	7c 93       	st	X, r23
    5228:	13 97       	sbiw	r26, 0x03	; 3
    522a:	9f 01       	movw	r18, r30
    522c:	2b 5b       	subi	r18, 0xBB	; 187
    522e:	3f 4f       	sbci	r19, 0xFF	; 255
    5230:	de 01       	movw	r26, r28
    5232:	a7 5b       	subi	r26, 0xB7	; 183
    5234:	bf 4f       	sbci	r27, 0xFF	; 255
    5236:	4d 91       	ld	r20, X+
    5238:	5d 91       	ld	r21, X+
    523a:	6d 91       	ld	r22, X+
    523c:	7c 91       	ld	r23, X
    523e:	d9 01       	movw	r26, r18
    5240:	4d 93       	st	X+, r20
    5242:	5d 93       	st	X+, r21
    5244:	6d 93       	st	X+, r22
    5246:	7c 93       	st	X, r23
    5248:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    524a:	9f 01       	movw	r18, r30
    524c:	27 5b       	subi	r18, 0xB7	; 183
    524e:	3f 4f       	sbci	r19, 0xFF	; 255
    5250:	de 01       	movw	r26, r28
    5252:	a3 5b       	subi	r26, 0xB3	; 179
    5254:	bf 4f       	sbci	r27, 0xFF	; 255
    5256:	4d 91       	ld	r20, X+
    5258:	5d 91       	ld	r21, X+
    525a:	6d 91       	ld	r22, X+
    525c:	7c 91       	ld	r23, X
    525e:	d9 01       	movw	r26, r18
    5260:	4d 93       	st	X+, r20
    5262:	5d 93       	st	X+, r21
    5264:	6d 93       	st	X+, r22
    5266:	7c 93       	st	X, r23
    5268:	13 97       	sbiw	r26, 0x03	; 3
    526a:	9f 01       	movw	r18, r30
    526c:	23 5b       	subi	r18, 0xB3	; 179
    526e:	3f 4f       	sbci	r19, 0xFF	; 255
    5270:	de 01       	movw	r26, r28
    5272:	af 5a       	subi	r26, 0xAF	; 175
    5274:	bf 4f       	sbci	r27, 0xFF	; 255
    5276:	4d 91       	ld	r20, X+
    5278:	5d 91       	ld	r21, X+
    527a:	6d 91       	ld	r22, X+
    527c:	7c 91       	ld	r23, X
    527e:	d9 01       	movw	r26, r18
    5280:	4d 93       	st	X+, r20
    5282:	5d 93       	st	X+, r21
    5284:	6d 93       	st	X+, r22
    5286:	7c 93       	st	X, r23
    5288:	13 97       	sbiw	r26, 0x03	; 3
    528a:	9f 01       	movw	r18, r30
    528c:	2f 5a       	subi	r18, 0xAF	; 175
    528e:	3f 4f       	sbci	r19, 0xFF	; 255
    5290:	de 01       	movw	r26, r28
    5292:	ab 5a       	subi	r26, 0xAB	; 171
    5294:	bf 4f       	sbci	r27, 0xFF	; 255
    5296:	4d 91       	ld	r20, X+
    5298:	5d 91       	ld	r21, X+
    529a:	6d 91       	ld	r22, X+
    529c:	7c 91       	ld	r23, X
    529e:	d9 01       	movw	r26, r18
    52a0:	4d 93       	st	X+, r20
    52a2:	5d 93       	st	X+, r21
    52a4:	6d 93       	st	X+, r22
    52a6:	7c 93       	st	X, r23
    52a8:	13 97       	sbiw	r26, 0x03	; 3
    52aa:	9f 01       	movw	r18, r30
    52ac:	2b 5a       	subi	r18, 0xAB	; 171
    52ae:	3f 4f       	sbci	r19, 0xFF	; 255
    52b0:	de 01       	movw	r26, r28
    52b2:	a7 5a       	subi	r26, 0xA7	; 167
    52b4:	bf 4f       	sbci	r27, 0xFF	; 255
    52b6:	4d 91       	ld	r20, X+
    52b8:	5d 91       	ld	r21, X+
    52ba:	6d 91       	ld	r22, X+
    52bc:	7c 91       	ld	r23, X
    52be:	d9 01       	movw	r26, r18
    52c0:	4d 93       	st	X+, r20
    52c2:	5d 93       	st	X+, r21
    52c4:	6d 93       	st	X+, r22
    52c6:	7c 93       	st	X, r23
    52c8:	13 97       	sbiw	r26, 0x03	; 3
    52ca:	9f 01       	movw	r18, r30
    52cc:	27 5a       	subi	r18, 0xA7	; 167
    52ce:	3f 4f       	sbci	r19, 0xFF	; 255
    52d0:	de 01       	movw	r26, r28
    52d2:	a3 5a       	subi	r26, 0xA3	; 163
    52d4:	bf 4f       	sbci	r27, 0xFF	; 255
    52d6:	4d 91       	ld	r20, X+
    52d8:	5d 91       	ld	r21, X+
    52da:	6d 91       	ld	r22, X+
    52dc:	7c 91       	ld	r23, X
    52de:	d9 01       	movw	r26, r18
    52e0:	4d 93       	st	X+, r20
    52e2:	5d 93       	st	X+, r21
    52e4:	6d 93       	st	X+, r22
    52e6:	7c 93       	st	X, r23
    52e8:	13 97       	sbiw	r26, 0x03	; 3
    52ea:	9f 01       	movw	r18, r30
    52ec:	23 5a       	subi	r18, 0xA3	; 163
    52ee:	3f 4f       	sbci	r19, 0xFF	; 255
    52f0:	de 01       	movw	r26, r28
    52f2:	af 59       	subi	r26, 0x9F	; 159
    52f4:	bf 4f       	sbci	r27, 0xFF	; 255
    52f6:	4d 91       	ld	r20, X+
    52f8:	5d 91       	ld	r21, X+
    52fa:	6d 91       	ld	r22, X+
    52fc:	7c 91       	ld	r23, X
    52fe:	d9 01       	movw	r26, r18
    5300:	4d 93       	st	X+, r20
    5302:	5d 93       	st	X+, r21
    5304:	6d 93       	st	X+, r22
    5306:	7c 93       	st	X, r23
    5308:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    530a:	9f 01       	movw	r18, r30
    530c:	2f 59       	subi	r18, 0x9F	; 159
    530e:	3f 4f       	sbci	r19, 0xFF	; 255
    5310:	de 01       	movw	r26, r28
    5312:	ab 59       	subi	r26, 0x9B	; 155
    5314:	bf 4f       	sbci	r27, 0xFF	; 255
    5316:	4d 91       	ld	r20, X+
    5318:	5d 91       	ld	r21, X+
    531a:	6d 91       	ld	r22, X+
    531c:	7c 91       	ld	r23, X
    531e:	d9 01       	movw	r26, r18
    5320:	4d 93       	st	X+, r20
    5322:	5d 93       	st	X+, r21
    5324:	6d 93       	st	X+, r22
    5326:	7c 93       	st	X, r23
    5328:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    532a:	9f 01       	movw	r18, r30
    532c:	2b 59       	subi	r18, 0x9B	; 155
    532e:	3f 4f       	sbci	r19, 0xFF	; 255
    5330:	de 01       	movw	r26, r28
    5332:	a7 59       	subi	r26, 0x97	; 151
    5334:	bf 4f       	sbci	r27, 0xFF	; 255
    5336:	4d 91       	ld	r20, X+
    5338:	5d 91       	ld	r21, X+
    533a:	6d 91       	ld	r22, X+
    533c:	7c 91       	ld	r23, X
    533e:	d9 01       	movw	r26, r18
    5340:	4d 93       	st	X+, r20
    5342:	5d 93       	st	X+, r21
    5344:	6d 93       	st	X+, r22
    5346:	7c 93       	st	X, r23
    5348:	13 97       	sbiw	r26, 0x03	; 3
    534a:	9f 01       	movw	r18, r30
    534c:	27 59       	subi	r18, 0x97	; 151
    534e:	3f 4f       	sbci	r19, 0xFF	; 255
    5350:	de 01       	movw	r26, r28
    5352:	a3 59       	subi	r26, 0x93	; 147
    5354:	bf 4f       	sbci	r27, 0xFF	; 255
    5356:	4d 91       	ld	r20, X+
    5358:	5d 91       	ld	r21, X+
    535a:	6d 91       	ld	r22, X+
    535c:	7c 91       	ld	r23, X
    535e:	d9 01       	movw	r26, r18
    5360:	4d 93       	st	X+, r20
    5362:	5d 93       	st	X+, r21
    5364:	6d 93       	st	X+, r22
    5366:	7c 93       	st	X, r23
    5368:	13 97       	sbiw	r26, 0x03	; 3
    536a:	9f 01       	movw	r18, r30
    536c:	23 59       	subi	r18, 0x93	; 147
    536e:	3f 4f       	sbci	r19, 0xFF	; 255
    5370:	ce 01       	movw	r24, r28
    5372:	8f 58       	subi	r24, 0x8F	; 143
    5374:	9f 4f       	sbci	r25, 0xFF	; 255
    5376:	dc 01       	movw	r26, r24
    5378:	4d 91       	ld	r20, X+
    537a:	5d 91       	ld	r21, X+
    537c:	6d 91       	ld	r22, X+
    537e:	7c 91       	ld	r23, X
    5380:	d9 01       	movw	r26, r18
    5382:	4d 93       	st	X+, r20
    5384:	5d 93       	st	X+, r21
    5386:	6d 93       	st	X+, r22
    5388:	7c 93       	st	X, r23
    538a:	13 97       	sbiw	r26, 0x03	; 3
    538c:	9f 01       	movw	r18, r30
    538e:	2f 58       	subi	r18, 0x8F	; 143
    5390:	3f 4f       	sbci	r19, 0xFF	; 255
    5392:	ce 01       	movw	r24, r28
    5394:	8b 58       	subi	r24, 0x8B	; 139
    5396:	9f 4f       	sbci	r25, 0xFF	; 255
    5398:	dc 01       	movw	r26, r24
    539a:	4d 91       	ld	r20, X+
    539c:	5d 91       	ld	r21, X+
    539e:	6d 91       	ld	r22, X+
    53a0:	7c 91       	ld	r23, X
    53a2:	d9 01       	movw	r26, r18
    53a4:	4d 93       	st	X+, r20
    53a6:	5d 93       	st	X+, r21
    53a8:	6d 93       	st	X+, r22
    53aa:	7c 93       	st	X, r23
    53ac:	13 97       	sbiw	r26, 0x03	; 3
    53ae:	df 01       	movw	r26, r30
    53b0:	ab 58       	subi	r26, 0x8B	; 139
    53b2:	bf 4f       	sbci	r27, 0xFF	; 255
    53b4:	c7 58       	subi	r28, 0x87	; 135
    53b6:	df 4f       	sbci	r29, 0xFF	; 255
    53b8:	48 81       	ld	r20, Y
    53ba:	59 81       	ldd	r21, Y+1	; 0x01
    53bc:	6a 81       	ldd	r22, Y+2	; 0x02
    53be:	7b 81       	ldd	r23, Y+3	; 0x03
    53c0:	4d 93       	st	X+, r20
    53c2:	5d 93       	st	X+, r21
    53c4:	6d 93       	st	X+, r22
    53c6:	7c 93       	st	X, r23
    53c8:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
	
	return msg;
}
    53ca:	8e 2f       	mov	r24, r30
    53cc:	9f 2f       	mov	r25, r31
    53ce:	df 91       	pop	r29
    53d0:	cf 91       	pop	r28
    53d2:	08 95       	ret

000053d4 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>:

void SimpleTelemetryMessage::buildMessage(byte *message)
{
    53d4:	cf 93       	push	r28
    53d6:	df 93       	push	r29
    53d8:	fc 01       	movw	r30, r24
    53da:	db 01       	movw	r26, r22
	if (message != NULL)
    53dc:	10 97       	sbiw	r26, 0x00	; 0
    53de:	09 f4       	brne	.+2      	; 0x53e2 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0xe>
    53e0:	85 c1       	rjmp	.+778    	; 0x56ec <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0x318>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    53e2:	8c 91       	ld	r24, X
    53e4:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    53e6:	11 96       	adiw	r26, 0x01	; 1
    53e8:	4d 91       	ld	r20, X+
    53ea:	5d 91       	ld	r21, X+
    53ec:	6d 91       	ld	r22, X+
    53ee:	7c 91       	ld	r23, X
    53f0:	14 97       	sbiw	r26, 0x04	; 4
    53f2:	45 83       	std	Z+5, r20	; 0x05
    53f4:	56 83       	std	Z+6, r21	; 0x06
    53f6:	67 83       	std	Z+7, r22	; 0x07
    53f8:	70 87       	std	Z+8, r23	; 0x08
    53fa:	15 96       	adiw	r26, 0x05	; 5
    53fc:	4d 91       	ld	r20, X+
    53fe:	5d 91       	ld	r21, X+
    5400:	6d 91       	ld	r22, X+
    5402:	7c 91       	ld	r23, X
    5404:	18 97       	sbiw	r26, 0x08	; 8
    5406:	41 87       	std	Z+9, r20	; 0x09
    5408:	52 87       	std	Z+10, r21	; 0x0a
    540a:	63 87       	std	Z+11, r22	; 0x0b
    540c:	74 87       	std	Z+12, r23	; 0x0c
    540e:	19 96       	adiw	r26, 0x09	; 9
    5410:	4d 91       	ld	r20, X+
    5412:	5d 91       	ld	r21, X+
    5414:	6d 91       	ld	r22, X+
    5416:	7c 91       	ld	r23, X
    5418:	1c 97       	sbiw	r26, 0x0c	; 12
    541a:	45 87       	std	Z+13, r20	; 0x0d
    541c:	56 87       	std	Z+14, r21	; 0x0e
    541e:	67 87       	std	Z+15, r22	; 0x0f
    5420:	70 8b       	std	Z+16, r23	; 0x10
    5422:	1d 96       	adiw	r26, 0x0d	; 13
    5424:	4d 91       	ld	r20, X+
    5426:	5d 91       	ld	r21, X+
    5428:	6d 91       	ld	r22, X+
    542a:	7c 91       	ld	r23, X
    542c:	50 97       	sbiw	r26, 0x10	; 16
    542e:	41 8b       	std	Z+17, r20	; 0x11
    5430:	52 8b       	std	Z+18, r21	; 0x12
    5432:	63 8b       	std	Z+19, r22	; 0x13
    5434:	74 8b       	std	Z+20, r23	; 0x14
    5436:	51 96       	adiw	r26, 0x11	; 17
    5438:	4d 91       	ld	r20, X+
    543a:	5d 91       	ld	r21, X+
    543c:	6d 91       	ld	r22, X+
    543e:	7c 91       	ld	r23, X
    5440:	54 97       	sbiw	r26, 0x14	; 20
    5442:	45 8b       	std	Z+21, r20	; 0x15
    5444:	56 8b       	std	Z+22, r21	; 0x16
    5446:	67 8b       	std	Z+23, r22	; 0x17
    5448:	70 8f       	std	Z+24, r23	; 0x18
    544a:	55 96       	adiw	r26, 0x15	; 21
    544c:	4d 91       	ld	r20, X+
    544e:	5d 91       	ld	r21, X+
    5450:	6d 91       	ld	r22, X+
    5452:	7c 91       	ld	r23, X
    5454:	58 97       	sbiw	r26, 0x18	; 24
    5456:	41 8f       	std	Z+25, r20	; 0x19
    5458:	52 8f       	std	Z+26, r21	; 0x1a
    545a:	63 8f       	std	Z+27, r22	; 0x1b
    545c:	74 8f       	std	Z+28, r23	; 0x1c
    545e:	59 96       	adiw	r26, 0x19	; 25
    5460:	4d 91       	ld	r20, X+
    5462:	5d 91       	ld	r21, X+
    5464:	6d 91       	ld	r22, X+
    5466:	7c 91       	ld	r23, X
    5468:	5c 97       	sbiw	r26, 0x1c	; 28
    546a:	45 8f       	std	Z+29, r20	; 0x1d
    546c:	56 8f       	std	Z+30, r21	; 0x1e
    546e:	67 8f       	std	Z+31, r22	; 0x1f
    5470:	70 a3       	std	Z+32, r23	; 0x20
    5472:	5d 96       	adiw	r26, 0x1d	; 29
    5474:	4d 91       	ld	r20, X+
    5476:	5d 91       	ld	r21, X+
    5478:	6d 91       	ld	r22, X+
    547a:	7c 91       	ld	r23, X
    547c:	90 97       	sbiw	r26, 0x20	; 32
    547e:	41 a3       	std	Z+33, r20	; 0x21
    5480:	52 a3       	std	Z+34, r21	; 0x22
    5482:	63 a3       	std	Z+35, r22	; 0x23
    5484:	74 a3       	std	Z+36, r23	; 0x24
    5486:	91 96       	adiw	r26, 0x21	; 33
    5488:	4d 91       	ld	r20, X+
    548a:	5d 91       	ld	r21, X+
    548c:	6d 91       	ld	r22, X+
    548e:	7c 91       	ld	r23, X
    5490:	94 97       	sbiw	r26, 0x24	; 36
    5492:	45 a3       	std	Z+37, r20	; 0x25
    5494:	56 a3       	std	Z+38, r21	; 0x26
    5496:	67 a3       	std	Z+39, r22	; 0x27
    5498:	70 a7       	std	Z+40, r23	; 0x28
    549a:	95 96       	adiw	r26, 0x25	; 37
    549c:	4d 91       	ld	r20, X+
    549e:	5d 91       	ld	r21, X+
    54a0:	6d 91       	ld	r22, X+
    54a2:	7c 91       	ld	r23, X
    54a4:	98 97       	sbiw	r26, 0x28	; 40
    54a6:	41 a7       	std	Z+41, r20	; 0x29
    54a8:	52 a7       	std	Z+42, r21	; 0x2a
    54aa:	63 a7       	std	Z+43, r22	; 0x2b
    54ac:	74 a7       	std	Z+44, r23	; 0x2c
    54ae:	99 96       	adiw	r26, 0x29	; 41
    54b0:	4d 91       	ld	r20, X+
    54b2:	5d 91       	ld	r21, X+
    54b4:	6d 91       	ld	r22, X+
    54b6:	7c 91       	ld	r23, X
    54b8:	9c 97       	sbiw	r26, 0x2c	; 44
    54ba:	45 a7       	std	Z+45, r20	; 0x2d
    54bc:	56 a7       	std	Z+46, r21	; 0x2e
    54be:	67 a7       	std	Z+47, r22	; 0x2f
    54c0:	70 ab       	std	Z+48, r23	; 0x30
    54c2:	9d 96       	adiw	r26, 0x2d	; 45
    54c4:	4d 91       	ld	r20, X+
    54c6:	5d 91       	ld	r21, X+
    54c8:	6d 91       	ld	r22, X+
    54ca:	7c 91       	ld	r23, X
    54cc:	d0 97       	sbiw	r26, 0x30	; 48
    54ce:	41 ab       	std	Z+49, r20	; 0x31
    54d0:	52 ab       	std	Z+50, r21	; 0x32
    54d2:	63 ab       	std	Z+51, r22	; 0x33
    54d4:	74 ab       	std	Z+52, r23	; 0x34
    54d6:	d1 96       	adiw	r26, 0x31	; 49
    54d8:	4d 91       	ld	r20, X+
    54da:	5d 91       	ld	r21, X+
    54dc:	6d 91       	ld	r22, X+
    54de:	7c 91       	ld	r23, X
    54e0:	d4 97       	sbiw	r26, 0x34	; 52
    54e2:	45 ab       	std	Z+53, r20	; 0x35
    54e4:	56 ab       	std	Z+54, r21	; 0x36
    54e6:	67 ab       	std	Z+55, r22	; 0x37
    54e8:	70 af       	std	Z+56, r23	; 0x38
    54ea:	d5 96       	adiw	r26, 0x35	; 53
    54ec:	4d 91       	ld	r20, X+
    54ee:	5d 91       	ld	r21, X+
    54f0:	6d 91       	ld	r22, X+
    54f2:	7c 91       	ld	r23, X
    54f4:	d8 97       	sbiw	r26, 0x38	; 56
    54f6:	41 af       	std	Z+57, r20	; 0x39
    54f8:	52 af       	std	Z+58, r21	; 0x3a
    54fa:	63 af       	std	Z+59, r22	; 0x3b
    54fc:	74 af       	std	Z+60, r23	; 0x3c
    54fe:	ef 01       	movw	r28, r30
    5500:	ed 96       	adiw	r28, 0x3d	; 61
    5502:	d9 96       	adiw	r26, 0x39	; 57
    5504:	4d 91       	ld	r20, X+
    5506:	5d 91       	ld	r21, X+
    5508:	6d 91       	ld	r22, X+
    550a:	7c 91       	ld	r23, X
    550c:	dc 97       	sbiw	r26, 0x3c	; 60
    550e:	48 83       	st	Y, r20
    5510:	59 83       	std	Y+1, r21	; 0x01
    5512:	6a 83       	std	Y+2, r22	; 0x02
    5514:	7b 83       	std	Y+3, r23	; 0x03
    5516:	9f 01       	movw	r18, r30
    5518:	2f 5b       	subi	r18, 0xBF	; 191
    551a:	3f 4f       	sbci	r19, 0xFF	; 255
    551c:	cd 01       	movw	r24, r26
    551e:	cd 96       	adiw	r24, 0x3d	; 61
    5520:	ec 01       	movw	r28, r24
    5522:	48 81       	ld	r20, Y
    5524:	59 81       	ldd	r21, Y+1	; 0x01
    5526:	6a 81       	ldd	r22, Y+2	; 0x02
    5528:	7b 81       	ldd	r23, Y+3	; 0x03
    552a:	e9 01       	movw	r28, r18
    552c:	48 83       	st	Y, r20
    552e:	59 83       	std	Y+1, r21	; 0x01
    5530:	6a 83       	std	Y+2, r22	; 0x02
    5532:	7b 83       	std	Y+3, r23	; 0x03
    5534:	9f 01       	movw	r18, r30
    5536:	2b 5b       	subi	r18, 0xBB	; 187
    5538:	3f 4f       	sbci	r19, 0xFF	; 255
    553a:	cd 01       	movw	r24, r26
    553c:	8f 5b       	subi	r24, 0xBF	; 191
    553e:	9f 4f       	sbci	r25, 0xFF	; 255
    5540:	ec 01       	movw	r28, r24
    5542:	48 81       	ld	r20, Y
    5544:	59 81       	ldd	r21, Y+1	; 0x01
    5546:	6a 81       	ldd	r22, Y+2	; 0x02
    5548:	7b 81       	ldd	r23, Y+3	; 0x03
    554a:	e9 01       	movw	r28, r18
    554c:	48 83       	st	Y, r20
    554e:	59 83       	std	Y+1, r21	; 0x01
    5550:	6a 83       	std	Y+2, r22	; 0x02
    5552:	7b 83       	std	Y+3, r23	; 0x03
    5554:	9f 01       	movw	r18, r30
    5556:	27 5b       	subi	r18, 0xB7	; 183
    5558:	3f 4f       	sbci	r19, 0xFF	; 255
    555a:	cd 01       	movw	r24, r26
    555c:	8b 5b       	subi	r24, 0xBB	; 187
    555e:	9f 4f       	sbci	r25, 0xFF	; 255
    5560:	ec 01       	movw	r28, r24
    5562:	48 81       	ld	r20, Y
    5564:	59 81       	ldd	r21, Y+1	; 0x01
    5566:	6a 81       	ldd	r22, Y+2	; 0x02
    5568:	7b 81       	ldd	r23, Y+3	; 0x03
    556a:	e9 01       	movw	r28, r18
    556c:	48 83       	st	Y, r20
    556e:	59 83       	std	Y+1, r21	; 0x01
    5570:	6a 83       	std	Y+2, r22	; 0x02
    5572:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5574:	9f 01       	movw	r18, r30
    5576:	23 5b       	subi	r18, 0xB3	; 179
    5578:	3f 4f       	sbci	r19, 0xFF	; 255
    557a:	cd 01       	movw	r24, r26
    557c:	87 5b       	subi	r24, 0xB7	; 183
    557e:	9f 4f       	sbci	r25, 0xFF	; 255
    5580:	ec 01       	movw	r28, r24
    5582:	48 81       	ld	r20, Y
    5584:	59 81       	ldd	r21, Y+1	; 0x01
    5586:	6a 81       	ldd	r22, Y+2	; 0x02
    5588:	7b 81       	ldd	r23, Y+3	; 0x03
    558a:	e9 01       	movw	r28, r18
    558c:	48 83       	st	Y, r20
    558e:	59 83       	std	Y+1, r21	; 0x01
    5590:	6a 83       	std	Y+2, r22	; 0x02
    5592:	7b 83       	std	Y+3, r23	; 0x03
    5594:	9f 01       	movw	r18, r30
    5596:	2f 5a       	subi	r18, 0xAF	; 175
    5598:	3f 4f       	sbci	r19, 0xFF	; 255
    559a:	cd 01       	movw	r24, r26
    559c:	83 5b       	subi	r24, 0xB3	; 179
    559e:	9f 4f       	sbci	r25, 0xFF	; 255
    55a0:	ec 01       	movw	r28, r24
    55a2:	48 81       	ld	r20, Y
    55a4:	59 81       	ldd	r21, Y+1	; 0x01
    55a6:	6a 81       	ldd	r22, Y+2	; 0x02
    55a8:	7b 81       	ldd	r23, Y+3	; 0x03
    55aa:	e9 01       	movw	r28, r18
    55ac:	48 83       	st	Y, r20
    55ae:	59 83       	std	Y+1, r21	; 0x01
    55b0:	6a 83       	std	Y+2, r22	; 0x02
    55b2:	7b 83       	std	Y+3, r23	; 0x03
    55b4:	9f 01       	movw	r18, r30
    55b6:	2b 5a       	subi	r18, 0xAB	; 171
    55b8:	3f 4f       	sbci	r19, 0xFF	; 255
    55ba:	cd 01       	movw	r24, r26
    55bc:	8f 5a       	subi	r24, 0xAF	; 175
    55be:	9f 4f       	sbci	r25, 0xFF	; 255
    55c0:	ec 01       	movw	r28, r24
    55c2:	48 81       	ld	r20, Y
    55c4:	59 81       	ldd	r21, Y+1	; 0x01
    55c6:	6a 81       	ldd	r22, Y+2	; 0x02
    55c8:	7b 81       	ldd	r23, Y+3	; 0x03
    55ca:	e9 01       	movw	r28, r18
    55cc:	48 83       	st	Y, r20
    55ce:	59 83       	std	Y+1, r21	; 0x01
    55d0:	6a 83       	std	Y+2, r22	; 0x02
    55d2:	7b 83       	std	Y+3, r23	; 0x03
    55d4:	9f 01       	movw	r18, r30
    55d6:	27 5a       	subi	r18, 0xA7	; 167
    55d8:	3f 4f       	sbci	r19, 0xFF	; 255
    55da:	cd 01       	movw	r24, r26
    55dc:	8b 5a       	subi	r24, 0xAB	; 171
    55de:	9f 4f       	sbci	r25, 0xFF	; 255
    55e0:	ec 01       	movw	r28, r24
    55e2:	48 81       	ld	r20, Y
    55e4:	59 81       	ldd	r21, Y+1	; 0x01
    55e6:	6a 81       	ldd	r22, Y+2	; 0x02
    55e8:	7b 81       	ldd	r23, Y+3	; 0x03
    55ea:	e9 01       	movw	r28, r18
    55ec:	48 83       	st	Y, r20
    55ee:	59 83       	std	Y+1, r21	; 0x01
    55f0:	6a 83       	std	Y+2, r22	; 0x02
    55f2:	7b 83       	std	Y+3, r23	; 0x03
    55f4:	9f 01       	movw	r18, r30
    55f6:	23 5a       	subi	r18, 0xA3	; 163
    55f8:	3f 4f       	sbci	r19, 0xFF	; 255
    55fa:	cd 01       	movw	r24, r26
    55fc:	87 5a       	subi	r24, 0xA7	; 167
    55fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5600:	ec 01       	movw	r28, r24
    5602:	48 81       	ld	r20, Y
    5604:	59 81       	ldd	r21, Y+1	; 0x01
    5606:	6a 81       	ldd	r22, Y+2	; 0x02
    5608:	7b 81       	ldd	r23, Y+3	; 0x03
    560a:	e9 01       	movw	r28, r18
    560c:	48 83       	st	Y, r20
    560e:	59 83       	std	Y+1, r21	; 0x01
    5610:	6a 83       	std	Y+2, r22	; 0x02
    5612:	7b 83       	std	Y+3, r23	; 0x03
    5614:	9f 01       	movw	r18, r30
    5616:	2f 59       	subi	r18, 0x9F	; 159
    5618:	3f 4f       	sbci	r19, 0xFF	; 255
    561a:	cd 01       	movw	r24, r26
    561c:	83 5a       	subi	r24, 0xA3	; 163
    561e:	9f 4f       	sbci	r25, 0xFF	; 255
    5620:	ec 01       	movw	r28, r24
    5622:	48 81       	ld	r20, Y
    5624:	59 81       	ldd	r21, Y+1	; 0x01
    5626:	6a 81       	ldd	r22, Y+2	; 0x02
    5628:	7b 81       	ldd	r23, Y+3	; 0x03
    562a:	e9 01       	movw	r28, r18
    562c:	48 83       	st	Y, r20
    562e:	59 83       	std	Y+1, r21	; 0x01
    5630:	6a 83       	std	Y+2, r22	; 0x02
    5632:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5634:	9f 01       	movw	r18, r30
    5636:	2b 59       	subi	r18, 0x9B	; 155
    5638:	3f 4f       	sbci	r19, 0xFF	; 255
    563a:	cd 01       	movw	r24, r26
    563c:	8f 59       	subi	r24, 0x9F	; 159
    563e:	9f 4f       	sbci	r25, 0xFF	; 255
    5640:	ec 01       	movw	r28, r24
    5642:	48 81       	ld	r20, Y
    5644:	59 81       	ldd	r21, Y+1	; 0x01
    5646:	6a 81       	ldd	r22, Y+2	; 0x02
    5648:	7b 81       	ldd	r23, Y+3	; 0x03
    564a:	e9 01       	movw	r28, r18
    564c:	48 83       	st	Y, r20
    564e:	59 83       	std	Y+1, r21	; 0x01
    5650:	6a 83       	std	Y+2, r22	; 0x02
    5652:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5654:	9f 01       	movw	r18, r30
    5656:	27 59       	subi	r18, 0x97	; 151
    5658:	3f 4f       	sbci	r19, 0xFF	; 255
    565a:	cd 01       	movw	r24, r26
    565c:	8b 59       	subi	r24, 0x9B	; 155
    565e:	9f 4f       	sbci	r25, 0xFF	; 255
    5660:	ec 01       	movw	r28, r24
    5662:	48 81       	ld	r20, Y
    5664:	59 81       	ldd	r21, Y+1	; 0x01
    5666:	6a 81       	ldd	r22, Y+2	; 0x02
    5668:	7b 81       	ldd	r23, Y+3	; 0x03
    566a:	e9 01       	movw	r28, r18
    566c:	48 83       	st	Y, r20
    566e:	59 83       	std	Y+1, r21	; 0x01
    5670:	6a 83       	std	Y+2, r22	; 0x02
    5672:	7b 83       	std	Y+3, r23	; 0x03
    5674:	9f 01       	movw	r18, r30
    5676:	23 59       	subi	r18, 0x93	; 147
    5678:	3f 4f       	sbci	r19, 0xFF	; 255
    567a:	cd 01       	movw	r24, r26
    567c:	87 59       	subi	r24, 0x97	; 151
    567e:	9f 4f       	sbci	r25, 0xFF	; 255
    5680:	ec 01       	movw	r28, r24
    5682:	48 81       	ld	r20, Y
    5684:	59 81       	ldd	r21, Y+1	; 0x01
    5686:	6a 81       	ldd	r22, Y+2	; 0x02
    5688:	7b 81       	ldd	r23, Y+3	; 0x03
    568a:	e9 01       	movw	r28, r18
    568c:	48 83       	st	Y, r20
    568e:	59 83       	std	Y+1, r21	; 0x01
    5690:	6a 83       	std	Y+2, r22	; 0x02
    5692:	7b 83       	std	Y+3, r23	; 0x03
    5694:	9f 01       	movw	r18, r30
    5696:	2f 58       	subi	r18, 0x8F	; 143
    5698:	3f 4f       	sbci	r19, 0xFF	; 255
    569a:	cd 01       	movw	r24, r26
    569c:	83 59       	subi	r24, 0x93	; 147
    569e:	9f 4f       	sbci	r25, 0xFF	; 255
    56a0:	ec 01       	movw	r28, r24
    56a2:	48 81       	ld	r20, Y
    56a4:	59 81       	ldd	r21, Y+1	; 0x01
    56a6:	6a 81       	ldd	r22, Y+2	; 0x02
    56a8:	7b 81       	ldd	r23, Y+3	; 0x03
    56aa:	e9 01       	movw	r28, r18
    56ac:	48 83       	st	Y, r20
    56ae:	59 83       	std	Y+1, r21	; 0x01
    56b0:	6a 83       	std	Y+2, r22	; 0x02
    56b2:	7b 83       	std	Y+3, r23	; 0x03
    56b4:	9f 01       	movw	r18, r30
    56b6:	2b 58       	subi	r18, 0x8B	; 139
    56b8:	3f 4f       	sbci	r19, 0xFF	; 255
    56ba:	cd 01       	movw	r24, r26
    56bc:	8f 58       	subi	r24, 0x8F	; 143
    56be:	9f 4f       	sbci	r25, 0xFF	; 255
    56c0:	ec 01       	movw	r28, r24
    56c2:	48 81       	ld	r20, Y
    56c4:	59 81       	ldd	r21, Y+1	; 0x01
    56c6:	6a 81       	ldd	r22, Y+2	; 0x02
    56c8:	7b 81       	ldd	r23, Y+3	; 0x03
    56ca:	e9 01       	movw	r28, r18
    56cc:	48 83       	st	Y, r20
    56ce:	59 83       	std	Y+1, r21	; 0x01
    56d0:	6a 83       	std	Y+2, r22	; 0x02
    56d2:	7b 83       	std	Y+3, r23	; 0x03
    56d4:	e7 58       	subi	r30, 0x87	; 135
    56d6:	ff 4f       	sbci	r31, 0xFF	; 255
    56d8:	ab 58       	subi	r26, 0x8B	; 139
    56da:	bf 4f       	sbci	r27, 0xFF	; 255
    56dc:	4d 91       	ld	r20, X+
    56de:	5d 91       	ld	r21, X+
    56e0:	6d 91       	ld	r22, X+
    56e2:	7c 91       	ld	r23, X
    56e4:	40 83       	st	Z, r20
    56e6:	51 83       	std	Z+1, r21	; 0x01
    56e8:	62 83       	std	Z+2, r22	; 0x02
    56ea:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    56ec:	df 91       	pop	r29
    56ee:	cf 91       	pop	r28
    56f0:	08 95       	ret

000056f2 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>:

SimpleTelemetryMessage* SimpleTelemetryMessage::buildMessageSt(byte *message)
{
    56f2:	0f 93       	push	r16
    56f4:	1f 93       	push	r17
    56f6:	cf 93       	push	r28
    56f8:	df 93       	push	r29
    56fa:	8c 01       	movw	r16, r24
	SimpleTelemetryMessage *msg = new SimpleTelemetryMessage();
    56fc:	8d e7       	ldi	r24, 0x7D	; 125
    56fe:	90 e0       	ldi	r25, 0x00	; 0
    5700:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    5704:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    5706:	86 e0       	ldi	r24, 0x06	; 6
    5708:	8a 83       	std	Y+2, r24	; 0x02
    570a:	89 e7       	ldi	r24, 0x79	; 121
    570c:	90 e0       	ldi	r25, 0x00	; 0
    570e:	9c 83       	std	Y+4, r25	; 0x04
    5710:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    5712:	88 e6       	ldi	r24, 0x68	; 104
    5714:	92 e0       	ldi	r25, 0x02	; 2
    5716:	99 83       	std	Y+1, r25	; 0x01
    5718:	88 83       	st	Y, r24
    571a:	1d 82       	std	Y+5, r1	; 0x05
    571c:	1e 82       	std	Y+6, r1	; 0x06
    571e:	1f 82       	std	Y+7, r1	; 0x07
    5720:	18 86       	std	Y+8, r1	; 0x08
    5722:	19 86       	std	Y+9, r1	; 0x09
    5724:	1a 86       	std	Y+10, r1	; 0x0a
    5726:	1b 86       	std	Y+11, r1	; 0x0b
    5728:	1c 86       	std	Y+12, r1	; 0x0c
    572a:	1d 86       	std	Y+13, r1	; 0x0d
    572c:	1e 86       	std	Y+14, r1	; 0x0e
    572e:	1f 86       	std	Y+15, r1	; 0x0f
    5730:	18 8a       	std	Y+16, r1	; 0x10
    5732:	19 8a       	std	Y+17, r1	; 0x11
    5734:	1a 8a       	std	Y+18, r1	; 0x12
    5736:	1b 8a       	std	Y+19, r1	; 0x13
    5738:	1c 8a       	std	Y+20, r1	; 0x14
    573a:	1d 8a       	std	Y+21, r1	; 0x15
    573c:	1e 8a       	std	Y+22, r1	; 0x16
    573e:	1f 8a       	std	Y+23, r1	; 0x17
    5740:	18 8e       	std	Y+24, r1	; 0x18
    5742:	19 8e       	std	Y+25, r1	; 0x19
    5744:	1a 8e       	std	Y+26, r1	; 0x1a
    5746:	1b 8e       	std	Y+27, r1	; 0x1b
    5748:	1c 8e       	std	Y+28, r1	; 0x1c
    574a:	1d 8e       	std	Y+29, r1	; 0x1d
    574c:	1e 8e       	std	Y+30, r1	; 0x1e
    574e:	1f 8e       	std	Y+31, r1	; 0x1f
    5750:	18 a2       	std	Y+32, r1	; 0x20
    5752:	19 a2       	std	Y+33, r1	; 0x21
    5754:	1a a2       	std	Y+34, r1	; 0x22
    5756:	1b a2       	std	Y+35, r1	; 0x23
    5758:	1c a2       	std	Y+36, r1	; 0x24
    575a:	1d a2       	std	Y+37, r1	; 0x25
    575c:	1e a2       	std	Y+38, r1	; 0x26
    575e:	1f a2       	std	Y+39, r1	; 0x27
    5760:	18 a6       	std	Y+40, r1	; 0x28
    5762:	19 a6       	std	Y+41, r1	; 0x29
    5764:	1a a6       	std	Y+42, r1	; 0x2a
    5766:	1b a6       	std	Y+43, r1	; 0x2b
    5768:	1c a6       	std	Y+44, r1	; 0x2c
    576a:	1d a6       	std	Y+45, r1	; 0x2d
    576c:	1e a6       	std	Y+46, r1	; 0x2e
    576e:	1f a6       	std	Y+47, r1	; 0x2f
    5770:	18 aa       	std	Y+48, r1	; 0x30
    5772:	19 aa       	std	Y+49, r1	; 0x31
    5774:	1a aa       	std	Y+50, r1	; 0x32
    5776:	1b aa       	std	Y+51, r1	; 0x33
    5778:	1c aa       	std	Y+52, r1	; 0x34
    577a:	1d aa       	std	Y+53, r1	; 0x35
    577c:	1e aa       	std	Y+54, r1	; 0x36
    577e:	1f aa       	std	Y+55, r1	; 0x37
    5780:	18 ae       	std	Y+56, r1	; 0x38
    5782:	19 ae       	std	Y+57, r1	; 0x39
    5784:	1a ae       	std	Y+58, r1	; 0x3a
    5786:	1b ae       	std	Y+59, r1	; 0x3b
    5788:	1c ae       	std	Y+60, r1	; 0x3c
    578a:	fe 01       	movw	r30, r28
    578c:	fd 96       	adiw	r30, 0x3d	; 61
    578e:	10 82       	st	Z, r1
    5790:	11 82       	std	Z+1, r1	; 0x01
    5792:	12 82       	std	Z+2, r1	; 0x02
    5794:	13 82       	std	Z+3, r1	; 0x03
    5796:	fe 01       	movw	r30, r28
    5798:	ef 5b       	subi	r30, 0xBF	; 191
    579a:	ff 4f       	sbci	r31, 0xFF	; 255
    579c:	10 82       	st	Z, r1
    579e:	11 82       	std	Z+1, r1	; 0x01
    57a0:	12 82       	std	Z+2, r1	; 0x02
    57a2:	13 82       	std	Z+3, r1	; 0x03
    57a4:	fe 01       	movw	r30, r28
    57a6:	eb 5b       	subi	r30, 0xBB	; 187
    57a8:	ff 4f       	sbci	r31, 0xFF	; 255
    57aa:	10 82       	st	Z, r1
    57ac:	11 82       	std	Z+1, r1	; 0x01
    57ae:	12 82       	std	Z+2, r1	; 0x02
    57b0:	13 82       	std	Z+3, r1	; 0x03
    57b2:	fe 01       	movw	r30, r28
    57b4:	e7 5b       	subi	r30, 0xB7	; 183
    57b6:	ff 4f       	sbci	r31, 0xFF	; 255
    57b8:	10 82       	st	Z, r1
    57ba:	11 82       	std	Z+1, r1	; 0x01
    57bc:	12 82       	std	Z+2, r1	; 0x02
    57be:	13 82       	std	Z+3, r1	; 0x03
    57c0:	fe 01       	movw	r30, r28
    57c2:	e3 5b       	subi	r30, 0xB3	; 179
    57c4:	ff 4f       	sbci	r31, 0xFF	; 255
    57c6:	10 82       	st	Z, r1
    57c8:	11 82       	std	Z+1, r1	; 0x01
    57ca:	12 82       	std	Z+2, r1	; 0x02
    57cc:	13 82       	std	Z+3, r1	; 0x03
    57ce:	fe 01       	movw	r30, r28
    57d0:	ef 5a       	subi	r30, 0xAF	; 175
    57d2:	ff 4f       	sbci	r31, 0xFF	; 255
    57d4:	10 82       	st	Z, r1
    57d6:	11 82       	std	Z+1, r1	; 0x01
    57d8:	12 82       	std	Z+2, r1	; 0x02
    57da:	13 82       	std	Z+3, r1	; 0x03
    57dc:	fe 01       	movw	r30, r28
    57de:	eb 5a       	subi	r30, 0xAB	; 171
    57e0:	ff 4f       	sbci	r31, 0xFF	; 255
    57e2:	10 82       	st	Z, r1
    57e4:	11 82       	std	Z+1, r1	; 0x01
    57e6:	12 82       	std	Z+2, r1	; 0x02
    57e8:	13 82       	std	Z+3, r1	; 0x03
    57ea:	fe 01       	movw	r30, r28
    57ec:	e7 5a       	subi	r30, 0xA7	; 167
    57ee:	ff 4f       	sbci	r31, 0xFF	; 255
    57f0:	10 82       	st	Z, r1
    57f2:	11 82       	std	Z+1, r1	; 0x01
    57f4:	12 82       	std	Z+2, r1	; 0x02
    57f6:	13 82       	std	Z+3, r1	; 0x03
    57f8:	fe 01       	movw	r30, r28
    57fa:	e3 5a       	subi	r30, 0xA3	; 163
    57fc:	ff 4f       	sbci	r31, 0xFF	; 255
    57fe:	10 82       	st	Z, r1
    5800:	11 82       	std	Z+1, r1	; 0x01
    5802:	12 82       	std	Z+2, r1	; 0x02
    5804:	13 82       	std	Z+3, r1	; 0x03
    5806:	fe 01       	movw	r30, r28
    5808:	ef 59       	subi	r30, 0x9F	; 159
    580a:	ff 4f       	sbci	r31, 0xFF	; 255
    580c:	10 82       	st	Z, r1
    580e:	11 82       	std	Z+1, r1	; 0x01
    5810:	12 82       	std	Z+2, r1	; 0x02
    5812:	13 82       	std	Z+3, r1	; 0x03
    5814:	fe 01       	movw	r30, r28
    5816:	eb 59       	subi	r30, 0x9B	; 155
    5818:	ff 4f       	sbci	r31, 0xFF	; 255
    581a:	10 82       	st	Z, r1
    581c:	11 82       	std	Z+1, r1	; 0x01
    581e:	12 82       	std	Z+2, r1	; 0x02
    5820:	13 82       	std	Z+3, r1	; 0x03
    5822:	fe 01       	movw	r30, r28
    5824:	e7 59       	subi	r30, 0x97	; 151
    5826:	ff 4f       	sbci	r31, 0xFF	; 255
    5828:	10 82       	st	Z, r1
    582a:	11 82       	std	Z+1, r1	; 0x01
    582c:	12 82       	std	Z+2, r1	; 0x02
    582e:	13 82       	std	Z+3, r1	; 0x03
    5830:	fe 01       	movw	r30, r28
    5832:	e3 59       	subi	r30, 0x93	; 147
    5834:	ff 4f       	sbci	r31, 0xFF	; 255
    5836:	10 82       	st	Z, r1
    5838:	11 82       	std	Z+1, r1	; 0x01
    583a:	12 82       	std	Z+2, r1	; 0x02
    583c:	13 82       	std	Z+3, r1	; 0x03
    583e:	fe 01       	movw	r30, r28
    5840:	ef 58       	subi	r30, 0x8F	; 143
    5842:	ff 4f       	sbci	r31, 0xFF	; 255
    5844:	10 82       	st	Z, r1
    5846:	11 82       	std	Z+1, r1	; 0x01
    5848:	12 82       	std	Z+2, r1	; 0x02
    584a:	13 82       	std	Z+3, r1	; 0x03
    584c:	fe 01       	movw	r30, r28
    584e:	eb 58       	subi	r30, 0x8B	; 139
    5850:	ff 4f       	sbci	r31, 0xFF	; 255
    5852:	10 82       	st	Z, r1
    5854:	11 82       	std	Z+1, r1	; 0x01
    5856:	12 82       	std	Z+2, r1	; 0x02
    5858:	13 82       	std	Z+3, r1	; 0x03
    585a:	fe 01       	movw	r30, r28
    585c:	e7 58       	subi	r30, 0x87	; 135
    585e:	ff 4f       	sbci	r31, 0xFF	; 255
    5860:	10 82       	st	Z, r1
    5862:	11 82       	std	Z+1, r1	; 0x01
    5864:	12 82       	std	Z+2, r1	; 0x02
    5866:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    5868:	b8 01       	movw	r22, r16
    586a:	ce 01       	movw	r24, r28
    586c:	0e 94 ea 29 	call	0x53d4	; 0x53d4 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    5870:	8c 2f       	mov	r24, r28
    5872:	9d 2f       	mov	r25, r29
    5874:	df 91       	pop	r29
    5876:	cf 91       	pop	r28
    5878:	1f 91       	pop	r17
    587a:	0f 91       	pop	r16
    587c:	08 95       	ret

0000587e <_ZN10helicopter8messages11SyncMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    587e:	20 e5       	ldi	r18, 0x50	; 80
    5880:	32 e0       	ldi	r19, 0x02	; 2
    5882:	fc 01       	movw	r30, r24
    5884:	31 83       	std	Z+1, r19	; 0x01
    5886:	20 83       	st	Z, r18
    5888:	08 95       	ret

0000588a <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>:
	return msg;
}

void SyncMessage::buildMessage(byte *message)
{
	if (message != NULL)
    588a:	61 15       	cp	r22, r1
    588c:	71 05       	cpc	r23, r1
    588e:	41 f0       	breq	.+16     	; 0x58a0 <_ZN10helicopter8messages11SyncMessage12buildMessageEPh+0x16>
	{
		msgType = message[0];
    5890:	fb 01       	movw	r30, r22
    5892:	20 81       	ld	r18, Z
    5894:	fc 01       	movw	r30, r24
    5896:	22 83       	std	Z+2, r18	; 0x02
		RequestedMessage = message[1];
    5898:	fb 01       	movw	r30, r22
    589a:	21 81       	ldd	r18, Z+1	; 0x01
    589c:	fc 01       	movw	r30, r24
    589e:	25 83       	std	Z+5, r18	; 0x05
    58a0:	08 95       	ret

000058a2 <_ZN10helicopter8messages11SyncMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SyncMessage::getBytes()
{
    58a2:	cf 93       	push	r28
    58a4:	df 93       	push	r29
    58a6:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    58a8:	82 e0       	ldi	r24, 0x02	; 2
    58aa:	90 e0       	ldi	r25, 0x00	; 0
    58ac:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    58b0:	fc 01       	movw	r30, r24
	byte *msgPtr = msg;
	msgPtr[0] = this->msgType;
    58b2:	8a 81       	ldd	r24, Y+2	; 0x02
    58b4:	80 83       	st	Z, r24
	msgPtr[1] = this->RequestedMessage;
    58b6:	8d 81       	ldd	r24, Y+5	; 0x05
    58b8:	81 83       	std	Z+1, r24	; 0x01
	
	return msg;
}
    58ba:	8e 2f       	mov	r24, r30
    58bc:	9f 2f       	mov	r25, r31
    58be:	df 91       	pop	r29
    58c0:	cf 91       	pop	r28
    58c2:	08 95       	ret

000058c4 <_ZN10helicopter8messages11SyncMessageD0Ev>:
    58c4:	20 e5       	ldi	r18, 0x50	; 80
    58c6:	32 e0       	ldi	r19, 0x02	; 2
    58c8:	fc 01       	movw	r30, r24
    58ca:	31 83       	std	Z+1, r19	; 0x01
    58cc:	20 83       	st	Z, r18
				}
				
				~SyncMessage()
				{
					
				}
    58ce:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    58d2:	08 95       	ret

000058d4 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>:
    58d4:	20 e5       	ldi	r18, 0x50	; 80
    58d6:	32 e0       	ldi	r19, 0x02	; 2
    58d8:	fc 01       	movw	r30, r24
    58da:	31 83       	std	Z+1, r19	; 0x01
    58dc:	20 83       	st	Z, r18
    58de:	08 95       	ret

000058e0 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>:
    58e0:	20 e5       	ldi	r18, 0x50	; 80
    58e2:	32 e0       	ldi	r19, 0x02	; 2
    58e4:	fc 01       	movw	r30, r24
    58e6:	31 83       	std	Z+1, r19	; 0x01
    58e8:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SystemTelemetryMessage() {}
    58ea:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    58ee:	08 95       	ret

000058f0 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SystemTelemetryMessage::getBytes()
{
    58f0:	cf 93       	push	r28
    58f2:	df 93       	push	r29
    58f4:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    58f6:	8d e2       	ldi	r24, 0x2D	; 45
    58f8:	91 e0       	ldi	r25, 0x01	; 1
    58fa:	0e 94 8a 64 	call	0xc914	; 0xc914 <_Znaj>
    58fe:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    5900:	8a 81       	ldd	r24, Y+2	; 0x02
    5902:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5904:	8d 81       	ldd	r24, Y+5	; 0x05
    5906:	9e 81       	ldd	r25, Y+6	; 0x06
    5908:	af 81       	ldd	r26, Y+7	; 0x07
    590a:	b8 85       	ldd	r27, Y+8	; 0x08
    590c:	81 83       	std	Z+1, r24	; 0x01
    590e:	92 83       	std	Z+2, r25	; 0x02
    5910:	a3 83       	std	Z+3, r26	; 0x03
    5912:	b4 83       	std	Z+4, r27	; 0x04
    5914:	89 85       	ldd	r24, Y+9	; 0x09
    5916:	9a 85       	ldd	r25, Y+10	; 0x0a
    5918:	ab 85       	ldd	r26, Y+11	; 0x0b
    591a:	bc 85       	ldd	r27, Y+12	; 0x0c
    591c:	85 83       	std	Z+5, r24	; 0x05
    591e:	96 83       	std	Z+6, r25	; 0x06
    5920:	a7 83       	std	Z+7, r26	; 0x07
    5922:	b0 87       	std	Z+8, r27	; 0x08
    5924:	8d 85       	ldd	r24, Y+13	; 0x0d
    5926:	9e 85       	ldd	r25, Y+14	; 0x0e
    5928:	af 85       	ldd	r26, Y+15	; 0x0f
    592a:	b8 89       	ldd	r27, Y+16	; 0x10
    592c:	81 87       	std	Z+9, r24	; 0x09
    592e:	92 87       	std	Z+10, r25	; 0x0a
    5930:	a3 87       	std	Z+11, r26	; 0x0b
    5932:	b4 87       	std	Z+12, r27	; 0x0c
    5934:	89 89       	ldd	r24, Y+17	; 0x11
    5936:	9a 89       	ldd	r25, Y+18	; 0x12
    5938:	ab 89       	ldd	r26, Y+19	; 0x13
    593a:	bc 89       	ldd	r27, Y+20	; 0x14
    593c:	85 87       	std	Z+13, r24	; 0x0d
    593e:	96 87       	std	Z+14, r25	; 0x0e
    5940:	a7 87       	std	Z+15, r26	; 0x0f
    5942:	b0 8b       	std	Z+16, r27	; 0x10
    5944:	8d 89       	ldd	r24, Y+21	; 0x15
    5946:	9e 89       	ldd	r25, Y+22	; 0x16
    5948:	af 89       	ldd	r26, Y+23	; 0x17
    594a:	b8 8d       	ldd	r27, Y+24	; 0x18
    594c:	81 8b       	std	Z+17, r24	; 0x11
    594e:	92 8b       	std	Z+18, r25	; 0x12
    5950:	a3 8b       	std	Z+19, r26	; 0x13
    5952:	b4 8b       	std	Z+20, r27	; 0x14
    5954:	89 8d       	ldd	r24, Y+25	; 0x19
    5956:	9a 8d       	ldd	r25, Y+26	; 0x1a
    5958:	ab 8d       	ldd	r26, Y+27	; 0x1b
    595a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    595c:	85 8b       	std	Z+21, r24	; 0x15
    595e:	96 8b       	std	Z+22, r25	; 0x16
    5960:	a7 8b       	std	Z+23, r26	; 0x17
    5962:	b0 8f       	std	Z+24, r27	; 0x18
    5964:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5966:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5968:	af 8d       	ldd	r26, Y+31	; 0x1f
    596a:	b8 a1       	ldd	r27, Y+32	; 0x20
    596c:	81 8f       	std	Z+25, r24	; 0x19
    596e:	92 8f       	std	Z+26, r25	; 0x1a
    5970:	a3 8f       	std	Z+27, r26	; 0x1b
    5972:	b4 8f       	std	Z+28, r27	; 0x1c
    5974:	89 a1       	ldd	r24, Y+33	; 0x21
    5976:	9a a1       	ldd	r25, Y+34	; 0x22
    5978:	ab a1       	ldd	r26, Y+35	; 0x23
    597a:	bc a1       	ldd	r27, Y+36	; 0x24
    597c:	85 8f       	std	Z+29, r24	; 0x1d
    597e:	96 8f       	std	Z+30, r25	; 0x1e
    5980:	a7 8f       	std	Z+31, r26	; 0x1f
    5982:	b0 a3       	std	Z+32, r27	; 0x20
    5984:	8d a1       	ldd	r24, Y+37	; 0x25
    5986:	9e a1       	ldd	r25, Y+38	; 0x26
    5988:	af a1       	ldd	r26, Y+39	; 0x27
    598a:	b8 a5       	ldd	r27, Y+40	; 0x28
    598c:	81 a3       	std	Z+33, r24	; 0x21
    598e:	92 a3       	std	Z+34, r25	; 0x22
    5990:	a3 a3       	std	Z+35, r26	; 0x23
    5992:	b4 a3       	std	Z+36, r27	; 0x24
    5994:	89 a5       	ldd	r24, Y+41	; 0x29
    5996:	9a a5       	ldd	r25, Y+42	; 0x2a
    5998:	ab a5       	ldd	r26, Y+43	; 0x2b
    599a:	bc a5       	ldd	r27, Y+44	; 0x2c
    599c:	85 a3       	std	Z+37, r24	; 0x25
    599e:	96 a3       	std	Z+38, r25	; 0x26
    59a0:	a7 a3       	std	Z+39, r26	; 0x27
    59a2:	b0 a7       	std	Z+40, r27	; 0x28
    59a4:	8d a5       	ldd	r24, Y+45	; 0x2d
    59a6:	9e a5       	ldd	r25, Y+46	; 0x2e
    59a8:	af a5       	ldd	r26, Y+47	; 0x2f
    59aa:	b8 a9       	ldd	r27, Y+48	; 0x30
    59ac:	81 a7       	std	Z+41, r24	; 0x29
    59ae:	92 a7       	std	Z+42, r25	; 0x2a
    59b0:	a3 a7       	std	Z+43, r26	; 0x2b
    59b2:	b4 a7       	std	Z+44, r27	; 0x2c
    59b4:	89 a9       	ldd	r24, Y+49	; 0x31
    59b6:	9a a9       	ldd	r25, Y+50	; 0x32
    59b8:	ab a9       	ldd	r26, Y+51	; 0x33
    59ba:	bc a9       	ldd	r27, Y+52	; 0x34
    59bc:	85 a7       	std	Z+45, r24	; 0x2d
    59be:	96 a7       	std	Z+46, r25	; 0x2e
    59c0:	a7 a7       	std	Z+47, r26	; 0x2f
    59c2:	b0 ab       	std	Z+48, r27	; 0x30
    59c4:	8d a9       	ldd	r24, Y+53	; 0x35
    59c6:	9e a9       	ldd	r25, Y+54	; 0x36
    59c8:	af a9       	ldd	r26, Y+55	; 0x37
    59ca:	b8 ad       	ldd	r27, Y+56	; 0x38
    59cc:	81 ab       	std	Z+49, r24	; 0x31
    59ce:	92 ab       	std	Z+50, r25	; 0x32
    59d0:	a3 ab       	std	Z+51, r26	; 0x33
    59d2:	b4 ab       	std	Z+52, r27	; 0x34
    59d4:	89 ad       	ldd	r24, Y+57	; 0x39
    59d6:	9a ad       	ldd	r25, Y+58	; 0x3a
    59d8:	ab ad       	ldd	r26, Y+59	; 0x3b
    59da:	bc ad       	ldd	r27, Y+60	; 0x3c
    59dc:	85 ab       	std	Z+53, r24	; 0x35
    59de:	96 ab       	std	Z+54, r25	; 0x36
    59e0:	a7 ab       	std	Z+55, r26	; 0x37
    59e2:	b0 af       	std	Z+56, r27	; 0x38
    59e4:	de 01       	movw	r26, r28
    59e6:	dd 96       	adiw	r26, 0x3d	; 61
    59e8:	8d 91       	ld	r24, X+
    59ea:	9d 91       	ld	r25, X+
    59ec:	0d 90       	ld	r0, X+
    59ee:	bc 91       	ld	r27, X
    59f0:	a0 2d       	mov	r26, r0
    59f2:	81 af       	std	Z+57, r24	; 0x39
    59f4:	92 af       	std	Z+58, r25	; 0x3a
    59f6:	a3 af       	std	Z+59, r26	; 0x3b
    59f8:	b4 af       	std	Z+60, r27	; 0x3c
    59fa:	9f 01       	movw	r18, r30
    59fc:	23 5c       	subi	r18, 0xC3	; 195
    59fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5a00:	de 01       	movw	r26, r28
    5a02:	af 5b       	subi	r26, 0xBF	; 191
    5a04:	bf 4f       	sbci	r27, 0xFF	; 255
    5a06:	4d 91       	ld	r20, X+
    5a08:	5d 91       	ld	r21, X+
    5a0a:	6d 91       	ld	r22, X+
    5a0c:	7c 91       	ld	r23, X
    5a0e:	d9 01       	movw	r26, r18
    5a10:	4d 93       	st	X+, r20
    5a12:	5d 93       	st	X+, r21
    5a14:	6d 93       	st	X+, r22
    5a16:	7c 93       	st	X, r23
    5a18:	13 97       	sbiw	r26, 0x03	; 3
    5a1a:	9f 01       	movw	r18, r30
    5a1c:	2f 5b       	subi	r18, 0xBF	; 191
    5a1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a20:	de 01       	movw	r26, r28
    5a22:	ab 5b       	subi	r26, 0xBB	; 187
    5a24:	bf 4f       	sbci	r27, 0xFF	; 255
    5a26:	4d 91       	ld	r20, X+
    5a28:	5d 91       	ld	r21, X+
    5a2a:	6d 91       	ld	r22, X+
    5a2c:	7c 91       	ld	r23, X
    5a2e:	d9 01       	movw	r26, r18
    5a30:	4d 93       	st	X+, r20
    5a32:	5d 93       	st	X+, r21
    5a34:	6d 93       	st	X+, r22
    5a36:	7c 93       	st	X, r23
    5a38:	13 97       	sbiw	r26, 0x03	; 3
    5a3a:	9f 01       	movw	r18, r30
    5a3c:	2b 5b       	subi	r18, 0xBB	; 187
    5a3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a40:	de 01       	movw	r26, r28
    5a42:	a7 5b       	subi	r26, 0xB7	; 183
    5a44:	bf 4f       	sbci	r27, 0xFF	; 255
    5a46:	4d 91       	ld	r20, X+
    5a48:	5d 91       	ld	r21, X+
    5a4a:	6d 91       	ld	r22, X+
    5a4c:	7c 91       	ld	r23, X
    5a4e:	d9 01       	movw	r26, r18
    5a50:	4d 93       	st	X+, r20
    5a52:	5d 93       	st	X+, r21
    5a54:	6d 93       	st	X+, r22
    5a56:	7c 93       	st	X, r23
    5a58:	13 97       	sbiw	r26, 0x03	; 3
    5a5a:	9f 01       	movw	r18, r30
    5a5c:	27 5b       	subi	r18, 0xB7	; 183
    5a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a60:	de 01       	movw	r26, r28
    5a62:	a3 5b       	subi	r26, 0xB3	; 179
    5a64:	bf 4f       	sbci	r27, 0xFF	; 255
    5a66:	4d 91       	ld	r20, X+
    5a68:	5d 91       	ld	r21, X+
    5a6a:	6d 91       	ld	r22, X+
    5a6c:	7c 91       	ld	r23, X
    5a6e:	d9 01       	movw	r26, r18
    5a70:	4d 93       	st	X+, r20
    5a72:	5d 93       	st	X+, r21
    5a74:	6d 93       	st	X+, r22
    5a76:	7c 93       	st	X, r23
    5a78:	13 97       	sbiw	r26, 0x03	; 3
    5a7a:	9f 01       	movw	r18, r30
    5a7c:	23 5b       	subi	r18, 0xB3	; 179
    5a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a80:	de 01       	movw	r26, r28
    5a82:	af 5a       	subi	r26, 0xAF	; 175
    5a84:	bf 4f       	sbci	r27, 0xFF	; 255
    5a86:	4d 91       	ld	r20, X+
    5a88:	5d 91       	ld	r21, X+
    5a8a:	6d 91       	ld	r22, X+
    5a8c:	7c 91       	ld	r23, X
    5a8e:	d9 01       	movw	r26, r18
    5a90:	4d 93       	st	X+, r20
    5a92:	5d 93       	st	X+, r21
    5a94:	6d 93       	st	X+, r22
    5a96:	7c 93       	st	X, r23
    5a98:	13 97       	sbiw	r26, 0x03	; 3
    5a9a:	9f 01       	movw	r18, r30
    5a9c:	2f 5a       	subi	r18, 0xAF	; 175
    5a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5aa0:	de 01       	movw	r26, r28
    5aa2:	ab 5a       	subi	r26, 0xAB	; 171
    5aa4:	bf 4f       	sbci	r27, 0xFF	; 255
    5aa6:	4d 91       	ld	r20, X+
    5aa8:	5d 91       	ld	r21, X+
    5aaa:	6d 91       	ld	r22, X+
    5aac:	7c 91       	ld	r23, X
    5aae:	d9 01       	movw	r26, r18
    5ab0:	4d 93       	st	X+, r20
    5ab2:	5d 93       	st	X+, r21
    5ab4:	6d 93       	st	X+, r22
    5ab6:	7c 93       	st	X, r23
    5ab8:	13 97       	sbiw	r26, 0x03	; 3
    5aba:	9f 01       	movw	r18, r30
    5abc:	2b 5a       	subi	r18, 0xAB	; 171
    5abe:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac0:	de 01       	movw	r26, r28
    5ac2:	a7 5a       	subi	r26, 0xA7	; 167
    5ac4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ac6:	4d 91       	ld	r20, X+
    5ac8:	5d 91       	ld	r21, X+
    5aca:	6d 91       	ld	r22, X+
    5acc:	7c 91       	ld	r23, X
    5ace:	d9 01       	movw	r26, r18
    5ad0:	4d 93       	st	X+, r20
    5ad2:	5d 93       	st	X+, r21
    5ad4:	6d 93       	st	X+, r22
    5ad6:	7c 93       	st	X, r23
    5ad8:	13 97       	sbiw	r26, 0x03	; 3
    5ada:	9f 01       	movw	r18, r30
    5adc:	27 5a       	subi	r18, 0xA7	; 167
    5ade:	3f 4f       	sbci	r19, 0xFF	; 255
    5ae0:	de 01       	movw	r26, r28
    5ae2:	a3 5a       	subi	r26, 0xA3	; 163
    5ae4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ae6:	4d 91       	ld	r20, X+
    5ae8:	5d 91       	ld	r21, X+
    5aea:	6d 91       	ld	r22, X+
    5aec:	7c 91       	ld	r23, X
    5aee:	d9 01       	movw	r26, r18
    5af0:	4d 93       	st	X+, r20
    5af2:	5d 93       	st	X+, r21
    5af4:	6d 93       	st	X+, r22
    5af6:	7c 93       	st	X, r23
    5af8:	13 97       	sbiw	r26, 0x03	; 3
    5afa:	9f 01       	movw	r18, r30
    5afc:	23 5a       	subi	r18, 0xA3	; 163
    5afe:	3f 4f       	sbci	r19, 0xFF	; 255
    5b00:	de 01       	movw	r26, r28
    5b02:	af 59       	subi	r26, 0x9F	; 159
    5b04:	bf 4f       	sbci	r27, 0xFF	; 255
    5b06:	4d 91       	ld	r20, X+
    5b08:	5d 91       	ld	r21, X+
    5b0a:	6d 91       	ld	r22, X+
    5b0c:	7c 91       	ld	r23, X
    5b0e:	d9 01       	movw	r26, r18
    5b10:	4d 93       	st	X+, r20
    5b12:	5d 93       	st	X+, r21
    5b14:	6d 93       	st	X+, r22
    5b16:	7c 93       	st	X, r23
    5b18:	13 97       	sbiw	r26, 0x03	; 3
    5b1a:	9f 01       	movw	r18, r30
    5b1c:	2f 59       	subi	r18, 0x9F	; 159
    5b1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b20:	de 01       	movw	r26, r28
    5b22:	ab 59       	subi	r26, 0x9B	; 155
    5b24:	bf 4f       	sbci	r27, 0xFF	; 255
    5b26:	4d 91       	ld	r20, X+
    5b28:	5d 91       	ld	r21, X+
    5b2a:	6d 91       	ld	r22, X+
    5b2c:	7c 91       	ld	r23, X
    5b2e:	d9 01       	movw	r26, r18
    5b30:	4d 93       	st	X+, r20
    5b32:	5d 93       	st	X+, r21
    5b34:	6d 93       	st	X+, r22
    5b36:	7c 93       	st	X, r23
    5b38:	13 97       	sbiw	r26, 0x03	; 3
    5b3a:	9f 01       	movw	r18, r30
    5b3c:	2b 59       	subi	r18, 0x9B	; 155
    5b3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b40:	de 01       	movw	r26, r28
    5b42:	a7 59       	subi	r26, 0x97	; 151
    5b44:	bf 4f       	sbci	r27, 0xFF	; 255
    5b46:	4d 91       	ld	r20, X+
    5b48:	5d 91       	ld	r21, X+
    5b4a:	6d 91       	ld	r22, X+
    5b4c:	7c 91       	ld	r23, X
    5b4e:	d9 01       	movw	r26, r18
    5b50:	4d 93       	st	X+, r20
    5b52:	5d 93       	st	X+, r21
    5b54:	6d 93       	st	X+, r22
    5b56:	7c 93       	st	X, r23
    5b58:	13 97       	sbiw	r26, 0x03	; 3
    5b5a:	9f 01       	movw	r18, r30
    5b5c:	27 59       	subi	r18, 0x97	; 151
    5b5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b60:	de 01       	movw	r26, r28
    5b62:	a3 59       	subi	r26, 0x93	; 147
    5b64:	bf 4f       	sbci	r27, 0xFF	; 255
    5b66:	4d 91       	ld	r20, X+
    5b68:	5d 91       	ld	r21, X+
    5b6a:	6d 91       	ld	r22, X+
    5b6c:	7c 91       	ld	r23, X
    5b6e:	d9 01       	movw	r26, r18
    5b70:	4d 93       	st	X+, r20
    5b72:	5d 93       	st	X+, r21
    5b74:	6d 93       	st	X+, r22
    5b76:	7c 93       	st	X, r23
    5b78:	13 97       	sbiw	r26, 0x03	; 3
    5b7a:	9f 01       	movw	r18, r30
    5b7c:	23 59       	subi	r18, 0x93	; 147
    5b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5b80:	de 01       	movw	r26, r28
    5b82:	af 58       	subi	r26, 0x8F	; 143
    5b84:	bf 4f       	sbci	r27, 0xFF	; 255
    5b86:	4d 91       	ld	r20, X+
    5b88:	5d 91       	ld	r21, X+
    5b8a:	6d 91       	ld	r22, X+
    5b8c:	7c 91       	ld	r23, X
    5b8e:	d9 01       	movw	r26, r18
    5b90:	4d 93       	st	X+, r20
    5b92:	5d 93       	st	X+, r21
    5b94:	6d 93       	st	X+, r22
    5b96:	7c 93       	st	X, r23
    5b98:	13 97       	sbiw	r26, 0x03	; 3
    5b9a:	9f 01       	movw	r18, r30
    5b9c:	2f 58       	subi	r18, 0x8F	; 143
    5b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5ba0:	de 01       	movw	r26, r28
    5ba2:	ab 58       	subi	r26, 0x8B	; 139
    5ba4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ba6:	4d 91       	ld	r20, X+
    5ba8:	5d 91       	ld	r21, X+
    5baa:	6d 91       	ld	r22, X+
    5bac:	7c 91       	ld	r23, X
    5bae:	d9 01       	movw	r26, r18
    5bb0:	4d 93       	st	X+, r20
    5bb2:	5d 93       	st	X+, r21
    5bb4:	6d 93       	st	X+, r22
    5bb6:	7c 93       	st	X, r23
    5bb8:	13 97       	sbiw	r26, 0x03	; 3
    5bba:	9f 01       	movw	r18, r30
    5bbc:	2b 58       	subi	r18, 0x8B	; 139
    5bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5bc0:	de 01       	movw	r26, r28
    5bc2:	a7 58       	subi	r26, 0x87	; 135
    5bc4:	bf 4f       	sbci	r27, 0xFF	; 255
    5bc6:	4d 91       	ld	r20, X+
    5bc8:	5d 91       	ld	r21, X+
    5bca:	6d 91       	ld	r22, X+
    5bcc:	7c 91       	ld	r23, X
    5bce:	d9 01       	movw	r26, r18
    5bd0:	4d 93       	st	X+, r20
    5bd2:	5d 93       	st	X+, r21
    5bd4:	6d 93       	st	X+, r22
    5bd6:	7c 93       	st	X, r23
    5bd8:	13 97       	sbiw	r26, 0x03	; 3
    5bda:	9f 01       	movw	r18, r30
    5bdc:	27 58       	subi	r18, 0x87	; 135
    5bde:	3f 4f       	sbci	r19, 0xFF	; 255
    5be0:	de 01       	movw	r26, r28
    5be2:	a3 58       	subi	r26, 0x83	; 131
    5be4:	bf 4f       	sbci	r27, 0xFF	; 255
    5be6:	4d 91       	ld	r20, X+
    5be8:	5d 91       	ld	r21, X+
    5bea:	6d 91       	ld	r22, X+
    5bec:	7c 91       	ld	r23, X
    5bee:	d9 01       	movw	r26, r18
    5bf0:	4d 93       	st	X+, r20
    5bf2:	5d 93       	st	X+, r21
    5bf4:	6d 93       	st	X+, r22
    5bf6:	7c 93       	st	X, r23
    5bf8:	13 97       	sbiw	r26, 0x03	; 3
    5bfa:	9f 01       	movw	r18, r30
    5bfc:	23 58       	subi	r18, 0x83	; 131
    5bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    5c00:	de 01       	movw	r26, r28
    5c02:	af 57       	subi	r26, 0x7F	; 127
    5c04:	bf 4f       	sbci	r27, 0xFF	; 255
    5c06:	4d 91       	ld	r20, X+
    5c08:	5d 91       	ld	r21, X+
    5c0a:	6d 91       	ld	r22, X+
    5c0c:	7c 91       	ld	r23, X
    5c0e:	d9 01       	movw	r26, r18
    5c10:	4d 93       	st	X+, r20
    5c12:	5d 93       	st	X+, r21
    5c14:	6d 93       	st	X+, r22
    5c16:	7c 93       	st	X, r23
    5c18:	13 97       	sbiw	r26, 0x03	; 3
    5c1a:	9f 01       	movw	r18, r30
    5c1c:	2f 57       	subi	r18, 0x7F	; 127
    5c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c20:	de 01       	movw	r26, r28
    5c22:	ab 57       	subi	r26, 0x7B	; 123
    5c24:	bf 4f       	sbci	r27, 0xFF	; 255
    5c26:	4d 91       	ld	r20, X+
    5c28:	5d 91       	ld	r21, X+
    5c2a:	6d 91       	ld	r22, X+
    5c2c:	7c 91       	ld	r23, X
    5c2e:	d9 01       	movw	r26, r18
    5c30:	4d 93       	st	X+, r20
    5c32:	5d 93       	st	X+, r21
    5c34:	6d 93       	st	X+, r22
    5c36:	7c 93       	st	X, r23
    5c38:	13 97       	sbiw	r26, 0x03	; 3
    5c3a:	9f 01       	movw	r18, r30
    5c3c:	2b 57       	subi	r18, 0x7B	; 123
    5c3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c40:	de 01       	movw	r26, r28
    5c42:	a7 57       	subi	r26, 0x77	; 119
    5c44:	bf 4f       	sbci	r27, 0xFF	; 255
    5c46:	4d 91       	ld	r20, X+
    5c48:	5d 91       	ld	r21, X+
    5c4a:	6d 91       	ld	r22, X+
    5c4c:	7c 91       	ld	r23, X
    5c4e:	d9 01       	movw	r26, r18
    5c50:	4d 93       	st	X+, r20
    5c52:	5d 93       	st	X+, r21
    5c54:	6d 93       	st	X+, r22
    5c56:	7c 93       	st	X, r23
    5c58:	13 97       	sbiw	r26, 0x03	; 3
    5c5a:	9f 01       	movw	r18, r30
    5c5c:	27 57       	subi	r18, 0x77	; 119
    5c5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c60:	de 01       	movw	r26, r28
    5c62:	a3 57       	subi	r26, 0x73	; 115
    5c64:	bf 4f       	sbci	r27, 0xFF	; 255
    5c66:	4d 91       	ld	r20, X+
    5c68:	5d 91       	ld	r21, X+
    5c6a:	6d 91       	ld	r22, X+
    5c6c:	7c 91       	ld	r23, X
    5c6e:	d9 01       	movw	r26, r18
    5c70:	4d 93       	st	X+, r20
    5c72:	5d 93       	st	X+, r21
    5c74:	6d 93       	st	X+, r22
    5c76:	7c 93       	st	X, r23
    5c78:	13 97       	sbiw	r26, 0x03	; 3
    5c7a:	9f 01       	movw	r18, r30
    5c7c:	23 57       	subi	r18, 0x73	; 115
    5c7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c80:	de 01       	movw	r26, r28
    5c82:	af 56       	subi	r26, 0x6F	; 111
    5c84:	bf 4f       	sbci	r27, 0xFF	; 255
    5c86:	4d 91       	ld	r20, X+
    5c88:	5d 91       	ld	r21, X+
    5c8a:	6d 91       	ld	r22, X+
    5c8c:	7c 91       	ld	r23, X
    5c8e:	d9 01       	movw	r26, r18
    5c90:	4d 93       	st	X+, r20
    5c92:	5d 93       	st	X+, r21
    5c94:	6d 93       	st	X+, r22
    5c96:	7c 93       	st	X, r23
    5c98:	13 97       	sbiw	r26, 0x03	; 3
    5c9a:	9f 01       	movw	r18, r30
    5c9c:	2f 56       	subi	r18, 0x6F	; 111
    5c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5ca0:	de 01       	movw	r26, r28
    5ca2:	ab 56       	subi	r26, 0x6B	; 107
    5ca4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ca6:	4d 91       	ld	r20, X+
    5ca8:	5d 91       	ld	r21, X+
    5caa:	6d 91       	ld	r22, X+
    5cac:	7c 91       	ld	r23, X
    5cae:	d9 01       	movw	r26, r18
    5cb0:	4d 93       	st	X+, r20
    5cb2:	5d 93       	st	X+, r21
    5cb4:	6d 93       	st	X+, r22
    5cb6:	7c 93       	st	X, r23
    5cb8:	13 97       	sbiw	r26, 0x03	; 3
    5cba:	9f 01       	movw	r18, r30
    5cbc:	2b 56       	subi	r18, 0x6B	; 107
    5cbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5cc0:	de 01       	movw	r26, r28
    5cc2:	a7 56       	subi	r26, 0x67	; 103
    5cc4:	bf 4f       	sbci	r27, 0xFF	; 255
    5cc6:	4d 91       	ld	r20, X+
    5cc8:	5d 91       	ld	r21, X+
    5cca:	6d 91       	ld	r22, X+
    5ccc:	7c 91       	ld	r23, X
    5cce:	d9 01       	movw	r26, r18
    5cd0:	4d 93       	st	X+, r20
    5cd2:	5d 93       	st	X+, r21
    5cd4:	6d 93       	st	X+, r22
    5cd6:	7c 93       	st	X, r23
    5cd8:	13 97       	sbiw	r26, 0x03	; 3
    5cda:	9f 01       	movw	r18, r30
    5cdc:	27 56       	subi	r18, 0x67	; 103
    5cde:	3f 4f       	sbci	r19, 0xFF	; 255
    5ce0:	de 01       	movw	r26, r28
    5ce2:	a3 56       	subi	r26, 0x63	; 99
    5ce4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ce6:	4d 91       	ld	r20, X+
    5ce8:	5d 91       	ld	r21, X+
    5cea:	6d 91       	ld	r22, X+
    5cec:	7c 91       	ld	r23, X
    5cee:	d9 01       	movw	r26, r18
    5cf0:	4d 93       	st	X+, r20
    5cf2:	5d 93       	st	X+, r21
    5cf4:	6d 93       	st	X+, r22
    5cf6:	7c 93       	st	X, r23
    5cf8:	13 97       	sbiw	r26, 0x03	; 3
    5cfa:	9f 01       	movw	r18, r30
    5cfc:	23 56       	subi	r18, 0x63	; 99
    5cfe:	3f 4f       	sbci	r19, 0xFF	; 255
    5d00:	de 01       	movw	r26, r28
    5d02:	af 55       	subi	r26, 0x5F	; 95
    5d04:	bf 4f       	sbci	r27, 0xFF	; 255
    5d06:	4d 91       	ld	r20, X+
    5d08:	5d 91       	ld	r21, X+
    5d0a:	6d 91       	ld	r22, X+
    5d0c:	7c 91       	ld	r23, X
    5d0e:	d9 01       	movw	r26, r18
    5d10:	4d 93       	st	X+, r20
    5d12:	5d 93       	st	X+, r21
    5d14:	6d 93       	st	X+, r22
    5d16:	7c 93       	st	X, r23
    5d18:	13 97       	sbiw	r26, 0x03	; 3
    5d1a:	9f 01       	movw	r18, r30
    5d1c:	2f 55       	subi	r18, 0x5F	; 95
    5d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d20:	de 01       	movw	r26, r28
    5d22:	ab 55       	subi	r26, 0x5B	; 91
    5d24:	bf 4f       	sbci	r27, 0xFF	; 255
    5d26:	4d 91       	ld	r20, X+
    5d28:	5d 91       	ld	r21, X+
    5d2a:	6d 91       	ld	r22, X+
    5d2c:	7c 91       	ld	r23, X
    5d2e:	d9 01       	movw	r26, r18
    5d30:	4d 93       	st	X+, r20
    5d32:	5d 93       	st	X+, r21
    5d34:	6d 93       	st	X+, r22
    5d36:	7c 93       	st	X, r23
    5d38:	13 97       	sbiw	r26, 0x03	; 3
    5d3a:	9f 01       	movw	r18, r30
    5d3c:	2b 55       	subi	r18, 0x5B	; 91
    5d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d40:	de 01       	movw	r26, r28
    5d42:	a7 55       	subi	r26, 0x57	; 87
    5d44:	bf 4f       	sbci	r27, 0xFF	; 255
    5d46:	4d 91       	ld	r20, X+
    5d48:	5d 91       	ld	r21, X+
    5d4a:	6d 91       	ld	r22, X+
    5d4c:	7c 91       	ld	r23, X
    5d4e:	d9 01       	movw	r26, r18
    5d50:	4d 93       	st	X+, r20
    5d52:	5d 93       	st	X+, r21
    5d54:	6d 93       	st	X+, r22
    5d56:	7c 93       	st	X, r23
    5d58:	13 97       	sbiw	r26, 0x03	; 3
    5d5a:	9f 01       	movw	r18, r30
    5d5c:	27 55       	subi	r18, 0x57	; 87
    5d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d60:	de 01       	movw	r26, r28
    5d62:	a3 55       	subi	r26, 0x53	; 83
    5d64:	bf 4f       	sbci	r27, 0xFF	; 255
    5d66:	4d 91       	ld	r20, X+
    5d68:	5d 91       	ld	r21, X+
    5d6a:	6d 91       	ld	r22, X+
    5d6c:	7c 91       	ld	r23, X
    5d6e:	d9 01       	movw	r26, r18
    5d70:	4d 93       	st	X+, r20
    5d72:	5d 93       	st	X+, r21
    5d74:	6d 93       	st	X+, r22
    5d76:	7c 93       	st	X, r23
    5d78:	13 97       	sbiw	r26, 0x03	; 3
    5d7a:	9f 01       	movw	r18, r30
    5d7c:	23 55       	subi	r18, 0x53	; 83
    5d7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d80:	de 01       	movw	r26, r28
    5d82:	af 54       	subi	r26, 0x4F	; 79
    5d84:	bf 4f       	sbci	r27, 0xFF	; 255
    5d86:	4d 91       	ld	r20, X+
    5d88:	5d 91       	ld	r21, X+
    5d8a:	6d 91       	ld	r22, X+
    5d8c:	7c 91       	ld	r23, X
    5d8e:	d9 01       	movw	r26, r18
    5d90:	4d 93       	st	X+, r20
    5d92:	5d 93       	st	X+, r21
    5d94:	6d 93       	st	X+, r22
    5d96:	7c 93       	st	X, r23
    5d98:	13 97       	sbiw	r26, 0x03	; 3
    5d9a:	9f 01       	movw	r18, r30
    5d9c:	2f 54       	subi	r18, 0x4F	; 79
    5d9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5da0:	de 01       	movw	r26, r28
    5da2:	ab 54       	subi	r26, 0x4B	; 75
    5da4:	bf 4f       	sbci	r27, 0xFF	; 255
    5da6:	4d 91       	ld	r20, X+
    5da8:	5d 91       	ld	r21, X+
    5daa:	6d 91       	ld	r22, X+
    5dac:	7c 91       	ld	r23, X
    5dae:	d9 01       	movw	r26, r18
    5db0:	4d 93       	st	X+, r20
    5db2:	5d 93       	st	X+, r21
    5db4:	6d 93       	st	X+, r22
    5db6:	7c 93       	st	X, r23
    5db8:	13 97       	sbiw	r26, 0x03	; 3
    5dba:	9f 01       	movw	r18, r30
    5dbc:	2b 54       	subi	r18, 0x4B	; 75
    5dbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5dc0:	de 01       	movw	r26, r28
    5dc2:	a7 54       	subi	r26, 0x47	; 71
    5dc4:	bf 4f       	sbci	r27, 0xFF	; 255
    5dc6:	4d 91       	ld	r20, X+
    5dc8:	5d 91       	ld	r21, X+
    5dca:	6d 91       	ld	r22, X+
    5dcc:	7c 91       	ld	r23, X
    5dce:	d9 01       	movw	r26, r18
    5dd0:	4d 93       	st	X+, r20
    5dd2:	5d 93       	st	X+, r21
    5dd4:	6d 93       	st	X+, r22
    5dd6:	7c 93       	st	X, r23
    5dd8:	13 97       	sbiw	r26, 0x03	; 3
    5dda:	9f 01       	movw	r18, r30
    5ddc:	27 54       	subi	r18, 0x47	; 71
    5dde:	3f 4f       	sbci	r19, 0xFF	; 255
    5de0:	de 01       	movw	r26, r28
    5de2:	a3 54       	subi	r26, 0x43	; 67
    5de4:	bf 4f       	sbci	r27, 0xFF	; 255
    5de6:	4d 91       	ld	r20, X+
    5de8:	5d 91       	ld	r21, X+
    5dea:	6d 91       	ld	r22, X+
    5dec:	7c 91       	ld	r23, X
    5dee:	d9 01       	movw	r26, r18
    5df0:	4d 93       	st	X+, r20
    5df2:	5d 93       	st	X+, r21
    5df4:	6d 93       	st	X+, r22
    5df6:	7c 93       	st	X, r23
    5df8:	13 97       	sbiw	r26, 0x03	; 3
    5dfa:	9f 01       	movw	r18, r30
    5dfc:	23 54       	subi	r18, 0x43	; 67
    5dfe:	3f 4f       	sbci	r19, 0xFF	; 255
    5e00:	de 01       	movw	r26, r28
    5e02:	af 53       	subi	r26, 0x3F	; 63
    5e04:	bf 4f       	sbci	r27, 0xFF	; 255
    5e06:	4d 91       	ld	r20, X+
    5e08:	5d 91       	ld	r21, X+
    5e0a:	6d 91       	ld	r22, X+
    5e0c:	7c 91       	ld	r23, X
    5e0e:	d9 01       	movw	r26, r18
    5e10:	4d 93       	st	X+, r20
    5e12:	5d 93       	st	X+, r21
    5e14:	6d 93       	st	X+, r22
    5e16:	7c 93       	st	X, r23
    5e18:	13 97       	sbiw	r26, 0x03	; 3
    5e1a:	9f 01       	movw	r18, r30
    5e1c:	2f 53       	subi	r18, 0x3F	; 63
    5e1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e20:	de 01       	movw	r26, r28
    5e22:	ab 53       	subi	r26, 0x3B	; 59
    5e24:	bf 4f       	sbci	r27, 0xFF	; 255
    5e26:	4d 91       	ld	r20, X+
    5e28:	5d 91       	ld	r21, X+
    5e2a:	6d 91       	ld	r22, X+
    5e2c:	7c 91       	ld	r23, X
    5e2e:	d9 01       	movw	r26, r18
    5e30:	4d 93       	st	X+, r20
    5e32:	5d 93       	st	X+, r21
    5e34:	6d 93       	st	X+, r22
    5e36:	7c 93       	st	X, r23
    5e38:	13 97       	sbiw	r26, 0x03	; 3
    5e3a:	9f 01       	movw	r18, r30
    5e3c:	2b 53       	subi	r18, 0x3B	; 59
    5e3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e40:	de 01       	movw	r26, r28
    5e42:	a7 53       	subi	r26, 0x37	; 55
    5e44:	bf 4f       	sbci	r27, 0xFF	; 255
    5e46:	4d 91       	ld	r20, X+
    5e48:	5d 91       	ld	r21, X+
    5e4a:	6d 91       	ld	r22, X+
    5e4c:	7c 91       	ld	r23, X
    5e4e:	d9 01       	movw	r26, r18
    5e50:	4d 93       	st	X+, r20
    5e52:	5d 93       	st	X+, r21
    5e54:	6d 93       	st	X+, r22
    5e56:	7c 93       	st	X, r23
    5e58:	13 97       	sbiw	r26, 0x03	; 3
    5e5a:	9f 01       	movw	r18, r30
    5e5c:	27 53       	subi	r18, 0x37	; 55
    5e5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e60:	de 01       	movw	r26, r28
    5e62:	a3 53       	subi	r26, 0x33	; 51
    5e64:	bf 4f       	sbci	r27, 0xFF	; 255
    5e66:	4d 91       	ld	r20, X+
    5e68:	5d 91       	ld	r21, X+
    5e6a:	6d 91       	ld	r22, X+
    5e6c:	7c 91       	ld	r23, X
    5e6e:	d9 01       	movw	r26, r18
    5e70:	4d 93       	st	X+, r20
    5e72:	5d 93       	st	X+, r21
    5e74:	6d 93       	st	X+, r22
    5e76:	7c 93       	st	X, r23
    5e78:	13 97       	sbiw	r26, 0x03	; 3
    5e7a:	9f 01       	movw	r18, r30
    5e7c:	23 53       	subi	r18, 0x33	; 51
    5e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e80:	de 01       	movw	r26, r28
    5e82:	af 52       	subi	r26, 0x2F	; 47
    5e84:	bf 4f       	sbci	r27, 0xFF	; 255
    5e86:	4d 91       	ld	r20, X+
    5e88:	5d 91       	ld	r21, X+
    5e8a:	6d 91       	ld	r22, X+
    5e8c:	7c 91       	ld	r23, X
    5e8e:	d9 01       	movw	r26, r18
    5e90:	4d 93       	st	X+, r20
    5e92:	5d 93       	st	X+, r21
    5e94:	6d 93       	st	X+, r22
    5e96:	7c 93       	st	X, r23
    5e98:	13 97       	sbiw	r26, 0x03	; 3
    5e9a:	9f 01       	movw	r18, r30
    5e9c:	2f 52       	subi	r18, 0x2F	; 47
    5e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5ea0:	de 01       	movw	r26, r28
    5ea2:	ab 52       	subi	r26, 0x2B	; 43
    5ea4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ea6:	4d 91       	ld	r20, X+
    5ea8:	5d 91       	ld	r21, X+
    5eaa:	6d 91       	ld	r22, X+
    5eac:	7c 91       	ld	r23, X
    5eae:	d9 01       	movw	r26, r18
    5eb0:	4d 93       	st	X+, r20
    5eb2:	5d 93       	st	X+, r21
    5eb4:	6d 93       	st	X+, r22
    5eb6:	7c 93       	st	X, r23
    5eb8:	13 97       	sbiw	r26, 0x03	; 3
    5eba:	9f 01       	movw	r18, r30
    5ebc:	2b 52       	subi	r18, 0x2B	; 43
    5ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec0:	de 01       	movw	r26, r28
    5ec2:	a7 52       	subi	r26, 0x27	; 39
    5ec4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ec6:	4d 91       	ld	r20, X+
    5ec8:	5d 91       	ld	r21, X+
    5eca:	6d 91       	ld	r22, X+
    5ecc:	7c 91       	ld	r23, X
    5ece:	d9 01       	movw	r26, r18
    5ed0:	4d 93       	st	X+, r20
    5ed2:	5d 93       	st	X+, r21
    5ed4:	6d 93       	st	X+, r22
    5ed6:	7c 93       	st	X, r23
    5ed8:	13 97       	sbiw	r26, 0x03	; 3
    5eda:	9f 01       	movw	r18, r30
    5edc:	27 52       	subi	r18, 0x27	; 39
    5ede:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee0:	de 01       	movw	r26, r28
    5ee2:	a3 52       	subi	r26, 0x23	; 35
    5ee4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ee6:	4d 91       	ld	r20, X+
    5ee8:	5d 91       	ld	r21, X+
    5eea:	6d 91       	ld	r22, X+
    5eec:	7c 91       	ld	r23, X
    5eee:	d9 01       	movw	r26, r18
    5ef0:	4d 93       	st	X+, r20
    5ef2:	5d 93       	st	X+, r21
    5ef4:	6d 93       	st	X+, r22
    5ef6:	7c 93       	st	X, r23
    5ef8:	13 97       	sbiw	r26, 0x03	; 3
    5efa:	9f 01       	movw	r18, r30
    5efc:	23 52       	subi	r18, 0x23	; 35
    5efe:	3f 4f       	sbci	r19, 0xFF	; 255
    5f00:	de 01       	movw	r26, r28
    5f02:	af 51       	subi	r26, 0x1F	; 31
    5f04:	bf 4f       	sbci	r27, 0xFF	; 255
    5f06:	4d 91       	ld	r20, X+
    5f08:	5d 91       	ld	r21, X+
    5f0a:	6d 91       	ld	r22, X+
    5f0c:	7c 91       	ld	r23, X
    5f0e:	d9 01       	movw	r26, r18
    5f10:	4d 93       	st	X+, r20
    5f12:	5d 93       	st	X+, r21
    5f14:	6d 93       	st	X+, r22
    5f16:	7c 93       	st	X, r23
    5f18:	13 97       	sbiw	r26, 0x03	; 3
    5f1a:	9f 01       	movw	r18, r30
    5f1c:	2f 51       	subi	r18, 0x1F	; 31
    5f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f20:	de 01       	movw	r26, r28
    5f22:	ab 51       	subi	r26, 0x1B	; 27
    5f24:	bf 4f       	sbci	r27, 0xFF	; 255
    5f26:	4d 91       	ld	r20, X+
    5f28:	5d 91       	ld	r21, X+
    5f2a:	6d 91       	ld	r22, X+
    5f2c:	7c 91       	ld	r23, X
    5f2e:	d9 01       	movw	r26, r18
    5f30:	4d 93       	st	X+, r20
    5f32:	5d 93       	st	X+, r21
    5f34:	6d 93       	st	X+, r22
    5f36:	7c 93       	st	X, r23
    5f38:	13 97       	sbiw	r26, 0x03	; 3
    5f3a:	9f 01       	movw	r18, r30
    5f3c:	2b 51       	subi	r18, 0x1B	; 27
    5f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f40:	de 01       	movw	r26, r28
    5f42:	a7 51       	subi	r26, 0x17	; 23
    5f44:	bf 4f       	sbci	r27, 0xFF	; 255
    5f46:	4d 91       	ld	r20, X+
    5f48:	5d 91       	ld	r21, X+
    5f4a:	6d 91       	ld	r22, X+
    5f4c:	7c 91       	ld	r23, X
    5f4e:	d9 01       	movw	r26, r18
    5f50:	4d 93       	st	X+, r20
    5f52:	5d 93       	st	X+, r21
    5f54:	6d 93       	st	X+, r22
    5f56:	7c 93       	st	X, r23
    5f58:	13 97       	sbiw	r26, 0x03	; 3
    5f5a:	9f 01       	movw	r18, r30
    5f5c:	27 51       	subi	r18, 0x17	; 23
    5f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f60:	de 01       	movw	r26, r28
    5f62:	a3 51       	subi	r26, 0x13	; 19
    5f64:	bf 4f       	sbci	r27, 0xFF	; 255
    5f66:	4d 91       	ld	r20, X+
    5f68:	5d 91       	ld	r21, X+
    5f6a:	6d 91       	ld	r22, X+
    5f6c:	7c 91       	ld	r23, X
    5f6e:	d9 01       	movw	r26, r18
    5f70:	4d 93       	st	X+, r20
    5f72:	5d 93       	st	X+, r21
    5f74:	6d 93       	st	X+, r22
    5f76:	7c 93       	st	X, r23
    5f78:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5f7a:	9f 01       	movw	r18, r30
    5f7c:	23 51       	subi	r18, 0x13	; 19
    5f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f80:	de 01       	movw	r26, r28
    5f82:	af 50       	subi	r26, 0x0F	; 15
    5f84:	bf 4f       	sbci	r27, 0xFF	; 255
    5f86:	4d 91       	ld	r20, X+
    5f88:	5d 91       	ld	r21, X+
    5f8a:	6d 91       	ld	r22, X+
    5f8c:	7c 91       	ld	r23, X
    5f8e:	d9 01       	movw	r26, r18
    5f90:	4d 93       	st	X+, r20
    5f92:	5d 93       	st	X+, r21
    5f94:	6d 93       	st	X+, r22
    5f96:	7c 93       	st	X, r23
    5f98:	13 97       	sbiw	r26, 0x03	; 3
    5f9a:	9f 01       	movw	r18, r30
    5f9c:	2f 50       	subi	r18, 0x0F	; 15
    5f9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5fa0:	de 01       	movw	r26, r28
    5fa2:	ab 50       	subi	r26, 0x0B	; 11
    5fa4:	bf 4f       	sbci	r27, 0xFF	; 255
    5fa6:	4d 91       	ld	r20, X+
    5fa8:	5d 91       	ld	r21, X+
    5faa:	6d 91       	ld	r22, X+
    5fac:	7c 91       	ld	r23, X
    5fae:	d9 01       	movw	r26, r18
    5fb0:	4d 93       	st	X+, r20
    5fb2:	5d 93       	st	X+, r21
    5fb4:	6d 93       	st	X+, r22
    5fb6:	7c 93       	st	X, r23
    5fb8:	13 97       	sbiw	r26, 0x03	; 3
    5fba:	9f 01       	movw	r18, r30
    5fbc:	2b 50       	subi	r18, 0x0B	; 11
    5fbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5fc0:	de 01       	movw	r26, r28
    5fc2:	a7 50       	subi	r26, 0x07	; 7
    5fc4:	bf 4f       	sbci	r27, 0xFF	; 255
    5fc6:	4d 91       	ld	r20, X+
    5fc8:	5d 91       	ld	r21, X+
    5fca:	6d 91       	ld	r22, X+
    5fcc:	7c 91       	ld	r23, X
    5fce:	d9 01       	movw	r26, r18
    5fd0:	4d 93       	st	X+, r20
    5fd2:	5d 93       	st	X+, r21
    5fd4:	6d 93       	st	X+, r22
    5fd6:	7c 93       	st	X, r23
    5fd8:	13 97       	sbiw	r26, 0x03	; 3
    5fda:	9f 01       	movw	r18, r30
    5fdc:	27 50       	subi	r18, 0x07	; 7
    5fde:	3f 4f       	sbci	r19, 0xFF	; 255
    5fe0:	de 01       	movw	r26, r28
    5fe2:	a3 50       	subi	r26, 0x03	; 3
    5fe4:	bf 4f       	sbci	r27, 0xFF	; 255
    5fe6:	4d 91       	ld	r20, X+
    5fe8:	5d 91       	ld	r21, X+
    5fea:	6d 91       	ld	r22, X+
    5fec:	7c 91       	ld	r23, X
    5fee:	d9 01       	movw	r26, r18
    5ff0:	4d 93       	st	X+, r20
    5ff2:	5d 93       	st	X+, r21
    5ff4:	6d 93       	st	X+, r22
    5ff6:	7c 93       	st	X, r23
    5ff8:	13 97       	sbiw	r26, 0x03	; 3
    5ffa:	9f 01       	movw	r18, r30
    5ffc:	23 50       	subi	r18, 0x03	; 3
    5ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    6000:	de 01       	movw	r26, r28
    6002:	af 5f       	subi	r26, 0xFF	; 255
    6004:	be 4f       	sbci	r27, 0xFE	; 254
    6006:	4d 91       	ld	r20, X+
    6008:	5d 91       	ld	r21, X+
    600a:	6d 91       	ld	r22, X+
    600c:	7c 91       	ld	r23, X
    600e:	d9 01       	movw	r26, r18
    6010:	4d 93       	st	X+, r20
    6012:	5d 93       	st	X+, r21
    6014:	6d 93       	st	X+, r22
    6016:	7c 93       	st	X, r23
    6018:	13 97       	sbiw	r26, 0x03	; 3
    601a:	9f 01       	movw	r18, r30
    601c:	2f 5f       	subi	r18, 0xFF	; 255
    601e:	3e 4f       	sbci	r19, 0xFE	; 254
    6020:	de 01       	movw	r26, r28
    6022:	ab 5f       	subi	r26, 0xFB	; 251
    6024:	be 4f       	sbci	r27, 0xFE	; 254
    6026:	4d 91       	ld	r20, X+
    6028:	5d 91       	ld	r21, X+
    602a:	6d 91       	ld	r22, X+
    602c:	7c 91       	ld	r23, X
    602e:	d9 01       	movw	r26, r18
    6030:	4d 93       	st	X+, r20
    6032:	5d 93       	st	X+, r21
    6034:	6d 93       	st	X+, r22
    6036:	7c 93       	st	X, r23
    6038:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    603a:	9f 01       	movw	r18, r30
    603c:	2b 5f       	subi	r18, 0xFB	; 251
    603e:	3e 4f       	sbci	r19, 0xFE	; 254
    6040:	de 01       	movw	r26, r28
    6042:	a7 5f       	subi	r26, 0xF7	; 247
    6044:	be 4f       	sbci	r27, 0xFE	; 254
    6046:	4d 91       	ld	r20, X+
    6048:	5d 91       	ld	r21, X+
    604a:	6d 91       	ld	r22, X+
    604c:	7c 91       	ld	r23, X
    604e:	d9 01       	movw	r26, r18
    6050:	4d 93       	st	X+, r20
    6052:	5d 93       	st	X+, r21
    6054:	6d 93       	st	X+, r22
    6056:	7c 93       	st	X, r23
    6058:	13 97       	sbiw	r26, 0x03	; 3
    605a:	9f 01       	movw	r18, r30
    605c:	27 5f       	subi	r18, 0xF7	; 247
    605e:	3e 4f       	sbci	r19, 0xFE	; 254
    6060:	de 01       	movw	r26, r28
    6062:	a3 5f       	subi	r26, 0xF3	; 243
    6064:	be 4f       	sbci	r27, 0xFE	; 254
    6066:	4d 91       	ld	r20, X+
    6068:	5d 91       	ld	r21, X+
    606a:	6d 91       	ld	r22, X+
    606c:	7c 91       	ld	r23, X
    606e:	d9 01       	movw	r26, r18
    6070:	4d 93       	st	X+, r20
    6072:	5d 93       	st	X+, r21
    6074:	6d 93       	st	X+, r22
    6076:	7c 93       	st	X, r23
    6078:	13 97       	sbiw	r26, 0x03	; 3
    607a:	9f 01       	movw	r18, r30
    607c:	23 5f       	subi	r18, 0xF3	; 243
    607e:	3e 4f       	sbci	r19, 0xFE	; 254
    6080:	de 01       	movw	r26, r28
    6082:	af 5e       	subi	r26, 0xEF	; 239
    6084:	be 4f       	sbci	r27, 0xFE	; 254
    6086:	4d 91       	ld	r20, X+
    6088:	5d 91       	ld	r21, X+
    608a:	6d 91       	ld	r22, X+
    608c:	7c 91       	ld	r23, X
    608e:	d9 01       	movw	r26, r18
    6090:	4d 93       	st	X+, r20
    6092:	5d 93       	st	X+, r21
    6094:	6d 93       	st	X+, r22
    6096:	7c 93       	st	X, r23
    6098:	13 97       	sbiw	r26, 0x03	; 3
    609a:	9f 01       	movw	r18, r30
    609c:	2f 5e       	subi	r18, 0xEF	; 239
    609e:	3e 4f       	sbci	r19, 0xFE	; 254
    60a0:	de 01       	movw	r26, r28
    60a2:	ab 5e       	subi	r26, 0xEB	; 235
    60a4:	be 4f       	sbci	r27, 0xFE	; 254
    60a6:	4d 91       	ld	r20, X+
    60a8:	5d 91       	ld	r21, X+
    60aa:	6d 91       	ld	r22, X+
    60ac:	7c 91       	ld	r23, X
    60ae:	d9 01       	movw	r26, r18
    60b0:	4d 93       	st	X+, r20
    60b2:	5d 93       	st	X+, r21
    60b4:	6d 93       	st	X+, r22
    60b6:	7c 93       	st	X, r23
    60b8:	13 97       	sbiw	r26, 0x03	; 3
    60ba:	9f 01       	movw	r18, r30
    60bc:	2b 5e       	subi	r18, 0xEB	; 235
    60be:	3e 4f       	sbci	r19, 0xFE	; 254
    60c0:	de 01       	movw	r26, r28
    60c2:	a7 5e       	subi	r26, 0xE7	; 231
    60c4:	be 4f       	sbci	r27, 0xFE	; 254
    60c6:	4d 91       	ld	r20, X+
    60c8:	5d 91       	ld	r21, X+
    60ca:	6d 91       	ld	r22, X+
    60cc:	7c 91       	ld	r23, X
    60ce:	d9 01       	movw	r26, r18
    60d0:	4d 93       	st	X+, r20
    60d2:	5d 93       	st	X+, r21
    60d4:	6d 93       	st	X+, r22
    60d6:	7c 93       	st	X, r23
    60d8:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    60da:	9f 01       	movw	r18, r30
    60dc:	27 5e       	subi	r18, 0xE7	; 231
    60de:	3e 4f       	sbci	r19, 0xFE	; 254
    60e0:	de 01       	movw	r26, r28
    60e2:	a3 5e       	subi	r26, 0xE3	; 227
    60e4:	be 4f       	sbci	r27, 0xFE	; 254
    60e6:	4d 91       	ld	r20, X+
    60e8:	5d 91       	ld	r21, X+
    60ea:	6d 91       	ld	r22, X+
    60ec:	7c 91       	ld	r23, X
    60ee:	d9 01       	movw	r26, r18
    60f0:	4d 93       	st	X+, r20
    60f2:	5d 93       	st	X+, r21
    60f4:	6d 93       	st	X+, r22
    60f6:	7c 93       	st	X, r23
    60f8:	13 97       	sbiw	r26, 0x03	; 3
    60fa:	9f 01       	movw	r18, r30
    60fc:	23 5e       	subi	r18, 0xE3	; 227
    60fe:	3e 4f       	sbci	r19, 0xFE	; 254
    6100:	de 01       	movw	r26, r28
    6102:	af 5d       	subi	r26, 0xDF	; 223
    6104:	be 4f       	sbci	r27, 0xFE	; 254
    6106:	4d 91       	ld	r20, X+
    6108:	5d 91       	ld	r21, X+
    610a:	6d 91       	ld	r22, X+
    610c:	7c 91       	ld	r23, X
    610e:	d9 01       	movw	r26, r18
    6110:	4d 93       	st	X+, r20
    6112:	5d 93       	st	X+, r21
    6114:	6d 93       	st	X+, r22
    6116:	7c 93       	st	X, r23
    6118:	13 97       	sbiw	r26, 0x03	; 3
    611a:	9f 01       	movw	r18, r30
    611c:	2f 5d       	subi	r18, 0xDF	; 223
    611e:	3e 4f       	sbci	r19, 0xFE	; 254
    6120:	ce 01       	movw	r24, r28
    6122:	8b 5d       	subi	r24, 0xDB	; 219
    6124:	9e 4f       	sbci	r25, 0xFE	; 254
    6126:	dc 01       	movw	r26, r24
    6128:	4d 91       	ld	r20, X+
    612a:	5d 91       	ld	r21, X+
    612c:	6d 91       	ld	r22, X+
    612e:	7c 91       	ld	r23, X
    6130:	d9 01       	movw	r26, r18
    6132:	4d 93       	st	X+, r20
    6134:	5d 93       	st	X+, r21
    6136:	6d 93       	st	X+, r22
    6138:	7c 93       	st	X, r23
    613a:	13 97       	sbiw	r26, 0x03	; 3
    613c:	9f 01       	movw	r18, r30
    613e:	2b 5d       	subi	r18, 0xDB	; 219
    6140:	3e 4f       	sbci	r19, 0xFE	; 254
    6142:	ce 01       	movw	r24, r28
    6144:	87 5d       	subi	r24, 0xD7	; 215
    6146:	9e 4f       	sbci	r25, 0xFE	; 254
    6148:	dc 01       	movw	r26, r24
    614a:	4d 91       	ld	r20, X+
    614c:	5d 91       	ld	r21, X+
    614e:	6d 91       	ld	r22, X+
    6150:	7c 91       	ld	r23, X
    6152:	d9 01       	movw	r26, r18
    6154:	4d 93       	st	X+, r20
    6156:	5d 93       	st	X+, r21
    6158:	6d 93       	st	X+, r22
    615a:	7c 93       	st	X, r23
    615c:	13 97       	sbiw	r26, 0x03	; 3
    615e:	df 01       	movw	r26, r30
    6160:	a7 5d       	subi	r26, 0xD7	; 215
    6162:	be 4f       	sbci	r27, 0xFE	; 254
    6164:	c3 5d       	subi	r28, 0xD3	; 211
    6166:	de 4f       	sbci	r29, 0xFE	; 254
    6168:	48 81       	ld	r20, Y
    616a:	59 81       	ldd	r21, Y+1	; 0x01
    616c:	6a 81       	ldd	r22, Y+2	; 0x02
    616e:	7b 81       	ldd	r23, Y+3	; 0x03
    6170:	4d 93       	st	X+, r20
    6172:	5d 93       	st	X+, r21
    6174:	6d 93       	st	X+, r22
    6176:	7c 93       	st	X, r23
    6178:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
				
	return msg;
}
    617a:	8e 2f       	mov	r24, r30
    617c:	9f 2f       	mov	r25, r31
    617e:	df 91       	pop	r29
    6180:	cf 91       	pop	r28
    6182:	08 95       	ret

00006184 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>:

void SystemTelemetryMessage::buildMessage(byte *message)
{
    6184:	cf 93       	push	r28
    6186:	df 93       	push	r29
    6188:	fc 01       	movw	r30, r24
    618a:	db 01       	movw	r26, r22
	if (message != NULL)
    618c:	10 97       	sbiw	r26, 0x00	; 0
    618e:	09 f4       	brne	.+2      	; 0x6192 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0xe>
    6190:	55 c4       	rjmp	.+2218   	; 0x6a3c <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0x8b8>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    6192:	8c 91       	ld	r24, X
    6194:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6196:	11 96       	adiw	r26, 0x01	; 1
    6198:	4d 91       	ld	r20, X+
    619a:	5d 91       	ld	r21, X+
    619c:	6d 91       	ld	r22, X+
    619e:	7c 91       	ld	r23, X
    61a0:	14 97       	sbiw	r26, 0x04	; 4
    61a2:	45 83       	std	Z+5, r20	; 0x05
    61a4:	56 83       	std	Z+6, r21	; 0x06
    61a6:	67 83       	std	Z+7, r22	; 0x07
    61a8:	70 87       	std	Z+8, r23	; 0x08
    61aa:	15 96       	adiw	r26, 0x05	; 5
    61ac:	4d 91       	ld	r20, X+
    61ae:	5d 91       	ld	r21, X+
    61b0:	6d 91       	ld	r22, X+
    61b2:	7c 91       	ld	r23, X
    61b4:	18 97       	sbiw	r26, 0x08	; 8
    61b6:	41 87       	std	Z+9, r20	; 0x09
    61b8:	52 87       	std	Z+10, r21	; 0x0a
    61ba:	63 87       	std	Z+11, r22	; 0x0b
    61bc:	74 87       	std	Z+12, r23	; 0x0c
    61be:	19 96       	adiw	r26, 0x09	; 9
    61c0:	4d 91       	ld	r20, X+
    61c2:	5d 91       	ld	r21, X+
    61c4:	6d 91       	ld	r22, X+
    61c6:	7c 91       	ld	r23, X
    61c8:	1c 97       	sbiw	r26, 0x0c	; 12
    61ca:	45 87       	std	Z+13, r20	; 0x0d
    61cc:	56 87       	std	Z+14, r21	; 0x0e
    61ce:	67 87       	std	Z+15, r22	; 0x0f
    61d0:	70 8b       	std	Z+16, r23	; 0x10
    61d2:	1d 96       	adiw	r26, 0x0d	; 13
    61d4:	4d 91       	ld	r20, X+
    61d6:	5d 91       	ld	r21, X+
    61d8:	6d 91       	ld	r22, X+
    61da:	7c 91       	ld	r23, X
    61dc:	50 97       	sbiw	r26, 0x10	; 16
    61de:	41 8b       	std	Z+17, r20	; 0x11
    61e0:	52 8b       	std	Z+18, r21	; 0x12
    61e2:	63 8b       	std	Z+19, r22	; 0x13
    61e4:	74 8b       	std	Z+20, r23	; 0x14
    61e6:	51 96       	adiw	r26, 0x11	; 17
    61e8:	4d 91       	ld	r20, X+
    61ea:	5d 91       	ld	r21, X+
    61ec:	6d 91       	ld	r22, X+
    61ee:	7c 91       	ld	r23, X
    61f0:	54 97       	sbiw	r26, 0x14	; 20
    61f2:	45 8b       	std	Z+21, r20	; 0x15
    61f4:	56 8b       	std	Z+22, r21	; 0x16
    61f6:	67 8b       	std	Z+23, r22	; 0x17
    61f8:	70 8f       	std	Z+24, r23	; 0x18
    61fa:	55 96       	adiw	r26, 0x15	; 21
    61fc:	4d 91       	ld	r20, X+
    61fe:	5d 91       	ld	r21, X+
    6200:	6d 91       	ld	r22, X+
    6202:	7c 91       	ld	r23, X
    6204:	58 97       	sbiw	r26, 0x18	; 24
    6206:	41 8f       	std	Z+25, r20	; 0x19
    6208:	52 8f       	std	Z+26, r21	; 0x1a
    620a:	63 8f       	std	Z+27, r22	; 0x1b
    620c:	74 8f       	std	Z+28, r23	; 0x1c
    620e:	59 96       	adiw	r26, 0x19	; 25
    6210:	4d 91       	ld	r20, X+
    6212:	5d 91       	ld	r21, X+
    6214:	6d 91       	ld	r22, X+
    6216:	7c 91       	ld	r23, X
    6218:	5c 97       	sbiw	r26, 0x1c	; 28
    621a:	45 8f       	std	Z+29, r20	; 0x1d
    621c:	56 8f       	std	Z+30, r21	; 0x1e
    621e:	67 8f       	std	Z+31, r22	; 0x1f
    6220:	70 a3       	std	Z+32, r23	; 0x20
    6222:	5d 96       	adiw	r26, 0x1d	; 29
    6224:	4d 91       	ld	r20, X+
    6226:	5d 91       	ld	r21, X+
    6228:	6d 91       	ld	r22, X+
    622a:	7c 91       	ld	r23, X
    622c:	90 97       	sbiw	r26, 0x20	; 32
    622e:	41 a3       	std	Z+33, r20	; 0x21
    6230:	52 a3       	std	Z+34, r21	; 0x22
    6232:	63 a3       	std	Z+35, r22	; 0x23
    6234:	74 a3       	std	Z+36, r23	; 0x24
    6236:	91 96       	adiw	r26, 0x21	; 33
    6238:	4d 91       	ld	r20, X+
    623a:	5d 91       	ld	r21, X+
    623c:	6d 91       	ld	r22, X+
    623e:	7c 91       	ld	r23, X
    6240:	94 97       	sbiw	r26, 0x24	; 36
    6242:	45 a3       	std	Z+37, r20	; 0x25
    6244:	56 a3       	std	Z+38, r21	; 0x26
    6246:	67 a3       	std	Z+39, r22	; 0x27
    6248:	70 a7       	std	Z+40, r23	; 0x28
    624a:	95 96       	adiw	r26, 0x25	; 37
    624c:	4d 91       	ld	r20, X+
    624e:	5d 91       	ld	r21, X+
    6250:	6d 91       	ld	r22, X+
    6252:	7c 91       	ld	r23, X
    6254:	98 97       	sbiw	r26, 0x28	; 40
    6256:	41 a7       	std	Z+41, r20	; 0x29
    6258:	52 a7       	std	Z+42, r21	; 0x2a
    625a:	63 a7       	std	Z+43, r22	; 0x2b
    625c:	74 a7       	std	Z+44, r23	; 0x2c
    625e:	99 96       	adiw	r26, 0x29	; 41
    6260:	4d 91       	ld	r20, X+
    6262:	5d 91       	ld	r21, X+
    6264:	6d 91       	ld	r22, X+
    6266:	7c 91       	ld	r23, X
    6268:	9c 97       	sbiw	r26, 0x2c	; 44
    626a:	45 a7       	std	Z+45, r20	; 0x2d
    626c:	56 a7       	std	Z+46, r21	; 0x2e
    626e:	67 a7       	std	Z+47, r22	; 0x2f
    6270:	70 ab       	std	Z+48, r23	; 0x30
    6272:	9d 96       	adiw	r26, 0x2d	; 45
    6274:	4d 91       	ld	r20, X+
    6276:	5d 91       	ld	r21, X+
    6278:	6d 91       	ld	r22, X+
    627a:	7c 91       	ld	r23, X
    627c:	d0 97       	sbiw	r26, 0x30	; 48
    627e:	41 ab       	std	Z+49, r20	; 0x31
    6280:	52 ab       	std	Z+50, r21	; 0x32
    6282:	63 ab       	std	Z+51, r22	; 0x33
    6284:	74 ab       	std	Z+52, r23	; 0x34
    6286:	d1 96       	adiw	r26, 0x31	; 49
    6288:	4d 91       	ld	r20, X+
    628a:	5d 91       	ld	r21, X+
    628c:	6d 91       	ld	r22, X+
    628e:	7c 91       	ld	r23, X
    6290:	d4 97       	sbiw	r26, 0x34	; 52
    6292:	45 ab       	std	Z+53, r20	; 0x35
    6294:	56 ab       	std	Z+54, r21	; 0x36
    6296:	67 ab       	std	Z+55, r22	; 0x37
    6298:	70 af       	std	Z+56, r23	; 0x38
    629a:	d5 96       	adiw	r26, 0x35	; 53
    629c:	4d 91       	ld	r20, X+
    629e:	5d 91       	ld	r21, X+
    62a0:	6d 91       	ld	r22, X+
    62a2:	7c 91       	ld	r23, X
    62a4:	d8 97       	sbiw	r26, 0x38	; 56
    62a6:	41 af       	std	Z+57, r20	; 0x39
    62a8:	52 af       	std	Z+58, r21	; 0x3a
    62aa:	63 af       	std	Z+59, r22	; 0x3b
    62ac:	74 af       	std	Z+60, r23	; 0x3c
    62ae:	ef 01       	movw	r28, r30
    62b0:	ed 96       	adiw	r28, 0x3d	; 61
    62b2:	d9 96       	adiw	r26, 0x39	; 57
    62b4:	4d 91       	ld	r20, X+
    62b6:	5d 91       	ld	r21, X+
    62b8:	6d 91       	ld	r22, X+
    62ba:	7c 91       	ld	r23, X
    62bc:	dc 97       	sbiw	r26, 0x3c	; 60
    62be:	48 83       	st	Y, r20
    62c0:	59 83       	std	Y+1, r21	; 0x01
    62c2:	6a 83       	std	Y+2, r22	; 0x02
    62c4:	7b 83       	std	Y+3, r23	; 0x03
    62c6:	9f 01       	movw	r18, r30
    62c8:	2f 5b       	subi	r18, 0xBF	; 191
    62ca:	3f 4f       	sbci	r19, 0xFF	; 255
    62cc:	cd 01       	movw	r24, r26
    62ce:	cd 96       	adiw	r24, 0x3d	; 61
    62d0:	ec 01       	movw	r28, r24
    62d2:	48 81       	ld	r20, Y
    62d4:	59 81       	ldd	r21, Y+1	; 0x01
    62d6:	6a 81       	ldd	r22, Y+2	; 0x02
    62d8:	7b 81       	ldd	r23, Y+3	; 0x03
    62da:	e9 01       	movw	r28, r18
    62dc:	48 83       	st	Y, r20
    62de:	59 83       	std	Y+1, r21	; 0x01
    62e0:	6a 83       	std	Y+2, r22	; 0x02
    62e2:	7b 83       	std	Y+3, r23	; 0x03
    62e4:	9f 01       	movw	r18, r30
    62e6:	2b 5b       	subi	r18, 0xBB	; 187
    62e8:	3f 4f       	sbci	r19, 0xFF	; 255
    62ea:	cd 01       	movw	r24, r26
    62ec:	8f 5b       	subi	r24, 0xBF	; 191
    62ee:	9f 4f       	sbci	r25, 0xFF	; 255
    62f0:	ec 01       	movw	r28, r24
    62f2:	48 81       	ld	r20, Y
    62f4:	59 81       	ldd	r21, Y+1	; 0x01
    62f6:	6a 81       	ldd	r22, Y+2	; 0x02
    62f8:	7b 81       	ldd	r23, Y+3	; 0x03
    62fa:	e9 01       	movw	r28, r18
    62fc:	48 83       	st	Y, r20
    62fe:	59 83       	std	Y+1, r21	; 0x01
    6300:	6a 83       	std	Y+2, r22	; 0x02
    6302:	7b 83       	std	Y+3, r23	; 0x03
    6304:	9f 01       	movw	r18, r30
    6306:	27 5b       	subi	r18, 0xB7	; 183
    6308:	3f 4f       	sbci	r19, 0xFF	; 255
    630a:	cd 01       	movw	r24, r26
    630c:	8b 5b       	subi	r24, 0xBB	; 187
    630e:	9f 4f       	sbci	r25, 0xFF	; 255
    6310:	ec 01       	movw	r28, r24
    6312:	48 81       	ld	r20, Y
    6314:	59 81       	ldd	r21, Y+1	; 0x01
    6316:	6a 81       	ldd	r22, Y+2	; 0x02
    6318:	7b 81       	ldd	r23, Y+3	; 0x03
    631a:	e9 01       	movw	r28, r18
    631c:	48 83       	st	Y, r20
    631e:	59 83       	std	Y+1, r21	; 0x01
    6320:	6a 83       	std	Y+2, r22	; 0x02
    6322:	7b 83       	std	Y+3, r23	; 0x03
    6324:	9f 01       	movw	r18, r30
    6326:	23 5b       	subi	r18, 0xB3	; 179
    6328:	3f 4f       	sbci	r19, 0xFF	; 255
    632a:	cd 01       	movw	r24, r26
    632c:	87 5b       	subi	r24, 0xB7	; 183
    632e:	9f 4f       	sbci	r25, 0xFF	; 255
    6330:	ec 01       	movw	r28, r24
    6332:	48 81       	ld	r20, Y
    6334:	59 81       	ldd	r21, Y+1	; 0x01
    6336:	6a 81       	ldd	r22, Y+2	; 0x02
    6338:	7b 81       	ldd	r23, Y+3	; 0x03
    633a:	e9 01       	movw	r28, r18
    633c:	48 83       	st	Y, r20
    633e:	59 83       	std	Y+1, r21	; 0x01
    6340:	6a 83       	std	Y+2, r22	; 0x02
    6342:	7b 83       	std	Y+3, r23	; 0x03
    6344:	9f 01       	movw	r18, r30
    6346:	2f 5a       	subi	r18, 0xAF	; 175
    6348:	3f 4f       	sbci	r19, 0xFF	; 255
    634a:	cd 01       	movw	r24, r26
    634c:	83 5b       	subi	r24, 0xB3	; 179
    634e:	9f 4f       	sbci	r25, 0xFF	; 255
    6350:	ec 01       	movw	r28, r24
    6352:	48 81       	ld	r20, Y
    6354:	59 81       	ldd	r21, Y+1	; 0x01
    6356:	6a 81       	ldd	r22, Y+2	; 0x02
    6358:	7b 81       	ldd	r23, Y+3	; 0x03
    635a:	e9 01       	movw	r28, r18
    635c:	48 83       	st	Y, r20
    635e:	59 83       	std	Y+1, r21	; 0x01
    6360:	6a 83       	std	Y+2, r22	; 0x02
    6362:	7b 83       	std	Y+3, r23	; 0x03
    6364:	9f 01       	movw	r18, r30
    6366:	2b 5a       	subi	r18, 0xAB	; 171
    6368:	3f 4f       	sbci	r19, 0xFF	; 255
    636a:	cd 01       	movw	r24, r26
    636c:	8f 5a       	subi	r24, 0xAF	; 175
    636e:	9f 4f       	sbci	r25, 0xFF	; 255
    6370:	ec 01       	movw	r28, r24
    6372:	48 81       	ld	r20, Y
    6374:	59 81       	ldd	r21, Y+1	; 0x01
    6376:	6a 81       	ldd	r22, Y+2	; 0x02
    6378:	7b 81       	ldd	r23, Y+3	; 0x03
    637a:	e9 01       	movw	r28, r18
    637c:	48 83       	st	Y, r20
    637e:	59 83       	std	Y+1, r21	; 0x01
    6380:	6a 83       	std	Y+2, r22	; 0x02
    6382:	7b 83       	std	Y+3, r23	; 0x03
    6384:	9f 01       	movw	r18, r30
    6386:	27 5a       	subi	r18, 0xA7	; 167
    6388:	3f 4f       	sbci	r19, 0xFF	; 255
    638a:	cd 01       	movw	r24, r26
    638c:	8b 5a       	subi	r24, 0xAB	; 171
    638e:	9f 4f       	sbci	r25, 0xFF	; 255
    6390:	ec 01       	movw	r28, r24
    6392:	48 81       	ld	r20, Y
    6394:	59 81       	ldd	r21, Y+1	; 0x01
    6396:	6a 81       	ldd	r22, Y+2	; 0x02
    6398:	7b 81       	ldd	r23, Y+3	; 0x03
    639a:	e9 01       	movw	r28, r18
    639c:	48 83       	st	Y, r20
    639e:	59 83       	std	Y+1, r21	; 0x01
    63a0:	6a 83       	std	Y+2, r22	; 0x02
    63a2:	7b 83       	std	Y+3, r23	; 0x03
    63a4:	9f 01       	movw	r18, r30
    63a6:	23 5a       	subi	r18, 0xA3	; 163
    63a8:	3f 4f       	sbci	r19, 0xFF	; 255
    63aa:	cd 01       	movw	r24, r26
    63ac:	87 5a       	subi	r24, 0xA7	; 167
    63ae:	9f 4f       	sbci	r25, 0xFF	; 255
    63b0:	ec 01       	movw	r28, r24
    63b2:	48 81       	ld	r20, Y
    63b4:	59 81       	ldd	r21, Y+1	; 0x01
    63b6:	6a 81       	ldd	r22, Y+2	; 0x02
    63b8:	7b 81       	ldd	r23, Y+3	; 0x03
    63ba:	e9 01       	movw	r28, r18
    63bc:	48 83       	st	Y, r20
    63be:	59 83       	std	Y+1, r21	; 0x01
    63c0:	6a 83       	std	Y+2, r22	; 0x02
    63c2:	7b 83       	std	Y+3, r23	; 0x03
    63c4:	9f 01       	movw	r18, r30
    63c6:	2f 59       	subi	r18, 0x9F	; 159
    63c8:	3f 4f       	sbci	r19, 0xFF	; 255
    63ca:	cd 01       	movw	r24, r26
    63cc:	83 5a       	subi	r24, 0xA3	; 163
    63ce:	9f 4f       	sbci	r25, 0xFF	; 255
    63d0:	ec 01       	movw	r28, r24
    63d2:	48 81       	ld	r20, Y
    63d4:	59 81       	ldd	r21, Y+1	; 0x01
    63d6:	6a 81       	ldd	r22, Y+2	; 0x02
    63d8:	7b 81       	ldd	r23, Y+3	; 0x03
    63da:	e9 01       	movw	r28, r18
    63dc:	48 83       	st	Y, r20
    63de:	59 83       	std	Y+1, r21	; 0x01
    63e0:	6a 83       	std	Y+2, r22	; 0x02
    63e2:	7b 83       	std	Y+3, r23	; 0x03
    63e4:	9f 01       	movw	r18, r30
    63e6:	2b 59       	subi	r18, 0x9B	; 155
    63e8:	3f 4f       	sbci	r19, 0xFF	; 255
    63ea:	cd 01       	movw	r24, r26
    63ec:	8f 59       	subi	r24, 0x9F	; 159
    63ee:	9f 4f       	sbci	r25, 0xFF	; 255
    63f0:	ec 01       	movw	r28, r24
    63f2:	48 81       	ld	r20, Y
    63f4:	59 81       	ldd	r21, Y+1	; 0x01
    63f6:	6a 81       	ldd	r22, Y+2	; 0x02
    63f8:	7b 81       	ldd	r23, Y+3	; 0x03
    63fa:	e9 01       	movw	r28, r18
    63fc:	48 83       	st	Y, r20
    63fe:	59 83       	std	Y+1, r21	; 0x01
    6400:	6a 83       	std	Y+2, r22	; 0x02
    6402:	7b 83       	std	Y+3, r23	; 0x03
    6404:	9f 01       	movw	r18, r30
    6406:	27 59       	subi	r18, 0x97	; 151
    6408:	3f 4f       	sbci	r19, 0xFF	; 255
    640a:	cd 01       	movw	r24, r26
    640c:	8b 59       	subi	r24, 0x9B	; 155
    640e:	9f 4f       	sbci	r25, 0xFF	; 255
    6410:	ec 01       	movw	r28, r24
    6412:	48 81       	ld	r20, Y
    6414:	59 81       	ldd	r21, Y+1	; 0x01
    6416:	6a 81       	ldd	r22, Y+2	; 0x02
    6418:	7b 81       	ldd	r23, Y+3	; 0x03
    641a:	e9 01       	movw	r28, r18
    641c:	48 83       	st	Y, r20
    641e:	59 83       	std	Y+1, r21	; 0x01
    6420:	6a 83       	std	Y+2, r22	; 0x02
    6422:	7b 83       	std	Y+3, r23	; 0x03
    6424:	9f 01       	movw	r18, r30
    6426:	23 59       	subi	r18, 0x93	; 147
    6428:	3f 4f       	sbci	r19, 0xFF	; 255
    642a:	cd 01       	movw	r24, r26
    642c:	87 59       	subi	r24, 0x97	; 151
    642e:	9f 4f       	sbci	r25, 0xFF	; 255
    6430:	ec 01       	movw	r28, r24
    6432:	48 81       	ld	r20, Y
    6434:	59 81       	ldd	r21, Y+1	; 0x01
    6436:	6a 81       	ldd	r22, Y+2	; 0x02
    6438:	7b 81       	ldd	r23, Y+3	; 0x03
    643a:	e9 01       	movw	r28, r18
    643c:	48 83       	st	Y, r20
    643e:	59 83       	std	Y+1, r21	; 0x01
    6440:	6a 83       	std	Y+2, r22	; 0x02
    6442:	7b 83       	std	Y+3, r23	; 0x03
    6444:	9f 01       	movw	r18, r30
    6446:	2f 58       	subi	r18, 0x8F	; 143
    6448:	3f 4f       	sbci	r19, 0xFF	; 255
    644a:	cd 01       	movw	r24, r26
    644c:	83 59       	subi	r24, 0x93	; 147
    644e:	9f 4f       	sbci	r25, 0xFF	; 255
    6450:	ec 01       	movw	r28, r24
    6452:	48 81       	ld	r20, Y
    6454:	59 81       	ldd	r21, Y+1	; 0x01
    6456:	6a 81       	ldd	r22, Y+2	; 0x02
    6458:	7b 81       	ldd	r23, Y+3	; 0x03
    645a:	e9 01       	movw	r28, r18
    645c:	48 83       	st	Y, r20
    645e:	59 83       	std	Y+1, r21	; 0x01
    6460:	6a 83       	std	Y+2, r22	; 0x02
    6462:	7b 83       	std	Y+3, r23	; 0x03
    6464:	9f 01       	movw	r18, r30
    6466:	2b 58       	subi	r18, 0x8B	; 139
    6468:	3f 4f       	sbci	r19, 0xFF	; 255
    646a:	cd 01       	movw	r24, r26
    646c:	8f 58       	subi	r24, 0x8F	; 143
    646e:	9f 4f       	sbci	r25, 0xFF	; 255
    6470:	ec 01       	movw	r28, r24
    6472:	48 81       	ld	r20, Y
    6474:	59 81       	ldd	r21, Y+1	; 0x01
    6476:	6a 81       	ldd	r22, Y+2	; 0x02
    6478:	7b 81       	ldd	r23, Y+3	; 0x03
    647a:	e9 01       	movw	r28, r18
    647c:	48 83       	st	Y, r20
    647e:	59 83       	std	Y+1, r21	; 0x01
    6480:	6a 83       	std	Y+2, r22	; 0x02
    6482:	7b 83       	std	Y+3, r23	; 0x03
    6484:	9f 01       	movw	r18, r30
    6486:	27 58       	subi	r18, 0x87	; 135
    6488:	3f 4f       	sbci	r19, 0xFF	; 255
    648a:	cd 01       	movw	r24, r26
    648c:	8b 58       	subi	r24, 0x8B	; 139
    648e:	9f 4f       	sbci	r25, 0xFF	; 255
    6490:	ec 01       	movw	r28, r24
    6492:	48 81       	ld	r20, Y
    6494:	59 81       	ldd	r21, Y+1	; 0x01
    6496:	6a 81       	ldd	r22, Y+2	; 0x02
    6498:	7b 81       	ldd	r23, Y+3	; 0x03
    649a:	e9 01       	movw	r28, r18
    649c:	48 83       	st	Y, r20
    649e:	59 83       	std	Y+1, r21	; 0x01
    64a0:	6a 83       	std	Y+2, r22	; 0x02
    64a2:	7b 83       	std	Y+3, r23	; 0x03
    64a4:	9f 01       	movw	r18, r30
    64a6:	23 58       	subi	r18, 0x83	; 131
    64a8:	3f 4f       	sbci	r19, 0xFF	; 255
    64aa:	cd 01       	movw	r24, r26
    64ac:	87 58       	subi	r24, 0x87	; 135
    64ae:	9f 4f       	sbci	r25, 0xFF	; 255
    64b0:	ec 01       	movw	r28, r24
    64b2:	48 81       	ld	r20, Y
    64b4:	59 81       	ldd	r21, Y+1	; 0x01
    64b6:	6a 81       	ldd	r22, Y+2	; 0x02
    64b8:	7b 81       	ldd	r23, Y+3	; 0x03
    64ba:	e9 01       	movw	r28, r18
    64bc:	48 83       	st	Y, r20
    64be:	59 83       	std	Y+1, r21	; 0x01
    64c0:	6a 83       	std	Y+2, r22	; 0x02
    64c2:	7b 83       	std	Y+3, r23	; 0x03
    64c4:	9f 01       	movw	r18, r30
    64c6:	2f 57       	subi	r18, 0x7F	; 127
    64c8:	3f 4f       	sbci	r19, 0xFF	; 255
    64ca:	cd 01       	movw	r24, r26
    64cc:	83 58       	subi	r24, 0x83	; 131
    64ce:	9f 4f       	sbci	r25, 0xFF	; 255
    64d0:	ec 01       	movw	r28, r24
    64d2:	48 81       	ld	r20, Y
    64d4:	59 81       	ldd	r21, Y+1	; 0x01
    64d6:	6a 81       	ldd	r22, Y+2	; 0x02
    64d8:	7b 81       	ldd	r23, Y+3	; 0x03
    64da:	e9 01       	movw	r28, r18
    64dc:	48 83       	st	Y, r20
    64de:	59 83       	std	Y+1, r21	; 0x01
    64e0:	6a 83       	std	Y+2, r22	; 0x02
    64e2:	7b 83       	std	Y+3, r23	; 0x03
    64e4:	9f 01       	movw	r18, r30
    64e6:	2b 57       	subi	r18, 0x7B	; 123
    64e8:	3f 4f       	sbci	r19, 0xFF	; 255
    64ea:	cd 01       	movw	r24, r26
    64ec:	8f 57       	subi	r24, 0x7F	; 127
    64ee:	9f 4f       	sbci	r25, 0xFF	; 255
    64f0:	ec 01       	movw	r28, r24
    64f2:	48 81       	ld	r20, Y
    64f4:	59 81       	ldd	r21, Y+1	; 0x01
    64f6:	6a 81       	ldd	r22, Y+2	; 0x02
    64f8:	7b 81       	ldd	r23, Y+3	; 0x03
    64fa:	e9 01       	movw	r28, r18
    64fc:	48 83       	st	Y, r20
    64fe:	59 83       	std	Y+1, r21	; 0x01
    6500:	6a 83       	std	Y+2, r22	; 0x02
    6502:	7b 83       	std	Y+3, r23	; 0x03
    6504:	9f 01       	movw	r18, r30
    6506:	27 57       	subi	r18, 0x77	; 119
    6508:	3f 4f       	sbci	r19, 0xFF	; 255
    650a:	cd 01       	movw	r24, r26
    650c:	8b 57       	subi	r24, 0x7B	; 123
    650e:	9f 4f       	sbci	r25, 0xFF	; 255
    6510:	ec 01       	movw	r28, r24
    6512:	48 81       	ld	r20, Y
    6514:	59 81       	ldd	r21, Y+1	; 0x01
    6516:	6a 81       	ldd	r22, Y+2	; 0x02
    6518:	7b 81       	ldd	r23, Y+3	; 0x03
    651a:	e9 01       	movw	r28, r18
    651c:	48 83       	st	Y, r20
    651e:	59 83       	std	Y+1, r21	; 0x01
    6520:	6a 83       	std	Y+2, r22	; 0x02
    6522:	7b 83       	std	Y+3, r23	; 0x03
    6524:	9f 01       	movw	r18, r30
    6526:	23 57       	subi	r18, 0x73	; 115
    6528:	3f 4f       	sbci	r19, 0xFF	; 255
    652a:	cd 01       	movw	r24, r26
    652c:	87 57       	subi	r24, 0x77	; 119
    652e:	9f 4f       	sbci	r25, 0xFF	; 255
    6530:	ec 01       	movw	r28, r24
    6532:	48 81       	ld	r20, Y
    6534:	59 81       	ldd	r21, Y+1	; 0x01
    6536:	6a 81       	ldd	r22, Y+2	; 0x02
    6538:	7b 81       	ldd	r23, Y+3	; 0x03
    653a:	e9 01       	movw	r28, r18
    653c:	48 83       	st	Y, r20
    653e:	59 83       	std	Y+1, r21	; 0x01
    6540:	6a 83       	std	Y+2, r22	; 0x02
    6542:	7b 83       	std	Y+3, r23	; 0x03
    6544:	9f 01       	movw	r18, r30
    6546:	2f 56       	subi	r18, 0x6F	; 111
    6548:	3f 4f       	sbci	r19, 0xFF	; 255
    654a:	cd 01       	movw	r24, r26
    654c:	83 57       	subi	r24, 0x73	; 115
    654e:	9f 4f       	sbci	r25, 0xFF	; 255
    6550:	ec 01       	movw	r28, r24
    6552:	48 81       	ld	r20, Y
    6554:	59 81       	ldd	r21, Y+1	; 0x01
    6556:	6a 81       	ldd	r22, Y+2	; 0x02
    6558:	7b 81       	ldd	r23, Y+3	; 0x03
    655a:	e9 01       	movw	r28, r18
    655c:	48 83       	st	Y, r20
    655e:	59 83       	std	Y+1, r21	; 0x01
    6560:	6a 83       	std	Y+2, r22	; 0x02
    6562:	7b 83       	std	Y+3, r23	; 0x03
    6564:	9f 01       	movw	r18, r30
    6566:	2b 56       	subi	r18, 0x6B	; 107
    6568:	3f 4f       	sbci	r19, 0xFF	; 255
    656a:	cd 01       	movw	r24, r26
    656c:	8f 56       	subi	r24, 0x6F	; 111
    656e:	9f 4f       	sbci	r25, 0xFF	; 255
    6570:	ec 01       	movw	r28, r24
    6572:	48 81       	ld	r20, Y
    6574:	59 81       	ldd	r21, Y+1	; 0x01
    6576:	6a 81       	ldd	r22, Y+2	; 0x02
    6578:	7b 81       	ldd	r23, Y+3	; 0x03
    657a:	e9 01       	movw	r28, r18
    657c:	48 83       	st	Y, r20
    657e:	59 83       	std	Y+1, r21	; 0x01
    6580:	6a 83       	std	Y+2, r22	; 0x02
    6582:	7b 83       	std	Y+3, r23	; 0x03
    6584:	9f 01       	movw	r18, r30
    6586:	27 56       	subi	r18, 0x67	; 103
    6588:	3f 4f       	sbci	r19, 0xFF	; 255
    658a:	cd 01       	movw	r24, r26
    658c:	8b 56       	subi	r24, 0x6B	; 107
    658e:	9f 4f       	sbci	r25, 0xFF	; 255
    6590:	ec 01       	movw	r28, r24
    6592:	48 81       	ld	r20, Y
    6594:	59 81       	ldd	r21, Y+1	; 0x01
    6596:	6a 81       	ldd	r22, Y+2	; 0x02
    6598:	7b 81       	ldd	r23, Y+3	; 0x03
    659a:	e9 01       	movw	r28, r18
    659c:	48 83       	st	Y, r20
    659e:	59 83       	std	Y+1, r21	; 0x01
    65a0:	6a 83       	std	Y+2, r22	; 0x02
    65a2:	7b 83       	std	Y+3, r23	; 0x03
    65a4:	9f 01       	movw	r18, r30
    65a6:	23 56       	subi	r18, 0x63	; 99
    65a8:	3f 4f       	sbci	r19, 0xFF	; 255
    65aa:	cd 01       	movw	r24, r26
    65ac:	87 56       	subi	r24, 0x67	; 103
    65ae:	9f 4f       	sbci	r25, 0xFF	; 255
    65b0:	ec 01       	movw	r28, r24
    65b2:	48 81       	ld	r20, Y
    65b4:	59 81       	ldd	r21, Y+1	; 0x01
    65b6:	6a 81       	ldd	r22, Y+2	; 0x02
    65b8:	7b 81       	ldd	r23, Y+3	; 0x03
    65ba:	e9 01       	movw	r28, r18
    65bc:	48 83       	st	Y, r20
    65be:	59 83       	std	Y+1, r21	; 0x01
    65c0:	6a 83       	std	Y+2, r22	; 0x02
    65c2:	7b 83       	std	Y+3, r23	; 0x03
    65c4:	9f 01       	movw	r18, r30
    65c6:	2f 55       	subi	r18, 0x5F	; 95
    65c8:	3f 4f       	sbci	r19, 0xFF	; 255
    65ca:	cd 01       	movw	r24, r26
    65cc:	83 56       	subi	r24, 0x63	; 99
    65ce:	9f 4f       	sbci	r25, 0xFF	; 255
    65d0:	ec 01       	movw	r28, r24
    65d2:	48 81       	ld	r20, Y
    65d4:	59 81       	ldd	r21, Y+1	; 0x01
    65d6:	6a 81       	ldd	r22, Y+2	; 0x02
    65d8:	7b 81       	ldd	r23, Y+3	; 0x03
    65da:	e9 01       	movw	r28, r18
    65dc:	48 83       	st	Y, r20
    65de:	59 83       	std	Y+1, r21	; 0x01
    65e0:	6a 83       	std	Y+2, r22	; 0x02
    65e2:	7b 83       	std	Y+3, r23	; 0x03
    65e4:	9f 01       	movw	r18, r30
    65e6:	2b 55       	subi	r18, 0x5B	; 91
    65e8:	3f 4f       	sbci	r19, 0xFF	; 255
    65ea:	cd 01       	movw	r24, r26
    65ec:	8f 55       	subi	r24, 0x5F	; 95
    65ee:	9f 4f       	sbci	r25, 0xFF	; 255
    65f0:	ec 01       	movw	r28, r24
    65f2:	48 81       	ld	r20, Y
    65f4:	59 81       	ldd	r21, Y+1	; 0x01
    65f6:	6a 81       	ldd	r22, Y+2	; 0x02
    65f8:	7b 81       	ldd	r23, Y+3	; 0x03
    65fa:	e9 01       	movw	r28, r18
    65fc:	48 83       	st	Y, r20
    65fe:	59 83       	std	Y+1, r21	; 0x01
    6600:	6a 83       	std	Y+2, r22	; 0x02
    6602:	7b 83       	std	Y+3, r23	; 0x03
    6604:	9f 01       	movw	r18, r30
    6606:	27 55       	subi	r18, 0x57	; 87
    6608:	3f 4f       	sbci	r19, 0xFF	; 255
    660a:	cd 01       	movw	r24, r26
    660c:	8b 55       	subi	r24, 0x5B	; 91
    660e:	9f 4f       	sbci	r25, 0xFF	; 255
    6610:	ec 01       	movw	r28, r24
    6612:	48 81       	ld	r20, Y
    6614:	59 81       	ldd	r21, Y+1	; 0x01
    6616:	6a 81       	ldd	r22, Y+2	; 0x02
    6618:	7b 81       	ldd	r23, Y+3	; 0x03
    661a:	e9 01       	movw	r28, r18
    661c:	48 83       	st	Y, r20
    661e:	59 83       	std	Y+1, r21	; 0x01
    6620:	6a 83       	std	Y+2, r22	; 0x02
    6622:	7b 83       	std	Y+3, r23	; 0x03
    6624:	9f 01       	movw	r18, r30
    6626:	23 55       	subi	r18, 0x53	; 83
    6628:	3f 4f       	sbci	r19, 0xFF	; 255
    662a:	cd 01       	movw	r24, r26
    662c:	87 55       	subi	r24, 0x57	; 87
    662e:	9f 4f       	sbci	r25, 0xFF	; 255
    6630:	ec 01       	movw	r28, r24
    6632:	48 81       	ld	r20, Y
    6634:	59 81       	ldd	r21, Y+1	; 0x01
    6636:	6a 81       	ldd	r22, Y+2	; 0x02
    6638:	7b 81       	ldd	r23, Y+3	; 0x03
    663a:	e9 01       	movw	r28, r18
    663c:	48 83       	st	Y, r20
    663e:	59 83       	std	Y+1, r21	; 0x01
    6640:	6a 83       	std	Y+2, r22	; 0x02
    6642:	7b 83       	std	Y+3, r23	; 0x03
    6644:	9f 01       	movw	r18, r30
    6646:	2f 54       	subi	r18, 0x4F	; 79
    6648:	3f 4f       	sbci	r19, 0xFF	; 255
    664a:	cd 01       	movw	r24, r26
    664c:	83 55       	subi	r24, 0x53	; 83
    664e:	9f 4f       	sbci	r25, 0xFF	; 255
    6650:	ec 01       	movw	r28, r24
    6652:	48 81       	ld	r20, Y
    6654:	59 81       	ldd	r21, Y+1	; 0x01
    6656:	6a 81       	ldd	r22, Y+2	; 0x02
    6658:	7b 81       	ldd	r23, Y+3	; 0x03
    665a:	e9 01       	movw	r28, r18
    665c:	48 83       	st	Y, r20
    665e:	59 83       	std	Y+1, r21	; 0x01
    6660:	6a 83       	std	Y+2, r22	; 0x02
    6662:	7b 83       	std	Y+3, r23	; 0x03
    6664:	9f 01       	movw	r18, r30
    6666:	2b 54       	subi	r18, 0x4B	; 75
    6668:	3f 4f       	sbci	r19, 0xFF	; 255
    666a:	cd 01       	movw	r24, r26
    666c:	8f 54       	subi	r24, 0x4F	; 79
    666e:	9f 4f       	sbci	r25, 0xFF	; 255
    6670:	ec 01       	movw	r28, r24
    6672:	48 81       	ld	r20, Y
    6674:	59 81       	ldd	r21, Y+1	; 0x01
    6676:	6a 81       	ldd	r22, Y+2	; 0x02
    6678:	7b 81       	ldd	r23, Y+3	; 0x03
    667a:	e9 01       	movw	r28, r18
    667c:	48 83       	st	Y, r20
    667e:	59 83       	std	Y+1, r21	; 0x01
    6680:	6a 83       	std	Y+2, r22	; 0x02
    6682:	7b 83       	std	Y+3, r23	; 0x03
    6684:	9f 01       	movw	r18, r30
    6686:	27 54       	subi	r18, 0x47	; 71
    6688:	3f 4f       	sbci	r19, 0xFF	; 255
    668a:	cd 01       	movw	r24, r26
    668c:	8b 54       	subi	r24, 0x4B	; 75
    668e:	9f 4f       	sbci	r25, 0xFF	; 255
    6690:	ec 01       	movw	r28, r24
    6692:	48 81       	ld	r20, Y
    6694:	59 81       	ldd	r21, Y+1	; 0x01
    6696:	6a 81       	ldd	r22, Y+2	; 0x02
    6698:	7b 81       	ldd	r23, Y+3	; 0x03
    669a:	e9 01       	movw	r28, r18
    669c:	48 83       	st	Y, r20
    669e:	59 83       	std	Y+1, r21	; 0x01
    66a0:	6a 83       	std	Y+2, r22	; 0x02
    66a2:	7b 83       	std	Y+3, r23	; 0x03
    66a4:	9f 01       	movw	r18, r30
    66a6:	23 54       	subi	r18, 0x43	; 67
    66a8:	3f 4f       	sbci	r19, 0xFF	; 255
    66aa:	cd 01       	movw	r24, r26
    66ac:	87 54       	subi	r24, 0x47	; 71
    66ae:	9f 4f       	sbci	r25, 0xFF	; 255
    66b0:	ec 01       	movw	r28, r24
    66b2:	48 81       	ld	r20, Y
    66b4:	59 81       	ldd	r21, Y+1	; 0x01
    66b6:	6a 81       	ldd	r22, Y+2	; 0x02
    66b8:	7b 81       	ldd	r23, Y+3	; 0x03
    66ba:	e9 01       	movw	r28, r18
    66bc:	48 83       	st	Y, r20
    66be:	59 83       	std	Y+1, r21	; 0x01
    66c0:	6a 83       	std	Y+2, r22	; 0x02
    66c2:	7b 83       	std	Y+3, r23	; 0x03
    66c4:	9f 01       	movw	r18, r30
    66c6:	2f 53       	subi	r18, 0x3F	; 63
    66c8:	3f 4f       	sbci	r19, 0xFF	; 255
    66ca:	cd 01       	movw	r24, r26
    66cc:	83 54       	subi	r24, 0x43	; 67
    66ce:	9f 4f       	sbci	r25, 0xFF	; 255
    66d0:	ec 01       	movw	r28, r24
    66d2:	48 81       	ld	r20, Y
    66d4:	59 81       	ldd	r21, Y+1	; 0x01
    66d6:	6a 81       	ldd	r22, Y+2	; 0x02
    66d8:	7b 81       	ldd	r23, Y+3	; 0x03
    66da:	e9 01       	movw	r28, r18
    66dc:	48 83       	st	Y, r20
    66de:	59 83       	std	Y+1, r21	; 0x01
    66e0:	6a 83       	std	Y+2, r22	; 0x02
    66e2:	7b 83       	std	Y+3, r23	; 0x03
    66e4:	9f 01       	movw	r18, r30
    66e6:	2b 53       	subi	r18, 0x3B	; 59
    66e8:	3f 4f       	sbci	r19, 0xFF	; 255
    66ea:	cd 01       	movw	r24, r26
    66ec:	8f 53       	subi	r24, 0x3F	; 63
    66ee:	9f 4f       	sbci	r25, 0xFF	; 255
    66f0:	ec 01       	movw	r28, r24
    66f2:	48 81       	ld	r20, Y
    66f4:	59 81       	ldd	r21, Y+1	; 0x01
    66f6:	6a 81       	ldd	r22, Y+2	; 0x02
    66f8:	7b 81       	ldd	r23, Y+3	; 0x03
    66fa:	e9 01       	movw	r28, r18
    66fc:	48 83       	st	Y, r20
    66fe:	59 83       	std	Y+1, r21	; 0x01
    6700:	6a 83       	std	Y+2, r22	; 0x02
    6702:	7b 83       	std	Y+3, r23	; 0x03
    6704:	9f 01       	movw	r18, r30
    6706:	27 53       	subi	r18, 0x37	; 55
    6708:	3f 4f       	sbci	r19, 0xFF	; 255
    670a:	cd 01       	movw	r24, r26
    670c:	8b 53       	subi	r24, 0x3B	; 59
    670e:	9f 4f       	sbci	r25, 0xFF	; 255
    6710:	ec 01       	movw	r28, r24
    6712:	48 81       	ld	r20, Y
    6714:	59 81       	ldd	r21, Y+1	; 0x01
    6716:	6a 81       	ldd	r22, Y+2	; 0x02
    6718:	7b 81       	ldd	r23, Y+3	; 0x03
    671a:	e9 01       	movw	r28, r18
    671c:	48 83       	st	Y, r20
    671e:	59 83       	std	Y+1, r21	; 0x01
    6720:	6a 83       	std	Y+2, r22	; 0x02
    6722:	7b 83       	std	Y+3, r23	; 0x03
    6724:	9f 01       	movw	r18, r30
    6726:	23 53       	subi	r18, 0x33	; 51
    6728:	3f 4f       	sbci	r19, 0xFF	; 255
    672a:	cd 01       	movw	r24, r26
    672c:	87 53       	subi	r24, 0x37	; 55
    672e:	9f 4f       	sbci	r25, 0xFF	; 255
    6730:	ec 01       	movw	r28, r24
    6732:	48 81       	ld	r20, Y
    6734:	59 81       	ldd	r21, Y+1	; 0x01
    6736:	6a 81       	ldd	r22, Y+2	; 0x02
    6738:	7b 81       	ldd	r23, Y+3	; 0x03
    673a:	e9 01       	movw	r28, r18
    673c:	48 83       	st	Y, r20
    673e:	59 83       	std	Y+1, r21	; 0x01
    6740:	6a 83       	std	Y+2, r22	; 0x02
    6742:	7b 83       	std	Y+3, r23	; 0x03
    6744:	9f 01       	movw	r18, r30
    6746:	2f 52       	subi	r18, 0x2F	; 47
    6748:	3f 4f       	sbci	r19, 0xFF	; 255
    674a:	cd 01       	movw	r24, r26
    674c:	83 53       	subi	r24, 0x33	; 51
    674e:	9f 4f       	sbci	r25, 0xFF	; 255
    6750:	ec 01       	movw	r28, r24
    6752:	48 81       	ld	r20, Y
    6754:	59 81       	ldd	r21, Y+1	; 0x01
    6756:	6a 81       	ldd	r22, Y+2	; 0x02
    6758:	7b 81       	ldd	r23, Y+3	; 0x03
    675a:	e9 01       	movw	r28, r18
    675c:	48 83       	st	Y, r20
    675e:	59 83       	std	Y+1, r21	; 0x01
    6760:	6a 83       	std	Y+2, r22	; 0x02
    6762:	7b 83       	std	Y+3, r23	; 0x03
    6764:	9f 01       	movw	r18, r30
    6766:	2b 52       	subi	r18, 0x2B	; 43
    6768:	3f 4f       	sbci	r19, 0xFF	; 255
    676a:	cd 01       	movw	r24, r26
    676c:	8f 52       	subi	r24, 0x2F	; 47
    676e:	9f 4f       	sbci	r25, 0xFF	; 255
    6770:	ec 01       	movw	r28, r24
    6772:	48 81       	ld	r20, Y
    6774:	59 81       	ldd	r21, Y+1	; 0x01
    6776:	6a 81       	ldd	r22, Y+2	; 0x02
    6778:	7b 81       	ldd	r23, Y+3	; 0x03
    677a:	e9 01       	movw	r28, r18
    677c:	48 83       	st	Y, r20
    677e:	59 83       	std	Y+1, r21	; 0x01
    6780:	6a 83       	std	Y+2, r22	; 0x02
    6782:	7b 83       	std	Y+3, r23	; 0x03
    6784:	9f 01       	movw	r18, r30
    6786:	27 52       	subi	r18, 0x27	; 39
    6788:	3f 4f       	sbci	r19, 0xFF	; 255
    678a:	cd 01       	movw	r24, r26
    678c:	8b 52       	subi	r24, 0x2B	; 43
    678e:	9f 4f       	sbci	r25, 0xFF	; 255
    6790:	ec 01       	movw	r28, r24
    6792:	48 81       	ld	r20, Y
    6794:	59 81       	ldd	r21, Y+1	; 0x01
    6796:	6a 81       	ldd	r22, Y+2	; 0x02
    6798:	7b 81       	ldd	r23, Y+3	; 0x03
    679a:	e9 01       	movw	r28, r18
    679c:	48 83       	st	Y, r20
    679e:	59 83       	std	Y+1, r21	; 0x01
    67a0:	6a 83       	std	Y+2, r22	; 0x02
    67a2:	7b 83       	std	Y+3, r23	; 0x03
    67a4:	9f 01       	movw	r18, r30
    67a6:	23 52       	subi	r18, 0x23	; 35
    67a8:	3f 4f       	sbci	r19, 0xFF	; 255
    67aa:	cd 01       	movw	r24, r26
    67ac:	87 52       	subi	r24, 0x27	; 39
    67ae:	9f 4f       	sbci	r25, 0xFF	; 255
    67b0:	ec 01       	movw	r28, r24
    67b2:	48 81       	ld	r20, Y
    67b4:	59 81       	ldd	r21, Y+1	; 0x01
    67b6:	6a 81       	ldd	r22, Y+2	; 0x02
    67b8:	7b 81       	ldd	r23, Y+3	; 0x03
    67ba:	e9 01       	movw	r28, r18
    67bc:	48 83       	st	Y, r20
    67be:	59 83       	std	Y+1, r21	; 0x01
    67c0:	6a 83       	std	Y+2, r22	; 0x02
    67c2:	7b 83       	std	Y+3, r23	; 0x03
    67c4:	9f 01       	movw	r18, r30
    67c6:	2f 51       	subi	r18, 0x1F	; 31
    67c8:	3f 4f       	sbci	r19, 0xFF	; 255
    67ca:	cd 01       	movw	r24, r26
    67cc:	83 52       	subi	r24, 0x23	; 35
    67ce:	9f 4f       	sbci	r25, 0xFF	; 255
    67d0:	ec 01       	movw	r28, r24
    67d2:	48 81       	ld	r20, Y
    67d4:	59 81       	ldd	r21, Y+1	; 0x01
    67d6:	6a 81       	ldd	r22, Y+2	; 0x02
    67d8:	7b 81       	ldd	r23, Y+3	; 0x03
    67da:	e9 01       	movw	r28, r18
    67dc:	48 83       	st	Y, r20
    67de:	59 83       	std	Y+1, r21	; 0x01
    67e0:	6a 83       	std	Y+2, r22	; 0x02
    67e2:	7b 83       	std	Y+3, r23	; 0x03
    67e4:	9f 01       	movw	r18, r30
    67e6:	2b 51       	subi	r18, 0x1B	; 27
    67e8:	3f 4f       	sbci	r19, 0xFF	; 255
    67ea:	cd 01       	movw	r24, r26
    67ec:	8f 51       	subi	r24, 0x1F	; 31
    67ee:	9f 4f       	sbci	r25, 0xFF	; 255
    67f0:	ec 01       	movw	r28, r24
    67f2:	48 81       	ld	r20, Y
    67f4:	59 81       	ldd	r21, Y+1	; 0x01
    67f6:	6a 81       	ldd	r22, Y+2	; 0x02
    67f8:	7b 81       	ldd	r23, Y+3	; 0x03
    67fa:	e9 01       	movw	r28, r18
    67fc:	48 83       	st	Y, r20
    67fe:	59 83       	std	Y+1, r21	; 0x01
    6800:	6a 83       	std	Y+2, r22	; 0x02
    6802:	7b 83       	std	Y+3, r23	; 0x03
    6804:	9f 01       	movw	r18, r30
    6806:	27 51       	subi	r18, 0x17	; 23
    6808:	3f 4f       	sbci	r19, 0xFF	; 255
    680a:	cd 01       	movw	r24, r26
    680c:	8b 51       	subi	r24, 0x1B	; 27
    680e:	9f 4f       	sbci	r25, 0xFF	; 255
    6810:	ec 01       	movw	r28, r24
    6812:	48 81       	ld	r20, Y
    6814:	59 81       	ldd	r21, Y+1	; 0x01
    6816:	6a 81       	ldd	r22, Y+2	; 0x02
    6818:	7b 81       	ldd	r23, Y+3	; 0x03
    681a:	e9 01       	movw	r28, r18
    681c:	48 83       	st	Y, r20
    681e:	59 83       	std	Y+1, r21	; 0x01
    6820:	6a 83       	std	Y+2, r22	; 0x02
    6822:	7b 83       	std	Y+3, r23	; 0x03
    6824:	9f 01       	movw	r18, r30
    6826:	23 51       	subi	r18, 0x13	; 19
    6828:	3f 4f       	sbci	r19, 0xFF	; 255
    682a:	cd 01       	movw	r24, r26
    682c:	87 51       	subi	r24, 0x17	; 23
    682e:	9f 4f       	sbci	r25, 0xFF	; 255
    6830:	ec 01       	movw	r28, r24
    6832:	48 81       	ld	r20, Y
    6834:	59 81       	ldd	r21, Y+1	; 0x01
    6836:	6a 81       	ldd	r22, Y+2	; 0x02
    6838:	7b 81       	ldd	r23, Y+3	; 0x03
    683a:	e9 01       	movw	r28, r18
    683c:	48 83       	st	Y, r20
    683e:	59 83       	std	Y+1, r21	; 0x01
    6840:	6a 83       	std	Y+2, r22	; 0x02
    6842:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6844:	9f 01       	movw	r18, r30
    6846:	2f 50       	subi	r18, 0x0F	; 15
    6848:	3f 4f       	sbci	r19, 0xFF	; 255
    684a:	cd 01       	movw	r24, r26
    684c:	83 51       	subi	r24, 0x13	; 19
    684e:	9f 4f       	sbci	r25, 0xFF	; 255
    6850:	ec 01       	movw	r28, r24
    6852:	48 81       	ld	r20, Y
    6854:	59 81       	ldd	r21, Y+1	; 0x01
    6856:	6a 81       	ldd	r22, Y+2	; 0x02
    6858:	7b 81       	ldd	r23, Y+3	; 0x03
    685a:	e9 01       	movw	r28, r18
    685c:	48 83       	st	Y, r20
    685e:	59 83       	std	Y+1, r21	; 0x01
    6860:	6a 83       	std	Y+2, r22	; 0x02
    6862:	7b 83       	std	Y+3, r23	; 0x03
    6864:	9f 01       	movw	r18, r30
    6866:	2b 50       	subi	r18, 0x0B	; 11
    6868:	3f 4f       	sbci	r19, 0xFF	; 255
    686a:	cd 01       	movw	r24, r26
    686c:	8f 50       	subi	r24, 0x0F	; 15
    686e:	9f 4f       	sbci	r25, 0xFF	; 255
    6870:	ec 01       	movw	r28, r24
    6872:	48 81       	ld	r20, Y
    6874:	59 81       	ldd	r21, Y+1	; 0x01
    6876:	6a 81       	ldd	r22, Y+2	; 0x02
    6878:	7b 81       	ldd	r23, Y+3	; 0x03
    687a:	e9 01       	movw	r28, r18
    687c:	48 83       	st	Y, r20
    687e:	59 83       	std	Y+1, r21	; 0x01
    6880:	6a 83       	std	Y+2, r22	; 0x02
    6882:	7b 83       	std	Y+3, r23	; 0x03
    6884:	9f 01       	movw	r18, r30
    6886:	27 50       	subi	r18, 0x07	; 7
    6888:	3f 4f       	sbci	r19, 0xFF	; 255
    688a:	cd 01       	movw	r24, r26
    688c:	8b 50       	subi	r24, 0x0B	; 11
    688e:	9f 4f       	sbci	r25, 0xFF	; 255
    6890:	ec 01       	movw	r28, r24
    6892:	48 81       	ld	r20, Y
    6894:	59 81       	ldd	r21, Y+1	; 0x01
    6896:	6a 81       	ldd	r22, Y+2	; 0x02
    6898:	7b 81       	ldd	r23, Y+3	; 0x03
    689a:	e9 01       	movw	r28, r18
    689c:	48 83       	st	Y, r20
    689e:	59 83       	std	Y+1, r21	; 0x01
    68a0:	6a 83       	std	Y+2, r22	; 0x02
    68a2:	7b 83       	std	Y+3, r23	; 0x03
    68a4:	9f 01       	movw	r18, r30
    68a6:	23 50       	subi	r18, 0x03	; 3
    68a8:	3f 4f       	sbci	r19, 0xFF	; 255
    68aa:	cd 01       	movw	r24, r26
    68ac:	87 50       	subi	r24, 0x07	; 7
    68ae:	9f 4f       	sbci	r25, 0xFF	; 255
    68b0:	ec 01       	movw	r28, r24
    68b2:	48 81       	ld	r20, Y
    68b4:	59 81       	ldd	r21, Y+1	; 0x01
    68b6:	6a 81       	ldd	r22, Y+2	; 0x02
    68b8:	7b 81       	ldd	r23, Y+3	; 0x03
    68ba:	e9 01       	movw	r28, r18
    68bc:	48 83       	st	Y, r20
    68be:	59 83       	std	Y+1, r21	; 0x01
    68c0:	6a 83       	std	Y+2, r22	; 0x02
    68c2:	7b 83       	std	Y+3, r23	; 0x03
    68c4:	9f 01       	movw	r18, r30
    68c6:	2f 5f       	subi	r18, 0xFF	; 255
    68c8:	3e 4f       	sbci	r19, 0xFE	; 254
    68ca:	cd 01       	movw	r24, r26
    68cc:	83 50       	subi	r24, 0x03	; 3
    68ce:	9f 4f       	sbci	r25, 0xFF	; 255
    68d0:	ec 01       	movw	r28, r24
    68d2:	48 81       	ld	r20, Y
    68d4:	59 81       	ldd	r21, Y+1	; 0x01
    68d6:	6a 81       	ldd	r22, Y+2	; 0x02
    68d8:	7b 81       	ldd	r23, Y+3	; 0x03
    68da:	e9 01       	movw	r28, r18
    68dc:	48 83       	st	Y, r20
    68de:	59 83       	std	Y+1, r21	; 0x01
    68e0:	6a 83       	std	Y+2, r22	; 0x02
    68e2:	7b 83       	std	Y+3, r23	; 0x03
    68e4:	9f 01       	movw	r18, r30
    68e6:	2b 5f       	subi	r18, 0xFB	; 251
    68e8:	3e 4f       	sbci	r19, 0xFE	; 254
    68ea:	cd 01       	movw	r24, r26
    68ec:	8f 5f       	subi	r24, 0xFF	; 255
    68ee:	9e 4f       	sbci	r25, 0xFE	; 254
    68f0:	ec 01       	movw	r28, r24
    68f2:	48 81       	ld	r20, Y
    68f4:	59 81       	ldd	r21, Y+1	; 0x01
    68f6:	6a 81       	ldd	r22, Y+2	; 0x02
    68f8:	7b 81       	ldd	r23, Y+3	; 0x03
    68fa:	e9 01       	movw	r28, r18
    68fc:	48 83       	st	Y, r20
    68fe:	59 83       	std	Y+1, r21	; 0x01
    6900:	6a 83       	std	Y+2, r22	; 0x02
    6902:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6904:	9f 01       	movw	r18, r30
    6906:	27 5f       	subi	r18, 0xF7	; 247
    6908:	3e 4f       	sbci	r19, 0xFE	; 254
    690a:	cd 01       	movw	r24, r26
    690c:	8b 5f       	subi	r24, 0xFB	; 251
    690e:	9e 4f       	sbci	r25, 0xFE	; 254
    6910:	ec 01       	movw	r28, r24
    6912:	48 81       	ld	r20, Y
    6914:	59 81       	ldd	r21, Y+1	; 0x01
    6916:	6a 81       	ldd	r22, Y+2	; 0x02
    6918:	7b 81       	ldd	r23, Y+3	; 0x03
    691a:	e9 01       	movw	r28, r18
    691c:	48 83       	st	Y, r20
    691e:	59 83       	std	Y+1, r21	; 0x01
    6920:	6a 83       	std	Y+2, r22	; 0x02
    6922:	7b 83       	std	Y+3, r23	; 0x03
    6924:	9f 01       	movw	r18, r30
    6926:	23 5f       	subi	r18, 0xF3	; 243
    6928:	3e 4f       	sbci	r19, 0xFE	; 254
    692a:	cd 01       	movw	r24, r26
    692c:	87 5f       	subi	r24, 0xF7	; 247
    692e:	9e 4f       	sbci	r25, 0xFE	; 254
    6930:	ec 01       	movw	r28, r24
    6932:	48 81       	ld	r20, Y
    6934:	59 81       	ldd	r21, Y+1	; 0x01
    6936:	6a 81       	ldd	r22, Y+2	; 0x02
    6938:	7b 81       	ldd	r23, Y+3	; 0x03
    693a:	e9 01       	movw	r28, r18
    693c:	48 83       	st	Y, r20
    693e:	59 83       	std	Y+1, r21	; 0x01
    6940:	6a 83       	std	Y+2, r22	; 0x02
    6942:	7b 83       	std	Y+3, r23	; 0x03
    6944:	9f 01       	movw	r18, r30
    6946:	2f 5e       	subi	r18, 0xEF	; 239
    6948:	3e 4f       	sbci	r19, 0xFE	; 254
    694a:	cd 01       	movw	r24, r26
    694c:	83 5f       	subi	r24, 0xF3	; 243
    694e:	9e 4f       	sbci	r25, 0xFE	; 254
    6950:	ec 01       	movw	r28, r24
    6952:	48 81       	ld	r20, Y
    6954:	59 81       	ldd	r21, Y+1	; 0x01
    6956:	6a 81       	ldd	r22, Y+2	; 0x02
    6958:	7b 81       	ldd	r23, Y+3	; 0x03
    695a:	e9 01       	movw	r28, r18
    695c:	48 83       	st	Y, r20
    695e:	59 83       	std	Y+1, r21	; 0x01
    6960:	6a 83       	std	Y+2, r22	; 0x02
    6962:	7b 83       	std	Y+3, r23	; 0x03
    6964:	9f 01       	movw	r18, r30
    6966:	2b 5e       	subi	r18, 0xEB	; 235
    6968:	3e 4f       	sbci	r19, 0xFE	; 254
    696a:	cd 01       	movw	r24, r26
    696c:	8f 5e       	subi	r24, 0xEF	; 239
    696e:	9e 4f       	sbci	r25, 0xFE	; 254
    6970:	ec 01       	movw	r28, r24
    6972:	48 81       	ld	r20, Y
    6974:	59 81       	ldd	r21, Y+1	; 0x01
    6976:	6a 81       	ldd	r22, Y+2	; 0x02
    6978:	7b 81       	ldd	r23, Y+3	; 0x03
    697a:	e9 01       	movw	r28, r18
    697c:	48 83       	st	Y, r20
    697e:	59 83       	std	Y+1, r21	; 0x01
    6980:	6a 83       	std	Y+2, r22	; 0x02
    6982:	7b 83       	std	Y+3, r23	; 0x03
    6984:	9f 01       	movw	r18, r30
    6986:	27 5e       	subi	r18, 0xE7	; 231
    6988:	3e 4f       	sbci	r19, 0xFE	; 254
    698a:	cd 01       	movw	r24, r26
    698c:	8b 5e       	subi	r24, 0xEB	; 235
    698e:	9e 4f       	sbci	r25, 0xFE	; 254
    6990:	ec 01       	movw	r28, r24
    6992:	48 81       	ld	r20, Y
    6994:	59 81       	ldd	r21, Y+1	; 0x01
    6996:	6a 81       	ldd	r22, Y+2	; 0x02
    6998:	7b 81       	ldd	r23, Y+3	; 0x03
    699a:	e9 01       	movw	r28, r18
    699c:	48 83       	st	Y, r20
    699e:	59 83       	std	Y+1, r21	; 0x01
    69a0:	6a 83       	std	Y+2, r22	; 0x02
    69a2:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    69a4:	9f 01       	movw	r18, r30
    69a6:	23 5e       	subi	r18, 0xE3	; 227
    69a8:	3e 4f       	sbci	r19, 0xFE	; 254
    69aa:	cd 01       	movw	r24, r26
    69ac:	87 5e       	subi	r24, 0xE7	; 231
    69ae:	9e 4f       	sbci	r25, 0xFE	; 254
    69b0:	ec 01       	movw	r28, r24
    69b2:	48 81       	ld	r20, Y
    69b4:	59 81       	ldd	r21, Y+1	; 0x01
    69b6:	6a 81       	ldd	r22, Y+2	; 0x02
    69b8:	7b 81       	ldd	r23, Y+3	; 0x03
    69ba:	e9 01       	movw	r28, r18
    69bc:	48 83       	st	Y, r20
    69be:	59 83       	std	Y+1, r21	; 0x01
    69c0:	6a 83       	std	Y+2, r22	; 0x02
    69c2:	7b 83       	std	Y+3, r23	; 0x03
    69c4:	9f 01       	movw	r18, r30
    69c6:	2f 5d       	subi	r18, 0xDF	; 223
    69c8:	3e 4f       	sbci	r19, 0xFE	; 254
    69ca:	cd 01       	movw	r24, r26
    69cc:	83 5e       	subi	r24, 0xE3	; 227
    69ce:	9e 4f       	sbci	r25, 0xFE	; 254
    69d0:	ec 01       	movw	r28, r24
    69d2:	48 81       	ld	r20, Y
    69d4:	59 81       	ldd	r21, Y+1	; 0x01
    69d6:	6a 81       	ldd	r22, Y+2	; 0x02
    69d8:	7b 81       	ldd	r23, Y+3	; 0x03
    69da:	e9 01       	movw	r28, r18
    69dc:	48 83       	st	Y, r20
    69de:	59 83       	std	Y+1, r21	; 0x01
    69e0:	6a 83       	std	Y+2, r22	; 0x02
    69e2:	7b 83       	std	Y+3, r23	; 0x03
    69e4:	9f 01       	movw	r18, r30
    69e6:	2b 5d       	subi	r18, 0xDB	; 219
    69e8:	3e 4f       	sbci	r19, 0xFE	; 254
    69ea:	cd 01       	movw	r24, r26
    69ec:	8f 5d       	subi	r24, 0xDF	; 223
    69ee:	9e 4f       	sbci	r25, 0xFE	; 254
    69f0:	ec 01       	movw	r28, r24
    69f2:	48 81       	ld	r20, Y
    69f4:	59 81       	ldd	r21, Y+1	; 0x01
    69f6:	6a 81       	ldd	r22, Y+2	; 0x02
    69f8:	7b 81       	ldd	r23, Y+3	; 0x03
    69fa:	e9 01       	movw	r28, r18
    69fc:	48 83       	st	Y, r20
    69fe:	59 83       	std	Y+1, r21	; 0x01
    6a00:	6a 83       	std	Y+2, r22	; 0x02
    6a02:	7b 83       	std	Y+3, r23	; 0x03
    6a04:	9f 01       	movw	r18, r30
    6a06:	27 5d       	subi	r18, 0xD7	; 215
    6a08:	3e 4f       	sbci	r19, 0xFE	; 254
    6a0a:	cd 01       	movw	r24, r26
    6a0c:	8b 5d       	subi	r24, 0xDB	; 219
    6a0e:	9e 4f       	sbci	r25, 0xFE	; 254
    6a10:	ec 01       	movw	r28, r24
    6a12:	48 81       	ld	r20, Y
    6a14:	59 81       	ldd	r21, Y+1	; 0x01
    6a16:	6a 81       	ldd	r22, Y+2	; 0x02
    6a18:	7b 81       	ldd	r23, Y+3	; 0x03
    6a1a:	e9 01       	movw	r28, r18
    6a1c:	48 83       	st	Y, r20
    6a1e:	59 83       	std	Y+1, r21	; 0x01
    6a20:	6a 83       	std	Y+2, r22	; 0x02
    6a22:	7b 83       	std	Y+3, r23	; 0x03
    6a24:	e3 5d       	subi	r30, 0xD3	; 211
    6a26:	fe 4f       	sbci	r31, 0xFE	; 254
    6a28:	a7 5d       	subi	r26, 0xD7	; 215
    6a2a:	be 4f       	sbci	r27, 0xFE	; 254
    6a2c:	4d 91       	ld	r20, X+
    6a2e:	5d 91       	ld	r21, X+
    6a30:	6d 91       	ld	r22, X+
    6a32:	7c 91       	ld	r23, X
    6a34:	40 83       	st	Z, r20
    6a36:	51 83       	std	Z+1, r21	; 0x01
    6a38:	62 83       	std	Z+2, r22	; 0x02
    6a3a:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    6a3c:	df 91       	pop	r29
    6a3e:	cf 91       	pop	r28
    6a40:	08 95       	ret

00006a42 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>:

SystemTelemetryMessage* SystemTelemetryMessage::buildMessageSt(byte *message)
{
    6a42:	0f 93       	push	r16
    6a44:	1f 93       	push	r17
    6a46:	cf 93       	push	r28
    6a48:	df 93       	push	r29
    6a4a:	8c 01       	movw	r16, r24
	SystemTelemetryMessage *msg = new SystemTelemetryMessage();
    6a4c:	81 e3       	ldi	r24, 0x31	; 49
    6a4e:	91 e0       	ldi	r25, 0x01	; 1
    6a50:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    6a54:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    6a56:	82 e0       	ldi	r24, 0x02	; 2
    6a58:	8a 83       	std	Y+2, r24	; 0x02
    6a5a:	8d e2       	ldi	r24, 0x2D	; 45
    6a5c:	91 e0       	ldi	r25, 0x01	; 1
    6a5e:	9c 83       	std	Y+4, r25	; 0x04
    6a60:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    6a62:	80 e8       	ldi	r24, 0x80	; 128
    6a64:	92 e0       	ldi	r25, 0x02	; 2
    6a66:	99 83       	std	Y+1, r25	; 0x01
    6a68:	88 83       	st	Y, r24
    6a6a:	1d 82       	std	Y+5, r1	; 0x05
    6a6c:	1e 82       	std	Y+6, r1	; 0x06
    6a6e:	1f 82       	std	Y+7, r1	; 0x07
    6a70:	18 86       	std	Y+8, r1	; 0x08
    6a72:	19 86       	std	Y+9, r1	; 0x09
    6a74:	1a 86       	std	Y+10, r1	; 0x0a
    6a76:	1b 86       	std	Y+11, r1	; 0x0b
    6a78:	1c 86       	std	Y+12, r1	; 0x0c
    6a7a:	1d 86       	std	Y+13, r1	; 0x0d
    6a7c:	1e 86       	std	Y+14, r1	; 0x0e
    6a7e:	1f 86       	std	Y+15, r1	; 0x0f
    6a80:	18 8a       	std	Y+16, r1	; 0x10
    6a82:	19 8a       	std	Y+17, r1	; 0x11
    6a84:	1a 8a       	std	Y+18, r1	; 0x12
    6a86:	1b 8a       	std	Y+19, r1	; 0x13
    6a88:	1c 8a       	std	Y+20, r1	; 0x14
    6a8a:	1d 8a       	std	Y+21, r1	; 0x15
    6a8c:	1e 8a       	std	Y+22, r1	; 0x16
    6a8e:	1f 8a       	std	Y+23, r1	; 0x17
    6a90:	18 8e       	std	Y+24, r1	; 0x18
    6a92:	19 8e       	std	Y+25, r1	; 0x19
    6a94:	1a 8e       	std	Y+26, r1	; 0x1a
    6a96:	1b 8e       	std	Y+27, r1	; 0x1b
    6a98:	1c 8e       	std	Y+28, r1	; 0x1c
    6a9a:	1d 8e       	std	Y+29, r1	; 0x1d
    6a9c:	1e 8e       	std	Y+30, r1	; 0x1e
    6a9e:	1f 8e       	std	Y+31, r1	; 0x1f
    6aa0:	18 a2       	std	Y+32, r1	; 0x20
    6aa2:	19 a2       	std	Y+33, r1	; 0x21
    6aa4:	1a a2       	std	Y+34, r1	; 0x22
    6aa6:	1b a2       	std	Y+35, r1	; 0x23
    6aa8:	1c a2       	std	Y+36, r1	; 0x24
    6aaa:	1d a2       	std	Y+37, r1	; 0x25
    6aac:	1e a2       	std	Y+38, r1	; 0x26
    6aae:	1f a2       	std	Y+39, r1	; 0x27
    6ab0:	18 a6       	std	Y+40, r1	; 0x28
    6ab2:	19 a6       	std	Y+41, r1	; 0x29
    6ab4:	1a a6       	std	Y+42, r1	; 0x2a
    6ab6:	1b a6       	std	Y+43, r1	; 0x2b
    6ab8:	1c a6       	std	Y+44, r1	; 0x2c
    6aba:	1d a6       	std	Y+45, r1	; 0x2d
    6abc:	1e a6       	std	Y+46, r1	; 0x2e
    6abe:	1f a6       	std	Y+47, r1	; 0x2f
    6ac0:	18 aa       	std	Y+48, r1	; 0x30
    6ac2:	19 aa       	std	Y+49, r1	; 0x31
    6ac4:	1a aa       	std	Y+50, r1	; 0x32
    6ac6:	1b aa       	std	Y+51, r1	; 0x33
    6ac8:	1c aa       	std	Y+52, r1	; 0x34
    6aca:	1d aa       	std	Y+53, r1	; 0x35
    6acc:	1e aa       	std	Y+54, r1	; 0x36
    6ace:	1f aa       	std	Y+55, r1	; 0x37
    6ad0:	18 ae       	std	Y+56, r1	; 0x38
    6ad2:	19 ae       	std	Y+57, r1	; 0x39
    6ad4:	1a ae       	std	Y+58, r1	; 0x3a
    6ad6:	1b ae       	std	Y+59, r1	; 0x3b
    6ad8:	1c ae       	std	Y+60, r1	; 0x3c
    6ada:	fe 01       	movw	r30, r28
    6adc:	fd 96       	adiw	r30, 0x3d	; 61
    6ade:	10 82       	st	Z, r1
    6ae0:	11 82       	std	Z+1, r1	; 0x01
    6ae2:	12 82       	std	Z+2, r1	; 0x02
    6ae4:	13 82       	std	Z+3, r1	; 0x03
    6ae6:	fe 01       	movw	r30, r28
    6ae8:	ef 5b       	subi	r30, 0xBF	; 191
    6aea:	ff 4f       	sbci	r31, 0xFF	; 255
    6aec:	10 82       	st	Z, r1
    6aee:	11 82       	std	Z+1, r1	; 0x01
    6af0:	12 82       	std	Z+2, r1	; 0x02
    6af2:	13 82       	std	Z+3, r1	; 0x03
    6af4:	fe 01       	movw	r30, r28
    6af6:	eb 5b       	subi	r30, 0xBB	; 187
    6af8:	ff 4f       	sbci	r31, 0xFF	; 255
    6afa:	10 82       	st	Z, r1
    6afc:	11 82       	std	Z+1, r1	; 0x01
    6afe:	12 82       	std	Z+2, r1	; 0x02
    6b00:	13 82       	std	Z+3, r1	; 0x03
    6b02:	fe 01       	movw	r30, r28
    6b04:	e7 5b       	subi	r30, 0xB7	; 183
    6b06:	ff 4f       	sbci	r31, 0xFF	; 255
    6b08:	10 82       	st	Z, r1
    6b0a:	11 82       	std	Z+1, r1	; 0x01
    6b0c:	12 82       	std	Z+2, r1	; 0x02
    6b0e:	13 82       	std	Z+3, r1	; 0x03
    6b10:	fe 01       	movw	r30, r28
    6b12:	e3 5b       	subi	r30, 0xB3	; 179
    6b14:	ff 4f       	sbci	r31, 0xFF	; 255
    6b16:	10 82       	st	Z, r1
    6b18:	11 82       	std	Z+1, r1	; 0x01
    6b1a:	12 82       	std	Z+2, r1	; 0x02
    6b1c:	13 82       	std	Z+3, r1	; 0x03
    6b1e:	fe 01       	movw	r30, r28
    6b20:	ef 5a       	subi	r30, 0xAF	; 175
    6b22:	ff 4f       	sbci	r31, 0xFF	; 255
    6b24:	10 82       	st	Z, r1
    6b26:	11 82       	std	Z+1, r1	; 0x01
    6b28:	12 82       	std	Z+2, r1	; 0x02
    6b2a:	13 82       	std	Z+3, r1	; 0x03
    6b2c:	fe 01       	movw	r30, r28
    6b2e:	eb 5a       	subi	r30, 0xAB	; 171
    6b30:	ff 4f       	sbci	r31, 0xFF	; 255
    6b32:	10 82       	st	Z, r1
    6b34:	11 82       	std	Z+1, r1	; 0x01
    6b36:	12 82       	std	Z+2, r1	; 0x02
    6b38:	13 82       	std	Z+3, r1	; 0x03
    6b3a:	fe 01       	movw	r30, r28
    6b3c:	e7 5a       	subi	r30, 0xA7	; 167
    6b3e:	ff 4f       	sbci	r31, 0xFF	; 255
    6b40:	10 82       	st	Z, r1
    6b42:	11 82       	std	Z+1, r1	; 0x01
    6b44:	12 82       	std	Z+2, r1	; 0x02
    6b46:	13 82       	std	Z+3, r1	; 0x03
    6b48:	fe 01       	movw	r30, r28
    6b4a:	e3 5a       	subi	r30, 0xA3	; 163
    6b4c:	ff 4f       	sbci	r31, 0xFF	; 255
    6b4e:	10 82       	st	Z, r1
    6b50:	11 82       	std	Z+1, r1	; 0x01
    6b52:	12 82       	std	Z+2, r1	; 0x02
    6b54:	13 82       	std	Z+3, r1	; 0x03
    6b56:	fe 01       	movw	r30, r28
    6b58:	ef 59       	subi	r30, 0x9F	; 159
    6b5a:	ff 4f       	sbci	r31, 0xFF	; 255
    6b5c:	10 82       	st	Z, r1
    6b5e:	11 82       	std	Z+1, r1	; 0x01
    6b60:	12 82       	std	Z+2, r1	; 0x02
    6b62:	13 82       	std	Z+3, r1	; 0x03
    6b64:	fe 01       	movw	r30, r28
    6b66:	eb 59       	subi	r30, 0x9B	; 155
    6b68:	ff 4f       	sbci	r31, 0xFF	; 255
    6b6a:	10 82       	st	Z, r1
    6b6c:	11 82       	std	Z+1, r1	; 0x01
    6b6e:	12 82       	std	Z+2, r1	; 0x02
    6b70:	13 82       	std	Z+3, r1	; 0x03
    6b72:	fe 01       	movw	r30, r28
    6b74:	e7 59       	subi	r30, 0x97	; 151
    6b76:	ff 4f       	sbci	r31, 0xFF	; 255
    6b78:	10 82       	st	Z, r1
    6b7a:	11 82       	std	Z+1, r1	; 0x01
    6b7c:	12 82       	std	Z+2, r1	; 0x02
    6b7e:	13 82       	std	Z+3, r1	; 0x03
    6b80:	fe 01       	movw	r30, r28
    6b82:	e3 59       	subi	r30, 0x93	; 147
    6b84:	ff 4f       	sbci	r31, 0xFF	; 255
    6b86:	10 82       	st	Z, r1
    6b88:	11 82       	std	Z+1, r1	; 0x01
    6b8a:	12 82       	std	Z+2, r1	; 0x02
    6b8c:	13 82       	std	Z+3, r1	; 0x03
    6b8e:	fe 01       	movw	r30, r28
    6b90:	ef 58       	subi	r30, 0x8F	; 143
    6b92:	ff 4f       	sbci	r31, 0xFF	; 255
    6b94:	10 82       	st	Z, r1
    6b96:	11 82       	std	Z+1, r1	; 0x01
    6b98:	12 82       	std	Z+2, r1	; 0x02
    6b9a:	13 82       	std	Z+3, r1	; 0x03
    6b9c:	fe 01       	movw	r30, r28
    6b9e:	eb 58       	subi	r30, 0x8B	; 139
    6ba0:	ff 4f       	sbci	r31, 0xFF	; 255
    6ba2:	10 82       	st	Z, r1
    6ba4:	11 82       	std	Z+1, r1	; 0x01
    6ba6:	12 82       	std	Z+2, r1	; 0x02
    6ba8:	13 82       	std	Z+3, r1	; 0x03
    6baa:	fe 01       	movw	r30, r28
    6bac:	e7 58       	subi	r30, 0x87	; 135
    6bae:	ff 4f       	sbci	r31, 0xFF	; 255
    6bb0:	10 82       	st	Z, r1
    6bb2:	11 82       	std	Z+1, r1	; 0x01
    6bb4:	12 82       	std	Z+2, r1	; 0x02
    6bb6:	13 82       	std	Z+3, r1	; 0x03
    6bb8:	fe 01       	movw	r30, r28
    6bba:	e3 58       	subi	r30, 0x83	; 131
    6bbc:	ff 4f       	sbci	r31, 0xFF	; 255
    6bbe:	10 82       	st	Z, r1
    6bc0:	11 82       	std	Z+1, r1	; 0x01
    6bc2:	12 82       	std	Z+2, r1	; 0x02
    6bc4:	13 82       	std	Z+3, r1	; 0x03
    6bc6:	fe 01       	movw	r30, r28
    6bc8:	ef 57       	subi	r30, 0x7F	; 127
    6bca:	ff 4f       	sbci	r31, 0xFF	; 255
    6bcc:	10 82       	st	Z, r1
    6bce:	11 82       	std	Z+1, r1	; 0x01
    6bd0:	12 82       	std	Z+2, r1	; 0x02
    6bd2:	13 82       	std	Z+3, r1	; 0x03
    6bd4:	fe 01       	movw	r30, r28
    6bd6:	eb 57       	subi	r30, 0x7B	; 123
    6bd8:	ff 4f       	sbci	r31, 0xFF	; 255
    6bda:	10 82       	st	Z, r1
    6bdc:	11 82       	std	Z+1, r1	; 0x01
    6bde:	12 82       	std	Z+2, r1	; 0x02
    6be0:	13 82       	std	Z+3, r1	; 0x03
    6be2:	fe 01       	movw	r30, r28
    6be4:	e7 57       	subi	r30, 0x77	; 119
    6be6:	ff 4f       	sbci	r31, 0xFF	; 255
    6be8:	10 82       	st	Z, r1
    6bea:	11 82       	std	Z+1, r1	; 0x01
    6bec:	12 82       	std	Z+2, r1	; 0x02
    6bee:	13 82       	std	Z+3, r1	; 0x03
    6bf0:	fe 01       	movw	r30, r28
    6bf2:	e3 57       	subi	r30, 0x73	; 115
    6bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    6bf6:	10 82       	st	Z, r1
    6bf8:	11 82       	std	Z+1, r1	; 0x01
    6bfa:	12 82       	std	Z+2, r1	; 0x02
    6bfc:	13 82       	std	Z+3, r1	; 0x03
    6bfe:	fe 01       	movw	r30, r28
    6c00:	ef 56       	subi	r30, 0x6F	; 111
    6c02:	ff 4f       	sbci	r31, 0xFF	; 255
    6c04:	10 82       	st	Z, r1
    6c06:	11 82       	std	Z+1, r1	; 0x01
    6c08:	12 82       	std	Z+2, r1	; 0x02
    6c0a:	13 82       	std	Z+3, r1	; 0x03
    6c0c:	fe 01       	movw	r30, r28
    6c0e:	eb 56       	subi	r30, 0x6B	; 107
    6c10:	ff 4f       	sbci	r31, 0xFF	; 255
    6c12:	10 82       	st	Z, r1
    6c14:	11 82       	std	Z+1, r1	; 0x01
    6c16:	12 82       	std	Z+2, r1	; 0x02
    6c18:	13 82       	std	Z+3, r1	; 0x03
    6c1a:	fe 01       	movw	r30, r28
    6c1c:	e7 56       	subi	r30, 0x67	; 103
    6c1e:	ff 4f       	sbci	r31, 0xFF	; 255
    6c20:	10 82       	st	Z, r1
    6c22:	11 82       	std	Z+1, r1	; 0x01
    6c24:	12 82       	std	Z+2, r1	; 0x02
    6c26:	13 82       	std	Z+3, r1	; 0x03
    6c28:	fe 01       	movw	r30, r28
    6c2a:	e3 56       	subi	r30, 0x63	; 99
    6c2c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c2e:	10 82       	st	Z, r1
    6c30:	11 82       	std	Z+1, r1	; 0x01
    6c32:	12 82       	std	Z+2, r1	; 0x02
    6c34:	13 82       	std	Z+3, r1	; 0x03
    6c36:	fe 01       	movw	r30, r28
    6c38:	ef 55       	subi	r30, 0x5F	; 95
    6c3a:	ff 4f       	sbci	r31, 0xFF	; 255
    6c3c:	10 82       	st	Z, r1
    6c3e:	11 82       	std	Z+1, r1	; 0x01
    6c40:	12 82       	std	Z+2, r1	; 0x02
    6c42:	13 82       	std	Z+3, r1	; 0x03
    6c44:	fe 01       	movw	r30, r28
    6c46:	eb 55       	subi	r30, 0x5B	; 91
    6c48:	ff 4f       	sbci	r31, 0xFF	; 255
    6c4a:	10 82       	st	Z, r1
    6c4c:	11 82       	std	Z+1, r1	; 0x01
    6c4e:	12 82       	std	Z+2, r1	; 0x02
    6c50:	13 82       	std	Z+3, r1	; 0x03
    6c52:	fe 01       	movw	r30, r28
    6c54:	e7 55       	subi	r30, 0x57	; 87
    6c56:	ff 4f       	sbci	r31, 0xFF	; 255
    6c58:	10 82       	st	Z, r1
    6c5a:	11 82       	std	Z+1, r1	; 0x01
    6c5c:	12 82       	std	Z+2, r1	; 0x02
    6c5e:	13 82       	std	Z+3, r1	; 0x03
    6c60:	fe 01       	movw	r30, r28
    6c62:	e3 55       	subi	r30, 0x53	; 83
    6c64:	ff 4f       	sbci	r31, 0xFF	; 255
    6c66:	10 82       	st	Z, r1
    6c68:	11 82       	std	Z+1, r1	; 0x01
    6c6a:	12 82       	std	Z+2, r1	; 0x02
    6c6c:	13 82       	std	Z+3, r1	; 0x03
    6c6e:	fe 01       	movw	r30, r28
    6c70:	ef 54       	subi	r30, 0x4F	; 79
    6c72:	ff 4f       	sbci	r31, 0xFF	; 255
    6c74:	10 82       	st	Z, r1
    6c76:	11 82       	std	Z+1, r1	; 0x01
    6c78:	12 82       	std	Z+2, r1	; 0x02
    6c7a:	13 82       	std	Z+3, r1	; 0x03
    6c7c:	fe 01       	movw	r30, r28
    6c7e:	eb 54       	subi	r30, 0x4B	; 75
    6c80:	ff 4f       	sbci	r31, 0xFF	; 255
    6c82:	10 82       	st	Z, r1
    6c84:	11 82       	std	Z+1, r1	; 0x01
    6c86:	12 82       	std	Z+2, r1	; 0x02
    6c88:	13 82       	std	Z+3, r1	; 0x03
    6c8a:	fe 01       	movw	r30, r28
    6c8c:	e7 54       	subi	r30, 0x47	; 71
    6c8e:	ff 4f       	sbci	r31, 0xFF	; 255
    6c90:	10 82       	st	Z, r1
    6c92:	11 82       	std	Z+1, r1	; 0x01
    6c94:	12 82       	std	Z+2, r1	; 0x02
    6c96:	13 82       	std	Z+3, r1	; 0x03
    6c98:	fe 01       	movw	r30, r28
    6c9a:	e3 54       	subi	r30, 0x43	; 67
    6c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c9e:	10 82       	st	Z, r1
    6ca0:	11 82       	std	Z+1, r1	; 0x01
    6ca2:	12 82       	std	Z+2, r1	; 0x02
    6ca4:	13 82       	std	Z+3, r1	; 0x03
    6ca6:	fe 01       	movw	r30, r28
    6ca8:	ef 53       	subi	r30, 0x3F	; 63
    6caa:	ff 4f       	sbci	r31, 0xFF	; 255
    6cac:	10 82       	st	Z, r1
    6cae:	11 82       	std	Z+1, r1	; 0x01
    6cb0:	12 82       	std	Z+2, r1	; 0x02
    6cb2:	13 82       	std	Z+3, r1	; 0x03
    6cb4:	fe 01       	movw	r30, r28
    6cb6:	eb 53       	subi	r30, 0x3B	; 59
    6cb8:	ff 4f       	sbci	r31, 0xFF	; 255
    6cba:	10 82       	st	Z, r1
    6cbc:	11 82       	std	Z+1, r1	; 0x01
    6cbe:	12 82       	std	Z+2, r1	; 0x02
    6cc0:	13 82       	std	Z+3, r1	; 0x03
    6cc2:	fe 01       	movw	r30, r28
    6cc4:	e7 53       	subi	r30, 0x37	; 55
    6cc6:	ff 4f       	sbci	r31, 0xFF	; 255
    6cc8:	10 82       	st	Z, r1
    6cca:	11 82       	std	Z+1, r1	; 0x01
    6ccc:	12 82       	std	Z+2, r1	; 0x02
    6cce:	13 82       	std	Z+3, r1	; 0x03
    6cd0:	fe 01       	movw	r30, r28
    6cd2:	e3 53       	subi	r30, 0x33	; 51
    6cd4:	ff 4f       	sbci	r31, 0xFF	; 255
    6cd6:	10 82       	st	Z, r1
    6cd8:	11 82       	std	Z+1, r1	; 0x01
    6cda:	12 82       	std	Z+2, r1	; 0x02
    6cdc:	13 82       	std	Z+3, r1	; 0x03
    6cde:	fe 01       	movw	r30, r28
    6ce0:	ef 52       	subi	r30, 0x2F	; 47
    6ce2:	ff 4f       	sbci	r31, 0xFF	; 255
    6ce4:	10 82       	st	Z, r1
    6ce6:	11 82       	std	Z+1, r1	; 0x01
    6ce8:	12 82       	std	Z+2, r1	; 0x02
    6cea:	13 82       	std	Z+3, r1	; 0x03
    6cec:	fe 01       	movw	r30, r28
    6cee:	eb 52       	subi	r30, 0x2B	; 43
    6cf0:	ff 4f       	sbci	r31, 0xFF	; 255
    6cf2:	10 82       	st	Z, r1
    6cf4:	11 82       	std	Z+1, r1	; 0x01
    6cf6:	12 82       	std	Z+2, r1	; 0x02
    6cf8:	13 82       	std	Z+3, r1	; 0x03
    6cfa:	fe 01       	movw	r30, r28
    6cfc:	e7 52       	subi	r30, 0x27	; 39
    6cfe:	ff 4f       	sbci	r31, 0xFF	; 255
    6d00:	10 82       	st	Z, r1
    6d02:	11 82       	std	Z+1, r1	; 0x01
    6d04:	12 82       	std	Z+2, r1	; 0x02
    6d06:	13 82       	std	Z+3, r1	; 0x03
    6d08:	fe 01       	movw	r30, r28
    6d0a:	e3 52       	subi	r30, 0x23	; 35
    6d0c:	ff 4f       	sbci	r31, 0xFF	; 255
    6d0e:	10 82       	st	Z, r1
    6d10:	11 82       	std	Z+1, r1	; 0x01
    6d12:	12 82       	std	Z+2, r1	; 0x02
    6d14:	13 82       	std	Z+3, r1	; 0x03
    6d16:	fe 01       	movw	r30, r28
    6d18:	ef 51       	subi	r30, 0x1F	; 31
    6d1a:	ff 4f       	sbci	r31, 0xFF	; 255
    6d1c:	10 82       	st	Z, r1
    6d1e:	11 82       	std	Z+1, r1	; 0x01
    6d20:	12 82       	std	Z+2, r1	; 0x02
    6d22:	13 82       	std	Z+3, r1	; 0x03
    6d24:	fe 01       	movw	r30, r28
    6d26:	eb 51       	subi	r30, 0x1B	; 27
    6d28:	ff 4f       	sbci	r31, 0xFF	; 255
    6d2a:	10 82       	st	Z, r1
    6d2c:	11 82       	std	Z+1, r1	; 0x01
    6d2e:	12 82       	std	Z+2, r1	; 0x02
    6d30:	13 82       	std	Z+3, r1	; 0x03
    6d32:	fe 01       	movw	r30, r28
    6d34:	e7 51       	subi	r30, 0x17	; 23
    6d36:	ff 4f       	sbci	r31, 0xFF	; 255
    6d38:	10 82       	st	Z, r1
    6d3a:	11 82       	std	Z+1, r1	; 0x01
    6d3c:	12 82       	std	Z+2, r1	; 0x02
    6d3e:	13 82       	std	Z+3, r1	; 0x03
    6d40:	fe 01       	movw	r30, r28
    6d42:	e3 51       	subi	r30, 0x13	; 19
    6d44:	ff 4f       	sbci	r31, 0xFF	; 255
    6d46:	10 82       	st	Z, r1
    6d48:	11 82       	std	Z+1, r1	; 0x01
    6d4a:	12 82       	std	Z+2, r1	; 0x02
    6d4c:	13 82       	std	Z+3, r1	; 0x03
    6d4e:	fe 01       	movw	r30, r28
    6d50:	ef 50       	subi	r30, 0x0F	; 15
    6d52:	ff 4f       	sbci	r31, 0xFF	; 255
    6d54:	10 82       	st	Z, r1
    6d56:	11 82       	std	Z+1, r1	; 0x01
    6d58:	12 82       	std	Z+2, r1	; 0x02
    6d5a:	13 82       	std	Z+3, r1	; 0x03
    6d5c:	fe 01       	movw	r30, r28
    6d5e:	eb 50       	subi	r30, 0x0B	; 11
    6d60:	ff 4f       	sbci	r31, 0xFF	; 255
    6d62:	10 82       	st	Z, r1
    6d64:	11 82       	std	Z+1, r1	; 0x01
    6d66:	12 82       	std	Z+2, r1	; 0x02
    6d68:	13 82       	std	Z+3, r1	; 0x03
    6d6a:	fe 01       	movw	r30, r28
    6d6c:	e7 50       	subi	r30, 0x07	; 7
    6d6e:	ff 4f       	sbci	r31, 0xFF	; 255
    6d70:	10 82       	st	Z, r1
    6d72:	11 82       	std	Z+1, r1	; 0x01
    6d74:	12 82       	std	Z+2, r1	; 0x02
    6d76:	13 82       	std	Z+3, r1	; 0x03
    6d78:	fe 01       	movw	r30, r28
    6d7a:	e3 50       	subi	r30, 0x03	; 3
    6d7c:	ff 4f       	sbci	r31, 0xFF	; 255
    6d7e:	10 82       	st	Z, r1
    6d80:	11 82       	std	Z+1, r1	; 0x01
    6d82:	12 82       	std	Z+2, r1	; 0x02
    6d84:	13 82       	std	Z+3, r1	; 0x03
    6d86:	fe 01       	movw	r30, r28
    6d88:	ef 5f       	subi	r30, 0xFF	; 255
    6d8a:	fe 4f       	sbci	r31, 0xFE	; 254
    6d8c:	10 82       	st	Z, r1
    6d8e:	11 82       	std	Z+1, r1	; 0x01
    6d90:	12 82       	std	Z+2, r1	; 0x02
    6d92:	13 82       	std	Z+3, r1	; 0x03
    6d94:	fe 01       	movw	r30, r28
    6d96:	eb 5f       	subi	r30, 0xFB	; 251
    6d98:	fe 4f       	sbci	r31, 0xFE	; 254
    6d9a:	10 82       	st	Z, r1
    6d9c:	11 82       	std	Z+1, r1	; 0x01
    6d9e:	12 82       	std	Z+2, r1	; 0x02
    6da0:	13 82       	std	Z+3, r1	; 0x03
    6da2:	fe 01       	movw	r30, r28
    6da4:	e7 5f       	subi	r30, 0xF7	; 247
    6da6:	fe 4f       	sbci	r31, 0xFE	; 254
    6da8:	10 82       	st	Z, r1
    6daa:	11 82       	std	Z+1, r1	; 0x01
    6dac:	12 82       	std	Z+2, r1	; 0x02
    6dae:	13 82       	std	Z+3, r1	; 0x03
    6db0:	fe 01       	movw	r30, r28
    6db2:	e3 5f       	subi	r30, 0xF3	; 243
    6db4:	fe 4f       	sbci	r31, 0xFE	; 254
    6db6:	10 82       	st	Z, r1
    6db8:	11 82       	std	Z+1, r1	; 0x01
    6dba:	12 82       	std	Z+2, r1	; 0x02
    6dbc:	13 82       	std	Z+3, r1	; 0x03
    6dbe:	fe 01       	movw	r30, r28
    6dc0:	ef 5e       	subi	r30, 0xEF	; 239
    6dc2:	fe 4f       	sbci	r31, 0xFE	; 254
    6dc4:	10 82       	st	Z, r1
    6dc6:	11 82       	std	Z+1, r1	; 0x01
    6dc8:	12 82       	std	Z+2, r1	; 0x02
    6dca:	13 82       	std	Z+3, r1	; 0x03
    6dcc:	fe 01       	movw	r30, r28
    6dce:	eb 5e       	subi	r30, 0xEB	; 235
    6dd0:	fe 4f       	sbci	r31, 0xFE	; 254
    6dd2:	10 82       	st	Z, r1
    6dd4:	11 82       	std	Z+1, r1	; 0x01
    6dd6:	12 82       	std	Z+2, r1	; 0x02
    6dd8:	13 82       	std	Z+3, r1	; 0x03
    6dda:	fe 01       	movw	r30, r28
    6ddc:	e7 5e       	subi	r30, 0xE7	; 231
    6dde:	fe 4f       	sbci	r31, 0xFE	; 254
    6de0:	10 82       	st	Z, r1
    6de2:	11 82       	std	Z+1, r1	; 0x01
    6de4:	12 82       	std	Z+2, r1	; 0x02
    6de6:	13 82       	std	Z+3, r1	; 0x03
    6de8:	fe 01       	movw	r30, r28
    6dea:	e3 5e       	subi	r30, 0xE3	; 227
    6dec:	fe 4f       	sbci	r31, 0xFE	; 254
    6dee:	10 82       	st	Z, r1
    6df0:	11 82       	std	Z+1, r1	; 0x01
    6df2:	12 82       	std	Z+2, r1	; 0x02
    6df4:	13 82       	std	Z+3, r1	; 0x03
    6df6:	fe 01       	movw	r30, r28
    6df8:	ef 5d       	subi	r30, 0xDF	; 223
    6dfa:	fe 4f       	sbci	r31, 0xFE	; 254
    6dfc:	10 82       	st	Z, r1
    6dfe:	11 82       	std	Z+1, r1	; 0x01
    6e00:	12 82       	std	Z+2, r1	; 0x02
    6e02:	13 82       	std	Z+3, r1	; 0x03
    6e04:	fe 01       	movw	r30, r28
    6e06:	eb 5d       	subi	r30, 0xDB	; 219
    6e08:	fe 4f       	sbci	r31, 0xFE	; 254
    6e0a:	10 82       	st	Z, r1
    6e0c:	11 82       	std	Z+1, r1	; 0x01
    6e0e:	12 82       	std	Z+2, r1	; 0x02
    6e10:	13 82       	std	Z+3, r1	; 0x03
    6e12:	fe 01       	movw	r30, r28
    6e14:	e7 5d       	subi	r30, 0xD7	; 215
    6e16:	fe 4f       	sbci	r31, 0xFE	; 254
    6e18:	10 82       	st	Z, r1
    6e1a:	11 82       	std	Z+1, r1	; 0x01
    6e1c:	12 82       	std	Z+2, r1	; 0x02
    6e1e:	13 82       	std	Z+3, r1	; 0x03
    6e20:	fe 01       	movw	r30, r28
    6e22:	e3 5d       	subi	r30, 0xD3	; 211
    6e24:	fe 4f       	sbci	r31, 0xFE	; 254
    6e26:	10 82       	st	Z, r1
    6e28:	11 82       	std	Z+1, r1	; 0x01
    6e2a:	12 82       	std	Z+2, r1	; 0x02
    6e2c:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    6e2e:	b8 01       	movw	r22, r16
    6e30:	ce 01       	movw	r24, r28
    6e32:	0e 94 c2 30 	call	0x6184	; 0x6184 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    6e36:	8c 2f       	mov	r24, r28
    6e38:	9d 2f       	mov	r25, r29
    6e3a:	df 91       	pop	r29
    6e3c:	cf 91       	pop	r28
    6e3e:	1f 91       	pop	r17
    6e40:	0f 91       	pop	r16
    6e42:	08 95       	ret

00006e44 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>:

SystemTelemetryMessage * SystemTelemetryMessage::buildMessageFromModel(SystemModel *model)
{
    6e44:	2f 92       	push	r2
    6e46:	3f 92       	push	r3
    6e48:	4f 92       	push	r4
    6e4a:	5f 92       	push	r5
    6e4c:	6f 92       	push	r6
    6e4e:	7f 92       	push	r7
    6e50:	8f 92       	push	r8
    6e52:	9f 92       	push	r9
    6e54:	af 92       	push	r10
    6e56:	bf 92       	push	r11
    6e58:	cf 92       	push	r12
    6e5a:	df 92       	push	r13
    6e5c:	ef 92       	push	r14
    6e5e:	ff 92       	push	r15
    6e60:	0f 93       	push	r16
    6e62:	1f 93       	push	r17
    6e64:	cf 93       	push	r28
    6e66:	df 93       	push	r29
    6e68:	cd b7       	in	r28, 0x3d	; 61
    6e6a:	de b7       	in	r29, 0x3e	; 62
    6e6c:	c8 54       	subi	r28, 0x48	; 72
    6e6e:	d1 09       	sbc	r29, r1
    6e70:	0f b6       	in	r0, 0x3f	; 63
    6e72:	f8 94       	cli
    6e74:	de bf       	out	0x3e, r29	; 62
    6e76:	0f be       	out	0x3f, r0	; 63
    6e78:	cd bf       	out	0x3d, r28	; 61
    6e7a:	25 96       	adiw	r28, 0x05	; 5
    6e7c:	9f af       	std	Y+63, r25	; 0x3f
    6e7e:	8e af       	std	Y+62, r24	; 0x3e
    6e80:	25 97       	sbiw	r28, 0x05	; 5
	SystemTelemetryMessage *message = new SystemTelemetryMessage();
    6e82:	81 e3       	ldi	r24, 0x31	; 49
    6e84:	91 e0       	ldi	r25, 0x01	; 1
    6e86:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    6e8a:	fc 01       	movw	r30, r24
    6e8c:	82 e0       	ldi	r24, 0x02	; 2
    6e8e:	82 83       	std	Z+2, r24	; 0x02
    6e90:	8d e2       	ldi	r24, 0x2D	; 45
    6e92:	91 e0       	ldi	r25, 0x01	; 1
    6e94:	94 83       	std	Z+4, r25	; 0x04
    6e96:	83 83       	std	Z+3, r24	; 0x03
    6e98:	80 e8       	ldi	r24, 0x80	; 128
    6e9a:	92 e0       	ldi	r25, 0x02	; 2
    6e9c:	91 83       	std	Z+1, r25	; 0x01
    6e9e:	80 83       	st	Z, r24
    6ea0:	15 82       	std	Z+5, r1	; 0x05
    6ea2:	16 82       	std	Z+6, r1	; 0x06
    6ea4:	17 82       	std	Z+7, r1	; 0x07
    6ea6:	10 86       	std	Z+8, r1	; 0x08
    6ea8:	11 86       	std	Z+9, r1	; 0x09
    6eaa:	12 86       	std	Z+10, r1	; 0x0a
    6eac:	13 86       	std	Z+11, r1	; 0x0b
    6eae:	14 86       	std	Z+12, r1	; 0x0c
    6eb0:	15 86       	std	Z+13, r1	; 0x0d
    6eb2:	16 86       	std	Z+14, r1	; 0x0e
    6eb4:	17 86       	std	Z+15, r1	; 0x0f
    6eb6:	10 8a       	std	Z+16, r1	; 0x10
    6eb8:	11 8a       	std	Z+17, r1	; 0x11
    6eba:	12 8a       	std	Z+18, r1	; 0x12
    6ebc:	13 8a       	std	Z+19, r1	; 0x13
    6ebe:	14 8a       	std	Z+20, r1	; 0x14
    6ec0:	15 8a       	std	Z+21, r1	; 0x15
    6ec2:	16 8a       	std	Z+22, r1	; 0x16
    6ec4:	17 8a       	std	Z+23, r1	; 0x17
    6ec6:	10 8e       	std	Z+24, r1	; 0x18
    6ec8:	11 8e       	std	Z+25, r1	; 0x19
    6eca:	12 8e       	std	Z+26, r1	; 0x1a
    6ecc:	13 8e       	std	Z+27, r1	; 0x1b
    6ece:	14 8e       	std	Z+28, r1	; 0x1c
    6ed0:	15 8e       	std	Z+29, r1	; 0x1d
    6ed2:	16 8e       	std	Z+30, r1	; 0x1e
    6ed4:	17 8e       	std	Z+31, r1	; 0x1f
    6ed6:	10 a2       	std	Z+32, r1	; 0x20
    6ed8:	11 a2       	std	Z+33, r1	; 0x21
    6eda:	12 a2       	std	Z+34, r1	; 0x22
    6edc:	13 a2       	std	Z+35, r1	; 0x23
    6ede:	14 a2       	std	Z+36, r1	; 0x24
    6ee0:	15 a2       	std	Z+37, r1	; 0x25
    6ee2:	16 a2       	std	Z+38, r1	; 0x26
    6ee4:	17 a2       	std	Z+39, r1	; 0x27
    6ee6:	10 a6       	std	Z+40, r1	; 0x28
    6ee8:	11 a6       	std	Z+41, r1	; 0x29
    6eea:	12 a6       	std	Z+42, r1	; 0x2a
    6eec:	13 a6       	std	Z+43, r1	; 0x2b
    6eee:	14 a6       	std	Z+44, r1	; 0x2c
    6ef0:	15 a6       	std	Z+45, r1	; 0x2d
    6ef2:	16 a6       	std	Z+46, r1	; 0x2e
    6ef4:	17 a6       	std	Z+47, r1	; 0x2f
    6ef6:	10 aa       	std	Z+48, r1	; 0x30
    6ef8:	11 aa       	std	Z+49, r1	; 0x31
    6efa:	12 aa       	std	Z+50, r1	; 0x32
    6efc:	13 aa       	std	Z+51, r1	; 0x33
    6efe:	14 aa       	std	Z+52, r1	; 0x34
    6f00:	15 aa       	std	Z+53, r1	; 0x35
    6f02:	16 aa       	std	Z+54, r1	; 0x36
    6f04:	17 aa       	std	Z+55, r1	; 0x37
    6f06:	10 ae       	std	Z+56, r1	; 0x38
    6f08:	11 ae       	std	Z+57, r1	; 0x39
    6f0a:	12 ae       	std	Z+58, r1	; 0x3a
    6f0c:	13 ae       	std	Z+59, r1	; 0x3b
    6f0e:	14 ae       	std	Z+60, r1	; 0x3c
    6f10:	9f 01       	movw	r18, r30
    6f12:	23 5c       	subi	r18, 0xC3	; 195
    6f14:	3f 4f       	sbci	r19, 0xFF	; 255
    6f16:	3a 83       	std	Y+2, r19	; 0x02
    6f18:	29 83       	std	Y+1, r18	; 0x01
    6f1a:	d9 01       	movw	r26, r18
    6f1c:	1d 92       	st	X+, r1
    6f1e:	1d 92       	st	X+, r1
    6f20:	1d 92       	st	X+, r1
    6f22:	1c 92       	st	X, r1
    6f24:	13 97       	sbiw	r26, 0x03	; 3
    6f26:	df 01       	movw	r26, r30
    6f28:	af 5b       	subi	r26, 0xBF	; 191
    6f2a:	bf 4f       	sbci	r27, 0xFF	; 255
    6f2c:	1d 92       	st	X+, r1
    6f2e:	1d 92       	st	X+, r1
    6f30:	1d 92       	st	X+, r1
    6f32:	1c 92       	st	X, r1
    6f34:	13 97       	sbiw	r26, 0x03	; 3
    6f36:	df 01       	movw	r26, r30
    6f38:	ab 5b       	subi	r26, 0xBB	; 187
    6f3a:	bf 4f       	sbci	r27, 0xFF	; 255
    6f3c:	1d 92       	st	X+, r1
    6f3e:	1d 92       	st	X+, r1
    6f40:	1d 92       	st	X+, r1
    6f42:	1c 92       	st	X, r1
    6f44:	13 97       	sbiw	r26, 0x03	; 3
    6f46:	df 01       	movw	r26, r30
    6f48:	a7 5b       	subi	r26, 0xB7	; 183
    6f4a:	bf 4f       	sbci	r27, 0xFF	; 255
    6f4c:	1d 92       	st	X+, r1
    6f4e:	1d 92       	st	X+, r1
    6f50:	1d 92       	st	X+, r1
    6f52:	1c 92       	st	X, r1
    6f54:	13 97       	sbiw	r26, 0x03	; 3
    6f56:	df 01       	movw	r26, r30
    6f58:	a3 5b       	subi	r26, 0xB3	; 179
    6f5a:	bf 4f       	sbci	r27, 0xFF	; 255
    6f5c:	1d 92       	st	X+, r1
    6f5e:	1d 92       	st	X+, r1
    6f60:	1d 92       	st	X+, r1
    6f62:	1c 92       	st	X, r1
    6f64:	13 97       	sbiw	r26, 0x03	; 3
    6f66:	df 01       	movw	r26, r30
    6f68:	af 5a       	subi	r26, 0xAF	; 175
    6f6a:	bf 4f       	sbci	r27, 0xFF	; 255
    6f6c:	1d 92       	st	X+, r1
    6f6e:	1d 92       	st	X+, r1
    6f70:	1d 92       	st	X+, r1
    6f72:	1c 92       	st	X, r1
    6f74:	13 97       	sbiw	r26, 0x03	; 3
    6f76:	8f 01       	movw	r16, r30
    6f78:	0b 5a       	subi	r16, 0xAB	; 171
    6f7a:	1f 4f       	sbci	r17, 0xFF	; 255
    6f7c:	d8 01       	movw	r26, r16
    6f7e:	1d 92       	st	X+, r1
    6f80:	1d 92       	st	X+, r1
    6f82:	1d 92       	st	X+, r1
    6f84:	1c 92       	st	X, r1
    6f86:	13 97       	sbiw	r26, 0x03	; 3
    6f88:	df 01       	movw	r26, r30
    6f8a:	a7 5a       	subi	r26, 0xA7	; 167
    6f8c:	bf 4f       	sbci	r27, 0xFF	; 255
    6f8e:	1d 92       	st	X+, r1
    6f90:	1d 92       	st	X+, r1
    6f92:	1d 92       	st	X+, r1
    6f94:	1c 92       	st	X, r1
    6f96:	13 97       	sbiw	r26, 0x03	; 3
    6f98:	af 01       	movw	r20, r30
    6f9a:	43 5a       	subi	r20, 0xA3	; 163
    6f9c:	5f 4f       	sbci	r21, 0xFF	; 255
    6f9e:	da 01       	movw	r26, r20
    6fa0:	1d 92       	st	X+, r1
    6fa2:	1d 92       	st	X+, r1
    6fa4:	1d 92       	st	X+, r1
    6fa6:	1c 92       	st	X, r1
    6fa8:	13 97       	sbiw	r26, 0x03	; 3
    6faa:	3f 01       	movw	r6, r30
    6fac:	b1 e6       	ldi	r27, 0x61	; 97
    6fae:	6b 0e       	add	r6, r27
    6fb0:	71 1c       	adc	r7, r1
    6fb2:	d3 01       	movw	r26, r6
    6fb4:	1d 92       	st	X+, r1
    6fb6:	1d 92       	st	X+, r1
    6fb8:	1d 92       	st	X+, r1
    6fba:	1c 92       	st	X, r1
    6fbc:	13 97       	sbiw	r26, 0x03	; 3
    6fbe:	bf 01       	movw	r22, r30
    6fc0:	6b 59       	subi	r22, 0x9B	; 155
    6fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    6fc4:	db 01       	movw	r26, r22
    6fc6:	1d 92       	st	X+, r1
    6fc8:	1d 92       	st	X+, r1
    6fca:	1d 92       	st	X+, r1
    6fcc:	1c 92       	st	X, r1
    6fce:	13 97       	sbiw	r26, 0x03	; 3
    6fd0:	5f 01       	movw	r10, r30
    6fd2:	b9 e6       	ldi	r27, 0x69	; 105
    6fd4:	ab 0e       	add	r10, r27
    6fd6:	b1 1c       	adc	r11, r1
    6fd8:	d5 01       	movw	r26, r10
    6fda:	1d 92       	st	X+, r1
    6fdc:	1d 92       	st	X+, r1
    6fde:	1d 92       	st	X+, r1
    6fe0:	1c 92       	st	X, r1
    6fe2:	13 97       	sbiw	r26, 0x03	; 3
    6fe4:	4f 01       	movw	r8, r30
    6fe6:	bd e6       	ldi	r27, 0x6D	; 109
    6fe8:	8b 0e       	add	r8, r27
    6fea:	91 1c       	adc	r9, r1
    6fec:	d4 01       	movw	r26, r8
    6fee:	1d 92       	st	X+, r1
    6ff0:	1d 92       	st	X+, r1
    6ff2:	1d 92       	st	X+, r1
    6ff4:	1c 92       	st	X, r1
    6ff6:	13 97       	sbiw	r26, 0x03	; 3
    6ff8:	9f 01       	movw	r18, r30
    6ffa:	2f 58       	subi	r18, 0x8F	; 143
    6ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ffe:	27 96       	adiw	r28, 0x07	; 7
    7000:	3f af       	std	Y+63, r19	; 0x3f
    7002:	2e af       	std	Y+62, r18	; 0x3e
    7004:	27 97       	sbiw	r28, 0x07	; 7
    7006:	d9 01       	movw	r26, r18
    7008:	1d 92       	st	X+, r1
    700a:	1d 92       	st	X+, r1
    700c:	1d 92       	st	X+, r1
    700e:	1c 92       	st	X, r1
    7010:	13 97       	sbiw	r26, 0x03	; 3
    7012:	2f 01       	movw	r4, r30
    7014:	b5 e7       	ldi	r27, 0x75	; 117
    7016:	4b 0e       	add	r4, r27
    7018:	51 1c       	adc	r5, r1
    701a:	d2 01       	movw	r26, r4
    701c:	1d 92       	st	X+, r1
    701e:	1d 92       	st	X+, r1
    7020:	1d 92       	st	X+, r1
    7022:	1c 92       	st	X, r1
    7024:	13 97       	sbiw	r26, 0x03	; 3
    7026:	df 01       	movw	r26, r30
    7028:	a7 58       	subi	r26, 0x87	; 135
    702a:	bf 4f       	sbci	r27, 0xFF	; 255
    702c:	1d 92       	st	X+, r1
    702e:	1d 92       	st	X+, r1
    7030:	1d 92       	st	X+, r1
    7032:	1c 92       	st	X, r1
    7034:	13 97       	sbiw	r26, 0x03	; 3
    7036:	df 01       	movw	r26, r30
    7038:	a3 58       	subi	r26, 0x83	; 131
    703a:	bf 4f       	sbci	r27, 0xFF	; 255
    703c:	1d 92       	st	X+, r1
    703e:	1d 92       	st	X+, r1
    7040:	1d 92       	st	X+, r1
    7042:	1c 92       	st	X, r1
    7044:	13 97       	sbiw	r26, 0x03	; 3
    7046:	df 01       	movw	r26, r30
    7048:	af 57       	subi	r26, 0x7F	; 127
    704a:	bf 4f       	sbci	r27, 0xFF	; 255
    704c:	1d 92       	st	X+, r1
    704e:	1d 92       	st	X+, r1
    7050:	1d 92       	st	X+, r1
    7052:	1c 92       	st	X, r1
    7054:	13 97       	sbiw	r26, 0x03	; 3
    7056:	df 01       	movw	r26, r30
    7058:	ab 57       	subi	r26, 0x7B	; 123
    705a:	bf 4f       	sbci	r27, 0xFF	; 255
    705c:	1d 92       	st	X+, r1
    705e:	1d 92       	st	X+, r1
    7060:	1d 92       	st	X+, r1
    7062:	1c 92       	st	X, r1
    7064:	13 97       	sbiw	r26, 0x03	; 3
    7066:	df 01       	movw	r26, r30
    7068:	a7 57       	subi	r26, 0x77	; 119
    706a:	bf 4f       	sbci	r27, 0xFF	; 255
    706c:	1d 92       	st	X+, r1
    706e:	1d 92       	st	X+, r1
    7070:	1d 92       	st	X+, r1
    7072:	1c 92       	st	X, r1
    7074:	13 97       	sbiw	r26, 0x03	; 3
    7076:	1f 01       	movw	r2, r30
    7078:	bd e8       	ldi	r27, 0x8D	; 141
    707a:	2b 0e       	add	r2, r27
    707c:	31 1c       	adc	r3, r1
    707e:	d1 01       	movw	r26, r2
    7080:	1d 92       	st	X+, r1
    7082:	1d 92       	st	X+, r1
    7084:	1d 92       	st	X+, r1
    7086:	1c 92       	st	X, r1
    7088:	13 97       	sbiw	r26, 0x03	; 3
    708a:	df 01       	movw	r26, r30
    708c:	af 56       	subi	r26, 0x6F	; 111
    708e:	bf 4f       	sbci	r27, 0xFF	; 255
    7090:	1d 92       	st	X+, r1
    7092:	1d 92       	st	X+, r1
    7094:	1d 92       	st	X+, r1
    7096:	1c 92       	st	X, r1
    7098:	13 97       	sbiw	r26, 0x03	; 3
    709a:	df 01       	movw	r26, r30
    709c:	ab 56       	subi	r26, 0x6B	; 107
    709e:	bf 4f       	sbci	r27, 0xFF	; 255
    70a0:	1d 92       	st	X+, r1
    70a2:	1d 92       	st	X+, r1
    70a4:	1d 92       	st	X+, r1
    70a6:	1c 92       	st	X, r1
    70a8:	13 97       	sbiw	r26, 0x03	; 3
    70aa:	9f 01       	movw	r18, r30
    70ac:	27 56       	subi	r18, 0x67	; 103
    70ae:	3f 4f       	sbci	r19, 0xFF	; 255
    70b0:	3c 83       	std	Y+4, r19	; 0x04
    70b2:	2b 83       	std	Y+3, r18	; 0x03
    70b4:	d9 01       	movw	r26, r18
    70b6:	1d 92       	st	X+, r1
    70b8:	1d 92       	st	X+, r1
    70ba:	1d 92       	st	X+, r1
    70bc:	1c 92       	st	X, r1
    70be:	13 97       	sbiw	r26, 0x03	; 3
    70c0:	9f 01       	movw	r18, r30
    70c2:	23 56       	subi	r18, 0x63	; 99
    70c4:	3f 4f       	sbci	r19, 0xFF	; 255
    70c6:	3e 83       	std	Y+6, r19	; 0x06
    70c8:	2d 83       	std	Y+5, r18	; 0x05
    70ca:	d9 01       	movw	r26, r18
    70cc:	1d 92       	st	X+, r1
    70ce:	1d 92       	st	X+, r1
    70d0:	1d 92       	st	X+, r1
    70d2:	1c 92       	st	X, r1
    70d4:	13 97       	sbiw	r26, 0x03	; 3
    70d6:	9f 01       	movw	r18, r30
    70d8:	2f 55       	subi	r18, 0x5F	; 95
    70da:	3f 4f       	sbci	r19, 0xFF	; 255
    70dc:	38 87       	std	Y+8, r19	; 0x08
    70de:	2f 83       	std	Y+7, r18	; 0x07
    70e0:	d9 01       	movw	r26, r18
    70e2:	1d 92       	st	X+, r1
    70e4:	1d 92       	st	X+, r1
    70e6:	1d 92       	st	X+, r1
    70e8:	1c 92       	st	X, r1
    70ea:	13 97       	sbiw	r26, 0x03	; 3
    70ec:	9f 01       	movw	r18, r30
    70ee:	2b 55       	subi	r18, 0x5B	; 91
    70f0:	3f 4f       	sbci	r19, 0xFF	; 255
    70f2:	3a 87       	std	Y+10, r19	; 0x0a
    70f4:	29 87       	std	Y+9, r18	; 0x09
    70f6:	d9 01       	movw	r26, r18
    70f8:	1d 92       	st	X+, r1
    70fa:	1d 92       	st	X+, r1
    70fc:	1d 92       	st	X+, r1
    70fe:	1c 92       	st	X, r1
    7100:	13 97       	sbiw	r26, 0x03	; 3
    7102:	9f 01       	movw	r18, r30
    7104:	27 55       	subi	r18, 0x57	; 87
    7106:	3f 4f       	sbci	r19, 0xFF	; 255
    7108:	3c 87       	std	Y+12, r19	; 0x0c
    710a:	2b 87       	std	Y+11, r18	; 0x0b
    710c:	d9 01       	movw	r26, r18
    710e:	1d 92       	st	X+, r1
    7110:	1d 92       	st	X+, r1
    7112:	1d 92       	st	X+, r1
    7114:	1c 92       	st	X, r1
    7116:	13 97       	sbiw	r26, 0x03	; 3
    7118:	9f 01       	movw	r18, r30
    711a:	23 55       	subi	r18, 0x53	; 83
    711c:	3f 4f       	sbci	r19, 0xFF	; 255
    711e:	3e 87       	std	Y+14, r19	; 0x0e
    7120:	2d 87       	std	Y+13, r18	; 0x0d
    7122:	d9 01       	movw	r26, r18
    7124:	1d 92       	st	X+, r1
    7126:	1d 92       	st	X+, r1
    7128:	1d 92       	st	X+, r1
    712a:	1c 92       	st	X, r1
    712c:	13 97       	sbiw	r26, 0x03	; 3
    712e:	df 01       	movw	r26, r30
    7130:	af 54       	subi	r26, 0x4F	; 79
    7132:	bf 4f       	sbci	r27, 0xFF	; 255
    7134:	1d 92       	st	X+, r1
    7136:	1d 92       	st	X+, r1
    7138:	1d 92       	st	X+, r1
    713a:	1c 92       	st	X, r1
    713c:	13 97       	sbiw	r26, 0x03	; 3
    713e:	df 01       	movw	r26, r30
    7140:	ab 54       	subi	r26, 0x4B	; 75
    7142:	bf 4f       	sbci	r27, 0xFF	; 255
    7144:	1d 92       	st	X+, r1
    7146:	1d 92       	st	X+, r1
    7148:	1d 92       	st	X+, r1
    714a:	1c 92       	st	X, r1
    714c:	13 97       	sbiw	r26, 0x03	; 3
    714e:	df 01       	movw	r26, r30
    7150:	a7 54       	subi	r26, 0x47	; 71
    7152:	bf 4f       	sbci	r27, 0xFF	; 255
    7154:	1d 92       	st	X+, r1
    7156:	1d 92       	st	X+, r1
    7158:	1d 92       	st	X+, r1
    715a:	1c 92       	st	X, r1
    715c:	13 97       	sbiw	r26, 0x03	; 3
    715e:	df 01       	movw	r26, r30
    7160:	a3 54       	subi	r26, 0x43	; 67
    7162:	bf 4f       	sbci	r27, 0xFF	; 255
    7164:	1d 92       	st	X+, r1
    7166:	1d 92       	st	X+, r1
    7168:	1d 92       	st	X+, r1
    716a:	1c 92       	st	X, r1
    716c:	13 97       	sbiw	r26, 0x03	; 3
    716e:	9f 01       	movw	r18, r30
    7170:	2f 53       	subi	r18, 0x3F	; 63
    7172:	3f 4f       	sbci	r19, 0xFF	; 255
    7174:	38 8b       	std	Y+16, r19	; 0x10
    7176:	2f 87       	std	Y+15, r18	; 0x0f
    7178:	d9 01       	movw	r26, r18
    717a:	1d 92       	st	X+, r1
    717c:	1d 92       	st	X+, r1
    717e:	1d 92       	st	X+, r1
    7180:	1c 92       	st	X, r1
    7182:	13 97       	sbiw	r26, 0x03	; 3
    7184:	9f 01       	movw	r18, r30
    7186:	2b 53       	subi	r18, 0x3B	; 59
    7188:	3f 4f       	sbci	r19, 0xFF	; 255
    718a:	3a 8b       	std	Y+18, r19	; 0x12
    718c:	29 8b       	std	Y+17, r18	; 0x11
    718e:	d9 01       	movw	r26, r18
    7190:	1d 92       	st	X+, r1
    7192:	1d 92       	st	X+, r1
    7194:	1d 92       	st	X+, r1
    7196:	1c 92       	st	X, r1
    7198:	13 97       	sbiw	r26, 0x03	; 3
    719a:	9f 01       	movw	r18, r30
    719c:	27 53       	subi	r18, 0x37	; 55
    719e:	3f 4f       	sbci	r19, 0xFF	; 255
    71a0:	3c 8b       	std	Y+20, r19	; 0x14
    71a2:	2b 8b       	std	Y+19, r18	; 0x13
    71a4:	d9 01       	movw	r26, r18
    71a6:	1d 92       	st	X+, r1
    71a8:	1d 92       	st	X+, r1
    71aa:	1d 92       	st	X+, r1
    71ac:	1c 92       	st	X, r1
    71ae:	13 97       	sbiw	r26, 0x03	; 3
    71b0:	9f 01       	movw	r18, r30
    71b2:	23 53       	subi	r18, 0x33	; 51
    71b4:	3f 4f       	sbci	r19, 0xFF	; 255
    71b6:	3e 8b       	std	Y+22, r19	; 0x16
    71b8:	2d 8b       	std	Y+21, r18	; 0x15
    71ba:	d9 01       	movw	r26, r18
    71bc:	1d 92       	st	X+, r1
    71be:	1d 92       	st	X+, r1
    71c0:	1d 92       	st	X+, r1
    71c2:	1c 92       	st	X, r1
    71c4:	13 97       	sbiw	r26, 0x03	; 3
    71c6:	9f 01       	movw	r18, r30
    71c8:	2f 52       	subi	r18, 0x2F	; 47
    71ca:	3f 4f       	sbci	r19, 0xFF	; 255
    71cc:	38 8f       	std	Y+24, r19	; 0x18
    71ce:	2f 8b       	std	Y+23, r18	; 0x17
    71d0:	d9 01       	movw	r26, r18
    71d2:	1d 92       	st	X+, r1
    71d4:	1d 92       	st	X+, r1
    71d6:	1d 92       	st	X+, r1
    71d8:	1c 92       	st	X, r1
    71da:	13 97       	sbiw	r26, 0x03	; 3
    71dc:	9f 01       	movw	r18, r30
    71de:	2b 52       	subi	r18, 0x2B	; 43
    71e0:	3f 4f       	sbci	r19, 0xFF	; 255
    71e2:	3a 8f       	std	Y+26, r19	; 0x1a
    71e4:	29 8f       	std	Y+25, r18	; 0x19
    71e6:	d9 01       	movw	r26, r18
    71e8:	1d 92       	st	X+, r1
    71ea:	1d 92       	st	X+, r1
    71ec:	1d 92       	st	X+, r1
    71ee:	1c 92       	st	X, r1
    71f0:	13 97       	sbiw	r26, 0x03	; 3
    71f2:	9f 01       	movw	r18, r30
    71f4:	27 52       	subi	r18, 0x27	; 39
    71f6:	3f 4f       	sbci	r19, 0xFF	; 255
    71f8:	3c 8f       	std	Y+28, r19	; 0x1c
    71fa:	2b 8f       	std	Y+27, r18	; 0x1b
    71fc:	d9 01       	movw	r26, r18
    71fe:	1d 92       	st	X+, r1
    7200:	1d 92       	st	X+, r1
    7202:	1d 92       	st	X+, r1
    7204:	1c 92       	st	X, r1
    7206:	13 97       	sbiw	r26, 0x03	; 3
    7208:	cf 01       	movw	r24, r30
    720a:	83 52       	subi	r24, 0x23	; 35
    720c:	9f 4f       	sbci	r25, 0xFF	; 255
    720e:	dc 01       	movw	r26, r24
    7210:	1d 92       	st	X+, r1
    7212:	1d 92       	st	X+, r1
    7214:	1d 92       	st	X+, r1
    7216:	1c 92       	st	X, r1
    7218:	13 97       	sbiw	r26, 0x03	; 3
    721a:	9f 01       	movw	r18, r30
    721c:	2f 51       	subi	r18, 0x1F	; 31
    721e:	3f 4f       	sbci	r19, 0xFF	; 255
    7220:	29 96       	adiw	r28, 0x09	; 9
    7222:	3f af       	std	Y+63, r19	; 0x3f
    7224:	2e af       	std	Y+62, r18	; 0x3e
    7226:	29 97       	sbiw	r28, 0x09	; 9
    7228:	d9 01       	movw	r26, r18
    722a:	1d 92       	st	X+, r1
    722c:	1d 92       	st	X+, r1
    722e:	1d 92       	st	X+, r1
    7230:	1c 92       	st	X, r1
    7232:	13 97       	sbiw	r26, 0x03	; 3
    7234:	9f 01       	movw	r18, r30
    7236:	2b 51       	subi	r18, 0x1B	; 27
    7238:	3f 4f       	sbci	r19, 0xFF	; 255
    723a:	3e 8f       	std	Y+30, r19	; 0x1e
    723c:	2d 8f       	std	Y+29, r18	; 0x1d
    723e:	d9 01       	movw	r26, r18
    7240:	1d 92       	st	X+, r1
    7242:	1d 92       	st	X+, r1
    7244:	1d 92       	st	X+, r1
    7246:	1c 92       	st	X, r1
    7248:	13 97       	sbiw	r26, 0x03	; 3
    724a:	9f 01       	movw	r18, r30
    724c:	27 51       	subi	r18, 0x17	; 23
    724e:	3f 4f       	sbci	r19, 0xFF	; 255
    7250:	38 a3       	std	Y+32, r19	; 0x20
    7252:	2f 8f       	std	Y+31, r18	; 0x1f
    7254:	d9 01       	movw	r26, r18
    7256:	1d 92       	st	X+, r1
    7258:	1d 92       	st	X+, r1
    725a:	1d 92       	st	X+, r1
    725c:	1c 92       	st	X, r1
    725e:	13 97       	sbiw	r26, 0x03	; 3
    7260:	9f 01       	movw	r18, r30
    7262:	23 51       	subi	r18, 0x13	; 19
    7264:	3f 4f       	sbci	r19, 0xFF	; 255
    7266:	3a a3       	std	Y+34, r19	; 0x22
    7268:	29 a3       	std	Y+33, r18	; 0x21
    726a:	d9 01       	movw	r26, r18
    726c:	1d 92       	st	X+, r1
    726e:	1d 92       	st	X+, r1
    7270:	1d 92       	st	X+, r1
    7272:	1c 92       	st	X, r1
    7274:	13 97       	sbiw	r26, 0x03	; 3
    7276:	9f 01       	movw	r18, r30
    7278:	2f 50       	subi	r18, 0x0F	; 15
    727a:	3f 4f       	sbci	r19, 0xFF	; 255
    727c:	3c a3       	std	Y+36, r19	; 0x24
    727e:	2b a3       	std	Y+35, r18	; 0x23
    7280:	d9 01       	movw	r26, r18
    7282:	1d 92       	st	X+, r1
    7284:	1d 92       	st	X+, r1
    7286:	1d 92       	st	X+, r1
    7288:	1c 92       	st	X, r1
    728a:	13 97       	sbiw	r26, 0x03	; 3
    728c:	9f 01       	movw	r18, r30
    728e:	2b 50       	subi	r18, 0x0B	; 11
    7290:	3f 4f       	sbci	r19, 0xFF	; 255
    7292:	3e a3       	std	Y+38, r19	; 0x26
    7294:	2d a3       	std	Y+37, r18	; 0x25
    7296:	d9 01       	movw	r26, r18
    7298:	1d 92       	st	X+, r1
    729a:	1d 92       	st	X+, r1
    729c:	1d 92       	st	X+, r1
    729e:	1c 92       	st	X, r1
    72a0:	13 97       	sbiw	r26, 0x03	; 3
    72a2:	9f 01       	movw	r18, r30
    72a4:	27 50       	subi	r18, 0x07	; 7
    72a6:	3f 4f       	sbci	r19, 0xFF	; 255
    72a8:	38 a7       	std	Y+40, r19	; 0x28
    72aa:	2f a3       	std	Y+39, r18	; 0x27
    72ac:	d9 01       	movw	r26, r18
    72ae:	1d 92       	st	X+, r1
    72b0:	1d 92       	st	X+, r1
    72b2:	1d 92       	st	X+, r1
    72b4:	1c 92       	st	X, r1
    72b6:	13 97       	sbiw	r26, 0x03	; 3
    72b8:	9f 01       	movw	r18, r30
    72ba:	23 50       	subi	r18, 0x03	; 3
    72bc:	3f 4f       	sbci	r19, 0xFF	; 255
    72be:	3a a7       	std	Y+42, r19	; 0x2a
    72c0:	29 a7       	std	Y+41, r18	; 0x29
    72c2:	d9 01       	movw	r26, r18
    72c4:	1d 92       	st	X+, r1
    72c6:	1d 92       	st	X+, r1
    72c8:	1d 92       	st	X+, r1
    72ca:	1c 92       	st	X, r1
    72cc:	13 97       	sbiw	r26, 0x03	; 3
    72ce:	9f 01       	movw	r18, r30
    72d0:	2f 5f       	subi	r18, 0xFF	; 255
    72d2:	3e 4f       	sbci	r19, 0xFE	; 254
    72d4:	3c a7       	std	Y+44, r19	; 0x2c
    72d6:	2b a7       	std	Y+43, r18	; 0x2b
    72d8:	d9 01       	movw	r26, r18
    72da:	1d 92       	st	X+, r1
    72dc:	1d 92       	st	X+, r1
    72de:	1d 92       	st	X+, r1
    72e0:	1c 92       	st	X, r1
    72e2:	13 97       	sbiw	r26, 0x03	; 3
    72e4:	9f 01       	movw	r18, r30
    72e6:	2b 5f       	subi	r18, 0xFB	; 251
    72e8:	3e 4f       	sbci	r19, 0xFE	; 254
    72ea:	3e a7       	std	Y+46, r19	; 0x2e
    72ec:	2d a7       	std	Y+45, r18	; 0x2d
    72ee:	d9 01       	movw	r26, r18
    72f0:	1d 92       	st	X+, r1
    72f2:	1d 92       	st	X+, r1
    72f4:	1d 92       	st	X+, r1
    72f6:	1c 92       	st	X, r1
    72f8:	13 97       	sbiw	r26, 0x03	; 3
    72fa:	9f 01       	movw	r18, r30
    72fc:	27 5f       	subi	r18, 0xF7	; 247
    72fe:	3e 4f       	sbci	r19, 0xFE	; 254
    7300:	38 ab       	std	Y+48, r19	; 0x30
    7302:	2f a7       	std	Y+47, r18	; 0x2f
    7304:	d9 01       	movw	r26, r18
    7306:	1d 92       	st	X+, r1
    7308:	1d 92       	st	X+, r1
    730a:	1d 92       	st	X+, r1
    730c:	1c 92       	st	X, r1
    730e:	13 97       	sbiw	r26, 0x03	; 3
    7310:	9f 01       	movw	r18, r30
    7312:	23 5f       	subi	r18, 0xF3	; 243
    7314:	3e 4f       	sbci	r19, 0xFE	; 254
    7316:	3a ab       	std	Y+50, r19	; 0x32
    7318:	29 ab       	std	Y+49, r18	; 0x31
    731a:	d9 01       	movw	r26, r18
    731c:	1d 92       	st	X+, r1
    731e:	1d 92       	st	X+, r1
    7320:	1d 92       	st	X+, r1
    7322:	1c 92       	st	X, r1
    7324:	13 97       	sbiw	r26, 0x03	; 3
    7326:	9f 01       	movw	r18, r30
    7328:	2f 5e       	subi	r18, 0xEF	; 239
    732a:	3e 4f       	sbci	r19, 0xFE	; 254
    732c:	3c ab       	std	Y+52, r19	; 0x34
    732e:	2b ab       	std	Y+51, r18	; 0x33
    7330:	d9 01       	movw	r26, r18
    7332:	1d 92       	st	X+, r1
    7334:	1d 92       	st	X+, r1
    7336:	1d 92       	st	X+, r1
    7338:	1c 92       	st	X, r1
    733a:	13 97       	sbiw	r26, 0x03	; 3
    733c:	9f 01       	movw	r18, r30
    733e:	2b 5e       	subi	r18, 0xEB	; 235
    7340:	3e 4f       	sbci	r19, 0xFE	; 254
    7342:	3e ab       	std	Y+54, r19	; 0x36
    7344:	2d ab       	std	Y+53, r18	; 0x35
    7346:	d9 01       	movw	r26, r18
    7348:	1d 92       	st	X+, r1
    734a:	1d 92       	st	X+, r1
    734c:	1d 92       	st	X+, r1
    734e:	1c 92       	st	X, r1
    7350:	13 97       	sbiw	r26, 0x03	; 3
    7352:	9f 01       	movw	r18, r30
    7354:	27 5e       	subi	r18, 0xE7	; 231
    7356:	3e 4f       	sbci	r19, 0xFE	; 254
    7358:	38 af       	std	Y+56, r19	; 0x38
    735a:	2f ab       	std	Y+55, r18	; 0x37
    735c:	d9 01       	movw	r26, r18
    735e:	1d 92       	st	X+, r1
    7360:	1d 92       	st	X+, r1
    7362:	1d 92       	st	X+, r1
    7364:	1c 92       	st	X, r1
    7366:	13 97       	sbiw	r26, 0x03	; 3
    7368:	9f 01       	movw	r18, r30
    736a:	23 5e       	subi	r18, 0xE3	; 227
    736c:	3e 4f       	sbci	r19, 0xFE	; 254
    736e:	3a af       	std	Y+58, r19	; 0x3a
    7370:	29 af       	std	Y+57, r18	; 0x39
    7372:	d9 01       	movw	r26, r18
    7374:	1d 92       	st	X+, r1
    7376:	1d 92       	st	X+, r1
    7378:	1d 92       	st	X+, r1
    737a:	1c 92       	st	X, r1
    737c:	13 97       	sbiw	r26, 0x03	; 3
    737e:	9f 01       	movw	r18, r30
    7380:	2f 5d       	subi	r18, 0xDF	; 223
    7382:	3e 4f       	sbci	r19, 0xFE	; 254
    7384:	3c af       	std	Y+60, r19	; 0x3c
    7386:	2b af       	std	Y+59, r18	; 0x3b
    7388:	d9 01       	movw	r26, r18
    738a:	1d 92       	st	X+, r1
    738c:	1d 92       	st	X+, r1
    738e:	1d 92       	st	X+, r1
    7390:	1c 92       	st	X, r1
    7392:	13 97       	sbiw	r26, 0x03	; 3
    7394:	9f 01       	movw	r18, r30
    7396:	2b 5d       	subi	r18, 0xDB	; 219
    7398:	3e 4f       	sbci	r19, 0xFE	; 254
    739a:	3e af       	std	Y+62, r19	; 0x3e
    739c:	2d af       	std	Y+61, r18	; 0x3d
    739e:	d9 01       	movw	r26, r18
    73a0:	1d 92       	st	X+, r1
    73a2:	1d 92       	st	X+, r1
    73a4:	1d 92       	st	X+, r1
    73a6:	1c 92       	st	X, r1
    73a8:	13 97       	sbiw	r26, 0x03	; 3
    73aa:	9f 01       	movw	r18, r30
    73ac:	27 5d       	subi	r18, 0xD7	; 215
    73ae:	3e 4f       	sbci	r19, 0xFE	; 254
    73b0:	21 96       	adiw	r28, 0x01	; 1
    73b2:	3f af       	std	Y+63, r19	; 0x3f
    73b4:	2e af       	std	Y+62, r18	; 0x3e
    73b6:	21 97       	sbiw	r28, 0x01	; 1
    73b8:	d9 01       	movw	r26, r18
    73ba:	1d 92       	st	X+, r1
    73bc:	1d 92       	st	X+, r1
    73be:	1d 92       	st	X+, r1
    73c0:	1c 92       	st	X, r1
    73c2:	13 97       	sbiw	r26, 0x03	; 3
    73c4:	9f 01       	movw	r18, r30
    73c6:	23 5d       	subi	r18, 0xD3	; 211
    73c8:	3e 4f       	sbci	r19, 0xFE	; 254
    73ca:	23 96       	adiw	r28, 0x03	; 3
    73cc:	3f af       	std	Y+63, r19	; 0x3f
    73ce:	2e af       	std	Y+62, r18	; 0x3e
    73d0:	23 97       	sbiw	r28, 0x03	; 3
    73d2:	d9 01       	movw	r26, r18
    73d4:	1d 92       	st	X+, r1
    73d6:	1d 92       	st	X+, r1
    73d8:	1d 92       	st	X+, r1
    73da:	1c 92       	st	X, r1
    73dc:	13 97       	sbiw	r26, 0x03	; 3
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}

			float YawDerivativeError() const {return yawDerivativeError;}
    73de:	25 96       	adiw	r28, 0x05	; 5
    73e0:	ae ad       	ldd	r26, Y+62	; 0x3e
    73e2:	bf ad       	ldd	r27, Y+63	; 0x3f
    73e4:	25 97       	sbiw	r28, 0x05	; 5
    73e6:	5e 96       	adiw	r26, 0x1e	; 30
    73e8:	cd 90       	ld	r12, X+
    73ea:	dd 90       	ld	r13, X+
    73ec:	ed 90       	ld	r14, X+
    73ee:	fc 90       	ld	r15, X
    73f0:	91 97       	sbiw	r26, 0x21	; 33
	
	message->YawDerivativeError = model->YawDerivativeError();
    73f2:	c5 86       	std	Z+13, r12	; 0x0d
    73f4:	d6 86       	std	Z+14, r13	; 0x0e
    73f6:	e7 86       	std	Z+15, r14	; 0x0f
    73f8:	f0 8a       	std	Z+16, r15	; 0x10
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
    73fa:	56 96       	adiw	r26, 0x16	; 22
    73fc:	cd 90       	ld	r12, X+
    73fe:	dd 90       	ld	r13, X+
    7400:	ed 90       	ld	r14, X+
    7402:	fc 90       	ld	r15, X
    7404:	59 97       	sbiw	r26, 0x19	; 25
	message->YawIntegral = model->YawIntegral();
    7406:	c5 82       	std	Z+5, r12	; 0x05
    7408:	d6 82       	std	Z+6, r13	; 0x06
    740a:	e7 82       	std	Z+7, r14	; 0x07
    740c:	f0 86       	std	Z+8, r15	; 0x08
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
    740e:	5a 96       	adiw	r26, 0x1a	; 26
    7410:	cd 90       	ld	r12, X+
    7412:	dd 90       	ld	r13, X+
    7414:	ed 90       	ld	r14, X+
    7416:	fc 90       	ld	r15, X
    7418:	5d 97       	sbiw	r26, 0x1d	; 29
	message->YawProportional = model->YawProportional();
    741a:	c1 86       	std	Z+9, r12	; 0x09
    741c:	d2 86       	std	Z+10, r13	; 0x0a
    741e:	e3 86       	std	Z+11, r14	; 0x0b
    7420:	f4 86       	std	Z+12, r15	; 0x0c
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    7422:	1a 96       	adiw	r26, 0x0a	; 10
    7424:	cd 90       	ld	r12, X+
    7426:	dd 90       	ld	r13, X+
    7428:	ed 90       	ld	r14, X+
    742a:	fc 90       	ld	r15, X
    742c:	1d 97       	sbiw	r26, 0x0d	; 13
	message->YawControl = model->YawControl();
    742e:	c1 8a       	std	Z+17, r12	; 0x11
    7430:	d2 8a       	std	Z+18, r13	; 0x12
    7432:	e3 8a       	std	Z+19, r14	; 0x13
    7434:	f4 8a       	std	Z+20, r15	; 0x14
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    7436:	6d 01       	movw	r12, r26
    7438:	b2 ed       	ldi	r27, 0xD2	; 210
    743a:	cb 0e       	add	r12, r27
    743c:	d1 1c       	adc	r13, r1
    743e:	d6 01       	movw	r26, r12
    7440:	cd 90       	ld	r12, X+
    7442:	dd 90       	ld	r13, X+
    7444:	ed 90       	ld	r14, X+
    7446:	fc 90       	ld	r15, X
	

	message->PitchRads = model->PitchRads();
    7448:	c5 a6       	std	Z+45, r12	; 0x2d
    744a:	d6 a6       	std	Z+46, r13	; 0x2e
    744c:	e7 a6       	std	Z+47, r14	; 0x2f
    744e:	f0 aa       	std	Z+48, r15	; 0x30
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    7450:	25 96       	adiw	r28, 0x05	; 5
    7452:	ae ad       	ldd	r26, Y+62	; 0x3e
    7454:	bf ad       	ldd	r27, Y+63	; 0x3f
    7456:	25 97       	sbiw	r28, 0x05	; 5
    7458:	92 96       	adiw	r26, 0x22	; 34
    745a:	cd 90       	ld	r12, X+
    745c:	dd 90       	ld	r13, X+
    745e:	ed 90       	ld	r14, X+
    7460:	fc 90       	ld	r15, X
    7462:	95 97       	sbiw	r26, 0x25	; 37
	message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    7464:	c5 a2       	std	Z+37, r12	; 0x25
    7466:	d6 a2       	std	Z+38, r13	; 0x26
    7468:	e7 a2       	std	Z+39, r14	; 0x27
    746a:	f0 a6       	std	Z+40, r15	; 0x28
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
    746c:	6d 01       	movw	r12, r26
    746e:	b6 e4       	ldi	r27, 0x46	; 70
    7470:	cb 0e       	add	r12, r27
    7472:	d1 1c       	adc	r13, r1
    7474:	d6 01       	movw	r26, r12
    7476:	cd 90       	ld	r12, X+
    7478:	dd 90       	ld	r13, X+
    747a:	ed 90       	ld	r14, X+
    747c:	fc 90       	ld	r15, X
	message->XDerivativeError = model->XDerivativeError();
    747e:	c1 ae       	std	Z+57, r12	; 0x39
    7480:	d2 ae       	std	Z+58, r13	; 0x3a
    7482:	e3 ae       	std	Z+59, r14	; 0x3b
    7484:	f4 ae       	std	Z+60, r15	; 0x3c
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
    7486:	25 96       	adiw	r28, 0x05	; 5
    7488:	ce ac       	ldd	r12, Y+62	; 0x3e
    748a:	df ac       	ldd	r13, Y+63	; 0x3f
    748c:	25 97       	sbiw	r28, 0x05	; 5
    748e:	b2 e4       	ldi	r27, 0x42	; 66
    7490:	cb 0e       	add	r12, r27
    7492:	d1 1c       	adc	r13, r1
    7494:	d6 01       	movw	r26, r12
    7496:	cd 90       	ld	r12, X+
    7498:	dd 90       	ld	r13, X+
    749a:	ed 90       	ld	r14, X+
    749c:	fc 90       	ld	r15, X
	message->XIntegral = model->XIntegral();
    749e:	c1 aa       	std	Z+49, r12	; 0x31
    74a0:	d2 aa       	std	Z+50, r13	; 0x32
    74a2:	e3 aa       	std	Z+51, r14	; 0x33
    74a4:	f4 aa       	std	Z+52, r15	; 0x34
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
    74a6:	25 96       	adiw	r28, 0x05	; 5
    74a8:	ce ac       	ldd	r12, Y+62	; 0x3e
    74aa:	df ac       	ldd	r13, Y+63	; 0x3f
    74ac:	25 97       	sbiw	r28, 0x05	; 5
    74ae:	be e3       	ldi	r27, 0x3E	; 62
    74b0:	cb 0e       	add	r12, r27
    74b2:	d1 1c       	adc	r13, r1
    74b4:	d6 01       	movw	r26, r12
    74b6:	cd 90       	ld	r12, X+
    74b8:	dd 90       	ld	r13, X+
    74ba:	ed 90       	ld	r14, X+
    74bc:	fc 90       	ld	r15, X
	message->XProportional = model->XProportional();
    74be:	c5 aa       	std	Z+53, r12	; 0x35
    74c0:	d6 aa       	std	Z+54, r13	; 0x36
    74c2:	e7 aa       	std	Z+55, r14	; 0x37
    74c4:	f0 ae       	std	Z+56, r15	; 0x38
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    74c6:	25 96       	adiw	r28, 0x05	; 5
    74c8:	ae ad       	ldd	r26, Y+62	; 0x3e
    74ca:	bf ad       	ldd	r27, Y+63	; 0x3f
    74cc:	25 97       	sbiw	r28, 0x05	; 5
    74ce:	d2 96       	adiw	r26, 0x32	; 50
    74d0:	cd 90       	ld	r12, X+
    74d2:	dd 90       	ld	r13, X+
    74d4:	ed 90       	ld	r14, X+
    74d6:	fc 90       	ld	r15, X
    74d8:	d5 97       	sbiw	r26, 0x35	; 53
	message->XVelocityFRDCms = model->XVelocityFRDCms();
    74da:	c1 a6       	std	Z+41, r12	; 0x29
    74dc:	d2 a6       	std	Z+42, r13	; 0x2a
    74de:	e3 a6       	std	Z+43, r14	; 0x2b
    74e0:	f4 a6       	std	Z+44, r15	; 0x2c
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    74e2:	9e 96       	adiw	r26, 0x2e	; 46
    74e4:	cd 90       	ld	r12, X+
    74e6:	dd 90       	ld	r13, X+
    74e8:	ed 90       	ld	r14, X+
    74ea:	fc 90       	ld	r15, X
    74ec:	d1 97       	sbiw	r26, 0x31	; 49
	message->LongitudeControl = model->LongitudeControl();
    74ee:	a9 81       	ldd	r26, Y+1	; 0x01
    74f0:	ba 81       	ldd	r27, Y+2	; 0x02
    74f2:	cd 92       	st	X+, r12
    74f4:	dd 92       	st	X+, r13
    74f6:	ed 92       	st	X+, r14
    74f8:	fc 92       	st	X, r15
    74fa:	13 97       	sbiw	r26, 0x03	; 3
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
    74fc:	25 96       	adiw	r28, 0x05	; 5
    74fe:	ae ad       	ldd	r26, Y+62	; 0x3e
    7500:	bf ad       	ldd	r27, Y+63	; 0x3f
    7502:	25 97       	sbiw	r28, 0x05	; 5
    7504:	da 96       	adiw	r26, 0x3a	; 58
    7506:	cd 90       	ld	r12, X+
    7508:	dd 90       	ld	r13, X+
    750a:	ed 90       	ld	r14, X+
    750c:	fc 90       	ld	r15, X
    750e:	dd 97       	sbiw	r26, 0x3d	; 61
	message->XLongitudeOuterLoopSetpoint = model->XLongitudeOuterLoopSetpoint();
    7510:	d8 01       	movw	r26, r16
    7512:	cd 92       	st	X+, r12
    7514:	dd 92       	st	X+, r13
    7516:	ed 92       	st	X+, r14
    7518:	fc 92       	st	X, r15
    751a:	13 97       	sbiw	r26, 0x03	; 3
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    751c:	25 96       	adiw	r28, 0x05	; 5
    751e:	0e ad       	ldd	r16, Y+62	; 0x3e
    7520:	1f ad       	ldd	r17, Y+63	; 0x3f
    7522:	25 97       	sbiw	r28, 0x05	; 5
    7524:	06 52       	subi	r16, 0x26	; 38
    7526:	1f 4f       	sbci	r17, 0xFF	; 255
    7528:	d8 01       	movw	r26, r16
    752a:	cd 90       	ld	r12, X+
    752c:	dd 90       	ld	r13, X+
    752e:	ed 90       	ld	r14, X+
    7530:	fc 90       	ld	r15, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    7532:	dc 01       	movw	r26, r24
    7534:	cd 92       	st	X+, r12
    7536:	dd 92       	st	X+, r13
    7538:	ed 92       	st	X+, r14
    753a:	fc 92       	st	X, r15
    753c:	13 97       	sbiw	r26, 0x03	; 3
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    753e:	25 96       	adiw	r28, 0x05	; 5
    7540:	ee ac       	ldd	r14, Y+62	; 0x3e
    7542:	ff ac       	ldd	r15, Y+63	; 0x3f
    7544:	25 97       	sbiw	r28, 0x05	; 5
    7546:	be ec       	ldi	r27, 0xCE	; 206
    7548:	eb 0e       	add	r14, r27
    754a:	f1 1c       	adc	r15, r1
    754c:	d7 01       	movw	r26, r14
    754e:	cd 90       	ld	r12, X+
    7550:	dd 90       	ld	r13, X+
    7552:	ed 90       	ld	r14, X+
    7554:	fc 90       	ld	r15, X

	
	message->RollRads = model->RollRads();
    7556:	db 01       	movw	r26, r22
    7558:	cd 92       	st	X+, r12
    755a:	dd 92       	st	X+, r13
    755c:	ed 92       	st	X+, r14
    755e:	fc 92       	st	X, r15
    7560:	13 97       	sbiw	r26, 0x03	; 3
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    7562:	25 96       	adiw	r28, 0x05	; 5
    7564:	6e ad       	ldd	r22, Y+62	; 0x3e
    7566:	7f ad       	ldd	r23, Y+63	; 0x3f
    7568:	25 97       	sbiw	r28, 0x05	; 5
    756a:	62 5b       	subi	r22, 0xB2	; 178
    756c:	7f 4f       	sbci	r23, 0xFF	; 255
    756e:	db 01       	movw	r26, r22
    7570:	cd 90       	ld	r12, X+
    7572:	dd 90       	ld	r13, X+
    7574:	ed 90       	ld	r14, X+
    7576:	fc 90       	ld	r15, X
	message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    7578:	da 01       	movw	r26, r20
    757a:	cd 92       	st	X+, r12
    757c:	dd 92       	st	X+, r13
    757e:	ed 92       	st	X+, r14
    7580:	fc 92       	st	X, r15
    7582:	13 97       	sbiw	r26, 0x03	; 3
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
    7584:	25 96       	adiw	r28, 0x05	; 5
    7586:	4e ad       	ldd	r20, Y+62	; 0x3e
    7588:	5f ad       	ldd	r21, Y+63	; 0x3f
    758a:	25 97       	sbiw	r28, 0x05	; 5
    758c:	4e 58       	subi	r20, 0x8E	; 142
    758e:	5f 4f       	sbci	r21, 0xFF	; 255
    7590:	da 01       	movw	r26, r20
    7592:	4d 91       	ld	r20, X+
    7594:	5d 91       	ld	r21, X+
    7596:	6d 91       	ld	r22, X+
    7598:	7c 91       	ld	r23, X
	message->YDerivativeError = model->YDerivativeError();
    759a:	27 96       	adiw	r28, 0x07	; 7
    759c:	ae ad       	ldd	r26, Y+62	; 0x3e
    759e:	bf ad       	ldd	r27, Y+63	; 0x3f
    75a0:	27 97       	sbiw	r28, 0x07	; 7
    75a2:	4d 93       	st	X+, r20
    75a4:	5d 93       	st	X+, r21
    75a6:	6d 93       	st	X+, r22
    75a8:	7c 93       	st	X, r23
    75aa:	13 97       	sbiw	r26, 0x03	; 3
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
    75ac:	25 96       	adiw	r28, 0x05	; 5
    75ae:	2e ad       	ldd	r18, Y+62	; 0x3e
    75b0:	3f ad       	ldd	r19, Y+63	; 0x3f
    75b2:	25 97       	sbiw	r28, 0x05	; 5
    75b4:	22 59       	subi	r18, 0x92	; 146
    75b6:	3f 4f       	sbci	r19, 0xFF	; 255
    75b8:	d9 01       	movw	r26, r18
    75ba:	4d 91       	ld	r20, X+
    75bc:	5d 91       	ld	r21, X+
    75be:	6d 91       	ld	r22, X+
    75c0:	7c 91       	ld	r23, X
	message->YIntegral = model->YIntegral();
    75c2:	d5 01       	movw	r26, r10
    75c4:	4d 93       	st	X+, r20
    75c6:	5d 93       	st	X+, r21
    75c8:	6d 93       	st	X+, r22
    75ca:	7c 93       	st	X, r23
    75cc:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
    75ce:	25 96       	adiw	r28, 0x05	; 5
    75d0:	2e ad       	ldd	r18, Y+62	; 0x3e
    75d2:	3f ad       	ldd	r19, Y+63	; 0x3f
    75d4:	25 97       	sbiw	r28, 0x05	; 5
    75d6:	26 59       	subi	r18, 0x96	; 150
    75d8:	3f 4f       	sbci	r19, 0xFF	; 255
    75da:	d9 01       	movw	r26, r18
    75dc:	4d 91       	ld	r20, X+
    75de:	5d 91       	ld	r21, X+
    75e0:	6d 91       	ld	r22, X+
    75e2:	7c 91       	ld	r23, X
	message->YProportional = model->YProportional();
    75e4:	d4 01       	movw	r26, r8
    75e6:	4d 93       	st	X+, r20
    75e8:	5d 93       	st	X+, r21
    75ea:	6d 93       	st	X+, r22
    75ec:	7c 93       	st	X, r23
    75ee:	13 97       	sbiw	r26, 0x03	; 3
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    75f0:	25 96       	adiw	r28, 0x05	; 5
    75f2:	2e ad       	ldd	r18, Y+62	; 0x3e
    75f4:	3f ad       	ldd	r19, Y+63	; 0x3f
    75f6:	25 97       	sbiw	r28, 0x05	; 5
    75f8:	22 5a       	subi	r18, 0xA2	; 162
    75fa:	3f 4f       	sbci	r19, 0xFF	; 255
    75fc:	d9 01       	movw	r26, r18
    75fe:	4d 91       	ld	r20, X+
    7600:	5d 91       	ld	r21, X+
    7602:	6d 91       	ld	r22, X+
    7604:	7c 91       	ld	r23, X
	message->YVelocityFRDCms = model->YVelocityFRDCms();
    7606:	d3 01       	movw	r26, r6
    7608:	4d 93       	st	X+, r20
    760a:	5d 93       	st	X+, r21
    760c:	6d 93       	st	X+, r22
    760e:	7c 93       	st	X, r23
    7610:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    7612:	25 96       	adiw	r28, 0x05	; 5
    7614:	2e ad       	ldd	r18, Y+62	; 0x3e
    7616:	3f ad       	ldd	r19, Y+63	; 0x3f
    7618:	25 97       	sbiw	r28, 0x05	; 5
    761a:	26 5a       	subi	r18, 0xA6	; 166
    761c:	3f 4f       	sbci	r19, 0xFF	; 255
    761e:	d9 01       	movw	r26, r18
    7620:	4d 91       	ld	r20, X+
    7622:	5d 91       	ld	r21, X+
    7624:	6d 91       	ld	r22, X+
    7626:	7c 91       	ld	r23, X
	message->LateralControl = model->LateralControl();
    7628:	d2 01       	movw	r26, r4
    762a:	4d 93       	st	X+, r20
    762c:	5d 93       	st	X+, r21
    762e:	6d 93       	st	X+, r22
    7630:	7c 93       	st	X, r23
    7632:	13 97       	sbiw	r26, 0x03	; 3
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
    7634:	25 96       	adiw	r28, 0x05	; 5
    7636:	2e ad       	ldd	r18, Y+62	; 0x3e
    7638:	3f ad       	ldd	r19, Y+63	; 0x3f
    763a:	25 97       	sbiw	r28, 0x05	; 5
    763c:	2a 59       	subi	r18, 0x9A	; 154
    763e:	3f 4f       	sbci	r19, 0xFF	; 255
    7640:	d9 01       	movw	r26, r18
    7642:	4d 91       	ld	r20, X+
    7644:	5d 91       	ld	r21, X+
    7646:	6d 91       	ld	r22, X+
    7648:	7c 91       	ld	r23, X
	message->YLateralOuterLoopSetpoint = model->YLateralOuterLoopSetpoint();
    764a:	d1 01       	movw	r26, r2
    764c:	4d 93       	st	X+, r20
    764e:	5d 93       	st	X+, r21
    7650:	6d 93       	st	X+, r22
    7652:	7c 93       	st	X, r23
    7654:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    7656:	25 96       	adiw	r28, 0x05	; 5
    7658:	2e ad       	ldd	r18, Y+62	; 0x3e
    765a:	3f ad       	ldd	r19, Y+63	; 0x3f
    765c:	25 97       	sbiw	r28, 0x05	; 5
    765e:	22 52       	subi	r18, 0x22	; 34
    7660:	3f 4f       	sbci	r19, 0xFF	; 255
    7662:	d9 01       	movw	r26, r18
    7664:	4d 91       	ld	r20, X+
    7666:	5d 91       	ld	r21, X+
    7668:	6d 91       	ld	r22, X+
    766a:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();	
    766c:	29 96       	adiw	r28, 0x09	; 9
    766e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7670:	bf ad       	ldd	r27, Y+63	; 0x3f
    7672:	29 97       	sbiw	r28, 0x09	; 9
    7674:	4d 93       	st	X+, r20
    7676:	5d 93       	st	X+, r21
    7678:	6d 93       	st	X+, r22
    767a:	7c 93       	st	X, r23
    767c:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}

			float ZDerivativeError() const {return zDerivativeError;}
    767e:	25 96       	adiw	r28, 0x05	; 5
    7680:	4e ad       	ldd	r20, Y+62	; 0x3e
    7682:	5f ad       	ldd	r21, Y+63	; 0x3f
    7684:	25 97       	sbiw	r28, 0x05	; 5
    7686:	42 56       	subi	r20, 0x62	; 98
    7688:	5f 4f       	sbci	r21, 0xFF	; 255
    768a:	da 01       	movw	r26, r20
    768c:	4d 91       	ld	r20, X+
    768e:	5d 91       	ld	r21, X+
    7690:	6d 91       	ld	r22, X+
    7692:	7c 91       	ld	r23, X
	
	
	//message->AltitudeMetersAgl = model->AltitudeMetersAgl();
	message->ZDerivativeError = model->ZDerivativeError();
    7694:	ab 85       	ldd	r26, Y+11	; 0x0b
    7696:	bc 85       	ldd	r27, Y+12	; 0x0c
    7698:	4d 93       	st	X+, r20
    769a:	5d 93       	st	X+, r21
    769c:	6d 93       	st	X+, r22
    769e:	7c 93       	st	X, r23
    76a0:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    76a2:	25 96       	adiw	r28, 0x05	; 5
    76a4:	4e ad       	ldd	r20, Y+62	; 0x3e
    76a6:	5f ad       	ldd	r21, Y+63	; 0x3f
    76a8:	25 97       	sbiw	r28, 0x05	; 5
    76aa:	4a 52       	subi	r20, 0x2A	; 42
    76ac:	5f 4f       	sbci	r21, 0xFF	; 255
    76ae:	da 01       	movw	r26, r20
    76b0:	4d 91       	ld	r20, X+
    76b2:	5d 91       	ld	r21, X+
    76b4:	6d 91       	ld	r22, X+
    76b6:	7c 91       	ld	r23, X
	message->YawRads = model->YawRads();
    76b8:	ad 81       	ldd	r26, Y+5	; 0x05
    76ba:	be 81       	ldd	r27, Y+6	; 0x06
    76bc:	4d 93       	st	X+, r20
    76be:	5d 93       	st	X+, r21
    76c0:	6d 93       	st	X+, r22
    76c2:	7c 93       	st	X, r23
    76c4:	13 97       	sbiw	r26, 0x03	; 3
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
    76c6:	25 96       	adiw	r28, 0x05	; 5
    76c8:	4e ad       	ldd	r20, Y+62	; 0x3e
    76ca:	5f ad       	ldd	r21, Y+63	; 0x3f
    76cc:	25 97       	sbiw	r28, 0x05	; 5
    76ce:	4a 56       	subi	r20, 0x6A	; 106
    76d0:	5f 4f       	sbci	r21, 0xFF	; 255
    76d2:	da 01       	movw	r26, r20
    76d4:	4d 91       	ld	r20, X+
    76d6:	5d 91       	ld	r21, X+
    76d8:	6d 91       	ld	r22, X+
    76da:	7c 91       	ld	r23, X
	message->ZIntegral = model->ZIntegral();
    76dc:	af 81       	ldd	r26, Y+7	; 0x07
    76de:	b8 85       	ldd	r27, Y+8	; 0x08
    76e0:	4d 93       	st	X+, r20
    76e2:	5d 93       	st	X+, r21
    76e4:	6d 93       	st	X+, r22
    76e6:	7c 93       	st	X, r23
    76e8:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
    76ea:	25 96       	adiw	r28, 0x05	; 5
    76ec:	4e ad       	ldd	r20, Y+62	; 0x3e
    76ee:	5f ad       	ldd	r21, Y+63	; 0x3f
    76f0:	25 97       	sbiw	r28, 0x05	; 5
    76f2:	46 56       	subi	r20, 0x66	; 102
    76f4:	5f 4f       	sbci	r21, 0xFF	; 255
    76f6:	da 01       	movw	r26, r20
    76f8:	4d 91       	ld	r20, X+
    76fa:	5d 91       	ld	r21, X+
    76fc:	6d 91       	ld	r22, X+
    76fe:	7c 91       	ld	r23, X
	message->ZProportional = model->ZProportional();
    7700:	a9 85       	ldd	r26, Y+9	; 0x09
    7702:	ba 85       	ldd	r27, Y+10	; 0x0a
    7704:	4d 93       	st	X+, r20
    7706:	5d 93       	st	X+, r21
    7708:	6d 93       	st	X+, r22
    770a:	7c 93       	st	X, r23
    770c:	13 97       	sbiw	r26, 0x03	; 3
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    770e:	25 96       	adiw	r28, 0x05	; 5
    7710:	4e ad       	ldd	r20, Y+62	; 0x3e
    7712:	5f ad       	ldd	r21, Y+63	; 0x3f
    7714:	25 97       	sbiw	r28, 0x05	; 5
    7716:	42 57       	subi	r20, 0x72	; 114
    7718:	5f 4f       	sbci	r21, 0xFF	; 255
    771a:	da 01       	movw	r26, r20
    771c:	4d 91       	ld	r20, X+
    771e:	5d 91       	ld	r21, X+
    7720:	6d 91       	ld	r22, X+
    7722:	7c 91       	ld	r23, X
	message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    7724:	ab 81       	ldd	r26, Y+3	; 0x03
    7726:	bc 81       	ldd	r27, Y+4	; 0x04
    7728:	4d 93       	st	X+, r20
    772a:	5d 93       	st	X+, r21
    772c:	6d 93       	st	X+, r22
    772e:	7c 93       	st	X, r23
    7730:	13 97       	sbiw	r26, 0x03	; 3

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    7732:	25 96       	adiw	r28, 0x05	; 5
    7734:	4e ad       	ldd	r20, Y+62	; 0x3e
    7736:	5f ad       	ldd	r21, Y+63	; 0x3f
    7738:	25 97       	sbiw	r28, 0x05	; 5
    773a:	4a 57       	subi	r20, 0x7A	; 122
    773c:	5f 4f       	sbci	r21, 0xFF	; 255
    773e:	da 01       	movw	r26, r20
    7740:	4d 91       	ld	r20, X+
    7742:	5d 91       	ld	r21, X+
    7744:	6d 91       	ld	r22, X+
    7746:	7c 91       	ld	r23, X
	message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    7748:	ad 85       	ldd	r26, Y+13	; 0x0d
    774a:	be 85       	ldd	r27, Y+14	; 0x0e
    774c:	4d 93       	st	X+, r20
    774e:	5d 93       	st	X+, r21
    7750:	6d 93       	st	X+, r22
    7752:	7c 93       	st	X, r23
    7754:	13 97       	sbiw	r26, 0x03	; 3
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    7756:	25 96       	adiw	r28, 0x05	; 5
    7758:	4e ad       	ldd	r20, Y+62	; 0x3e
    775a:	5f ad       	ldd	r21, Y+63	; 0x3f
    775c:	25 97       	sbiw	r28, 0x05	; 5
    775e:	42 58       	subi	r20, 0x82	; 130
    7760:	5f 4f       	sbci	r21, 0xFF	; 255
    7762:	da 01       	movw	r26, r20
    7764:	4d 91       	ld	r20, X+
    7766:	5d 91       	ld	r21, X+
    7768:	6d 91       	ld	r22, X+
    776a:	7c 91       	ld	r23, X
	message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    776c:	af 85       	ldd	r26, Y+15	; 0x0f
    776e:	b8 89       	ldd	r27, Y+16	; 0x10
    7770:	4d 93       	st	X+, r20
    7772:	5d 93       	st	X+, r21
    7774:	6d 93       	st	X+, r22
    7776:	7c 93       	st	X, r23
    7778:	13 97       	sbiw	r26, 0x03	; 3

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    777a:	25 96       	adiw	r28, 0x05	; 5
    777c:	4e ad       	ldd	r20, Y+62	; 0x3e
    777e:	5f ad       	ldd	r21, Y+63	; 0x3f
    7780:	25 97       	sbiw	r28, 0x05	; 5
    7782:	4a 51       	subi	r20, 0x1A	; 26
    7784:	5f 4f       	sbci	r21, 0xFF	; 255
    7786:	da 01       	movw	r26, r20
    7788:	4d 91       	ld	r20, X+
    778a:	5d 91       	ld	r21, X+
    778c:	6d 91       	ld	r22, X+
    778e:	7c 91       	ld	r23, X
	
	
	
	message->XAccelFrdMss = model->XAccelFrdMss();
    7790:	ad 89       	ldd	r26, Y+21	; 0x15
    7792:	be 89       	ldd	r27, Y+22	; 0x16
    7794:	4d 93       	st	X+, r20
    7796:	5d 93       	st	X+, r21
    7798:	6d 93       	st	X+, r22
    779a:	7c 93       	st	X, r23
    779c:	13 97       	sbiw	r26, 0x03	; 3
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    779e:	25 96       	adiw	r28, 0x05	; 5
    77a0:	4e ad       	ldd	r20, Y+62	; 0x3e
    77a2:	5f ad       	ldd	r21, Y+63	; 0x3f
    77a4:	25 97       	sbiw	r28, 0x05	; 5
    77a6:	46 51       	subi	r20, 0x16	; 22
    77a8:	5f 4f       	sbci	r21, 0xFF	; 255
    77aa:	da 01       	movw	r26, r20
    77ac:	4d 91       	ld	r20, X+
    77ae:	5d 91       	ld	r21, X+
    77b0:	6d 91       	ld	r22, X+
    77b2:	7c 91       	ld	r23, X
	message->YAccelFrdMss = model->YAccelFrdMss();
    77b4:	af 89       	ldd	r26, Y+23	; 0x17
    77b6:	b8 8d       	ldd	r27, Y+24	; 0x18
    77b8:	4d 93       	st	X+, r20
    77ba:	5d 93       	st	X+, r21
    77bc:	6d 93       	st	X+, r22
    77be:	7c 93       	st	X, r23
    77c0:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    77c2:	25 96       	adiw	r28, 0x05	; 5
    77c4:	4e ad       	ldd	r20, Y+62	; 0x3e
    77c6:	5f ad       	ldd	r21, Y+63	; 0x3f
    77c8:	25 97       	sbiw	r28, 0x05	; 5
    77ca:	42 51       	subi	r20, 0x12	; 18
    77cc:	5f 4f       	sbci	r21, 0xFF	; 255
    77ce:	da 01       	movw	r26, r20
    77d0:	4d 91       	ld	r20, X+
    77d2:	5d 91       	ld	r21, X+
    77d4:	6d 91       	ld	r22, X+
    77d6:	7c 91       	ld	r23, X
	message->ZAccelFrdMss = model->ZAccelFrdMss();
    77d8:	a9 8d       	ldd	r26, Y+25	; 0x19
    77da:	ba 8d       	ldd	r27, Y+26	; 0x1a
    77dc:	4d 93       	st	X+, r20
    77de:	5d 93       	st	X+, r21
    77e0:	6d 93       	st	X+, r22
    77e2:	7c 93       	st	X, r23
    77e4:	13 97       	sbiw	r26, 0x03	; 3
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    77e6:	25 96       	adiw	r28, 0x05	; 5
    77e8:	4e ad       	ldd	r20, Y+62	; 0x3e
    77ea:	5f ad       	ldd	r21, Y+63	; 0x3f
    77ec:	25 97       	sbiw	r28, 0x05	; 5
    77ee:	4e 51       	subi	r20, 0x1E	; 30
    77f0:	5f 4f       	sbci	r21, 0xFF	; 255
    77f2:	da 01       	movw	r26, r20
    77f4:	4d 91       	ld	r20, X+
    77f6:	5d 91       	ld	r21, X+
    77f8:	6d 91       	ld	r22, X+
    77fa:	7c 91       	ld	r23, X
	message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    77fc:	ab 8d       	ldd	r26, Y+27	; 0x1b
    77fe:	bc 8d       	ldd	r27, Y+28	; 0x1c
    7800:	4d 93       	st	X+, r20
    7802:	5d 93       	st	X+, r21
    7804:	6d 93       	st	X+, r22
    7806:	7c 93       	st	X, r23
    7808:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    780a:	d8 01       	movw	r26, r16
    780c:	4d 91       	ld	r20, X+
    780e:	5d 91       	ld	r21, X+
    7810:	6d 91       	ld	r22, X+
    7812:	7c 91       	ld	r23, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    7814:	dc 01       	movw	r26, r24
    7816:	4d 93       	st	X+, r20
    7818:	5d 93       	st	X+, r21
    781a:	6d 93       	st	X+, r22
    781c:	7c 93       	st	X, r23
    781e:	13 97       	sbiw	r26, 0x03	; 3
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    7820:	d9 01       	movw	r26, r18
    7822:	4d 91       	ld	r20, X+
    7824:	5d 91       	ld	r21, X+
    7826:	6d 91       	ld	r22, X+
    7828:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    782a:	29 96       	adiw	r28, 0x09	; 9
    782c:	ae ad       	ldd	r26, Y+62	; 0x3e
    782e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7830:	29 97       	sbiw	r28, 0x09	; 9
    7832:	4d 93       	st	X+, r20
    7834:	5d 93       	st	X+, r21
    7836:	6d 93       	st	X+, r22
    7838:	7c 93       	st	X, r23
    783a:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    783c:	25 96       	adiw	r28, 0x05	; 5
    783e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7840:	bf ad       	ldd	r27, Y+63	; 0x3f
    7842:	25 97       	sbiw	r28, 0x05	; 5
    7844:	ae 50       	subi	r26, 0x0E	; 14
    7846:	bf 4f       	sbci	r27, 0xFF	; 255
    7848:	4d 91       	ld	r20, X+
    784a:	5d 91       	ld	r21, X+
    784c:	6d 91       	ld	r22, X+
    784e:	7c 91       	ld	r23, X
	message->XMagFrd = model->XMagFrd();
    7850:	ad 8d       	ldd	r26, Y+29	; 0x1d
    7852:	be 8d       	ldd	r27, Y+30	; 0x1e
    7854:	4d 93       	st	X+, r20
    7856:	5d 93       	st	X+, r21
    7858:	6d 93       	st	X+, r22
    785a:	7c 93       	st	X, r23
    785c:	13 97       	sbiw	r26, 0x03	; 3
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    785e:	25 96       	adiw	r28, 0x05	; 5
    7860:	ae ad       	ldd	r26, Y+62	; 0x3e
    7862:	bf ad       	ldd	r27, Y+63	; 0x3f
    7864:	25 97       	sbiw	r28, 0x05	; 5
    7866:	aa 50       	subi	r26, 0x0A	; 10
    7868:	bf 4f       	sbci	r27, 0xFF	; 255
    786a:	4d 91       	ld	r20, X+
    786c:	5d 91       	ld	r21, X+
    786e:	6d 91       	ld	r22, X+
    7870:	7c 91       	ld	r23, X
	message->YMagFrd = model->YMagFrd();
    7872:	af 8d       	ldd	r26, Y+31	; 0x1f
    7874:	b8 a1       	ldd	r27, Y+32	; 0x20
    7876:	4d 93       	st	X+, r20
    7878:	5d 93       	st	X+, r21
    787a:	6d 93       	st	X+, r22
    787c:	7c 93       	st	X, r23
    787e:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    7880:	25 96       	adiw	r28, 0x05	; 5
    7882:	ae ad       	ldd	r26, Y+62	; 0x3e
    7884:	bf ad       	ldd	r27, Y+63	; 0x3f
    7886:	25 97       	sbiw	r28, 0x05	; 5
    7888:	a6 50       	subi	r26, 0x06	; 6
    788a:	bf 4f       	sbci	r27, 0xFF	; 255
    788c:	4d 91       	ld	r20, X+
    788e:	5d 91       	ld	r21, X+
    7890:	6d 91       	ld	r22, X+
    7892:	7c 91       	ld	r23, X
	message->ZMagFrd = model->ZMagFrd();
    7894:	a9 a1       	ldd	r26, Y+33	; 0x21
    7896:	ba a1       	ldd	r27, Y+34	; 0x22
    7898:	4d 93       	st	X+, r20
    789a:	5d 93       	st	X+, r21
    789c:	6d 93       	st	X+, r22
    789e:	7c 93       	st	X, r23
    78a0:	13 97       	sbiw	r26, 0x03	; 3
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    78a2:	25 96       	adiw	r28, 0x05	; 5
    78a4:	ae ad       	ldd	r26, Y+62	; 0x3e
    78a6:	bf ad       	ldd	r27, Y+63	; 0x3f
    78a8:	25 97       	sbiw	r28, 0x05	; 5
    78aa:	a2 50       	subi	r26, 0x02	; 2
    78ac:	bf 4f       	sbci	r27, 0xFF	; 255
    78ae:	4d 91       	ld	r20, X+
    78b0:	5d 91       	ld	r21, X+
    78b2:	6d 91       	ld	r22, X+
    78b4:	7c 91       	ld	r23, X

	message->XEcefCm = model->XEcefCm();
    78b6:	ab a1       	ldd	r26, Y+35	; 0x23
    78b8:	bc a1       	ldd	r27, Y+36	; 0x24
    78ba:	4d 93       	st	X+, r20
    78bc:	5d 93       	st	X+, r21
    78be:	6d 93       	st	X+, r22
    78c0:	7c 93       	st	X, r23
    78c2:	13 97       	sbiw	r26, 0x03	; 3
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    78c4:	25 96       	adiw	r28, 0x05	; 5
    78c6:	ae ad       	ldd	r26, Y+62	; 0x3e
    78c8:	bf ad       	ldd	r27, Y+63	; 0x3f
    78ca:	25 97       	sbiw	r28, 0x05	; 5
    78cc:	ae 5f       	subi	r26, 0xFE	; 254
    78ce:	be 4f       	sbci	r27, 0xFE	; 254
    78d0:	4d 91       	ld	r20, X+
    78d2:	5d 91       	ld	r21, X+
    78d4:	6d 91       	ld	r22, X+
    78d6:	7c 91       	ld	r23, X
	message->YEcefCm = model->YEcefCm();
    78d8:	ad a1       	ldd	r26, Y+37	; 0x25
    78da:	be a1       	ldd	r27, Y+38	; 0x26
    78dc:	4d 93       	st	X+, r20
    78de:	5d 93       	st	X+, r21
    78e0:	6d 93       	st	X+, r22
    78e2:	7c 93       	st	X, r23
    78e4:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    78e6:	25 96       	adiw	r28, 0x05	; 5
    78e8:	ae ad       	ldd	r26, Y+62	; 0x3e
    78ea:	bf ad       	ldd	r27, Y+63	; 0x3f
    78ec:	25 97       	sbiw	r28, 0x05	; 5
    78ee:	aa 5f       	subi	r26, 0xFA	; 250
    78f0:	be 4f       	sbci	r27, 0xFE	; 254
    78f2:	4d 91       	ld	r20, X+
    78f4:	5d 91       	ld	r21, X+
    78f6:	6d 91       	ld	r22, X+
    78f8:	7c 91       	ld	r23, X
	message->ZEcefCm = model->ZEcefCm();	
    78fa:	af a1       	ldd	r26, Y+39	; 0x27
    78fc:	b8 a5       	ldd	r27, Y+40	; 0x28
    78fe:	4d 93       	st	X+, r20
    7900:	5d 93       	st	X+, r21
    7902:	6d 93       	st	X+, r22
    7904:	7c 93       	st	X, r23
    7906:	13 97       	sbiw	r26, 0x03	; 3
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    7908:	25 96       	adiw	r28, 0x05	; 5
    790a:	ae ad       	ldd	r26, Y+62	; 0x3e
    790c:	bf ad       	ldd	r27, Y+63	; 0x3f
    790e:	25 97       	sbiw	r28, 0x05	; 5
    7910:	a6 5f       	subi	r26, 0xF6	; 246
    7912:	be 4f       	sbci	r27, 0xFE	; 254
    7914:	4d 91       	ld	r20, X+
    7916:	5d 91       	ld	r21, X+
    7918:	6d 91       	ld	r22, X+
    791a:	7c 91       	ld	r23, X
	message->XVEcefCms = model->XVEcefCms();
    791c:	a9 a5       	ldd	r26, Y+41	; 0x29
    791e:	ba a5       	ldd	r27, Y+42	; 0x2a
    7920:	4d 93       	st	X+, r20
    7922:	5d 93       	st	X+, r21
    7924:	6d 93       	st	X+, r22
    7926:	7c 93       	st	X, r23
    7928:	13 97       	sbiw	r26, 0x03	; 3
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    792a:	25 96       	adiw	r28, 0x05	; 5
    792c:	ae ad       	ldd	r26, Y+62	; 0x3e
    792e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7930:	25 97       	sbiw	r28, 0x05	; 5
    7932:	a2 5f       	subi	r26, 0xF2	; 242
    7934:	be 4f       	sbci	r27, 0xFE	; 254
    7936:	4d 91       	ld	r20, X+
    7938:	5d 91       	ld	r21, X+
    793a:	6d 91       	ld	r22, X+
    793c:	7c 91       	ld	r23, X
	message->YVEcefCms = model->YVEcefCms();
    793e:	ab a5       	ldd	r26, Y+43	; 0x2b
    7940:	bc a5       	ldd	r27, Y+44	; 0x2c
    7942:	4d 93       	st	X+, r20
    7944:	5d 93       	st	X+, r21
    7946:	6d 93       	st	X+, r22
    7948:	7c 93       	st	X, r23
    794a:	13 97       	sbiw	r26, 0x03	; 3
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    794c:	25 96       	adiw	r28, 0x05	; 5
    794e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7950:	bf ad       	ldd	r27, Y+63	; 0x3f
    7952:	25 97       	sbiw	r28, 0x05	; 5
    7954:	ae 5e       	subi	r26, 0xEE	; 238
    7956:	be 4f       	sbci	r27, 0xFE	; 254
    7958:	4d 91       	ld	r20, X+
    795a:	5d 91       	ld	r21, X+
    795c:	6d 91       	ld	r22, X+
    795e:	7c 91       	ld	r23, X
	message->ZVEcefCms = model->ZVEcefCms();
    7960:	ad a5       	ldd	r26, Y+45	; 0x2d
    7962:	be a5       	ldd	r27, Y+46	; 0x2e
    7964:	4d 93       	st	X+, r20
    7966:	5d 93       	st	X+, r21
    7968:	6d 93       	st	X+, r22
    796a:	7c 93       	st	X, r23
    796c:	13 97       	sbiw	r26, 0x03	; 3
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    796e:	25 96       	adiw	r28, 0x05	; 5
    7970:	ae ad       	ldd	r26, Y+62	; 0x3e
    7972:	bf ad       	ldd	r27, Y+63	; 0x3f
    7974:	25 97       	sbiw	r28, 0x05	; 5
    7976:	aa 5e       	subi	r26, 0xEA	; 234
    7978:	be 4f       	sbci	r27, 0xFE	; 254
    797a:	4d 91       	ld	r20, X+
    797c:	5d 91       	ld	r21, X+
    797e:	6d 91       	ld	r22, X+
    7980:	7c 91       	ld	r23, X
	message->PressureMillibars = model->PressureMillibars();
    7982:	af a5       	ldd	r26, Y+47	; 0x2f
    7984:	b8 a9       	ldd	r27, Y+48	; 0x30
    7986:	4d 93       	st	X+, r20
    7988:	5d 93       	st	X+, r21
    798a:	6d 93       	st	X+, r22
    798c:	7c 93       	st	X, r23
    798e:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    7990:	25 96       	adiw	r28, 0x05	; 5
    7992:	ae ad       	ldd	r26, Y+62	; 0x3e
    7994:	bf ad       	ldd	r27, Y+63	; 0x3f
    7996:	25 97       	sbiw	r28, 0x05	; 5
    7998:	ae 54       	subi	r26, 0x4E	; 78
    799a:	bf 4f       	sbci	r27, 0xFF	; 255
    799c:	4d 91       	ld	r20, X+
    799e:	5d 91       	ld	r21, X+
    79a0:	6d 91       	ld	r22, X+
    79a2:	7c 91       	ld	r23, X
	
	
	
	message->ChecksumErrors = model->ChecksumErrors();
    79a4:	ad ad       	ldd	r26, Y+61	; 0x3d
    79a6:	be ad       	ldd	r27, Y+62	; 0x3e
    79a8:	4d 93       	st	X+, r20
    79aa:	5d 93       	st	X+, r21
    79ac:	6d 93       	st	X+, r22
    79ae:	7c 93       	st	X, r23
    79b0:	13 97       	sbiw	r26, 0x03	; 3

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    79b2:	25 96       	adiw	r28, 0x05	; 5
    79b4:	ae ad       	ldd	r26, Y+62	; 0x3e
    79b6:	bf ad       	ldd	r27, Y+63	; 0x3f
    79b8:	25 97       	sbiw	r28, 0x05	; 5
    79ba:	a6 55       	subi	r26, 0x56	; 86
    79bc:	bf 4f       	sbci	r27, 0xFF	; 255
    79be:	4d 91       	ld	r20, X+
    79c0:	5d 91       	ld	r21, X+
    79c2:	6d 91       	ld	r22, X+
    79c4:	7c 91       	ld	r23, X
	message->Timeouts = model->Timeouts();
    79c6:	a9 ad       	ldd	r26, Y+57	; 0x39
    79c8:	ba ad       	ldd	r27, Y+58	; 0x3a
    79ca:	4d 93       	st	X+, r20
    79cc:	5d 93       	st	X+, r21
    79ce:	6d 93       	st	X+, r22
    79d0:	7c 93       	st	X, r23
    79d2:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    79d4:	25 96       	adiw	r28, 0x05	; 5
    79d6:	ae ad       	ldd	r26, Y+62	; 0x3e
    79d8:	bf ad       	ldd	r27, Y+63	; 0x3f
    79da:	25 97       	sbiw	r28, 0x05	; 5
    79dc:	a2 55       	subi	r26, 0x52	; 82
    79de:	bf 4f       	sbci	r27, 0xFF	; 255
    79e0:	4d 91       	ld	r20, X+
    79e2:	5d 91       	ld	r21, X+
    79e4:	6d 91       	ld	r22, X+
    79e6:	7c 91       	ld	r23, X
	message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    79e8:	ab ad       	ldd	r26, Y+59	; 0x3b
    79ea:	bc ad       	ldd	r27, Y+60	; 0x3c
    79ec:	4d 93       	st	X+, r20
    79ee:	5d 93       	st	X+, r21
    79f0:	6d 93       	st	X+, r22
    79f2:	7c 93       	st	X, r23
    79f4:	13 97       	sbiw	r26, 0x03	; 3
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    79f6:	25 96       	adiw	r28, 0x05	; 5
    79f8:	ae ad       	ldd	r26, Y+62	; 0x3e
    79fa:	bf ad       	ldd	r27, Y+63	; 0x3f
    79fc:	25 97       	sbiw	r28, 0x05	; 5
    79fe:	aa 54       	subi	r26, 0x4A	; 74
    7a00:	bf 4f       	sbci	r27, 0xFF	; 255
    7a02:	4d 91       	ld	r20, X+
    7a04:	5d 91       	ld	r21, X+
    7a06:	6d 91       	ld	r22, X+
    7a08:	7c 91       	ld	r23, X
	message->NumOfBlownFrames = model->BlownFrames();
    7a0a:	21 96       	adiw	r28, 0x01	; 1
    7a0c:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a0e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a10:	21 97       	sbiw	r28, 0x01	; 1
    7a12:	4d 93       	st	X+, r20
    7a14:	5d 93       	st	X+, r21
    7a16:	6d 93       	st	X+, r22
    7a18:	7c 93       	st	X, r23
    7a1a:	13 97       	sbiw	r26, 0x03	; 3
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    7a1c:	25 96       	adiw	r28, 0x05	; 5
    7a1e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a20:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a22:	25 97       	sbiw	r28, 0x05	; 5
    7a24:	a6 54       	subi	r26, 0x46	; 70
    7a26:	bf 4f       	sbci	r27, 0xFF	; 255
    7a28:	4d 91       	ld	r20, X+
    7a2a:	5d 91       	ld	r21, X+
    7a2c:	6d 91       	ld	r22, X+
    7a2e:	7c 91       	ld	r23, X
	message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    7a30:	23 96       	adiw	r28, 0x03	; 3
    7a32:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a34:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a36:	23 97       	sbiw	r28, 0x03	; 3
    7a38:	4d 93       	st	X+, r20
    7a3a:	5d 93       	st	X+, r21
    7a3c:	6d 93       	st	X+, r22
    7a3e:	7c 93       	st	X, r23
    7a40:	13 97       	sbiw	r26, 0x03	; 3
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
    7a42:	25 96       	adiw	r28, 0x05	; 5
    7a44:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a46:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a48:	25 97       	sbiw	r28, 0x05	; 5
    7a4a:	96 96       	adiw	r26, 0x26	; 38
    7a4c:	4d 91       	ld	r20, X+
    7a4e:	5d 91       	ld	r21, X+
    7a50:	6d 91       	ld	r22, X+
    7a52:	7c 91       	ld	r23, X
    7a54:	99 97       	sbiw	r26, 0x29	; 41
	
	
	
	message->XRefSetpoint = model->ReferenceXNEDLocalFrameCm();
    7a56:	a9 a9       	ldd	r26, Y+49	; 0x31
    7a58:	ba a9       	ldd	r27, Y+50	; 0x32
    7a5a:	4d 93       	st	X+, r20
    7a5c:	5d 93       	st	X+, r21
    7a5e:	6d 93       	st	X+, r22
    7a60:	7c 93       	st	X, r23
    7a62:	13 97       	sbiw	r26, 0x03	; 3


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    7a64:	25 96       	adiw	r28, 0x05	; 5
    7a66:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a68:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a6a:	25 97       	sbiw	r28, 0x05	; 5
    7a6c:	ae 5a       	subi	r26, 0xAE	; 174
    7a6e:	bf 4f       	sbci	r27, 0xFF	; 255
    7a70:	4d 91       	ld	r20, X+
    7a72:	5d 91       	ld	r21, X+
    7a74:	6d 91       	ld	r22, X+
    7a76:	7c 91       	ld	r23, X
	message->YRefSetpoint = model->ReferenceYNEDLocalFrameCm();
    7a78:	ab a9       	ldd	r26, Y+51	; 0x33
    7a7a:	bc a9       	ldd	r27, Y+52	; 0x34
    7a7c:	4d 93       	st	X+, r20
    7a7e:	5d 93       	st	X+, r21
    7a80:	6d 93       	st	X+, r22
    7a82:	7c 93       	st	X, r23
    7a84:	13 97       	sbiw	r26, 0x03	; 3

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    7a86:	25 96       	adiw	r28, 0x05	; 5
    7a88:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a8a:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a8c:	25 97       	sbiw	r28, 0x05	; 5
    7a8e:	ae 57       	subi	r26, 0x7E	; 126
    7a90:	bf 4f       	sbci	r27, 0xFF	; 255
    7a92:	4d 91       	ld	r20, X+
    7a94:	5d 91       	ld	r21, X+
    7a96:	6d 91       	ld	r22, X+
    7a98:	7c 91       	ld	r23, X
	message->ZRefSetpoint = model->ReferenceZNEDLocalFrameCm();	
    7a9a:	ad a9       	ldd	r26, Y+53	; 0x35
    7a9c:	be a9       	ldd	r27, Y+54	; 0x36
    7a9e:	4d 93       	st	X+, r20
    7aa0:	5d 93       	st	X+, r21
    7aa2:	6d 93       	st	X+, r22
    7aa4:	7c 93       	st	X, r23
    7aa6:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
    7aa8:	25 96       	adiw	r28, 0x05	; 5
    7aaa:	ae ad       	ldd	r26, Y+62	; 0x3e
    7aac:	bf ad       	ldd	r27, Y+63	; 0x3f
    7aae:	25 97       	sbiw	r28, 0x05	; 5
    7ab0:	16 96       	adiw	r26, 0x06	; 6
    7ab2:	4d 91       	ld	r20, X+
    7ab4:	5d 91       	ld	r21, X+
    7ab6:	6d 91       	ld	r22, X+
    7ab8:	7c 91       	ld	r23, X
    7aba:	19 97       	sbiw	r26, 0x09	; 9
	message->YawRefSetpoint = model->ReferenceMagYawRads();
    7abc:	af a9       	ldd	r26, Y+55	; 0x37
    7abe:	b8 ad       	ldd	r27, Y+56	; 0x38
    7ac0:	4d 93       	st	X+, r20
    7ac2:	5d 93       	st	X+, r21
    7ac4:	6d 93       	st	X+, r22
    7ac6:	7c 93       	st	X, r23
    7ac8:	13 97       	sbiw	r26, 0x03	; 3

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    7aca:	25 96       	adiw	r28, 0x05	; 5
    7acc:	ae ad       	ldd	r26, Y+62	; 0x3e
    7ace:	bf ad       	ldd	r27, Y+63	; 0x3f
    7ad0:	25 97       	sbiw	r28, 0x05	; 5
    7ad2:	ae 55       	subi	r26, 0x5E	; 94
    7ad4:	bf 4f       	sbci	r27, 0xFF	; 255
    7ad6:	4d 91       	ld	r20, X+
    7ad8:	5d 91       	ld	r21, X+
    7ada:	6d 91       	ld	r22, X+
    7adc:	7c 91       	ld	r23, X
	
	
	message->LatitudeDegrees = model->LatitudeDegrees();
    7ade:	a9 89       	ldd	r26, Y+17	; 0x11
    7ae0:	ba 89       	ldd	r27, Y+18	; 0x12
    7ae2:	4d 93       	st	X+, r20
    7ae4:	5d 93       	st	X+, r21
    7ae6:	6d 93       	st	X+, r22
    7ae8:	7c 93       	st	X, r23
    7aea:	13 97       	sbiw	r26, 0x03	; 3
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    7aec:	25 96       	adiw	r28, 0x05	; 5
    7aee:	ae ad       	ldd	r26, Y+62	; 0x3e
    7af0:	bf ad       	ldd	r27, Y+63	; 0x3f
    7af2:	25 97       	sbiw	r28, 0x05	; 5
    7af4:	aa 55       	subi	r26, 0x5A	; 90
    7af6:	bf 4f       	sbci	r27, 0xFF	; 255
    7af8:	4d 91       	ld	r20, X+
    7afa:	5d 91       	ld	r21, X+
    7afc:	6d 91       	ld	r22, X+
    7afe:	7c 91       	ld	r23, X
	message->LongitudeDegrees = model->LongitudeDegrees();
    7b00:	ab 89       	ldd	r26, Y+19	; 0x13
    7b02:	bc 89       	ldd	r27, Y+20	; 0x14
    7b04:	4d 93       	st	X+, r20
    7b06:	5d 93       	st	X+, r21
    7b08:	6d 93       	st	X+, r22
    7b0a:	7c 93       	st	X, r23
    7b0c:	13 97       	sbiw	r26, 0x03	; 3
	
	return message;
}
    7b0e:	8e 2f       	mov	r24, r30
    7b10:	9f 2f       	mov	r25, r31
    7b12:	c8 5b       	subi	r28, 0xB8	; 184
    7b14:	df 4f       	sbci	r29, 0xFF	; 255
    7b16:	0f b6       	in	r0, 0x3f	; 63
    7b18:	f8 94       	cli
    7b1a:	de bf       	out	0x3e, r29	; 62
    7b1c:	0f be       	out	0x3f, r0	; 63
    7b1e:	cd bf       	out	0x3d, r28	; 61
    7b20:	df 91       	pop	r29
    7b22:	cf 91       	pop	r28
    7b24:	1f 91       	pop	r17
    7b26:	0f 91       	pop	r16
    7b28:	ff 90       	pop	r15
    7b2a:	ef 90       	pop	r14
    7b2c:	df 90       	pop	r13
    7b2e:	cf 90       	pop	r12
    7b30:	bf 90       	pop	r11
    7b32:	af 90       	pop	r10
    7b34:	9f 90       	pop	r9
    7b36:	8f 90       	pop	r8
    7b38:	7f 90       	pop	r7
    7b3a:	6f 90       	pop	r6
    7b3c:	5f 90       	pop	r5
    7b3e:	4f 90       	pop	r4
    7b40:	3f 90       	pop	r3
    7b42:	2f 90       	pop	r2
    7b44:	08 95       	ret

00007b46 <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>:
	model->YVEcefCms(this->YVEcefCms);
	model->ZVEcefCms(this->ZVEcefCms);
}

void SystemTelemetryMessage::updateModelFromMessageFromSimulator (SystemModel *model)
{
    7b46:	fb 01       	movw	r30, r22
	//Convert from meters per sec, to foot per sec.
	
	
	
	//Copy fake gyroscope data
	model->PitchAngularVelocityRadsPerSecond(this->PitchAngularVelocityRadsPerSecond);
    7b48:	dc 01       	movw	r26, r24
    7b4a:	a3 52       	subi	r26, 0x23	; 35
    7b4c:	bf 4f       	sbci	r27, 0xFF	; 255
    7b4e:	4d 91       	ld	r20, X+
    7b50:	5d 91       	ld	r21, X+
    7b52:	6d 91       	ld	r22, X+
    7b54:	7c 91       	ld	r23, X
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    7b56:	df 01       	movw	r26, r30
    7b58:	a6 52       	subi	r26, 0x26	; 38
    7b5a:	bf 4f       	sbci	r27, 0xFF	; 255
    7b5c:	4d 93       	st	X+, r20
    7b5e:	5d 93       	st	X+, r21
    7b60:	6d 93       	st	X+, r22
    7b62:	7c 93       	st	X, r23
    7b64:	13 97       	sbiw	r26, 0x03	; 3
	model->YawAngularVelocityRadsPerSecond(this->YawAngularVelocityRadsPerSecond);
    7b66:	dc 01       	movw	r26, r24
    7b68:	a7 52       	subi	r26, 0x27	; 39
    7b6a:	bf 4f       	sbci	r27, 0xFF	; 255
    7b6c:	4d 91       	ld	r20, X+
    7b6e:	5d 91       	ld	r21, X+
    7b70:	6d 91       	ld	r22, X+
    7b72:	7c 91       	ld	r23, X
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    7b74:	df 01       	movw	r26, r30
    7b76:	ae 51       	subi	r26, 0x1E	; 30
    7b78:	bf 4f       	sbci	r27, 0xFF	; 255
    7b7a:	4d 93       	st	X+, r20
    7b7c:	5d 93       	st	X+, r21
    7b7e:	6d 93       	st	X+, r22
    7b80:	7c 93       	st	X, r23
    7b82:	13 97       	sbiw	r26, 0x03	; 3
	model->RollAngularVelocityRadsPerSecond(this->RollAngularVelocityRadsPerSecond);
    7b84:	dc 01       	movw	r26, r24
    7b86:	af 51       	subi	r26, 0x1F	; 31
    7b88:	bf 4f       	sbci	r27, 0xFF	; 255
    7b8a:	4d 91       	ld	r20, X+
    7b8c:	5d 91       	ld	r21, X+
    7b8e:	6d 91       	ld	r22, X+
    7b90:	7c 91       	ld	r23, X
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    7b92:	df 01       	movw	r26, r30
    7b94:	a2 52       	subi	r26, 0x22	; 34
    7b96:	bf 4f       	sbci	r27, 0xFF	; 255
    7b98:	4d 93       	st	X+, r20
    7b9a:	5d 93       	st	X+, r21
    7b9c:	6d 93       	st	X+, r22
    7b9e:	7c 93       	st	X, r23
    7ba0:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake GPS data
//	model->XVelocityMetersPerSecond(this->XVelocityMetersPerSecond); //this is supposed to be 'output' data, not input.
//	model->YVelocityMetersPerSecond(this->YVelocityMetersPerSecond);
	//ZVelocity is derived from pressure changes. //model->ZVelocityMetersPerSecond(this->ZVelocityMetersPerSecond); 
	model->LatitudeDegrees(this->LatitudeDegrees);
    7ba2:	dc 01       	movw	r26, r24
    7ba4:	ab 53       	subi	r26, 0x3B	; 59
    7ba6:	bf 4f       	sbci	r27, 0xFF	; 255
    7ba8:	4d 91       	ld	r20, X+
    7baa:	5d 91       	ld	r21, X+
    7bac:	6d 91       	ld	r22, X+
    7bae:	7c 91       	ld	r23, X
			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						
    7bb0:	df 01       	movw	r26, r30
    7bb2:	ae 55       	subi	r26, 0x5E	; 94
    7bb4:	bf 4f       	sbci	r27, 0xFF	; 255
    7bb6:	4d 93       	st	X+, r20
    7bb8:	5d 93       	st	X+, r21
    7bba:	6d 93       	st	X+, r22
    7bbc:	7c 93       	st	X, r23
    7bbe:	13 97       	sbiw	r26, 0x03	; 3
	model->LongitudeDegrees(this->LongitudeDegrees);
    7bc0:	dc 01       	movw	r26, r24
    7bc2:	a7 53       	subi	r26, 0x37	; 55
    7bc4:	bf 4f       	sbci	r27, 0xFF	; 255
    7bc6:	4d 91       	ld	r20, X+
    7bc8:	5d 91       	ld	r21, X+
    7bca:	6d 91       	ld	r22, X+
    7bcc:	7c 91       	ld	r23, X

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
    7bce:	df 01       	movw	r26, r30
    7bd0:	aa 55       	subi	r26, 0x5A	; 90
    7bd2:	bf 4f       	sbci	r27, 0xFF	; 255
    7bd4:	4d 93       	st	X+, r20
    7bd6:	5d 93       	st	X+, r21
    7bd8:	6d 93       	st	X+, r22
    7bda:	7c 93       	st	X, r23
    7bdc:	13 97       	sbiw	r26, 0x03	; 3
	model->XEcefCm(this->XEcefCm);
    7bde:	dc 01       	movw	r26, r24
    7be0:	af 50       	subi	r26, 0x0F	; 15
    7be2:	bf 4f       	sbci	r27, 0xFF	; 255
    7be4:	4d 91       	ld	r20, X+
    7be6:	5d 91       	ld	r21, X+
    7be8:	6d 91       	ld	r22, X+
    7bea:	7c 91       	ld	r23, X
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    7bec:	df 01       	movw	r26, r30
    7bee:	a2 50       	subi	r26, 0x02	; 2
    7bf0:	bf 4f       	sbci	r27, 0xFF	; 255
    7bf2:	4d 93       	st	X+, r20
    7bf4:	5d 93       	st	X+, r21
    7bf6:	6d 93       	st	X+, r22
    7bf8:	7c 93       	st	X, r23
    7bfa:	13 97       	sbiw	r26, 0x03	; 3
	model->YEcefCm(this->YEcefCm);
    7bfc:	dc 01       	movw	r26, r24
    7bfe:	ab 50       	subi	r26, 0x0B	; 11
    7c00:	bf 4f       	sbci	r27, 0xFF	; 255
    7c02:	4d 91       	ld	r20, X+
    7c04:	5d 91       	ld	r21, X+
    7c06:	6d 91       	ld	r22, X+
    7c08:	7c 91       	ld	r23, X
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    7c0a:	df 01       	movw	r26, r30
    7c0c:	ae 5f       	subi	r26, 0xFE	; 254
    7c0e:	be 4f       	sbci	r27, 0xFE	; 254
    7c10:	4d 93       	st	X+, r20
    7c12:	5d 93       	st	X+, r21
    7c14:	6d 93       	st	X+, r22
    7c16:	7c 93       	st	X, r23
    7c18:	13 97       	sbiw	r26, 0x03	; 3
	model->ZEcefCm(this->ZEcefCm);
    7c1a:	dc 01       	movw	r26, r24
    7c1c:	a7 50       	subi	r26, 0x07	; 7
    7c1e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c20:	4d 91       	ld	r20, X+
    7c22:	5d 91       	ld	r21, X+
    7c24:	6d 91       	ld	r22, X+
    7c26:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    7c28:	df 01       	movw	r26, r30
    7c2a:	aa 5f       	subi	r26, 0xFA	; 250
    7c2c:	be 4f       	sbci	r27, 0xFE	; 254
    7c2e:	4d 93       	st	X+, r20
    7c30:	5d 93       	st	X+, r21
    7c32:	6d 93       	st	X+, r22
    7c34:	7c 93       	st	X, r23
    7c36:	13 97       	sbiw	r26, 0x03	; 3
		
	//Copy fake accelerometer data
	model->XAccelFrdMss(this->XAccelFrdMss);
    7c38:	dc 01       	movw	r26, r24
    7c3a:	a3 53       	subi	r26, 0x33	; 51
    7c3c:	bf 4f       	sbci	r27, 0xFF	; 255
    7c3e:	4d 91       	ld	r20, X+
    7c40:	5d 91       	ld	r21, X+
    7c42:	6d 91       	ld	r22, X+
    7c44:	7c 91       	ld	r23, X
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    7c46:	df 01       	movw	r26, r30
    7c48:	aa 51       	subi	r26, 0x1A	; 26
    7c4a:	bf 4f       	sbci	r27, 0xFF	; 255
    7c4c:	4d 93       	st	X+, r20
    7c4e:	5d 93       	st	X+, r21
    7c50:	6d 93       	st	X+, r22
    7c52:	7c 93       	st	X, r23
    7c54:	13 97       	sbiw	r26, 0x03	; 3
	model->YAccelFrdMss(this->YAccelFrdMss);
    7c56:	dc 01       	movw	r26, r24
    7c58:	af 52       	subi	r26, 0x2F	; 47
    7c5a:	bf 4f       	sbci	r27, 0xFF	; 255
    7c5c:	4d 91       	ld	r20, X+
    7c5e:	5d 91       	ld	r21, X+
    7c60:	6d 91       	ld	r22, X+
    7c62:	7c 91       	ld	r23, X

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    7c64:	df 01       	movw	r26, r30
    7c66:	a6 51       	subi	r26, 0x16	; 22
    7c68:	bf 4f       	sbci	r27, 0xFF	; 255
    7c6a:	4d 93       	st	X+, r20
    7c6c:	5d 93       	st	X+, r21
    7c6e:	6d 93       	st	X+, r22
    7c70:	7c 93       	st	X, r23
    7c72:	13 97       	sbiw	r26, 0x03	; 3
	model->ZAccelFrdMss(this->ZAccelFrdMss);
    7c74:	dc 01       	movw	r26, r24
    7c76:	ab 52       	subi	r26, 0x2B	; 43
    7c78:	bf 4f       	sbci	r27, 0xFF	; 255
    7c7a:	4d 91       	ld	r20, X+
    7c7c:	5d 91       	ld	r21, X+
    7c7e:	6d 91       	ld	r22, X+
    7c80:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    7c82:	df 01       	movw	r26, r30
    7c84:	a2 51       	subi	r26, 0x12	; 18
    7c86:	bf 4f       	sbci	r27, 0xFF	; 255
    7c88:	4d 93       	st	X+, r20
    7c8a:	5d 93       	st	X+, r21
    7c8c:	6d 93       	st	X+, r22
    7c8e:	7c 93       	st	X, r23
    7c90:	13 97       	sbiw	r26, 0x03	; 3
	model->XVEcefCms(this->XVEcefCms);
    7c92:	dc 01       	movw	r26, r24
    7c94:	a3 50       	subi	r26, 0x03	; 3
    7c96:	bf 4f       	sbci	r27, 0xFF	; 255
    7c98:	4d 91       	ld	r20, X+
    7c9a:	5d 91       	ld	r21, X+
    7c9c:	6d 91       	ld	r22, X+
    7c9e:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    7ca0:	df 01       	movw	r26, r30
    7ca2:	a6 5f       	subi	r26, 0xF6	; 246
    7ca4:	be 4f       	sbci	r27, 0xFE	; 254
    7ca6:	4d 93       	st	X+, r20
    7ca8:	5d 93       	st	X+, r21
    7caa:	6d 93       	st	X+, r22
    7cac:	7c 93       	st	X, r23
    7cae:	13 97       	sbiw	r26, 0x03	; 3
	model->YVEcefCms(this->YVEcefCms);
    7cb0:	dc 01       	movw	r26, r24
    7cb2:	af 5f       	subi	r26, 0xFF	; 255
    7cb4:	be 4f       	sbci	r27, 0xFE	; 254
    7cb6:	4d 91       	ld	r20, X+
    7cb8:	5d 91       	ld	r21, X+
    7cba:	6d 91       	ld	r22, X+
    7cbc:	7c 91       	ld	r23, X
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    7cbe:	df 01       	movw	r26, r30
    7cc0:	a2 5f       	subi	r26, 0xF2	; 242
    7cc2:	be 4f       	sbci	r27, 0xFE	; 254
    7cc4:	4d 93       	st	X+, r20
    7cc6:	5d 93       	st	X+, r21
    7cc8:	6d 93       	st	X+, r22
    7cca:	7c 93       	st	X, r23
    7ccc:	13 97       	sbiw	r26, 0x03	; 3
	model->ZVEcefCms(this->ZVEcefCms);
    7cce:	dc 01       	movw	r26, r24
    7cd0:	ab 5f       	subi	r26, 0xFB	; 251
    7cd2:	be 4f       	sbci	r27, 0xFE	; 254
    7cd4:	4d 91       	ld	r20, X+
    7cd6:	5d 91       	ld	r21, X+
    7cd8:	6d 91       	ld	r22, X+
    7cda:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    7cdc:	df 01       	movw	r26, r30
    7cde:	ae 5e       	subi	r26, 0xEE	; 238
    7ce0:	be 4f       	sbci	r27, 0xFE	; 254
    7ce2:	4d 93       	st	X+, r20
    7ce4:	5d 93       	st	X+, r21
    7ce6:	6d 93       	st	X+, r22
    7ce8:	7c 93       	st	X, r23
    7cea:	13 97       	sbiw	r26, 0x03	; 3

	//copy fake mag data
	model->XMagFrd(this->XMagFrd);
    7cec:	dc 01       	movw	r26, r24
    7cee:	ab 51       	subi	r26, 0x1B	; 27
    7cf0:	bf 4f       	sbci	r27, 0xFF	; 255
    7cf2:	4d 91       	ld	r20, X+
    7cf4:	5d 91       	ld	r21, X+
    7cf6:	6d 91       	ld	r22, X+
    7cf8:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    7cfa:	df 01       	movw	r26, r30
    7cfc:	ae 50       	subi	r26, 0x0E	; 14
    7cfe:	bf 4f       	sbci	r27, 0xFF	; 255
    7d00:	4d 93       	st	X+, r20
    7d02:	5d 93       	st	X+, r21
    7d04:	6d 93       	st	X+, r22
    7d06:	7c 93       	st	X, r23
    7d08:	13 97       	sbiw	r26, 0x03	; 3
	model->YMagFrd(this->YMagFrd);
    7d0a:	dc 01       	movw	r26, r24
    7d0c:	a7 51       	subi	r26, 0x17	; 23
    7d0e:	bf 4f       	sbci	r27, 0xFF	; 255
    7d10:	4d 91       	ld	r20, X+
    7d12:	5d 91       	ld	r21, X+
    7d14:	6d 91       	ld	r22, X+
    7d16:	7c 91       	ld	r23, X

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    7d18:	df 01       	movw	r26, r30
    7d1a:	aa 50       	subi	r26, 0x0A	; 10
    7d1c:	bf 4f       	sbci	r27, 0xFF	; 255
    7d1e:	4d 93       	st	X+, r20
    7d20:	5d 93       	st	X+, r21
    7d22:	6d 93       	st	X+, r22
    7d24:	7c 93       	st	X, r23
    7d26:	13 97       	sbiw	r26, 0x03	; 3
	model->ZMagFrd(this->ZMagFrd);
    7d28:	dc 01       	movw	r26, r24
    7d2a:	a3 51       	subi	r26, 0x13	; 19
    7d2c:	bf 4f       	sbci	r27, 0xFF	; 255
    7d2e:	4d 91       	ld	r20, X+
    7d30:	5d 91       	ld	r21, X+
    7d32:	6d 91       	ld	r22, X+
    7d34:	7c 91       	ld	r23, X

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    7d36:	df 01       	movw	r26, r30
    7d38:	a6 50       	subi	r26, 0x06	; 6
    7d3a:	bf 4f       	sbci	r27, 0xFF	; 255
    7d3c:	4d 93       	st	X+, r20
    7d3e:	5d 93       	st	X+, r21
    7d40:	6d 93       	st	X+, r22
    7d42:	7c 93       	st	X, r23
    7d44:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake barometer data.
	model->PressureMillibars(this->PressureMillibars);	
    7d46:	dc 01       	movw	r26, r24
    7d48:	a7 5f       	subi	r26, 0xF7	; 247
    7d4a:	be 4f       	sbci	r27, 0xFE	; 254
    7d4c:	4d 91       	ld	r20, X+
    7d4e:	5d 91       	ld	r21, X+
    7d50:	6d 91       	ld	r22, X+
    7d52:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    7d54:	df 01       	movw	r26, r30
    7d56:	aa 5e       	subi	r26, 0xEA	; 234
    7d58:	be 4f       	sbci	r27, 0xFE	; 254
    7d5a:	4d 93       	st	X+, r20
    7d5c:	5d 93       	st	X+, r21
    7d5e:	6d 93       	st	X+, r22
    7d60:	7c 93       	st	X, r23
    7d62:	13 97       	sbiw	r26, 0x03	; 3


	model->ReferenceXNEDLocalFrameCm(this->XRefSetpoint);
    7d64:	dc 01       	movw	r26, r24
    7d66:	a3 5f       	subi	r26, 0xF3	; 243
    7d68:	be 4f       	sbci	r27, 0xFE	; 254
    7d6a:	4d 91       	ld	r20, X+
    7d6c:	5d 91       	ld	r21, X+
    7d6e:	6d 91       	ld	r22, X+
    7d70:	7c 91       	ld	r23, X
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    7d72:	46 a3       	std	Z+38, r20	; 0x26
    7d74:	57 a3       	std	Z+39, r21	; 0x27
    7d76:	60 a7       	std	Z+40, r22	; 0x28
    7d78:	71 a7       	std	Z+41, r23	; 0x29
	model->ReferenceYNEDLocalFrameCm(this->YRefSetpoint);
    7d7a:	dc 01       	movw	r26, r24
    7d7c:	af 5e       	subi	r26, 0xEF	; 239
    7d7e:	be 4f       	sbci	r27, 0xFE	; 254
    7d80:	4d 91       	ld	r20, X+
    7d82:	5d 91       	ld	r21, X+
    7d84:	6d 91       	ld	r22, X+
    7d86:	7c 91       	ld	r23, X

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    7d88:	df 01       	movw	r26, r30
    7d8a:	ae 5a       	subi	r26, 0xAE	; 174
    7d8c:	bf 4f       	sbci	r27, 0xFF	; 255
    7d8e:	4d 93       	st	X+, r20
    7d90:	5d 93       	st	X+, r21
    7d92:	6d 93       	st	X+, r22
    7d94:	7c 93       	st	X, r23
    7d96:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceZNEDLocalFrameCm(this->ZRefSetpoint);
    7d98:	dc 01       	movw	r26, r24
    7d9a:	ab 5e       	subi	r26, 0xEB	; 235
    7d9c:	be 4f       	sbci	r27, 0xFE	; 254
    7d9e:	4d 91       	ld	r20, X+
    7da0:	5d 91       	ld	r21, X+
    7da2:	6d 91       	ld	r22, X+
    7da4:	7c 91       	ld	r23, X
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    7da6:	df 01       	movw	r26, r30
    7da8:	ae 57       	subi	r26, 0x7E	; 126
    7daa:	bf 4f       	sbci	r27, 0xFF	; 255
    7dac:	4d 93       	st	X+, r20
    7dae:	5d 93       	st	X+, r21
    7db0:	6d 93       	st	X+, r22
    7db2:	7c 93       	st	X, r23
    7db4:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceMagYawRads(this->YawRefSetpoint);
    7db6:	dc 01       	movw	r26, r24
    7db8:	a7 5e       	subi	r26, 0xE7	; 231
    7dba:	be 4f       	sbci	r27, 0xFE	; 254
    7dbc:	8d 91       	ld	r24, X+
    7dbe:	9d 91       	ld	r25, X+
    7dc0:	0d 90       	ld	r0, X+
    7dc2:	bc 91       	ld	r27, X
    7dc4:	a0 2d       	mov	r26, r0
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    7dc6:	86 83       	std	Z+6, r24	; 0x06
    7dc8:	97 83       	std	Z+7, r25	; 0x07
    7dca:	a0 87       	std	Z+8, r26	; 0x08
    7dcc:	b1 87       	std	Z+9, r27	; 0x09
    7dce:	08 95       	ret

00007dd0 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>:
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;//.08f;//.05f;//.15;//.14f;//.08;//.08;*/
float AHRS::ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .001f;
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;

void AHRS::scaleAndAdjust(float vectorToAdjust[3], float vectorToScale[3], float scalerValue, float (&outputVector)[3])
{
    7dd0:	8f 92       	push	r8
    7dd2:	9f 92       	push	r9
    7dd4:	af 92       	push	r10
    7dd6:	bf 92       	push	r11
    7dd8:	cf 92       	push	r12
    7dda:	df 92       	push	r13
    7ddc:	ef 92       	push	r14
    7dde:	ff 92       	push	r15
    7de0:	0f 93       	push	r16
    7de2:	1f 93       	push	r17
    7de4:	cf 93       	push	r28
    7de6:	df 93       	push	r29
    7de8:	eb 01       	movw	r28, r22
    7dea:	6a 01       	movw	r12, r20
    7dec:	48 01       	movw	r8, r16
    7dee:	59 01       	movw	r10, r18
	outputVector[0] = vectorToAdjust[0] - scalerValue * vectorToScale[0];
    7df0:	fa 01       	movw	r30, r20
    7df2:	20 81       	ld	r18, Z
    7df4:	31 81       	ldd	r19, Z+1	; 0x01
    7df6:	42 81       	ldd	r20, Z+2	; 0x02
    7df8:	53 81       	ldd	r21, Z+3	; 0x03
    7dfa:	c5 01       	movw	r24, r10
    7dfc:	b4 01       	movw	r22, r8
    7dfe:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    7e02:	9b 01       	movw	r18, r22
    7e04:	ac 01       	movw	r20, r24
    7e06:	68 81       	ld	r22, Y
    7e08:	79 81       	ldd	r23, Y+1	; 0x01
    7e0a:	8a 81       	ldd	r24, Y+2	; 0x02
    7e0c:	9b 81       	ldd	r25, Y+3	; 0x03
    7e0e:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    7e12:	f7 01       	movw	r30, r14
    7e14:	60 83       	st	Z, r22
    7e16:	71 83       	std	Z+1, r23	; 0x01
    7e18:	82 83       	std	Z+2, r24	; 0x02
    7e1a:	93 83       	std	Z+3, r25	; 0x03
	outputVector[1] = vectorToAdjust[1] - scalerValue * vectorToScale[1];
    7e1c:	f6 01       	movw	r30, r12
    7e1e:	24 81       	ldd	r18, Z+4	; 0x04
    7e20:	35 81       	ldd	r19, Z+5	; 0x05
    7e22:	46 81       	ldd	r20, Z+6	; 0x06
    7e24:	57 81       	ldd	r21, Z+7	; 0x07
    7e26:	c5 01       	movw	r24, r10
    7e28:	b4 01       	movw	r22, r8
    7e2a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    7e2e:	9b 01       	movw	r18, r22
    7e30:	ac 01       	movw	r20, r24
    7e32:	6c 81       	ldd	r22, Y+4	; 0x04
    7e34:	7d 81       	ldd	r23, Y+5	; 0x05
    7e36:	8e 81       	ldd	r24, Y+6	; 0x06
    7e38:	9f 81       	ldd	r25, Y+7	; 0x07
    7e3a:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    7e3e:	f7 01       	movw	r30, r14
    7e40:	64 83       	std	Z+4, r22	; 0x04
    7e42:	75 83       	std	Z+5, r23	; 0x05
    7e44:	86 83       	std	Z+6, r24	; 0x06
    7e46:	97 83       	std	Z+7, r25	; 0x07
	outputVector[2] = vectorToAdjust[2] - scalerValue * vectorToScale[2];	
    7e48:	f6 01       	movw	r30, r12
    7e4a:	20 85       	ldd	r18, Z+8	; 0x08
    7e4c:	31 85       	ldd	r19, Z+9	; 0x09
    7e4e:	42 85       	ldd	r20, Z+10	; 0x0a
    7e50:	53 85       	ldd	r21, Z+11	; 0x0b
    7e52:	c5 01       	movw	r24, r10
    7e54:	b4 01       	movw	r22, r8
    7e56:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    7e5a:	9b 01       	movw	r18, r22
    7e5c:	ac 01       	movw	r20, r24
    7e5e:	68 85       	ldd	r22, Y+8	; 0x08
    7e60:	79 85       	ldd	r23, Y+9	; 0x09
    7e62:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e64:	9b 85       	ldd	r25, Y+11	; 0x0b
    7e66:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    7e6a:	f7 01       	movw	r30, r14
    7e6c:	60 87       	std	Z+8, r22	; 0x08
    7e6e:	71 87       	std	Z+9, r23	; 0x09
    7e70:	82 87       	std	Z+10, r24	; 0x0a
    7e72:	93 87       	std	Z+11, r25	; 0x0b
}
    7e74:	df 91       	pop	r29
    7e76:	cf 91       	pop	r28
    7e78:	1f 91       	pop	r17
    7e7a:	0f 91       	pop	r16
    7e7c:	ff 90       	pop	r15
    7e7e:	ef 90       	pop	r14
    7e80:	df 90       	pop	r13
    7e82:	cf 90       	pop	r12
    7e84:	bf 90       	pop	r11
    7e86:	af 90       	pop	r10
    7e88:	9f 90       	pop	r9
    7e8a:	8f 90       	pop	r8
    7e8c:	08 95       	ret

00007e8e <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>:


void AHRS::orthonormalizeDcm() 
{
    7e8e:	6f 92       	push	r6
    7e90:	7f 92       	push	r7
    7e92:	8f 92       	push	r8
    7e94:	9f 92       	push	r9
    7e96:	af 92       	push	r10
    7e98:	bf 92       	push	r11
    7e9a:	cf 92       	push	r12
    7e9c:	df 92       	push	r13
    7e9e:	ef 92       	push	r14
    7ea0:	ff 92       	push	r15
    7ea2:	0f 93       	push	r16
    7ea4:	1f 93       	push	r17
    7ea6:	cf 93       	push	r28
    7ea8:	df 93       	push	r29
    7eaa:	5c 01       	movw	r10, r24
	/**
	 * The dot product of two orthonormal vectors should be 0 (because cos(90) = 0). So this
	 * gives us an error of how far from orthonormal the vectors are. It's a measure
	 * of how much X and Y are rotated towards each other. 
	 */
	float error = MatrixUtil::DotProduct(dcm[0], dcm[1]);
    7eac:	ec 01       	movw	r28, r24
    7eae:	c4 5b       	subi	r28, 0xB4	; 180
    7eb0:	df 4f       	sbci	r29, 0xFF	; 255
    7eb2:	6c 01       	movw	r12, r24
    7eb4:	80 e4       	ldi	r24, 0x40	; 64
    7eb6:	c8 0e       	add	r12, r24
    7eb8:	d1 1c       	adc	r13, r1
    7eba:	be 01       	movw	r22, r28
    7ebc:	c6 01       	movw	r24, r12
    7ebe:	0e 94 a5 69 	call	0xd34a	; 0xd34a <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>
	
	/**
	 * Scale and adjust the two vectors involved in calculating the error to bring them 
	 * 'closer' to each other (more orthonormal)
	 */
	scaleAndAdjust(dcm[0], dcm[1], (error/2), dcm[0]);
    7ec2:	20 e0       	ldi	r18, 0x00	; 0
    7ec4:	30 e0       	ldi	r19, 0x00	; 0
    7ec6:	40 e0       	ldi	r20, 0x00	; 0
    7ec8:	5f e3       	ldi	r21, 0x3F	; 63
    7eca:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    7ece:	66 2e       	mov	r6, r22
    7ed0:	77 2e       	mov	r7, r23
    7ed2:	88 2e       	mov	r8, r24
    7ed4:	99 2e       	mov	r9, r25
    7ed6:	76 01       	movw	r14, r12
    7ed8:	98 2f       	mov	r25, r24
    7eda:	06 2d       	mov	r16, r6
    7edc:	17 2d       	mov	r17, r7
    7ede:	29 2f       	mov	r18, r25
    7ee0:	39 2d       	mov	r19, r9
    7ee2:	ae 01       	movw	r20, r28
    7ee4:	b6 01       	movw	r22, r12
    7ee6:	c5 01       	movw	r24, r10
    7ee8:	0e 94 e8 3e 	call	0x7dd0	; 0x7dd0 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	scaleAndAdjust(dcm[1], dcm[0], (error/2), dcm[1]);
    7eec:	7e 01       	movw	r14, r28
    7eee:	28 2d       	mov	r18, r8
    7ef0:	39 2d       	mov	r19, r9
    7ef2:	a6 01       	movw	r20, r12
    7ef4:	be 01       	movw	r22, r28
    7ef6:	c5 01       	movw	r24, r10
    7ef8:	0e 94 e8 3e 	call	0x7dd0	; 0x7dd0 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	
	//The remaining vector will become the cross product of the other two vectors
	MatrixUtil::CrossProduct(dcm[0], dcm[1], dcm[2]);
    7efc:	88 e5       	ldi	r24, 0x58	; 88
    7efe:	a8 0e       	add	r10, r24
    7f00:	b1 1c       	adc	r11, r1
    7f02:	a5 01       	movw	r20, r10
    7f04:	be 01       	movw	r22, r28
    7f06:	c6 01       	movw	r24, r12
    7f08:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	
	//Normalize the matrix to ensure that the vector's magnitudes = 1
	MatrixUtil::Normalize(dcm[0]);
    7f0c:	c6 01       	movw	r24, r12
    7f0e:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[1]);
    7f12:	ce 01       	movw	r24, r28
    7f14:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[2]);
    7f18:	c5 01       	movw	r24, r10
    7f1a:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
}
    7f1e:	df 91       	pop	r29
    7f20:	cf 91       	pop	r28
    7f22:	1f 91       	pop	r17
    7f24:	0f 91       	pop	r16
    7f26:	ff 90       	pop	r15
    7f28:	ef 90       	pop	r14
    7f2a:	df 90       	pop	r13
    7f2c:	cf 90       	pop	r12
    7f2e:	bf 90       	pop	r11
    7f30:	af 90       	pop	r10
    7f32:	9f 90       	pop	r9
    7f34:	8f 90       	pop	r8
    7f36:	7f 90       	pop	r7
    7f38:	6f 90       	pop	r6
    7f3a:	08 95       	ret

00007f3c <_ZN10helicopter10navigation4AHRS6updateEfffffffff>:


void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
	float frdGyroXRs, float frdGyroYRs, float frdGyroZRs,
	float frdMagX, float frdMagY, float frdMagZ)
{
    7f3c:	2f 92       	push	r2
    7f3e:	3f 92       	push	r3
    7f40:	4f 92       	push	r4
    7f42:	5f 92       	push	r5
    7f44:	6f 92       	push	r6
    7f46:	7f 92       	push	r7
    7f48:	8f 92       	push	r8
    7f4a:	9f 92       	push	r9
    7f4c:	af 92       	push	r10
    7f4e:	bf 92       	push	r11
    7f50:	cf 92       	push	r12
    7f52:	df 92       	push	r13
    7f54:	ef 92       	push	r14
    7f56:	ff 92       	push	r15
    7f58:	0f 93       	push	r16
    7f5a:	1f 93       	push	r17
    7f5c:	cf 93       	push	r28
    7f5e:	df 93       	push	r29
    7f60:	cd b7       	in	r28, 0x3d	; 61
    7f62:	de b7       	in	r29, 0x3e	; 62
    7f64:	ce 57       	subi	r28, 0x7E	; 126
    7f66:	d1 09       	sbc	r29, r1
    7f68:	0f b6       	in	r0, 0x3f	; 63
    7f6a:	f8 94       	cli
    7f6c:	de bf       	out	0x3e, r29	; 62
    7f6e:	0f be       	out	0x3f, r0	; 63
    7f70:	cd bf       	out	0x3d, r28	; 61
    7f72:	2c 01       	movw	r4, r24
    7f74:	e1 96       	adiw	r28, 0x31	; 49
    7f76:	8c ae       	std	Y+60, r8	; 0x3c
    7f78:	9d ae       	std	Y+61, r9	; 0x3d
    7f7a:	ae ae       	std	Y+62, r10	; 0x3e
    7f7c:	bf ae       	std	Y+63, r11	; 0x3f
    7f7e:	e1 97       	sbiw	r28, 0x31	; 49
	float accelerometerVector[3] = {frdAccXMss, frdAccYMss, frdAccZMss};
    7f80:	a5 96       	adiw	r28, 0x25	; 37
    7f82:	4c af       	std	Y+60, r20	; 0x3c
    7f84:	5d af       	std	Y+61, r21	; 0x3d
    7f86:	6e af       	std	Y+62, r22	; 0x3e
    7f88:	7f af       	std	Y+63, r23	; 0x3f
    7f8a:	a5 97       	sbiw	r28, 0x25	; 37
    7f8c:	a9 96       	adiw	r28, 0x29	; 41
    7f8e:	0c af       	std	Y+60, r16	; 0x3c
    7f90:	1d af       	std	Y+61, r17	; 0x3d
    7f92:	2e af       	std	Y+62, r18	; 0x3e
    7f94:	3f af       	std	Y+63, r19	; 0x3f
    7f96:	a9 97       	sbiw	r28, 0x29	; 41
    7f98:	ad 96       	adiw	r28, 0x2d	; 45
    7f9a:	cc ae       	std	Y+60, r12	; 0x3c
    7f9c:	dd ae       	std	Y+61, r13	; 0x3d
    7f9e:	ee ae       	std	Y+62, r14	; 0x3e
    7fa0:	ff ae       	std	Y+63, r15	; 0x3f
    7fa2:	ad 97       	sbiw	r28, 0x2d	; 45
	float magnetometerVector[3] = {frdMagX, frdMagY, frdMagZ};
    7fa4:	c4 56       	subi	r28, 0x64	; 100
    7fa6:	df 4f       	sbci	r29, 0xFF	; 255
    7fa8:	88 81       	ld	r24, Y
    7faa:	99 81       	ldd	r25, Y+1	; 0x01
    7fac:	aa 81       	ldd	r26, Y+2	; 0x02
    7fae:	bb 81       	ldd	r27, Y+3	; 0x03
    7fb0:	cc 59       	subi	r28, 0x9C	; 156
    7fb2:	d0 40       	sbci	r29, 0x00	; 0
    7fb4:	69 96       	adiw	r28, 0x19	; 25
    7fb6:	8c af       	std	Y+60, r24	; 0x3c
    7fb8:	9d af       	std	Y+61, r25	; 0x3d
    7fba:	ae af       	std	Y+62, r26	; 0x3e
    7fbc:	bf af       	std	Y+63, r27	; 0x3f
    7fbe:	69 97       	sbiw	r28, 0x19	; 25
    7fc0:	c0 56       	subi	r28, 0x60	; 96
    7fc2:	df 4f       	sbci	r29, 0xFF	; 255
    7fc4:	88 81       	ld	r24, Y
    7fc6:	99 81       	ldd	r25, Y+1	; 0x01
    7fc8:	aa 81       	ldd	r26, Y+2	; 0x02
    7fca:	bb 81       	ldd	r27, Y+3	; 0x03
    7fcc:	c0 5a       	subi	r28, 0xA0	; 160
    7fce:	d0 40       	sbci	r29, 0x00	; 0
    7fd0:	6d 96       	adiw	r28, 0x1d	; 29
    7fd2:	8c af       	std	Y+60, r24	; 0x3c
    7fd4:	9d af       	std	Y+61, r25	; 0x3d
    7fd6:	ae af       	std	Y+62, r26	; 0x3e
    7fd8:	bf af       	std	Y+63, r27	; 0x3f
    7fda:	6d 97       	sbiw	r28, 0x1d	; 29
    7fdc:	cc 55       	subi	r28, 0x5C	; 92
    7fde:	df 4f       	sbci	r29, 0xFF	; 255
    7fe0:	88 81       	ld	r24, Y
    7fe2:	99 81       	ldd	r25, Y+1	; 0x01
    7fe4:	aa 81       	ldd	r26, Y+2	; 0x02
    7fe6:	bb 81       	ldd	r27, Y+3	; 0x03
    7fe8:	c4 5a       	subi	r28, 0xA4	; 164
    7fea:	d0 40       	sbci	r29, 0x00	; 0
    7fec:	a1 96       	adiw	r28, 0x21	; 33
    7fee:	8c af       	std	Y+60, r24	; 0x3c
    7ff0:	9d af       	std	Y+61, r25	; 0x3d
    7ff2:	ae af       	std	Y+62, r26	; 0x3e
    7ff4:	bf af       	std	Y+63, r27	; 0x3f
    7ff6:	a1 97       	sbiw	r28, 0x21	; 33
		
	float accelerometerAngularDisplacement[3] = {0};
    7ff8:	7e 01       	movw	r14, r28
    7ffa:	89 e4       	ldi	r24, 0x49	; 73
    7ffc:	e8 0e       	add	r14, r24
    7ffe:	f1 1c       	adc	r15, r1
    8000:	0f 2e       	mov	r0, r31
    8002:	fc e0       	ldi	r31, 0x0C	; 12
    8004:	df 2e       	mov	r13, r31
    8006:	f0 2d       	mov	r31, r0
    8008:	d7 01       	movw	r26, r14
    800a:	ed 2d       	mov	r30, r13
    800c:	1d 92       	st	X+, r1
    800e:	ea 95       	dec	r30
    8010:	e9 f7       	brne	.-6      	; 0x800c <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xd0>
	float magnetometerAngularDisplacement[3] = {0};
    8012:	5e 01       	movw	r10, r28
    8014:	fd e3       	ldi	r31, 0x3D	; 61
    8016:	af 0e       	add	r10, r31
    8018:	b1 1c       	adc	r11, r1
    801a:	d5 01       	movw	r26, r10
    801c:	ed 2d       	mov	r30, r13
    801e:	1d 92       	st	X+, r1
    8020:	ea 95       	dec	r30
    8022:	e9 f7       	brne	.-6      	; 0x801e <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xe2>
		
	//Scale the gyro value by the time interval to get the angle in rads.
	float gyroscopeAngularDisplacement[3] = { frdGyroXRs * gyroTimeInterval, 
												frdGyroYRs * gyroTimeInterval, 
												frdGyroZRs * gyroTimeInterval};	
    8024:	d2 01       	movw	r26, r4
    8026:	6d 90       	ld	r6, X+
    8028:	7d 90       	ld	r7, X+
    802a:	8d 90       	ld	r8, X+
    802c:	9c 90       	ld	r9, X
    802e:	e1 96       	adiw	r28, 0x31	; 49
    8030:	2c ad       	ldd	r18, Y+60	; 0x3c
    8032:	3d ad       	ldd	r19, Y+61	; 0x3d
    8034:	4e ad       	ldd	r20, Y+62	; 0x3e
    8036:	5f ad       	ldd	r21, Y+63	; 0x3f
    8038:	e1 97       	sbiw	r28, 0x31	; 49
    803a:	c4 01       	movw	r24, r8
    803c:	b3 01       	movw	r22, r6
    803e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    8042:	69 ab       	std	Y+49, r22	; 0x31
    8044:	7a ab       	std	Y+50, r23	; 0x32
    8046:	8b ab       	std	Y+51, r24	; 0x33
    8048:	9c ab       	std	Y+52, r25	; 0x34
    804a:	cc 56       	subi	r28, 0x6C	; 108
    804c:	df 4f       	sbci	r29, 0xFF	; 255
    804e:	28 81       	ld	r18, Y
    8050:	39 81       	ldd	r19, Y+1	; 0x01
    8052:	4a 81       	ldd	r20, Y+2	; 0x02
    8054:	5b 81       	ldd	r21, Y+3	; 0x03
    8056:	c4 59       	subi	r28, 0x94	; 148
    8058:	d0 40       	sbci	r29, 0x00	; 0
    805a:	c4 01       	movw	r24, r8
    805c:	b3 01       	movw	r22, r6
    805e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    8062:	6d ab       	std	Y+53, r22	; 0x35
    8064:	7e ab       	std	Y+54, r23	; 0x36
    8066:	8f ab       	std	Y+55, r24	; 0x37
    8068:	98 af       	std	Y+56, r25	; 0x38
    806a:	c8 56       	subi	r28, 0x68	; 104
    806c:	df 4f       	sbci	r29, 0xFF	; 255
    806e:	28 81       	ld	r18, Y
    8070:	39 81       	ldd	r19, Y+1	; 0x01
    8072:	4a 81       	ldd	r20, Y+2	; 0x02
    8074:	5b 81       	ldd	r21, Y+3	; 0x03
    8076:	c8 59       	subi	r28, 0x98	; 152
    8078:	d0 40       	sbci	r29, 0x00	; 0
    807a:	c4 01       	movw	r24, r8
    807c:	b3 01       	movw	r22, r6
    807e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    8082:	69 af       	std	Y+57, r22	; 0x39
    8084:	7a af       	std	Y+58, r23	; 0x3a
    8086:	8b af       	std	Y+59, r24	; 0x3b
    8088:	9c af       	std	Y+60, r25	; 0x3c
												
	float angularDisplacementWeightedAverage [3] = {0};	
    808a:	3e 01       	movw	r6, r28
    808c:	b5 e2       	ldi	r27, 0x25	; 37
    808e:	6b 0e       	add	r6, r27
    8090:	71 1c       	adc	r7, r1
    8092:	f3 01       	movw	r30, r6
    8094:	8d 2d       	mov	r24, r13
    8096:	11 92       	st	Z+, r1
    8098:	8a 95       	dec	r24
    809a:	e9 f7       	brne	.-6      	; 0x8096 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x15a>
		
	float changeInVector [3] = {0};
    809c:	fe 01       	movw	r30, r28
    809e:	79 96       	adiw	r30, 0x19	; 25
    80a0:	df 01       	movw	r26, r30
    80a2:	8d 2d       	mov	r24, r13
    80a4:	1d 92       	st	X+, r1
    80a6:	8a 95       	dec	r24
    80a8:	e9 f7       	brne	.-6      	; 0x80a4 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x168>
		 
	//Normalize the accelerometer and magnetometer data so that their magnitudes = 1. The DCM matrix
	//is based on unit vectors (vectors with a magnitude of one)
	MatrixUtil::Normalize(accelerometerVector);
    80aa:	ce 01       	movw	r24, r28
    80ac:	8f 59       	subi	r24, 0x9F	; 159
    80ae:	9f 4f       	sbci	r25, 0xFF	; 255
    80b0:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(magnetometerVector);
    80b4:	ce 01       	movw	r24, r28
    80b6:	8b 5a       	subi	r24, 0xAB	; 171
    80b8:	9f 4f       	sbci	r25, 0xFF	; 255
    80ba:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	 * west vector, and the accelerometer vector to get a 'north facing' vector which is the corrected
	 * magnetometer vector.
	 *
	 * Taken from Starlino's January 20, 2012 post at http://www.starlino.com/dcm_tutorial.html 
	 */
	float westFacingVector[3] = {0};//since the acceleration vector is pointing down, this is actually an east facing vector in our case. 
    80be:	4e 01       	movw	r8, r28
    80c0:	9d e0       	ldi	r25, 0x0D	; 13
    80c2:	89 0e       	add	r8, r25
    80c4:	91 1c       	adc	r9, r1
    80c6:	d4 01       	movw	r26, r8
    80c8:	ed 2d       	mov	r30, r13
    80ca:	1d 92       	st	X+, r1
    80cc:	ea 95       	dec	r30
    80ce:	e9 f7       	brne	.-6      	; 0x80ca <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x18e>
	float correctedMagnetometerVector[3] = {0};
    80d0:	8e 01       	movw	r16, r28
    80d2:	0f 5f       	subi	r16, 0xFF	; 255
    80d4:	1f 4f       	sbci	r17, 0xFF	; 255
    80d6:	d8 01       	movw	r26, r16
    80d8:	1d 92       	st	X+, r1
    80da:	da 94       	dec	r13
    80dc:	e9 f7       	brne	.-6      	; 0x80d8 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x19c>
		
	
	MatrixUtil::CrossProduct(dcm[2], magnetometerVector, westFacingVector);	
    80de:	62 01       	movw	r12, r4
    80e0:	b8 e5       	ldi	r27, 0x58	; 88
    80e2:	cb 0e       	add	r12, r27
    80e4:	d1 1c       	adc	r13, r1
    80e6:	a4 01       	movw	r20, r8
    80e8:	be 01       	movw	r22, r28
    80ea:	6b 5a       	subi	r22, 0xAB	; 171
    80ec:	7f 4f       	sbci	r23, 0xFF	; 255
    80ee:	c6 01       	movw	r24, r12
    80f0:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(westFacingVector, dcm[2], correctedMagnetometerVector);
    80f4:	a8 01       	movw	r20, r16
    80f6:	b6 01       	movw	r22, r12
    80f8:	c4 01       	movw	r24, r8
    80fa:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	//Doing it this way prevents a 'gyro' effect where if you pitch up, it causes the gyro to affect the yaw, and then it 'stabilizes' back to normal value
	//This way prevents that. if you took the DCM value and cross proded that with the mag value, you would get the gyro affect. 
	/*MatrixUtil::CrossProduct(accelerometerVector, magnetometerVector, westFacingVector);
	MatrixUtil::CrossProduct(westFacingVector, accelerometerVector, correctedMagnetometerVector);	*/
	
	MatrixUtil::Normalize(correctedMagnetometerVector);
    80fe:	c8 01       	movw	r24, r16
    8100:	0e 94 87 66 	call	0xcd0e	; 0xcd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	//This gives the angular displacement that the helicopter has moved since the last
	//iteration.
	//d?a = dt wa = KB0 x (KB1A - KB0) - see http://www.starlino.com/dcm_tutorial.html for proof		
	/*MatrixUtil::CrossProduct(accelerometerVector, dcm[2], accelerometerAngularDisplacement);
	MatrixUtil::CrossProduct(correctedMagnetometerVector, dcm[0], magnetometerAngularDisplacement);*/
	MatrixUtil::CrossProduct(dcm[2], accelerometerVector, accelerometerAngularDisplacement);
    8104:	a7 01       	movw	r20, r14
    8106:	be 01       	movw	r22, r28
    8108:	6f 59       	subi	r22, 0x9F	; 159
    810a:	7f 4f       	sbci	r23, 0xFF	; 255
    810c:	c6 01       	movw	r24, r12
    810e:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(dcm[0], correctedMagnetometerVector, magnetometerAngularDisplacement);
    8112:	a5 01       	movw	r20, r10
    8114:	b8 01       	movw	r22, r16
    8116:	c2 01       	movw	r24, r4
    8118:	80 5c       	subi	r24, 0xC0	; 192
    811a:	9f 4f       	sbci	r25, 0xFF	; 255
    811c:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    8120:	80 91 0a 02 	lds	r24, 0x020A
    8124:	90 91 0b 02 	lds	r25, 0x020B
    8128:	a0 91 0c 02 	lds	r26, 0x020C
    812c:	b0 91 0d 02 	lds	r27, 0x020D
    8130:	e5 96       	adiw	r28, 0x35	; 53
    8132:	8c af       	std	Y+60, r24	; 0x3c
    8134:	9d af       	std	Y+61, r25	; 0x3d
    8136:	ae af       	std	Y+62, r26	; 0x3e
    8138:	bf af       	std	Y+63, r27	; 0x3f
    813a:	e5 97       	sbiw	r28, 0x35	; 53
    813c:	80 91 06 02 	lds	r24, 0x0206
    8140:	90 91 07 02 	lds	r25, 0x0207
    8144:	a0 91 08 02 	lds	r26, 0x0208
    8148:	b0 91 09 02 	lds	r27, 0x0209
    814c:	e9 96       	adiw	r28, 0x39	; 57
    814e:	8c af       	std	Y+60, r24	; 0x3c
    8150:	9d af       	std	Y+61, r25	; 0x3d
    8152:	ae af       	std	Y+62, r26	; 0x3e
    8154:	bf af       	std	Y+63, r27	; 0x3f
    8156:	e9 97       	sbiw	r28, 0x39	; 57
    8158:	20 e0       	ldi	r18, 0x00	; 0
    815a:	30 e0       	ldi	r19, 0x00	; 0
    815c:	40 e8       	ldi	r20, 0x80	; 128
    815e:	5f e3       	ldi	r21, 0x3F	; 63
    8160:	e5 96       	adiw	r28, 0x35	; 53
    8162:	6c ad       	ldd	r22, Y+60	; 0x3c
    8164:	7d ad       	ldd	r23, Y+61	; 0x3d
    8166:	8e ad       	ldd	r24, Y+62	; 0x3e
    8168:	9f ad       	ldd	r25, Y+63	; 0x3f
    816a:	e5 97       	sbiw	r28, 0x35	; 53
    816c:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    8170:	9b 01       	movw	r18, r22
    8172:	ac 01       	movw	r20, r24
    8174:	e9 96       	adiw	r28, 0x39	; 57
    8176:	6c ad       	ldd	r22, Y+60	; 0x3c
    8178:	7d ad       	ldd	r23, Y+61	; 0x3d
    817a:	8e ad       	ldd	r24, Y+62	; 0x3e
    817c:	9f ad       	ldd	r25, Y+63	; 0x3f
    817e:	e9 97       	sbiw	r28, 0x39	; 57
    8180:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    8184:	ec 96       	adiw	r28, 0x3c	; 60
    8186:	6f af       	std	Y+63, r22	; 0x3f
    8188:	ec 97       	sbiw	r28, 0x3c	; 60
    818a:	ed 96       	adiw	r28, 0x3d	; 61
    818c:	7f af       	std	Y+63, r23	; 0x3f
    818e:	ed 97       	sbiw	r28, 0x3d	; 61
    8190:	38 2e       	mov	r3, r24
    8192:	29 2e       	mov	r2, r25
    8194:	87 01       	movw	r16, r14
    8196:	6e 01       	movw	r12, r28
    8198:	91 e3       	ldi	r25, 0x31	; 49
    819a:	c9 0e       	add	r12, r25
    819c:	d1 1c       	adc	r13, r1
    819e:	af 96       	adiw	r28, 0x2f	; 47
    81a0:	bf ae       	std	Y+63, r11	; 0x3f
    81a2:	ae ae       	std	Y+62, r10	; 0x3e
    81a4:	af 97       	sbiw	r28, 0x2f	; 47
	return angle;
}



void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
    81a6:	d7 01       	movw	r26, r14
    81a8:	1c 96       	adiw	r26, 0x0c	; 12
    81aa:	eb 96       	adiw	r28, 0x3b	; 59
    81ac:	bf af       	std	Y+63, r27	; 0x3f
    81ae:	ae af       	std	Y+62, r26	; 0x3e
    81b0:	eb 97       	sbiw	r28, 0x3b	; 59
    81b2:	ef 96       	adiw	r28, 0x3f	; 63
    81b4:	5f ae       	std	Y+63, r5	; 0x3f
    81b6:	4e ae       	std	Y+62, r4	; 0x3e
    81b8:	ef 97       	sbiw	r28, 0x3f	; 63
    81ba:	26 01       	movw	r4, r12
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    81bc:	f8 01       	movw	r30, r16
    81be:	61 91       	ld	r22, Z+
    81c0:	71 91       	ld	r23, Z+
    81c2:	81 91       	ld	r24, Z+
    81c4:	91 91       	ld	r25, Z+
    81c6:	8f 01       	movw	r16, r30
		/**
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
    81c8:	d2 01       	movw	r26, r4
    81ca:	cd 90       	ld	r12, X+
    81cc:	dd 90       	ld	r13, X+
    81ce:	ed 90       	ld	r14, X+
    81d0:	fd 90       	ld	r15, X+
    81d2:	2d 01       	movw	r4, r26
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    81d4:	af 96       	adiw	r28, 0x2f	; 47
    81d6:	ee ad       	ldd	r30, Y+62	; 0x3e
    81d8:	ff ad       	ldd	r31, Y+63	; 0x3f
    81da:	af 97       	sbiw	r28, 0x2f	; 47
    81dc:	81 90       	ld	r8, Z+
    81de:	91 90       	ld	r9, Z+
    81e0:	a1 90       	ld	r10, Z+
    81e2:	b1 90       	ld	r11, Z+
    81e4:	af 96       	adiw	r28, 0x2f	; 47
    81e6:	ff af       	std	Y+63, r31	; 0x3f
    81e8:	ee af       	std	Y+62, r30	; 0x3e
    81ea:	af 97       	sbiw	r28, 0x2f	; 47
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    81ec:	e5 96       	adiw	r28, 0x35	; 53
    81ee:	2c ad       	ldd	r18, Y+60	; 0x3c
    81f0:	3d ad       	ldd	r19, Y+61	; 0x3d
    81f2:	4e ad       	ldd	r20, Y+62	; 0x3e
    81f4:	5f ad       	ldd	r21, Y+63	; 0x3f
    81f6:	e5 97       	sbiw	r28, 0x35	; 53
    81f8:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    81fc:	a7 01       	movw	r20, r14
    81fe:	96 01       	movw	r18, r12
    8200:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    8204:	6b 01       	movw	r12, r22
    8206:	7c 01       	movw	r14, r24
    8208:	e9 96       	adiw	r28, 0x39	; 57
    820a:	2c ad       	ldd	r18, Y+60	; 0x3c
    820c:	3d ad       	ldd	r19, Y+61	; 0x3d
    820e:	4e ad       	ldd	r20, Y+62	; 0x3e
    8210:	5f ad       	ldd	r21, Y+63	; 0x3f
    8212:	e9 97       	sbiw	r28, 0x39	; 57
    8214:	c5 01       	movw	r24, r10
    8216:	b4 01       	movw	r22, r8
    8218:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    821c:	9b 01       	movw	r18, r22
    821e:	ac 01       	movw	r20, r24
    8220:	c7 01       	movw	r24, r14
    8222:	b6 01       	movw	r22, r12
    8224:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    8228:	ec 96       	adiw	r28, 0x3c	; 60
    822a:	bf ad       	ldd	r27, Y+63	; 0x3f
    822c:	ec 97       	sbiw	r28, 0x3c	; 60
    822e:	ed 96       	adiw	r28, 0x3d	; 61
    8230:	af ad       	ldd	r26, Y+63	; 0x3f
    8232:	ed 97       	sbiw	r28, 0x3d	; 61
    8234:	2b 2f       	mov	r18, r27
    8236:	3a 2f       	mov	r19, r26
    8238:	43 2d       	mov	r20, r3
    823a:	52 2d       	mov	r21, r2
    823c:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    8240:	d3 01       	movw	r26, r6
    8242:	6d 93       	st	X+, r22
    8244:	7d 93       	st	X+, r23
    8246:	8d 93       	st	X+, r24
    8248:	9d 93       	st	X+, r25
    824a:	3d 01       	movw	r6, r26
	debug2 = accelerometerVector[1];
	debug3 = accelerometerVector[2];
	*/
	//Calculate the weighted average of the angular displacements to obtain the correction vector
	//to adjust the DCM.
	for (int i = 0; i < 3; i++)
    824c:	eb 96       	adiw	r28, 0x3b	; 59
    824e:	ee ad       	ldd	r30, Y+62	; 0x3e
    8250:	ff ad       	ldd	r31, Y+63	; 0x3f
    8252:	eb 97       	sbiw	r28, 0x3b	; 59
    8254:	0e 17       	cp	r16, r30
    8256:	1f 07       	cpc	r17, r31
    8258:	09 f0       	breq	.+2      	; 0x825c <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x320>
    825a:	b0 cf       	rjmp	.-160    	; 0x81bc <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x280>
    825c:	ef 96       	adiw	r28, 0x3f	; 63
    825e:	4e ac       	ldd	r4, Y+62	; 0x3e
    8260:	5f ac       	ldd	r5, Y+63	; 0x3f
    8262:	ef 97       	sbiw	r28, 0x3f	; 63
	return angle;
}



void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
    8264:	82 01       	movw	r16, r4
    8266:	00 5c       	subi	r16, 0xC0	; 192
    8268:	1f 4f       	sbci	r17, 0xFF	; 255
    826a:	e1 2c       	mov	r14, r1
    826c:	f1 2c       	mov	r15, r1
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
	{
		MatrixUtil::CrossProduct(angularDisplacementWeightedAverage, dcm[i], changeInVector);
    826e:	b7 01       	movw	r22, r14
    8270:	66 0f       	add	r22, r22
    8272:	77 1f       	adc	r23, r23
    8274:	6e 0d       	add	r22, r14
    8276:	7f 1d       	adc	r23, r15
    8278:	66 0f       	add	r22, r22
    827a:	77 1f       	adc	r23, r23
    827c:	66 0f       	add	r22, r22
    827e:	77 1f       	adc	r23, r23
    8280:	60 5c       	subi	r22, 0xC0	; 192
    8282:	7f 4f       	sbci	r23, 0xFF	; 255
    8284:	64 0d       	add	r22, r4
    8286:	75 1d       	adc	r23, r5
    8288:	ae 01       	movw	r20, r28
    828a:	47 5e       	subi	r20, 0xE7	; 231
    828c:	5f 4f       	sbci	r21, 0xFF	; 255
    828e:	ce 01       	movw	r24, r28
    8290:	85 96       	adiw	r24, 0x25	; 37
    8292:	0e 94 06 66 	call	0xcc0c	; 0xcc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		
		dcm[i][0] += changeInVector[0];
    8296:	29 8d       	ldd	r18, Y+25	; 0x19
    8298:	3a 8d       	ldd	r19, Y+26	; 0x1a
    829a:	4b 8d       	ldd	r20, Y+27	; 0x1b
    829c:	5c 8d       	ldd	r21, Y+28	; 0x1c
    829e:	d8 01       	movw	r26, r16
    82a0:	6d 91       	ld	r22, X+
    82a2:	7d 91       	ld	r23, X+
    82a4:	8d 91       	ld	r24, X+
    82a6:	9c 91       	ld	r25, X
    82a8:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    82ac:	f8 01       	movw	r30, r16
    82ae:	60 83       	st	Z, r22
    82b0:	71 83       	std	Z+1, r23	; 0x01
    82b2:	82 83       	std	Z+2, r24	; 0x02
    82b4:	93 83       	std	Z+3, r25	; 0x03
		dcm[i][1] += changeInVector[1];
    82b6:	2d 8d       	ldd	r18, Y+29	; 0x1d
    82b8:	3e 8d       	ldd	r19, Y+30	; 0x1e
    82ba:	4f 8d       	ldd	r20, Y+31	; 0x1f
    82bc:	58 a1       	ldd	r21, Y+32	; 0x20
    82be:	64 81       	ldd	r22, Z+4	; 0x04
    82c0:	75 81       	ldd	r23, Z+5	; 0x05
    82c2:	86 81       	ldd	r24, Z+6	; 0x06
    82c4:	97 81       	ldd	r25, Z+7	; 0x07
    82c6:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    82ca:	d8 01       	movw	r26, r16
    82cc:	14 96       	adiw	r26, 0x04	; 4
    82ce:	6d 93       	st	X+, r22
    82d0:	7d 93       	st	X+, r23
    82d2:	8d 93       	st	X+, r24
    82d4:	9c 93       	st	X, r25
    82d6:	17 97       	sbiw	r26, 0x07	; 7
		dcm[i][2] += changeInVector[2];
    82d8:	29 a1       	ldd	r18, Y+33	; 0x21
    82da:	3a a1       	ldd	r19, Y+34	; 0x22
    82dc:	4b a1       	ldd	r20, Y+35	; 0x23
    82de:	5c a1       	ldd	r21, Y+36	; 0x24
    82e0:	18 96       	adiw	r26, 0x08	; 8
    82e2:	6d 91       	ld	r22, X+
    82e4:	7d 91       	ld	r23, X+
    82e6:	8d 91       	ld	r24, X+
    82e8:	9c 91       	ld	r25, X
    82ea:	1b 97       	sbiw	r26, 0x0b	; 11
    82ec:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    82f0:	f8 01       	movw	r30, r16
    82f2:	60 87       	std	Z+8, r22	; 0x08
    82f4:	71 87       	std	Z+9, r23	; 0x09
    82f6:	82 87       	std	Z+10, r24	; 0x0a
    82f8:	93 87       	std	Z+11, r25	; 0x0b
	/**
	 * Adjust the dcm matrix by the calculated angular displacement. We adjust the DCM matrix by the averaged
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
    82fa:	ff ef       	ldi	r31, 0xFF	; 255
    82fc:	ef 1a       	sub	r14, r31
    82fe:	ff 0a       	sbc	r15, r31
    8300:	04 5f       	subi	r16, 0xF4	; 244
    8302:	1f 4f       	sbci	r17, 0xFF	; 255
    8304:	83 e0       	ldi	r24, 0x03	; 3
    8306:	e8 16       	cp	r14, r24
    8308:	f1 04       	cpc	r15, r1
    830a:	09 f0       	breq	.+2      	; 0x830e <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x3d2>
    830c:	b0 cf       	rjmp	.-160    	; 0x826e <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x332>
	}
	
	
	
	//Adjust the matrix to make it closer to orthonormal.
	orthonormalizeDcm();
    830e:	c2 01       	movw	r24, r4
    8310:	0e 94 47 3f 	call	0x7e8e	; 0x7e8e <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    8314:	f2 01       	movw	r30, r4
    8316:	e0 5c       	subi	r30, 0xC0	; 192
    8318:	ff 4f       	sbci	r31, 0xFF	; 255
    831a:	20 81       	ld	r18, Z
    831c:	31 81       	ldd	r19, Z+1	; 0x01
    831e:	42 81       	ldd	r20, Z+2	; 0x02
    8320:	53 81       	ldd	r21, Z+3	; 0x03
    8322:	f2 01       	movw	r30, r4
    8324:	e4 5b       	subi	r30, 0xB4	; 180
    8326:	ff 4f       	sbci	r31, 0xFF	; 255
    8328:	60 81       	ld	r22, Z
    832a:	71 81       	ldd	r23, Z+1	; 0x01
    832c:	82 81       	ldd	r24, Z+2	; 0x02
    832e:	93 81       	ldd	r25, Z+3	; 0x03
    8330:	0e 94 fb 6a 	call	0xd5f6	; 0xd5f6 <atan2>
    8334:	6b 01       	movw	r12, r22
    8336:	7c 01       	movw	r14, r24
	if (yawRads < 0)
    8338:	20 e0       	ldi	r18, 0x00	; 0
    833a:	30 e0       	ldi	r19, 0x00	; 0
    833c:	a9 01       	movw	r20, r18
    833e:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    8342:	88 23       	and	r24, r24
    8344:	44 f0       	brlt	.+16     	; 0x8356 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x41a>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    8346:	d2 01       	movw	r26, r4
    8348:	98 96       	adiw	r26, 0x28	; 40
    834a:	cd 92       	st	X+, r12
    834c:	dd 92       	st	X+, r13
    834e:	ed 92       	st	X+, r14
    8350:	fc 92       	st	X, r15
    8352:	9b 97       	sbiw	r26, 0x2b	; 43
    8354:	0d c0       	rjmp	.+26     	; 0x8370 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x434>
	if (yawRads < 0)
	{
		yawRads = 2.0f * M_PI + yawRads;
    8356:	2b ed       	ldi	r18, 0xDB	; 219
    8358:	3f e0       	ldi	r19, 0x0F	; 15
    835a:	49 ec       	ldi	r20, 0xC9	; 201
    835c:	50 e4       	ldi	r21, 0x40	; 64
    835e:	c7 01       	movw	r24, r14
    8360:	b6 01       	movw	r22, r12
    8362:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    8366:	f2 01       	movw	r30, r4
    8368:	60 a7       	std	Z+40, r22	; 0x28
    836a:	71 a7       	std	Z+41, r23	; 0x29
    836c:	82 a7       	std	Z+42, r24	; 0x2a
    836e:	93 a7       	std	Z+43, r25	; 0x2b
	}
	
	pitchRads = -asin(dcm[2][0]);
    8370:	f2 01       	movw	r30, r4
    8372:	e8 5a       	subi	r30, 0xA8	; 168
    8374:	ff 4f       	sbci	r31, 0xFF	; 255
    8376:	60 81       	ld	r22, Z
    8378:	71 81       	ldd	r23, Z+1	; 0x01
    837a:	82 81       	ldd	r24, Z+2	; 0x02
    837c:	93 81       	ldd	r25, Z+3	; 0x03
    837e:	0e 94 d5 6a 	call	0xd5aa	; 0xd5aa <asin>
    8382:	dc 01       	movw	r26, r24
    8384:	cb 01       	movw	r24, r22
    8386:	b0 58       	subi	r27, 0x80	; 128
    8388:	f2 01       	movw	r30, r4
    838a:	84 a7       	std	Z+44, r24	; 0x2c
    838c:	95 a7       	std	Z+45, r25	; 0x2d
    838e:	a6 a7       	std	Z+46, r26	; 0x2e
    8390:	b7 a7       	std	Z+47, r27	; 0x2f
	rollRads = atan2(dcm[2][1], dcm[2][2]);
    8392:	e0 5a       	subi	r30, 0xA0	; 160
    8394:	ff 4f       	sbci	r31, 0xFF	; 255
    8396:	20 81       	ld	r18, Z
    8398:	31 81       	ldd	r19, Z+1	; 0x01
    839a:	42 81       	ldd	r20, Z+2	; 0x02
    839c:	53 81       	ldd	r21, Z+3	; 0x03
    839e:	f2 01       	movw	r30, r4
    83a0:	e4 5a       	subi	r30, 0xA4	; 164
    83a2:	ff 4f       	sbci	r31, 0xFF	; 255
    83a4:	60 81       	ld	r22, Z
    83a6:	71 81       	ldd	r23, Z+1	; 0x01
    83a8:	82 81       	ldd	r24, Z+2	; 0x02
    83aa:	93 81       	ldd	r25, Z+3	; 0x03
    83ac:	0e 94 fb 6a 	call	0xd5f6	; 0xd5f6 <atan2>
    83b0:	d2 01       	movw	r26, r4
    83b2:	d0 96       	adiw	r26, 0x30	; 48
    83b4:	6d 93       	st	X+, r22
    83b6:	7d 93       	st	X+, r23
    83b8:	8d 93       	st	X+, r24
    83ba:	9c 93       	st	X, r25
    83bc:	d3 97       	sbiw	r26, 0x33	; 51
yawRads = heading;	*/
	
	
	

}
    83be:	c2 58       	subi	r28, 0x82	; 130
    83c0:	df 4f       	sbci	r29, 0xFF	; 255
    83c2:	0f b6       	in	r0, 0x3f	; 63
    83c4:	f8 94       	cli
    83c6:	de bf       	out	0x3e, r29	; 62
    83c8:	0f be       	out	0x3f, r0	; 63
    83ca:	cd bf       	out	0x3d, r28	; 61
    83cc:	df 91       	pop	r29
    83ce:	cf 91       	pop	r28
    83d0:	1f 91       	pop	r17
    83d2:	0f 91       	pop	r16
    83d4:	ff 90       	pop	r15
    83d6:	ef 90       	pop	r14
    83d8:	df 90       	pop	r13
    83da:	cf 90       	pop	r12
    83dc:	bf 90       	pop	r11
    83de:	af 90       	pop	r10
    83e0:	9f 90       	pop	r9
    83e2:	8f 90       	pop	r8
    83e4:	7f 90       	pop	r7
    83e6:	6f 90       	pop	r6
    83e8:	5f 90       	pop	r5
    83ea:	4f 90       	pop	r4
    83ec:	3f 90       	pop	r3
    83ee:	2f 90       	pop	r2
    83f0:	08 95       	ret

000083f2 <_ZN10helicopter10navigation4AHRS10getYawRadsEv>:

float AHRS::getYawRads()
{
    83f2:	fc 01       	movw	r30, r24
	return yawRads;
}
    83f4:	50 a5       	ldd	r21, Z+40	; 0x28
    83f6:	41 a5       	ldd	r20, Z+41	; 0x29
    83f8:	32 a5       	ldd	r19, Z+42	; 0x2a
    83fa:	23 a5       	ldd	r18, Z+43	; 0x2b
    83fc:	65 2f       	mov	r22, r21
    83fe:	74 2f       	mov	r23, r20
    8400:	83 2f       	mov	r24, r19
    8402:	92 2f       	mov	r25, r18
    8404:	08 95       	ret

00008406 <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>:

float AHRS::getPitchRads()
{
    8406:	fc 01       	movw	r30, r24
	return pitchRads;
}
    8408:	54 a5       	ldd	r21, Z+44	; 0x2c
    840a:	45 a5       	ldd	r20, Z+45	; 0x2d
    840c:	36 a5       	ldd	r19, Z+46	; 0x2e
    840e:	27 a5       	ldd	r18, Z+47	; 0x2f
    8410:	65 2f       	mov	r22, r21
    8412:	74 2f       	mov	r23, r20
    8414:	83 2f       	mov	r24, r19
    8416:	92 2f       	mov	r25, r18
    8418:	08 95       	ret

0000841a <_ZN10helicopter10navigation4AHRS11getRollRadsEv>:

float AHRS::getRollRads()
{
    841a:	fc 01       	movw	r30, r24
	return rollRads;
}
    841c:	50 a9       	ldd	r21, Z+48	; 0x30
    841e:	41 a9       	ldd	r20, Z+49	; 0x31
    8420:	32 a9       	ldd	r19, Z+50	; 0x32
    8422:	23 a9       	ldd	r18, Z+51	; 0x33
    8424:	65 2f       	mov	r22, r21
    8426:	74 2f       	mov	r23, r20
    8428:	83 2f       	mov	r24, r19
    842a:	92 2f       	mov	r25, r18
    842c:	08 95       	ret

0000842e <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>:
	}

	return scheduler;
}

Scheduler::Scheduler(unsigned long cpuSpeed, PRESCALER prescaler, int schedulerTickFrequencyHz)
    842e:	8f 92       	push	r8
    8430:	9f 92       	push	r9
    8432:	af 92       	push	r10
    8434:	bf 92       	push	r11
    8436:	ef 92       	push	r14
    8438:	ff 92       	push	r15
    843a:	0f 93       	push	r16
    843c:	1f 93       	push	r17
    843e:	cf 93       	push	r28
    8440:	df 93       	push	r29
    8442:	ec 01       	movw	r28, r24
    8444:	cb 01       	movw	r24, r22
    8446:	ba 01       	movw	r22, r20
    8448:	79 01       	movw	r14, r18
{
	//Calculate the timer value to achieve the desired frequency.
	targetTimerCount =  ((cpuSpeed / prescaler) / schedulerTickFrequencyHz);
    844a:	44 27       	eor	r20, r20
    844c:	37 fd       	sbrc	r19, 7
    844e:	40 95       	com	r20
    8450:	54 2f       	mov	r21, r20
    8452:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    8456:	49 01       	movw	r8, r18
    8458:	5a 01       	movw	r10, r20
    845a:	98 01       	movw	r18, r16
    845c:	44 27       	eor	r20, r20
    845e:	37 fd       	sbrc	r19, 7
    8460:	40 95       	com	r20
    8462:	54 2f       	mov	r21, r20
    8464:	c5 01       	movw	r24, r10
    8466:	b4 01       	movw	r22, r8
    8468:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    846c:	3d ab       	std	Y+53, r19	; 0x35
    846e:	2c ab       	std	Y+52, r18	; 0x34

	this->targetTimerCount = targetTimerCount;

	this->prescaler = prescaler;
    8470:	ff aa       	std	Y+55, r15	; 0x37
    8472:	ee aa       	std	Y+54, r14	; 0x36
	
	numOfTasks = 0;
    8474:	1b aa       	std	Y+51, r1	; 0x33
    8476:	1a aa       	std	Y+50, r1	; 0x32
	
	blowFrameDetected = false;
    8478:	18 ae       	std	Y+56, r1	; 0x38
	
	completedDispatch = true;
    847a:	81 e0       	ldi	r24, 0x01	; 1
    847c:	89 af       	std	Y+57, r24	; 0x39
}
    847e:	df 91       	pop	r29
    8480:	cf 91       	pop	r28
    8482:	1f 91       	pop	r17
    8484:	0f 91       	pop	r16
    8486:	ff 90       	pop	r15
    8488:	ef 90       	pop	r14
    848a:	bf 90       	pop	r11
    848c:	af 90       	pop	r10
    848e:	9f 90       	pop	r9
    8490:	8f 90       	pop	r8
    8492:	08 95       	ret

00008494 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>:
using namespace helicopter::model;

Scheduler* Scheduler::scheduler = NULL;

Scheduler* Scheduler::getScheduler()
{
    8494:	0f 93       	push	r16
    8496:	1f 93       	push	r17
    8498:	cf 93       	push	r28
    849a:	df 93       	push	r29
	if (scheduler == NULL)
    849c:	80 91 a6 03 	lds	r24, 0x03A6
    84a0:	90 91 a7 03 	lds	r25, 0x03A7
    84a4:	89 2b       	or	r24, r25
    84a6:	99 f4       	brne	.+38     	; 0x84ce <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv+0x3a>
	{
		scheduler = new Scheduler(F_CPU, PRESCALE_BY_TENTWENTYFOUR, SCHEDULER_TICK_FREQUENCY_HZ);
    84a8:	8a e3       	ldi	r24, 0x3A	; 58
    84aa:	90 e0       	ldi	r25, 0x00	; 0
    84ac:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    84b0:	ec 01       	movw	r28, r24
    84b2:	08 ec       	ldi	r16, 0xC8	; 200
    84b4:	10 e0       	ldi	r17, 0x00	; 0
    84b6:	20 e0       	ldi	r18, 0x00	; 0
    84b8:	34 e0       	ldi	r19, 0x04	; 4
    84ba:	40 e0       	ldi	r20, 0x00	; 0
    84bc:	54 e2       	ldi	r21, 0x24	; 36
    84be:	64 ef       	ldi	r22, 0xF4	; 244
    84c0:	70 e0       	ldi	r23, 0x00	; 0
    84c2:	0e 94 17 42 	call	0x842e	; 0x842e <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>
    84c6:	d0 93 a7 03 	sts	0x03A7, r29
    84ca:	c0 93 a6 03 	sts	0x03A6, r28
	}

	return scheduler;
}
    84ce:	80 91 a6 03 	lds	r24, 0x03A6
    84d2:	90 91 a7 03 	lds	r25, 0x03A7
    84d6:	df 91       	pop	r29
    84d8:	cf 91       	pop	r28
    84da:	1f 91       	pop	r17
    84dc:	0f 91       	pop	r16
    84de:	08 95       	ret

000084e0 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>:
	}
}

int Scheduler::addTask(Task *task)
{
	if (numOfTasks < MAXNUMOFTASKS)
    84e0:	fc 01       	movw	r30, r24
    84e2:	22 a9       	ldd	r18, Z+50	; 0x32
    84e4:	33 a9       	ldd	r19, Z+51	; 0x33
    84e6:	29 31       	cpi	r18, 0x19	; 25
    84e8:	31 05       	cpc	r19, r1
    84ea:	7c f4       	brge	.+30     	; 0x850a <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE+0x2a>
	{
		tasks[numOfTasks] = task;
    84ec:	f9 01       	movw	r30, r18
    84ee:	ee 0f       	add	r30, r30
    84f0:	ff 1f       	adc	r31, r31
    84f2:	e8 0f       	add	r30, r24
    84f4:	f9 1f       	adc	r31, r25
    84f6:	71 83       	std	Z+1, r23	; 0x01
    84f8:	60 83       	st	Z, r22
		numOfTasks++;
    84fa:	2f 5f       	subi	r18, 0xFF	; 255
    84fc:	3f 4f       	sbci	r19, 0xFF	; 255
    84fe:	fc 01       	movw	r30, r24
    8500:	33 ab       	std	Z+51, r19	; 0x33
    8502:	22 ab       	std	Z+50, r18	; 0x32
		
		return 0;
    8504:	20 e0       	ldi	r18, 0x00	; 0
    8506:	30 e0       	ldi	r19, 0x00	; 0
    8508:	02 c0       	rjmp	.+4      	; 0x850e <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE+0x2e>
	}

	return -1;
    850a:	2f ef       	ldi	r18, 0xFF	; 255
    850c:	3f ef       	ldi	r19, 0xFF	; 255
}
    850e:	82 2f       	mov	r24, r18
    8510:	93 2f       	mov	r25, r19
    8512:	08 95       	ret

00008514 <_ZN10helicopter9scheduler9Scheduler4initEv>:

void Scheduler::init()
{
    8514:	ef 92       	push	r14
    8516:	ff 92       	push	r15
    8518:	0f 93       	push	r16
    851a:	1f 93       	push	r17
    851c:	cf 93       	push	r28
    851e:	df 93       	push	r29
    8520:	7c 01       	movw	r14, r24
	cli();
    8522:	f8 94       	cli
	
	for (int i = 0; i < numOfTasks; i++)
    8524:	dc 01       	movw	r26, r24
    8526:	d2 96       	adiw	r26, 0x32	; 50
    8528:	8d 91       	ld	r24, X+
    852a:	9c 91       	ld	r25, X
    852c:	d3 97       	sbiw	r26, 0x33	; 51
    852e:	18 16       	cp	r1, r24
    8530:	19 06       	cpc	r1, r25
    8532:	ac f4       	brge	.+42     	; 0x855e <_ZN10helicopter9scheduler9Scheduler4initEv+0x4a>
    8534:	87 01       	movw	r16, r14
    8536:	c0 e0       	ldi	r28, 0x00	; 0
    8538:	d0 e0       	ldi	r29, 0x00	; 0
	{
		tasks[i]->init();
    853a:	f8 01       	movw	r30, r16
    853c:	81 91       	ld	r24, Z+
    853e:	91 91       	ld	r25, Z+
    8540:	8f 01       	movw	r16, r30
    8542:	dc 01       	movw	r26, r24
    8544:	ed 91       	ld	r30, X+
    8546:	fc 91       	ld	r31, X
    8548:	06 80       	ldd	r0, Z+6	; 0x06
    854a:	f7 81       	ldd	r31, Z+7	; 0x07
    854c:	e0 2d       	mov	r30, r0
    854e:	19 95       	eicall

void Scheduler::init()
{
	cli();
	
	for (int i = 0; i < numOfTasks; i++)
    8550:	21 96       	adiw	r28, 0x01	; 1
    8552:	f7 01       	movw	r30, r14
    8554:	22 a9       	ldd	r18, Z+50	; 0x32
    8556:	33 a9       	ldd	r19, Z+51	; 0x33
    8558:	c2 17       	cp	r28, r18
    855a:	d3 07       	cpc	r29, r19
    855c:	74 f3       	brlt	.-36     	; 0x853a <_ZN10helicopter9scheduler9Scheduler4initEv+0x26>
	{
		tasks[i]->init();
	}
	
	//setup timer
	OCR2A = targetTimerCount; //Set Clear Timer on Compare (auto reset) (CTC)
    855e:	d7 01       	movw	r26, r14
    8560:	d4 96       	adiw	r26, 0x34	; 52
    8562:	8c 91       	ld	r24, X
    8564:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2A |= (1 << WGM21); //Configure timer 2 for ctc mode
    8568:	e0 eb       	ldi	r30, 0xB0	; 176
    856a:	f0 e0       	ldi	r31, 0x00	; 0
    856c:	80 81       	ld	r24, Z
    856e:	82 60       	ori	r24, 0x02	; 2
    8570:	80 83       	st	Z, r24
	TIMSK2 |= (1 << OCIE2A); //enable ctc interrupt for OCR0A
    8572:	e0 e7       	ldi	r30, 0x70	; 112
    8574:	f0 e0       	ldi	r31, 0x00	; 0
    8576:	80 81       	ld	r24, Z
    8578:	82 60       	ori	r24, 0x02	; 2
    857a:	80 83       	st	Z, r24
		
	sei(); //Enable global interrupts
    857c:	78 94       	sei
}
    857e:	df 91       	pop	r29
    8580:	cf 91       	pop	r28
    8582:	1f 91       	pop	r17
    8584:	0f 91       	pop	r16
    8586:	ff 90       	pop	r15
    8588:	ef 90       	pop	r14
    858a:	08 95       	ret

0000858c <_ZN10helicopter9scheduler9Scheduler8dispatchEv>:

void Scheduler::dispatch()
{
    858c:	ef 92       	push	r14
    858e:	ff 92       	push	r15
    8590:	0f 93       	push	r16
    8592:	1f 93       	push	r17
    8594:	cf 93       	push	r28
    8596:	df 93       	push	r29
    8598:	7c 01       	movw	r14, r24
	completedDispatch = false;
    859a:	fc 01       	movw	r30, r24
    859c:	11 ae       	std	Z+57, r1	; 0x39
	blowFrameDetected = false;
    859e:	10 ae       	std	Z+56, r1	; 0x38
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    85a0:	82 a9       	ldd	r24, Z+50	; 0x32
    85a2:	93 a9       	ldd	r25, Z+51	; 0x33
    85a4:	18 16       	cp	r1, r24
    85a6:	19 06       	cpc	r1, r25
    85a8:	f4 f4       	brge	.+60     	; 0x85e6 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x5a>
    85aa:	87 01       	movw	r16, r14
    85ac:	c0 e0       	ldi	r28, 0x00	; 0
    85ae:	d0 e0       	ldi	r29, 0x00	; 0
	{
		task = tasks[i];
    85b0:	f8 01       	movw	r30, r16
    85b2:	a1 91       	ld	r26, Z+
    85b4:	b1 91       	ld	r27, Z+
    85b6:	8f 01       	movw	r16, r30
		
		if (task->getIsReadyToRun())
    85b8:	16 96       	adiw	r26, 0x06	; 6
    85ba:	8c 91       	ld	r24, X
    85bc:	16 97       	sbiw	r26, 0x06	; 6
    85be:	88 23       	and	r24, r24
    85c0:	59 f0       	breq	.+22     	; 0x85d8 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x4c>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    85c2:	16 96       	adiw	r26, 0x06	; 6
    85c4:	1c 92       	st	X, r1
    85c6:	16 97       	sbiw	r26, 0x06	; 6
		{
			task->setIsReadyToRun(false);
			task->runTask();
    85c8:	ed 91       	ld	r30, X+
    85ca:	fc 91       	ld	r31, X
    85cc:	11 97       	sbiw	r26, 0x01	; 1
    85ce:	00 84       	ldd	r0, Z+8	; 0x08
    85d0:	f1 85       	ldd	r31, Z+9	; 0x09
    85d2:	e0 2d       	mov	r30, r0
    85d4:	cd 01       	movw	r24, r26
    85d6:	19 95       	eicall
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    85d8:	21 96       	adiw	r28, 0x01	; 1
    85da:	f7 01       	movw	r30, r14
    85dc:	22 a9       	ldd	r18, Z+50	; 0x32
    85de:	33 a9       	ldd	r19, Z+51	; 0x33
    85e0:	c2 17       	cp	r28, r18
    85e2:	d3 07       	cpc	r29, r19
    85e4:	2c f3       	brlt	.-54     	; 0x85b0 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x24>
			task->setIsReadyToRun(false);
			task->runTask();
		}
	}

	completedDispatch = true;
    85e6:	81 e0       	ldi	r24, 0x01	; 1
    85e8:	f7 01       	movw	r30, r14
    85ea:	81 af       	std	Z+57, r24	; 0x39
	
	//tells the processor to goto sleep to conserve power since no more
	//tasks are scheduled to be run until after the next scheduler interrupt(tick)
	//which will then wake the processor back up.
	set_sleep_mode(SLEEP_MODE_IDLE);
    85ec:	83 b7       	in	r24, 0x33	; 51
    85ee:	81 7f       	andi	r24, 0xF1	; 241
    85f0:	83 bf       	out	0x33, r24	; 51
	sleep_mode();
    85f2:	83 b7       	in	r24, 0x33	; 51
    85f4:	81 60       	ori	r24, 0x01	; 1
    85f6:	83 bf       	out	0x33, r24	; 51
    85f8:	88 95       	sleep
    85fa:	83 b7       	in	r24, 0x33	; 51
    85fc:	8e 7f       	andi	r24, 0xFE	; 254
    85fe:	83 bf       	out	0x33, r24	; 51
}
    8600:	df 91       	pop	r29
    8602:	cf 91       	pop	r28
    8604:	1f 91       	pop	r17
    8606:	0f 91       	pop	r16
    8608:	ff 90       	pop	r15
    860a:	ef 90       	pop	r14
    860c:	08 95       	ret

0000860e <_ZN10helicopter9scheduler9Scheduler5startEv>:

void Scheduler::start()
{
	//Setting TCCR to a prescaler will start the timer.
	switch(this->prescaler)
    860e:	fc 01       	movw	r30, r24
    8610:	86 a9       	ldd	r24, Z+54	; 0x36
    8612:	97 a9       	ldd	r25, Z+55	; 0x37
    8614:	80 34       	cpi	r24, 0x40	; 64
    8616:	91 05       	cpc	r25, r1
    8618:	d9 f0       	breq	.+54     	; 0x8650 <_ZN10helicopter9scheduler9Scheduler5startEv+0x42>
    861a:	34 f4       	brge	.+12     	; 0x8628 <_ZN10helicopter9scheduler9Scheduler5startEv+0x1a>
    861c:	81 30       	cpi	r24, 0x01	; 1
    861e:	91 05       	cpc	r25, r1
    8620:	59 f0       	breq	.+22     	; 0x8638 <_ZN10helicopter9scheduler9Scheduler5startEv+0x2a>
    8622:	08 97       	sbiw	r24, 0x08	; 8
    8624:	39 f5       	brne	.+78     	; 0x8674 <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
    8626:	0e c0       	rjmp	.+28     	; 0x8644 <_ZN10helicopter9scheduler9Scheduler5startEv+0x36>
    8628:	81 15       	cp	r24, r1
    862a:	f1 e0       	ldi	r31, 0x01	; 1
    862c:	9f 07       	cpc	r25, r31
    862e:	b1 f0       	breq	.+44     	; 0x865c <_ZN10helicopter9scheduler9Scheduler5startEv+0x4e>
    8630:	81 15       	cp	r24, r1
    8632:	94 40       	sbci	r25, 0x04	; 4
    8634:	f9 f4       	brne	.+62     	; 0x8674 <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
    8636:	18 c0       	rjmp	.+48     	; 0x8668 <_ZN10helicopter9scheduler9Scheduler5startEv+0x5a>
	{
		case 1:
			TCCR2B |= NoPrescaling;
    8638:	e1 eb       	ldi	r30, 0xB1	; 177
    863a:	f0 e0       	ldi	r31, 0x00	; 0
    863c:	80 81       	ld	r24, Z
    863e:	81 60       	ori	r24, 0x01	; 1
    8640:	80 83       	st	Z, r24
			break;
    8642:	08 95       	ret
		case 8:
			TCCR2B |= PrescaleByEight;
    8644:	e1 eb       	ldi	r30, 0xB1	; 177
    8646:	f0 e0       	ldi	r31, 0x00	; 0
    8648:	80 81       	ld	r24, Z
    864a:	82 60       	ori	r24, 0x02	; 2
    864c:	80 83       	st	Z, r24
			break;
    864e:	08 95       	ret
		case 64:
			TCCR2B |= PrescaleBySixtyFour;
    8650:	e1 eb       	ldi	r30, 0xB1	; 177
    8652:	f0 e0       	ldi	r31, 0x00	; 0
    8654:	80 81       	ld	r24, Z
    8656:	84 60       	ori	r24, 0x04	; 4
    8658:	80 83       	st	Z, r24
			break;
    865a:	08 95       	ret
		case 256:
			TCCR2B |= PrescaleByTwofiftysix;
    865c:	e1 eb       	ldi	r30, 0xB1	; 177
    865e:	f0 e0       	ldi	r31, 0x00	; 0
    8660:	80 81       	ld	r24, Z
    8662:	86 60       	ori	r24, 0x06	; 6
    8664:	80 83       	st	Z, r24
			break;
    8666:	08 95       	ret
		case 1024:
			TCCR2B |= PrescaleByTentwentyfour;
    8668:	e1 eb       	ldi	r30, 0xB1	; 177
    866a:	f0 e0       	ldi	r31, 0x00	; 0
    866c:	80 81       	ld	r24, Z
    866e:	87 60       	ori	r24, 0x07	; 7
    8670:	80 83       	st	Z, r24
			break;
    8672:	08 95       	ret
		default:
			TCCR2B |= NoPrescaling;	
    8674:	e1 eb       	ldi	r30, 0xB1	; 177
    8676:	f0 e0       	ldi	r31, 0x00	; 0
    8678:	80 81       	ld	r24, Z
    867a:	81 60       	ori	r24, 0x01	; 1
    867c:	80 83       	st	Z, r24
    867e:	08 95       	ret

00008680 <__vector_13>:

/**
 * Interrupt service routine for determining when tasks are ready to execute.
 */
ISR(TIMER2_COMPA_vect)
{
    8680:	1f 92       	push	r1
    8682:	0f 92       	push	r0
    8684:	0f b6       	in	r0, 0x3f	; 63
    8686:	0f 92       	push	r0
    8688:	11 24       	eor	r1, r1
    868a:	0b b6       	in	r0, 0x3b	; 59
    868c:	0f 92       	push	r0
    868e:	2f 93       	push	r18
    8690:	3f 93       	push	r19
    8692:	4f 93       	push	r20
    8694:	5f 93       	push	r21
    8696:	6f 93       	push	r22
    8698:	7f 93       	push	r23
    869a:	8f 93       	push	r24
    869c:	9f 93       	push	r25
    869e:	af 93       	push	r26
    86a0:	bf 93       	push	r27
    86a2:	cf 93       	push	r28
    86a4:	df 93       	push	r29
    86a6:	ef 93       	push	r30
    86a8:	ff 93       	push	r31
publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);	
}
	*/
	
	
	Scheduler *scheduler = Scheduler::getScheduler();
    86aa:	0e 94 4a 42 	call	0x8494	; 0x8494 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    86ae:	ec 01       	movw	r28, r24
	
	//Detect if the scheduler blew a frame
	if (!scheduler->hasCompletedDispatch())
    86b0:	89 ad       	ldd	r24, Y+57	; 0x39
    86b2:	81 11       	cpse	r24, r1
    86b4:	12 c0       	rjmp	.+36     	; 0x86da <__vector_13+0x5a>
	{
//		scheduler->hasBlownFrame(true);
//publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);		
//SystemModel::publicModel->SerialCommunicationBufferOverruns(SystemModel::publicModel->SerialCommunicationBufferOverruns() + 1);		
SystemModel::publicModel->BlownFrames(SystemModel::publicModel->BlownFrames() + 1);		
    86b6:	e0 91 a4 03 	lds	r30, 0x03A4
    86ba:	f0 91 a5 03 	lds	r31, 0x03A5
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
    86be:	ea 54       	subi	r30, 0x4A	; 74
    86c0:	ff 4f       	sbci	r31, 0xFF	; 255
    86c2:	40 81       	ld	r20, Z
    86c4:	51 81       	ldd	r21, Z+1	; 0x01
    86c6:	62 81       	ldd	r22, Z+2	; 0x02
    86c8:	73 81       	ldd	r23, Z+3	; 0x03
    86ca:	4f 5f       	subi	r20, 0xFF	; 255
    86cc:	5f 4f       	sbci	r21, 0xFF	; 255
    86ce:	6f 4f       	sbci	r22, 0xFF	; 255
    86d0:	7f 4f       	sbci	r23, 0xFF	; 255
    86d2:	40 83       	st	Z, r20
    86d4:	51 83       	std	Z+1, r21	; 0x01
    86d6:	62 83       	std	Z+2, r22	; 0x02
    86d8:	73 83       	std	Z+3, r23	; 0x03
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    86da:	8a a9       	ldd	r24, Y+50	; 0x32
    86dc:	9b a9       	ldd	r25, Y+51	; 0x33
    86de:	18 16       	cp	r1, r24
    86e0:	19 06       	cpc	r1, r25
    86e2:	e4 f4       	brge	.+56     	; 0x871c <__vector_13+0x9c>
    86e4:	de 01       	movw	r26, r28
    86e6:	20 e0       	ldi	r18, 0x00	; 0
    86e8:	30 e0       	ldi	r19, 0x00	; 0
    86ea:	61 e0       	ldi	r22, 0x01	; 1
	{
		task = scheduler->getTasks()[i];
    86ec:	ed 91       	ld	r30, X+
    86ee:	fd 91       	ld	r31, X+
				virtual void runTask();
				
					
				int getDelay()
				{
					return delay;
    86f0:	42 81       	ldd	r20, Z+2	; 0x02
    86f2:	53 81       	ldd	r21, Z+3	; 0x03
		
		if (task->getDelay() <= 1)
    86f4:	42 30       	cpi	r20, 0x02	; 2
    86f6:	51 05       	cpc	r21, r1
    86f8:	34 f4       	brge	.+12     	; 0x8706 <__vector_13+0x86>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    86fa:	66 83       	std	Z+6, r22	; 0x06
					return period;
				}
				
				void setDelay(int delay)
				{
					this->delay = delay;
    86fc:	84 81       	ldd	r24, Z+4	; 0x04
    86fe:	95 81       	ldd	r25, Z+5	; 0x05
    8700:	93 83       	std	Z+3, r25	; 0x03
    8702:	82 83       	std	Z+2, r24	; 0x02
    8704:	04 c0       	rjmp	.+8      	; 0x870e <__vector_13+0x8e>
				/**
				 * Reduces the delay by one tick.
				 */
				void reduceDelay()
				{
					delay--;
    8706:	41 50       	subi	r20, 0x01	; 1
    8708:	51 09       	sbc	r21, r1
    870a:	53 83       	std	Z+3, r21	; 0x03
    870c:	42 83       	std	Z+2, r20	; 0x02
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    870e:	2f 5f       	subi	r18, 0xFF	; 255
    8710:	3f 4f       	sbci	r19, 0xFF	; 255
    8712:	8a a9       	ldd	r24, Y+50	; 0x32
    8714:	9b a9       	ldd	r25, Y+51	; 0x33
    8716:	28 17       	cp	r18, r24
    8718:	39 07       	cpc	r19, r25
    871a:	44 f3       	brlt	.-48     	; 0x86ec <__vector_13+0x6c>
		}else
		{
			task->reduceDelay();
		}
	}
}
    871c:	ff 91       	pop	r31
    871e:	ef 91       	pop	r30
    8720:	df 91       	pop	r29
    8722:	cf 91       	pop	r28
    8724:	bf 91       	pop	r27
    8726:	af 91       	pop	r26
    8728:	9f 91       	pop	r25
    872a:	8f 91       	pop	r24
    872c:	7f 91       	pop	r23
    872e:	6f 91       	pop	r22
    8730:	5f 91       	pop	r21
    8732:	4f 91       	pop	r20
    8734:	3f 91       	pop	r19
    8736:	2f 91       	pop	r18
    8738:	0f 90       	pop	r0
    873a:	0b be       	out	0x3b, r0	; 59
    873c:	0f 90       	pop	r0
    873e:	0f be       	out	0x3f, r0	; 63
    8740:	0f 90       	pop	r0
    8742:	1f 90       	pop	r1
    8744:	18 95       	reti

00008746 <_ZN10helicopter7sensors15BarometerSensor4initEv>:


using namespace helicopter::sensors;

void BarometerSensor::init()
{
    8746:	0f 93       	push	r16
    8748:	1f 93       	push	r17
    874a:	cf 93       	push	r28
    874c:	df 93       	push	r29
    874e:	ec 01       	movw	r28, r24
	//Per page 9 of MS5611-01Ba03.PDF Reset the barometer to ensure calibration PROM gets loaded.
	spiDriver->transactionWrite(RESET_COMMAND);
    8750:	6e e1       	ldi	r22, 0x1E	; 30
    8752:	88 81       	ld	r24, Y
    8754:	99 81       	ldd	r25, Y+1	; 0x01
    8756:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    875a:	8f e1       	ldi	r24, 0x1F	; 31
    875c:	9e e4       	ldi	r25, 0x4E	; 78
    875e:	01 97       	sbiw	r24, 0x01	; 1
    8760:	f1 f7       	brne	.-4      	; 0x875e <_ZN10helicopter7sensors15BarometerSensor4initEv+0x18>
    8762:	00 c0       	rjmp	.+0      	; 0x8764 <_ZN10helicopter7sensors15BarometerSensor4initEv+0x1e>
    8764:	00 00       	nop
	/**
	 * Each barometer is individually calibrated at the factory. This reads those calibration
	 * values for our calculations to compensate temperature and pressure values. 
	 * Those values are stored in the programmable read only memory (PROM) of the barometer
	 */
	spiDriver->beginTransaction();
    8766:	88 81       	ld	r24, Y
    8768:	99 81       	ldd	r25, Y+1	; 0x01
    876a:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C1_COMMAND);
    876e:	62 ea       	ldi	r22, 0xA2	; 162
    8770:	88 81       	ld	r24, Y
    8772:	99 81       	ldd	r25, Y+1	; 0x01
    8774:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivity_SENSt1_C1 = spiDriver->readUInt();
    8778:	88 81       	ld	r24, Y
    877a:	99 81       	ldd	r25, Y+1	; 0x01
    877c:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8780:	8c 01       	movw	r16, r24
    8782:	8a 8b       	std	Y+18, r24	; 0x12
    8784:	1b 8b       	std	Y+19, r17	; 0x13
    8786:	1c 8a       	std	Y+20, r1	; 0x14
    8788:	1d 8a       	std	Y+21, r1	; 0x15
    878a:	1e 8a       	std	Y+22, r1	; 0x16
    878c:	1f 8a       	std	Y+23, r1	; 0x17
    878e:	18 8e       	std	Y+24, r1	; 0x18
    8790:	19 8e       	std	Y+25, r1	; 0x19
	spiDriver->endTransaction();
    8792:	88 81       	ld	r24, Y
    8794:	99 81       	ldd	r25, Y+1	; 0x01
    8796:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    879a:	88 81       	ld	r24, Y
    879c:	99 81       	ldd	r25, Y+1	; 0x01
    879e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C2_COMMAND);
    87a2:	64 ea       	ldi	r22, 0xA4	; 164
    87a4:	88 81       	ld	r24, Y
    87a6:	99 81       	ldd	r25, Y+1	; 0x01
    87a8:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivityOffset_OFFt1_C2 = spiDriver->readUInt();
    87ac:	88 81       	ld	r24, Y
    87ae:	99 81       	ldd	r25, Y+1	; 0x01
    87b0:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    87b4:	8c 01       	movw	r16, r24
    87b6:	8a 8f       	std	Y+26, r24	; 0x1a
    87b8:	1b 8f       	std	Y+27, r17	; 0x1b
    87ba:	1c 8e       	std	Y+28, r1	; 0x1c
    87bc:	1d 8e       	std	Y+29, r1	; 0x1d
    87be:	1e 8e       	std	Y+30, r1	; 0x1e
    87c0:	1f 8e       	std	Y+31, r1	; 0x1f
    87c2:	18 a2       	std	Y+32, r1	; 0x20
    87c4:	19 a2       	std	Y+33, r1	; 0x21
	spiDriver->endTransaction();
    87c6:	88 81       	ld	r24, Y
    87c8:	99 81       	ldd	r25, Y+1	; 0x01
    87ca:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>

	spiDriver->beginTransaction();
    87ce:	88 81       	ld	r24, Y
    87d0:	99 81       	ldd	r25, Y+1	; 0x01
    87d2:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C3_COMMAND);
    87d6:	66 ea       	ldi	r22, 0xA6	; 166
    87d8:	88 81       	ld	r24, Y
    87da:	99 81       	ldd	r25, Y+1	; 0x01
    87dc:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureSensitivity_TCS_C3 = spiDriver->readUInt();
    87e0:	88 81       	ld	r24, Y
    87e2:	99 81       	ldd	r25, Y+1	; 0x01
    87e4:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    87e8:	8c 01       	movw	r16, r24
    87ea:	8a a3       	std	Y+34, r24	; 0x22
    87ec:	1b a3       	std	Y+35, r17	; 0x23
    87ee:	1c a2       	std	Y+36, r1	; 0x24
    87f0:	1d a2       	std	Y+37, r1	; 0x25
    87f2:	1e a2       	std	Y+38, r1	; 0x26
    87f4:	1f a2       	std	Y+39, r1	; 0x27
    87f6:	18 a6       	std	Y+40, r1	; 0x28
    87f8:	19 a6       	std	Y+41, r1	; 0x29
	spiDriver->endTransaction();
    87fa:	88 81       	ld	r24, Y
    87fc:	99 81       	ldd	r25, Y+1	; 0x01
    87fe:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    8802:	88 81       	ld	r24, Y
    8804:	99 81       	ldd	r25, Y+1	; 0x01
    8806:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C4_COMMAND);
    880a:	68 ea       	ldi	r22, 0xA8	; 168
    880c:	88 81       	ld	r24, Y
    880e:	99 81       	ldd	r25, Y+1	; 0x01
    8810:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureOffset_TCO_C4 = spiDriver->readUInt();
    8814:	88 81       	ld	r24, Y
    8816:	99 81       	ldd	r25, Y+1	; 0x01
    8818:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    881c:	8c 01       	movw	r16, r24
    881e:	8a a7       	std	Y+42, r24	; 0x2a
    8820:	1b a7       	std	Y+43, r17	; 0x2b
    8822:	1c a6       	std	Y+44, r1	; 0x2c
    8824:	1d a6       	std	Y+45, r1	; 0x2d
    8826:	1e a6       	std	Y+46, r1	; 0x2e
    8828:	1f a6       	std	Y+47, r1	; 0x2f
    882a:	18 aa       	std	Y+48, r1	; 0x30
    882c:	19 aa       	std	Y+49, r1	; 0x31
	spiDriver->endTransaction();
    882e:	88 81       	ld	r24, Y
    8830:	99 81       	ldd	r25, Y+1	; 0x01
    8832:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    8836:	88 81       	ld	r24, Y
    8838:	99 81       	ldd	r25, Y+1	; 0x01
    883a:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C5_COMMAND);
    883e:	6a ea       	ldi	r22, 0xAA	; 170
    8840:	88 81       	ld	r24, Y
    8842:	99 81       	ldd	r25, Y+1	; 0x01
    8844:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	referenceTemperature_Tref_C5 = spiDriver->readUInt();
    8848:	88 81       	ld	r24, Y
    884a:	99 81       	ldd	r25, Y+1	; 0x01
    884c:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8850:	8c 01       	movw	r16, r24
    8852:	8a ab       	std	Y+50, r24	; 0x32
    8854:	1b ab       	std	Y+51, r17	; 0x33
    8856:	1c aa       	std	Y+52, r1	; 0x34
    8858:	1d aa       	std	Y+53, r1	; 0x35
    885a:	1e aa       	std	Y+54, r1	; 0x36
    885c:	1f aa       	std	Y+55, r1	; 0x37
    885e:	18 ae       	std	Y+56, r1	; 0x38
    8860:	19 ae       	std	Y+57, r1	; 0x39
	spiDriver->endTransaction();
    8862:	88 81       	ld	r24, Y
    8864:	99 81       	ldd	r25, Y+1	; 0x01
    8866:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    886a:	88 81       	ld	r24, Y
    886c:	99 81       	ldd	r25, Y+1	; 0x01
    886e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C6_COMMAND);
    8872:	6c ea       	ldi	r22, 0xAC	; 172
    8874:	88 81       	ld	r24, Y
    8876:	99 81       	ldd	r25, Y+1	; 0x01
    8878:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfTheTemperature_TEMPSENS_C6 = spiDriver->readUInt();
    887c:	88 81       	ld	r24, Y
    887e:	99 81       	ldd	r25, Y+1	; 0x01
    8880:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8884:	8c 01       	movw	r16, r24
    8886:	fe 01       	movw	r30, r28
    8888:	fa 96       	adiw	r30, 0x3a	; 58
    888a:	8a af       	std	Y+58, r24	; 0x3a
    888c:	11 83       	std	Z+1, r17	; 0x01
    888e:	12 82       	std	Z+2, r1	; 0x02
    8890:	13 82       	std	Z+3, r1	; 0x03
    8892:	14 82       	std	Z+4, r1	; 0x04
    8894:	15 82       	std	Z+5, r1	; 0x05
    8896:	16 82       	std	Z+6, r1	; 0x06
    8898:	17 82       	std	Z+7, r1	; 0x07
	spiDriver->endTransaction();
    889a:	88 81       	ld	r24, Y
    889c:	99 81       	ldd	r25, Y+1	; 0x01
    889e:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    88a2:	df 91       	pop	r29
    88a4:	cf 91       	pop	r28
    88a6:	1f 91       	pop	r17
    88a8:	0f 91       	pop	r16
    88aa:	08 95       	ret

000088ac <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>:
	 * Initiate conversion for pressure.
	 * According to page 5 in MS5611-01Ba03.PDF, the best noise performance is obtained
	 * when the SPI bus is idle during ADC conversion. So we keep the ADC initiation command
	 * in it's own transaction to reduce noise. 
	 */
	spiDriver->transactionWrite(CONVERT_D1_PRESSURE_OSR_4096);
    88ac:	68 e4       	ldi	r22, 0x48	; 72
    88ae:	fc 01       	movw	r30, r24
    88b0:	80 81       	ld	r24, Z
    88b2:	91 81       	ldd	r25, Z+1	; 0x01
    88b4:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    88b8:	08 95       	ret

000088ba <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>:
}

void BarometerSensor::readD1Data()
{	
    88ba:	cf 92       	push	r12
    88bc:	df 92       	push	r13
    88be:	ef 92       	push	r14
    88c0:	ff 92       	push	r15
    88c2:	cf 93       	push	r28
    88c4:	df 93       	push	r29
    88c6:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    88c8:	88 81       	ld	r24, Y
    88ca:	99 81       	ldd	r25, Y+1	; 0x01
    88cc:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    88d0:	60 e0       	ldi	r22, 0x00	; 0
    88d2:	88 81       	ld	r24, Y
    88d4:	99 81       	ldd	r25, Y+1	; 0x01
    88d6:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	
	/**
	 * The pressure is 3 bytes. So read the hight byte, shift it by eight, read the mid byte, shift by 8, then read the low byte
	 * to form a 3 byte 'long'
	 */
	rawPressure = spiDriver->readByte();
    88da:	88 81       	ld	r24, Y
    88dc:	99 81       	ldd	r25, Y+1	; 0x01
    88de:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    88e2:	c8 2e       	mov	r12, r24
    88e4:	d1 2c       	mov	r13, r1
    88e6:	e1 2c       	mov	r14, r1
    88e8:	f1 2c       	mov	r15, r1
    88ea:	ce 82       	std	Y+6, r12	; 0x06
    88ec:	df 82       	std	Y+7, r13	; 0x07
    88ee:	e8 86       	std	Y+8, r14	; 0x08
    88f0:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    88f2:	88 81       	ld	r24, Y
    88f4:	99 81       	ldd	r25, Y+1	; 0x01
    88f6:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    88fa:	fe 2c       	mov	r15, r14
    88fc:	ed 2c       	mov	r14, r13
    88fe:	dc 2c       	mov	r13, r12
    8900:	cc 24       	eor	r12, r12
    8902:	c8 2a       	or	r12, r24
    8904:	ce 82       	std	Y+6, r12	; 0x06
    8906:	df 82       	std	Y+7, r13	; 0x07
    8908:	e8 86       	std	Y+8, r14	; 0x08
    890a:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    890c:	88 81       	ld	r24, Y
    890e:	99 81       	ldd	r25, Y+1	; 0x01
    8910:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8914:	fe 2c       	mov	r15, r14
    8916:	ed 2c       	mov	r14, r13
    8918:	dc 2c       	mov	r13, r12
    891a:	cc 24       	eor	r12, r12
    891c:	c8 2a       	or	r12, r24
    891e:	ce 82       	std	Y+6, r12	; 0x06
    8920:	df 82       	std	Y+7, r13	; 0x07
    8922:	e8 86       	std	Y+8, r14	; 0x08
    8924:	f9 86       	std	Y+9, r15	; 0x09
	
	spiDriver->endTransaction();	
    8926:	88 81       	ld	r24, Y
    8928:	99 81       	ldd	r25, Y+1	; 0x01
    892a:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    892e:	df 91       	pop	r29
    8930:	cf 91       	pop	r28
    8932:	ff 90       	pop	r15
    8934:	ef 90       	pop	r14
    8936:	df 90       	pop	r13
    8938:	cf 90       	pop	r12
    893a:	08 95       	ret

0000893c <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>:

void BarometerSensor::sendD2Command()
{
	//Initiate conversion for temperature.
	spiDriver->transactionWrite(CONVERT_D2_TEMPERATURE_OSR_4096);	
    893c:	68 e5       	ldi	r22, 0x58	; 88
    893e:	fc 01       	movw	r30, r24
    8940:	80 81       	ld	r24, Z
    8942:	91 81       	ldd	r25, Z+1	; 0x01
    8944:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    8948:	08 95       	ret

0000894a <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>:
}

void BarometerSensor::readD2Data()
{
    894a:	cf 92       	push	r12
    894c:	df 92       	push	r13
    894e:	ef 92       	push	r14
    8950:	ff 92       	push	r15
    8952:	cf 93       	push	r28
    8954:	df 93       	push	r29
    8956:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    8958:	88 81       	ld	r24, Y
    895a:	99 81       	ldd	r25, Y+1	; 0x01
    895c:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    8960:	60 e0       	ldi	r22, 0x00	; 0
    8962:	88 81       	ld	r24, Y
    8964:	99 81       	ldd	r25, Y+1	; 0x01
    8966:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	rawTemperature = spiDriver->readByte();
    896a:	88 81       	ld	r24, Y
    896c:	99 81       	ldd	r25, Y+1	; 0x01
    896e:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8972:	c8 2e       	mov	r12, r24
    8974:	d1 2c       	mov	r13, r1
    8976:	e1 2c       	mov	r14, r1
    8978:	f1 2c       	mov	r15, r1
    897a:	ca 82       	std	Y+2, r12	; 0x02
    897c:	db 82       	std	Y+3, r13	; 0x03
    897e:	ec 82       	std	Y+4, r14	; 0x04
    8980:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();
    8982:	88 81       	ld	r24, Y
    8984:	99 81       	ldd	r25, Y+1	; 0x01
    8986:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    898a:	fe 2c       	mov	r15, r14
    898c:	ed 2c       	mov	r14, r13
    898e:	dc 2c       	mov	r13, r12
    8990:	cc 24       	eor	r12, r12
    8992:	c8 2a       	or	r12, r24
    8994:	ca 82       	std	Y+2, r12	; 0x02
    8996:	db 82       	std	Y+3, r13	; 0x03
    8998:	ec 82       	std	Y+4, r14	; 0x04
    899a:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();	
    899c:	88 81       	ld	r24, Y
    899e:	99 81       	ldd	r25, Y+1	; 0x01
    89a0:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    89a4:	fe 2c       	mov	r15, r14
    89a6:	ed 2c       	mov	r14, r13
    89a8:	dc 2c       	mov	r13, r12
    89aa:	cc 24       	eor	r12, r12
    89ac:	c8 2a       	or	r12, r24
    89ae:	ca 82       	std	Y+2, r12	; 0x02
    89b0:	db 82       	std	Y+3, r13	; 0x03
    89b2:	ec 82       	std	Y+4, r14	; 0x04
    89b4:	fd 82       	std	Y+5, r15	; 0x05

	spiDriver->endTransaction();	
    89b6:	88 81       	ld	r24, Y
    89b8:	99 81       	ldd	r25, Y+1	; 0x01
    89ba:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    89be:	df 91       	pop	r29
    89c0:	cf 91       	pop	r28
    89c2:	ff 90       	pop	r15
    89c4:	ef 90       	pop	r14
    89c6:	df 90       	pop	r13
    89c8:	cf 90       	pop	r12
    89ca:	08 95       	ret

000089cc <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>:


void BarometerSensor::processBaroData()
{
    89cc:	2f 92       	push	r2
    89ce:	3f 92       	push	r3
    89d0:	4f 92       	push	r4
    89d2:	5f 92       	push	r5
    89d4:	6f 92       	push	r6
    89d6:	7f 92       	push	r7
    89d8:	8f 92       	push	r8
    89da:	9f 92       	push	r9
    89dc:	af 92       	push	r10
    89de:	bf 92       	push	r11
    89e0:	cf 92       	push	r12
    89e2:	df 92       	push	r13
    89e4:	ef 92       	push	r14
    89e6:	ff 92       	push	r15
    89e8:	0f 93       	push	r16
    89ea:	1f 93       	push	r17
    89ec:	cf 93       	push	r28
    89ee:	df 93       	push	r29
    89f0:	cd b7       	in	r28, 0x3d	; 61
    89f2:	de b7       	in	r29, 0x3e	; 62
    89f4:	c8 54       	subi	r28, 0x48	; 72
    89f6:	d1 09       	sbc	r29, r1
    89f8:	0f b6       	in	r0, 0x3f	; 63
    89fa:	f8 94       	cli
    89fc:	de bf       	out	0x3e, r29	; 62
    89fe:	0f be       	out	0x3f, r0	; 63
    8a00:	cd bf       	out	0x3d, r28	; 61
    8a02:	27 96       	adiw	r28, 0x07	; 7
    8a04:	9f af       	std	Y+63, r25	; 0x3f
    8a06:	8e af       	std	Y+62, r24	; 0x3e
    8a08:	27 97       	sbiw	r28, 0x07	; 7
	
	/**
	* Formulas from page 7 on MS5611-01BA03.pdf
	*/
	int64_t rawPress = rawPressure;
    8a0a:	fc 01       	movw	r30, r24
    8a0c:	86 81       	ldd	r24, Z+6	; 0x06
    8a0e:	97 81       	ldd	r25, Z+7	; 0x07
    8a10:	a0 85       	ldd	r26, Z+8	; 0x08
    8a12:	b1 85       	ldd	r27, Z+9	; 0x09
    8a14:	8c 01       	movw	r16, r24
    8a16:	9d 01       	movw	r18, r26
    8a18:	40 e0       	ldi	r20, 0x00	; 0
    8a1a:	50 e0       	ldi	r21, 0x00	; 0
    8a1c:	ba 01       	movw	r22, r20
    8a1e:	8d 87       	std	Y+13, r24	; 0x0d
    8a20:	1e 87       	std	Y+14, r17	; 0x0e
    8a22:	2f 87       	std	Y+15, r18	; 0x0f
    8a24:	38 8b       	std	Y+16, r19	; 0x10
    8a26:	49 8b       	std	Y+17, r20	; 0x11
    8a28:	5a 8b       	std	Y+18, r21	; 0x12
    8a2a:	6b 8b       	std	Y+19, r22	; 0x13
    8a2c:	7c 8b       	std	Y+20, r23	; 0x14
	int64_t rawTemp = rawTemperature;
    8a2e:	82 80       	ldd	r8, Z+2	; 0x02
    8a30:	93 80       	ldd	r9, Z+3	; 0x03
    8a32:	a4 80       	ldd	r10, Z+4	; 0x04
    8a34:	b5 80       	ldd	r11, Z+5	; 0x05

	//I use the shift operators instead of division. (I.e. << 8 = dividing by 2^8).
	int64_t tempDifference = rawTemp - (referenceTemperature_Tref_C5 << 8);
    8a36:	22 a9       	ldd	r18, Z+50	; 0x32
    8a38:	33 a9       	ldd	r19, Z+51	; 0x33
    8a3a:	44 a9       	ldd	r20, Z+52	; 0x34
    8a3c:	55 a9       	ldd	r21, Z+53	; 0x35
    8a3e:	66 a9       	ldd	r22, Z+54	; 0x36
    8a40:	77 a9       	ldd	r23, Z+55	; 0x37
    8a42:	80 ad       	ldd	r24, Z+56	; 0x38
    8a44:	91 ad       	ldd	r25, Z+57	; 0x39
    8a46:	08 e0       	ldi	r16, 0x08	; 8
    8a48:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8a4c:	62 2e       	mov	r6, r18
    8a4e:	73 2e       	mov	r7, r19
    8a50:	b4 2f       	mov	r27, r20
    8a52:	a5 2f       	mov	r26, r21
    8a54:	f6 2f       	mov	r31, r22
    8a56:	e7 2f       	mov	r30, r23
    8a58:	08 2f       	mov	r16, r24
    8a5a:	19 2f       	mov	r17, r25
    8a5c:	28 2d       	mov	r18, r8
    8a5e:	39 2d       	mov	r19, r9
    8a60:	4a 2d       	mov	r20, r10
    8a62:	5b 2d       	mov	r21, r11
    8a64:	60 e0       	ldi	r22, 0x00	; 0
    8a66:	70 e0       	ldi	r23, 0x00	; 0
    8a68:	80 e0       	ldi	r24, 0x00	; 0
    8a6a:	90 e0       	ldi	r25, 0x00	; 0
    8a6c:	a6 2c       	mov	r10, r6
    8a6e:	b7 2c       	mov	r11, r7
    8a70:	cb 2e       	mov	r12, r27
    8a72:	da 2e       	mov	r13, r26
    8a74:	ef 2e       	mov	r14, r31
    8a76:	fe 2e       	mov	r15, r30
    8a78:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8a7c:	32 2e       	mov	r3, r18
    8a7e:	23 2e       	mov	r2, r19
    8a80:	49 83       	std	Y+1, r20	; 0x01
    8a82:	5a 83       	std	Y+2, r21	; 0x02
    8a84:	6b 83       	std	Y+3, r22	; 0x03
    8a86:	7c 83       	std	Y+4, r23	; 0x04
    8a88:	88 2e       	mov	r8, r24
    8a8a:	99 2e       	mov	r9, r25
	int64_t temp = 2000 + ((tempDifference * temperatureCoefficientOfTheTemperature_TEMPSENS_C6) >> 23);
    8a8c:	27 96       	adiw	r28, 0x07	; 7
    8a8e:	ee ad       	ldd	r30, Y+62	; 0x3e
    8a90:	ff ad       	ldd	r31, Y+63	; 0x3f
    8a92:	27 97       	sbiw	r28, 0x07	; 7
    8a94:	fa 96       	adiw	r30, 0x3a	; 58
    8a96:	27 96       	adiw	r28, 0x07	; 7
    8a98:	ae ad       	ldd	r26, Y+62	; 0x3e
    8a9a:	bf ad       	ldd	r27, Y+63	; 0x3f
    8a9c:	27 97       	sbiw	r28, 0x07	; 7
    8a9e:	da 96       	adiw	r26, 0x3a	; 58
    8aa0:	ac 90       	ld	r10, X
    8aa2:	b1 80       	ldd	r11, Z+1	; 0x01
    8aa4:	c2 80       	ldd	r12, Z+2	; 0x02
    8aa6:	d3 80       	ldd	r13, Z+3	; 0x03
    8aa8:	e4 80       	ldd	r14, Z+4	; 0x04
    8aaa:	f5 80       	ldd	r15, Z+5	; 0x05
    8aac:	06 81       	ldd	r16, Z+6	; 0x06
    8aae:	17 81       	ldd	r17, Z+7	; 0x07
    8ab0:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8ab4:	07 e1       	ldi	r16, 0x17	; 23
    8ab6:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8aba:	29 8f       	std	Y+25, r18	; 0x19
    8abc:	3a 8f       	std	Y+26, r19	; 0x1a
    8abe:	4b 8f       	std	Y+27, r20	; 0x1b
    8ac0:	5c 8f       	std	Y+28, r21	; 0x1c
    8ac2:	6d 8f       	std	Y+29, r22	; 0x1d
    8ac4:	7e 8f       	std	Y+30, r23	; 0x1e
    8ac6:	8f 8f       	std	Y+31, r24	; 0x1f
    8ac8:	98 a3       	std	Y+32, r25	; 0x20
    8aca:	20 53       	subi	r18, 0x30	; 48
    8acc:	38 4f       	sbci	r19, 0xF8	; 248
    8ace:	4f 4f       	sbci	r20, 0xFF	; 255
    8ad0:	5f 4f       	sbci	r21, 0xFF	; 255
    8ad2:	6f 4f       	sbci	r22, 0xFF	; 255
    8ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    8ad6:	8f 4f       	sbci	r24, 0xFF	; 255
    8ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    8ada:	2d 8b       	std	Y+21, r18	; 0x15
    8adc:	3e 8b       	std	Y+22, r19	; 0x16
    8ade:	4f 8b       	std	Y+23, r20	; 0x17
    8ae0:	58 8f       	std	Y+24, r21	; 0x18
    8ae2:	69 a3       	std	Y+33, r22	; 0x21
    8ae4:	7a a3       	std	Y+34, r23	; 0x22
    8ae6:	8b a3       	std	Y+35, r24	; 0x23
    8ae8:	9c a3       	std	Y+36, r25	; 0x24
	int64_t tempOffset = (pressureSensitivityOffset_OFFt1_C2 << 16) + ((temperatureCoefficientOfPressureOffset_TCO_C4 * tempDifference) >> 7);
    8aea:	27 96       	adiw	r28, 0x07	; 7
    8aec:	ee ad       	ldd	r30, Y+62	; 0x3e
    8aee:	ff ad       	ldd	r31, Y+63	; 0x3f
    8af0:	27 97       	sbiw	r28, 0x07	; 7
    8af2:	22 8d       	ldd	r18, Z+26	; 0x1a
    8af4:	33 8d       	ldd	r19, Z+27	; 0x1b
    8af6:	44 8d       	ldd	r20, Z+28	; 0x1c
    8af8:	55 8d       	ldd	r21, Z+29	; 0x1d
    8afa:	66 8d       	ldd	r22, Z+30	; 0x1e
    8afc:	77 8d       	ldd	r23, Z+31	; 0x1f
    8afe:	80 a1       	ldd	r24, Z+32	; 0x20
    8b00:	91 a1       	ldd	r25, Z+33	; 0x21
    8b02:	00 e1       	ldi	r16, 0x10	; 16
    8b04:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8b08:	2d 83       	std	Y+5, r18	; 0x05
    8b0a:	3e 83       	std	Y+6, r19	; 0x06
    8b0c:	4f 83       	std	Y+7, r20	; 0x07
    8b0e:	58 87       	std	Y+8, r21	; 0x08
    8b10:	76 2e       	mov	r7, r22
    8b12:	67 2e       	mov	r6, r23
    8b14:	58 2e       	mov	r5, r24
    8b16:	49 2e       	mov	r4, r25
    8b18:	a2 a4       	ldd	r10, Z+42	; 0x2a
    8b1a:	b3 a4       	ldd	r11, Z+43	; 0x2b
    8b1c:	c4 a4       	ldd	r12, Z+44	; 0x2c
    8b1e:	d5 a4       	ldd	r13, Z+45	; 0x2d
    8b20:	e6 a4       	ldd	r14, Z+46	; 0x2e
    8b22:	f7 a4       	ldd	r15, Z+47	; 0x2f
    8b24:	00 a9       	ldd	r16, Z+48	; 0x30
    8b26:	11 a9       	ldd	r17, Z+49	; 0x31
    8b28:	23 2d       	mov	r18, r3
    8b2a:	32 2d       	mov	r19, r2
    8b2c:	49 81       	ldd	r20, Y+1	; 0x01
    8b2e:	5a 81       	ldd	r21, Y+2	; 0x02
    8b30:	6b 81       	ldd	r22, Y+3	; 0x03
    8b32:	7c 81       	ldd	r23, Y+4	; 0x04
    8b34:	88 2d       	mov	r24, r8
    8b36:	99 2d       	mov	r25, r9
    8b38:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8b3c:	07 e0       	ldi	r16, 0x07	; 7
    8b3e:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8b42:	a2 2e       	mov	r10, r18
    8b44:	b3 2e       	mov	r11, r19
    8b46:	c4 2e       	mov	r12, r20
    8b48:	d5 2e       	mov	r13, r21
    8b4a:	e6 2e       	mov	r14, r22
    8b4c:	f7 2e       	mov	r15, r23
    8b4e:	08 2f       	mov	r16, r24
    8b50:	19 2f       	mov	r17, r25
    8b52:	2d 81       	ldd	r18, Y+5	; 0x05
    8b54:	3e 81       	ldd	r19, Y+6	; 0x06
    8b56:	4f 81       	ldd	r20, Y+7	; 0x07
    8b58:	58 85       	ldd	r21, Y+8	; 0x08
    8b5a:	67 2d       	mov	r22, r7
    8b5c:	76 2d       	mov	r23, r6
    8b5e:	85 2d       	mov	r24, r5
    8b60:	94 2d       	mov	r25, r4
    8b62:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8b66:	2d 83       	std	Y+5, r18	; 0x05
    8b68:	3e 83       	std	Y+6, r19	; 0x06
    8b6a:	4f 83       	std	Y+7, r20	; 0x07
    8b6c:	58 87       	std	Y+8, r21	; 0x08
    8b6e:	6d a3       	std	Y+37, r22	; 0x25
    8b70:	7e a3       	std	Y+38, r23	; 0x26
    8b72:	8f a3       	std	Y+39, r24	; 0x27
    8b74:	98 a7       	std	Y+40, r25	; 0x28
	int64_t sensitivityAtTemp = (pressureSensitivity_SENSt1_C1 << 15) + ((temperatureCoefficientOfPressureSensitivity_TCS_C3 * tempDifference) >> 8);
    8b76:	27 96       	adiw	r28, 0x07	; 7
    8b78:	ae ad       	ldd	r26, Y+62	; 0x3e
    8b7a:	bf ad       	ldd	r27, Y+63	; 0x3f
    8b7c:	27 97       	sbiw	r28, 0x07	; 7
    8b7e:	52 96       	adiw	r26, 0x12	; 18
    8b80:	2c 91       	ld	r18, X
    8b82:	52 97       	sbiw	r26, 0x12	; 18
    8b84:	53 96       	adiw	r26, 0x13	; 19
    8b86:	3c 91       	ld	r19, X
    8b88:	53 97       	sbiw	r26, 0x13	; 19
    8b8a:	54 96       	adiw	r26, 0x14	; 20
    8b8c:	4c 91       	ld	r20, X
    8b8e:	54 97       	sbiw	r26, 0x14	; 20
    8b90:	55 96       	adiw	r26, 0x15	; 21
    8b92:	5c 91       	ld	r21, X
    8b94:	55 97       	sbiw	r26, 0x15	; 21
    8b96:	56 96       	adiw	r26, 0x16	; 22
    8b98:	6c 91       	ld	r22, X
    8b9a:	56 97       	sbiw	r26, 0x16	; 22
    8b9c:	57 96       	adiw	r26, 0x17	; 23
    8b9e:	7c 91       	ld	r23, X
    8ba0:	57 97       	sbiw	r26, 0x17	; 23
    8ba2:	58 96       	adiw	r26, 0x18	; 24
    8ba4:	8c 91       	ld	r24, X
    8ba6:	58 97       	sbiw	r26, 0x18	; 24
    8ba8:	59 96       	adiw	r26, 0x19	; 25
    8baa:	9c 91       	ld	r25, X
    8bac:	59 97       	sbiw	r26, 0x19	; 25
    8bae:	0f e0       	ldi	r16, 0x0F	; 15
    8bb0:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8bb4:	29 87       	std	Y+9, r18	; 0x09
    8bb6:	3a 87       	std	Y+10, r19	; 0x0a
    8bb8:	4b 87       	std	Y+11, r20	; 0x0b
    8bba:	5c 87       	std	Y+12, r21	; 0x0c
    8bbc:	76 2e       	mov	r7, r22
    8bbe:	67 2e       	mov	r6, r23
    8bc0:	58 2e       	mov	r5, r24
    8bc2:	49 2e       	mov	r4, r25
    8bc4:	92 96       	adiw	r26, 0x22	; 34
    8bc6:	ac 90       	ld	r10, X
    8bc8:	92 97       	sbiw	r26, 0x22	; 34
    8bca:	93 96       	adiw	r26, 0x23	; 35
    8bcc:	bc 90       	ld	r11, X
    8bce:	93 97       	sbiw	r26, 0x23	; 35
    8bd0:	94 96       	adiw	r26, 0x24	; 36
    8bd2:	cc 90       	ld	r12, X
    8bd4:	94 97       	sbiw	r26, 0x24	; 36
    8bd6:	95 96       	adiw	r26, 0x25	; 37
    8bd8:	dc 90       	ld	r13, X
    8bda:	95 97       	sbiw	r26, 0x25	; 37
    8bdc:	96 96       	adiw	r26, 0x26	; 38
    8bde:	ec 90       	ld	r14, X
    8be0:	96 97       	sbiw	r26, 0x26	; 38
    8be2:	97 96       	adiw	r26, 0x27	; 39
    8be4:	fc 90       	ld	r15, X
    8be6:	97 97       	sbiw	r26, 0x27	; 39
    8be8:	98 96       	adiw	r26, 0x28	; 40
    8bea:	0c 91       	ld	r16, X
    8bec:	98 97       	sbiw	r26, 0x28	; 40
    8bee:	99 96       	adiw	r26, 0x29	; 41
    8bf0:	1c 91       	ld	r17, X
    8bf2:	23 2d       	mov	r18, r3
    8bf4:	32 2d       	mov	r19, r2
    8bf6:	49 81       	ldd	r20, Y+1	; 0x01
    8bf8:	5a 81       	ldd	r21, Y+2	; 0x02
    8bfa:	6b 81       	ldd	r22, Y+3	; 0x03
    8bfc:	7c 81       	ldd	r23, Y+4	; 0x04
    8bfe:	88 2d       	mov	r24, r8
    8c00:	99 2d       	mov	r25, r9
    8c02:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8c06:	08 e0       	ldi	r16, 0x08	; 8
    8c08:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8c0c:	a2 2e       	mov	r10, r18
    8c0e:	b3 2e       	mov	r11, r19
    8c10:	c4 2e       	mov	r12, r20
    8c12:	d5 2e       	mov	r13, r21
    8c14:	e6 2e       	mov	r14, r22
    8c16:	f7 2e       	mov	r15, r23
    8c18:	08 2f       	mov	r16, r24
    8c1a:	19 2f       	mov	r17, r25
    8c1c:	29 85       	ldd	r18, Y+9	; 0x09
    8c1e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8c20:	4b 85       	ldd	r20, Y+11	; 0x0b
    8c22:	5c 85       	ldd	r21, Y+12	; 0x0c
    8c24:	67 2d       	mov	r22, r7
    8c26:	76 2d       	mov	r23, r6
    8c28:	85 2d       	mov	r24, r5
    8c2a:	94 2d       	mov	r25, r4
    8c2c:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8c30:	29 87       	std	Y+9, r18	; 0x09
    8c32:	3a 87       	std	Y+10, r19	; 0x0a
    8c34:	4b 87       	std	Y+11, r20	; 0x0b
    8c36:	5c 87       	std	Y+12, r21	; 0x0c
    8c38:	76 2e       	mov	r7, r22
    8c3a:	47 2e       	mov	r4, r23
    8c3c:	58 2e       	mov	r5, r24
    8c3e:	69 2e       	mov	r6, r25
		
	/**
	 * The sensor's accuracy drops off when the temp is below 20*C. So the following is
	 * code to compensate for temperature below 20*C. 
	 */
	if (temp < 2000)
    8c40:	2d 89       	ldd	r18, Y+21	; 0x15
    8c42:	3e 89       	ldd	r19, Y+22	; 0x16
    8c44:	4f 89       	ldd	r20, Y+23	; 0x17
    8c46:	58 8d       	ldd	r21, Y+24	; 0x18
    8c48:	69 a1       	ldd	r22, Y+33	; 0x21
    8c4a:	7a a1       	ldd	r23, Y+34	; 0x22
    8c4c:	8b a1       	ldd	r24, Y+35	; 0x23
    8c4e:	9c a1       	ldd	r25, Y+36	; 0x24
    8c50:	2f 3c       	cpi	r18, 0xCF	; 207
    8c52:	37 40       	sbci	r19, 0x07	; 7
    8c54:	41 05       	cpc	r20, r1
    8c56:	51 05       	cpc	r21, r1
    8c58:	61 05       	cpc	r22, r1
    8c5a:	71 05       	cpc	r23, r1
    8c5c:	81 05       	cpc	r24, r1
    8c5e:	91 05       	cpc	r25, r1
    8c60:	11 f0       	breq	.+4      	; 0x8c66 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    8c62:	0c f0       	brlt	.+2      	; 0x8c66 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    8c64:	97 c1       	rjmp	.+814    	; 0x8f94 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x5c8>
	{
		int64_t temp2 = (tempDifference * tempDifference) >> 31;
    8c66:	a3 2c       	mov	r10, r3
    8c68:	b2 2c       	mov	r11, r2
    8c6a:	c9 80       	ldd	r12, Y+1	; 0x01
    8c6c:	da 80       	ldd	r13, Y+2	; 0x02
    8c6e:	eb 80       	ldd	r14, Y+3	; 0x03
    8c70:	fc 80       	ldd	r15, Y+4	; 0x04
    8c72:	08 2d       	mov	r16, r8
    8c74:	19 2d       	mov	r17, r9
    8c76:	23 2d       	mov	r18, r3
    8c78:	32 2d       	mov	r19, r2
    8c7a:	4c 2d       	mov	r20, r12
    8c7c:	5d 2d       	mov	r21, r13
    8c7e:	6e 2d       	mov	r22, r14
    8c80:	7f 2d       	mov	r23, r15
    8c82:	88 2d       	mov	r24, r8
    8c84:	99 2d       	mov	r25, r9
    8c86:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8c8a:	0f e1       	ldi	r16, 0x1F	; 31
    8c8c:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8c90:	2d af       	std	Y+61, r18	; 0x3d
    8c92:	3e af       	std	Y+62, r19	; 0x3e
    8c94:	4f af       	std	Y+63, r20	; 0x3f
    8c96:	21 96       	adiw	r28, 0x01	; 1
    8c98:	5f af       	std	Y+63, r21	; 0x3f
    8c9a:	21 97       	sbiw	r28, 0x01	; 1
    8c9c:	22 96       	adiw	r28, 0x02	; 2
    8c9e:	6f af       	std	Y+63, r22	; 0x3f
    8ca0:	22 97       	sbiw	r28, 0x02	; 2
    8ca2:	23 96       	adiw	r28, 0x03	; 3
    8ca4:	7f af       	std	Y+63, r23	; 0x3f
    8ca6:	23 97       	sbiw	r28, 0x03	; 3
    8ca8:	24 96       	adiw	r28, 0x04	; 4
    8caa:	8f af       	std	Y+63, r24	; 0x3f
    8cac:	24 97       	sbiw	r28, 0x04	; 4
    8cae:	25 96       	adiw	r28, 0x05	; 5
    8cb0:	9f af       	std	Y+63, r25	; 0x3f
    8cb2:	25 97       	sbiw	r28, 0x05	; 5
		
		int64_t temporaryValue = (temp - 2000);
		temporaryValue *= temporaryValue;
    8cb4:	a9 8c       	ldd	r10, Y+25	; 0x19
    8cb6:	ba 8c       	ldd	r11, Y+26	; 0x1a
    8cb8:	cb 8c       	ldd	r12, Y+27	; 0x1b
    8cba:	dc 8c       	ldd	r13, Y+28	; 0x1c
    8cbc:	ed 8c       	ldd	r14, Y+29	; 0x1d
    8cbe:	fe 8c       	ldd	r15, Y+30	; 0x1e
    8cc0:	0f 8d       	ldd	r16, Y+31	; 0x1f
    8cc2:	18 a1       	ldd	r17, Y+32	; 0x20
    8cc4:	2a 2d       	mov	r18, r10
    8cc6:	3b 2d       	mov	r19, r11
    8cc8:	4c 2d       	mov	r20, r12
    8cca:	5d 2d       	mov	r21, r13
    8ccc:	6e 2d       	mov	r22, r14
    8cce:	7f 2d       	mov	r23, r15
    8cd0:	80 2f       	mov	r24, r16
    8cd2:	91 2f       	mov	r25, r17
    8cd4:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8cd8:	2e ab       	std	Y+54, r18	; 0x36
    8cda:	a3 2f       	mov	r26, r19
    8cdc:	b4 2f       	mov	r27, r20
    8cde:	e5 2f       	mov	r30, r21
    8ce0:	26 2e       	mov	r2, r22
    8ce2:	97 2e       	mov	r9, r23
    8ce4:	88 2e       	mov	r8, r24
    8ce6:	39 2e       	mov	r3, r25
		
		int64_t tempOffset2 = 5 * (temporaryValue >> 1);
    8ce8:	4b 2f       	mov	r20, r27
    8cea:	5e 2f       	mov	r21, r30
    8cec:	62 2d       	mov	r22, r2
    8cee:	79 2d       	mov	r23, r9
    8cf0:	88 2d       	mov	r24, r8
    8cf2:	93 2d       	mov	r25, r3
    8cf4:	01 e0       	ldi	r16, 0x01	; 1
    8cf6:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8cfa:	a2 2e       	mov	r10, r18
    8cfc:	b3 2e       	mov	r11, r19
    8cfe:	c4 2e       	mov	r12, r20
    8d00:	d5 2e       	mov	r13, r21
    8d02:	e6 2e       	mov	r14, r22
    8d04:	f7 2e       	mov	r15, r23
    8d06:	f8 2f       	mov	r31, r24
    8d08:	19 2f       	mov	r17, r25
    8d0a:	02 e0       	ldi	r16, 0x02	; 2
    8d0c:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8d10:	0f 2f       	mov	r16, r31
    8d12:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8d16:	2e a7       	std	Y+46, r18	; 0x2e
    8d18:	3f a7       	std	Y+47, r19	; 0x2f
    8d1a:	48 ab       	std	Y+48, r20	; 0x30
    8d1c:	59 ab       	std	Y+49, r21	; 0x31
    8d1e:	6a ab       	std	Y+50, r22	; 0x32
    8d20:	7b ab       	std	Y+51, r23	; 0x33
    8d22:	8c ab       	std	Y+52, r24	; 0x34
    8d24:	9d ab       	std	Y+53, r25	; 0x35
    8d26:	f2 2f       	mov	r31, r18
    8d28:	3b 83       	std	Y+3, r19	; 0x03
    8d2a:	4c 83       	std	Y+4, r20	; 0x04
    8d2c:	59 a7       	std	Y+41, r21	; 0x29
    8d2e:	6a a7       	std	Y+42, r22	; 0x2a
    8d30:	7b a7       	std	Y+43, r23	; 0x2b
    8d32:	8c a7       	std	Y+44, r24	; 0x2c
    8d34:	9d a7       	std	Y+45, r25	; 0x2d
		int64_t sensitivity2 = 5 * (temporaryValue >> 2);	
    8d36:	2e a9       	ldd	r18, Y+54	; 0x36
    8d38:	3a 2f       	mov	r19, r26
    8d3a:	4b 2f       	mov	r20, r27
    8d3c:	5e 2f       	mov	r21, r30
    8d3e:	62 2d       	mov	r22, r2
    8d40:	79 2d       	mov	r23, r9
    8d42:	88 2d       	mov	r24, r8
    8d44:	93 2d       	mov	r25, r3
    8d46:	02 e0       	ldi	r16, 0x02	; 2
    8d48:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8d4c:	a2 2e       	mov	r10, r18
    8d4e:	b3 2e       	mov	r11, r19
    8d50:	c4 2e       	mov	r12, r20
    8d52:	d5 2e       	mov	r13, r21
    8d54:	e6 2e       	mov	r14, r22
    8d56:	f7 2e       	mov	r15, r23
    8d58:	e8 2f       	mov	r30, r24
    8d5a:	19 2f       	mov	r17, r25
    8d5c:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8d60:	0e 2f       	mov	r16, r30
    8d62:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8d66:	29 83       	std	Y+1, r18	; 0x01
    8d68:	3e ab       	std	Y+54, r19	; 0x36
    8d6a:	4f ab       	std	Y+55, r20	; 0x37
    8d6c:	58 af       	std	Y+56, r21	; 0x38
    8d6e:	69 af       	std	Y+57, r22	; 0x39
    8d70:	7a af       	std	Y+58, r23	; 0x3a
    8d72:	8b af       	std	Y+59, r24	; 0x3b
    8d74:	9c af       	std	Y+60, r25	; 0x3c
    8d76:	22 2e       	mov	r2, r18
    8d78:	93 2e       	mov	r9, r19
    8d7a:	84 2e       	mov	r8, r20
    8d7c:	b5 2f       	mov	r27, r21
    8d7e:	36 2e       	mov	r3, r22
    8d80:	a7 2f       	mov	r26, r23
    8d82:	29 96       	adiw	r28, 0x09	; 9
    8d84:	8f af       	std	Y+63, r24	; 0x3f
    8d86:	29 97       	sbiw	r28, 0x09	; 9
    8d88:	28 96       	adiw	r28, 0x08	; 8
    8d8a:	9f af       	std	Y+63, r25	; 0x3f
    8d8c:	28 97       	sbiw	r28, 0x08	; 8
							
		//Temperature correction code for below 15*c
		if (temp < -1500)
    8d8e:	2d 89       	ldd	r18, Y+21	; 0x15
    8d90:	3e 89       	ldd	r19, Y+22	; 0x16
    8d92:	4f 89       	ldd	r20, Y+23	; 0x17
    8d94:	58 8d       	ldd	r21, Y+24	; 0x18
    8d96:	69 a1       	ldd	r22, Y+33	; 0x21
    8d98:	7a a1       	ldd	r23, Y+34	; 0x22
    8d9a:	8b a1       	ldd	r24, Y+35	; 0x23
    8d9c:	9c a1       	ldd	r25, Y+36	; 0x24
    8d9e:	24 32       	cpi	r18, 0x24	; 36
    8da0:	3a 4f       	sbci	r19, 0xFA	; 250
    8da2:	4f 4f       	sbci	r20, 0xFF	; 255
    8da4:	5f 4f       	sbci	r21, 0xFF	; 255
    8da6:	6f 4f       	sbci	r22, 0xFF	; 255
    8da8:	7f 4f       	sbci	r23, 0xFF	; 255
    8daa:	8f 4f       	sbci	r24, 0xFF	; 255
    8dac:	9f 4f       	sbci	r25, 0xFF	; 255
    8dae:	0c f0       	brlt	.+2      	; 0x8db2 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x3e6>
    8db0:	99 c0       	rjmp	.+306    	; 0x8ee4 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x518>
		{
			int64_t temporaryValue2 = temp + 1500;
    8db2:	29 8d       	ldd	r18, Y+25	; 0x19
    8db4:	3a 8d       	ldd	r19, Y+26	; 0x1a
    8db6:	4b 8d       	ldd	r20, Y+27	; 0x1b
    8db8:	5c 8d       	ldd	r21, Y+28	; 0x1c
    8dba:	6d 8d       	ldd	r22, Y+29	; 0x1d
    8dbc:	7e 8d       	ldd	r23, Y+30	; 0x1e
    8dbe:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8dc0:	98 a1       	ldd	r25, Y+32	; 0x20
    8dc2:	24 55       	subi	r18, 0x54	; 84
    8dc4:	32 4f       	sbci	r19, 0xF2	; 242
    8dc6:	4f 4f       	sbci	r20, 0xFF	; 255
    8dc8:	5f 4f       	sbci	r21, 0xFF	; 255
    8dca:	6f 4f       	sbci	r22, 0xFF	; 255
    8dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    8dce:	8f 4f       	sbci	r24, 0xFF	; 255
    8dd0:	9f 4f       	sbci	r25, 0xFF	; 255
			temporaryValue2 *= temporaryValue2;
    8dd2:	a2 2e       	mov	r10, r18
    8dd4:	b3 2e       	mov	r11, r19
    8dd6:	c4 2e       	mov	r12, r20
    8dd8:	d5 2e       	mov	r13, r21
    8dda:	e6 2e       	mov	r14, r22
    8ddc:	f7 2e       	mov	r15, r23
    8dde:	08 2f       	mov	r16, r24
    8de0:	19 2f       	mov	r17, r25
    8de2:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8de6:	b2 2f       	mov	r27, r18
    8de8:	a3 2f       	mov	r26, r19
    8dea:	e4 2f       	mov	r30, r20
    8dec:	59 8f       	std	Y+25, r21	; 0x19
    8dee:	26 2e       	mov	r2, r22
    8df0:	37 2e       	mov	r3, r23
    8df2:	98 2e       	mov	r9, r24
    8df4:	89 2e       	mov	r8, r25
			
			tempOffset2 = tempOffset2 + 7 * temporaryValue2;
    8df6:	03 e0       	ldi	r16, 0x03	; 3
    8df8:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8dfc:	ab 2e       	mov	r10, r27
    8dfe:	ba 2e       	mov	r11, r26
    8e00:	ce 2e       	mov	r12, r30
    8e02:	d9 8c       	ldd	r13, Y+25	; 0x19
    8e04:	e2 2c       	mov	r14, r2
    8e06:	f3 2c       	mov	r15, r3
    8e08:	09 2d       	mov	r16, r9
    8e0a:	18 2d       	mov	r17, r8
    8e0c:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8e10:	a2 2e       	mov	r10, r18
    8e12:	b3 2e       	mov	r11, r19
    8e14:	c4 2e       	mov	r12, r20
    8e16:	d5 2e       	mov	r13, r21
    8e18:	e6 2e       	mov	r14, r22
    8e1a:	f7 2e       	mov	r15, r23
    8e1c:	08 2f       	mov	r16, r24
    8e1e:	19 2f       	mov	r17, r25
    8e20:	2e a5       	ldd	r18, Y+46	; 0x2e
    8e22:	3f a5       	ldd	r19, Y+47	; 0x2f
    8e24:	48 a9       	ldd	r20, Y+48	; 0x30
    8e26:	59 a9       	ldd	r21, Y+49	; 0x31
    8e28:	6a a9       	ldd	r22, Y+50	; 0x32
    8e2a:	7b a9       	ldd	r23, Y+51	; 0x33
    8e2c:	8c a9       	ldd	r24, Y+52	; 0x34
    8e2e:	9d a9       	ldd	r25, Y+53	; 0x35
    8e30:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8e34:	f2 2f       	mov	r31, r18
    8e36:	3b 83       	std	Y+3, r19	; 0x03
    8e38:	4c 83       	std	Y+4, r20	; 0x04
    8e3a:	59 a7       	std	Y+41, r21	; 0x29
    8e3c:	6a a7       	std	Y+42, r22	; 0x2a
    8e3e:	7b a7       	std	Y+43, r23	; 0x2b
    8e40:	8c a7       	std	Y+44, r24	; 0x2c
    8e42:	9d a7       	std	Y+45, r25	; 0x2d
			sensitivity2 = sensitivity2 + 11 * (temporaryValue2 >> 1);
    8e44:	2b 2f       	mov	r18, r27
    8e46:	3a 2f       	mov	r19, r26
    8e48:	4e 2f       	mov	r20, r30
    8e4a:	59 8d       	ldd	r21, Y+25	; 0x19
    8e4c:	62 2d       	mov	r22, r2
    8e4e:	73 2d       	mov	r23, r3
    8e50:	89 2d       	mov	r24, r9
    8e52:	98 2d       	mov	r25, r8
    8e54:	01 e0       	ldi	r16, 0x01	; 1
    8e56:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8e5a:	2a 8f       	std	Y+26, r18	; 0x1a
    8e5c:	a3 2f       	mov	r26, r19
    8e5e:	b4 2f       	mov	r27, r20
    8e60:	59 8f       	std	Y+25, r21	; 0x19
    8e62:	26 2e       	mov	r2, r22
    8e64:	97 2e       	mov	r9, r23
    8e66:	88 2e       	mov	r8, r24
    8e68:	39 2e       	mov	r3, r25
    8e6a:	4b 2f       	mov	r20, r27
    8e6c:	62 2d       	mov	r22, r2
    8e6e:	79 2d       	mov	r23, r9
    8e70:	88 2d       	mov	r24, r8
    8e72:	93 2d       	mov	r25, r3
    8e74:	02 e0       	ldi	r16, 0x02	; 2
    8e76:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8e7a:	a2 2e       	mov	r10, r18
    8e7c:	b3 2e       	mov	r11, r19
    8e7e:	c4 2e       	mov	r12, r20
    8e80:	d5 2e       	mov	r13, r21
    8e82:	e6 2e       	mov	r14, r22
    8e84:	f7 2e       	mov	r15, r23
    8e86:	e8 2f       	mov	r30, r24
    8e88:	19 2f       	mov	r17, r25
    8e8a:	0e 94 ef 6f 	call	0xdfde	; 0xdfde <__ashldi3>
    8e8e:	0e 2f       	mov	r16, r30
    8e90:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8e94:	aa 8c       	ldd	r10, Y+26	; 0x1a
    8e96:	ba 2e       	mov	r11, r26
    8e98:	cb 2e       	mov	r12, r27
    8e9a:	d9 8c       	ldd	r13, Y+25	; 0x19
    8e9c:	e2 2c       	mov	r14, r2
    8e9e:	f9 2c       	mov	r15, r9
    8ea0:	08 2d       	mov	r16, r8
    8ea2:	13 2d       	mov	r17, r3
    8ea4:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8ea8:	a2 2e       	mov	r10, r18
    8eaa:	b3 2e       	mov	r11, r19
    8eac:	c4 2e       	mov	r12, r20
    8eae:	d5 2e       	mov	r13, r21
    8eb0:	e6 2e       	mov	r14, r22
    8eb2:	f7 2e       	mov	r15, r23
    8eb4:	08 2f       	mov	r16, r24
    8eb6:	19 2f       	mov	r17, r25
    8eb8:	29 81       	ldd	r18, Y+1	; 0x01
    8eba:	3e a9       	ldd	r19, Y+54	; 0x36
    8ebc:	4f a9       	ldd	r20, Y+55	; 0x37
    8ebe:	58 ad       	ldd	r21, Y+56	; 0x38
    8ec0:	69 ad       	ldd	r22, Y+57	; 0x39
    8ec2:	7a ad       	ldd	r23, Y+58	; 0x3a
    8ec4:	8b ad       	ldd	r24, Y+59	; 0x3b
    8ec6:	9c ad       	ldd	r25, Y+60	; 0x3c
    8ec8:	0e 94 0d 70 	call	0xe01a	; 0xe01a <__adddi3>
    8ecc:	22 2e       	mov	r2, r18
    8ece:	93 2e       	mov	r9, r19
    8ed0:	84 2e       	mov	r8, r20
    8ed2:	b5 2f       	mov	r27, r21
    8ed4:	36 2e       	mov	r3, r22
    8ed6:	a7 2f       	mov	r26, r23
    8ed8:	29 96       	adiw	r28, 0x09	; 9
    8eda:	8f af       	std	Y+63, r24	; 0x3f
    8edc:	29 97       	sbiw	r28, 0x09	; 9
    8ede:	28 96       	adiw	r28, 0x08	; 8
    8ee0:	9f af       	std	Y+63, r25	; 0x3f
    8ee2:	28 97       	sbiw	r28, 0x08	; 8
		}
		
				
		temp = temp - temp2;
    8ee4:	2d 89       	ldd	r18, Y+21	; 0x15
    8ee6:	3e 89       	ldd	r19, Y+22	; 0x16
    8ee8:	4f 89       	ldd	r20, Y+23	; 0x17
    8eea:	58 8d       	ldd	r21, Y+24	; 0x18
    8eec:	69 a1       	ldd	r22, Y+33	; 0x21
    8eee:	7a a1       	ldd	r23, Y+34	; 0x22
    8ef0:	8b a1       	ldd	r24, Y+35	; 0x23
    8ef2:	9c a1       	ldd	r25, Y+36	; 0x24
    8ef4:	ad ac       	ldd	r10, Y+61	; 0x3d
    8ef6:	be ac       	ldd	r11, Y+62	; 0x3e
    8ef8:	cf ac       	ldd	r12, Y+63	; 0x3f
    8efa:	21 96       	adiw	r28, 0x01	; 1
    8efc:	df ac       	ldd	r13, Y+63	; 0x3f
    8efe:	21 97       	sbiw	r28, 0x01	; 1
    8f00:	22 96       	adiw	r28, 0x02	; 2
    8f02:	ef ac       	ldd	r14, Y+63	; 0x3f
    8f04:	22 97       	sbiw	r28, 0x02	; 2
    8f06:	23 96       	adiw	r28, 0x03	; 3
    8f08:	ff ac       	ldd	r15, Y+63	; 0x3f
    8f0a:	23 97       	sbiw	r28, 0x03	; 3
    8f0c:	24 96       	adiw	r28, 0x04	; 4
    8f0e:	0f ad       	ldd	r16, Y+63	; 0x3f
    8f10:	24 97       	sbiw	r28, 0x04	; 4
    8f12:	25 96       	adiw	r28, 0x05	; 5
    8f14:	1f ad       	ldd	r17, Y+63	; 0x3f
    8f16:	25 97       	sbiw	r28, 0x05	; 5
    8f18:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8f1c:	2d 8b       	std	Y+21, r18	; 0x15
    8f1e:	3e 8b       	std	Y+22, r19	; 0x16
    8f20:	4f 8b       	std	Y+23, r20	; 0x17
    8f22:	58 8f       	std	Y+24, r21	; 0x18
		tempOffset = tempOffset - tempOffset2;
    8f24:	2d 81       	ldd	r18, Y+5	; 0x05
    8f26:	3e 81       	ldd	r19, Y+6	; 0x06
    8f28:	4f 81       	ldd	r20, Y+7	; 0x07
    8f2a:	58 85       	ldd	r21, Y+8	; 0x08
    8f2c:	6d a1       	ldd	r22, Y+37	; 0x25
    8f2e:	7e a1       	ldd	r23, Y+38	; 0x26
    8f30:	8f a1       	ldd	r24, Y+39	; 0x27
    8f32:	98 a5       	ldd	r25, Y+40	; 0x28
    8f34:	af 2e       	mov	r10, r31
    8f36:	bb 80       	ldd	r11, Y+3	; 0x03
    8f38:	cc 80       	ldd	r12, Y+4	; 0x04
    8f3a:	d9 a4       	ldd	r13, Y+41	; 0x29
    8f3c:	ea a4       	ldd	r14, Y+42	; 0x2a
    8f3e:	fb a4       	ldd	r15, Y+43	; 0x2b
    8f40:	0c a5       	ldd	r16, Y+44	; 0x2c
    8f42:	1d a5       	ldd	r17, Y+45	; 0x2d
    8f44:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8f48:	2d 83       	std	Y+5, r18	; 0x05
    8f4a:	3e 83       	std	Y+6, r19	; 0x06
    8f4c:	4f 83       	std	Y+7, r20	; 0x07
    8f4e:	58 87       	std	Y+8, r21	; 0x08
    8f50:	6d a3       	std	Y+37, r22	; 0x25
    8f52:	7e a3       	std	Y+38, r23	; 0x26
    8f54:	8f a3       	std	Y+39, r24	; 0x27
    8f56:	98 a7       	std	Y+40, r25	; 0x28
		sensitivityAtTemp = sensitivityAtTemp - sensitivity2;
    8f58:	29 85       	ldd	r18, Y+9	; 0x09
    8f5a:	3a 85       	ldd	r19, Y+10	; 0x0a
    8f5c:	4b 85       	ldd	r20, Y+11	; 0x0b
    8f5e:	5c 85       	ldd	r21, Y+12	; 0x0c
    8f60:	67 2d       	mov	r22, r7
    8f62:	74 2d       	mov	r23, r4
    8f64:	85 2d       	mov	r24, r5
    8f66:	96 2d       	mov	r25, r6
    8f68:	a2 2c       	mov	r10, r2
    8f6a:	b9 2c       	mov	r11, r9
    8f6c:	c8 2c       	mov	r12, r8
    8f6e:	db 2e       	mov	r13, r27
    8f70:	e3 2c       	mov	r14, r3
    8f72:	fa 2e       	mov	r15, r26
    8f74:	29 96       	adiw	r28, 0x09	; 9
    8f76:	0f ad       	ldd	r16, Y+63	; 0x3f
    8f78:	29 97       	sbiw	r28, 0x09	; 9
    8f7a:	28 96       	adiw	r28, 0x08	; 8
    8f7c:	1f ad       	ldd	r17, Y+63	; 0x3f
    8f7e:	28 97       	sbiw	r28, 0x08	; 8
    8f80:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8f84:	29 87       	std	Y+9, r18	; 0x09
    8f86:	3a 87       	std	Y+10, r19	; 0x0a
    8f88:	4b 87       	std	Y+11, r20	; 0x0b
    8f8a:	5c 87       	std	Y+12, r21	; 0x0c
    8f8c:	76 2e       	mov	r7, r22
    8f8e:	47 2e       	mov	r4, r23
    8f90:	58 2e       	mov	r5, r24
    8f92:	69 2e       	mov	r6, r25
	}
	
	pressureMillibars = (((((rawPress * sensitivityAtTemp) >> 21) - tempOffset)) >> 15);
    8f94:	a9 84       	ldd	r10, Y+9	; 0x09
    8f96:	ba 84       	ldd	r11, Y+10	; 0x0a
    8f98:	cb 84       	ldd	r12, Y+11	; 0x0b
    8f9a:	dc 84       	ldd	r13, Y+12	; 0x0c
    8f9c:	e7 2c       	mov	r14, r7
    8f9e:	f4 2c       	mov	r15, r4
    8fa0:	05 2d       	mov	r16, r5
    8fa2:	16 2d       	mov	r17, r6
    8fa4:	2d 85       	ldd	r18, Y+13	; 0x0d
    8fa6:	3e 85       	ldd	r19, Y+14	; 0x0e
    8fa8:	4f 85       	ldd	r20, Y+15	; 0x0f
    8faa:	58 89       	ldd	r21, Y+16	; 0x10
    8fac:	60 e0       	ldi	r22, 0x00	; 0
    8fae:	70 e0       	ldi	r23, 0x00	; 0
    8fb0:	80 e0       	ldi	r24, 0x00	; 0
    8fb2:	90 e0       	ldi	r25, 0x00	; 0
    8fb4:	0e 94 94 6f 	call	0xdf28	; 0xdf28 <__muldi3>
    8fb8:	05 e1       	ldi	r16, 0x15	; 21
    8fba:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8fbe:	ad 80       	ldd	r10, Y+5	; 0x05
    8fc0:	be 80       	ldd	r11, Y+6	; 0x06
    8fc2:	cf 80       	ldd	r12, Y+7	; 0x07
    8fc4:	d8 84       	ldd	r13, Y+8	; 0x08
    8fc6:	ed a0       	ldd	r14, Y+37	; 0x25
    8fc8:	fe a0       	ldd	r15, Y+38	; 0x26
    8fca:	0f a1       	ldd	r16, Y+39	; 0x27
    8fcc:	18 a5       	ldd	r17, Y+40	; 0x28
    8fce:	0e 94 16 70 	call	0xe02c	; 0xe02c <__subdi3>
    8fd2:	0f e0       	ldi	r16, 0x0F	; 15
    8fd4:	0e 94 fe 6f 	call	0xdffc	; 0xdffc <__ashrdi3>
    8fd8:	27 96       	adiw	r28, 0x07	; 7
    8fda:	ae ad       	ldd	r26, Y+62	; 0x3e
    8fdc:	bf ad       	ldd	r27, Y+63	; 0x3f
    8fde:	27 97       	sbiw	r28, 0x07	; 7
    8fe0:	1e 96       	adiw	r26, 0x0e	; 14
    8fe2:	2c 93       	st	X, r18
    8fe4:	1e 97       	sbiw	r26, 0x0e	; 14
    8fe6:	1f 96       	adiw	r26, 0x0f	; 15
    8fe8:	3c 93       	st	X, r19
    8fea:	1f 97       	sbiw	r26, 0x0f	; 15
    8fec:	50 96       	adiw	r26, 0x10	; 16
    8fee:	4c 93       	st	X, r20
    8ff0:	50 97       	sbiw	r26, 0x10	; 16
    8ff2:	51 96       	adiw	r26, 0x11	; 17
    8ff4:	5c 93       	st	X, r21
    8ff6:	51 97       	sbiw	r26, 0x11	; 17
	temperatureCelcius = temp;
    8ff8:	3d 89       	ldd	r19, Y+21	; 0x15
    8ffa:	2e 89       	ldd	r18, Y+22	; 0x16
    8ffc:	9f 89       	ldd	r25, Y+23	; 0x17
    8ffe:	88 8d       	ldd	r24, Y+24	; 0x18
    9000:	1a 96       	adiw	r26, 0x0a	; 10
    9002:	3c 93       	st	X, r19
    9004:	1a 97       	sbiw	r26, 0x0a	; 10
    9006:	1b 96       	adiw	r26, 0x0b	; 11
    9008:	2c 93       	st	X, r18
    900a:	1b 97       	sbiw	r26, 0x0b	; 11
    900c:	1c 96       	adiw	r26, 0x0c	; 12
    900e:	9c 93       	st	X, r25
    9010:	1c 97       	sbiw	r26, 0x0c	; 12
    9012:	1d 96       	adiw	r26, 0x0d	; 13
    9014:	8c 93       	st	X, r24
}
    9016:	c8 5b       	subi	r28, 0xB8	; 184
    9018:	df 4f       	sbci	r29, 0xFF	; 255
    901a:	0f b6       	in	r0, 0x3f	; 63
    901c:	f8 94       	cli
    901e:	de bf       	out	0x3e, r29	; 62
    9020:	0f be       	out	0x3f, r0	; 63
    9022:	cd bf       	out	0x3d, r28	; 61
    9024:	df 91       	pop	r29
    9026:	cf 91       	pop	r28
    9028:	1f 91       	pop	r17
    902a:	0f 91       	pop	r16
    902c:	ff 90       	pop	r15
    902e:	ef 90       	pop	r14
    9030:	df 90       	pop	r13
    9032:	cf 90       	pop	r12
    9034:	bf 90       	pop	r11
    9036:	af 90       	pop	r10
    9038:	9f 90       	pop	r9
    903a:	8f 90       	pop	r8
    903c:	7f 90       	pop	r7
    903e:	6f 90       	pop	r6
    9040:	5f 90       	pop	r5
    9042:	4f 90       	pop	r4
    9044:	3f 90       	pop	r3
    9046:	2f 90       	pop	r2
    9048:	08 95       	ret

0000904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>:
	
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
    904a:	af 92       	push	r10
    904c:	bf 92       	push	r11
    904e:	cf 92       	push	r12
    9050:	df 92       	push	r13
    9052:	ef 92       	push	r14
    9054:	ff 92       	push	r15
    9056:	0f 93       	push	r16
    9058:	1f 93       	push	r17
    905a:	cf 93       	push	r28
    905c:	df 93       	push	r29
    905e:	1f 92       	push	r1
    9060:	cd b7       	in	r28, 0x3d	; 61
    9062:	de b7       	in	r29, 0x3e	; 62
    9064:	8c 01       	movw	r16, r24
	int status = 0;
	byte b = 0;
    9066:	19 82       	std	Y+1, r1	; 0x01
	
	unsigned long currentFourBytes = 0;
    9068:	c1 2c       	mov	r12, r1
    906a:	d1 2c       	mov	r13, r1
    906c:	76 01       	movw	r14, r12
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
	int status = 0;
    906e:	80 e0       	ldi	r24, 0x00	; 0
    9070:	90 e0       	ldi	r25, 0x00	; 0
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
    9072:	00 97       	sbiw	r24, 0x00	; 0
    9074:	09 f0       	breq	.+2      	; 0x9078 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x2e>
    9076:	5a c0       	rjmp	.+180    	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    9078:	21 e0       	ldi	r18, 0x01	; 1
    907a:	c2 16       	cp	r12, r18
    907c:	25 e0       	ldi	r18, 0x05	; 5
    907e:	d2 06       	cpc	r13, r18
    9080:	22 e6       	ldi	r18, 0x62	; 98
    9082:	e2 06       	cpc	r14, r18
    9084:	25 eb       	ldi	r18, 0xB5	; 181
    9086:	f2 06       	cpc	r15, r18
    9088:	09 f4       	brne	.+2      	; 0x908c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x42>
    908a:	4a c0       	rjmp	.+148    	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xd6>
    908c:	c1 14       	cp	r12, r1
    908e:	a5 e0       	ldi	r26, 0x05	; 5
    9090:	da 06       	cpc	r13, r26
    9092:	a2 e6       	ldi	r26, 0x62	; 98
    9094:	ea 06       	cpc	r14, r26
    9096:	a5 eb       	ldi	r26, 0xB5	; 181
    9098:	fa 06       	cpc	r15, r26
    909a:	01 f5       	brne	.+64     	; 0x90dc <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x92>
    909c:	41 c0       	rjmp	.+130    	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xd6>
    909e:	b1 e0       	ldi	r27, 0x01	; 1
    90a0:	ab 1a       	sub	r10, r27
    90a2:	b1 08       	sbc	r11, r1
		ackNackData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
    90a4:	19 f0       	breq	.+6      	; 0x90ac <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x62>
    90a6:	00 97       	sbiw	r24, 0x00	; 0
    90a8:	69 f1       	breq	.+90     	; 0x9104 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xba>
    90aa:	40 c0       	rjmp	.+128    	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
		
			ackNackData[i] = b;
		}
	}	
	
	if (status == 0 && currentFourBytes == ackHeaderID)
    90ac:	00 97       	sbiw	r24, 0x00	; 0
    90ae:	f1 f5       	brne	.+124    	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    90b0:	e1 e0       	ldi	r30, 0x01	; 1
    90b2:	ce 16       	cp	r12, r30
    90b4:	e5 e0       	ldi	r30, 0x05	; 5
    90b6:	de 06       	cpc	r13, r30
    90b8:	e2 e6       	ldi	r30, 0x62	; 98
    90ba:	ee 06       	cpc	r14, r30
    90bc:	e5 eb       	ldi	r30, 0xB5	; 181
    90be:	fe 06       	cpc	r15, r30
    90c0:	49 f0       	breq	.+18     	; 0x90d4 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x8a>
	{
		return 0;
	}else if (status == 0 && currentFourBytes == nackHeaderID)
    90c2:	c1 14       	cp	r12, r1
    90c4:	f5 e0       	ldi	r31, 0x05	; 5
    90c6:	df 06       	cpc	r13, r31
    90c8:	f2 e6       	ldi	r31, 0x62	; 98
    90ca:	ef 06       	cpc	r14, r31
    90cc:	f5 eb       	ldi	r31, 0xB5	; 181
    90ce:	ff 06       	cpc	r15, r31
    90d0:	11 f0       	breq	.+4      	; 0x90d6 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x8c>
    90d2:	2c c0       	rjmp	.+88     	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    90d4:	2b c0       	rjmp	.+86     	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
	{
		return 1;
    90d6:	81 e0       	ldi	r24, 0x01	; 1
    90d8:	90 e0       	ldi	r25, 0x00	; 0
    90da:	28 c0       	rjmp	.+80     	; 0x912c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
	{
		status = serialDriver->receive(b);
    90dc:	d8 01       	movw	r26, r16
    90de:	8d 91       	ld	r24, X+
    90e0:	9c 91       	ld	r25, X
    90e2:	dc 01       	movw	r26, r24
    90e4:	ed 91       	ld	r30, X+
    90e6:	fc 91       	ld	r31, X
    90e8:	02 88       	ldd	r0, Z+18	; 0x12
    90ea:	f3 89       	ldd	r31, Z+19	; 0x13
    90ec:	e0 2d       	mov	r30, r0
    90ee:	be 01       	movw	r22, r28
    90f0:	6f 5f       	subi	r22, 0xFF	; 255
    90f2:	7f 4f       	sbci	r23, 0xFF	; 255
    90f4:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    90f6:	fe 2c       	mov	r15, r14
    90f8:	ed 2c       	mov	r14, r13
    90fa:	dc 2c       	mov	r13, r12
    90fc:	cc 24       	eor	r12, r12
    90fe:	29 81       	ldd	r18, Y+1	; 0x01
    9100:	c2 2a       	or	r12, r18
    9102:	b7 cf       	rjmp	.-146    	; 0x9072 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x28>
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
		{
			status = serialDriver->receive(b);
    9104:	f8 01       	movw	r30, r16
    9106:	80 81       	ld	r24, Z
    9108:	91 81       	ldd	r25, Z+1	; 0x01
    910a:	dc 01       	movw	r26, r24
    910c:	ed 91       	ld	r30, X+
    910e:	fc 91       	ld	r31, X
    9110:	02 88       	ldd	r0, Z+18	; 0x12
    9112:	f3 89       	ldd	r31, Z+19	; 0x13
    9114:	e0 2d       	mov	r30, r0
    9116:	be 01       	movw	r22, r28
    9118:	6f 5f       	subi	r22, 0xFF	; 255
    911a:	7f 4f       	sbci	r23, 0xFF	; 255
    911c:	19 95       	eicall
    911e:	bf cf       	rjmp	.-130    	; 0x909e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x54>
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
	int status = 0;
    9120:	0f 2e       	mov	r0, r31
    9122:	f7 e0       	ldi	r31, 0x07	; 7
    9124:	af 2e       	mov	r10, r31
    9126:	b1 2c       	mov	r11, r1
    9128:	f0 2d       	mov	r31, r0
    912a:	b9 cf       	rjmp	.-142    	; 0x909e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x54>
	{
		return 1;
	}
		
	return status;
}
    912c:	0f 90       	pop	r0
    912e:	df 91       	pop	r29
    9130:	cf 91       	pop	r28
    9132:	1f 91       	pop	r17
    9134:	0f 91       	pop	r16
    9136:	ff 90       	pop	r15
    9138:	ef 90       	pop	r14
    913a:	df 90       	pop	r13
    913c:	cf 90       	pop	r12
    913e:	bf 90       	pop	r11
    9140:	af 90       	pop	r10
    9142:	08 95       	ret

00009144 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>:


int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
{
    9144:	4f 92       	push	r4
    9146:	5f 92       	push	r5
    9148:	6f 92       	push	r6
    914a:	7f 92       	push	r7
    914c:	8f 92       	push	r8
    914e:	9f 92       	push	r9
    9150:	af 92       	push	r10
    9152:	bf 92       	push	r11
    9154:	cf 92       	push	r12
    9156:	df 92       	push	r13
    9158:	ef 92       	push	r14
    915a:	ff 92       	push	r15
    915c:	0f 93       	push	r16
    915e:	1f 93       	push	r17
    9160:	cf 93       	push	r28
    9162:	df 93       	push	r29
    9164:	1f 92       	push	r1
    9166:	cd b7       	in	r28, 0x3d	; 61
    9168:	de b7       	in	r29, 0x3e	; 62
    916a:	6c 01       	movw	r12, r24
    916c:	2a 01       	movw	r4, r20
    916e:	3b 01       	movw	r6, r22
    9170:	79 01       	movw	r14, r18
	int status = 0;
	byte b = 0;
    9172:	19 82       	std	Y+1, r1	; 0x01
	
	unsigned long currentFourBytes = 0;
    9174:	81 2c       	mov	r8, r1
    9176:	91 2c       	mov	r9, r1
    9178:	54 01       	movw	r10, r8
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    917a:	84 14       	cp	r8, r4
    917c:	95 04       	cpc	r9, r5
    917e:	a6 04       	cpc	r10, r6
    9180:	b7 04       	cpc	r11, r7
    9182:	e1 f4       	brne	.+56     	; 0x91bc <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x78>
    9184:	07 c0       	rjmp	.+14     	; 0x9194 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x50>
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    9186:	a0 16       	cp	r10, r16
    9188:	b1 06       	cpc	r11, r17
    918a:	0c f0       	brlt	.+2      	; 0x918e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x4a>
    918c:	42 c0       	rjmp	.+132    	; 0x9212 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
    918e:	00 97       	sbiw	r24, 0x00	; 0
    9190:	59 f1       	breq	.+86     	; 0x91e8 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xa4>
    9192:	3f c0       	rjmp	.+126    	; 0x9212 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
	if (status == 0)
	{
		/**
		* Populate the message array with the first four bytes.
		*/
		msgData[0] = 0xFF & (currentFourBytes >> 24);
    9194:	d7 01       	movw	r26, r14
    9196:	bc 92       	st	X, r11
		msgData[1] = 0xFF & (currentFourBytes >> 16);
    9198:	11 96       	adiw	r26, 0x01	; 1
    919a:	ac 92       	st	X, r10
    919c:	11 97       	sbiw	r26, 0x01	; 1
		msgData[2] = 0xFF & (currentFourBytes >> 8);
    919e:	12 96       	adiw	r26, 0x02	; 2
    91a0:	9c 92       	st	X, r9
    91a2:	12 97       	sbiw	r26, 0x02	; 2
		msgData[3] = 0xFF & currentFourBytes;
    91a4:	13 96       	adiw	r26, 0x03	; 3
    91a6:	8c 92       	st	X, r8
		
	return status;
}


int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
    91a8:	b4 e0       	ldi	r27, 0x04	; 4
    91aa:	eb 0e       	add	r14, r27
    91ac:	f1 1c       	adc	r15, r1
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    91ae:	68 94       	set
    91b0:	aa 24       	eor	r10, r10
    91b2:	a2 f8       	bld	r10, 2
    91b4:	b1 2c       	mov	r11, r1
    91b6:	80 e0       	ldi	r24, 0x00	; 0
    91b8:	90 e0       	ldi	r25, 0x00	; 0
    91ba:	e5 cf       	rjmp	.-54     	; 0x9186 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x42>
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
	{
		status = serialDriver->receive(b);
    91bc:	f6 01       	movw	r30, r12
    91be:	80 81       	ld	r24, Z
    91c0:	91 81       	ldd	r25, Z+1	; 0x01
    91c2:	dc 01       	movw	r26, r24
    91c4:	ed 91       	ld	r30, X+
    91c6:	fc 91       	ld	r31, X
    91c8:	02 88       	ldd	r0, Z+18	; 0x12
    91ca:	f3 89       	ldd	r31, Z+19	; 0x13
    91cc:	e0 2d       	mov	r30, r0
    91ce:	be 01       	movw	r22, r28
    91d0:	6f 5f       	subi	r22, 0xFF	; 255
    91d2:	7f 4f       	sbci	r23, 0xFF	; 255
    91d4:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    91d6:	ba 2c       	mov	r11, r10
    91d8:	a9 2c       	mov	r10, r9
    91da:	98 2c       	mov	r9, r8
    91dc:	88 24       	eor	r8, r8
    91de:	29 81       	ldd	r18, Y+1	; 0x01
    91e0:	82 2a       	or	r8, r18
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    91e2:	00 97       	sbiw	r24, 0x00	; 0
    91e4:	b1 f4       	brne	.+44     	; 0x9212 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
    91e6:	c9 cf       	rjmp	.-110    	; 0x917a <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x36>
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
		{
			status = serialDriver->receive(b);
    91e8:	f6 01       	movw	r30, r12
    91ea:	80 81       	ld	r24, Z
    91ec:	91 81       	ldd	r25, Z+1	; 0x01
    91ee:	dc 01       	movw	r26, r24
    91f0:	ed 91       	ld	r30, X+
    91f2:	fc 91       	ld	r31, X
    91f4:	02 88       	ldd	r0, Z+18	; 0x12
    91f6:	f3 89       	ldd	r31, Z+19	; 0x13
    91f8:	e0 2d       	mov	r30, r0
    91fa:	be 01       	movw	r22, r28
    91fc:	6f 5f       	subi	r22, 0xFF	; 255
    91fe:	7f 4f       	sbci	r23, 0xFF	; 255
    9200:	19 95       	eicall
		
			msgData[i] = b;
    9202:	29 81       	ldd	r18, Y+1	; 0x01
    9204:	f7 01       	movw	r30, r14
    9206:	21 93       	st	Z+, r18
    9208:	7f 01       	movw	r14, r30
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    920a:	ff ef       	ldi	r31, 0xFF	; 255
    920c:	af 1a       	sub	r10, r31
    920e:	bf 0a       	sbc	r11, r31
    9210:	ba cf       	rjmp	.-140    	; 0x9186 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x42>
			msgData[i] = b;
		}
	}	
		
	return status;
}
    9212:	0f 90       	pop	r0
    9214:	df 91       	pop	r29
    9216:	cf 91       	pop	r28
    9218:	1f 91       	pop	r17
    921a:	0f 91       	pop	r16
    921c:	ff 90       	pop	r15
    921e:	ef 90       	pop	r14
    9220:	df 90       	pop	r13
    9222:	cf 90       	pop	r12
    9224:	bf 90       	pop	r11
    9226:	af 90       	pop	r10
    9228:	9f 90       	pop	r9
    922a:	8f 90       	pop	r8
    922c:	7f 90       	pop	r7
    922e:	6f 90       	pop	r6
    9230:	5f 90       	pop	r5
    9232:	4f 90       	pop	r4
    9234:	08 95       	ret

00009236 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>:

int GPSSensor::readSensor(byte *pollMsg, int pollMsgSize, byte *msgData, int msgDataSize )
{
    9236:	af 92       	push	r10
    9238:	bf 92       	push	r11
    923a:	cf 92       	push	r12
    923c:	df 92       	push	r13
    923e:	ef 92       	push	r14
    9240:	ff 92       	push	r15
    9242:	0f 93       	push	r16
    9244:	1f 93       	push	r17
    9246:	cf 93       	push	r28
    9248:	df 93       	push	r29
    924a:	ec 01       	movw	r28, r24
    924c:	6b 01       	movw	r12, r22
    924e:	5a 01       	movw	r10, r20
    9250:	79 01       	movw	r14, r18
	
	//Clear the serial driver's buffer of any existing data.
	//serialDriver->clearBuffer();
	
	//Start timer
	serialDriver->startTimer();
    9252:	88 81       	ld	r24, Y
    9254:	99 81       	ldd	r25, Y+1	; 0x01
    9256:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
	
	
	//Send poll command
	status = serialDriver->transmit((const char*)pollMsg, pollMsgSize);
    925a:	a5 01       	movw	r20, r10
    925c:	b6 01       	movw	r22, r12
    925e:	88 81       	ld	r24, Y
    9260:	99 81       	ldd	r25, Y+1	; 0x01
    9262:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
    9266:	5c 01       	movw	r10, r24
	
	if (status == 0)
    9268:	00 97       	sbiw	r24, 0x00	; 0
    926a:	99 f4       	brne	.+38     	; 0x9292 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i+0x5c>
		 * against the incoming header and ID field.
		 */
		unsigned long desiredHeaderID = (unsigned long) pollMsg[0] << 24 | 
										(unsigned long) pollMsg[1] << 16 | 
										(unsigned long) pollMsg[2] << 8 | 
										(unsigned long) pollMsg[3];
    926c:	f6 01       	movw	r30, r12
    926e:	80 81       	ld	r24, Z
    9270:	41 81       	ldd	r20, Z+1	; 0x01
    9272:	50 e0       	ldi	r21, 0x00	; 0
    9274:	60 e0       	ldi	r22, 0x00	; 0
    9276:	70 e0       	ldi	r23, 0x00	; 0
    9278:	ba 01       	movw	r22, r20
    927a:	55 27       	eor	r21, r21
    927c:	44 27       	eor	r20, r20
    927e:	78 2b       	or	r23, r24
    9280:	83 81       	ldd	r24, Z+3	; 0x03
    9282:	48 2b       	or	r20, r24
    9284:	82 81       	ldd	r24, Z+2	; 0x02
    9286:	58 2b       	or	r21, r24
										
		status = receiveGpsData(desiredHeaderID, msgData, msgDataSize);
    9288:	97 01       	movw	r18, r14
    928a:	ce 01       	movw	r24, r28
    928c:	0e 94 a2 48 	call	0x9144	; 0x9144 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>
    9290:	5c 01       	movw	r10, r24

	}
	

	//Stop timer
	serialDriver->stopTimer();
    9292:	88 81       	ld	r24, Y
    9294:	99 81       	ldd	r25, Y+1	; 0x01
    9296:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
}
    929a:	8a 2d       	mov	r24, r10
    929c:	9b 2d       	mov	r25, r11
    929e:	df 91       	pop	r29
    92a0:	cf 91       	pop	r28
    92a2:	1f 91       	pop	r17
    92a4:	0f 91       	pop	r16
    92a6:	ff 90       	pop	r15
    92a8:	ef 90       	pop	r14
    92aa:	df 90       	pop	r13
    92ac:	cf 90       	pop	r12
    92ae:	bf 90       	pop	r11
    92b0:	af 90       	pop	r10
    92b2:	08 95       	ret

000092b4 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>:
	return status;
}


int GPSSensor::processSensorSolution()
{
    92b4:	fc 01       	movw	r30, r24
	int status = 0;
	
	if (navSolMsgReceived)
    92b6:	80 91 aa 03 	lds	r24, 0x03AA
    92ba:	88 23       	and	r24, r24
    92bc:	09 f4       	brne	.+2      	; 0x92c0 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0xc>
    92be:	bd c0       	rjmp	.+378    	; 0x943a <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x186>
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];		
		*/
		

		positionFixStatus =  navSolMsgBuffer2[16] >= 3 ? VALID : INVALID;
    92c0:	80 91 bd 03 	lds	r24, 0x03BD
    92c4:	83 30       	cpi	r24, 0x03	; 3
    92c6:	10 f0       	brcs	.+4      	; 0x92cc <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18>
    92c8:	82 e0       	ldi	r24, 0x02	; 2
    92ca:	01 c0       	rjmp	.+2      	; 0x92ce <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x1a>
    92cc:	81 e0       	ldi	r24, 0x01	; 1
    92ce:	82 a7       	std	Z+42, r24	; 0x2a

		//Parse position info
		xEcefCm =  ((long)navSolMsgBuffer2[21] << 24) | ((long)navSolMsgBuffer2[20] << 16) | ((long)navSolMsgBuffer2[19] << 8) | (long) navSolMsgBuffer2[18];
    92d0:	20 91 c2 03 	lds	r18, 0x03C2
    92d4:	80 91 c1 03 	lds	r24, 0x03C1
    92d8:	90 e0       	ldi	r25, 0x00	; 0
    92da:	a0 e0       	ldi	r26, 0x00	; 0
    92dc:	b0 e0       	ldi	r27, 0x00	; 0
    92de:	dc 01       	movw	r26, r24
    92e0:	99 27       	eor	r25, r25
    92e2:	88 27       	eor	r24, r24
    92e4:	b2 2b       	or	r27, r18
    92e6:	20 91 bf 03 	lds	r18, 0x03BF
    92ea:	82 2b       	or	r24, r18
    92ec:	20 91 c0 03 	lds	r18, 0x03C0
    92f0:	92 2b       	or	r25, r18
    92f2:	82 87       	std	Z+10, r24	; 0x0a
    92f4:	93 87       	std	Z+11, r25	; 0x0b
    92f6:	a4 87       	std	Z+12, r26	; 0x0c
    92f8:	b5 87       	std	Z+13, r27	; 0x0d
		yEcefCm =  ((long)navSolMsgBuffer2[25] << 24) | ((long)navSolMsgBuffer2[24] << 16) | ((long)navSolMsgBuffer2[23] << 8) | (long) navSolMsgBuffer2[22];
    92fa:	20 91 c6 03 	lds	r18, 0x03C6
    92fe:	80 91 c5 03 	lds	r24, 0x03C5
    9302:	90 e0       	ldi	r25, 0x00	; 0
    9304:	a0 e0       	ldi	r26, 0x00	; 0
    9306:	b0 e0       	ldi	r27, 0x00	; 0
    9308:	dc 01       	movw	r26, r24
    930a:	99 27       	eor	r25, r25
    930c:	88 27       	eor	r24, r24
    930e:	b2 2b       	or	r27, r18
    9310:	20 91 c3 03 	lds	r18, 0x03C3
    9314:	82 2b       	or	r24, r18
    9316:	20 91 c4 03 	lds	r18, 0x03C4
    931a:	92 2b       	or	r25, r18
    931c:	86 87       	std	Z+14, r24	; 0x0e
    931e:	97 87       	std	Z+15, r25	; 0x0f
    9320:	a0 8b       	std	Z+16, r26	; 0x10
    9322:	b1 8b       	std	Z+17, r27	; 0x11
		zEcefCm =  ((long)navSolMsgBuffer2[29] << 24) | ((long)navSolMsgBuffer2[28] << 16) | ((long)navSolMsgBuffer2[27] << 8) | (long) navSolMsgBuffer2[26];
    9324:	20 91 ca 03 	lds	r18, 0x03CA
    9328:	80 91 c9 03 	lds	r24, 0x03C9
    932c:	90 e0       	ldi	r25, 0x00	; 0
    932e:	a0 e0       	ldi	r26, 0x00	; 0
    9330:	b0 e0       	ldi	r27, 0x00	; 0
    9332:	dc 01       	movw	r26, r24
    9334:	99 27       	eor	r25, r25
    9336:	88 27       	eor	r24, r24
    9338:	b2 2b       	or	r27, r18
    933a:	20 91 c7 03 	lds	r18, 0x03C7
    933e:	82 2b       	or	r24, r18
    9340:	20 91 c8 03 	lds	r18, 0x03C8
    9344:	92 2b       	or	r25, r18
    9346:	82 8b       	std	Z+18, r24	; 0x12
    9348:	93 8b       	std	Z+19, r25	; 0x13
    934a:	a4 8b       	std	Z+20, r26	; 0x14
    934c:	b5 8b       	std	Z+21, r27	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsgBuffer2[33] << 24) | ((long)navSolMsgBuffer2[32] << 16) | ((long)navSolMsgBuffer2[31] << 8) | (long) navSolMsgBuffer2[30];
    934e:	20 91 ce 03 	lds	r18, 0x03CE
    9352:	80 91 cd 03 	lds	r24, 0x03CD
    9356:	90 e0       	ldi	r25, 0x00	; 0
    9358:	a0 e0       	ldi	r26, 0x00	; 0
    935a:	b0 e0       	ldi	r27, 0x00	; 0
    935c:	dc 01       	movw	r26, r24
    935e:	99 27       	eor	r25, r25
    9360:	88 27       	eor	r24, r24
    9362:	b2 2b       	or	r27, r18
    9364:	20 91 cb 03 	lds	r18, 0x03CB
    9368:	82 2b       	or	r24, r18
    936a:	20 91 cc 03 	lds	r18, 0x03CC
    936e:	92 2b       	or	r25, r18
    9370:	86 8b       	std	Z+22, r24	; 0x16
    9372:	97 8b       	std	Z+23, r25	; 0x17
    9374:	a0 8f       	std	Z+24, r26	; 0x18
    9376:	b1 8f       	std	Z+25, r27	; 0x19

		//Parse velocity info
		xVEcefCms =  ((long)navSolMsgBuffer2[37] << 24) | ((long)navSolMsgBuffer2[36] << 16) | ((long)navSolMsgBuffer2[35] << 8) | (long) navSolMsgBuffer2[34];
    9378:	20 91 d2 03 	lds	r18, 0x03D2
    937c:	80 91 d1 03 	lds	r24, 0x03D1
    9380:	90 e0       	ldi	r25, 0x00	; 0
    9382:	a0 e0       	ldi	r26, 0x00	; 0
    9384:	b0 e0       	ldi	r27, 0x00	; 0
    9386:	dc 01       	movw	r26, r24
    9388:	99 27       	eor	r25, r25
    938a:	88 27       	eor	r24, r24
    938c:	b2 2b       	or	r27, r18
    938e:	20 91 cf 03 	lds	r18, 0x03CF
    9392:	82 2b       	or	r24, r18
    9394:	20 91 d0 03 	lds	r18, 0x03D0
    9398:	92 2b       	or	r25, r18
    939a:	82 8f       	std	Z+26, r24	; 0x1a
    939c:	93 8f       	std	Z+27, r25	; 0x1b
    939e:	a4 8f       	std	Z+28, r26	; 0x1c
    93a0:	b5 8f       	std	Z+29, r27	; 0x1d
		yVEcefCms =  ((long)navSolMsgBuffer2[41] << 24) | ((long)navSolMsgBuffer2[40] << 16) | ((long)navSolMsgBuffer2[39] << 8) | (long) navSolMsgBuffer2[38];
    93a2:	20 91 d6 03 	lds	r18, 0x03D6
    93a6:	80 91 d5 03 	lds	r24, 0x03D5
    93aa:	90 e0       	ldi	r25, 0x00	; 0
    93ac:	a0 e0       	ldi	r26, 0x00	; 0
    93ae:	b0 e0       	ldi	r27, 0x00	; 0
    93b0:	dc 01       	movw	r26, r24
    93b2:	99 27       	eor	r25, r25
    93b4:	88 27       	eor	r24, r24
    93b6:	b2 2b       	or	r27, r18
    93b8:	20 91 d3 03 	lds	r18, 0x03D3
    93bc:	82 2b       	or	r24, r18
    93be:	20 91 d4 03 	lds	r18, 0x03D4
    93c2:	92 2b       	or	r25, r18
    93c4:	86 8f       	std	Z+30, r24	; 0x1e
    93c6:	97 8f       	std	Z+31, r25	; 0x1f
    93c8:	a0 a3       	std	Z+32, r26	; 0x20
    93ca:	b1 a3       	std	Z+33, r27	; 0x21
		zVEcefCms =  ((long)navSolMsgBuffer2[45] << 24) | ((long)navSolMsgBuffer2[44] << 16) | ((long)navSolMsgBuffer2[43] << 8) | (long) navSolMsgBuffer2[42];
    93cc:	20 91 da 03 	lds	r18, 0x03DA
    93d0:	80 91 d9 03 	lds	r24, 0x03D9
    93d4:	90 e0       	ldi	r25, 0x00	; 0
    93d6:	a0 e0       	ldi	r26, 0x00	; 0
    93d8:	b0 e0       	ldi	r27, 0x00	; 0
    93da:	dc 01       	movw	r26, r24
    93dc:	99 27       	eor	r25, r25
    93de:	88 27       	eor	r24, r24
    93e0:	b2 2b       	or	r27, r18
    93e2:	20 91 d7 03 	lds	r18, 0x03D7
    93e6:	82 2b       	or	r24, r18
    93e8:	20 91 d8 03 	lds	r18, 0x03D8
    93ec:	92 2b       	or	r25, r18
    93ee:	82 a3       	std	Z+34, r24	; 0x22
    93f0:	93 a3       	std	Z+35, r25	; 0x23
    93f2:	a4 a3       	std	Z+36, r26	; 0x24
    93f4:	b5 a3       	std	Z+37, r27	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsgBuffer2[49] << 24) | ((long)navSolMsgBuffer2[48] << 16) | ((long)navSolMsgBuffer2[47] << 8) | (long) navSolMsgBuffer2[46];
    93f6:	80 91 de 03 	lds	r24, 0x03DE
    93fa:	40 91 dd 03 	lds	r20, 0x03DD
    93fe:	50 e0       	ldi	r21, 0x00	; 0
    9400:	60 e0       	ldi	r22, 0x00	; 0
    9402:	70 e0       	ldi	r23, 0x00	; 0
    9404:	ba 01       	movw	r22, r20
    9406:	55 27       	eor	r21, r21
    9408:	44 27       	eor	r20, r20
    940a:	78 2b       	or	r23, r24
    940c:	80 91 db 03 	lds	r24, 0x03DB
    9410:	48 2b       	or	r20, r24
    9412:	80 91 dc 03 	lds	r24, 0x03DC
    9416:	58 2b       	or	r21, r24
    9418:	46 a3       	std	Z+38, r20	; 0x26
    941a:	57 a3       	std	Z+39, r21	; 0x27
    941c:	60 a7       	std	Z+40, r22	; 0x28
    941e:	71 a7       	std	Z+41, r23	; 0x29

		
		navSolMsgReceived = false;
    9420:	10 92 aa 03 	sts	0x03AA, r1
		processing = false;
    9424:	10 92 a8 03 	sts	0x03A8, r1
		
		
		if (crcError)
    9428:	80 91 a9 03 	lds	r24, 0x03A9
    942c:	88 23       	and	r24, r24
    942e:	41 f0       	breq	.+16     	; 0x9440 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18c>
		{
			status = -1;
			crcError = false;
    9430:	10 92 a9 03 	sts	0x03A9, r1
		processing = false;
		
		
		if (crcError)
		{
			status = -1;
    9434:	2f ef       	ldi	r18, 0xFF	; 255
    9436:	3f ef       	ldi	r19, 0xFF	; 255
    9438:	05 c0       	rjmp	.+10     	; 0x9444 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x190>
}


int GPSSensor::processSensorSolution()
{
	int status = 0;
    943a:	20 e0       	ldi	r18, 0x00	; 0
    943c:	30 e0       	ldi	r19, 0x00	; 0
    943e:	02 c0       	rjmp	.+4      	; 0x9444 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x190>
    9440:	20 e0       	ldi	r18, 0x00	; 0
    9442:	30 e0       	ldi	r19, 0x00	; 0
		
		
	}
	
	return status;
}
    9444:	82 2f       	mov	r24, r18
    9446:	93 2f       	mov	r25, r19
    9448:	08 95       	ret

0000944a <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>:

int GPSSensor::readSensorSolution()
{
    944a:	ef 92       	push	r14
    944c:	ff 92       	push	r15
    944e:	0f 93       	push	r16
    9450:	1f 93       	push	r17
    9452:	cf 93       	push	r28
    9454:	df 93       	push	r29
    9456:	cd b7       	in	r28, 0x3d	; 61
    9458:	de b7       	in	r29, 0x3e	; 62
    945a:	ec 97       	sbiw	r28, 0x3c	; 60
    945c:	0f b6       	in	r0, 0x3f	; 63
    945e:	f8 94       	cli
    9460:	de bf       	out	0x3e, r29	; 62
    9462:	0f be       	out	0x3f, r0	; 63
    9464:	cd bf       	out	0x3d, r28	; 61
    9466:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte navSolMsg[60] = {0};
    9468:	9e 01       	movw	r18, r28
    946a:	2f 5f       	subi	r18, 0xFF	; 255
    946c:	3f 4f       	sbci	r19, 0xFF	; 255
    946e:	8c e3       	ldi	r24, 0x3C	; 60
    9470:	f9 01       	movw	r30, r18
    9472:	11 92       	st	Z+, r1
    9474:	8a 95       	dec	r24
    9476:	e9 f7       	brne	.-6      	; 0x9472 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x28>
	
	status = readSensor((byte *)NAV_SOL_POLLMSG, sizeof(NAV_SOL_POLLMSG), navSolMsg, sizeof(navSolMsg));
    9478:	0c e3       	ldi	r16, 0x3C	; 60
    947a:	10 e0       	ldi	r17, 0x00	; 0
    947c:	48 e0       	ldi	r20, 0x08	; 8
    947e:	50 e0       	ldi	r21, 0x00	; 0
    9480:	66 ed       	ldi	r22, 0xD6	; 214
    9482:	72 e0       	ldi	r23, 0x02	; 2
    9484:	c7 01       	movw	r24, r14
    9486:	0e 94 1b 49 	call	0x9236	; 0x9236 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    948a:	9c 01       	movw	r18, r24
	
	if (status == 0)
    948c:	00 97       	sbiw	r24, 0x00	; 0
    948e:	09 f0       	breq	.+2      	; 0x9492 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x48>
    9490:	90 c0       	rjmp	.+288    	; 0x95b2 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x168>
	{
		//Parse status info 
		positionFixStatus =  navSolMsg[16] >= 3 ? VALID : INVALID;
    9492:	89 89       	ldd	r24, Y+17	; 0x11
    9494:	83 30       	cpi	r24, 0x03	; 3
    9496:	10 f0       	brcs	.+4      	; 0x949c <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x52>
    9498:	82 e0       	ldi	r24, 0x02	; 2
    949a:	01 c0       	rjmp	.+2      	; 0x949e <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x54>
    949c:	81 e0       	ldi	r24, 0x01	; 1
    949e:	f7 01       	movw	r30, r14
    94a0:	82 a7       	std	Z+42, r24	; 0x2a
		
		//Parse position info
		xEcefCm =  ((long)navSolMsg[21] << 24) | ((long)navSolMsg[20] << 16) | ((long)navSolMsg[19] << 8) | (long) navSolMsg[18];
    94a2:	4e 89       	ldd	r20, Y+22	; 0x16
    94a4:	8d 89       	ldd	r24, Y+21	; 0x15
    94a6:	90 e0       	ldi	r25, 0x00	; 0
    94a8:	a0 e0       	ldi	r26, 0x00	; 0
    94aa:	b0 e0       	ldi	r27, 0x00	; 0
    94ac:	dc 01       	movw	r26, r24
    94ae:	99 27       	eor	r25, r25
    94b0:	88 27       	eor	r24, r24
    94b2:	b4 2b       	or	r27, r20
    94b4:	4b 89       	ldd	r20, Y+19	; 0x13
    94b6:	84 2b       	or	r24, r20
    94b8:	4c 89       	ldd	r20, Y+20	; 0x14
    94ba:	94 2b       	or	r25, r20
    94bc:	82 87       	std	Z+10, r24	; 0x0a
    94be:	93 87       	std	Z+11, r25	; 0x0b
    94c0:	a4 87       	std	Z+12, r26	; 0x0c
    94c2:	b5 87       	std	Z+13, r27	; 0x0d
		yEcefCm =  ((long)navSolMsg[25] << 24) | ((long)navSolMsg[24] << 16) | ((long)navSolMsg[23] << 8) | (long) navSolMsg[22];
    94c4:	4a 8d       	ldd	r20, Y+26	; 0x1a
    94c6:	89 8d       	ldd	r24, Y+25	; 0x19
    94c8:	90 e0       	ldi	r25, 0x00	; 0
    94ca:	a0 e0       	ldi	r26, 0x00	; 0
    94cc:	b0 e0       	ldi	r27, 0x00	; 0
    94ce:	dc 01       	movw	r26, r24
    94d0:	99 27       	eor	r25, r25
    94d2:	88 27       	eor	r24, r24
    94d4:	b4 2b       	or	r27, r20
    94d6:	4f 89       	ldd	r20, Y+23	; 0x17
    94d8:	84 2b       	or	r24, r20
    94da:	48 8d       	ldd	r20, Y+24	; 0x18
    94dc:	94 2b       	or	r25, r20
    94de:	86 87       	std	Z+14, r24	; 0x0e
    94e0:	97 87       	std	Z+15, r25	; 0x0f
    94e2:	a0 8b       	std	Z+16, r26	; 0x10
    94e4:	b1 8b       	std	Z+17, r27	; 0x11
		zEcefCm =  ((long)navSolMsg[29] << 24) | ((long)navSolMsg[28] << 16) | ((long)navSolMsg[27] << 8) | (long) navSolMsg[26];
    94e6:	4e 8d       	ldd	r20, Y+30	; 0x1e
    94e8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    94ea:	90 e0       	ldi	r25, 0x00	; 0
    94ec:	a0 e0       	ldi	r26, 0x00	; 0
    94ee:	b0 e0       	ldi	r27, 0x00	; 0
    94f0:	dc 01       	movw	r26, r24
    94f2:	99 27       	eor	r25, r25
    94f4:	88 27       	eor	r24, r24
    94f6:	b4 2b       	or	r27, r20
    94f8:	4b 8d       	ldd	r20, Y+27	; 0x1b
    94fa:	84 2b       	or	r24, r20
    94fc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    94fe:	94 2b       	or	r25, r20
    9500:	82 8b       	std	Z+18, r24	; 0x12
    9502:	93 8b       	std	Z+19, r25	; 0x13
    9504:	a4 8b       	std	Z+20, r26	; 0x14
    9506:	b5 8b       	std	Z+21, r27	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsg[33] << 24) | ((long)navSolMsg[32] << 16) | ((long)navSolMsg[31] << 8) | (long) navSolMsg[30];
    9508:	4a a1       	ldd	r20, Y+34	; 0x22
    950a:	89 a1       	ldd	r24, Y+33	; 0x21
    950c:	90 e0       	ldi	r25, 0x00	; 0
    950e:	a0 e0       	ldi	r26, 0x00	; 0
    9510:	b0 e0       	ldi	r27, 0x00	; 0
    9512:	dc 01       	movw	r26, r24
    9514:	99 27       	eor	r25, r25
    9516:	88 27       	eor	r24, r24
    9518:	b4 2b       	or	r27, r20
    951a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    951c:	84 2b       	or	r24, r20
    951e:	48 a1       	ldd	r20, Y+32	; 0x20
    9520:	94 2b       	or	r25, r20
    9522:	86 8b       	std	Z+22, r24	; 0x16
    9524:	97 8b       	std	Z+23, r25	; 0x17
    9526:	a0 8f       	std	Z+24, r26	; 0x18
    9528:	b1 8f       	std	Z+25, r27	; 0x19
		
		//Parse velocity info
		xVEcefCms =  ((long)navSolMsg[37] << 24) | ((long)navSolMsg[36] << 16) | ((long)navSolMsg[35] << 8) | (long) navSolMsg[34];
    952a:	4e a1       	ldd	r20, Y+38	; 0x26
    952c:	8d a1       	ldd	r24, Y+37	; 0x25
    952e:	90 e0       	ldi	r25, 0x00	; 0
    9530:	a0 e0       	ldi	r26, 0x00	; 0
    9532:	b0 e0       	ldi	r27, 0x00	; 0
    9534:	dc 01       	movw	r26, r24
    9536:	99 27       	eor	r25, r25
    9538:	88 27       	eor	r24, r24
    953a:	b4 2b       	or	r27, r20
    953c:	4b a1       	ldd	r20, Y+35	; 0x23
    953e:	84 2b       	or	r24, r20
    9540:	4c a1       	ldd	r20, Y+36	; 0x24
    9542:	94 2b       	or	r25, r20
    9544:	82 8f       	std	Z+26, r24	; 0x1a
    9546:	93 8f       	std	Z+27, r25	; 0x1b
    9548:	a4 8f       	std	Z+28, r26	; 0x1c
    954a:	b5 8f       	std	Z+29, r27	; 0x1d
		yVEcefCms =  ((long)navSolMsg[41] << 24) | ((long)navSolMsg[40] << 16) | ((long)navSolMsg[39] << 8) | (long) navSolMsg[38];
    954c:	4a a5       	ldd	r20, Y+42	; 0x2a
    954e:	89 a5       	ldd	r24, Y+41	; 0x29
    9550:	90 e0       	ldi	r25, 0x00	; 0
    9552:	a0 e0       	ldi	r26, 0x00	; 0
    9554:	b0 e0       	ldi	r27, 0x00	; 0
    9556:	dc 01       	movw	r26, r24
    9558:	99 27       	eor	r25, r25
    955a:	88 27       	eor	r24, r24
    955c:	b4 2b       	or	r27, r20
    955e:	4f a1       	ldd	r20, Y+39	; 0x27
    9560:	84 2b       	or	r24, r20
    9562:	48 a5       	ldd	r20, Y+40	; 0x28
    9564:	94 2b       	or	r25, r20
    9566:	86 8f       	std	Z+30, r24	; 0x1e
    9568:	97 8f       	std	Z+31, r25	; 0x1f
    956a:	a0 a3       	std	Z+32, r26	; 0x20
    956c:	b1 a3       	std	Z+33, r27	; 0x21
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
    956e:	4e a5       	ldd	r20, Y+46	; 0x2e
    9570:	8d a5       	ldd	r24, Y+45	; 0x2d
    9572:	90 e0       	ldi	r25, 0x00	; 0
    9574:	a0 e0       	ldi	r26, 0x00	; 0
    9576:	b0 e0       	ldi	r27, 0x00	; 0
    9578:	dc 01       	movw	r26, r24
    957a:	99 27       	eor	r25, r25
    957c:	88 27       	eor	r24, r24
    957e:	b4 2b       	or	r27, r20
    9580:	4b a5       	ldd	r20, Y+43	; 0x2b
    9582:	84 2b       	or	r24, r20
    9584:	4c a5       	ldd	r20, Y+44	; 0x2c
    9586:	94 2b       	or	r25, r20
    9588:	82 a3       	std	Z+34, r24	; 0x22
    958a:	93 a3       	std	Z+35, r25	; 0x23
    958c:	a4 a3       	std	Z+36, r26	; 0x24
    958e:	b5 a3       	std	Z+37, r27	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];
    9590:	8a a9       	ldd	r24, Y+50	; 0x32
    9592:	49 a9       	ldd	r20, Y+49	; 0x31
    9594:	50 e0       	ldi	r21, 0x00	; 0
    9596:	60 e0       	ldi	r22, 0x00	; 0
    9598:	70 e0       	ldi	r23, 0x00	; 0
    959a:	ba 01       	movw	r22, r20
    959c:	55 27       	eor	r21, r21
    959e:	44 27       	eor	r20, r20
    95a0:	78 2b       	or	r23, r24
    95a2:	8f a5       	ldd	r24, Y+47	; 0x2f
    95a4:	48 2b       	or	r20, r24
    95a6:	88 a9       	ldd	r24, Y+48	; 0x30
    95a8:	58 2b       	or	r21, r24
    95aa:	46 a3       	std	Z+38, r20	; 0x26
    95ac:	57 a3       	std	Z+39, r21	; 0x27
    95ae:	60 a7       	std	Z+40, r22	; 0x28
    95b0:	71 a7       	std	Z+41, r23	; 0x29
		
	}

	return status;
}
    95b2:	82 2f       	mov	r24, r18
    95b4:	93 2f       	mov	r25, r19
    95b6:	ec 96       	adiw	r28, 0x3c	; 60
    95b8:	0f b6       	in	r0, 0x3f	; 63
    95ba:	f8 94       	cli
    95bc:	de bf       	out	0x3e, r29	; 62
    95be:	0f be       	out	0x3f, r0	; 63
    95c0:	cd bf       	out	0x3d, r28	; 61
    95c2:	df 91       	pop	r29
    95c4:	cf 91       	pop	r28
    95c6:	1f 91       	pop	r17
    95c8:	0f 91       	pop	r16
    95ca:	ff 90       	pop	r15
    95cc:	ef 90       	pop	r14
    95ce:	08 95       	ret

000095d0 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>:


int GPSSensor::readSensorNavStatus()
{
    95d0:	ef 92       	push	r14
    95d2:	ff 92       	push	r15
    95d4:	0f 93       	push	r16
    95d6:	1f 93       	push	r17
    95d8:	cf 93       	push	r28
    95da:	df 93       	push	r29
    95dc:	cd b7       	in	r28, 0x3d	; 61
    95de:	de b7       	in	r29, 0x3e	; 62
    95e0:	66 97       	sbiw	r28, 0x16	; 22
    95e2:	0f b6       	in	r0, 0x3f	; 63
    95e4:	f8 94       	cli
    95e6:	de bf       	out	0x3e, r29	; 62
    95e8:	0f be       	out	0x3f, r0	; 63
    95ea:	cd bf       	out	0x3d, r28	; 61
    95ec:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte statusMsg[22] = {0};
    95ee:	9e 01       	movw	r18, r28
    95f0:	2f 5f       	subi	r18, 0xFF	; 255
    95f2:	3f 4f       	sbci	r19, 0xFF	; 255
    95f4:	86 e1       	ldi	r24, 0x16	; 22
    95f6:	f9 01       	movw	r30, r18
    95f8:	11 92       	st	Z+, r1
    95fa:	8a 95       	dec	r24
    95fc:	e9 f7       	brne	.-6      	; 0x95f8 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x28>
	
	status = readSensor((byte *)NAV_STATUS_POLLMSG, sizeof(NAV_STATUS_POLLMSG), statusMsg, sizeof(statusMsg));
    95fe:	06 e1       	ldi	r16, 0x16	; 22
    9600:	10 e0       	ldi	r17, 0x00	; 0
    9602:	48 e0       	ldi	r20, 0x08	; 8
    9604:	50 e0       	ldi	r21, 0x00	; 0
    9606:	6e ec       	ldi	r22, 0xCE	; 206
    9608:	72 e0       	ldi	r23, 0x02	; 2
    960a:	c7 01       	movw	r24, r14
    960c:	0e 94 1b 49 	call	0x9236	; 0x9236 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    9610:	9c 01       	movw	r18, r24
	
	if (status == 0)
    9612:	00 97       	sbiw	r24, 0x00	; 0
    9614:	41 f4       	brne	.+16     	; 0x9626 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x56>
	{
		//parse results
		positionFixStatus =  statusMsg[10] >= 3 ? VALID : INVALID;
    9616:	8b 85       	ldd	r24, Y+11	; 0x0b
    9618:	83 30       	cpi	r24, 0x03	; 3
    961a:	10 f0       	brcs	.+4      	; 0x9620 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x50>
    961c:	82 e0       	ldi	r24, 0x02	; 2
    961e:	01 c0       	rjmp	.+2      	; 0x9622 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x52>
    9620:	81 e0       	ldi	r24, 0x01	; 1
    9622:	f7 01       	movw	r30, r14
    9624:	82 a7       	std	Z+42, r24	; 0x2a
	}

	return status;
}
    9626:	82 2f       	mov	r24, r18
    9628:	93 2f       	mov	r25, r19
    962a:	66 96       	adiw	r28, 0x16	; 22
    962c:	0f b6       	in	r0, 0x3f	; 63
    962e:	f8 94       	cli
    9630:	de bf       	out	0x3e, r29	; 62
    9632:	0f be       	out	0x3f, r0	; 63
    9634:	cd bf       	out	0x3d, r28	; 61
    9636:	df 91       	pop	r29
    9638:	cf 91       	pop	r28
    963a:	1f 91       	pop	r17
    963c:	0f 91       	pop	r16
    963e:	ff 90       	pop	r15
    9640:	ef 90       	pop	r14
    9642:	08 95       	ret

00009644 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>:

	return status;
}

int GPSSensor::readSensorLLH()
{
    9644:	ef 92       	push	r14
    9646:	ff 92       	push	r15
    9648:	0f 93       	push	r16
    964a:	1f 93       	push	r17
    964c:	cf 93       	push	r28
    964e:	df 93       	push	r29
    9650:	cd b7       	in	r28, 0x3d	; 61
    9652:	de b7       	in	r29, 0x3e	; 62
    9654:	a2 97       	sbiw	r28, 0x22	; 34
    9656:	0f b6       	in	r0, 0x3f	; 63
    9658:	f8 94       	cli
    965a:	de bf       	out	0x3e, r29	; 62
    965c:	0f be       	out	0x3f, r0	; 63
    965e:	cd bf       	out	0x3d, r28	; 61
    9660:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte llhMsg[34] = {0};
    9662:	9e 01       	movw	r18, r28
    9664:	2f 5f       	subi	r18, 0xFF	; 255
    9666:	3f 4f       	sbci	r19, 0xFF	; 255
    9668:	82 e2       	ldi	r24, 0x22	; 34
    966a:	f9 01       	movw	r30, r18
    966c:	11 92       	st	Z+, r1
    966e:	8a 95       	dec	r24
    9670:	e9 f7       	brne	.-6      	; 0x966c <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x28>
	
	status = readSensor((byte *)NAV_POSLLH_POLLMSG, sizeof(NAV_POSLLH_POLLMSG), llhMsg, sizeof(llhMsg));
    9672:	02 e2       	ldi	r16, 0x22	; 34
    9674:	10 e0       	ldi	r17, 0x00	; 0
    9676:	48 e0       	ldi	r20, 0x08	; 8
    9678:	50 e0       	ldi	r21, 0x00	; 0
    967a:	6e ed       	ldi	r22, 0xDE	; 222
    967c:	72 e0       	ldi	r23, 0x02	; 2
    967e:	c7 01       	movw	r24, r14
    9680:	0e 94 1b 49 	call	0x9236	; 0x9236 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    9684:	9c 01       	movw	r18, r24

	if (status == 0)
    9686:	00 97       	sbiw	r24, 0x00	; 0
    9688:	19 f5       	brne	.+70     	; 0x96d0 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x8c>
	{
		//parse results
		longitudeDegE7 =  ((long)llhMsg[13] << 24) | ((long)llhMsg[12] << 16) | ((long)llhMsg[11] << 8) | (long)llhMsg[10];
    968a:	4e 85       	ldd	r20, Y+14	; 0x0e
    968c:	8d 85       	ldd	r24, Y+13	; 0x0d
    968e:	90 e0       	ldi	r25, 0x00	; 0
    9690:	a0 e0       	ldi	r26, 0x00	; 0
    9692:	b0 e0       	ldi	r27, 0x00	; 0
    9694:	dc 01       	movw	r26, r24
    9696:	99 27       	eor	r25, r25
    9698:	88 27       	eor	r24, r24
    969a:	b4 2b       	or	r27, r20
    969c:	4b 85       	ldd	r20, Y+11	; 0x0b
    969e:	84 2b       	or	r24, r20
    96a0:	4c 85       	ldd	r20, Y+12	; 0x0c
    96a2:	94 2b       	or	r25, r20
    96a4:	f7 01       	movw	r30, r14
    96a6:	86 83       	std	Z+6, r24	; 0x06
    96a8:	97 83       	std	Z+7, r25	; 0x07
    96aa:	a0 87       	std	Z+8, r26	; 0x08
    96ac:	b1 87       	std	Z+9, r27	; 0x09
		latitudeDegE7 =  ((long)llhMsg[17] << 24) | ((long)llhMsg[16] << 16) | ((long)llhMsg[15] << 8) | (long) llhMsg[14];		
    96ae:	8a 89       	ldd	r24, Y+18	; 0x12
    96b0:	49 89       	ldd	r20, Y+17	; 0x11
    96b2:	50 e0       	ldi	r21, 0x00	; 0
    96b4:	60 e0       	ldi	r22, 0x00	; 0
    96b6:	70 e0       	ldi	r23, 0x00	; 0
    96b8:	ba 01       	movw	r22, r20
    96ba:	55 27       	eor	r21, r21
    96bc:	44 27       	eor	r20, r20
    96be:	78 2b       	or	r23, r24
    96c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    96c2:	48 2b       	or	r20, r24
    96c4:	88 89       	ldd	r24, Y+16	; 0x10
    96c6:	58 2b       	or	r21, r24
    96c8:	42 83       	std	Z+2, r20	; 0x02
    96ca:	53 83       	std	Z+3, r21	; 0x03
    96cc:	64 83       	std	Z+4, r22	; 0x04
    96ce:	75 83       	std	Z+5, r23	; 0x05
	}

	return status;
}
    96d0:	82 2f       	mov	r24, r18
    96d2:	93 2f       	mov	r25, r19
    96d4:	a2 96       	adiw	r28, 0x22	; 34
    96d6:	0f b6       	in	r0, 0x3f	; 63
    96d8:	f8 94       	cli
    96da:	de bf       	out	0x3e, r29	; 62
    96dc:	0f be       	out	0x3f, r0	; 63
    96de:	cd bf       	out	0x3d, r28	; 61
    96e0:	df 91       	pop	r29
    96e2:	cf 91       	pop	r28
    96e4:	1f 91       	pop	r17
    96e6:	0f 91       	pop	r16
    96e8:	ff 90       	pop	r15
    96ea:	ef 90       	pop	r14
    96ec:	08 95       	ret

000096ee <_ZN10helicopter7sensors9GPSSensor4initEv>:

int GPSSensor::init()
{
    96ee:	cf 93       	push	r28
    96f0:	df 93       	push	r29
    96f2:	ec 01       	movw	r28, r24
	
	/**
	 * Transmit a hotstart reset and then clear the buffers so that if the gps is still periodically
	 * sending data, it doesn't cause an overflow of the serial drivers buffer. 
	 */
	serialDriver->clearBuffer();
    96f4:	88 81       	ld	r24, Y
    96f6:	99 81       	ldd	r25, Y+1	; 0x01
    96f8:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>
	serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    96fc:	4c e0       	ldi	r20, 0x0C	; 12
    96fe:	50 e0       	ldi	r21, 0x00	; 0
    9700:	68 e8       	ldi	r22, 0x88	; 136
    9702:	72 e0       	ldi	r23, 0x02	; 2
    9704:	88 81       	ld	r24, Y
    9706:	99 81       	ldd	r25, Y+1	; 0x01
    9708:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	/**
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
    970c:	ce 01       	movw	r24, r28
    970e:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    9712:	00 97       	sbiw	r24, 0x00	; 0
    9714:	79 f0       	breq	.+30     	; 0x9734 <_ZN10helicopter7sensors9GPSSensor4initEv+0x46>
	{
		//Nack received, so resend command
		if (status == 1)
    9716:	01 97       	sbiw	r24, 0x01	; 1
    9718:	41 f4       	brne	.+16     	; 0x972a <_ZN10helicopter7sensors9GPSSensor4initEv+0x3c>
		{
			serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    971a:	4c e0       	ldi	r20, 0x0C	; 12
    971c:	50 e0       	ldi	r21, 0x00	; 0
    971e:	68 e8       	ldi	r22, 0x88	; 136
    9720:	72 e0       	ldi	r23, 0x02	; 2
    9722:	88 81       	ld	r24, Y
    9724:	99 81       	ldd	r25, Y+1	; 0x01
    9726:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    972a:	ce 01       	movw	r24, r28
    972c:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
	while(status != 0)
    9730:	00 97       	sbiw	r24, 0x00	; 0
    9732:	89 f7       	brne	.-30     	; 0x9716 <_ZN10helicopter7sensors9GPSSensor4initEv+0x28>
    9734:	2f ef       	ldi	r18, 0xFF	; 255
    9736:	8e e9       	ldi	r24, 0x9E	; 158
    9738:	94 e2       	ldi	r25, 0x24	; 36
    973a:	21 50       	subi	r18, 0x01	; 1
    973c:	80 40       	sbci	r24, 0x00	; 0
    973e:	90 40       	sbci	r25, 0x00	; 0
    9740:	e1 f7       	brne	.-8      	; 0x973a <_ZN10helicopter7sensors9GPSSensor4initEv+0x4c>
    9742:	00 c0       	rjmp	.+0      	; 0x9744 <_ZN10helicopter7sensors9GPSSensor4initEv+0x56>
    9744:	00 00       	nop
	
	
	/**
	* Configure the GPS's port to use, protocol, and speed.
	*/
	serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    9746:	4c e1       	ldi	r20, 0x1C	; 28
    9748:	50 e0       	ldi	r21, 0x00	; 0
    974a:	62 ea       	ldi	r22, 0xA2	; 162
    974c:	72 e0       	ldi	r23, 0x02	; 2
    974e:	88 81       	ld	r24, Y
    9750:	99 81       	ldd	r25, Y+1	; 0x01
    9752:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	 * byte and discard each byte of the ack message because if we don't read ALL the bytes
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
    9756:	ce 01       	movw	r24, r28
    9758:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    975c:	00 97       	sbiw	r24, 0x00	; 0
    975e:	79 f0       	breq	.+30     	; 0x977e <_ZN10helicopter7sensors9GPSSensor4initEv+0x90>
	{
		//Nack received, so resend command
		if (status == 1)
    9760:	01 97       	sbiw	r24, 0x01	; 1
    9762:	41 f4       	brne	.+16     	; 0x9774 <_ZN10helicopter7sensors9GPSSensor4initEv+0x86>
		{
			serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    9764:	4c e1       	ldi	r20, 0x1C	; 28
    9766:	50 e0       	ldi	r21, 0x00	; 0
    9768:	62 ea       	ldi	r22, 0xA2	; 162
    976a:	72 e0       	ldi	r23, 0x02	; 2
    976c:	88 81       	ld	r24, Y
    976e:	99 81       	ldd	r25, Y+1	; 0x01
    9770:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    9774:	ce 01       	movw	r24, r28
    9776:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
	while(status != 0)
    977a:	00 97       	sbiw	r24, 0x00	; 0
    977c:	89 f7       	brne	.-30     	; 0x9760 <_ZN10helicopter7sensors9GPSSensor4initEv+0x72>
			
		}
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    977e:	4e e0       	ldi	r20, 0x0E	; 14
    9780:	50 e0       	ldi	r21, 0x00	; 0
    9782:	64 e9       	ldi	r22, 0x94	; 148
    9784:	72 e0       	ldi	r23, 0x02	; 2
    9786:	88 81       	ld	r24, Y
    9788:	99 81       	ldd	r25, Y+1	; 0x01
    978a:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	status = receiveAckNack();
    978e:	ce 01       	movw	r24, r28
    9790:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    9794:	9c 01       	movw	r18, r24
	while(status != 0)
    9796:	00 97       	sbiw	r24, 0x00	; 0
    9798:	89 f0       	breq	.+34     	; 0x97bc <_ZN10helicopter7sensors9GPSSensor4initEv+0xce>
	{
		//Nack received, so resend command
		if (status == 1)
    979a:	21 30       	cpi	r18, 0x01	; 1
    979c:	31 05       	cpc	r19, r1
    979e:	41 f4       	brne	.+16     	; 0x97b0 <_ZN10helicopter7sensors9GPSSensor4initEv+0xc2>
		{
			serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    97a0:	4e e0       	ldi	r20, 0x0E	; 14
    97a2:	50 e0       	ldi	r21, 0x00	; 0
    97a4:	64 e9       	ldi	r22, 0x94	; 148
    97a6:	72 e0       	ldi	r23, 0x02	; 2
    97a8:	88 81       	ld	r24, Y
    97aa:	99 81       	ldd	r25, Y+1	; 0x01
    97ac:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    97b0:	ce 01       	movw	r24, r28
    97b2:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    97b6:	9c 01       	movw	r18, r24
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
	status = receiveAckNack();
	while(status != 0)
    97b8:	00 97       	sbiw	r24, 0x00	; 0
    97ba:	79 f7       	brne	.-34     	; 0x979a <_ZN10helicopter7sensors9GPSSensor4initEv+0xac>
		status = receiveAckNack();
	}


	return status;
}
    97bc:	82 2f       	mov	r24, r18
    97be:	93 2f       	mov	r25, r19
    97c0:	df 91       	pop	r29
    97c2:	cf 91       	pop	r28
    97c4:	08 95       	ret

000097c6 <_ZN10helicopter7sensors9GPSSensor5startEv>:


int GPSSensor::start()
{
    97c6:	cf 93       	push	r28
    97c8:	df 93       	push	r29
    97ca:	ec 01       	movw	r28, r24
	cli();
    97cc:	f8 94       	cli
	/**
	* Hack to setup the serial driver to interrupt when data is received.
	*/
	UCSR1B |= (1<<RXCIE1);
    97ce:	e9 ec       	ldi	r30, 0xC9	; 201
    97d0:	f0 e0       	ldi	r31, 0x00	; 0
    97d2:	80 81       	ld	r24, Z
    97d4:	80 68       	ori	r24, 0x80	; 128
    97d6:	80 83       	st	Z, r24
	

	/**
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    97d8:	40 e1       	ldi	r20, 0x10	; 16
    97da:	50 e0       	ldi	r21, 0x00	; 0
    97dc:	6e eb       	ldi	r22, 0xBE	; 190
    97de:	72 e0       	ldi	r23, 0x02	; 2
    97e0:	88 81       	ld	r24, Y
    97e2:	99 81       	ldd	r25, Y+1	; 0x01
    97e4:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
		
	int status = receiveAckNack();
    97e8:	ce 01       	movw	r24, r28
    97ea:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    97ee:	9c 01       	movw	r18, r24
	while(status != 0)
    97f0:	00 97       	sbiw	r24, 0x00	; 0
    97f2:	89 f0       	breq	.+34     	; 0x9816 <_ZN10helicopter7sensors9GPSSensor5startEv+0x50>
	{
		//Nack received, so resend command
		if (status == 1)
    97f4:	21 30       	cpi	r18, 0x01	; 1
    97f6:	31 05       	cpc	r19, r1
    97f8:	41 f4       	brne	.+16     	; 0x980a <_ZN10helicopter7sensors9GPSSensor5startEv+0x44>
		{
			serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    97fa:	40 e1       	ldi	r20, 0x10	; 16
    97fc:	50 e0       	ldi	r21, 0x00	; 0
    97fe:	6e eb       	ldi	r22, 0xBE	; 190
    9800:	72 e0       	ldi	r23, 0x02	; 2
    9802:	88 81       	ld	r24, Y
    9804:	99 81       	ldd	r25, Y+1	; 0x01
    9806:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    980a:	ce 01       	movw	r24, r28
    980c:	0e 94 25 48 	call	0x904a	; 0x904a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    9810:	9c 01       	movw	r18, r24
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
		
	int status = receiveAckNack();
	while(status != 0)
    9812:	00 97       	sbiw	r24, 0x00	; 0
    9814:	79 f7       	brne	.-34     	; 0x97f4 <_ZN10helicopter7sensors9GPSSensor5startEv+0x2e>
			
		}
		status = receiveAckNack();
	}

	sei();	
    9816:	78 94       	sei
	
	return status;
}
    9818:	82 2f       	mov	r24, r18
    981a:	93 2f       	mov	r25, r19
    981c:	df 91       	pop	r29
    981e:	cf 91       	pop	r28
    9820:	08 95       	ret

00009822 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>:
				
bool GPSSensor::isGpsReady()
{
	return positionFixStatus == VALID;;
    9822:	21 e0       	ldi	r18, 0x01	; 1
    9824:	fc 01       	movw	r30, r24
    9826:	82 a5       	ldd	r24, Z+42	; 0x2a
    9828:	82 30       	cpi	r24, 0x02	; 2
    982a:	09 f0       	breq	.+2      	; 0x982e <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv+0xc>
    982c:	20 e0       	ldi	r18, 0x00	; 0
}
    982e:	82 2f       	mov	r24, r18
    9830:	08 95       	ret

00009832 <__vector_36>:



//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART1_RX_vect)
{
    9832:	1f 92       	push	r1
    9834:	0f 92       	push	r0
    9836:	0f b6       	in	r0, 0x3f	; 63
    9838:	0f 92       	push	r0
    983a:	11 24       	eor	r1, r1
    983c:	0b b6       	in	r0, 0x3b	; 59
    983e:	0f 92       	push	r0
    9840:	2f 93       	push	r18
    9842:	3f 93       	push	r19
    9844:	4f 93       	push	r20
    9846:	8f 93       	push	r24
    9848:	9f 93       	push	r25
    984a:	af 93       	push	r26
    984c:	bf 93       	push	r27
    984e:	ef 93       	push	r30
    9850:	ff 93       	push	r31

	byte msgByte = UDR1;
    9852:	20 91 ce 00 	lds	r18, 0x00CE
	

	if (GPSSensor::navSolBufferCounter < GPSSensor::navSolBufferSize)
    9856:	80 91 ab 03 	lds	r24, 0x03AB
    985a:	90 91 ac 03 	lds	r25, 0x03AC
    985e:	8c 33       	cpi	r24, 0x3C	; 60
    9860:	91 05       	cpc	r25, r1
    9862:	0c f0       	brlt	.+2      	; 0x9866 <__vector_36+0x34>
    9864:	50 c0       	rjmp	.+160    	; 0x9906 <__vector_36+0xd4>
		/**
		* if the first data values don't match header values and id values, then the msg has been corrupted
		* so ignore the message. 0xB5 is the first header byte, 0x62 is the second header byte,
		* 0x01 is the first ID byte for the nav_sol msg and 0x06 is the second header byte.
		*/
		if ((GPSSensor::navSolBufferCounter == 0 && msgByte != 0xB5) ||
    9866:	00 97       	sbiw	r24, 0x00	; 0
    9868:	21 f4       	brne	.+8      	; 0x9872 <__vector_36+0x40>
    986a:	25 3b       	cpi	r18, 0xB5	; 181
    986c:	09 f0       	breq	.+2      	; 0x9870 <__vector_36+0x3e>
    986e:	64 c0       	rjmp	.+200    	; 0x9938 <__vector_36+0x106>
    9870:	0e c0       	rjmp	.+28     	; 0x988e <__vector_36+0x5c>
    9872:	81 30       	cpi	r24, 0x01	; 1
    9874:	91 05       	cpc	r25, r1
    9876:	21 f4       	brne	.+8      	; 0x9880 <__vector_36+0x4e>
    9878:	22 36       	cpi	r18, 0x62	; 98
    987a:	09 f0       	breq	.+2      	; 0x987e <__vector_36+0x4c>
    987c:	5d c0       	rjmp	.+186    	; 0x9938 <__vector_36+0x106>
    987e:	4a c0       	rjmp	.+148    	; 0x9914 <__vector_36+0xe2>
    9880:	82 30       	cpi	r24, 0x02	; 2
    9882:	91 05       	cpc	r25, r1
    9884:	21 f4       	brne	.+8      	; 0x988e <__vector_36+0x5c>
    9886:	21 30       	cpi	r18, 0x01	; 1
    9888:	09 f0       	breq	.+2      	; 0x988c <__vector_36+0x5a>
    988a:	56 c0       	rjmp	.+172    	; 0x9938 <__vector_36+0x106>
    988c:	5c c0       	rjmp	.+184    	; 0x9946 <__vector_36+0x114>
    988e:	83 30       	cpi	r24, 0x03	; 3
    9890:	91 05       	cpc	r25, r1
    9892:	09 f0       	breq	.+2      	; 0x9896 <__vector_36+0x64>
    9894:	3f c0       	rjmp	.+126    	; 0x9914 <__vector_36+0xe2>
    9896:	26 30       	cpi	r18, 0x06	; 6
    9898:	09 f0       	breq	.+2      	; 0x989c <__vector_36+0x6a>
    989a:	4e c0       	rjmp	.+156    	; 0x9938 <__vector_36+0x106>
    989c:	54 c0       	rjmp	.+168    	; 0x9946 <__vector_36+0x114>
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
    989e:	41 91       	ld	r20, Z+
    98a0:	24 0f       	add	r18, r20
					ckB = ckB + ckA;
    98a2:	32 0f       	add	r19, r18
			{
				//8-bit fletcher algorithm defined on page 86 of gps pdf.
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
    98a4:	e8 17       	cp	r30, r24
    98a6:	f9 07       	cpc	r31, r25
    98a8:	d1 f7       	brne	.-12     	; 0x989e <__vector_36+0x6c>
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
					ckB = ckB + ckA;
				}
				
				if (GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 2] == ckA && 
    98aa:	80 91 23 04 	lds	r24, 0x0423
    98ae:	28 13       	cpse	r18, r24
    98b0:	20 c0       	rjmp	.+64     	; 0x98f2 <__vector_36+0xc0>
    98b2:	80 91 24 04 	lds	r24, 0x0424
    98b6:	38 13       	cpse	r19, r24
    98b8:	1c c0       	rjmp	.+56     	; 0x98f2 <__vector_36+0xc0>
					GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 1] == ckB)
				{
					//Don't change the buffer data if the system is currently processing the buffer.
					if (GPSSensor::processing == false)
    98ba:	80 91 a8 03 	lds	r24, 0x03A8
    98be:	81 11       	cpse	r24, r1
    98c0:	11 c0       	rjmp	.+34     	; 0x98e4 <__vector_36+0xb2>
					{
						memcpy(GPSSensor::navSolMsgBuffer2,GPSSensor::navSolMsgBuffer, GPSSensor::navSolBufferSize);
    98c2:	8c e3       	ldi	r24, 0x3C	; 60
    98c4:	e9 ee       	ldi	r30, 0xE9	; 233
    98c6:	f3 e0       	ldi	r31, 0x03	; 3
    98c8:	ad ea       	ldi	r26, 0xAD	; 173
    98ca:	b3 e0       	ldi	r27, 0x03	; 3
    98cc:	01 90       	ld	r0, Z+
    98ce:	0d 92       	st	X+, r0
    98d0:	8a 95       	dec	r24
    98d2:	e1 f7       	brne	.-8      	; 0x98cc <__vector_36+0x9a>
						GPSSensor::navSolMsgReceived = true;
    98d4:	81 e0       	ldi	r24, 0x01	; 1
    98d6:	80 93 aa 03 	sts	0x03AA, r24
						GPSSensor::navSolBufferCounter = 0;						
    98da:	10 92 ac 03 	sts	0x03AC, r1
    98de:	10 92 ab 03 	sts	0x03AB, r1
    98e2:	3a c0       	rjmp	.+116    	; 0x9958 <__vector_36+0x126>
					{
						//Reset for a new message and drop this message because the system was processing the current message
						//when the new message came in. 
						//This could be bad because if the timing planets aligned, and this kept happening and the gps messages
						//kept getting dropped, then that would be bad. 
						GPSSensor::navSolMsgReceived = false;
    98e4:	10 92 aa 03 	sts	0x03AA, r1
						GPSSensor::navSolBufferCounter = 0;
    98e8:	10 92 ac 03 	sts	0x03AC, r1
    98ec:	10 92 ab 03 	sts	0x03AB, r1
    98f0:	33 c0       	rjmp	.+102    	; 0x9958 <__vector_36+0x126>
					}
			
				}else
				{
					//GPS checksum didn't match. 
					GPSSensor::navSolMsgReceived = false;
    98f2:	10 92 aa 03 	sts	0x03AA, r1
					GPSSensor::navSolBufferCounter = 0;
    98f6:	10 92 ac 03 	sts	0x03AC, r1
    98fa:	10 92 ab 03 	sts	0x03AB, r1
					GPSSensor::crcError = true;
    98fe:	81 e0       	ldi	r24, 0x01	; 1
    9900:	80 93 a9 03 	sts	0x03A9, r24
    9904:	29 c0       	rjmp	.+82     	; 0x9958 <__vector_36+0x126>
			}			
		}
	}else
	{
		//Theres been some kind of error and the buffer overran, so reset.
		GPSSensor::navSolMsgReceived = false;
    9906:	10 92 aa 03 	sts	0x03AA, r1
		GPSSensor::navSolBufferCounter = 0;
    990a:	10 92 ac 03 	sts	0x03AC, r1
    990e:	10 92 ab 03 	sts	0x03AB, r1
    9912:	22 c0       	rjmp	.+68     	; 0x9958 <__vector_36+0x126>
		{
			GPSSensor::navSolMsgReceived = false;
			GPSSensor::navSolBufferCounter = 0;
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    9914:	fc 01       	movw	r30, r24
    9916:	e7 51       	subi	r30, 0x17	; 23
    9918:	fc 4f       	sbci	r31, 0xFC	; 252
    991a:	20 83       	st	Z, r18
    991c:	01 96       	adiw	r24, 0x01	; 1
    991e:	90 93 ac 03 	sts	0x03AC, r25
    9922:	80 93 ab 03 	sts	0x03AB, r24
			
			if (GPSSensor::navSolBufferCounter >= GPSSensor::navSolBufferSize)
    9926:	cc 97       	sbiw	r24, 0x3c	; 60
    9928:	bc f0       	brlt	.+46     	; 0x9958 <__vector_36+0x126>
    992a:	eb ee       	ldi	r30, 0xEB	; 235
    992c:	f3 e0       	ldi	r31, 0x03	; 3




//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART1_RX_vect)
    992e:	83 e2       	ldi	r24, 0x23	; 35
    9930:	94 e0       	ldi	r25, 0x04	; 4
    9932:	30 e0       	ldi	r19, 0x00	; 0
    9934:	20 e0       	ldi	r18, 0x00	; 0
    9936:	b3 cf       	rjmp	.-154    	; 0x989e <__vector_36+0x6c>
			isCorrupted = true;
		}
		
		if (isCorrupted)
		{
			GPSSensor::navSolMsgReceived = false;
    9938:	10 92 aa 03 	sts	0x03AA, r1
			GPSSensor::navSolBufferCounter = 0;
    993c:	10 92 ac 03 	sts	0x03AC, r1
    9940:	10 92 ab 03 	sts	0x03AB, r1
    9944:	09 c0       	rjmp	.+18     	; 0x9958 <__vector_36+0x126>
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    9946:	fc 01       	movw	r30, r24
    9948:	e7 51       	subi	r30, 0x17	; 23
    994a:	fc 4f       	sbci	r31, 0xFC	; 252
    994c:	20 83       	st	Z, r18
    994e:	01 96       	adiw	r24, 0x01	; 1
    9950:	90 93 ac 03 	sts	0x03AC, r25
    9954:	80 93 ab 03 	sts	0x03AB, r24

	
	//I'll want to make sure I do a memcpy on the buffer when i start working on it
	//to ensure it's not adjusted while I'm working on it.
	//and I'll want to set variable to false first.
    9958:	ff 91       	pop	r31
    995a:	ef 91       	pop	r30
    995c:	bf 91       	pop	r27
    995e:	af 91       	pop	r26
    9960:	9f 91       	pop	r25
    9962:	8f 91       	pop	r24
    9964:	4f 91       	pop	r20
    9966:	3f 91       	pop	r19
    9968:	2f 91       	pop	r18
    996a:	0f 90       	pop	r0
    996c:	0b be       	out	0x3b, r0	; 59
    996e:	0f 90       	pop	r0
    9970:	0f be       	out	0x3f, r0	; 63
    9972:	0f 90       	pop	r0
    9974:	1f 90       	pop	r1
    9976:	18 95       	reti

00009978 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>:
	this->gyroOffsets[2] = offsetz;
	
}

void IMUSensor::readSensor()
{
    9978:	8f 92       	push	r8
    997a:	9f 92       	push	r9
    997c:	af 92       	push	r10
    997e:	bf 92       	push	r11
    9980:	cf 92       	push	r12
    9982:	df 92       	push	r13
    9984:	ef 92       	push	r14
    9986:	ff 92       	push	r15
    9988:	cf 93       	push	r28
    998a:	df 93       	push	r29
    998c:	ec 01       	movw	r28, r24
	if (!hasBeenRead)
    998e:	fc 01       	movw	r30, r24
    9990:	e6 5b       	subi	r30, 0xB6	; 182
    9992:	ff 4f       	sbci	r31, 0xFF	; 255
    9994:	80 81       	ld	r24, Z
    9996:	81 11       	cpse	r24, r1
    9998:	05 c0       	rjmp	.+10     	; 0x99a4 <_ZN10helicopter7sensors9IMUSensor10readSensorEv+0x2c>
	{
		missedRead = true;
    999a:	fe 01       	movw	r30, r28
    999c:	e5 5b       	subi	r30, 0xB5	; 181
    999e:	ff 4f       	sbci	r31, 0xFF	; 255
    99a0:	81 e0       	ldi	r24, 0x01	; 1
    99a2:	80 83       	st	Z, r24
	}
	
	hasBeenRead = false;
    99a4:	fe 01       	movw	r30, r28
    99a6:	e6 5b       	subi	r30, 0xB6	; 182
    99a8:	ff 4f       	sbci	r31, 0xFF	; 255
    99aa:	10 82       	st	Z, r1
	
	//indicate that this device is about to begin communicating with the sensor.
	spiDriver->beginTransaction();
    99ac:	8c a1       	ldd	r24, Y+36	; 0x24
    99ae:	9d a1       	ldd	r25, Y+37	; 0x25
    99b0:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	 * is now pointing to.
	 * The address is 'or'ed by the 'readcommand' to indicate to the
	 * sensor that the subsequent commands should read data
	 * from the sensor.
	 */	
	spiDriver->write(REG_ACCEL_XOUT_H | readCommand);
    99b4:	6b eb       	ldi	r22, 0xBB	; 187
    99b6:	8c a1       	ldd	r24, Y+36	; 0x24
    99b8:	9d a1       	ldd	r25, Y+37	; 0x25
    99ba:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>

	rawAccX = spiDriver->readInt();
    99be:	8c a1       	ldd	r24, Y+36	; 0x24
    99c0:	9d a1       	ldd	r25, Y+37	; 0x25
    99c2:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99c6:	9f a3       	std	Y+39, r25	; 0x27
    99c8:	8e a3       	std	Y+38, r24	; 0x26
	rawAccY = spiDriver->readInt();
    99ca:	8c a1       	ldd	r24, Y+36	; 0x24
    99cc:	9d a1       	ldd	r25, Y+37	; 0x25
    99ce:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99d2:	99 a7       	std	Y+41, r25	; 0x29
    99d4:	88 a7       	std	Y+40, r24	; 0x28
	rawAccZ = spiDriver->readInt();
    99d6:	8c a1       	ldd	r24, Y+36	; 0x24
    99d8:	9d a1       	ldd	r25, Y+37	; 0x25
    99da:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99de:	9b a7       	std	Y+43, r25	; 0x2b
    99e0:	8a a7       	std	Y+42, r24	; 0x2a
	
	//read the temp data, and ignore it since it isn't used.
	spiDriver->readInt();
    99e2:	8c a1       	ldd	r24, Y+36	; 0x24
    99e4:	9d a1       	ldd	r25, Y+37	; 0x25
    99e6:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
	
	rawGyroX = spiDriver->readInt();
    99ea:	8c a1       	ldd	r24, Y+36	; 0x24
    99ec:	9d a1       	ldd	r25, Y+37	; 0x25
    99ee:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99f2:	9d a7       	std	Y+45, r25	; 0x2d
    99f4:	8c a7       	std	Y+44, r24	; 0x2c
	rawGyroY = spiDriver->readInt();
    99f6:	8c a1       	ldd	r24, Y+36	; 0x24
    99f8:	9d a1       	ldd	r25, Y+37	; 0x25
    99fa:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99fe:	9f a7       	std	Y+47, r25	; 0x2f
    9a00:	8e a7       	std	Y+46, r24	; 0x2e
	rawGyroZ = spiDriver->readInt();
    9a02:	8c a1       	ldd	r24, Y+36	; 0x24
    9a04:	9d a1       	ldd	r25, Y+37	; 0x25
    9a06:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9a0a:	99 ab       	std	Y+49, r25	; 0x31
    9a0c:	88 ab       	std	Y+48, r24	; 0x30
	
	/**
	 * The master (this CPU) then pulls the slave select line low indicating
	 * that it is done communicating.
	 */
	spiDriver->endTransaction();
    9a0e:	8c a1       	ldd	r24, Y+36	; 0x24
    9a10:	9d a1       	ldd	r25, Y+37	; 0x25
    9a12:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a16:	6e a1       	ldd	r22, Y+38	; 0x26
    9a18:	7f a1       	ldd	r23, Y+39	; 0x27
    9a1a:	88 27       	eor	r24, r24
    9a1c:	77 fd       	sbrc	r23, 7
    9a1e:	80 95       	com	r24
    9a20:	98 2f       	mov	r25, r24
    9a22:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9a26:	2a e0       	ldi	r18, 0x0A	; 10
    9a28:	38 ee       	ldi	r19, 0xE8	; 232
    9a2a:	4c e1       	ldi	r20, 0x1C	; 28
    9a2c:	5a e3       	ldi	r21, 0x3A	; 58
    9a2e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    9a32:	46 2f       	mov	r20, r22
    9a34:	57 2f       	mov	r21, r23
    9a36:	68 2f       	mov	r22, r24
    9a38:	79 2f       	mov	r23, r25
    9a3a:	4a 01       	movw	r8, r20
    9a3c:	5b 01       	movw	r10, r22
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a3e:	6a a5       	ldd	r22, Y+42	; 0x2a
    9a40:	7b a5       	ldd	r23, Y+43	; 0x2b
    9a42:	71 95       	neg	r23
    9a44:	61 95       	neg	r22
    9a46:	71 09       	sbc	r23, r1
    9a48:	88 27       	eor	r24, r24
    9a4a:	77 fd       	sbrc	r23, 7
    9a4c:	80 95       	com	r24
    9a4e:	98 2f       	mov	r25, r24
    9a50:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9a54:	2a e0       	ldi	r18, 0x0A	; 10
    9a56:	38 ee       	ldi	r19, 0xE8	; 232
    9a58:	4c e1       	ldi	r20, 0x1C	; 28
    9a5a:	5a e3       	ldi	r21, 0x3A	; 58
    9a5c:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    9a60:	46 2f       	mov	r20, r22
    9a62:	57 2f       	mov	r21, r23
    9a64:	68 2f       	mov	r22, r24
    9a66:	79 2f       	mov	r23, r25
    9a68:	6a 01       	movw	r12, r20
    9a6a:	7b 01       	movw	r14, r22
	
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a6c:	68 a5       	ldd	r22, Y+40	; 0x28
    9a6e:	79 a5       	ldd	r23, Y+41	; 0x29
    9a70:	88 27       	eor	r24, r24
    9a72:	77 fd       	sbrc	r23, 7
    9a74:	80 95       	com	r24
    9a76:	98 2f       	mov	r25, r24
    9a78:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9a7c:	2a e0       	ldi	r18, 0x0A	; 10
    9a7e:	38 ee       	ldi	r19, 0xE8	; 232
    9a80:	4c e1       	ldi	r20, 0x1C	; 28
    9a82:	5a e3       	ldi	r21, 0x3A	; 58
    9a84:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	//Multiplying by negative 1 because technically the gravity vector is what we want to be
	//FRD, not the acceleration vector. so since gravity is -9.8 we want to convert it to 9.8.
	frdAccXMss *= -1;
    9a88:	dc 01       	movw	r26, r24
    9a8a:	cb 01       	movw	r24, r22
    9a8c:	b0 58       	subi	r27, 0x80	; 128
    9a8e:	8a ab       	std	Y+50, r24	; 0x32
    9a90:	9b ab       	std	Y+51, r25	; 0x33
    9a92:	ac ab       	std	Y+52, r26	; 0x34
    9a94:	bd ab       	std	Y+53, r27	; 0x35
	frdAccYMss *= -1;
    9a96:	b7 fa       	bst	r11, 7
    9a98:	b0 94       	com	r11
    9a9a:	b7 f8       	bld	r11, 7
    9a9c:	b0 94       	com	r11
    9a9e:	8e aa       	std	Y+54, r8	; 0x36
    9aa0:	9f aa       	std	Y+55, r9	; 0x37
    9aa2:	a8 ae       	std	Y+56, r10	; 0x38
    9aa4:	b9 ae       	std	Y+57, r11	; 0x39
	frdAccZMss *= -1;
    9aa6:	f7 fa       	bst	r15, 7
    9aa8:	f0 94       	com	r15
    9aaa:	f7 f8       	bld	r15, 7
    9aac:	f0 94       	com	r15
    9aae:	ca ae       	std	Y+58, r12	; 0x3a
    9ab0:	db ae       	std	Y+59, r13	; 0x3b
    9ab2:	ec ae       	std	Y+60, r14	; 0x3c
    9ab4:	fd ae       	std	Y+61, r15	; 0x3d
	
	frdGyroXRs = (rawGyroY - gyroOffsets[1]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9ab6:	7e 01       	movw	r14, r28
    9ab8:	8e e3       	ldi	r24, 0x3E	; 62
    9aba:	e8 0e       	add	r14, r24
    9abc:	f1 1c       	adc	r15, r1
    9abe:	6e a5       	ldd	r22, Y+46	; 0x2e
    9ac0:	7f a5       	ldd	r23, Y+47	; 0x2f
    9ac2:	88 27       	eor	r24, r24
    9ac4:	77 fd       	sbrc	r23, 7
    9ac6:	80 95       	com	r24
    9ac8:	98 2f       	mov	r25, r24
    9aca:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9ace:	fe 01       	movw	r30, r28
    9ad0:	e0 5b       	subi	r30, 0xB0	; 176
    9ad2:	ff 4f       	sbci	r31, 0xFF	; 255
    9ad4:	20 81       	ld	r18, Z
    9ad6:	31 81       	ldd	r19, Z+1	; 0x01
    9ad8:	42 81       	ldd	r20, Z+2	; 0x02
    9ada:	53 81       	ldd	r21, Z+3	; 0x03
    9adc:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    9ae0:	25 ea       	ldi	r18, 0xA5	; 165
    9ae2:	39 ee       	ldi	r19, 0xE9	; 233
    9ae4:	4a e6       	ldi	r20, 0x6A	; 106
    9ae6:	54 e4       	ldi	r21, 0x44	; 68
    9ae8:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9aec:	f7 01       	movw	r30, r14
    9aee:	60 83       	st	Z, r22
    9af0:	71 83       	std	Z+1, r23	; 0x01
    9af2:	82 83       	std	Z+2, r24	; 0x02
    9af4:	93 83       	std	Z+3, r25	; 0x03
	frdGyroYRs = (rawGyroX - gyroOffsets[0]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9af6:	7e 01       	movw	r14, r28
    9af8:	f2 e4       	ldi	r31, 0x42	; 66
    9afa:	ef 0e       	add	r14, r31
    9afc:	f1 1c       	adc	r15, r1
    9afe:	6c a5       	ldd	r22, Y+44	; 0x2c
    9b00:	7d a5       	ldd	r23, Y+45	; 0x2d
    9b02:	88 27       	eor	r24, r24
    9b04:	77 fd       	sbrc	r23, 7
    9b06:	80 95       	com	r24
    9b08:	98 2f       	mov	r25, r24
    9b0a:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9b0e:	fe 01       	movw	r30, r28
    9b10:	e4 5b       	subi	r30, 0xB4	; 180
    9b12:	ff 4f       	sbci	r31, 0xFF	; 255
    9b14:	20 81       	ld	r18, Z
    9b16:	31 81       	ldd	r19, Z+1	; 0x01
    9b18:	42 81       	ldd	r20, Z+2	; 0x02
    9b1a:	53 81       	ldd	r21, Z+3	; 0x03
    9b1c:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    9b20:	25 ea       	ldi	r18, 0xA5	; 165
    9b22:	39 ee       	ldi	r19, 0xE9	; 233
    9b24:	4a e6       	ldi	r20, 0x6A	; 106
    9b26:	54 e4       	ldi	r21, 0x44	; 68
    9b28:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9b2c:	f7 01       	movw	r30, r14
    9b2e:	60 83       	st	Z, r22
    9b30:	71 83       	std	Z+1, r23	; 0x01
    9b32:	82 83       	std	Z+2, r24	; 0x02
    9b34:	93 83       	std	Z+3, r25	; 0x03
	frdGyroZRs = -(rawGyroZ - gyroOffsets[2]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9b36:	7e 01       	movw	r14, r28
    9b38:	f6 e4       	ldi	r31, 0x46	; 70
    9b3a:	ef 0e       	add	r14, r31
    9b3c:	f1 1c       	adc	r15, r1
    9b3e:	68 a9       	ldd	r22, Y+48	; 0x30
    9b40:	79 a9       	ldd	r23, Y+49	; 0x31
    9b42:	88 27       	eor	r24, r24
    9b44:	77 fd       	sbrc	r23, 7
    9b46:	80 95       	com	r24
    9b48:	98 2f       	mov	r25, r24
    9b4a:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9b4e:	cc 5a       	subi	r28, 0xAC	; 172
    9b50:	df 4f       	sbci	r29, 0xFF	; 255
    9b52:	28 81       	ld	r18, Y
    9b54:	39 81       	ldd	r19, Y+1	; 0x01
    9b56:	4a 81       	ldd	r20, Y+2	; 0x02
    9b58:	5b 81       	ldd	r21, Y+3	; 0x03
    9b5a:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    9b5e:	90 58       	subi	r25, 0x80	; 128
    9b60:	25 ea       	ldi	r18, 0xA5	; 165
    9b62:	39 ee       	ldi	r19, 0xE9	; 233
    9b64:	4a e6       	ldi	r20, 0x6A	; 106
    9b66:	54 e4       	ldi	r21, 0x44	; 68
    9b68:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9b6c:	f7 01       	movw	r30, r14
    9b6e:	60 83       	st	Z, r22
    9b70:	71 83       	std	Z+1, r23	; 0x01
    9b72:	82 83       	std	Z+2, r24	; 0x02
    9b74:	93 83       	std	Z+3, r25	; 0x03
	
	
}
    9b76:	df 91       	pop	r29
    9b78:	cf 91       	pop	r28
    9b7a:	ff 90       	pop	r15
    9b7c:	ef 90       	pop	r14
    9b7e:	df 90       	pop	r13
    9b80:	cf 90       	pop	r12
    9b82:	bf 90       	pop	r11
    9b84:	af 90       	pop	r10
    9b86:	9f 90       	pop	r9
    9b88:	8f 90       	pop	r8
    9b8a:	08 95       	ret

00009b8c <_ZN10helicopter7sensors9IMUSensor4initEv>:
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 16384;



void IMUSensor::init()
{
    9b8c:	2f 92       	push	r2
    9b8e:	3f 92       	push	r3
    9b90:	4f 92       	push	r4
    9b92:	5f 92       	push	r5
    9b94:	6f 92       	push	r6
    9b96:	7f 92       	push	r7
    9b98:	8f 92       	push	r8
    9b9a:	9f 92       	push	r9
    9b9c:	af 92       	push	r10
    9b9e:	bf 92       	push	r11
    9ba0:	cf 92       	push	r12
    9ba2:	df 92       	push	r13
    9ba4:	ef 92       	push	r14
    9ba6:	ff 92       	push	r15
    9ba8:	0f 93       	push	r16
    9baa:	1f 93       	push	r17
    9bac:	cf 93       	push	r28
    9bae:	df 93       	push	r29
    9bb0:	cd b7       	in	r28, 0x3d	; 61
    9bb2:	de b7       	in	r29, 0x3e	; 62
    9bb4:	ac 97       	sbiw	r28, 0x2c	; 44
    9bb6:	0f b6       	in	r0, 0x3f	; 63
    9bb8:	f8 94       	cli
    9bba:	de bf       	out	0x3e, r29	; 62
    9bbc:	0f be       	out	0x3f, r0	; 63
    9bbe:	cd bf       	out	0x3d, r28	; 61
    9bc0:	9e 83       	std	Y+6, r25	; 0x06
    9bc2:	8d 83       	std	Y+5, r24	; 0x05
	
	//Reset the sensor in case of a soft reset the sensor
	//might still have had power and thus not reset.
	//End the transaction. If I don't close and restart a new
	//transaction, accelerometer data doesn't seem to be able to be read.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_DEVICE_RESET);
    9bc4:	40 e8       	ldi	r20, 0x80	; 128
    9bc6:	6b e6       	ldi	r22, 0x6B	; 107
    9bc8:	dc 01       	movw	r26, r24
    9bca:	94 96       	adiw	r26, 0x24	; 36
    9bcc:	8d 91       	ld	r24, X+
    9bce:	9c 91       	ld	r25, X
    9bd0:	95 97       	sbiw	r26, 0x25	; 37
    9bd2:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9bd6:	bf ef       	ldi	r27, 0xFF	; 255
    9bd8:	e1 ee       	ldi	r30, 0xE1	; 225
    9bda:	f4 e0       	ldi	r31, 0x04	; 4
    9bdc:	b1 50       	subi	r27, 0x01	; 1
    9bde:	e0 40       	sbci	r30, 0x00	; 0
    9be0:	f0 40       	sbci	r31, 0x00	; 0
    9be2:	e1 f7       	brne	.-8      	; 0x9bdc <_ZN10helicopter7sensors9IMUSensor4initEv+0x50>
    9be4:	00 c0       	rjmp	.+0      	; 0x9be6 <_ZN10helicopter7sensors9IMUSensor4initEv+0x5a>
    9be6:	00 00       	nop
	//wait for device reset
	_delay_ms(100);

	//Select Gyro Z as the reference clock. Selecting a gyro clock
	//is recommended in pag 41 of RM-MPU-6000A.pdf for improved stability.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_CLKSEL_GYROZ);
    9be8:	43 e0       	ldi	r20, 0x03	; 3
    9bea:	6b e6       	ldi	r22, 0x6B	; 107
    9bec:	ad 81       	ldd	r26, Y+5	; 0x05
    9bee:	be 81       	ldd	r27, Y+6	; 0x06
    9bf0:	94 96       	adiw	r26, 0x24	; 36
    9bf2:	8d 91       	ld	r24, X+
    9bf4:	9c 91       	ld	r25, X
    9bf6:	95 97       	sbiw	r26, 0x25	; 37
    9bf8:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9bfc:	bf ef       	ldi	r27, 0xFF	; 255
    9bfe:	e1 ee       	ldi	r30, 0xE1	; 225
    9c00:	f4 e0       	ldi	r31, 0x04	; 4
    9c02:	b1 50       	subi	r27, 0x01	; 1
    9c04:	e0 40       	sbci	r30, 0x00	; 0
    9c06:	f0 40       	sbci	r31, 0x00	; 0
    9c08:	e1 f7       	brne	.-8      	; 0x9c02 <_ZN10helicopter7sensors9IMUSensor4initEv+0x76>
    9c0a:	00 c0       	rjmp	.+0      	; 0x9c0c <_ZN10helicopter7sensors9IMUSensor4initEv+0x80>
    9c0c:	00 00       	nop
	//takes a long time and reading accelerometer data
	//returns 0 unless this is done.
	_delay_ms(100);

	//Enable SPI Interface / disable i2c.
	spiDriver->transactionWrite(REG_USER_CTRL,BITS_I2C_IF_DIS);
    9c0e:	40 e1       	ldi	r20, 0x10	; 16
    9c10:	6a e6       	ldi	r22, 0x6A	; 106
    9c12:	ad 81       	ldd	r26, Y+5	; 0x05
    9c14:	be 81       	ldd	r27, Y+6	; 0x06
    9c16:	94 96       	adiw	r26, 0x24	; 36
    9c18:	8d 91       	ld	r24, X+
    9c1a:	9c 91       	ld	r25, X
    9c1c:	95 97       	sbiw	r26, 0x25	; 37
    9c1e:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Set the sampling rate to 1kHz.
	spiDriver->transactionWrite(REG_SMPLRT_DIV,BITS_SMPLRT_DIV);
    9c22:	40 e0       	ldi	r20, 0x00	; 0
    9c24:	69 e1       	ldi	r22, 0x19	; 25
    9c26:	ed 81       	ldd	r30, Y+5	; 0x05
    9c28:	fe 81       	ldd	r31, Y+6	; 0x06
    9c2a:	84 a1       	ldd	r24, Z+36	; 0x24
    9c2c:	95 a1       	ldd	r25, Z+37	; 0x25
    9c2e:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	
	//Configures the Digital Low Pass Filter. This is how frequently the sensor readings are updated
	//for accelerometers and gyroscopes.
	spiDriver->transactionWrite(REG_CONFIG,BITS_DLPF_CFG);
    9c32:	42 e0       	ldi	r20, 0x02	; 2
    9c34:	6a e1       	ldi	r22, 0x1A	; 26
    9c36:	ad 81       	ldd	r26, Y+5	; 0x05
    9c38:	be 81       	ldd	r27, Y+6	; 0x06
    9c3a:	94 96       	adiw	r26, 0x24	; 36
    9c3c:	8d 91       	ld	r24, X+
    9c3e:	9c 91       	ld	r25, X
    9c40:	95 97       	sbiw	r26, 0x25	; 37
    9c42:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Configures the sensitivity / scale range of the gyroscope
	spiDriver->transactionWrite(REG_GYRO_CONFIG,BITS_FS_SEL);
    9c46:	48 e1       	ldi	r20, 0x18	; 24
    9c48:	6b e1       	ldi	r22, 0x1B	; 27
    9c4a:	ed 81       	ldd	r30, Y+5	; 0x05
    9c4c:	fe 81       	ldd	r31, Y+6	; 0x06
    9c4e:	84 a1       	ldd	r24, Z+36	; 0x24
    9c50:	95 a1       	ldd	r25, Z+37	; 0x25
    9c52:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//configure the sensitivity / scale range of the accelerometer
	spiDriver->transactionWrite(REG_ACCEL_CONFIG,BITS_AFS_SEL);
    9c56:	40 e0       	ldi	r20, 0x00	; 0
    9c58:	6c e1       	ldi	r22, 0x1C	; 28
    9c5a:	ad 81       	ldd	r26, Y+5	; 0x05
    9c5c:	be 81       	ldd	r27, Y+6	; 0x06
    9c5e:	94 96       	adiw	r26, 0x24	; 36
    9c60:	8d 91       	ld	r24, X+
    9c62:	9c 91       	ld	r25, X
    9c64:	95 97       	sbiw	r26, 0x25	; 37
    9c66:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9c6a:	dd c1       	rjmp	.+954    	; 0xa026 <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
		{
			this->readSensor();
    9c6c:	c8 01       	movw	r24, r16
    9c6e:	0e 94 bc 4c 	call	0x9978	; 0x9978 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
    9c72:	b1 e0       	ldi	r27, 0x01	; 1
    9c74:	eb 1a       	sub	r14, r27
    9c76:	f1 08       	sbc	r15, r1
		offsety = 0.0f;
		offsetz = 0.0f;
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
    9c78:	c9 f7       	brne	.-14     	; 0x9c6c <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			this->readSensor();
		}
		


		float minoffsetx = this->rawGyroX;
    9c7a:	ed 81       	ldd	r30, Y+5	; 0x05
    9c7c:	fe 81       	ldd	r31, Y+6	; 0x06
    9c7e:	64 a5       	ldd	r22, Z+44	; 0x2c
    9c80:	75 a5       	ldd	r23, Z+45	; 0x2d
    9c82:	88 27       	eor	r24, r24
    9c84:	77 fd       	sbrc	r23, 7
    9c86:	80 95       	com	r24
    9c88:	98 2f       	mov	r25, r24
    9c8a:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9c8e:	06 2f       	mov	r16, r22
    9c90:	17 2f       	mov	r17, r23
    9c92:	a8 2e       	mov	r10, r24
    9c94:	b9 2e       	mov	r11, r25
    9c96:	6b 8b       	std	Y+19, r22	; 0x13
    9c98:	7c 8b       	std	Y+20, r23	; 0x14
    9c9a:	8d 8b       	std	Y+21, r24	; 0x15
    9c9c:	9e 8b       	std	Y+22, r25	; 0x16
		float minoffsety = this->rawGyroY;
    9c9e:	ad 81       	ldd	r26, Y+5	; 0x05
    9ca0:	be 81       	ldd	r27, Y+6	; 0x06
    9ca2:	9e 96       	adiw	r26, 0x2e	; 46
    9ca4:	6d 91       	ld	r22, X+
    9ca6:	7c 91       	ld	r23, X
    9ca8:	9f 97       	sbiw	r26, 0x2f	; 47
    9caa:	88 27       	eor	r24, r24
    9cac:	77 fd       	sbrc	r23, 7
    9cae:	80 95       	com	r24
    9cb0:	98 2f       	mov	r25, r24
    9cb2:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9cb6:	c6 2e       	mov	r12, r22
    9cb8:	d7 2e       	mov	r13, r23
    9cba:	e8 2e       	mov	r14, r24
    9cbc:	f9 2e       	mov	r15, r25
    9cbe:	6b 8f       	std	Y+27, r22	; 0x1b
    9cc0:	7c 8f       	std	Y+28, r23	; 0x1c
    9cc2:	8d 8f       	std	Y+29, r24	; 0x1d
    9cc4:	9e 8f       	std	Y+30, r25	; 0x1e
		float minoffsetz = this->rawGyroZ;
    9cc6:	ed 81       	ldd	r30, Y+5	; 0x05
    9cc8:	fe 81       	ldd	r31, Y+6	; 0x06
    9cca:	60 a9       	ldd	r22, Z+48	; 0x30
    9ccc:	71 a9       	ldd	r23, Z+49	; 0x31
    9cce:	88 27       	eor	r24, r24
    9cd0:	77 fd       	sbrc	r23, 7
    9cd2:	80 95       	com	r24
    9cd4:	98 2f       	mov	r25, r24
    9cd6:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9cda:	6b a3       	std	Y+35, r22	; 0x23
    9cdc:	7c a3       	std	Y+36, r23	; 0x24
    9cde:	8d a3       	std	Y+37, r24	; 0x25
    9ce0:	9e a3       	std	Y+38, r25	; 0x26
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
    9ce2:	6f a3       	std	Y+39, r22	; 0x27
    9ce4:	78 a7       	std	Y+40, r23	; 0x28
    9ce6:	89 a7       	std	Y+41, r24	; 0x29
    9ce8:	9a a7       	std	Y+42, r25	; 0x2a
		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
    9cea:	cf 8e       	std	Y+31, r12	; 0x1f
    9cec:	d8 a2       	std	Y+32, r13	; 0x20
    9cee:	e9 a2       	std	Y+33, r14	; 0x21
    9cf0:	fa a2       	std	Y+34, r15	; 0x22

		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
    9cf2:	0f 8b       	std	Y+23, r16	; 0x17
    9cf4:	18 8f       	std	Y+24, r17	; 0x18
    9cf6:	a9 8e       	std	Y+25, r10	; 0x19
    9cf8:	ba 8e       	std	Y+26, r11	; 0x1a
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    9cfa:	61 2c       	mov	r6, r1
    9cfc:	71 2c       	mov	r7, r1
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
		offsetz = 0.0f;
    9cfe:	1f 86       	std	Y+15, r1	; 0x0f
    9d00:	18 8a       	std	Y+16, r1	; 0x10
    9d02:	19 8a       	std	Y+17, r1	; 0x11
    9d04:	1a 8a       	std	Y+18, r1	; 0x12
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
    9d06:	1b 86       	std	Y+11, r1	; 0x0b
    9d08:	1c 86       	std	Y+12, r1	; 0x0c
    9d0a:	1d 86       	std	Y+13, r1	; 0x0d
    9d0c:	1e 86       	std	Y+14, r1	; 0x0e
	
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
    9d0e:	1f 82       	std	Y+7, r1	; 0x07
    9d10:	18 86       	std	Y+8, r1	; 0x08
    9d12:	19 86       	std	Y+9, r1	; 0x09
    9d14:	1a 86       	std	Y+10, r1	; 0x0a
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
		{
			this->readSensor();
    9d16:	8d 81       	ldd	r24, Y+5	; 0x05
    9d18:	9e 81       	ldd	r25, Y+6	; 0x06
    9d1a:	0e 94 bc 4c 	call	0x9978	; 0x9978 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
		
			offsetx = (this->rawGyroX + i*offsetx) / (i+1);
    9d1e:	ad 81       	ldd	r26, Y+5	; 0x05
    9d20:	be 81       	ldd	r27, Y+6	; 0x06
    9d22:	9c 96       	adiw	r26, 0x2c	; 44
    9d24:	6d 91       	ld	r22, X+
    9d26:	7c 91       	ld	r23, X
    9d28:	9d 97       	sbiw	r26, 0x2d	; 45
    9d2a:	88 27       	eor	r24, r24
    9d2c:	77 fd       	sbrc	r23, 7
    9d2e:	80 95       	com	r24
    9d30:	98 2f       	mov	r25, r24
    9d32:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9d36:	26 2e       	mov	r2, r22
    9d38:	37 2e       	mov	r3, r23
    9d3a:	89 83       	std	Y+1, r24	; 0x01
    9d3c:	9a 83       	std	Y+2, r25	; 0x02
    9d3e:	b3 01       	movw	r22, r6
    9d40:	88 27       	eor	r24, r24
    9d42:	77 fd       	sbrc	r23, 7
    9d44:	80 95       	com	r24
    9d46:	98 2f       	mov	r25, r24
    9d48:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9d4c:	4b 01       	movw	r8, r22
    9d4e:	5c 01       	movw	r10, r24
    9d50:	7f 81       	ldd	r23, Y+7	; 0x07
    9d52:	68 85       	ldd	r22, Y+8	; 0x08
    9d54:	99 85       	ldd	r25, Y+9	; 0x09
    9d56:	8a 85       	ldd	r24, Y+10	; 0x0a
    9d58:	27 2f       	mov	r18, r23
    9d5a:	36 2f       	mov	r19, r22
    9d5c:	49 2f       	mov	r20, r25
    9d5e:	58 2f       	mov	r21, r24
    9d60:	c5 01       	movw	r24, r10
    9d62:	b4 01       	movw	r22, r8
    9d64:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    9d68:	9b 01       	movw	r18, r22
    9d6a:	ac 01       	movw	r20, r24
    9d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    9d6e:	1a 81       	ldd	r17, Y+2	; 0x02
    9d70:	62 2d       	mov	r22, r2
    9d72:	73 2d       	mov	r23, r3
    9d74:	8e 2f       	mov	r24, r30
    9d76:	91 2f       	mov	r25, r17
    9d78:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    9d7c:	06 2f       	mov	r16, r22
    9d7e:	17 2f       	mov	r17, r23
    9d80:	48 2e       	mov	r4, r24
    9d82:	59 2e       	mov	r5, r25
    9d84:	bf ef       	ldi	r27, 0xFF	; 255
    9d86:	6b 1a       	sub	r6, r27
    9d88:	7b 0a       	sbc	r7, r27
    9d8a:	b3 01       	movw	r22, r6
    9d8c:	88 27       	eor	r24, r24
    9d8e:	77 fd       	sbrc	r23, 7
    9d90:	80 95       	com	r24
    9d92:	98 2f       	mov	r25, r24
    9d94:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9d98:	6b 01       	movw	r12, r22
    9d9a:	7c 01       	movw	r14, r24
    9d9c:	9b 01       	movw	r18, r22
    9d9e:	ac 01       	movw	r20, r24
    9da0:	60 2f       	mov	r22, r16
    9da2:	71 2f       	mov	r23, r17
    9da4:	84 2d       	mov	r24, r4
    9da6:	95 2d       	mov	r25, r5
    9da8:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9dac:	6f 83       	std	Y+7, r22	; 0x07
    9dae:	78 87       	std	Y+8, r23	; 0x08
    9db0:	89 87       	std	Y+9, r24	; 0x09
    9db2:	9a 87       	std	Y+10, r25	; 0x0a
			offsety = (this->rawGyroY + i*offsety) / (i+1);
    9db4:	ed 81       	ldd	r30, Y+5	; 0x05
    9db6:	fe 81       	ldd	r31, Y+6	; 0x06
    9db8:	66 a5       	ldd	r22, Z+46	; 0x2e
    9dba:	77 a5       	ldd	r23, Z+47	; 0x2f
    9dbc:	88 27       	eor	r24, r24
    9dbe:	77 fd       	sbrc	r23, 7
    9dc0:	80 95       	com	r24
    9dc2:	98 2f       	mov	r25, r24
    9dc4:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9dc8:	46 2e       	mov	r4, r22
    9dca:	57 2e       	mov	r5, r23
    9dcc:	8b 83       	std	Y+3, r24	; 0x03
    9dce:	9c 83       	std	Y+4, r25	; 0x04
    9dd0:	a5 01       	movw	r20, r10
    9dd2:	94 01       	movw	r18, r8
    9dd4:	bb 85       	ldd	r27, Y+11	; 0x0b
    9dd6:	ac 85       	ldd	r26, Y+12	; 0x0c
    9dd8:	ed 85       	ldd	r30, Y+13	; 0x0d
    9dda:	1e 85       	ldd	r17, Y+14	; 0x0e
    9ddc:	6b 2f       	mov	r22, r27
    9dde:	7a 2f       	mov	r23, r26
    9de0:	8e 2f       	mov	r24, r30
    9de2:	91 2f       	mov	r25, r17
    9de4:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    9de8:	9b 01       	movw	r18, r22
    9dea:	ac 01       	movw	r20, r24
    9dec:	eb 81       	ldd	r30, Y+3	; 0x03
    9dee:	1c 81       	ldd	r17, Y+4	; 0x04
    9df0:	64 2d       	mov	r22, r4
    9df2:	75 2d       	mov	r23, r5
    9df4:	8e 2f       	mov	r24, r30
    9df6:	91 2f       	mov	r25, r17
    9df8:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    9dfc:	a7 01       	movw	r20, r14
    9dfe:	96 01       	movw	r18, r12
    9e00:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9e04:	6b 87       	std	Y+11, r22	; 0x0b
    9e06:	7c 87       	std	Y+12, r23	; 0x0c
    9e08:	8d 87       	std	Y+13, r24	; 0x0d
    9e0a:	9e 87       	std	Y+14, r25	; 0x0e
			offsetz = (this->rawGyroZ + i*offsetz) / (i+1);
    9e0c:	ad 81       	ldd	r26, Y+5	; 0x05
    9e0e:	be 81       	ldd	r27, Y+6	; 0x06
    9e10:	d0 96       	adiw	r26, 0x30	; 48
    9e12:	6d 91       	ld	r22, X+
    9e14:	7c 91       	ld	r23, X
    9e16:	d1 97       	sbiw	r26, 0x31	; 49
    9e18:	88 27       	eor	r24, r24
    9e1a:	77 fd       	sbrc	r23, 7
    9e1c:	80 95       	com	r24
    9e1e:	98 2f       	mov	r25, r24
    9e20:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    9e24:	06 2f       	mov	r16, r22
    9e26:	17 2f       	mov	r17, r23
    9e28:	8c a7       	std	Y+44, r24	; 0x2c
    9e2a:	9b a7       	std	Y+43, r25	; 0x2b
    9e2c:	a5 01       	movw	r20, r10
    9e2e:	94 01       	movw	r18, r8
    9e30:	bf 85       	ldd	r27, Y+15	; 0x0f
    9e32:	a8 89       	ldd	r26, Y+16	; 0x10
    9e34:	b9 88       	ldd	r11, Y+17	; 0x11
    9e36:	aa 88       	ldd	r10, Y+18	; 0x12
    9e38:	6b 2f       	mov	r22, r27
    9e3a:	7a 2f       	mov	r23, r26
    9e3c:	8b 2d       	mov	r24, r11
    9e3e:	9a 2d       	mov	r25, r10
    9e40:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    9e44:	9b 01       	movw	r18, r22
    9e46:	ac 01       	movw	r20, r24
    9e48:	fc a5       	ldd	r31, Y+44	; 0x2c
    9e4a:	eb a5       	ldd	r30, Y+43	; 0x2b
    9e4c:	60 2f       	mov	r22, r16
    9e4e:	71 2f       	mov	r23, r17
    9e50:	8f 2f       	mov	r24, r31
    9e52:	9e 2f       	mov	r25, r30
    9e54:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    9e58:	a7 01       	movw	r20, r14
    9e5a:	96 01       	movw	r18, r12
    9e5c:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    9e60:	6f 87       	std	Y+15, r22	; 0x0f
    9e62:	78 8b       	std	Y+16, r23	; 0x10
    9e64:	89 8b       	std	Y+17, r24	; 0x11
    9e66:	9a 8b       	std	Y+18, r25	; 0x12
			
			minoffsetx = this->rawGyroX < minoffsetx ? this->rawGyroX : minoffsetx;
    9e68:	7b 89       	ldd	r23, Y+19	; 0x13
    9e6a:	6c 89       	ldd	r22, Y+20	; 0x14
    9e6c:	9d 89       	ldd	r25, Y+21	; 0x15
    9e6e:	8e 89       	ldd	r24, Y+22	; 0x16
    9e70:	27 2f       	mov	r18, r23
    9e72:	36 2f       	mov	r19, r22
    9e74:	49 2f       	mov	r20, r25
    9e76:	58 2f       	mov	r21, r24
    9e78:	f9 80       	ldd	r15, Y+1	; 0x01
    9e7a:	ea 80       	ldd	r14, Y+2	; 0x02
    9e7c:	62 2d       	mov	r22, r2
    9e7e:	73 2d       	mov	r23, r3
    9e80:	8f 2d       	mov	r24, r15
    9e82:	9e 2d       	mov	r25, r14
    9e84:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    9e88:	88 23       	and	r24, r24
    9e8a:	24 f4       	brge	.+8      	; 0x9e94 <_ZN10helicopter7sensors9IMUSensor4initEv+0x308>
    9e8c:	2b 8a       	std	Y+19, r2	; 0x13
    9e8e:	3c 8a       	std	Y+20, r3	; 0x14
    9e90:	fd 8a       	std	Y+21, r15	; 0x15
    9e92:	ee 8a       	std	Y+22, r14	; 0x16
			minoffsety = this->rawGyroY < minoffsety ? this->rawGyroY : minoffsety;
    9e94:	7b 8d       	ldd	r23, Y+27	; 0x1b
    9e96:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9e98:	9d 8d       	ldd	r25, Y+29	; 0x1d
    9e9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9e9c:	27 2f       	mov	r18, r23
    9e9e:	36 2f       	mov	r19, r22
    9ea0:	49 2f       	mov	r20, r25
    9ea2:	58 2f       	mov	r21, r24
    9ea4:	fb 80       	ldd	r15, Y+3	; 0x03
    9ea6:	ec 80       	ldd	r14, Y+4	; 0x04
    9ea8:	64 2d       	mov	r22, r4
    9eaa:	75 2d       	mov	r23, r5
    9eac:	8f 2d       	mov	r24, r15
    9eae:	9e 2d       	mov	r25, r14
    9eb0:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    9eb4:	88 23       	and	r24, r24
    9eb6:	24 f4       	brge	.+8      	; 0x9ec0 <_ZN10helicopter7sensors9IMUSensor4initEv+0x334>
    9eb8:	4b 8e       	std	Y+27, r4	; 0x1b
    9eba:	5c 8e       	std	Y+28, r5	; 0x1c
    9ebc:	fd 8e       	std	Y+29, r15	; 0x1d
    9ebe:	ee 8e       	std	Y+30, r14	; 0x1e
			minoffsetz = this->rawGyroZ < minoffsetz ? this->rawGyroZ : minoffsetz;
    9ec0:	7b a1       	ldd	r23, Y+35	; 0x23
    9ec2:	6c a1       	ldd	r22, Y+36	; 0x24
    9ec4:	9d a1       	ldd	r25, Y+37	; 0x25
    9ec6:	8e a1       	ldd	r24, Y+38	; 0x26
    9ec8:	27 2f       	mov	r18, r23
    9eca:	36 2f       	mov	r19, r22
    9ecc:	49 2f       	mov	r20, r25
    9ece:	58 2f       	mov	r21, r24
    9ed0:	fc a5       	ldd	r31, Y+44	; 0x2c
    9ed2:	eb a5       	ldd	r30, Y+43	; 0x2b
    9ed4:	60 2f       	mov	r22, r16
    9ed6:	71 2f       	mov	r23, r17
    9ed8:	8f 2f       	mov	r24, r31
    9eda:	9e 2f       	mov	r25, r30
    9edc:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    9ee0:	88 23       	and	r24, r24
    9ee2:	34 f4       	brge	.+12     	; 0x9ef0 <_ZN10helicopter7sensors9IMUSensor4initEv+0x364>
    9ee4:	0b a3       	std	Y+35, r16	; 0x23
    9ee6:	1c a3       	std	Y+36, r17	; 0x24
    9ee8:	8c a5       	ldd	r24, Y+44	; 0x2c
    9eea:	8d a3       	std	Y+37, r24	; 0x25
    9eec:	9b a5       	ldd	r25, Y+43	; 0x2b
    9eee:	9e a3       	std	Y+38, r25	; 0x26
			
			maxoffsetx = this->rawGyroX > maxoffsetx ? this->rawGyroX : maxoffsetx;
    9ef0:	7f 89       	ldd	r23, Y+23	; 0x17
    9ef2:	68 8d       	ldd	r22, Y+24	; 0x18
    9ef4:	99 8d       	ldd	r25, Y+25	; 0x19
    9ef6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9ef8:	27 2f       	mov	r18, r23
    9efa:	36 2f       	mov	r19, r22
    9efc:	49 2f       	mov	r20, r25
    9efe:	58 2f       	mov	r21, r24
    9f00:	f9 80       	ldd	r15, Y+1	; 0x01
    9f02:	ea 80       	ldd	r14, Y+2	; 0x02
    9f04:	62 2d       	mov	r22, r2
    9f06:	73 2d       	mov	r23, r3
    9f08:	8f 2d       	mov	r24, r15
    9f0a:	9e 2d       	mov	r25, r14
    9f0c:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    9f10:	18 16       	cp	r1, r24
    9f12:	24 f4       	brge	.+8      	; 0x9f1c <_ZN10helicopter7sensors9IMUSensor4initEv+0x390>
    9f14:	2f 8a       	std	Y+23, r2	; 0x17
    9f16:	38 8e       	std	Y+24, r3	; 0x18
    9f18:	f9 8e       	std	Y+25, r15	; 0x19
    9f1a:	ea 8e       	std	Y+26, r14	; 0x1a
			maxoffsety = this->rawGyroY > maxoffsety ? this->rawGyroY : maxoffsety;
    9f1c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    9f1e:	68 a1       	ldd	r22, Y+32	; 0x20
    9f20:	99 a1       	ldd	r25, Y+33	; 0x21
    9f22:	8a a1       	ldd	r24, Y+34	; 0x22
    9f24:	27 2f       	mov	r18, r23
    9f26:	36 2f       	mov	r19, r22
    9f28:	49 2f       	mov	r20, r25
    9f2a:	58 2f       	mov	r21, r24
    9f2c:	fb 80       	ldd	r15, Y+3	; 0x03
    9f2e:	ec 80       	ldd	r14, Y+4	; 0x04
    9f30:	64 2d       	mov	r22, r4
    9f32:	75 2d       	mov	r23, r5
    9f34:	8f 2d       	mov	r24, r15
    9f36:	9e 2d       	mov	r25, r14
    9f38:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    9f3c:	18 16       	cp	r1, r24
    9f3e:	24 f4       	brge	.+8      	; 0x9f48 <_ZN10helicopter7sensors9IMUSensor4initEv+0x3bc>
    9f40:	4f 8e       	std	Y+31, r4	; 0x1f
    9f42:	58 a2       	std	Y+32, r5	; 0x20
    9f44:	f9 a2       	std	Y+33, r15	; 0x21
    9f46:	ea a2       	std	Y+34, r14	; 0x22
			maxoffsetz = this->rawGyroZ > maxoffsetz ? this->rawGyroZ : maxoffsetz;
    9f48:	7f a1       	ldd	r23, Y+39	; 0x27
    9f4a:	68 a5       	ldd	r22, Y+40	; 0x28
    9f4c:	99 a5       	ldd	r25, Y+41	; 0x29
    9f4e:	8a a5       	ldd	r24, Y+42	; 0x2a
    9f50:	27 2f       	mov	r18, r23
    9f52:	36 2f       	mov	r19, r22
    9f54:	49 2f       	mov	r20, r25
    9f56:	58 2f       	mov	r21, r24
    9f58:	fc a5       	ldd	r31, Y+44	; 0x2c
    9f5a:	eb a5       	ldd	r30, Y+43	; 0x2b
    9f5c:	60 2f       	mov	r22, r16
    9f5e:	71 2f       	mov	r23, r17
    9f60:	8f 2f       	mov	r24, r31
    9f62:	9e 2f       	mov	r25, r30
    9f64:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    9f68:	18 16       	cp	r1, r24
    9f6a:	34 f4       	brge	.+12     	; 0x9f78 <_ZN10helicopter7sensors9IMUSensor4initEv+0x3ec>
    9f6c:	0f a3       	std	Y+39, r16	; 0x27
    9f6e:	18 a7       	std	Y+40, r17	; 0x28
    9f70:	2c a5       	ldd	r18, Y+44	; 0x2c
    9f72:	29 a7       	std	Y+41, r18	; 0x29
    9f74:	8b a5       	ldd	r24, Y+43	; 0x2b
    9f76:	8a a7       	std	Y+42, r24	; 0x2a
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    9f78:	98 ee       	ldi	r25, 0xE8	; 232
    9f7a:	69 16       	cp	r6, r25
    9f7c:	93 e0       	ldi	r25, 0x03	; 3
    9f7e:	79 06       	cpc	r7, r25
    9f80:	09 f0       	breq	.+2      	; 0x9f84 <_ZN10helicopter7sensors9IMUSensor4initEv+0x3f8>
    9f82:	c9 ce       	rjmp	.-622    	; 0x9d16 <_ZN10helicopter7sensors9IMUSensor4initEv+0x18a>
			
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
    9f84:	7b 89       	ldd	r23, Y+19	; 0x13
    9f86:	6c 89       	ldd	r22, Y+20	; 0x14
    9f88:	9d 89       	ldd	r25, Y+21	; 0x15
    9f8a:	8e 89       	ldd	r24, Y+22	; 0x16
    9f8c:	27 2f       	mov	r18, r23
    9f8e:	36 2f       	mov	r19, r22
    9f90:	49 2f       	mov	r20, r25
    9f92:	58 2f       	mov	r21, r24
    9f94:	bf 89       	ldd	r27, Y+23	; 0x17
    9f96:	a8 8d       	ldd	r26, Y+24	; 0x18
    9f98:	e9 8d       	ldd	r30, Y+25	; 0x19
    9f9a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    9f9c:	6b 2f       	mov	r22, r27
    9f9e:	7a 2f       	mov	r23, r26
    9fa0:	8e 2f       	mov	r24, r30
    9fa2:	91 2f       	mov	r25, r17
    9fa4:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    9fa8:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    9faa:	20 e0       	ldi	r18, 0x00	; 0
    9fac:	30 e0       	ldi	r19, 0x00	; 0
    9fae:	40 e2       	ldi	r20, 0x20	; 32
    9fb0:	51 e4       	ldi	r21, 0x41	; 65
    9fb2:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    9fb6:	88 23       	and	r24, r24
    9fb8:	b4 f5       	brge	.+108    	; 0xa026 <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
    9fba:	7b 8d       	ldd	r23, Y+27	; 0x1b
    9fbc:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9fbe:	9d 8d       	ldd	r25, Y+29	; 0x1d
    9fc0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9fc2:	27 2f       	mov	r18, r23
    9fc4:	36 2f       	mov	r19, r22
    9fc6:	49 2f       	mov	r20, r25
    9fc8:	58 2f       	mov	r21, r24
    9fca:	bf 8d       	ldd	r27, Y+31	; 0x1f
    9fcc:	a8 a1       	ldd	r26, Y+32	; 0x20
    9fce:	e9 a1       	ldd	r30, Y+33	; 0x21
    9fd0:	1a a1       	ldd	r17, Y+34	; 0x22
    9fd2:	6b 2f       	mov	r22, r27
    9fd4:	7a 2f       	mov	r23, r26
    9fd6:	8e 2f       	mov	r24, r30
    9fd8:	91 2f       	mov	r25, r17
    9fda:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    9fde:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    9fe0:	20 e0       	ldi	r18, 0x00	; 0
    9fe2:	30 e0       	ldi	r19, 0x00	; 0
    9fe4:	40 e2       	ldi	r20, 0x20	; 32
    9fe6:	51 e4       	ldi	r21, 0x41	; 65
    9fe8:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    9fec:	88 23       	and	r24, r24
    9fee:	dc f4       	brge	.+54     	; 0xa026 <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
		float differenceZ = fabs(maxoffsetz - minoffsetz);
    9ff0:	7b a1       	ldd	r23, Y+35	; 0x23
    9ff2:	6c a1       	ldd	r22, Y+36	; 0x24
    9ff4:	9d a1       	ldd	r25, Y+37	; 0x25
    9ff6:	8e a1       	ldd	r24, Y+38	; 0x26
    9ff8:	27 2f       	mov	r18, r23
    9ffa:	36 2f       	mov	r19, r22
    9ffc:	49 2f       	mov	r20, r25
    9ffe:	58 2f       	mov	r21, r24
    a000:	bf a1       	ldd	r27, Y+39	; 0x27
    a002:	a8 a5       	ldd	r26, Y+40	; 0x28
    a004:	e9 a5       	ldd	r30, Y+41	; 0x29
    a006:	1a a5       	ldd	r17, Y+42	; 0x2a
    a008:	6b 2f       	mov	r22, r27
    a00a:	7a 2f       	mov	r23, r26
    a00c:	8e 2f       	mov	r24, r30
    a00e:	91 2f       	mov	r25, r17
    a010:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    a014:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    a016:	20 e0       	ldi	r18, 0x00	; 0
    a018:	30 e0       	ldi	r19, 0x00	; 0
    a01a:	40 e2       	ldi	r20, 0x20	; 32
    a01c:	51 e4       	ldi	r21, 0x41	; 65
    a01e:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    a022:	88 23       	and	r24, r24
    a024:	44 f0       	brlt	.+16     	; 0xa036 <_ZN10helicopter7sensors9IMUSensor4initEv+0x4aa>
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 16384;



void IMUSensor::init()
{
    a026:	0f 2e       	mov	r0, r31
    a028:	f4 e1       	ldi	r31, 0x14	; 20
    a02a:	ef 2e       	mov	r14, r31
    a02c:	f1 2c       	mov	r15, r1
    a02e:	f0 2d       	mov	r31, r0
    a030:	0d 81       	ldd	r16, Y+5	; 0x05
    a032:	1e 81       	ldd	r17, Y+6	; 0x06
    a034:	1b ce       	rjmp	.-970    	; 0x9c6c <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			isStable = true;
		}
		
	}
	
	this->gyroOffsets[0] = offsetx;
    a036:	ed 81       	ldd	r30, Y+5	; 0x05
    a038:	fe 81       	ldd	r31, Y+6	; 0x06
    a03a:	e4 5b       	subi	r30, 0xB4	; 180
    a03c:	ff 4f       	sbci	r31, 0xFF	; 255
    a03e:	5f 81       	ldd	r21, Y+7	; 0x07
    a040:	48 85       	ldd	r20, Y+8	; 0x08
    a042:	39 85       	ldd	r19, Y+9	; 0x09
    a044:	2a 85       	ldd	r18, Y+10	; 0x0a
    a046:	85 2f       	mov	r24, r21
    a048:	94 2f       	mov	r25, r20
    a04a:	a3 2f       	mov	r26, r19
    a04c:	b2 2f       	mov	r27, r18
    a04e:	80 83       	st	Z, r24
    a050:	91 83       	std	Z+1, r25	; 0x01
    a052:	a2 83       	std	Z+2, r26	; 0x02
    a054:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[1] = offsety;
    a056:	ed 81       	ldd	r30, Y+5	; 0x05
    a058:	fe 81       	ldd	r31, Y+6	; 0x06
    a05a:	e0 5b       	subi	r30, 0xB0	; 176
    a05c:	ff 4f       	sbci	r31, 0xFF	; 255
    a05e:	5b 85       	ldd	r21, Y+11	; 0x0b
    a060:	4c 85       	ldd	r20, Y+12	; 0x0c
    a062:	3d 85       	ldd	r19, Y+13	; 0x0d
    a064:	2e 85       	ldd	r18, Y+14	; 0x0e
    a066:	85 2f       	mov	r24, r21
    a068:	94 2f       	mov	r25, r20
    a06a:	a3 2f       	mov	r26, r19
    a06c:	b2 2f       	mov	r27, r18
    a06e:	80 83       	st	Z, r24
    a070:	91 83       	std	Z+1, r25	; 0x01
    a072:	a2 83       	std	Z+2, r26	; 0x02
    a074:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[2] = offsetz;
    a076:	ed 81       	ldd	r30, Y+5	; 0x05
    a078:	fe 81       	ldd	r31, Y+6	; 0x06
    a07a:	ec 5a       	subi	r30, 0xAC	; 172
    a07c:	ff 4f       	sbci	r31, 0xFF	; 255
    a07e:	5f 85       	ldd	r21, Y+15	; 0x0f
    a080:	48 89       	ldd	r20, Y+16	; 0x10
    a082:	39 89       	ldd	r19, Y+17	; 0x11
    a084:	2a 89       	ldd	r18, Y+18	; 0x12
    a086:	85 2f       	mov	r24, r21
    a088:	94 2f       	mov	r25, r20
    a08a:	a3 2f       	mov	r26, r19
    a08c:	b2 2f       	mov	r27, r18
    a08e:	80 83       	st	Z, r24
    a090:	91 83       	std	Z+1, r25	; 0x01
    a092:	a2 83       	std	Z+2, r26	; 0x02
    a094:	b3 83       	std	Z+3, r27	; 0x03
	
}
    a096:	ac 96       	adiw	r28, 0x2c	; 44
    a098:	0f b6       	in	r0, 0x3f	; 63
    a09a:	f8 94       	cli
    a09c:	de bf       	out	0x3e, r29	; 62
    a09e:	0f be       	out	0x3f, r0	; 63
    a0a0:	cd bf       	out	0x3d, r28	; 61
    a0a2:	df 91       	pop	r29
    a0a4:	cf 91       	pop	r28
    a0a6:	1f 91       	pop	r17
    a0a8:	0f 91       	pop	r16
    a0aa:	ff 90       	pop	r15
    a0ac:	ef 90       	pop	r14
    a0ae:	df 90       	pop	r13
    a0b0:	cf 90       	pop	r12
    a0b2:	bf 90       	pop	r11
    a0b4:	af 90       	pop	r10
    a0b6:	9f 90       	pop	r9
    a0b8:	8f 90       	pop	r8
    a0ba:	7f 90       	pop	r7
    a0bc:	6f 90       	pop	r6
    a0be:	5f 90       	pop	r5
    a0c0:	4f 90       	pop	r4
    a0c2:	3f 90       	pop	r3
    a0c4:	2f 90       	pop	r2
    a0c6:	08 95       	ret

0000a0c8 <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>:
		_offset[1] = new_offsets[1];
		_offset[2] = new_offsets[2];
	
}

MagnetometerSensor::MagnetometerSensor(TWIDriver *driver):
    a0c8:	cf 92       	push	r12
    a0ca:	df 92       	push	r13
    a0cc:	ef 92       	push	r14
    a0ce:	ff 92       	push	r15
    a0d0:	0f 93       	push	r16
    a0d2:	1f 93       	push	r17
    a0d4:	fc 01       	movw	r30, r24
	rawMagY(0),
	rawMagZ(0),
	frdMagX(0),
	frdMagY(0),
	frdMagZ(0),
	driver(driver)
    a0d6:	11 82       	std	Z+1, r1	; 0x01
    a0d8:	10 82       	st	Z, r1
    a0da:	13 82       	std	Z+3, r1	; 0x03
    a0dc:	12 82       	std	Z+2, r1	; 0x02
    a0de:	15 82       	std	Z+5, r1	; 0x05
    a0e0:	14 82       	std	Z+4, r1	; 0x04
    a0e2:	16 82       	std	Z+6, r1	; 0x06
    a0e4:	17 82       	std	Z+7, r1	; 0x07
    a0e6:	10 86       	std	Z+8, r1	; 0x08
    a0e8:	11 86       	std	Z+9, r1	; 0x09
    a0ea:	12 86       	std	Z+10, r1	; 0x0a
    a0ec:	13 86       	std	Z+11, r1	; 0x0b
    a0ee:	14 86       	std	Z+12, r1	; 0x0c
    a0f0:	15 86       	std	Z+13, r1	; 0x0d
    a0f2:	16 86       	std	Z+14, r1	; 0x0e
    a0f4:	17 86       	std	Z+15, r1	; 0x0f
    a0f6:	10 8a       	std	Z+16, r1	; 0x10
    a0f8:	11 8a       	std	Z+17, r1	; 0x11
    a0fa:	77 ab       	std	Z+55, r23	; 0x37
    a0fc:	66 ab       	std	Z+54, r22	; 0x36
	/**
		* Create a rotation matrix to rotate the magnetometer sensor data by
		* 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
		* counterclockwise on the Z axis.
		*/
	memset(magLBUToFRDRotationMatrix,0,sizeof(magLBUToFRDRotationMatrix));
    a0fe:	6c 01       	movw	r12, r24
    a100:	82 e1       	ldi	r24, 0x12	; 18
    a102:	c8 0e       	add	r12, r24
    a104:	d1 1c       	adc	r13, r1
    a106:	84 e2       	ldi	r24, 0x24	; 36
    a108:	f6 01       	movw	r30, r12
    a10a:	11 92       	st	Z+, r1
    a10c:	8a 95       	dec	r24
    a10e:	e9 f7       	brne	.-6      	; 0xa10a <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE+0x42>
					
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
	MatrixUtil::CreateRotationMatrix(0.0f, 0.0f, (M_PI/2.0f), magLBUToFRDRotationMatrix);
    a110:	1b ed       	ldi	r17, 0xDB	; 219
    a112:	e1 2e       	mov	r14, r17
    a114:	1f e0       	ldi	r17, 0x0F	; 15
    a116:	f1 2e       	mov	r15, r17
    a118:	09 ec       	ldi	r16, 0xC9	; 201
    a11a:	1f e3       	ldi	r17, 0x3F	; 63
    a11c:	20 e0       	ldi	r18, 0x00	; 0
    a11e:	30 e0       	ldi	r19, 0x00	; 0
    a120:	a9 01       	movw	r20, r18
    a122:	ca 01       	movw	r24, r20
    a124:	b9 01       	movw	r22, r18
    a126:	0e 94 1d 67 	call	0xce3a	; 0xce3a <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
}
    a12a:	1f 91       	pop	r17
    a12c:	0f 91       	pop	r16
    a12e:	ff 90       	pop	r15
    a130:	ef 90       	pop	r14
    a132:	df 90       	pop	r13
    a134:	cf 90       	pop	r12
    a136:	08 95       	ret

0000a138 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>:


float _offsets2[3] = {0};
float previousMag[3] = {.001, .001, .001};
int MagnetometerSensor::readSensor()
{
    a138:	0f 93       	push	r16
    a13a:	1f 93       	push	r17
    a13c:	cf 93       	push	r28
    a13e:	df 93       	push	r29
    a140:	cd b7       	in	r28, 0x3d	; 61
    a142:	de b7       	in	r29, 0x3e	; 62
    a144:	64 97       	sbiw	r28, 0x14	; 20
    a146:	0f b6       	in	r0, 0x3f	; 63
    a148:	f8 94       	cli
    a14a:	de bf       	out	0x3e, r29	; 62
    a14c:	0f be       	out	0x3f, r0	; 63
    a14e:	cd bf       	out	0x3d, r28	; 61
    a150:	8c 01       	movw	r16, r24
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    a152:	fc 01       	movw	r30, r24
    a154:	86 a9       	ldd	r24, Z+54	; 0x36
    a156:	97 a9       	ldd	r25, Z+55	; 0x37
    a158:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a15c:	81 11       	cpse	r24, r1
    a15e:	08 c0       	rjmp	.+16     	; 0xa170 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x38>
    a160:	f8 01       	movw	r30, r16
    a162:	86 a9       	ldd	r24, Z+54	; 0x36
    a164:	97 a9       	ldd	r25, Z+55	; 0x37
    a166:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a16a:	2f ef       	ldi	r18, 0xFF	; 255
    a16c:	3f ef       	ldi	r19, 0xFF	; 255
    a16e:	61 c1       	rjmp	.+706    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		driver->stop();
		return -1;
	}*/		
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK));
    a170:	48 e1       	ldi	r20, 0x18	; 24
    a172:	6c e3       	ldi	r22, 0x3C	; 60
    a174:	f8 01       	movw	r30, r16
    a176:	86 a9       	ldd	r24, Z+54	; 0x36
    a178:	97 a9       	ldd	r25, Z+55	; 0x37
    a17a:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a17e:	81 11       	cpse	r24, r1
    a180:	08 c0       	rjmp	.+16     	; 0xa192 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x5a>
    a182:	f8 01       	movw	r30, r16
    a184:	86 a9       	ldd	r24, Z+54	; 0x36
    a186:	97 a9       	ldd	r25, Z+55	; 0x37
    a188:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a18c:	2f ef       	ldi	r18, 0xFF	; 255
    a18e:	3f ef       	ldi	r19, 0xFF	; 255
    a190:	50 c1       	rjmp	.+672    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK));
    a192:	48 e2       	ldi	r20, 0x28	; 40
    a194:	63 e0       	ldi	r22, 0x03	; 3
    a196:	f8 01       	movw	r30, r16
    a198:	86 a9       	ldd	r24, Z+54	; 0x36
    a19a:	97 a9       	ldd	r25, Z+55	; 0x37
    a19c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a1a0:	81 11       	cpse	r24, r1
    a1a2:	08 c0       	rjmp	.+16     	; 0xa1b4 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x7c>
    a1a4:	f8 01       	movw	r30, r16
    a1a6:	86 a9       	ldd	r24, Z+54	; 0x36
    a1a8:	97 a9       	ldd	r25, Z+55	; 0x37
    a1aa:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1ae:	2f ef       	ldi	r18, 0xFF	; 255
    a1b0:	3f ef       	ldi	r19, 0xFF	; 255
    a1b2:	3f c1       	rjmp	.+638    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    a1b4:	f8 01       	movw	r30, r16
    a1b6:	86 a9       	ldd	r24, Z+54	; 0x36
    a1b8:	97 a9       	ldd	r25, Z+55	; 0x37
    a1ba:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a1be:	81 11       	cpse	r24, r1
    a1c0:	08 c0       	rjmp	.+16     	; 0xa1d2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x9a>
    a1c2:	f8 01       	movw	r30, r16
    a1c4:	86 a9       	ldd	r24, Z+54	; 0x36
    a1c6:	97 a9       	ldd	r25, Z+55	; 0x37
    a1c8:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1cc:	2f ef       	ldi	r18, 0xFF	; 255
    a1ce:	3f ef       	ldi	r19, 0xFF	; 255
    a1d0:	30 c1       	rjmp	.+608    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK));
    a1d2:	40 e4       	ldi	r20, 0x40	; 64
    a1d4:	6d e3       	ldi	r22, 0x3D	; 61
    a1d6:	f8 01       	movw	r30, r16
    a1d8:	86 a9       	ldd	r24, Z+54	; 0x36
    a1da:	97 a9       	ldd	r25, Z+55	; 0x37
    a1dc:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a1e0:	81 11       	cpse	r24, r1
    a1e2:	08 c0       	rjmp	.+16     	; 0xa1f4 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xbc>
    a1e4:	f8 01       	movw	r30, r16
    a1e6:	86 a9       	ldd	r24, Z+54	; 0x36
    a1e8:	97 a9       	ldd	r25, Z+55	; 0x37
    a1ea:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1ee:	2f ef       	ldi	r18, 0xFF	; 255
    a1f0:	3f ef       	ldi	r19, 0xFF	; 255
    a1f2:	1f c1       	rjmp	.+574    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	
	
		
	byte highByte = 0;
    a1f4:	1c 8a       	std	Y+20, r1	; 0x14
	byte lowByte = 0;
    a1f6:	1b 8a       	std	Y+19, r1	; 0x13
		
	CHECK(driver->readByte(true, highByte));
    a1f8:	ae 01       	movw	r20, r28
    a1fa:	4c 5e       	subi	r20, 0xEC	; 236
    a1fc:	5f 4f       	sbci	r21, 0xFF	; 255
    a1fe:	61 e0       	ldi	r22, 0x01	; 1
    a200:	f8 01       	movw	r30, r16
    a202:	86 a9       	ldd	r24, Z+54	; 0x36
    a204:	97 a9       	ldd	r25, Z+55	; 0x37
    a206:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a20a:	81 11       	cpse	r24, r1
    a20c:	08 c0       	rjmp	.+16     	; 0xa21e <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xe6>
    a20e:	f8 01       	movw	r30, r16
    a210:	86 a9       	ldd	r24, Z+54	; 0x36
    a212:	97 a9       	ldd	r25, Z+55	; 0x37
    a214:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a218:	2f ef       	ldi	r18, 0xFF	; 255
    a21a:	3f ef       	ldi	r19, 0xFF	; 255
    a21c:	0a c1       	rjmp	.+532    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	CHECK(driver->readByte(true, lowByte));
    a21e:	ae 01       	movw	r20, r28
    a220:	4d 5e       	subi	r20, 0xED	; 237
    a222:	5f 4f       	sbci	r21, 0xFF	; 255
    a224:	61 e0       	ldi	r22, 0x01	; 1
    a226:	f8 01       	movw	r30, r16
    a228:	86 a9       	ldd	r24, Z+54	; 0x36
    a22a:	97 a9       	ldd	r25, Z+55	; 0x37
    a22c:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a230:	81 11       	cpse	r24, r1
    a232:	08 c0       	rjmp	.+16     	; 0xa244 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x10c>
    a234:	f8 01       	movw	r30, r16
    a236:	86 a9       	ldd	r24, Z+54	; 0x36
    a238:	97 a9       	ldd	r25, Z+55	; 0x37
    a23a:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a23e:	2f ef       	ldi	r18, 0xFF	; 255
    a240:	3f ef       	ldi	r19, 0xFF	; 255
    a242:	f7 c0       	rjmp	.+494    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagX = (highByte << 8) | (lowByte);
    a244:	9c 89       	ldd	r25, Y+20	; 0x14
    a246:	80 e0       	ldi	r24, 0x00	; 0
    a248:	2b 89       	ldd	r18, Y+19	; 0x13
    a24a:	82 2b       	or	r24, r18
    a24c:	f8 01       	movw	r30, r16
    a24e:	91 83       	std	Z+1, r25	; 0x01
    a250:	80 83       	st	Z, r24
		
	CHECK(driver->readByte(true, highByte));
    a252:	ae 01       	movw	r20, r28
    a254:	4c 5e       	subi	r20, 0xEC	; 236
    a256:	5f 4f       	sbci	r21, 0xFF	; 255
    a258:	61 e0       	ldi	r22, 0x01	; 1
    a25a:	86 a9       	ldd	r24, Z+54	; 0x36
    a25c:	97 a9       	ldd	r25, Z+55	; 0x37
    a25e:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a262:	81 11       	cpse	r24, r1
    a264:	08 c0       	rjmp	.+16     	; 0xa276 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x13e>
    a266:	f8 01       	movw	r30, r16
    a268:	86 a9       	ldd	r24, Z+54	; 0x36
    a26a:	97 a9       	ldd	r25, Z+55	; 0x37
    a26c:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a270:	2f ef       	ldi	r18, 0xFF	; 255
    a272:	3f ef       	ldi	r19, 0xFF	; 255
    a274:	de c0       	rjmp	.+444    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	CHECK(driver->readByte(true, lowByte));
    a276:	ae 01       	movw	r20, r28
    a278:	4d 5e       	subi	r20, 0xED	; 237
    a27a:	5f 4f       	sbci	r21, 0xFF	; 255
    a27c:	61 e0       	ldi	r22, 0x01	; 1
    a27e:	f8 01       	movw	r30, r16
    a280:	86 a9       	ldd	r24, Z+54	; 0x36
    a282:	97 a9       	ldd	r25, Z+55	; 0x37
    a284:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a288:	81 11       	cpse	r24, r1
    a28a:	08 c0       	rjmp	.+16     	; 0xa29c <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x164>
    a28c:	f8 01       	movw	r30, r16
    a28e:	86 a9       	ldd	r24, Z+54	; 0x36
    a290:	97 a9       	ldd	r25, Z+55	; 0x37
    a292:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a296:	2f ef       	ldi	r18, 0xFF	; 255
    a298:	3f ef       	ldi	r19, 0xFF	; 255
    a29a:	cb c0       	rjmp	.+406    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagZ = (highByte << 8) | (lowByte);
    a29c:	9c 89       	ldd	r25, Y+20	; 0x14
    a29e:	80 e0       	ldi	r24, 0x00	; 0
    a2a0:	2b 89       	ldd	r18, Y+19	; 0x13
    a2a2:	82 2b       	or	r24, r18
    a2a4:	f8 01       	movw	r30, r16
    a2a6:	95 83       	std	Z+5, r25	; 0x05
    a2a8:	84 83       	std	Z+4, r24	; 0x04
		
	CHECK(driver->readByte(true, highByte));
    a2aa:	ae 01       	movw	r20, r28
    a2ac:	4c 5e       	subi	r20, 0xEC	; 236
    a2ae:	5f 4f       	sbci	r21, 0xFF	; 255
    a2b0:	61 e0       	ldi	r22, 0x01	; 1
    a2b2:	86 a9       	ldd	r24, Z+54	; 0x36
    a2b4:	97 a9       	ldd	r25, Z+55	; 0x37
    a2b6:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a2ba:	81 11       	cpse	r24, r1
    a2bc:	08 c0       	rjmp	.+16     	; 0xa2ce <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x196>
    a2be:	f8 01       	movw	r30, r16
    a2c0:	86 a9       	ldd	r24, Z+54	; 0x36
    a2c2:	97 a9       	ldd	r25, Z+55	; 0x37
    a2c4:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a2c8:	2f ef       	ldi	r18, 0xFF	; 255
    a2ca:	3f ef       	ldi	r19, 0xFF	; 255
    a2cc:	b2 c0       	rjmp	.+356    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
		
	//We don't send an acknowledgment on the last byte to be read (the magnetic Y values low byte) because of an apparent undocumented requirement by the device
	//that the nack needs to be sent to have the internal pointer go back to the magnetic X variable.
	//According to wikipedia, when in masterreceive mode, the master sends an ack bit after every byte read except for the last one. 
	CHECK(driver->readByte(false, lowByte));
    a2ce:	ae 01       	movw	r20, r28
    a2d0:	4d 5e       	subi	r20, 0xED	; 237
    a2d2:	5f 4f       	sbci	r21, 0xFF	; 255
    a2d4:	60 e0       	ldi	r22, 0x00	; 0
    a2d6:	f8 01       	movw	r30, r16
    a2d8:	86 a9       	ldd	r24, Z+54	; 0x36
    a2da:	97 a9       	ldd	r25, Z+55	; 0x37
    a2dc:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a2e0:	81 11       	cpse	r24, r1
    a2e2:	08 c0       	rjmp	.+16     	; 0xa2f4 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1bc>
    a2e4:	f8 01       	movw	r30, r16
    a2e6:	86 a9       	ldd	r24, Z+54	; 0x36
    a2e8:	97 a9       	ldd	r25, Z+55	; 0x37
    a2ea:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a2ee:	2f ef       	ldi	r18, 0xFF	; 255
    a2f0:	3f ef       	ldi	r19, 0xFF	; 255
    a2f2:	9f c0       	rjmp	.+318    	; 0xa432 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagY = (highByte << 8) | (lowByte);		
    a2f4:	9c 89       	ldd	r25, Y+20	; 0x14
    a2f6:	80 e0       	ldi	r24, 0x00	; 0
    a2f8:	2b 89       	ldd	r18, Y+19	; 0x13
    a2fa:	82 2b       	or	r24, r18
    a2fc:	f8 01       	movw	r30, r16
    a2fe:	93 83       	std	Z+3, r25	; 0x03
    a300:	82 83       	std	Z+2, r24	; 0x02
	
	//transmit stop condition
	driver->stop();
    a302:	86 a9       	ldd	r24, Z+54	; 0x36
    a304:	97 a9       	ldd	r25, Z+55	; 0x37
    a306:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
		
	/**
	 * correct for magnetic interference. Code from ardupilot file found here:
	 * https://github.com/diydrones/ardupilot/blob/6af705d4554defc27aa475dab99f918b26de3ce1/libraries/AP_Compass/Compass_learn.cpp
	 */
	if (readyForOffsets)
    a30a:	80 91 25 04 	lds	r24, 0x0425
    a30e:	88 23       	and	r24, r24
    a310:	09 f4       	brne	.+2      	; 0xa314 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1dc>
    a312:	46 c0       	rjmp	.+140    	; 0xa3a0 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x268>
	{
		rawMagX *= calibration[0];
    a314:	f8 01       	movw	r30, r16
    a316:	60 81       	ld	r22, Z
    a318:	71 81       	ldd	r23, Z+1	; 0x01
    a31a:	88 27       	eor	r24, r24
    a31c:	77 fd       	sbrc	r23, 7
    a31e:	80 95       	com	r24
    a320:	98 2f       	mov	r25, r24
    a322:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a326:	20 91 26 04 	lds	r18, 0x0426
    a32a:	30 91 27 04 	lds	r19, 0x0427
    a32e:	40 91 28 04 	lds	r20, 0x0428
    a332:	50 91 29 04 	lds	r21, 0x0429
    a336:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    a33a:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    a33e:	f8 01       	movw	r30, r16
    a340:	71 83       	std	Z+1, r23	; 0x01
    a342:	60 83       	st	Z, r22
		rawMagY *= calibration[1];
    a344:	62 81       	ldd	r22, Z+2	; 0x02
    a346:	73 81       	ldd	r23, Z+3	; 0x03
    a348:	88 27       	eor	r24, r24
    a34a:	77 fd       	sbrc	r23, 7
    a34c:	80 95       	com	r24
    a34e:	98 2f       	mov	r25, r24
    a350:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a354:	20 91 2a 04 	lds	r18, 0x042A
    a358:	30 91 2b 04 	lds	r19, 0x042B
    a35c:	40 91 2c 04 	lds	r20, 0x042C
    a360:	50 91 2d 04 	lds	r21, 0x042D
    a364:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    a368:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    a36c:	f8 01       	movw	r30, r16
    a36e:	73 83       	std	Z+3, r23	; 0x03
    a370:	62 83       	std	Z+2, r22	; 0x02
		rawMagZ *= calibration[2];
    a372:	64 81       	ldd	r22, Z+4	; 0x04
    a374:	75 81       	ldd	r23, Z+5	; 0x05
    a376:	88 27       	eor	r24, r24
    a378:	77 fd       	sbrc	r23, 7
    a37a:	80 95       	com	r24
    a37c:	98 2f       	mov	r25, r24
    a37e:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a382:	20 91 2e 04 	lds	r18, 0x042E
    a386:	30 91 2f 04 	lds	r19, 0x042F
    a38a:	40 91 30 04 	lds	r20, 0x0430
    a38e:	50 91 31 04 	lds	r21, 0x0431
    a392:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    a396:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    a39a:	f8 01       	movw	r30, r16
    a39c:	75 83       	std	Z+5, r23	; 0x05
    a39e:	64 83       	std	Z+4, r22	; 0x04
		
		
		
	
	//Convert the raw values to FRD values.
	float rotatedValues[3] = {0};
    a3a0:	ae 01       	movw	r20, r28
    a3a2:	4f 5f       	subi	r20, 0xFF	; 255
    a3a4:	5f 4f       	sbci	r21, 0xFF	; 255
    a3a6:	8c e0       	ldi	r24, 0x0C	; 12
    a3a8:	fa 01       	movw	r30, r20
    a3aa:	11 92       	st	Z+, r1
    a3ac:	8a 95       	dec	r24
    a3ae:	e9 f7       	brne	.-6      	; 0xa3aa <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x272>
	int values[3] = {rawMagX, rawMagY, rawMagZ};
    a3b0:	f8 01       	movw	r30, r16
    a3b2:	80 81       	ld	r24, Z
    a3b4:	91 81       	ldd	r25, Z+1	; 0x01
    a3b6:	9e 87       	std	Y+14, r25	; 0x0e
    a3b8:	8d 87       	std	Y+13, r24	; 0x0d
    a3ba:	82 81       	ldd	r24, Z+2	; 0x02
    a3bc:	93 81       	ldd	r25, Z+3	; 0x03
    a3be:	98 8b       	std	Y+16, r25	; 0x10
    a3c0:	8f 87       	std	Y+15, r24	; 0x0f
    a3c2:	84 81       	ldd	r24, Z+4	; 0x04
    a3c4:	95 81       	ldd	r25, Z+5	; 0x05
    a3c6:	9a 8b       	std	Y+18, r25	; 0x12
    a3c8:	89 8b       	std	Y+17, r24	; 0x11
	
	MatrixUtil::RotateMatrix(magLBUToFRDRotationMatrix, values, rotatedValues);
    a3ca:	be 01       	movw	r22, r28
    a3cc:	63 5f       	subi	r22, 0xF3	; 243
    a3ce:	7f 4f       	sbci	r23, 0xFF	; 255
    a3d0:	c8 01       	movw	r24, r16
    a3d2:	42 96       	adiw	r24, 0x12	; 18
    a3d4:	0e 94 c1 68 	call	0xd182	; 0xd182 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>

	//Manually rotate in order to reduce processing
	
	/*frdMagX = rawMagY;
	frdMagY = -rawMagX;*/
	frdMagX = -rawMagY;
    a3d8:	f8 01       	movw	r30, r16
    a3da:	62 81       	ldd	r22, Z+2	; 0x02
    a3dc:	73 81       	ldd	r23, Z+3	; 0x03
    a3de:	71 95       	neg	r23
    a3e0:	61 95       	neg	r22
    a3e2:	71 09       	sbc	r23, r1
    a3e4:	88 27       	eor	r24, r24
    a3e6:	77 fd       	sbrc	r23, 7
    a3e8:	80 95       	com	r24
    a3ea:	98 2f       	mov	r25, r24
    a3ec:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a3f0:	f8 01       	movw	r30, r16
    a3f2:	66 83       	std	Z+6, r22	; 0x06
    a3f4:	77 83       	std	Z+7, r23	; 0x07
    a3f6:	80 87       	std	Z+8, r24	; 0x08
    a3f8:	91 87       	std	Z+9, r25	; 0x09
	frdMagY = rawMagX;
    a3fa:	60 81       	ld	r22, Z
    a3fc:	71 81       	ldd	r23, Z+1	; 0x01
    a3fe:	88 27       	eor	r24, r24
    a400:	77 fd       	sbrc	r23, 7
    a402:	80 95       	com	r24
    a404:	98 2f       	mov	r25, r24
    a406:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a40a:	f8 01       	movw	r30, r16
    a40c:	62 87       	std	Z+10, r22	; 0x0a
    a40e:	73 87       	std	Z+11, r23	; 0x0b
    a410:	84 87       	std	Z+12, r24	; 0x0c
    a412:	95 87       	std	Z+13, r25	; 0x0d
	frdMagZ = rawMagZ;
    a414:	64 81       	ldd	r22, Z+4	; 0x04
    a416:	75 81       	ldd	r23, Z+5	; 0x05
    a418:	88 27       	eor	r24, r24
    a41a:	77 fd       	sbrc	r23, 7
    a41c:	80 95       	com	r24
    a41e:	98 2f       	mov	r25, r24
    a420:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a424:	f8 01       	movw	r30, r16
    a426:	66 87       	std	Z+14, r22	; 0x0e
    a428:	77 87       	std	Z+15, r23	; 0x0f
    a42a:	80 8b       	std	Z+16, r24	; 0x10
    a42c:	91 8b       	std	Z+17, r25	; 0x11
		
		
		
		
		
	return 0;
    a42e:	20 e0       	ldi	r18, 0x00	; 0
    a430:	30 e0       	ldi	r19, 0x00	; 0
    a432:	82 2f       	mov	r24, r18
    a434:	93 2f       	mov	r25, r19
    a436:	64 96       	adiw	r28, 0x14	; 20
    a438:	0f b6       	in	r0, 0x3f	; 63
    a43a:	f8 94       	cli
    a43c:	de bf       	out	0x3e, r29	; 62
    a43e:	0f be       	out	0x3f, r0	; 63
    a440:	cd bf       	out	0x3d, r28	; 61
    a442:	df 91       	pop	r29
    a444:	cf 91       	pop	r28
    a446:	1f 91       	pop	r17
    a448:	0f 91       	pop	r16
    a44a:	08 95       	ret

0000a44c <_ZN10helicopter7sensors18MagnetometerSensor4initEv>:

float calibration[3] = {};
bool readyForOffsets = false;

bool MagnetometerSensor::init()
{
    a44c:	2f 92       	push	r2
    a44e:	3f 92       	push	r3
    a450:	4f 92       	push	r4
    a452:	5f 92       	push	r5
    a454:	6f 92       	push	r6
    a456:	7f 92       	push	r7
    a458:	8f 92       	push	r8
    a45a:	9f 92       	push	r9
    a45c:	af 92       	push	r10
    a45e:	bf 92       	push	r11
    a460:	cf 92       	push	r12
    a462:	df 92       	push	r13
    a464:	ef 92       	push	r14
    a466:	ff 92       	push	r15
    a468:	0f 93       	push	r16
    a46a:	1f 93       	push	r17
    a46c:	cf 93       	push	r28
    a46e:	df 93       	push	r29
    a470:	ec 01       	movw	r28, r24
	* Configure the output rate of the sensor, and number of samples that are averaged
	* per measurement output
	*/
	
	//Start a two wire transaction
	if(!driver->start())
    a472:	8e a9       	ldd	r24, Y+54	; 0x36
    a474:	9f a9       	ldd	r25, Y+55	; 0x37
    a476:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a47a:	88 23       	and	r24, r24
    a47c:	09 f4       	brne	.+2      	; 0xa480 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x34>
    a47e:	6f c2       	rjmp	.+1246   	; 0xa95e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x512>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation 
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a480:	48 e1       	ldi	r20, 0x18	; 24
    a482:	6c e3       	ldi	r22, 0x3C	; 60
    a484:	8e a9       	ldd	r24, Y+54	; 0x36
    a486:	9f a9       	ldd	r25, Y+55	; 0x37
    a488:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a48c:	88 23       	and	r24, r24
    a48e:	09 f4       	brne	.+2      	; 0xa492 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x46>
    a490:	68 c2       	rjmp	.+1232   	; 0xa962 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x516>
	{
		return false;
	}
		
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a492:	48 e2       	ldi	r20, 0x28	; 40
    a494:	60 e0       	ldi	r22, 0x00	; 0
    a496:	8e a9       	ldd	r24, Y+54	; 0x36
    a498:	9f a9       	ldd	r25, Y+55	; 0x37
    a49a:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a49e:	88 23       	and	r24, r24
    a4a0:	09 f4       	brne	.+2      	; 0xa4a4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58>
    a4a2:	61 c2       	rjmp	.+1218   	; 0xa966 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x51a>
	{
		return false;
	}
		
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a4a4:	48 e2       	ldi	r20, 0x28	; 40
    a4a6:	68 e7       	ldi	r22, 0x78	; 120
    a4a8:	8e a9       	ldd	r24, Y+54	; 0x36
    a4aa:	9f a9       	ldd	r25, Y+55	; 0x37
    a4ac:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4b0:	88 23       	and	r24, r24
    a4b2:	09 f4       	brne	.+2      	; 0xa4b6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x6a>
    a4b4:	5a c2       	rjmp	.+1204   	; 0xa96a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x51e>
	{
		return false;
	}	

	//end the transaction
	driver->stop();
    a4b6:	8e a9       	ldd	r24, Y+54	; 0x36
    a4b8:	9f a9       	ldd	r25, Y+55	; 0x37
    a4ba:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    a4be:	8e a9       	ldd	r24, Y+54	; 0x36
    a4c0:	9f a9       	ldd	r25, Y+55	; 0x37
    a4c2:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a4c6:	88 23       	and	r24, r24
    a4c8:	09 f4       	brne	.+2      	; 0xa4cc <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x80>
    a4ca:	51 c2       	rjmp	.+1186   	; 0xa96e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x522>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a4cc:	48 e1       	ldi	r20, 0x18	; 24
    a4ce:	6c e3       	ldi	r22, 0x3C	; 60
    a4d0:	8e a9       	ldd	r24, Y+54	; 0x36
    a4d2:	9f a9       	ldd	r25, Y+55	; 0x37
    a4d4:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4d8:	88 23       	and	r24, r24
    a4da:	09 f4       	brne	.+2      	; 0xa4de <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x92>
    a4dc:	4a c2       	rjmp	.+1172   	; 0xa972 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x526>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a4de:	48 e2       	ldi	r20, 0x28	; 40
    a4e0:	61 e0       	ldi	r22, 0x01	; 1
    a4e2:	8e a9       	ldd	r24, Y+54	; 0x36
    a4e4:	9f a9       	ldd	r25, Y+55	; 0x37
    a4e6:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4ea:	88 23       	and	r24, r24
    a4ec:	09 f4       	brne	.+2      	; 0xa4f0 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xa4>
    a4ee:	43 c2       	rjmp	.+1158   	; 0xa976 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x52a>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(REGISTER_B_CONFIGURATION_660_GAIN, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a4f0:	48 e2       	ldi	r20, 0x28	; 40
    a4f2:	60 e6       	ldi	r22, 0x60	; 96
    a4f4:	8e a9       	ldd	r24, Y+54	; 0x36
    a4f6:	9f a9       	ldd	r25, Y+55	; 0x37
    a4f8:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4fc:	88 23       	and	r24, r24
    a4fe:	09 f4       	brne	.+2      	; 0xa502 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xb6>
    a500:	3c c2       	rjmp	.+1144   	; 0xa97a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x52e>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    a502:	8e a9       	ldd	r24, Y+54	; 0x36
    a504:	9f a9       	ldd	r25, Y+55	; 0x37
    a506:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	    int numAttempts = 0, good_count = 0;
	    bool success = false;
		byte PositiveBiasConfig = 0x11;
		byte calibration_gain = 0x60;
	
	calibration[0] = 0;
    a50a:	10 92 26 04 	sts	0x0426, r1
    a50e:	10 92 27 04 	sts	0x0427, r1
    a512:	10 92 28 04 	sts	0x0428, r1
    a516:	10 92 29 04 	sts	0x0429, r1
	calibration[1] = 0;
    a51a:	10 92 2a 04 	sts	0x042A, r1
    a51e:	10 92 2b 04 	sts	0x042B, r1
    a522:	10 92 2c 04 	sts	0x042C, r1
    a526:	10 92 2d 04 	sts	0x042D, r1
	calibration[2] = 0;
    a52a:	10 92 2e 04 	sts	0x042E, r1
    a52e:	10 92 2f 04 	sts	0x042F, r1
    a532:	10 92 30 04 	sts	0x0430, r1
    a536:	10 92 31 04 	sts	0x0431, r1
	//
	float expected_x = -713;//766;
	float expected_y = 766;//713;
	float expected_z = 713;
	
	    int numAttempts = 0, good_count = 0;
    a53a:	21 2c       	mov	r2, r1
    a53c:	31 2c       	mov	r3, r1
    a53e:	00 e0       	ldi	r16, 0x00	; 0
    a540:	10 e0       	ldi	r17, 0x00	; 0
	
	calibration[0] = 0;
	calibration[1] = 0;
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    a542:	37 c1       	rjmp	.+622    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a544:	48 e1       	ldi	r20, 0x18	; 24
    a546:	6c e3       	ldi	r22, 0x3C	; 60
    a548:	8e a9       	ldd	r24, Y+54	; 0x36
    a54a:	9f a9       	ldd	r25, Y+55	; 0x37
    a54c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a550:	88 23       	and	r24, r24
    a552:	09 f4       	brne	.+2      	; 0xa556 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x10a>
    a554:	14 c2       	rjmp	.+1064   	; 0xa97e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x532>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a556:	48 e2       	ldi	r20, 0x28	; 40
    a558:	60 e0       	ldi	r22, 0x00	; 0
    a55a:	8e a9       	ldd	r24, Y+54	; 0x36
    a55c:	9f a9       	ldd	r25, Y+55	; 0x37
    a55e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a562:	88 23       	and	r24, r24
    a564:	09 f4       	brne	.+2      	; 0xa568 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x11c>
    a566:	0d c2       	rjmp	.+1050   	; 0xa982 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x536>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(PositiveBiasConfig, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a568:	48 e2       	ldi	r20, 0x28	; 40
    a56a:	61 e1       	ldi	r22, 0x11	; 17
    a56c:	8e a9       	ldd	r24, Y+54	; 0x36
    a56e:	9f a9       	ldd	r25, Y+55	; 0x37
    a570:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a574:	88 23       	and	r24, r24
    a576:	09 f4       	brne	.+2      	; 0xa57a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x12e>
    a578:	06 c2       	rjmp	.+1036   	; 0xa986 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x53a>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    a57a:	8e a9       	ldd	r24, Y+54	; 0x36
    a57c:	9f a9       	ldd	r25, Y+55	; 0x37
    a57e:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a582:	2f ef       	ldi	r18, 0xFF	; 255
    a584:	80 e7       	ldi	r24, 0x70	; 112
    a586:	92 e0       	ldi	r25, 0x02	; 2
    a588:	21 50       	subi	r18, 0x01	; 1
    a58a:	80 40       	sbci	r24, 0x00	; 0
    a58c:	90 40       	sbci	r25, 0x00	; 0
    a58e:	e1 f7       	brne	.-8      	; 0xa588 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x13c>
    a590:	00 c0       	rjmp	.+0      	; 0xa592 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x146>
    a592:	00 00       	nop

        
        _delay_ms(50);

        // set gains
	if(!driver->start())
    a594:	8e a9       	ldd	r24, Y+54	; 0x36
    a596:	9f a9       	ldd	r25, Y+55	; 0x37
    a598:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a59c:	88 23       	and	r24, r24
    a59e:	09 f4       	brne	.+2      	; 0xa5a2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x156>
    a5a0:	f4 c1       	rjmp	.+1000   	; 0xa98a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x53e>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a5a2:	48 e1       	ldi	r20, 0x18	; 24
    a5a4:	6c e3       	ldi	r22, 0x3C	; 60
    a5a6:	8e a9       	ldd	r24, Y+54	; 0x36
    a5a8:	9f a9       	ldd	r25, Y+55	; 0x37
    a5aa:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5ae:	88 23       	and	r24, r24
    a5b0:	09 f4       	brne	.+2      	; 0xa5b4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x168>
    a5b2:	ed c1       	rjmp	.+986    	; 0xa98e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x542>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a5b4:	48 e2       	ldi	r20, 0x28	; 40
    a5b6:	61 e0       	ldi	r22, 0x01	; 1
    a5b8:	8e a9       	ldd	r24, Y+54	; 0x36
    a5ba:	9f a9       	ldd	r25, Y+55	; 0x37
    a5bc:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5c0:	88 23       	and	r24, r24
    a5c2:	09 f4       	brne	.+2      	; 0xa5c6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x17a>
    a5c4:	e6 c1       	rjmp	.+972    	; 0xa992 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x546>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(calibration_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a5c6:	48 e2       	ldi	r20, 0x28	; 40
    a5c8:	60 e6       	ldi	r22, 0x60	; 96
    a5ca:	8e a9       	ldd	r24, Y+54	; 0x36
    a5cc:	9f a9       	ldd	r25, Y+55	; 0x37
    a5ce:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5d2:	88 23       	and	r24, r24
    a5d4:	09 f4       	brne	.+2      	; 0xa5d8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x18c>
    a5d6:	df c1       	rjmp	.+958    	; 0xa996 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x54a>
	{
		return false;
	}

	//end the transaction
	driver->stop();		
    a5d8:	8e a9       	ldd	r24, Y+54	; 0x36
    a5da:	9f a9       	ldd	r25, Y+55	; 0x37
    a5dc:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a5e0:	ef ef       	ldi	r30, 0xFF	; 255
    a5e2:	f0 e7       	ldi	r31, 0x70	; 112
    a5e4:	22 e0       	ldi	r18, 0x02	; 2
    a5e6:	e1 50       	subi	r30, 0x01	; 1
    a5e8:	f0 40       	sbci	r31, 0x00	; 0
    a5ea:	20 40       	sbci	r18, 0x00	; 0
    a5ec:	e1 f7       	brne	.-8      	; 0xa5e6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x19a>
    a5ee:	00 c0       	rjmp	.+0      	; 0xa5f0 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1a4>
    a5f0:	00 00       	nop
	
	
	        _delay_ms(50);

	        // set gains
	        if(!driver->start())
    a5f2:	8e a9       	ldd	r24, Y+54	; 0x36
    a5f4:	9f a9       	ldd	r25, Y+55	; 0x37
    a5f6:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a5fa:	88 23       	and	r24, r24
    a5fc:	09 f4       	brne	.+2      	; 0xa600 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1b4>
    a5fe:	cd c1       	rjmp	.+922    	; 0xa99a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x54e>
	        {
		        return false;
	        }
	        
	        //Indicate that the next value is a write operation
	        if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a600:	48 e1       	ldi	r20, 0x18	; 24
    a602:	6c e3       	ldi	r22, 0x3C	; 60
    a604:	8e a9       	ldd	r24, Y+54	; 0x36
    a606:	9f a9       	ldd	r25, Y+55	; 0x37
    a608:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a60c:	88 23       	and	r24, r24
    a60e:	09 f4       	brne	.+2      	; 0xa612 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1c6>
    a610:	c6 c1       	rjmp	.+908    	; 0xa99e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x552>
		        return false;
	        }
	        
			
	        //Write to the device so that the 'pointer' moves to register B
	        if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a612:	48 e2       	ldi	r20, 0x28	; 40
    a614:	62 e0       	ldi	r22, 0x02	; 2
    a616:	8e a9       	ldd	r24, Y+54	; 0x36
    a618:	9f a9       	ldd	r25, Y+55	; 0x37
    a61a:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a61e:	88 23       	and	r24, r24
    a620:	09 f4       	brne	.+2      	; 0xa624 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1d8>
    a622:	bf c1       	rjmp	.+894    	; 0xa9a2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x556>
	        {
		        return false;
	        }
	        byte singleConversion = 0x01;
	        //Write the configuration value to register B
	        if (!driver->write(singleConversion, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a624:	48 e2       	ldi	r20, 0x28	; 40
    a626:	61 e0       	ldi	r22, 0x01	; 1
    a628:	8e a9       	ldd	r24, Y+54	; 0x36
    a62a:	9f a9       	ldd	r25, Y+55	; 0x37
    a62c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a630:	88 23       	and	r24, r24
    a632:	09 f4       	brne	.+2      	; 0xa636 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1ea>
    a634:	b8 c1       	rjmp	.+880    	; 0xa9a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x55a>
	        {
		        return false;
	        }

	        //end the transaction
	        driver->stop();
    a636:	8e a9       	ldd	r24, Y+54	; 0x36
    a638:	9f a9       	ldd	r25, Y+55	; 0x37
    a63a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a63e:	8f ef       	ldi	r24, 0xFF	; 255
    a640:	90 e7       	ldi	r25, 0x70	; 112
    a642:	e2 e0       	ldi	r30, 0x02	; 2
    a644:	81 50       	subi	r24, 0x01	; 1
    a646:	90 40       	sbci	r25, 0x00	; 0
    a648:	e0 40       	sbci	r30, 0x00	; 0
    a64a:	e1 f7       	brne	.-8      	; 0xa644 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1f8>
    a64c:	00 c0       	rjmp	.+0      	; 0xa64e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x202>
    a64e:	00 00       	nop
	
		
		_delay_ms(50);
		
        // read values from the compass
       readSensor();
    a650:	ce 01       	movw	r24, r28
    a652:	0e 94 9c 50 	call	0xa138	; 0xa138 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    a656:	ff ef       	ldi	r31, 0xFF	; 255
    a658:	20 e7       	ldi	r18, 0x70	; 112
    a65a:	82 e0       	ldi	r24, 0x02	; 2
    a65c:	f1 50       	subi	r31, 0x01	; 1
    a65e:	20 40       	sbci	r18, 0x00	; 0
    a660:	80 40       	sbci	r24, 0x00	; 0
    a662:	e1 f7       	brne	.-8      	; 0xa65c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x210>
    a664:	00 c0       	rjmp	.+0      	; 0xa666 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x21a>
    a666:	00 00       	nop
		_delay_ms(50);

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
    a668:	2e 81       	ldd	r18, Y+6	; 0x06
    a66a:	3f 81       	ldd	r19, Y+7	; 0x07
    a66c:	48 85       	ldd	r20, Y+8	; 0x08
    a66e:	59 85       	ldd	r21, Y+9	; 0x09
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a670:	8a 84       	ldd	r8, Y+10	; 0x0a
    a672:	9b 84       	ldd	r9, Y+11	; 0x0b
    a674:	ac 84       	ldd	r10, Y+12	; 0x0c
    a676:	bd 84       	ldd	r11, Y+13	; 0x0d
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a678:	ce 84       	ldd	r12, Y+14	; 0x0e
    a67a:	df 84       	ldd	r13, Y+15	; 0x0f
    a67c:	e8 88       	ldd	r14, Y+16	; 0x10
    a67e:	f9 88       	ldd	r15, Y+17	; 0x11

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a680:	03 30       	cpi	r16, 0x03	; 3
    a682:	11 05       	cpc	r17, r1
    a684:	0c f4       	brge	.+2      	; 0xa688 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x23c>
    a686:	95 c0       	rjmp	.+298    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
		_delay_ms(50);

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
    a688:	60 e0       	ldi	r22, 0x00	; 0
    a68a:	70 e4       	ldi	r23, 0x40	; 64
    a68c:	82 e3       	ldi	r24, 0x32	; 50
    a68e:	94 ec       	ldi	r25, 0xC4	; 196
    a690:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a694:	2b 01       	movw	r4, r22
    a696:	3c 01       	movw	r6, r24
    a698:	e8 94       	clt
    a69a:	77 f8       	bld	r7, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a69c:	23 e3       	ldi	r18, 0x33	; 51
    a69e:	33 e3       	ldi	r19, 0x33	; 51
    a6a0:	43 e3       	ldi	r20, 0x33	; 51
    a6a2:	5f e3       	ldi	r21, 0x3F	; 63
    a6a4:	c3 01       	movw	r24, r6
    a6a6:	b2 01       	movw	r22, r4
    a6a8:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    a6ac:	18 16       	cp	r1, r24
    a6ae:	0c f0       	brlt	.+2      	; 0xa6b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x266>
    a6b0:	80 c0       	rjmp	.+256    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a6b2:	2d ec       	ldi	r18, 0xCD	; 205
    a6b4:	3c ec       	ldi	r19, 0xCC	; 204
    a6b6:	4c ea       	ldi	r20, 0xAC	; 172
    a6b8:	5f e3       	ldi	r21, 0x3F	; 63
    a6ba:	c3 01       	movw	r24, r6
    a6bc:	b2 01       	movw	r22, r4
    a6be:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    a6c2:	88 23       	and	r24, r24
    a6c4:	0c f0       	brlt	.+2      	; 0xa6c8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x27c>
    a6c6:	75 c0       	rjmp	.+234    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a6c8:	a5 01       	movw	r20, r10
    a6ca:	94 01       	movw	r18, r8
    a6cc:	60 e0       	ldi	r22, 0x00	; 0
    a6ce:	70 e8       	ldi	r23, 0x80	; 128
    a6d0:	8f e3       	ldi	r24, 0x3F	; 63
    a6d2:	94 e4       	ldi	r25, 0x44	; 68
    a6d4:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a6d8:	4b 01       	movw	r8, r22
    a6da:	5c 01       	movw	r10, r24
    a6dc:	e8 94       	clt
    a6de:	b7 f8       	bld	r11, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a6e0:	23 e3       	ldi	r18, 0x33	; 51
    a6e2:	33 e3       	ldi	r19, 0x33	; 51
    a6e4:	43 e3       	ldi	r20, 0x33	; 51
    a6e6:	5f e3       	ldi	r21, 0x3F	; 63
    a6e8:	c5 01       	movw	r24, r10
    a6ea:	b4 01       	movw	r22, r8
    a6ec:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    a6f0:	18 16       	cp	r1, r24
    a6f2:	0c f0       	brlt	.+2      	; 0xa6f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2aa>
    a6f4:	5e c0       	rjmp	.+188    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a6f6:	2d ec       	ldi	r18, 0xCD	; 205
    a6f8:	3c ec       	ldi	r19, 0xCC	; 204
    a6fa:	4c ea       	ldi	r20, 0xAC	; 172
    a6fc:	5f e3       	ldi	r21, 0x3F	; 63
    a6fe:	c5 01       	movw	r24, r10
    a700:	b4 01       	movw	r22, r8
    a702:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    a706:	88 23       	and	r24, r24
    a708:	0c f0       	brlt	.+2      	; 0xa70c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2c0>
    a70a:	53 c0       	rjmp	.+166    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a70c:	a7 01       	movw	r20, r14
    a70e:	96 01       	movw	r18, r12
    a710:	60 e0       	ldi	r22, 0x00	; 0
    a712:	70 e4       	ldi	r23, 0x40	; 64
    a714:	82 e3       	ldi	r24, 0x32	; 50
    a716:	94 e4       	ldi	r25, 0x44	; 68
    a718:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a71c:	6b 01       	movw	r12, r22
    a71e:	7c 01       	movw	r14, r24
    a720:	e8 94       	clt
    a722:	f7 f8       	bld	r15, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a724:	23 e3       	ldi	r18, 0x33	; 51
    a726:	33 e3       	ldi	r19, 0x33	; 51
    a728:	43 e3       	ldi	r20, 0x33	; 51
    a72a:	5f e3       	ldi	r21, 0x3F	; 63
    a72c:	c7 01       	movw	r24, r14
    a72e:	b6 01       	movw	r22, r12
    a730:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    a734:	18 16       	cp	r1, r24
    a736:	ec f5       	brge	.+122    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a738:	2d ec       	ldi	r18, 0xCD	; 205
    a73a:	3c ec       	ldi	r19, 0xCC	; 204
    a73c:	4c ea       	ldi	r20, 0xAC	; 172
    a73e:	5f e3       	ldi	r21, 0x3F	; 63
    a740:	c7 01       	movw	r24, r14
    a742:	b6 01       	movw	r22, r12
    a744:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    a748:	88 23       	and	r24, r24
    a74a:	9c f5       	brge	.+102    	; 0xa7b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
            cal[0] > 0.7f && cal[0] < 1.35f &&
            cal[1] > 0.7f && cal[1] < 1.35f &&
            cal[2] > 0.7f && cal[2] < 1.35f) {
//        if (numAttempts > 2 ) {				
            // hal.console->printf_P(PSTR("cal=%.2f %.2f %.2f good\n"), cal[0], cal[1], cal[2]);
            good_count++;
    a74c:	9f ef       	ldi	r25, 0xFF	; 255
    a74e:	29 1a       	sub	r2, r25
    a750:	39 0a       	sbc	r3, r25
            calibration[0] += cal[0];
    a752:	e6 e2       	ldi	r30, 0x26	; 38
    a754:	f4 e0       	ldi	r31, 0x04	; 4
    a756:	20 81       	ld	r18, Z
    a758:	31 81       	ldd	r19, Z+1	; 0x01
    a75a:	42 81       	ldd	r20, Z+2	; 0x02
    a75c:	53 81       	ldd	r21, Z+3	; 0x03
    a75e:	c3 01       	movw	r24, r6
    a760:	b2 01       	movw	r22, r4
    a762:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    a766:	e6 e2       	ldi	r30, 0x26	; 38
    a768:	f4 e0       	ldi	r31, 0x04	; 4
    a76a:	60 83       	st	Z, r22
    a76c:	71 83       	std	Z+1, r23	; 0x01
    a76e:	82 83       	std	Z+2, r24	; 0x02
    a770:	93 83       	std	Z+3, r25	; 0x03
            calibration[1] += cal[1];
    a772:	ea e2       	ldi	r30, 0x2A	; 42
    a774:	f4 e0       	ldi	r31, 0x04	; 4
    a776:	20 81       	ld	r18, Z
    a778:	31 81       	ldd	r19, Z+1	; 0x01
    a77a:	42 81       	ldd	r20, Z+2	; 0x02
    a77c:	53 81       	ldd	r21, Z+3	; 0x03
    a77e:	c5 01       	movw	r24, r10
    a780:	b4 01       	movw	r22, r8
    a782:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    a786:	ea e2       	ldi	r30, 0x2A	; 42
    a788:	f4 e0       	ldi	r31, 0x04	; 4
    a78a:	60 83       	st	Z, r22
    a78c:	71 83       	std	Z+1, r23	; 0x01
    a78e:	82 83       	std	Z+2, r24	; 0x02
    a790:	93 83       	std	Z+3, r25	; 0x03
            calibration[2] += cal[2];
    a792:	ee e2       	ldi	r30, 0x2E	; 46
    a794:	f4 e0       	ldi	r31, 0x04	; 4
    a796:	20 81       	ld	r18, Z
    a798:	31 81       	ldd	r19, Z+1	; 0x01
    a79a:	42 81       	ldd	r20, Z+2	; 0x02
    a79c:	53 81       	ldd	r21, Z+3	; 0x03
    a79e:	c7 01       	movw	r24, r14
    a7a0:	b6 01       	movw	r22, r12
    a7a2:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    a7a6:	ee e2       	ldi	r30, 0x2E	; 46
    a7a8:	f4 e0       	ldi	r31, 0x04	; 4
    a7aa:	60 83       	st	Z, r22
    a7ac:	71 83       	std	Z+1, r23	; 0x01
    a7ae:	82 83       	std	Z+2, r24	; 0x02
    a7b0:	93 83       	std	Z+3, r25	; 0x03
	
	calibration[0] = 0;
	calibration[1] = 0;
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    a7b2:	09 31       	cpi	r16, 0x19	; 25
    a7b4:	11 05       	cpc	r17, r1
    a7b6:	09 f4       	brne	.+2      	; 0xa7ba <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x36e>
    a7b8:	10 c1       	rjmp	.+544    	; 0xa9da <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58e>
    a7ba:	f5 e0       	ldi	r31, 0x05	; 5
    a7bc:	2f 16       	cp	r2, r31
    a7be:	31 04       	cpc	r3, r1
    a7c0:	0c f4       	brge	.+2      	; 0xa7c4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x378>
    a7c2:	11 c1       	rjmp	.+546    	; 0xa9e6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x59a>
          impact is that the values we report on APM1/APM2 are lower
          than they should be (by a multiple of about 0.6). This
          doesn't have any impact other than the learned compass
          offsets
         */
        calibration[0] = calibration[0]  / good_count;
    a7c4:	b1 01       	movw	r22, r2
    a7c6:	88 27       	eor	r24, r24
    a7c8:	77 fd       	sbrc	r23, 7
    a7ca:	80 95       	com	r24
    a7cc:	98 2f       	mov	r25, r24
    a7ce:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    a7d2:	6b 01       	movw	r12, r22
    a7d4:	7c 01       	movw	r14, r24
    a7d6:	06 e2       	ldi	r16, 0x26	; 38
    a7d8:	14 e0       	ldi	r17, 0x04	; 4
    a7da:	9b 01       	movw	r18, r22
    a7dc:	ac 01       	movw	r20, r24
    a7de:	f8 01       	movw	r30, r16
    a7e0:	60 81       	ld	r22, Z
    a7e2:	71 81       	ldd	r23, Z+1	; 0x01
    a7e4:	82 81       	ldd	r24, Z+2	; 0x02
    a7e6:	93 81       	ldd	r25, Z+3	; 0x03
    a7e8:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a7ec:	f8 01       	movw	r30, r16
    a7ee:	60 83       	st	Z, r22
    a7f0:	71 83       	std	Z+1, r23	; 0x01
    a7f2:	82 83       	std	Z+2, r24	; 0x02
    a7f4:	93 83       	std	Z+3, r25	; 0x03
        calibration[1] = calibration[1]  / good_count;
    a7f6:	0a e2       	ldi	r16, 0x2A	; 42
    a7f8:	14 e0       	ldi	r17, 0x04	; 4
    a7fa:	a7 01       	movw	r20, r14
    a7fc:	96 01       	movw	r18, r12
    a7fe:	f8 01       	movw	r30, r16
    a800:	60 81       	ld	r22, Z
    a802:	71 81       	ldd	r23, Z+1	; 0x01
    a804:	82 81       	ldd	r24, Z+2	; 0x02
    a806:	93 81       	ldd	r25, Z+3	; 0x03
    a808:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a80c:	f8 01       	movw	r30, r16
    a80e:	60 83       	st	Z, r22
    a810:	71 83       	std	Z+1, r23	; 0x01
    a812:	82 83       	std	Z+2, r24	; 0x02
    a814:	93 83       	std	Z+3, r25	; 0x03
        calibration[2] = calibration[2]  / good_count;
    a816:	0e e2       	ldi	r16, 0x2E	; 46
    a818:	14 e0       	ldi	r17, 0x04	; 4
    a81a:	a7 01       	movw	r20, r14
    a81c:	96 01       	movw	r18, r12
    a81e:	f8 01       	movw	r30, r16
    a820:	60 81       	ld	r22, Z
    a822:	71 81       	ldd	r23, Z+1	; 0x01
    a824:	82 81       	ldd	r24, Z+2	; 0x02
    a826:	93 81       	ldd	r25, Z+3	; 0x03
    a828:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    a82c:	f8 01       	movw	r30, r16
    a82e:	60 83       	st	Z, r22
    a830:	71 83       	std	Z+1, r23	; 0x01
    a832:	82 83       	std	Z+2, r24	; 0x02
    a834:	93 83       	std	Z+3, r25	; 0x03
    a836:	1c c0       	rjmp	.+56     	; 0xa870 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x424>
        success = true;
    } else {
        /* best guess */
        calibration[0] = 1.0;
    a838:	80 e0       	ldi	r24, 0x00	; 0
    a83a:	90 e0       	ldi	r25, 0x00	; 0
    a83c:	a0 e8       	ldi	r26, 0x80	; 128
    a83e:	bf e3       	ldi	r27, 0x3F	; 63
    a840:	80 93 26 04 	sts	0x0426, r24
    a844:	90 93 27 04 	sts	0x0427, r25
    a848:	a0 93 28 04 	sts	0x0428, r26
    a84c:	b0 93 29 04 	sts	0x0429, r27
        calibration[1] = 1.0;
    a850:	80 93 2a 04 	sts	0x042A, r24
    a854:	90 93 2b 04 	sts	0x042B, r25
    a858:	a0 93 2c 04 	sts	0x042C, r26
    a85c:	b0 93 2d 04 	sts	0x042D, r27
        calibration[2] = 1.0;
    a860:	80 93 2e 04 	sts	0x042E, r24
    a864:	90 93 2f 04 	sts	0x042F, r25
    a868:	a0 93 30 04 	sts	0x0430, r26
    a86c:	b0 93 31 04 	sts	0x0431, r27
	
	
	
	
	
	readyForOffsets = true;
    a870:	81 e0       	ldi	r24, 0x01	; 1
    a872:	80 93 25 04 	sts	0x0425, r24
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    a876:	8e a9       	ldd	r24, Y+54	; 0x36
    a878:	9f a9       	ldd	r25, Y+55	; 0x37
    a87a:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a87e:	88 23       	and	r24, r24
    a880:	09 f4       	brne	.+2      	; 0xa884 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x438>
    a882:	93 c0       	rjmp	.+294    	; 0xa9aa <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x55e>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a884:	48 e1       	ldi	r20, 0x18	; 24
    a886:	6c e3       	ldi	r22, 0x3C	; 60
    a888:	8e a9       	ldd	r24, Y+54	; 0x36
    a88a:	9f a9       	ldd	r25, Y+55	; 0x37
    a88c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a890:	88 23       	and	r24, r24
    a892:	09 f4       	brne	.+2      	; 0xa896 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x44a>
    a894:	8c c0       	rjmp	.+280    	; 0xa9ae <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x562>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a896:	48 e2       	ldi	r20, 0x28	; 40
    a898:	60 e0       	ldi	r22, 0x00	; 0
    a89a:	8e a9       	ldd	r24, Y+54	; 0x36
    a89c:	9f a9       	ldd	r25, Y+55	; 0x37
    a89e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8a2:	88 23       	and	r24, r24
    a8a4:	09 f4       	brne	.+2      	; 0xa8a8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x45c>
    a8a6:	85 c0       	rjmp	.+266    	; 0xa9b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x566>
	{
		return false;
	}
	
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a8a8:	48 e2       	ldi	r20, 0x28	; 40
    a8aa:	68 e7       	ldi	r22, 0x78	; 120
    a8ac:	8e a9       	ldd	r24, Y+54	; 0x36
    a8ae:	9f a9       	ldd	r25, Y+55	; 0x37
    a8b0:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8b4:	88 23       	and	r24, r24
    a8b6:	09 f4       	brne	.+2      	; 0xa8ba <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x46e>
    a8b8:	7e c0       	rjmp	.+252    	; 0xa9b6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x56a>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    a8ba:	8e a9       	ldd	r24, Y+54	; 0x36
    a8bc:	9f a9       	ldd	r25, Y+55	; 0x37
    a8be:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	byte primary_gain = 0x20;
	       // set gains
	       if(!driver->start())
    a8c2:	8e a9       	ldd	r24, Y+54	; 0x36
    a8c4:	9f a9       	ldd	r25, Y+55	; 0x37
    a8c6:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a8ca:	88 23       	and	r24, r24
    a8cc:	09 f4       	brne	.+2      	; 0xa8d0 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x484>
    a8ce:	75 c0       	rjmp	.+234    	; 0xa9ba <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x56e>
	       {
		       return false;
	       }
	       
	       //Indicate that the next value is a write operation
	       if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a8d0:	48 e1       	ldi	r20, 0x18	; 24
    a8d2:	6c e3       	ldi	r22, 0x3C	; 60
    a8d4:	8e a9       	ldd	r24, Y+54	; 0x36
    a8d6:	9f a9       	ldd	r25, Y+55	; 0x37
    a8d8:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8dc:	88 23       	and	r24, r24
    a8de:	09 f4       	brne	.+2      	; 0xa8e2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x496>
    a8e0:	6e c0       	rjmp	.+220    	; 0xa9be <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x572>
	       {
		       return false;
	       }
	       
	       //Write to the device so that the 'pointer' moves to register B
	       if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a8e2:	48 e2       	ldi	r20, 0x28	; 40
    a8e4:	61 e0       	ldi	r22, 0x01	; 1
    a8e6:	8e a9       	ldd	r24, Y+54	; 0x36
    a8e8:	9f a9       	ldd	r25, Y+55	; 0x37
    a8ea:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8ee:	88 23       	and	r24, r24
    a8f0:	09 f4       	brne	.+2      	; 0xa8f4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4a8>
    a8f2:	67 c0       	rjmp	.+206    	; 0xa9c2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }
	       
	       //Write the configuration value to register B
	       if (!driver->write(primary_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a8f4:	48 e2       	ldi	r20, 0x28	; 40
    a8f6:	60 e2       	ldi	r22, 0x20	; 32
    a8f8:	8e a9       	ldd	r24, Y+54	; 0x36
    a8fa:	9f a9       	ldd	r25, Y+55	; 0x37
    a8fc:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a900:	88 23       	and	r24, r24
    a902:	09 f4       	brne	.+2      	; 0xa906 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4ba>
    a904:	60 c0       	rjmp	.+192    	; 0xa9c6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x57a>
	       {
		       return false;
	       }

	       //end the transaction
	       driver->stop();
    a906:	8e a9       	ldd	r24, Y+54	; 0x36
    a908:	9f a9       	ldd	r25, Y+55	; 0x37
    a90a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>

	/**
	* Set the compass mode for continuous measurement
	*/
	//start a transaction
	if(!driver->start())
    a90e:	8e a9       	ldd	r24, Y+54	; 0x36
    a910:	9f a9       	ldd	r25, Y+55	; 0x37
    a912:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a916:	88 23       	and	r24, r24
    a918:	09 f4       	brne	.+2      	; 0xa91c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4d0>
    a91a:	57 c0       	rjmp	.+174    	; 0xa9ca <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x57e>
	{
		return false;
	}
		
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a91c:	48 e1       	ldi	r20, 0x18	; 24
    a91e:	6c e3       	ldi	r22, 0x3C	; 60
    a920:	8e a9       	ldd	r24, Y+54	; 0x36
    a922:	9f a9       	ldd	r25, Y+55	; 0x37
    a924:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a928:	88 23       	and	r24, r24
    a92a:	09 f4       	brne	.+2      	; 0xa92e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4e2>
    a92c:	50 c0       	rjmp	.+160    	; 0xa9ce <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x582>
	{
		return false;
	}		
		
	//Write to the device so that the 'pointer' moves to the mode register
	if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a92e:	48 e2       	ldi	r20, 0x28	; 40
    a930:	62 e0       	ldi	r22, 0x02	; 2
    a932:	8e a9       	ldd	r24, Y+54	; 0x36
    a934:	9f a9       	ldd	r25, Y+55	; 0x37
    a936:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a93a:	88 23       	and	r24, r24
    a93c:	09 f4       	brne	.+2      	; 0xa940 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4f4>
    a93e:	49 c0       	rjmp	.+146    	; 0xa9d2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x586>
	{
		return false;
	}

	//Write the configuration value to the mode register
	if (!driver->write(COMPASS_MODE_CONTINUOUS_MEASUREMENT_MODE, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a940:	48 e2       	ldi	r20, 0x28	; 40
    a942:	60 e0       	ldi	r22, 0x00	; 0
    a944:	8e a9       	ldd	r24, Y+54	; 0x36
    a946:	9f a9       	ldd	r25, Y+55	; 0x37
    a948:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a94c:	88 23       	and	r24, r24
    a94e:	09 f4       	brne	.+2      	; 0xa952 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x506>
    a950:	42 c0       	rjmp	.+132    	; 0xa9d6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58a>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    a952:	8e a9       	ldd	r24, Y+54	; 0x36
    a954:	9f a9       	ldd	r25, Y+55	; 0x37
    a956:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	return true;
    a95a:	81 e0       	ldi	r24, 0x01	; 1
    a95c:	4c c0       	rjmp	.+152    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	*/
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a95e:	80 e0       	ldi	r24, 0x00	; 0
    a960:	4a c0       	rjmp	.+148    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation 
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a962:	80 e0       	ldi	r24, 0x00	; 0
    a964:	48 c0       	rjmp	.+144    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a966:	80 e0       	ldi	r24, 0x00	; 0
    a968:	46 c0       	rjmp	.+140    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a96a:	80 e0       	ldi	r24, 0x00	; 0
    a96c:	44 c0       	rjmp	.+136    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a96e:	80 e0       	ldi	r24, 0x00	; 0
    a970:	42 c0       	rjmp	.+132    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a972:	80 e0       	ldi	r24, 0x00	; 0
    a974:	40 c0       	rjmp	.+128    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a976:	80 e0       	ldi	r24, 0x00	; 0
    a978:	3e c0       	rjmp	.+124    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write the configuration value to register B
	if (!driver->write(REGISTER_B_CONFIGURATION_660_GAIN, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a97a:	80 e0       	ldi	r24, 0x00	; 0
    a97c:	3c c0       	rjmp	.+120    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a97e:	80 e0       	ldi	r24, 0x00	; 0
    a980:	3a c0       	rjmp	.+116    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a982:	80 e0       	ldi	r24, 0x00	; 0
    a984:	38 c0       	rjmp	.+112    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(PositiveBiasConfig, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a986:	80 e0       	ldi	r24, 0x00	; 0
    a988:	36 c0       	rjmp	.+108    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>

        
        _delay_ms(50);

        // set gains
	if(!driver->start())
    a98a:	80 e0       	ldi	r24, 0x00	; 0
    a98c:	34 c0       	rjmp	.+104    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a98e:	80 e0       	ldi	r24, 0x00	; 0
    a990:	32 c0       	rjmp	.+100    	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a992:	80 e0       	ldi	r24, 0x00	; 0
    a994:	30 c0       	rjmp	.+96     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(calibration_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a996:	80 e0       	ldi	r24, 0x00	; 0
    a998:	2e c0       	rjmp	.+92     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	        _delay_ms(50);

	        // set gains
	        if(!driver->start())
    a99a:	80 e0       	ldi	r24, 0x00	; 0
    a99c:	2c c0       	rjmp	.+88     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	        {
		        return false;
	        }
	        
	        //Indicate that the next value is a write operation
	        if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a99e:	80 e0       	ldi	r24, 0x00	; 0
    a9a0:	2a c0       	rjmp	.+84     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
		        return false;
	        }
	        
			
	        //Write to the device so that the 'pointer' moves to register B
	        if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a9a2:	80 e0       	ldi	r24, 0x00	; 0
    a9a4:	28 c0       	rjmp	.+80     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	        {
		        return false;
	        }
	        byte singleConversion = 0x01;
	        //Write the configuration value to register B
	        if (!driver->write(singleConversion, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a9a6:	80 e0       	ldi	r24, 0x00	; 0
    a9a8:	26 c0       	rjmp	.+76     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a9aa:	80 e0       	ldi	r24, 0x00	; 0
    a9ac:	24 c0       	rjmp	.+72     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a9ae:	80 e0       	ldi	r24, 0x00	; 0
    a9b0:	22 c0       	rjmp	.+68     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9b2:	80 e0       	ldi	r24, 0x00	; 0
    a9b4:	20 c0       	rjmp	.+64     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9b6:	80 e0       	ldi	r24, 0x00	; 0
    a9b8:	1e c0       	rjmp	.+60     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	byte primary_gain = 0x20;
	       // set gains
	       if(!driver->start())
	       {
		       return false;
    a9ba:	80 e0       	ldi	r24, 0x00	; 0
    a9bc:	1c c0       	rjmp	.+56     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Indicate that the next value is a write operation
	       if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	       {
		       return false;
    a9be:	80 e0       	ldi	r24, 0x00	; 0
    a9c0:	1a c0       	rjmp	.+52     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Write to the device so that the 'pointer' moves to register B
	       if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	       {
		       return false;
    a9c2:	80 e0       	ldi	r24, 0x00	; 0
    a9c4:	18 c0       	rjmp	.+48     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Write the configuration value to register B
	       if (!driver->write(primary_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	       {
		       return false;
    a9c6:	80 e0       	ldi	r24, 0x00	; 0
    a9c8:	16 c0       	rjmp	.+44     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	* Set the compass mode for continuous measurement
	*/
	//start a transaction
	if(!driver->start())
	{
		return false;
    a9ca:	80 e0       	ldi	r24, 0x00	; 0
    a9cc:	14 c0       	rjmp	.+40     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a9ce:	80 e0       	ldi	r24, 0x00	; 0
    a9d0:	12 c0       	rjmp	.+36     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}		
		
	//Write to the device so that the 'pointer' moves to the mode register
	if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9d2:	80 e0       	ldi	r24, 0x00	; 0
    a9d4:	10 c0       	rjmp	.+32     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}

	//Write the configuration value to the mode register
	if (!driver->write(COMPASS_MODE_CONTINUOUS_MEASUREMENT_MODE, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9d6:	80 e0       	ldi	r24, 0x00	; 0
    a9d8:	0e c0       	rjmp	.+28     	; 0xa9f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
        }


    }

    if (good_count >= 5) {
    a9da:	f5 e0       	ldi	r31, 0x05	; 5
    a9dc:	2f 16       	cp	r2, r31
    a9de:	31 04       	cpc	r3, r1
    a9e0:	0c f4       	brge	.+2      	; 0xa9e4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x598>
    a9e2:	2a cf       	rjmp	.-428    	; 0xa838 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x3ec>
    a9e4:	ef ce       	rjmp	.-546    	; 0xa7c4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x378>
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    {
        // record number of attempts at initialisation
        numAttempts++;
    a9e6:	0f 5f       	subi	r16, 0xFF	; 255
    a9e8:	1f 4f       	sbci	r17, 0xFF	; 255



// force positiveBias (compass should return 715 for all channels)
	//Start a two wire transaction
	if(!driver->start())
    a9ea:	8e a9       	ldd	r24, Y+54	; 0x36
    a9ec:	9f a9       	ldd	r25, Y+55	; 0x37
    a9ee:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a9f2:	81 11       	cpse	r24, r1
    a9f4:	a7 cd       	rjmp	.-1202   	; 0xa544 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xf8>

	//end the transaction
	driver->stop();
	
	return true;
}
    a9f6:	df 91       	pop	r29
    a9f8:	cf 91       	pop	r28
    a9fa:	1f 91       	pop	r17
    a9fc:	0f 91       	pop	r16
    a9fe:	ff 90       	pop	r15
    aa00:	ef 90       	pop	r14
    aa02:	df 90       	pop	r13
    aa04:	cf 90       	pop	r12
    aa06:	bf 90       	pop	r11
    aa08:	af 90       	pop	r10
    aa0a:	9f 90       	pop	r9
    aa0c:	8f 90       	pop	r8
    aa0e:	7f 90       	pop	r7
    aa10:	6f 90       	pop	r6
    aa12:	5f 90       	pop	r5
    aa14:	4f 90       	pop	r4
    aa16:	3f 90       	pop	r3
    aa18:	2f 90       	pop	r2
    aa1a:	08 95       	ret

0000aa1c <_ZN10helicopter5tasks4Task4initEv>:
				virtual ~Task(){}
				
				/**
				 * Function to initialize the task before execution.
				 */
				virtual void init(){;}
    aa1c:	08 95       	ret

0000aa1e <_ZN10helicopter5tasks14NavigationTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    aa1e:	26 e7       	ldi	r18, 0x76	; 118
    aa20:	33 e0       	ldi	r19, 0x03	; 3
    aa22:	fc 01       	movw	r30, r24
    aa24:	31 83       	std	Z+1, r19	; 0x01
    aa26:	20 83       	st	Z, r18
    aa28:	08 95       	ret

0000aa2a <_ZN10helicopter5tasks14NavigationTaskD0Ev>:
    aa2a:	26 e7       	ldi	r18, 0x76	; 118
    aa2c:	33 e0       	ldi	r19, 0x03	; 3
    aa2e:	fc 01       	movw	r30, r24
    aa30:	31 83       	std	Z+1, r19	; 0x01
    aa32:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class NavigationTask : public Task
    aa34:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    aa38:	08 95       	ret

0000aa3a <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>:
{
	
}

void NavigationTask::runTaskImpl()
{
    aa3a:	6f 92       	push	r6
    aa3c:	7f 92       	push	r7
    aa3e:	8f 92       	push	r8
    aa40:	9f 92       	push	r9
    aa42:	af 92       	push	r10
    aa44:	bf 92       	push	r11
    aa46:	cf 92       	push	r12
    aa48:	df 92       	push	r13
    aa4a:	ef 92       	push	r14
    aa4c:	ff 92       	push	r15
    aa4e:	0f 93       	push	r16
    aa50:	1f 93       	push	r17
    aa52:	cf 93       	push	r28
    aa54:	df 93       	push	r29
    aa56:	ec 01       	movw	r28, r24
	//avoid oversampling by only calculating a new ahrs value if we have new gyro data (since our AHRS is most sensitive to gyro data).
	if (model->RollAngularVelocityRadsPerSecond() != oldrollAngularVelocityRs || 
    aa58:	6d 84       	ldd	r6, Y+13	; 0x0d
    aa5a:	7e 84       	ldd	r7, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    aa5c:	f3 01       	movw	r30, r6
    aa5e:	e2 52       	subi	r30, 0x22	; 34
    aa60:	ff 4f       	sbci	r31, 0xFF	; 255
    aa62:	80 80       	ld	r8, Z
    aa64:	91 80       	ldd	r9, Z+1	; 0x01
    aa66:	a2 80       	ldd	r10, Z+2	; 0x02
    aa68:	b3 80       	ldd	r11, Z+3	; 0x03
    aa6a:	a5 01       	movw	r20, r10
    aa6c:	94 01       	movw	r18, r8
    aa6e:	6b 89       	ldd	r22, Y+19	; 0x13
    aa70:	7c 89       	ldd	r23, Y+20	; 0x14
    aa72:	8d 89       	ldd	r24, Y+21	; 0x15
    aa74:	9e 89       	ldd	r25, Y+22	; 0x16
    aa76:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    aa7a:	81 11       	cpse	r24, r1
    aa7c:	1f c0       	rjmp	.+62     	; 0xaabc <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    aa7e:	f3 01       	movw	r30, r6
    aa80:	e6 52       	subi	r30, 0x26	; 38
    aa82:	ff 4f       	sbci	r31, 0xFF	; 255
    aa84:	20 81       	ld	r18, Z
    aa86:	31 81       	ldd	r19, Z+1	; 0x01
    aa88:	42 81       	ldd	r20, Z+2	; 0x02
    aa8a:	53 81       	ldd	r21, Z+3	; 0x03
    aa8c:	6f 85       	ldd	r22, Y+15	; 0x0f
    aa8e:	78 89       	ldd	r23, Y+16	; 0x10
    aa90:	89 89       	ldd	r24, Y+17	; 0x11
    aa92:	9a 89       	ldd	r25, Y+18	; 0x12
    aa94:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    aa98:	81 11       	cpse	r24, r1
    aa9a:	10 c0       	rjmp	.+32     	; 0xaabc <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    aa9c:	f3 01       	movw	r30, r6
    aa9e:	ee 51       	subi	r30, 0x1E	; 30
    aaa0:	ff 4f       	sbci	r31, 0xFF	; 255
    aaa2:	20 81       	ld	r18, Z
    aaa4:	31 81       	ldd	r19, Z+1	; 0x01
    aaa6:	42 81       	ldd	r20, Z+2	; 0x02
    aaa8:	53 81       	ldd	r21, Z+3	; 0x03
    aaaa:	6f 89       	ldd	r22, Y+23	; 0x17
    aaac:	78 8d       	ldd	r23, Y+24	; 0x18
    aaae:	89 8d       	ldd	r24, Y+25	; 0x19
    aab0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    aab2:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    aab6:	88 23       	and	r24, r24
    aab8:	09 f4       	brne	.+2      	; 0xaabc <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
    aaba:	9f c0       	rjmp	.+318    	; 0xabfa <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x1c0>
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    aabc:	f3 01       	movw	r30, r6
    aabe:	e2 51       	subi	r30, 0x12	; 18
    aac0:	ff 4f       	sbci	r31, 0xFF	; 255
		/**
		 * Update the AHRS
		 */
		ahrs->update(model->XAccelFrdMss(), model->YAccelFrdMss(), model->ZAccelFrdMss(),
					model->RollAngularVelocityRadsPerSecond(), model->PitchAngularVelocityRadsPerSecond(), model->YawAngularVelocityRadsPerSecond(),
					model->XMagFrd(), model->YMagFrd(), model->ZMagFrd());
    aac2:	c0 80       	ld	r12, Z
    aac4:	d1 80       	ldd	r13, Z+1	; 0x01
    aac6:	e2 80       	ldd	r14, Z+2	; 0x02
    aac8:	f3 80       	ldd	r15, Z+3	; 0x03
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    aaca:	f3 01       	movw	r30, r6
    aacc:	e6 51       	subi	r30, 0x16	; 22
    aace:	ff 4f       	sbci	r31, 0xFF	; 255
    aad0:	00 81       	ld	r16, Z
    aad2:	11 81       	ldd	r17, Z+1	; 0x01
    aad4:	22 81       	ldd	r18, Z+2	; 0x02
    aad6:	33 81       	ldd	r19, Z+3	; 0x03

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    aad8:	f3 01       	movw	r30, r6
    aada:	ea 51       	subi	r30, 0x1A	; 26
    aadc:	ff 4f       	sbci	r31, 0xFF	; 255
    aade:	40 81       	ld	r20, Z
    aae0:	51 81       	ldd	r21, Z+1	; 0x01
    aae2:	62 81       	ldd	r22, Z+2	; 0x02
    aae4:	73 81       	ldd	r23, Z+3	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    aae6:	f3 01       	movw	r30, r6
    aae8:	e6 50       	subi	r30, 0x06	; 6
    aaea:	ff 4f       	sbci	r31, 0xFF	; 255
    aaec:	83 81       	ldd	r24, Z+3	; 0x03
    aaee:	8f 93       	push	r24
    aaf0:	82 81       	ldd	r24, Z+2	; 0x02
    aaf2:	8f 93       	push	r24
    aaf4:	81 81       	ldd	r24, Z+1	; 0x01
    aaf6:	8f 93       	push	r24
    aaf8:	e0 81       	ld	r30, Z
    aafa:	ef 93       	push	r30
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    aafc:	f3 01       	movw	r30, r6
    aafe:	ea 50       	subi	r30, 0x0A	; 10
    ab00:	ff 4f       	sbci	r31, 0xFF	; 255
    ab02:	83 81       	ldd	r24, Z+3	; 0x03
    ab04:	8f 93       	push	r24
    ab06:	82 81       	ldd	r24, Z+2	; 0x02
    ab08:	8f 93       	push	r24
    ab0a:	81 81       	ldd	r24, Z+1	; 0x01
    ab0c:	8f 93       	push	r24
    ab0e:	e0 81       	ld	r30, Z
    ab10:	ef 93       	push	r30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    ab12:	f3 01       	movw	r30, r6
    ab14:	ee 50       	subi	r30, 0x0E	; 14
    ab16:	ff 4f       	sbci	r31, 0xFF	; 255
    ab18:	83 81       	ldd	r24, Z+3	; 0x03
    ab1a:	8f 93       	push	r24
    ab1c:	82 81       	ldd	r24, Z+2	; 0x02
    ab1e:	8f 93       	push	r24
    ab20:	81 81       	ldd	r24, Z+1	; 0x01
    ab22:	8f 93       	push	r24
    ab24:	e0 81       	ld	r30, Z
    ab26:	ef 93       	push	r30
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    ab28:	f3 01       	movw	r30, r6
    ab2a:	ee 51       	subi	r30, 0x1E	; 30
    ab2c:	ff 4f       	sbci	r31, 0xFF	; 255
    ab2e:	83 81       	ldd	r24, Z+3	; 0x03
    ab30:	8f 93       	push	r24
    ab32:	82 81       	ldd	r24, Z+2	; 0x02
    ab34:	8f 93       	push	r24
    ab36:	81 81       	ldd	r24, Z+1	; 0x01
    ab38:	8f 93       	push	r24
    ab3a:	e0 81       	ld	r30, Z
    ab3c:	ef 93       	push	r30
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    ab3e:	f3 01       	movw	r30, r6
    ab40:	e6 52       	subi	r30, 0x26	; 38
    ab42:	ff 4f       	sbci	r31, 0xFF	; 255
    ab44:	83 81       	ldd	r24, Z+3	; 0x03
    ab46:	8f 93       	push	r24
    ab48:	82 81       	ldd	r24, Z+2	; 0x02
    ab4a:	8f 93       	push	r24
    ab4c:	81 81       	ldd	r24, Z+1	; 0x01
    ab4e:	8f 93       	push	r24
    ab50:	e0 81       	ld	r30, Z
    ab52:	ef 93       	push	r30
    ab54:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab56:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab58:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <_ZN10helicopter10navigation4AHRS6updateEfffffffff>
				
		model->YawRads(ahrs->getYawRads());
    ab5c:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab5e:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab60:	0e 94 f9 41 	call	0x83f2	; 0x83f2 <_ZN10helicopter10navigation4AHRS10getYawRadsEv>
    ab64:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab66:	fe 85       	ldd	r31, Y+14	; 0x0e

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
    ab68:	ea 52       	subi	r30, 0x2A	; 42
    ab6a:	ff 4f       	sbci	r31, 0xFF	; 255
    ab6c:	60 83       	st	Z, r22
    ab6e:	71 83       	std	Z+1, r23	; 0x01
    ab70:	82 83       	std	Z+2, r24	; 0x02
    ab72:	93 83       	std	Z+3, r25	; 0x03
		model->PitchRads(ahrs->getPitchRads());
    ab74:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab76:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab78:	0e 94 03 42 	call	0x8406	; 0x8406 <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>
    ab7c:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab7e:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
    ab80:	ee 52       	subi	r30, 0x2E	; 46
    ab82:	ff 4f       	sbci	r31, 0xFF	; 255
    ab84:	60 83       	st	Z, r22
    ab86:	71 83       	std	Z+1, r23	; 0x01
    ab88:	82 83       	std	Z+2, r24	; 0x02
    ab8a:	93 83       	std	Z+3, r25	; 0x03
		model->RollRads(ahrs->getRollRads());
    ab8c:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab8e:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab90:	0e 94 0d 42 	call	0x841a	; 0x841a <_ZN10helicopter10navigation4AHRS11getRollRadsEv>
    ab94:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab96:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	
    ab98:	e2 53       	subi	r30, 0x32	; 50
    ab9a:	ff 4f       	sbci	r31, 0xFF	; 255
    ab9c:	60 83       	st	Z, r22
    ab9e:	71 83       	std	Z+1, r23	; 0x01
    aba0:	82 83       	std	Z+2, r24	; 0x02
    aba2:	93 83       	std	Z+3, r25	; 0x03
		
		oldrollAngularVelocityRs = model->RollAngularVelocityRadsPerSecond();
    aba4:	2d 85       	ldd	r18, Y+13	; 0x0d
    aba6:	3e 85       	ldd	r19, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    aba8:	f9 01       	movw	r30, r18
    abaa:	e2 52       	subi	r30, 0x22	; 34
    abac:	ff 4f       	sbci	r31, 0xFF	; 255
    abae:	80 81       	ld	r24, Z
    abb0:	91 81       	ldd	r25, Z+1	; 0x01
    abb2:	a2 81       	ldd	r26, Z+2	; 0x02
    abb4:	b3 81       	ldd	r27, Z+3	; 0x03
    abb6:	8b 8b       	std	Y+19, r24	; 0x13
    abb8:	9c 8b       	std	Y+20, r25	; 0x14
    abba:	ad 8b       	std	Y+21, r26	; 0x15
    abbc:	be 8b       	std	Y+22, r27	; 0x16
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    abbe:	f9 01       	movw	r30, r18
    abc0:	e6 52       	subi	r30, 0x26	; 38
    abc2:	ff 4f       	sbci	r31, 0xFF	; 255
    abc4:	80 81       	ld	r24, Z
    abc6:	91 81       	ldd	r25, Z+1	; 0x01
    abc8:	a2 81       	ldd	r26, Z+2	; 0x02
    abca:	b3 81       	ldd	r27, Z+3	; 0x03
		oldpitchAngularVelocityRs = model->PitchAngularVelocityRadsPerSecond();
    abcc:	8f 87       	std	Y+15, r24	; 0x0f
    abce:	98 8b       	std	Y+16, r25	; 0x10
    abd0:	a9 8b       	std	Y+17, r26	; 0x11
    abd2:	ba 8b       	std	Y+18, r27	; 0x12
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    abd4:	f9 01       	movw	r30, r18
    abd6:	ee 51       	subi	r30, 0x1E	; 30
    abd8:	ff 4f       	sbci	r31, 0xFF	; 255
    abda:	80 81       	ld	r24, Z
    abdc:	91 81       	ldd	r25, Z+1	; 0x01
    abde:	a2 81       	ldd	r26, Z+2	; 0x02
    abe0:	b3 81       	ldd	r27, Z+3	; 0x03
		oldyawAngularVelocityRs = model->YawAngularVelocityRadsPerSecond();
    abe2:	8f 8b       	std	Y+23, r24	; 0x17
    abe4:	98 8f       	std	Y+24, r25	; 0x18
    abe6:	a9 8f       	std	Y+25, r26	; 0x19
    abe8:	ba 8f       	std	Y+26, r27	; 0x1a
    abea:	8d b7       	in	r24, 0x3d	; 61
    abec:	9e b7       	in	r25, 0x3e	; 62
    abee:	44 96       	adiw	r24, 0x14	; 20
    abf0:	0f b6       	in	r0, 0x3f	; 63
    abf2:	f8 94       	cli
    abf4:	9e bf       	out	0x3e, r25	; 62
    abf6:	0f be       	out	0x3f, r0	; 63
    abf8:	8d bf       	out	0x3d, r24	; 61
	//model->YNEDLocalFrameCm(localNEDY);
	////model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	//
	//
	
}
    abfa:	df 91       	pop	r29
    abfc:	cf 91       	pop	r28
    abfe:	1f 91       	pop	r17
    ac00:	0f 91       	pop	r16
    ac02:	ff 90       	pop	r15
    ac04:	ef 90       	pop	r14
    ac06:	df 90       	pop	r13
    ac08:	cf 90       	pop	r12
    ac0a:	bf 90       	pop	r11
    ac0c:	af 90       	pop	r10
    ac0e:	9f 90       	pop	r9
    ac10:	8f 90       	pop	r8
    ac12:	7f 90       	pop	r7
    ac14:	6f 90       	pop	r6
    ac16:	08 95       	ret

0000ac18 <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float NavigationTask::WEIGHT = .15;


NavigationTask::NavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    ac18:	4f 92       	push	r4
    ac1a:	5f 92       	push	r5
    ac1c:	6f 92       	push	r6
    ac1e:	7f 92       	push	r7
    ac20:	af 92       	push	r10
    ac22:	bf 92       	push	r11
    ac24:	cf 92       	push	r12
    ac26:	df 92       	push	r13
    ac28:	ef 92       	push	r14
    ac2a:	ff 92       	push	r15
    ac2c:	0f 93       	push	r16
    ac2e:	1f 93       	push	r17
    ac30:	cf 93       	push	r28
    ac32:	df 93       	push	r29
    ac34:	ec 01       	movw	r28, r24
    ac36:	2a 01       	movw	r4, r20
    ac38:	3b 01       	movw	r6, r22
    ac3a:	59 01       	movw	r10, r18
    ac3c:	b7 01       	movw	r22, r14
    ac3e:	a6 01       	movw	r20, r12
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model),
oldpitchAngularVelocityRs(0),
oldrollAngularVelocityRs(0),
oldyawAngularVelocityRs(0)
    ac40:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    ac44:	8a ee       	ldi	r24, 0xEA	; 234
    ac46:	92 e0       	ldi	r25, 0x02	; 2
    ac48:	99 83       	std	Y+1, r25	; 0x01
    ac4a:	88 83       	st	Y, r24
    ac4c:	4f 82       	std	Y+7, r4	; 0x07
    ac4e:	58 86       	std	Y+8, r5	; 0x08
    ac50:	69 86       	std	Y+9, r6	; 0x09
    ac52:	7a 86       	std	Y+10, r7	; 0x0a
    ac54:	bc 86       	std	Y+12, r11	; 0x0c
    ac56:	ab 86       	std	Y+11, r10	; 0x0b
    ac58:	1e 87       	std	Y+14, r17	; 0x0e
    ac5a:	0d 87       	std	Y+13, r16	; 0x0d
    ac5c:	1f 86       	std	Y+15, r1	; 0x0f
    ac5e:	18 8a       	std	Y+16, r1	; 0x10
    ac60:	19 8a       	std	Y+17, r1	; 0x11
    ac62:	1a 8a       	std	Y+18, r1	; 0x12
    ac64:	1b 8a       	std	Y+19, r1	; 0x13
    ac66:	1c 8a       	std	Y+20, r1	; 0x14
    ac68:	1d 8a       	std	Y+21, r1	; 0x15
    ac6a:	1e 8a       	std	Y+22, r1	; 0x16
    ac6c:	1f 8a       	std	Y+23, r1	; 0x17
    ac6e:	18 8e       	std	Y+24, r1	; 0x18
    ac70:	19 8e       	std	Y+25, r1	; 0x19
    ac72:	1a 8e       	std	Y+26, r1	; 0x1a
{
	
}
    ac74:	df 91       	pop	r29
    ac76:	cf 91       	pop	r28
    ac78:	1f 91       	pop	r17
    ac7a:	0f 91       	pop	r16
    ac7c:	ff 90       	pop	r15
    ac7e:	ef 90       	pop	r14
    ac80:	df 90       	pop	r13
    ac82:	cf 90       	pop	r12
    ac84:	bf 90       	pop	r11
    ac86:	af 90       	pop	r10
    ac88:	7f 90       	pop	r7
    ac8a:	6f 90       	pop	r6
    ac8c:	5f 90       	pop	r5
    ac8e:	4f 90       	pop	r4
    ac90:	08 95       	ret

0000ac92 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>:
    ac92:	26 e7       	ldi	r18, 0x76	; 118
    ac94:	33 e0       	ldi	r19, 0x03	; 3
    ac96:	fc 01       	movw	r30, r24
    ac98:	31 83       	std	Z+1, r19	; 0x01
    ac9a:	20 83       	st	Z, r18
    ac9c:	08 95       	ret

0000ac9e <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>:
    ac9e:	26 e7       	ldi	r18, 0x76	; 118
    aca0:	33 e0       	ldi	r19, 0x03	; 3
    aca2:	fc 01       	movw	r30, r24
    aca4:	31 83       	std	Z+1, r19	; 0x01
    aca6:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDInnerLoopTask : public Task
    aca8:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    acac:	08 95       	ret

0000acae <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>:
{
	
}

void PIDInnerLoopTask::runTaskImpl()
{
    acae:	cf 93       	push	r28
    acb0:	df 93       	push	r29
    acb2:	ec 01       	movw	r28, r24
	pidController->cyclicLateralInnerLoopUpdate();
    acb4:	8f 81       	ldd	r24, Y+7	; 0x07
    acb6:	98 85       	ldd	r25, Y+8	; 0x08
    acb8:	0e 94 0b 0a 	call	0x1416	; 0x1416 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>
	pidController->cyclicLongitudeInnerLoopUpdate();
    acbc:	8f 81       	ldd	r24, Y+7	; 0x07
    acbe:	98 85       	ldd	r25, Y+8	; 0x08
    acc0:	0e 94 9b 09 	call	0x1336	; 0x1336 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>
}
    acc4:	df 91       	pop	r29
    acc6:	cf 91       	pop	r28
    acc8:	08 95       	ret

0000acca <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDInnerLoopTask.h"

using namespace helicopter::tasks;

PIDInnerLoopTask::PIDInnerLoopTask (PIDController *pidController, int delay, int period) :
    acca:	0f 93       	push	r16
    accc:	1f 93       	push	r17
    acce:	cf 93       	push	r28
    acd0:	df 93       	push	r29
    acd2:	ec 01       	movw	r28, r24
    acd4:	8b 01       	movw	r16, r22
    acd6:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    acd8:	a9 01       	movw	r20, r18
    acda:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    acde:	88 ef       	ldi	r24, 0xF8	; 248
    ace0:	92 e0       	ldi	r25, 0x02	; 2
    ace2:	99 83       	std	Y+1, r25	; 0x01
    ace4:	88 83       	st	Y, r24
    ace6:	18 87       	std	Y+8, r17	; 0x08
    ace8:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    acea:	df 91       	pop	r29
    acec:	cf 91       	pop	r28
    acee:	1f 91       	pop	r17
    acf0:	0f 91       	pop	r16
    acf2:	08 95       	ret

0000acf4 <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>:
    acf4:	26 e7       	ldi	r18, 0x76	; 118
    acf6:	33 e0       	ldi	r19, 0x03	; 3
    acf8:	fc 01       	movw	r30, r24
    acfa:	31 83       	std	Z+1, r19	; 0x01
    acfc:	20 83       	st	Z, r18
    acfe:	08 95       	ret

0000ad00 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>:
    ad00:	26 e7       	ldi	r18, 0x76	; 118
    ad02:	33 e0       	ldi	r19, 0x03	; 3
    ad04:	fc 01       	movw	r30, r24
    ad06:	31 83       	std	Z+1, r19	; 0x01
    ad08:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDOuterLoopTask : public Task
    ad0a:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    ad0e:	08 95       	ret

0000ad10 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>:
	
}

void PIDOuterLoopTask::runTaskImpl()
{
	pidController->outerLoopUpdate();
    ad10:	fc 01       	movw	r30, r24
    ad12:	87 81       	ldd	r24, Z+7	; 0x07
    ad14:	90 85       	ldd	r25, Z+8	; 0x08
    ad16:	0e 94 e7 08 	call	0x11ce	; 0x11ce <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>
    ad1a:	08 95       	ret

0000ad1c <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDOuterLoopTask.h"

using namespace helicopter::tasks;

PIDOuterLoopTask::PIDOuterLoopTask (PIDController *pidController, int delay, int period) :
    ad1c:	0f 93       	push	r16
    ad1e:	1f 93       	push	r17
    ad20:	cf 93       	push	r28
    ad22:	df 93       	push	r29
    ad24:	ec 01       	movw	r28, r24
    ad26:	8b 01       	movw	r16, r22
    ad28:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    ad2a:	a9 01       	movw	r20, r18
    ad2c:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    ad30:	86 e0       	ldi	r24, 0x06	; 6
    ad32:	93 e0       	ldi	r25, 0x03	; 3
    ad34:	99 83       	std	Y+1, r25	; 0x01
    ad36:	88 83       	st	Y, r24
    ad38:	18 87       	std	Y+8, r17	; 0x08
    ad3a:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    ad3c:	df 91       	pop	r29
    ad3e:	cf 91       	pop	r28
    ad40:	1f 91       	pop	r17
    ad42:	0f 91       	pop	r16
    ad44:	08 95       	ret

0000ad46 <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>:
    ad46:	26 e7       	ldi	r18, 0x76	; 118
    ad48:	33 e0       	ldi	r19, 0x03	; 3
    ad4a:	fc 01       	movw	r30, r24
    ad4c:	31 83       	std	Z+1, r19	; 0x01
    ad4e:	20 83       	st	Z, r18
    ad50:	08 95       	ret

0000ad52 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>:
    ad52:	26 e7       	ldi	r18, 0x76	; 118
    ad54:	33 e0       	ldi	r19, 0x03	; 3
    ad56:	fc 01       	movw	r30, r24
    ad58:	31 83       	std	Z+1, r19	; 0x01
    ad5a:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PVNavigationTask : public Task
    ad5c:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    ad60:	08 95       	ret

0000ad62 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>:
{
	
}

void PVNavigationTask::runTaskImpl()
{	
    ad62:	2f 92       	push	r2
    ad64:	3f 92       	push	r3
    ad66:	4f 92       	push	r4
    ad68:	5f 92       	push	r5
    ad6a:	6f 92       	push	r6
    ad6c:	7f 92       	push	r7
    ad6e:	8f 92       	push	r8
    ad70:	9f 92       	push	r9
    ad72:	af 92       	push	r10
    ad74:	bf 92       	push	r11
    ad76:	cf 92       	push	r12
    ad78:	df 92       	push	r13
    ad7a:	ef 92       	push	r14
    ad7c:	ff 92       	push	r15
    ad7e:	0f 93       	push	r16
    ad80:	1f 93       	push	r17
    ad82:	cf 93       	push	r28
    ad84:	df 93       	push	r29
    ad86:	cd b7       	in	r28, 0x3d	; 61
    ad88:	de b7       	in	r29, 0x3e	; 62
    ad8a:	e4 97       	sbiw	r28, 0x34	; 52
    ad8c:	0f b6       	in	r0, 0x3f	; 63
    ad8e:	f8 94       	cli
    ad90:	de bf       	out	0x3e, r29	; 62
    ad92:	0f be       	out	0x3f, r0	; 63
    ad94:	cd bf       	out	0x3d, r28	; 61
    ad96:	4c 01       	movw	r8, r24
	/**
	 * Process GPS data into NED position and velocity. 
	 */
	float rotatedVelocityMatrix[3] = {};
    ad98:	8c e0       	ldi	r24, 0x0C	; 12
    ad9a:	7e 01       	movw	r14, r28
    ad9c:	99 e1       	ldi	r25, 0x19	; 25
    ad9e:	e9 0e       	add	r14, r25
    ada0:	f1 1c       	adc	r15, r1
    ada2:	d7 01       	movw	r26, r14
    ada4:	e8 2f       	mov	r30, r24
    ada6:	1d 92       	st	X+, r1
    ada8:	ea 95       	dec	r30
    adaa:	e9 f7       	brne	.-6      	; 0xada6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x44>
	float velocityBodyFrame[3] = {};
    adac:	6e 01       	movw	r12, r28
    adae:	fd e0       	ldi	r31, 0x0D	; 13
    adb0:	cf 0e       	add	r12, r31
    adb2:	d1 1c       	adc	r13, r1
    adb4:	d6 01       	movw	r26, r12
    adb6:	1d 92       	st	X+, r1
    adb8:	8a 95       	dec	r24
    adba:	e9 f7       	brne	.-6      	; 0xadb6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x54>
		
	float velocityMatrix[3] = {(float)model->XVEcefCms(), (float)model->YVEcefCms(), (float)model->ZVEcefCms()};
    adbc:	f4 01       	movw	r30, r8
    adbe:	05 85       	ldd	r16, Z+13	; 0x0d
    adc0:	16 85       	ldd	r17, Z+14	; 0x0e
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    adc2:	f8 01       	movw	r30, r16
    adc4:	e6 5f       	subi	r30, 0xF6	; 246
    adc6:	fe 4f       	sbci	r31, 0xFE	; 254
    adc8:	60 81       	ld	r22, Z
    adca:	71 81       	ldd	r23, Z+1	; 0x01
    adcc:	82 81       	ldd	r24, Z+2	; 0x02
    adce:	93 81       	ldd	r25, Z+3	; 0x03
    add0:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    add4:	69 83       	std	Y+1, r22	; 0x01
    add6:	7a 83       	std	Y+2, r23	; 0x02
    add8:	8b 83       	std	Y+3, r24	; 0x03
    adda:	9c 83       	std	Y+4, r25	; 0x04
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    addc:	f8 01       	movw	r30, r16
    adde:	e2 5f       	subi	r30, 0xF2	; 242
    ade0:	fe 4f       	sbci	r31, 0xFE	; 254
    ade2:	60 81       	ld	r22, Z
    ade4:	71 81       	ldd	r23, Z+1	; 0x01
    ade6:	82 81       	ldd	r24, Z+2	; 0x02
    ade8:	93 81       	ldd	r25, Z+3	; 0x03
    adea:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    adee:	6d 83       	std	Y+5, r22	; 0x05
    adf0:	7e 83       	std	Y+6, r23	; 0x06
    adf2:	8f 83       	std	Y+7, r24	; 0x07
    adf4:	98 87       	std	Y+8, r25	; 0x08
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    adf6:	f8 01       	movw	r30, r16
    adf8:	ee 5e       	subi	r30, 0xEE	; 238
    adfa:	fe 4f       	sbci	r31, 0xFE	; 254
    adfc:	60 81       	ld	r22, Z
    adfe:	71 81       	ldd	r23, Z+1	; 0x01
    ae00:	82 81       	ldd	r24, Z+2	; 0x02
    ae02:	93 81       	ldd	r25, Z+3	; 0x03
    ae04:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    ae08:	69 87       	std	Y+9, r22	; 0x09
    ae0a:	7a 87       	std	Y+10, r23	; 0x0a
    ae0c:	8b 87       	std	Y+11, r24	; 0x0b
    ae0e:	9c 87       	std	Y+12, r25	; 0x0c
	MatrixUtil::RotateMatrix(model->EcefToLocalNEDRotationMatrix,velocityMatrix,rotatedVelocityMatrix);
    ae10:	a7 01       	movw	r20, r14
    ae12:	be 01       	movw	r22, r28
    ae14:	6f 5f       	subi	r22, 0xFF	; 255
    ae16:	7f 4f       	sbci	r23, 0xFF	; 255
    ae18:	c8 01       	movw	r24, r16
    ae1a:	82 5e       	subi	r24, 0xE2	; 226
    ae1c:	9e 4f       	sbci	r25, 0xFE	; 254
    ae1e:	0e 94 40 69 	call	0xd280	; 0xd280 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
    ae22:	d4 01       	movw	r26, r8
    ae24:	1d 96       	adiw	r26, 0x0d	; 13
    ae26:	ed 91       	ld	r30, X+
    ae28:	fc 91       	ld	r31, X
    ae2a:	1e 97       	sbiw	r26, 0x0e	; 14
	/*
	MatrixUtil::CreateRotationMatrixTransposed(ahrs->getRollRads(), ahrs->getPitchRads(), ahrs->getYawRads(), nedToBodyFrameMatrix);
	MatrixUtil::RotateMatrix(nedToBodyFrameMatrix,rotatedVelocityMatrix, velocityBodyFrame);
	*/
	
	MatrixUtil::RotateMatrixT(model->Ahrs()->dcm,rotatedVelocityMatrix, velocityBodyFrame);	
    ae2c:	80 81       	ld	r24, Z
    ae2e:	91 81       	ldd	r25, Z+1	; 0x01
    ae30:	a6 01       	movw	r20, r12
    ae32:	b7 01       	movw	r22, r14
    ae34:	80 5c       	subi	r24, 0xC0	; 192
    ae36:	9f 4f       	sbci	r25, 0xFF	; 255
    ae38:	0e 94 5d 68 	call	0xd0ba	; 0xd0ba <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	
	model->XVelocityFRDCms(velocityBodyFrame[0]);
    ae3c:	d4 01       	movw	r26, r8
    ae3e:	1d 96       	adiw	r26, 0x0d	; 13
    ae40:	ed 91       	ld	r30, X+
    ae42:	fc 91       	ld	r31, X
    ae44:	1e 97       	sbiw	r26, 0x0e	; 14

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
    ae46:	8d 85       	ldd	r24, Y+13	; 0x0d
    ae48:	9e 85       	ldd	r25, Y+14	; 0x0e
    ae4a:	af 85       	ldd	r26, Y+15	; 0x0f
    ae4c:	b8 89       	ldd	r27, Y+16	; 0x10
    ae4e:	82 ab       	std	Z+50, r24	; 0x32
    ae50:	93 ab       	std	Z+51, r25	; 0x33
    ae52:	a4 ab       	std	Z+52, r26	; 0x34
    ae54:	b5 ab       	std	Z+53, r27	; 0x35
	model->YVelocityFRDCms(velocityBodyFrame[1]);
    ae56:	d4 01       	movw	r26, r8
    ae58:	1d 96       	adiw	r26, 0x0d	; 13
    ae5a:	ed 91       	ld	r30, X+
    ae5c:	fc 91       	ld	r31, X
    ae5e:	1e 97       	sbiw	r26, 0x0e	; 14

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}
    ae60:	e2 5a       	subi	r30, 0xA2	; 162
    ae62:	ff 4f       	sbci	r31, 0xFF	; 255
    ae64:	89 89       	ldd	r24, Y+17	; 0x11
    ae66:	9a 89       	ldd	r25, Y+18	; 0x12
    ae68:	ab 89       	ldd	r26, Y+19	; 0x13
    ae6a:	bc 89       	ldd	r27, Y+20	; 0x14
    ae6c:	80 83       	st	Z, r24
    ae6e:	91 83       	std	Z+1, r25	; 0x01
    ae70:	a2 83       	std	Z+2, r26	; 0x02
    ae72:	b3 83       	std	Z+3, r27	; 0x03
	

	
	
	if (model->HasNewPressureReading == true)
    ae74:	f4 01       	movw	r30, r8
    ae76:	05 85       	ldd	r16, Z+13	; 0x0d
    ae78:	16 85       	ldd	r17, Z+14	; 0x0e
    ae7a:	f8 01       	movw	r30, r16
    ae7c:	ee 5b       	subi	r30, 0xBE	; 190
    ae7e:	fe 4f       	sbci	r31, 0xFE	; 254
    ae80:	80 81       	ld	r24, Z
    ae82:	88 23       	and	r24, r24
    ae84:	09 f4       	brne	.+2      	; 0xae88 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x126>
    ae86:	77 c0       	rjmp	.+238    	; 0xaf76 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x214>
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    ae88:	f8 01       	movw	r30, r16
    ae8a:	ea 5e       	subi	r30, 0xEA	; 234
    ae8c:	fe 4f       	sbci	r31, 0xFE	; 254
		 * Multiply by -100 because in NED, 'down' is positive. And to convert meters to cm.
		 * -0.00000687535 = -6.8755856 * 10^-6
		 */
		//float altitudeMslCm = (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		//4433228.712 is a number I came up with from simplifying the expression (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		float altitudeMslCm = (pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712; 
    ae8e:	20 e0       	ldi	r18, 0x00	; 0
    ae90:	30 e5       	ldi	r19, 0x50	; 80
    ae92:	4d e7       	ldi	r20, 0x7D	; 125
    ae94:	54 e4       	ldi	r21, 0x44	; 68
    ae96:	60 81       	ld	r22, Z
    ae98:	71 81       	ldd	r23, Z+1	; 0x01
    ae9a:	82 81       	ldd	r24, Z+2	; 0x02
    ae9c:	93 81       	ldd	r25, Z+3	; 0x03
    ae9e:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    aea2:	0e 94 88 6d 	call	0xdb10	; 0xdb10 <log10>
    aea6:	2b e2       	ldi	r18, 0x2B	; 43
    aea8:	30 e3       	ldi	r19, 0x30	; 48
    aeaa:	48 ea       	ldi	r20, 0xA8	; 168
    aeac:	50 e4       	ldi	r21, 0x40	; 64
    aeae:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    aeb2:	9b 01       	movw	r18, r22
    aeb4:	ac 01       	movw	r20, r24
    aeb6:	60 e0       	ldi	r22, 0x00	; 0
    aeb8:	70 e0       	ldi	r23, 0x00	; 0
    aeba:	80 e2       	ldi	r24, 0x20	; 32
    aebc:	91 e4       	ldi	r25, 0x41	; 65
    aebe:	0e 94 36 6e 	call	0xdc6c	; 0xdc6c <pow>
    aec2:	20 e0       	ldi	r18, 0x00	; 0
    aec4:	30 e0       	ldi	r19, 0x00	; 0
    aec6:	40 e8       	ldi	r20, 0x80	; 128
    aec8:	5f e3       	ldi	r21, 0x3F	; 63
    aeca:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    aece:	29 e9       	ldi	r18, 0x99	; 153
    aed0:	3a e4       	ldi	r19, 0x4A	; 74
    aed2:	47 e8       	ldi	r20, 0x87	; 135
    aed4:	5a e4       	ldi	r21, 0x4A	; 74
    aed6:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    aeda:	c6 2e       	mov	r12, r22
    aedc:	d7 2e       	mov	r13, r23
    aede:	e8 2e       	mov	r14, r24
    aee0:	f9 2e       	mov	r15, r25
		//bool hasGoodAltitude = true;
	
		//model->ZNEDLocalFrameCm((float) (altitudeMslCm - model->InitialAltitudeCm()));
	
	
		if (!isnanf(altitudeMslCm) && 
    aee2:	76 2f       	mov	r23, r22
    aee4:	27 2f       	mov	r18, r23
    aee6:	3d 2d       	mov	r19, r13
    aee8:	4e 2d       	mov	r20, r14
    aeea:	5f 2d       	mov	r21, r15
    aeec:	6c 2d       	mov	r22, r12
    aeee:	7d 2d       	mov	r23, r13
    aef0:	8e 2d       	mov	r24, r14
    aef2:	9f 2d       	mov	r25, r15
    aef4:	0e 94 cd 6e 	call	0xdd9a	; 0xdd9a <__unordsf2>
    aef8:	81 11       	cpse	r24, r1
    aefa:	35 c0       	rjmp	.+106    	; 0xaf66 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
    aefc:	f8 01       	movw	r30, r16
    aefe:	e6 53       	subi	r30, 0x36	; 54
    af00:	ff 4f       	sbci	r31, 0xFF	; 255
    af02:	20 81       	ld	r18, Z
    af04:	31 81       	ldd	r19, Z+1	; 0x01
    af06:	42 81       	ldd	r20, Z+2	; 0x02
    af08:	53 81       	ldd	r21, Z+3	; 0x03
    af0a:	6c 2d       	mov	r22, r12
    af0c:	7d 2d       	mov	r23, r13
    af0e:	8e 2d       	mov	r24, r14
    af10:	9f 2d       	mov	r25, r15
    af12:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    af16:	26 2e       	mov	r2, r22
    af18:	37 2e       	mov	r3, r23
    af1a:	e8 2e       	mov	r14, r24
    af1c:	f9 2e       	mov	r15, r25
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    af1e:	f8 01       	movw	r30, r16
    af20:	e2 58       	subi	r30, 0x82	; 130
    af22:	ff 4f       	sbci	r31, 0xFF	; 255
    af24:	40 80       	ld	r4, Z
    af26:	51 80       	ldd	r5, Z+1	; 0x01
    af28:	62 80       	ldd	r6, Z+2	; 0x02
    af2a:	73 80       	ldd	r7, Z+3	; 0x03
    af2c:	a3 01       	movw	r20, r6
    af2e:	92 01       	movw	r18, r4
    af30:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    af34:	a6 2e       	mov	r10, r22
    af36:	b7 2e       	mov	r11, r23
    af38:	c8 2e       	mov	r12, r24
    af3a:	d9 2e       	mov	r13, r25
    af3c:	20 e0       	ldi	r18, 0x00	; 0
    af3e:	30 e0       	ldi	r19, 0x00	; 0
    af40:	48 e4       	ldi	r20, 0x48	; 72
    af42:	54 e4       	ldi	r21, 0x44	; 68
    af44:	0e 94 4e 6b 	call	0xd69c	; 0xd69c <__cmpsf2>
    af48:	88 23       	and	r24, r24
    af4a:	6c f4       	brge	.+26     	; 0xaf66 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
    af4c:	20 e0       	ldi	r18, 0x00	; 0
    af4e:	30 e0       	ldi	r19, 0x00	; 0
    af50:	48 e4       	ldi	r20, 0x48	; 72
    af52:	54 ec       	ldi	r21, 0xC4	; 196
    af54:	6a 2d       	mov	r22, r10
    af56:	7b 2d       	mov	r23, r11
    af58:	8c 2d       	mov	r24, r12
    af5a:	9d 2d       	mov	r25, r13
    af5c:	0e 94 7d 6d 	call	0xdafa	; 0xdafa <__gesf2>
    af60:	18 16       	cp	r1, r24
    af62:	0c f4       	brge	.+2      	; 0xaf66 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
    af64:	93 c0       	rjmp	.+294    	; 0xb08c <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x32a>
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
		}
					
		
		model->HasNewPressureReading = false;
    af66:	d4 01       	movw	r26, r8
    af68:	1d 96       	adiw	r26, 0x0d	; 13
    af6a:	ed 91       	ld	r30, X+
    af6c:	fc 91       	ld	r31, X
    af6e:	1e 97       	sbiw	r26, 0x0e	; 14
    af70:	ee 5b       	subi	r30, 0xBE	; 190
    af72:	fe 4f       	sbci	r31, 0xFE	; 254
    af74:	10 82       	st	Z, r1
	
				
	/**
	* Convert position to local NED
	*/
	float localNEDX = 0.0;
    af76:	1d a6       	std	Y+45, r1	; 0x2d
    af78:	1e a6       	std	Y+46, r1	; 0x2e
    af7a:	1f a6       	std	Y+47, r1	; 0x2f
    af7c:	18 aa       	std	Y+48, r1	; 0x30
	float localNEDY = 0.0;
    af7e:	19 a6       	std	Y+41, r1	; 0x29
    af80:	1a a6       	std	Y+42, r1	; 0x2a
    af82:	1b a6       	std	Y+43, r1	; 0x2b
    af84:	1c a6       	std	Y+44, r1	; 0x2c
	float localNEDZ = 0.0;
    af86:	1d a2       	std	Y+37, r1	; 0x25
    af88:	1e a2       	std	Y+38, r1	; 0x26
    af8a:	1f a2       	std	Y+39, r1	; 0x27
    af8c:	18 a6       	std	Y+40, r1	; 0x28
	
	CoordinateUtil::ConvertFromECEFToLocalNED(model->InitialXPositionEcef(), model->InitialYPositionEcef(), model->InitialZPositionEcef(),
		model->XEcefCm(), model->YEcefCm(), model->ZEcefCm(), model->EcefToLocalNEDRotationMatrix,
		localNEDX, localNEDY, localNEDZ);
    af8e:	f4 01       	movw	r30, r8
    af90:	05 85       	ldd	r16, Z+13	; 0x0d
    af92:	16 85       	ldd	r17, Z+14	; 0x0e
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    af94:	f8 01       	movw	r30, r16
    af96:	e2 50       	subi	r30, 0x02	; 2
    af98:	ff 4f       	sbci	r31, 0xFF	; 255
    af9a:	a0 80       	ld	r10, Z
    af9c:	b1 80       	ldd	r11, Z+1	; 0x01
    af9e:	c2 80       	ldd	r12, Z+2	; 0x02
    afa0:	d3 80       	ldd	r13, Z+3	; 0x03
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
    afa2:	f8 01       	movw	r30, r16
    afa4:	ea 53       	subi	r30, 0x3A	; 58
    afa6:	ff 4f       	sbci	r31, 0xFF	; 255
    afa8:	60 81       	ld	r22, Z
    afaa:	71 81       	ldd	r23, Z+1	; 0x01
    afac:	82 81       	ldd	r24, Z+2	; 0x02
    afae:	93 81       	ldd	r25, Z+3	; 0x03
    afb0:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    afb4:	69 ab       	std	Y+49, r22	; 0x31
    afb6:	7a ab       	std	Y+50, r23	; 0x32
    afb8:	8b ab       	std	Y+51, r24	; 0x33
    afba:	9c ab       	std	Y+52, r25	; 0x34
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
    afbc:	f8 01       	movw	r30, r16
    afbe:	ee 53       	subi	r30, 0x3E	; 62
    afc0:	ff 4f       	sbci	r31, 0xFF	; 255
    afc2:	60 81       	ld	r22, Z
    afc4:	71 81       	ldd	r23, Z+1	; 0x01
    afc6:	82 81       	ldd	r24, Z+2	; 0x02
    afc8:	93 81       	ldd	r25, Z+3	; 0x03
    afca:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    afce:	2b 01       	movw	r4, r22
    afd0:	3c 01       	movw	r6, r24
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
    afd2:	f8 01       	movw	r30, r16
    afd4:	e2 54       	subi	r30, 0x42	; 66
    afd6:	ff 4f       	sbci	r31, 0xFF	; 255
    afd8:	60 81       	ld	r22, Z
    afda:	71 81       	ldd	r23, Z+1	; 0x01
    afdc:	82 81       	ldd	r24, Z+2	; 0x02
    afde:	93 81       	ldd	r25, Z+3	; 0x03
    afe0:	0e 94 bd 6b 	call	0xd77a	; 0xd77a <__fixsfsi>
    afe4:	9e 01       	movw	r18, r28
    afe6:	2b 5d       	subi	r18, 0xDB	; 219
    afe8:	3f 4f       	sbci	r19, 0xFF	; 255
    afea:	3f 93       	push	r19
    afec:	2f 93       	push	r18
    afee:	9e 01       	movw	r18, r28
    aff0:	27 5d       	subi	r18, 0xD7	; 215
    aff2:	3f 4f       	sbci	r19, 0xFF	; 255
    aff4:	3f 93       	push	r19
    aff6:	2f 93       	push	r18
    aff8:	9e 01       	movw	r18, r28
    affa:	23 5d       	subi	r18, 0xD3	; 211
    affc:	3f 4f       	sbci	r19, 0xFF	; 255
    affe:	3f 93       	push	r19
    b000:	2f 93       	push	r18
    b002:	98 01       	movw	r18, r16
    b004:	22 5e       	subi	r18, 0xE2	; 226
    b006:	3e 4f       	sbci	r19, 0xFE	; 254
    b008:	3f 93       	push	r19
    b00a:	2f 93       	push	r18
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    b00c:	f8 01       	movw	r30, r16
    b00e:	ea 5f       	subi	r30, 0xFA	; 250
    b010:	fe 4f       	sbci	r31, 0xFE	; 254
    b012:	23 81       	ldd	r18, Z+3	; 0x03
    b014:	2f 93       	push	r18
    b016:	22 81       	ldd	r18, Z+2	; 0x02
    b018:	2f 93       	push	r18
    b01a:	21 81       	ldd	r18, Z+1	; 0x01
    b01c:	2f 93       	push	r18
    b01e:	20 81       	ld	r18, Z
    b020:	2f 93       	push	r18
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    b022:	f8 01       	movw	r30, r16
    b024:	ee 5f       	subi	r30, 0xFE	; 254
    b026:	fe 4f       	sbci	r31, 0xFE	; 254
    b028:	23 81       	ldd	r18, Z+3	; 0x03
    b02a:	2f 93       	push	r18
    b02c:	22 81       	ldd	r18, Z+2	; 0x02
    b02e:	2f 93       	push	r18
    b030:	21 81       	ldd	r18, Z+1	; 0x01
    b032:	2f 93       	push	r18
    b034:	20 81       	ld	r18, Z
    b036:	2f 93       	push	r18
    b038:	e9 a8       	ldd	r14, Y+49	; 0x31
    b03a:	fa a8       	ldd	r15, Y+50	; 0x32
    b03c:	0b a9       	ldd	r16, Y+51	; 0x33
    b03e:	1c a9       	ldd	r17, Y+52	; 0x34
    b040:	a3 01       	movw	r20, r6
    b042:	92 01       	movw	r18, r4
    b044:	0e 94 4e 65 	call	0xca9c	; 0xca9c <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>
	
	model->XNEDLocalFrameCm(localNEDX);
    b048:	d4 01       	movw	r26, r8
    b04a:	1d 96       	adiw	r26, 0x0d	; 13
    b04c:	ed 91       	ld	r30, X+
    b04e:	fc 91       	ld	r31, X
    b050:	1e 97       	sbiw	r26, 0x0e	; 14
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
    b052:	8d a5       	ldd	r24, Y+45	; 0x2d
    b054:	9e a5       	ldd	r25, Y+46	; 0x2e
    b056:	af a5       	ldd	r26, Y+47	; 0x2f
    b058:	b8 a9       	ldd	r27, Y+48	; 0x30
    b05a:	82 a3       	std	Z+34, r24	; 0x22
    b05c:	93 a3       	std	Z+35, r25	; 0x23
    b05e:	a4 a3       	std	Z+36, r26	; 0x24
    b060:	b5 a3       	std	Z+37, r27	; 0x25
	model->YNEDLocalFrameCm(localNEDY);
    b062:	d4 01       	movw	r26, r8
    b064:	1d 96       	adiw	r26, 0x0d	; 13
    b066:	ed 91       	ld	r30, X+
    b068:	fc 91       	ld	r31, X
    b06a:	1e 97       	sbiw	r26, 0x0e	; 14
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}
    b06c:	e2 5b       	subi	r30, 0xB2	; 178
    b06e:	ff 4f       	sbci	r31, 0xFF	; 255
    b070:	89 a5       	ldd	r24, Y+41	; 0x29
    b072:	9a a5       	ldd	r25, Y+42	; 0x2a
    b074:	ab a5       	ldd	r26, Y+43	; 0x2b
    b076:	bc a5       	ldd	r27, Y+44	; 0x2c
    b078:	80 83       	st	Z, r24
    b07a:	91 83       	std	Z+1, r25	; 0x01
    b07c:	a2 83       	std	Z+2, r26	; 0x02
    b07e:	b3 83       	std	Z+3, r27	; 0x03
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    b080:	0f b6       	in	r0, 0x3f	; 63
    b082:	f8 94       	cli
    b084:	de bf       	out	0x3e, r29	; 62
    b086:	0f be       	out	0x3f, r0	; 63
    b088:	cd bf       	out	0x3d, r28	; 61
    b08a:	42 c0       	rjmp	.+132    	; 0xb110 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x3ae>
	
			//exponential smoothing. http://en.wikipedia.org/wiki/Exponential_smoothing
			//St = aX + (1-a)St-1
			float altitudeCmAglTemp = (float) (altitudeMslCm - model->InitialAltitudeCm());
			float previousAltitudeCmAgl = model->ZNEDLocalFrameCm();
			float currentAltitudeCmAgl = WEIGHT * (altitudeCmAglTemp) + (1 - WEIGHT)*previousAltitudeCmAgl;
    b08c:	2a e9       	ldi	r18, 0x9A	; 154
    b08e:	39 e9       	ldi	r19, 0x99	; 153
    b090:	49 e1       	ldi	r20, 0x19	; 25
    b092:	5e e3       	ldi	r21, 0x3E	; 62
    b094:	62 2d       	mov	r22, r2
    b096:	73 2d       	mov	r23, r3
    b098:	8e 2d       	mov	r24, r14
    b09a:	9f 2d       	mov	r25, r15
    b09c:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    b0a0:	6b 01       	movw	r12, r22
    b0a2:	7c 01       	movw	r14, r24
    b0a4:	2a e9       	ldi	r18, 0x9A	; 154
    b0a6:	39 e9       	ldi	r19, 0x99	; 153
    b0a8:	49 e5       	ldi	r20, 0x59	; 89
    b0aa:	5f e3       	ldi	r21, 0x3F	; 63
    b0ac:	c3 01       	movw	r24, r6
    b0ae:	b2 01       	movw	r22, r4
    b0b0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    b0b4:	9b 01       	movw	r18, r22
    b0b6:	ac 01       	movw	r20, r24
    b0b8:	c7 01       	movw	r24, r14
    b0ba:	b6 01       	movw	r22, r12
    b0bc:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    b0c0:	c6 2e       	mov	r12, r22
    b0c2:	d7 2e       	mov	r13, r23
    b0c4:	e8 2e       	mov	r14, r24
    b0c6:	f9 2e       	mov	r15, r25

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}
    b0c8:	02 57       	subi	r16, 0x72	; 114
    b0ca:	1f 4f       	sbci	r17, 0xFF	; 255
			//model->AltitudeMetersAgl(currentAltitudeMetersAgl);
	
			//Calculate altitude speed.
			//model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) * BAROMETER_SENSOR_READ_PERIOD));
			model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) / barometerSensorReadPeriod));
    b0cc:	a3 01       	movw	r20, r6
    b0ce:	92 01       	movw	r18, r4
    b0d0:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    b0d4:	d4 01       	movw	r26, r8
    b0d6:	17 96       	adiw	r26, 0x07	; 7
    b0d8:	2d 91       	ld	r18, X+
    b0da:	3d 91       	ld	r19, X+
    b0dc:	4d 91       	ld	r20, X+
    b0de:	5c 91       	ld	r21, X
    b0e0:	1a 97       	sbiw	r26, 0x0a	; 10
    b0e2:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    b0e6:	f8 01       	movw	r30, r16
    b0e8:	60 83       	st	Z, r22
    b0ea:	71 83       	std	Z+1, r23	; 0x01
    b0ec:	82 83       	std	Z+2, r24	; 0x02
    b0ee:	93 83       	std	Z+3, r25	; 0x03
	
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
    b0f0:	d4 01       	movw	r26, r8
    b0f2:	1d 96       	adiw	r26, 0x0d	; 13
    b0f4:	ed 91       	ld	r30, X+
    b0f6:	fc 91       	ld	r31, X
    b0f8:	1e 97       	sbiw	r26, 0x0e	; 14
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }
    b0fa:	e2 58       	subi	r30, 0x82	; 130
    b0fc:	ff 4f       	sbci	r31, 0xFF	; 255
    b0fe:	8c 2d       	mov	r24, r12
    b100:	9d 2d       	mov	r25, r13
    b102:	ae 2d       	mov	r26, r14
    b104:	bf 2d       	mov	r27, r15
    b106:	80 83       	st	Z, r24
    b108:	91 83       	std	Z+1, r25	; 0x01
    b10a:	a2 83       	std	Z+2, r26	; 0x02
    b10c:	b3 83       	std	Z+3, r27	; 0x03
    b10e:	2b cf       	rjmp	.-426    	; 0xaf66 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
	model->YNEDLocalFrameCm(localNEDY);
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    b110:	e4 96       	adiw	r28, 0x34	; 52
    b112:	0f b6       	in	r0, 0x3f	; 63
    b114:	f8 94       	cli
    b116:	de bf       	out	0x3e, r29	; 62
    b118:	0f be       	out	0x3f, r0	; 63
    b11a:	cd bf       	out	0x3d, r28	; 61
    b11c:	df 91       	pop	r29
    b11e:	cf 91       	pop	r28
    b120:	1f 91       	pop	r17
    b122:	0f 91       	pop	r16
    b124:	ff 90       	pop	r15
    b126:	ef 90       	pop	r14
    b128:	df 90       	pop	r13
    b12a:	cf 90       	pop	r12
    b12c:	bf 90       	pop	r11
    b12e:	af 90       	pop	r10
    b130:	9f 90       	pop	r9
    b132:	8f 90       	pop	r8
    b134:	7f 90       	pop	r7
    b136:	6f 90       	pop	r6
    b138:	5f 90       	pop	r5
    b13a:	4f 90       	pop	r4
    b13c:	3f 90       	pop	r3
    b13e:	2f 90       	pop	r2
    b140:	08 95       	ret

0000b142 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float PVNavigationTask::WEIGHT = .15;


PVNavigationTask::PVNavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    b142:	4f 92       	push	r4
    b144:	5f 92       	push	r5
    b146:	6f 92       	push	r6
    b148:	7f 92       	push	r7
    b14a:	af 92       	push	r10
    b14c:	bf 92       	push	r11
    b14e:	cf 92       	push	r12
    b150:	df 92       	push	r13
    b152:	ef 92       	push	r14
    b154:	ff 92       	push	r15
    b156:	0f 93       	push	r16
    b158:	1f 93       	push	r17
    b15a:	cf 93       	push	r28
    b15c:	df 93       	push	r29
    b15e:	ec 01       	movw	r28, r24
    b160:	2a 01       	movw	r4, r20
    b162:	3b 01       	movw	r6, r22
    b164:	59 01       	movw	r10, r18
    b166:	b7 01       	movw	r22, r14
    b168:	a6 01       	movw	r20, r12
Task(delay, period),
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model)
    b16a:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b16e:	84 e1       	ldi	r24, 0x14	; 20
    b170:	93 e0       	ldi	r25, 0x03	; 3
    b172:	99 83       	std	Y+1, r25	; 0x01
    b174:	88 83       	st	Y, r24
    b176:	4f 82       	std	Y+7, r4	; 0x07
    b178:	58 86       	std	Y+8, r5	; 0x08
    b17a:	69 86       	std	Y+9, r6	; 0x09
    b17c:	7a 86       	std	Y+10, r7	; 0x0a
    b17e:	bc 86       	std	Y+12, r11	; 0x0c
    b180:	ab 86       	std	Y+11, r10	; 0x0b
    b182:	1e 87       	std	Y+14, r17	; 0x0e
    b184:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    b186:	df 91       	pop	r29
    b188:	cf 91       	pop	r28
    b18a:	1f 91       	pop	r17
    b18c:	0f 91       	pop	r16
    b18e:	ff 90       	pop	r15
    b190:	ef 90       	pop	r14
    b192:	df 90       	pop	r13
    b194:	cf 90       	pop	r12
    b196:	bf 90       	pop	r11
    b198:	af 90       	pop	r10
    b19a:	7f 90       	pop	r7
    b19c:	6f 90       	pop	r6
    b19e:	5f 90       	pop	r5
    b1a0:	4f 90       	pop	r4
    b1a2:	08 95       	ret

0000b1a4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>:
    b1a4:	26 e7       	ldi	r18, 0x76	; 118
    b1a6:	33 e0       	ldi	r19, 0x03	; 3
    b1a8:	fc 01       	movw	r30, r24
    b1aa:	31 83       	std	Z+1, r19	; 0x01
    b1ac:	20 83       	st	Z, r18
    b1ae:	08 95       	ret

0000b1b0 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>:
    b1b0:	26 e7       	ldi	r18, 0x76	; 118
    b1b2:	33 e0       	ldi	r19, 0x03	; 3
    b1b4:	fc 01       	movw	r30, r24
    b1b6:	31 83       	std	Z+1, r19	; 0x01
    b1b8:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadBarometerSensorTask : public Task
    b1ba:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b1be:	08 95       	ret

0000b1c0 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>:
	
}


void ReadBarometerSensorTask::runTaskImpl()
{
    b1c0:	0f 93       	push	r16
    b1c2:	1f 93       	push	r17
    b1c4:	cf 93       	push	r28
    b1c6:	df 93       	push	r29
    b1c8:	ec 01       	movw	r28, r24
	//barometerSensor->readSensor();
	
	switch(step++)
    b1ca:	8b 85       	ldd	r24, Y+11	; 0x0b
    b1cc:	9c 85       	ldd	r25, Y+12	; 0x0c
    b1ce:	9c 01       	movw	r18, r24
    b1d0:	2f 5f       	subi	r18, 0xFF	; 255
    b1d2:	3f 4f       	sbci	r19, 0xFF	; 255
    b1d4:	3c 87       	std	Y+12, r19	; 0x0c
    b1d6:	2b 87       	std	Y+11, r18	; 0x0b
    b1d8:	81 30       	cpi	r24, 0x01	; 1
    b1da:	91 05       	cpc	r25, r1
    b1dc:	51 f0       	breq	.+20     	; 0xb1f2 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x32>
    b1de:	82 30       	cpi	r24, 0x02	; 2
    b1e0:	91 05       	cpc	r25, r1
    b1e2:	81 f0       	breq	.+32     	; 0xb204 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x44>
    b1e4:	89 2b       	or	r24, r25
    b1e6:	d1 f5       	brne	.+116    	; 0xb25c <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x9c>
	{
		
		case 0:
			barometerSensor->sendD1Command();
    b1e8:	89 85       	ldd	r24, Y+9	; 0x09
    b1ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1ec:	0e 94 56 44 	call	0x88ac	; 0x88ac <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>
		break;
    b1f0:	37 c0       	rjmp	.+110    	; 0xb260 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 1:
			barometerSensor->readD1Data();
    b1f2:	89 85       	ldd	r24, Y+9	; 0x09
    b1f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1f6:	0e 94 5d 44 	call	0x88ba	; 0x88ba <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>
			barometerSensor->sendD2Command();
    b1fa:	89 85       	ldd	r24, Y+9	; 0x09
    b1fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1fe:	0e 94 9e 44 	call	0x893c	; 0x893c <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>
		break;
    b202:	2e c0       	rjmp	.+92     	; 0xb260 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 2:
			barometerSensor->readD2Data();
    b204:	89 85       	ldd	r24, Y+9	; 0x09
    b206:	9a 85       	ldd	r25, Y+10	; 0x0a
    b208:	0e 94 a5 44 	call	0x894a	; 0x894a <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>
			barometerSensor->processBaroData();
    b20c:	89 85       	ldd	r24, Y+9	; 0x09
    b20e:	9a 85       	ldd	r25, Y+10	; 0x0a
    b210:	0e 94 e6 44 	call	0x89cc	; 0x89cc <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>
			
			if (model->SensorInput() == SystemModel::RealSensors)
    b214:	ef 81       	ldd	r30, Y+7	; 0x07
    b216:	f8 85       	ldd	r31, Y+8	; 0x08
    b218:	84 81       	ldd	r24, Z+4	; 0x04
    b21a:	81 30       	cpi	r24, 0x01	; 1
    b21c:	e1 f4       	brne	.+56     	; 0xb256 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x96>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    b21e:	8f 01       	movw	r16, r30
    b220:	0a 5e       	subi	r16, 0xEA	; 234
    b222:	1e 4f       	sbci	r17, 0xFE	; 254
					return temperatureCelcius;
				}
				
				long getPressureMillibars()
				{
					return pressureMillibars;
    b224:	e9 85       	ldd	r30, Y+9	; 0x09
    b226:	fa 85       	ldd	r31, Y+10	; 0x0a
			{
				model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
    b228:	66 85       	ldd	r22, Z+14	; 0x0e
    b22a:	77 85       	ldd	r23, Z+15	; 0x0f
    b22c:	80 89       	ldd	r24, Z+16	; 0x10
    b22e:	91 89       	ldd	r25, Z+17	; 0x11
    b230:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    b234:	20 e0       	ldi	r18, 0x00	; 0
    b236:	30 e0       	ldi	r19, 0x00	; 0
    b238:	48 ec       	ldi	r20, 0xC8	; 200
    b23a:	52 e4       	ldi	r21, 0x42	; 66
    b23c:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    b240:	f8 01       	movw	r30, r16
    b242:	60 83       	st	Z, r22
    b244:	71 83       	std	Z+1, r23	; 0x01
    b246:	82 83       	std	Z+2, r24	; 0x02
    b248:	93 83       	std	Z+3, r25	; 0x03
				model->HasNewPressureReading = true;
    b24a:	ef 81       	ldd	r30, Y+7	; 0x07
    b24c:	f8 85       	ldd	r31, Y+8	; 0x08
    b24e:	ee 5b       	subi	r30, 0xBE	; 190
    b250:	fe 4f       	sbci	r31, 0xFE	; 254
    b252:	81 e0       	ldi	r24, 0x01	; 1
    b254:	80 83       	st	Z, r24
			}
			
			
			step = 0;
    b256:	1c 86       	std	Y+12, r1	; 0x0c
    b258:	1b 86       	std	Y+11, r1	; 0x0b
		break;
    b25a:	02 c0       	rjmp	.+4      	; 0xb260 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		default:
			step = 0;
    b25c:	1c 86       	std	Y+12, r1	; 0x0c
    b25e:	1b 86       	std	Y+11, r1	; 0x0b
		*/
	}
	
	
	//model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
}
    b260:	df 91       	pop	r29
    b262:	cf 91       	pop	r28
    b264:	1f 91       	pop	r17
    b266:	0f 91       	pop	r16
    b268:	08 95       	ret

0000b26a <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>:
 */ 
#include "ReadBarometerSensorTask.h"

using namespace helicopter::tasks;

ReadBarometerSensorTask::ReadBarometerSensorTask (SystemModel *model, BarometerSensor *barometerSensor, int delay, int period) :
    b26a:	cf 92       	push	r12
    b26c:	df 92       	push	r13
    b26e:	ef 92       	push	r14
    b270:	ff 92       	push	r15
    b272:	0f 93       	push	r16
    b274:	1f 93       	push	r17
    b276:	cf 93       	push	r28
    b278:	df 93       	push	r29
    b27a:	ec 01       	movw	r28, r24
    b27c:	6b 01       	movw	r12, r22
    b27e:	7a 01       	movw	r14, r20
    b280:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
barometerSensor(barometerSensor),
step(0)
    b282:	b9 01       	movw	r22, r18
    b284:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b288:	82 e2       	ldi	r24, 0x22	; 34
    b28a:	93 e0       	ldi	r25, 0x03	; 3
    b28c:	99 83       	std	Y+1, r25	; 0x01
    b28e:	88 83       	st	Y, r24
    b290:	d8 86       	std	Y+8, r13	; 0x08
    b292:	cf 82       	std	Y+7, r12	; 0x07
    b294:	fa 86       	std	Y+10, r15	; 0x0a
    b296:	e9 86       	std	Y+9, r14	; 0x09
    b298:	1c 86       	std	Y+12, r1	; 0x0c
    b29a:	1b 86       	std	Y+11, r1	; 0x0b
{
	
}
    b29c:	df 91       	pop	r29
    b29e:	cf 91       	pop	r28
    b2a0:	1f 91       	pop	r17
    b2a2:	0f 91       	pop	r16
    b2a4:	ff 90       	pop	r15
    b2a6:	ef 90       	pop	r14
    b2a8:	df 90       	pop	r13
    b2aa:	cf 90       	pop	r12
    b2ac:	08 95       	ret

0000b2ae <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>:
    b2ae:	26 e7       	ldi	r18, 0x76	; 118
    b2b0:	33 e0       	ldi	r19, 0x03	; 3
    b2b2:	fc 01       	movw	r30, r24
    b2b4:	31 83       	std	Z+1, r19	; 0x01
    b2b6:	20 83       	st	Z, r18
    b2b8:	08 95       	ret

0000b2ba <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>:
    b2ba:	26 e7       	ldi	r18, 0x76	; 118
    b2bc:	33 e0       	ldi	r19, 0x03	; 3
    b2be:	fc 01       	movw	r30, r24
    b2c0:	31 83       	std	Z+1, r19	; 0x01
    b2c2:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadGPSSensorTask : public Task
    b2c4:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b2c8:	08 95       	ret

0000b2ca <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>:
	
}


void ReadGPSSensorTask::runTaskImpl()
{
    b2ca:	cf 93       	push	r28
    b2cc:	df 93       	push	r29
    b2ce:	ec 01       	movw	r28, r24
	
	int status = gpsSensor->processSensorSolution();
    b2d0:	89 85       	ldd	r24, Y+9	; 0x09
    b2d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    b2d4:	0e 94 5a 49 	call	0x92b4	; 0x92b4 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b2d8:	ef 81       	ldd	r30, Y+7	; 0x07
    b2da:	f8 85       	ldd	r31, Y+8	; 0x08
    b2dc:	24 81       	ldd	r18, Z+4	; 0x04
    b2de:	21 30       	cpi	r18, 0x01	; 1
    b2e0:	09 f0       	breq	.+2      	; 0xb2e4 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0x1a>
    b2e2:	65 c0       	rjmp	.+202    	; 0xb3ae <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
					return longitudeDegE7;
				}			
					
				long getXEcefCm()
				{
					return xEcefCm;
    b2e4:	a9 85       	ldd	r26, Y+9	; 0x09
    b2e6:	ba 85       	ldd	r27, Y+10	; 0x0a
    b2e8:	1a 96       	adiw	r26, 0x0a	; 10
    b2ea:	4d 91       	ld	r20, X+
    b2ec:	5d 91       	ld	r21, X+
    b2ee:	6d 91       	ld	r22, X+
    b2f0:	7c 91       	ld	r23, X
    b2f2:	1d 97       	sbiw	r26, 0x0d	; 13
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    b2f4:	e2 50       	subi	r30, 0x02	; 2
    b2f6:	ff 4f       	sbci	r31, 0xFF	; 255
    b2f8:	40 83       	st	Z, r20
    b2fa:	51 83       	std	Z+1, r21	; 0x01
    b2fc:	62 83       	std	Z+2, r22	; 0x02
    b2fe:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYEcefCm()
				{
					return yEcefCm;
    b300:	e9 85       	ldd	r30, Y+9	; 0x09
    b302:	fa 85       	ldd	r31, Y+10	; 0x0a
    b304:	46 85       	ldd	r20, Z+14	; 0x0e
    b306:	57 85       	ldd	r21, Z+15	; 0x0f
    b308:	60 89       	ldd	r22, Z+16	; 0x10
    b30a:	71 89       	ldd	r23, Z+17	; 0x11
	{
		model->XEcefCm(gpsSensor->getXEcefCm());
		model->YEcefCm(gpsSensor->getYEcefCm());
    b30c:	ef 81       	ldd	r30, Y+7	; 0x07
    b30e:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    b310:	ee 5f       	subi	r30, 0xFE	; 254
    b312:	fe 4f       	sbci	r31, 0xFE	; 254
    b314:	40 83       	st	Z, r20
    b316:	51 83       	std	Z+1, r21	; 0x01
    b318:	62 83       	std	Z+2, r22	; 0x02
    b31a:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZEcefCm()
				{
					return zEcefCm;
    b31c:	e9 85       	ldd	r30, Y+9	; 0x09
    b31e:	fa 85       	ldd	r31, Y+10	; 0x0a
    b320:	42 89       	ldd	r20, Z+18	; 0x12
    b322:	53 89       	ldd	r21, Z+19	; 0x13
    b324:	64 89       	ldd	r22, Z+20	; 0x14
    b326:	75 89       	ldd	r23, Z+21	; 0x15
		model->ZEcefCm(gpsSensor->getZEcefCm());
    b328:	ef 81       	ldd	r30, Y+7	; 0x07
    b32a:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    b32c:	ea 5f       	subi	r30, 0xFA	; 250
    b32e:	fe 4f       	sbci	r31, 0xFE	; 254
    b330:	40 83       	st	Z, r20
    b332:	51 83       	std	Z+1, r21	; 0x01
    b334:	62 83       	std	Z+2, r22	; 0x02
    b336:	73 83       	std	Z+3, r23	; 0x03
				
				
				
				long getXVEcefCms()
				{
					return xVEcefCms;
    b338:	e9 85       	ldd	r30, Y+9	; 0x09
    b33a:	fa 85       	ldd	r31, Y+10	; 0x0a
    b33c:	42 8d       	ldd	r20, Z+26	; 0x1a
    b33e:	53 8d       	ldd	r21, Z+27	; 0x1b
    b340:	64 8d       	ldd	r22, Z+28	; 0x1c
    b342:	75 8d       	ldd	r23, Z+29	; 0x1d
		
		model->XVEcefCms(gpsSensor->getXVEcefCms());
    b344:	ef 81       	ldd	r30, Y+7	; 0x07
    b346:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    b348:	e6 5f       	subi	r30, 0xF6	; 246
    b34a:	fe 4f       	sbci	r31, 0xFE	; 254
    b34c:	40 83       	st	Z, r20
    b34e:	51 83       	std	Z+1, r21	; 0x01
    b350:	62 83       	std	Z+2, r22	; 0x02
    b352:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYVEcefCms()
				{
					return yVEcefCms;
    b354:	e9 85       	ldd	r30, Y+9	; 0x09
    b356:	fa 85       	ldd	r31, Y+10	; 0x0a
    b358:	46 8d       	ldd	r20, Z+30	; 0x1e
    b35a:	57 8d       	ldd	r21, Z+31	; 0x1f
    b35c:	60 a1       	ldd	r22, Z+32	; 0x20
    b35e:	71 a1       	ldd	r23, Z+33	; 0x21
		model->YVEcefCms(gpsSensor->getYVEcefCms());
    b360:	ef 81       	ldd	r30, Y+7	; 0x07
    b362:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    b364:	e2 5f       	subi	r30, 0xF2	; 242
    b366:	fe 4f       	sbci	r31, 0xFE	; 254
    b368:	40 83       	st	Z, r20
    b36a:	51 83       	std	Z+1, r21	; 0x01
    b36c:	62 83       	std	Z+2, r22	; 0x02
    b36e:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZVEcefCms()
				{
					return zVEcefCms;
    b370:	e9 85       	ldd	r30, Y+9	; 0x09
    b372:	fa 85       	ldd	r31, Y+10	; 0x0a
    b374:	42 a1       	ldd	r20, Z+34	; 0x22
    b376:	53 a1       	ldd	r21, Z+35	; 0x23
    b378:	64 a1       	ldd	r22, Z+36	; 0x24
    b37a:	75 a1       	ldd	r23, Z+37	; 0x25
		model->ZVEcefCms(gpsSensor->getZVEcefCms());
    b37c:	ef 81       	ldd	r30, Y+7	; 0x07
    b37e:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    b380:	ee 5e       	subi	r30, 0xEE	; 238
    b382:	fe 4f       	sbci	r31, 0xFE	; 254
    b384:	40 83       	st	Z, r20
    b386:	51 83       	std	Z+1, r21	; 0x01
    b388:	62 83       	std	Z+2, r22	; 0x02
    b38a:	73 83       	std	Z+3, r23	; 0x03
		
		if (status == -1)
    b38c:	01 96       	adiw	r24, 0x01	; 1
    b38e:	79 f4       	brne	.+30     	; 0xb3ae <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
		{
			model->ChecksumErrors(model->ChecksumErrors() + 1);
    b390:	ef 81       	ldd	r30, Y+7	; 0x07
    b392:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    b394:	ee 54       	subi	r30, 0x4E	; 78
    b396:	ff 4f       	sbci	r31, 0xFF	; 255
    b398:	80 81       	ld	r24, Z
    b39a:	91 81       	ldd	r25, Z+1	; 0x01
    b39c:	a2 81       	ldd	r26, Z+2	; 0x02
    b39e:	b3 81       	ldd	r27, Z+3	; 0x03
    b3a0:	01 96       	adiw	r24, 0x01	; 1
    b3a2:	a1 1d       	adc	r26, r1
    b3a4:	b1 1d       	adc	r27, r1
    b3a6:	80 83       	st	Z, r24
    b3a8:	91 83       	std	Z+1, r25	; 0x01
    b3aa:	a2 83       	std	Z+2, r26	; 0x02
    b3ac:	b3 83       	std	Z+3, r27	; 0x03
	model->XVEcefCms(gpsSensor->getXVEcefCms());
	model->YVEcefCms(gpsSensor->getYVEcefCms());
	model->ZVEcefCms(gpsSensor->getZVEcefCms());
	*/
	
}
    b3ae:	df 91       	pop	r29
    b3b0:	cf 91       	pop	r28
    b3b2:	08 95       	ret

0000b3b4 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>:
 */ 
#include "ReadGPSSensorTask.h"

using namespace helicopter::tasks;

ReadGPSSensorTask::ReadGPSSensorTask (SystemModel *model, GPSSensor *gpsSensor, int delay, int period) :
    b3b4:	cf 92       	push	r12
    b3b6:	df 92       	push	r13
    b3b8:	ef 92       	push	r14
    b3ba:	ff 92       	push	r15
    b3bc:	0f 93       	push	r16
    b3be:	1f 93       	push	r17
    b3c0:	cf 93       	push	r28
    b3c2:	df 93       	push	r29
    b3c4:	ec 01       	movw	r28, r24
    b3c6:	6b 01       	movw	r12, r22
    b3c8:	7a 01       	movw	r14, r20
    b3ca:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
gpsSensor(gpsSensor),
sendReadCommand(true)
    b3cc:	b9 01       	movw	r22, r18
    b3ce:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b3d2:	80 e3       	ldi	r24, 0x30	; 48
    b3d4:	93 e0       	ldi	r25, 0x03	; 3
    b3d6:	99 83       	std	Y+1, r25	; 0x01
    b3d8:	88 83       	st	Y, r24
    b3da:	d8 86       	std	Y+8, r13	; 0x08
    b3dc:	cf 82       	std	Y+7, r12	; 0x07
    b3de:	fa 86       	std	Y+10, r15	; 0x0a
    b3e0:	e9 86       	std	Y+9, r14	; 0x09
    b3e2:	81 e0       	ldi	r24, 0x01	; 1
    b3e4:	8b 87       	std	Y+11, r24	; 0x0b
{
	
}
    b3e6:	df 91       	pop	r29
    b3e8:	cf 91       	pop	r28
    b3ea:	1f 91       	pop	r17
    b3ec:	0f 91       	pop	r16
    b3ee:	ff 90       	pop	r15
    b3f0:	ef 90       	pop	r14
    b3f2:	df 90       	pop	r13
    b3f4:	cf 90       	pop	r12
    b3f6:	08 95       	ret

0000b3f8 <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>:
    b3f8:	26 e7       	ldi	r18, 0x76	; 118
    b3fa:	33 e0       	ldi	r19, 0x03	; 3
    b3fc:	fc 01       	movw	r30, r24
    b3fe:	31 83       	std	Z+1, r19	; 0x01
    b400:	20 83       	st	Z, r18
    b402:	08 95       	ret

0000b404 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>:
    b404:	26 e7       	ldi	r18, 0x76	; 118
    b406:	33 e0       	ldi	r19, 0x03	; 3
    b408:	fc 01       	movw	r30, r24
    b40a:	31 83       	std	Z+1, r19	; 0x01
    b40c:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadIMUSensorTask : public Task
    b40e:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b412:	08 95       	ret

0000b414 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>:
	
}


void ReadIMUSensorTask::runTaskImpl()
{
    b414:	cf 93       	push	r28
    b416:	df 93       	push	r29
    b418:	ec 01       	movw	r28, r24
	//Read the sensor values from the IMU Sensor.
	imuSensor->readSensor();
    b41a:	89 85       	ldd	r24, Y+9	; 0x09
    b41c:	9a 85       	ldd	r25, Y+10	; 0x0a
    b41e:	0e 94 bc 4c 	call	0x9978	; 0x9978 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b422:	ef 81       	ldd	r30, Y+7	; 0x07
    b424:	f8 85       	ldd	r31, Y+8	; 0x08
    b426:	84 81       	ldd	r24, Z+4	; 0x04
    b428:	81 30       	cpi	r24, 0x01	; 1
    b42a:	09 f0       	breq	.+2      	; 0xb42e <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0x1a>
    b42c:	59 c0       	rjmp	.+178    	; 0xb4e0 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0xcc>
				int getRawGyroZ() { return rawGyroZ;}					
				
				/**
				 * Returns the acceleration in meters per second per second in the X direction in Front (X) Right (Y) Down (Z) coordinate system
				 */
				float getFRDAccXMss() { return frdAccXMss;}
    b42e:	a9 85       	ldd	r26, Y+9	; 0x09
    b430:	ba 85       	ldd	r27, Y+10	; 0x0a
    b432:	d2 96       	adiw	r26, 0x32	; 50
    b434:	8d 91       	ld	r24, X+
    b436:	9d 91       	ld	r25, X+
    b438:	0d 90       	ld	r0, X+
    b43a:	bc 91       	ld	r27, X
    b43c:	a0 2d       	mov	r26, r0
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    b43e:	ea 51       	subi	r30, 0x1A	; 26
    b440:	ff 4f       	sbci	r31, 0xFF	; 255
    b442:	80 83       	st	Z, r24
    b444:	91 83       	std	Z+1, r25	; 0x01
    b446:	a2 83       	std	Z+2, r26	; 0x02
    b448:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Y direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccYMss() { return frdAccYMss;}
    b44a:	e9 85       	ldd	r30, Y+9	; 0x09
    b44c:	fa 85       	ldd	r31, Y+10	; 0x0a
    b44e:	86 a9       	ldd	r24, Z+54	; 0x36
    b450:	97 a9       	ldd	r25, Z+55	; 0x37
    b452:	a0 ad       	ldd	r26, Z+56	; 0x38
    b454:	b1 ad       	ldd	r27, Z+57	; 0x39
	{
		model->XAccelFrdMss(imuSensor->getFRDAccXMss());
		model->YAccelFrdMss(imuSensor->getFRDAccYMss());
    b456:	ef 81       	ldd	r30, Y+7	; 0x07
    b458:	f8 85       	ldd	r31, Y+8	; 0x08

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    b45a:	e6 51       	subi	r30, 0x16	; 22
    b45c:	ff 4f       	sbci	r31, 0xFF	; 255
    b45e:	80 83       	st	Z, r24
    b460:	91 83       	std	Z+1, r25	; 0x01
    b462:	a2 83       	std	Z+2, r26	; 0x02
    b464:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Z direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccZMss() { return frdAccZMss;}
    b466:	e9 85       	ldd	r30, Y+9	; 0x09
    b468:	fa 85       	ldd	r31, Y+10	; 0x0a
    b46a:	82 ad       	ldd	r24, Z+58	; 0x3a
    b46c:	93 ad       	ldd	r25, Z+59	; 0x3b
    b46e:	a4 ad       	ldd	r26, Z+60	; 0x3c
    b470:	b5 ad       	ldd	r27, Z+61	; 0x3d
		model->ZAccelFrdMss(imuSensor->getFRDAccZMss());
    b472:	ef 81       	ldd	r30, Y+7	; 0x07
    b474:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    b476:	e2 51       	subi	r30, 0x12	; 18
    b478:	ff 4f       	sbci	r31, 0xFF	; 255
    b47a:	80 83       	st	Z, r24
    b47c:	91 83       	std	Z+1, r25	; 0x01
    b47e:	a2 83       	std	Z+2, r26	; 0x02
    b480:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the X axis in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDGyroXRs() { return frdGyroXRs;}
    b482:	e9 85       	ldd	r30, Y+9	; 0x09
    b484:	fa 85       	ldd	r31, Y+10	; 0x0a
    b486:	fe 96       	adiw	r30, 0x3e	; 62
    b488:	80 81       	ld	r24, Z
    b48a:	91 81       	ldd	r25, Z+1	; 0x01
    b48c:	a2 81       	ldd	r26, Z+2	; 0x02
    b48e:	b3 81       	ldd	r27, Z+3	; 0x03
		
		model->RollAngularVelocityRadsPerSecond(imuSensor->getFRDGyroXRs());
    b490:	ef 81       	ldd	r30, Y+7	; 0x07
    b492:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    b494:	e2 52       	subi	r30, 0x22	; 34
    b496:	ff 4f       	sbci	r31, 0xFF	; 255
    b498:	80 83       	st	Z, r24
    b49a:	91 83       	std	Z+1, r25	; 0x01
    b49c:	a2 83       	std	Z+2, r26	; 0x02
    b49e:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Y axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroYRs() { return frdGyroYRs;}
    b4a0:	e9 85       	ldd	r30, Y+9	; 0x09
    b4a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    b4a4:	ee 5b       	subi	r30, 0xBE	; 190
    b4a6:	ff 4f       	sbci	r31, 0xFF	; 255
    b4a8:	40 81       	ld	r20, Z
    b4aa:	51 81       	ldd	r21, Z+1	; 0x01
    b4ac:	62 81       	ldd	r22, Z+2	; 0x02
    b4ae:	73 81       	ldd	r23, Z+3	; 0x03
		model->PitchAngularVelocityRadsPerSecond(imuSensor->getFRDGyroYRs());
    b4b0:	ef 81       	ldd	r30, Y+7	; 0x07
    b4b2:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    b4b4:	e6 52       	subi	r30, 0x26	; 38
    b4b6:	ff 4f       	sbci	r31, 0xFF	; 255
    b4b8:	40 83       	st	Z, r20
    b4ba:	51 83       	std	Z+1, r21	; 0x01
    b4bc:	62 83       	std	Z+2, r22	; 0x02
    b4be:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Z axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroZRs() { return frdGyroZRs;}	
    b4c0:	e9 85       	ldd	r30, Y+9	; 0x09
    b4c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    b4c4:	ea 5b       	subi	r30, 0xBA	; 186
    b4c6:	ff 4f       	sbci	r31, 0xFF	; 255
    b4c8:	40 81       	ld	r20, Z
    b4ca:	51 81       	ldd	r21, Z+1	; 0x01
    b4cc:	62 81       	ldd	r22, Z+2	; 0x02
    b4ce:	73 81       	ldd	r23, Z+3	; 0x03
		model->YawAngularVelocityRadsPerSecond(imuSensor->getFRDGyroZRs());		
    b4d0:	ef 81       	ldd	r30, Y+7	; 0x07
    b4d2:	f8 85       	ldd	r31, Y+8	; 0x08
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    b4d4:	ee 51       	subi	r30, 0x1E	; 30
    b4d6:	ff 4f       	sbci	r31, 0xFF	; 255
    b4d8:	40 83       	st	Z, r20
    b4da:	51 83       	std	Z+1, r21	; 0x01
    b4dc:	62 83       	std	Z+2, r22	; 0x02
    b4de:	73 83       	std	Z+3, r23	; 0x03
				
	}
}
    b4e0:	df 91       	pop	r29
    b4e2:	cf 91       	pop	r28
    b4e4:	08 95       	ret

0000b4e6 <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>:
#include "ReadIMUSensorTask.h"

using namespace helicopter::tasks;

ReadIMUSensorTask::ReadIMUSensorTask (SystemModel *model, IMUSensor *imuSensor, int delay, int period) :
    b4e6:	cf 92       	push	r12
    b4e8:	df 92       	push	r13
    b4ea:	ef 92       	push	r14
    b4ec:	ff 92       	push	r15
    b4ee:	0f 93       	push	r16
    b4f0:	1f 93       	push	r17
    b4f2:	cf 93       	push	r28
    b4f4:	df 93       	push	r29
    b4f6:	ec 01       	movw	r28, r24
    b4f8:	6b 01       	movw	r12, r22
    b4fa:	7a 01       	movw	r14, r20
    b4fc:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
imuSensor(imuSensor)
    b4fe:	b9 01       	movw	r22, r18
    b500:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b504:	8e e3       	ldi	r24, 0x3E	; 62
    b506:	93 e0       	ldi	r25, 0x03	; 3
    b508:	99 83       	std	Y+1, r25	; 0x01
    b50a:	88 83       	st	Y, r24
    b50c:	d8 86       	std	Y+8, r13	; 0x08
    b50e:	cf 82       	std	Y+7, r12	; 0x07
    b510:	fa 86       	std	Y+10, r15	; 0x0a
    b512:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b514:	df 91       	pop	r29
    b516:	cf 91       	pop	r28
    b518:	1f 91       	pop	r17
    b51a:	0f 91       	pop	r16
    b51c:	ff 90       	pop	r15
    b51e:	ef 90       	pop	r14
    b520:	df 90       	pop	r13
    b522:	cf 90       	pop	r12
    b524:	08 95       	ret

0000b526 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>:
    b526:	26 e7       	ldi	r18, 0x76	; 118
    b528:	33 e0       	ldi	r19, 0x03	; 3
    b52a:	fc 01       	movw	r30, r24
    b52c:	31 83       	std	Z+1, r19	; 0x01
    b52e:	20 83       	st	Z, r18
    b530:	08 95       	ret

0000b532 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>:
    b532:	26 e7       	ldi	r18, 0x76	; 118
    b534:	33 e0       	ldi	r19, 0x03	; 3
    b536:	fc 01       	movw	r30, r24
    b538:	31 83       	std	Z+1, r19	; 0x01
    b53a:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadMagnetometerSensorTask : public Task
    b53c:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b540:	08 95       	ret

0000b542 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>:
	
}


void ReadMagnetometerSensorTask::runTaskImpl()
{
    b542:	cf 93       	push	r28
    b544:	df 93       	push	r29
    b546:	ec 01       	movw	r28, r24


	if (magnetometerSensor->readSensor() != 0)
    b548:	89 85       	ldd	r24, Y+9	; 0x09
    b54a:	9a 85       	ldd	r25, Y+10	; 0x0a
    b54c:	0e 94 9c 50 	call	0xa138	; 0xa138 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    b550:	89 2b       	or	r24, r25
    b552:	81 f0       	breq	.+32     	; 0xb574 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x32>
	{
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    b554:	ef 81       	ldd	r30, Y+7	; 0x07
    b556:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    b558:	ee 54       	subi	r30, 0x4E	; 78
    b55a:	ff 4f       	sbci	r31, 0xFF	; 255
    b55c:	80 81       	ld	r24, Z
    b55e:	91 81       	ldd	r25, Z+1	; 0x01
    b560:	a2 81       	ldd	r26, Z+2	; 0x02
    b562:	b3 81       	ldd	r27, Z+3	; 0x03
    b564:	01 96       	adiw	r24, 0x01	; 1
    b566:	a1 1d       	adc	r26, r1
    b568:	b1 1d       	adc	r27, r1
    b56a:	80 83       	st	Z, r24
    b56c:	91 83       	std	Z+1, r25	; 0x01
    b56e:	a2 83       	std	Z+2, r26	; 0x02
    b570:	b3 83       	std	Z+3, r27	; 0x03
    b572:	2f c0       	rjmp	.+94     	; 0xb5d2 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
		return;
	}
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b574:	ef 81       	ldd	r30, Y+7	; 0x07
    b576:	f8 85       	ldd	r31, Y+8	; 0x08
    b578:	84 81       	ldd	r24, Z+4	; 0x04
    b57a:	81 30       	cpi	r24, 0x01	; 1
    b57c:	51 f5       	brne	.+84     	; 0xb5d2 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
				 * Retrieves the X sensor reading converted so that
				 * it points out the front of the CPU
				 */				
				float getFRDX()
				{
					return frdMagX;
    b57e:	a9 85       	ldd	r26, Y+9	; 0x09
    b580:	ba 85       	ldd	r27, Y+10	; 0x0a
    b582:	16 96       	adiw	r26, 0x06	; 6
    b584:	8d 91       	ld	r24, X+
    b586:	9d 91       	ld	r25, X+
    b588:	0d 90       	ld	r0, X+
    b58a:	bc 91       	ld	r27, X
    b58c:	a0 2d       	mov	r26, r0
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    b58e:	ee 50       	subi	r30, 0x0E	; 14
    b590:	ff 4f       	sbci	r31, 0xFF	; 255
    b592:	80 83       	st	Z, r24
    b594:	91 83       	std	Z+1, r25	; 0x01
    b596:	a2 83       	std	Z+2, r26	; 0x02
    b598:	b3 83       	std	Z+3, r27	; 0x03
				 * Retrieves the Y sensor reading converted so that
				 * it points out the right of the CPU
				 */	
				float getFRDY()
				{
					return frdMagY;
    b59a:	e9 85       	ldd	r30, Y+9	; 0x09
    b59c:	fa 85       	ldd	r31, Y+10	; 0x0a
    b59e:	82 85       	ldd	r24, Z+10	; 0x0a
    b5a0:	93 85       	ldd	r25, Z+11	; 0x0b
    b5a2:	a4 85       	ldd	r26, Z+12	; 0x0c
    b5a4:	b5 85       	ldd	r27, Z+13	; 0x0d
	{
		model->XMagFrd(magnetometerSensor->getFRDX());
		model->YMagFrd(magnetometerSensor->getFRDY());
    b5a6:	ef 81       	ldd	r30, Y+7	; 0x07
    b5a8:	f8 85       	ldd	r31, Y+8	; 0x08

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    b5aa:	ea 50       	subi	r30, 0x0A	; 10
    b5ac:	ff 4f       	sbci	r31, 0xFF	; 255
    b5ae:	80 83       	st	Z, r24
    b5b0:	91 83       	std	Z+1, r25	; 0x01
    b5b2:	a2 83       	std	Z+2, r26	; 0x02
    b5b4:	b3 83       	std	Z+3, r27	; 0x03
				 * Retrieves the Z sensor reading converted so that
				 * it points down out of the CPU
				 */					
				float getFRDZ()
				{
					return frdMagZ;
    b5b6:	e9 85       	ldd	r30, Y+9	; 0x09
    b5b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    b5ba:	46 85       	ldd	r20, Z+14	; 0x0e
    b5bc:	57 85       	ldd	r21, Z+15	; 0x0f
    b5be:	60 89       	ldd	r22, Z+16	; 0x10
    b5c0:	71 89       	ldd	r23, Z+17	; 0x11
		model->ZMagFrd(magnetometerSensor->getFRDZ());
    b5c2:	ef 81       	ldd	r30, Y+7	; 0x07
    b5c4:	f8 85       	ldd	r31, Y+8	; 0x08

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    b5c6:	e6 50       	subi	r30, 0x06	; 6
    b5c8:	ff 4f       	sbci	r31, 0xFF	; 255
    b5ca:	40 83       	st	Z, r20
    b5cc:	51 83       	std	Z+1, r21	; 0x01
    b5ce:	62 83       	std	Z+2, r22	; 0x02
    b5d0:	73 83       	std	Z+3, r23	; 0x03
model->off3(magnetometerSensor->debug[2]);
*/

	}
	
}
    b5d2:	df 91       	pop	r29
    b5d4:	cf 91       	pop	r28
    b5d6:	08 95       	ret

0000b5d8 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>:
#include "ReadMagnetometerSensorTask.h"
#include <avr/io.h>

using namespace helicopter::tasks;

ReadMagnetometerSensorTask::ReadMagnetometerSensorTask (SystemModel *model, MagnetometerSensor *magnetometerSensor, int delay, int period) :
    b5d8:	cf 92       	push	r12
    b5da:	df 92       	push	r13
    b5dc:	ef 92       	push	r14
    b5de:	ff 92       	push	r15
    b5e0:	0f 93       	push	r16
    b5e2:	1f 93       	push	r17
    b5e4:	cf 93       	push	r28
    b5e6:	df 93       	push	r29
    b5e8:	ec 01       	movw	r28, r24
    b5ea:	6b 01       	movw	r12, r22
    b5ec:	7a 01       	movw	r14, r20
    b5ee:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
magnetometerSensor(magnetometerSensor)
    b5f0:	b9 01       	movw	r22, r18
    b5f2:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b5f6:	8c e4       	ldi	r24, 0x4C	; 76
    b5f8:	93 e0       	ldi	r25, 0x03	; 3
    b5fa:	99 83       	std	Y+1, r25	; 0x01
    b5fc:	88 83       	st	Y, r24
    b5fe:	d8 86       	std	Y+8, r13	; 0x08
    b600:	cf 82       	std	Y+7, r12	; 0x07
    b602:	fa 86       	std	Y+10, r15	; 0x0a
    b604:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b606:	df 91       	pop	r29
    b608:	cf 91       	pop	r28
    b60a:	1f 91       	pop	r17
    b60c:	0f 91       	pop	r16
    b60e:	ff 90       	pop	r15
    b610:	ef 90       	pop	r14
    b612:	df 90       	pop	r13
    b614:	cf 90       	pop	r12
    b616:	08 95       	ret

0000b618 <_ZN10helicopter5tasks16ServoControlTaskD1Ev>:
    b618:	26 e7       	ldi	r18, 0x76	; 118
    b61a:	33 e0       	ldi	r19, 0x03	; 3
    b61c:	fc 01       	movw	r30, r24
    b61e:	31 83       	std	Z+1, r19	; 0x01
    b620:	20 83       	st	Z, r18
    b622:	08 95       	ret

0000b624 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>:
    b624:	26 e7       	ldi	r18, 0x76	; 118
    b626:	33 e0       	ldi	r19, 0x03	; 3
    b628:	fc 01       	movw	r30, r24
    b62a:	31 83       	std	Z+1, r19	; 0x01
    b62c:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ServoControlTask : public Task
    b62e:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b632:	08 95       	ret

0000b634 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>:
	
}


void ServoControlTask::runTaskImpl()
{
    b634:	8f 92       	push	r8
    b636:	9f 92       	push	r9
    b638:	af 92       	push	r10
    b63a:	bf 92       	push	r11
    b63c:	cf 92       	push	r12
    b63e:	df 92       	push	r13
    b640:	ef 92       	push	r14
    b642:	ff 92       	push	r15
    b644:	0f 93       	push	r16
    b646:	1f 93       	push	r17

	radioControllerInterface->controlServos(model->LateralControl(), model->LongitudeControl(), model->MainRotorCollectiveControl(), model->YawControl(), model->AuxChannelValue());
    b648:	dc 01       	movw	r26, r24
    b64a:	17 96       	adiw	r26, 0x07	; 7
    b64c:	ed 91       	ld	r30, X+
    b64e:	fc 91       	ld	r31, X
    b650:	18 97       	sbiw	r26, 0x08	; 8
    b652:	82 84       	ldd	r8, Z+10	; 0x0a
    b654:	93 84       	ldd	r9, Z+11	; 0x0b
    b656:	a4 84       	ldd	r10, Z+12	; 0x0c
    b658:	b5 84       	ldd	r11, Z+13	; 0x0d

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    b65a:	df 01       	movw	r26, r30
    b65c:	aa 57       	subi	r26, 0x7A	; 122
    b65e:	bf 4f       	sbci	r27, 0xFF	; 255
    b660:	cd 90       	ld	r12, X+
    b662:	dd 90       	ld	r13, X+
    b664:	ed 90       	ld	r14, X+
    b666:	fc 90       	ld	r15, X
    b668:	06 a5       	ldd	r16, Z+46	; 0x2e
    b66a:	17 a5       	ldd	r17, Z+47	; 0x2f
    b66c:	20 a9       	ldd	r18, Z+48	; 0x30
    b66e:	31 a9       	ldd	r19, Z+49	; 0x31
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    b670:	df 01       	movw	r26, r30
    b672:	a6 5a       	subi	r26, 0xA6	; 166
    b674:	bf 4f       	sbci	r27, 0xFF	; 255
    b676:	4d 91       	ld	r20, X+
    b678:	5d 91       	ld	r21, X+
    b67a:	6d 91       	ld	r22, X+
    b67c:	7c 91       	ld	r23, X
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
    b67e:	e6 5e       	subi	r30, 0xE6	; 230
    b680:	fe 4f       	sbci	r31, 0xFE	; 254
    b682:	a3 81       	ldd	r26, Z+3	; 0x03
    b684:	af 93       	push	r26
    b686:	a2 81       	ldd	r26, Z+2	; 0x02
    b688:	af 93       	push	r26
    b68a:	a1 81       	ldd	r26, Z+1	; 0x01
    b68c:	af 93       	push	r26
    b68e:	e0 81       	ld	r30, Z
    b690:	ef 93       	push	r30
    b692:	fc 01       	movw	r30, r24
    b694:	81 85       	ldd	r24, Z+9	; 0x09
    b696:	92 85       	ldd	r25, Z+10	; 0x0a
    b698:	0e 94 91 21 	call	0x4322	; 0x4322 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>
    b69c:	0f 90       	pop	r0
    b69e:	0f 90       	pop	r0
    b6a0:	0f 90       	pop	r0
    b6a2:	0f 90       	pop	r0
		
		
		
		
	}*/
}
    b6a4:	1f 91       	pop	r17
    b6a6:	0f 91       	pop	r16
    b6a8:	ff 90       	pop	r15
    b6aa:	ef 90       	pop	r14
    b6ac:	df 90       	pop	r13
    b6ae:	cf 90       	pop	r12
    b6b0:	bf 90       	pop	r11
    b6b2:	af 90       	pop	r10
    b6b4:	9f 90       	pop	r9
    b6b6:	8f 90       	pop	r8
    b6b8:	08 95       	ret

0000b6ba <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>:
 */ 
#include "ServoControlTask.h"

using namespace helicopter::tasks;

ServoControlTask::ServoControlTask (SystemModel *model, RadioControllerInterface *radioControllerInterface,int delay, int period) :
    b6ba:	cf 92       	push	r12
    b6bc:	df 92       	push	r13
    b6be:	ef 92       	push	r14
    b6c0:	ff 92       	push	r15
    b6c2:	0f 93       	push	r16
    b6c4:	1f 93       	push	r17
    b6c6:	cf 93       	push	r28
    b6c8:	df 93       	push	r29
    b6ca:	ec 01       	movw	r28, r24
    b6cc:	6b 01       	movw	r12, r22
    b6ce:	7a 01       	movw	r14, r20
    b6d0:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
radioControllerInterface(radioControllerInterface)
    b6d2:	b9 01       	movw	r22, r18
    b6d4:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    b6d8:	8a e5       	ldi	r24, 0x5A	; 90
    b6da:	93 e0       	ldi	r25, 0x03	; 3
    b6dc:	99 83       	std	Y+1, r25	; 0x01
    b6de:	88 83       	st	Y, r24
    b6e0:	d8 86       	std	Y+8, r13	; 0x08
    b6e2:	cf 82       	std	Y+7, r12	; 0x07
    b6e4:	fa 86       	std	Y+10, r15	; 0x0a
    b6e6:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b6e8:	df 91       	pop	r29
    b6ea:	cf 91       	pop	r28
    b6ec:	1f 91       	pop	r17
    b6ee:	0f 91       	pop	r16
    b6f0:	ff 90       	pop	r15
    b6f2:	ef 90       	pop	r14
    b6f4:	df 90       	pop	r13
    b6f6:	cf 90       	pop	r12
    b6f8:	08 95       	ret

0000b6fa <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>:
    b6fa:	26 e7       	ldi	r18, 0x76	; 118
    b6fc:	33 e0       	ldi	r19, 0x03	; 3
    b6fe:	fc 01       	movw	r30, r24
    b700:	31 83       	std	Z+1, r19	; 0x01
    b702:	20 83       	st	Z, r18
    b704:	08 95       	ret

0000b706 <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>:
    b706:	26 e7       	ldi	r18, 0x76	; 118
    b708:	33 e0       	ldi	r19, 0x03	; 3
    b70a:	fc 01       	movw	r30, r24
    b70c:	31 83       	std	Z+1, r19	; 0x01
    b70e:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * Task to receive simulator telemetry data from the ground control station.
		 */
		class SimTelemetryTask : public Task
    b710:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    b714:	08 95       	ret

0000b716 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>:
//}
//


void SimTelemetryTask::runTaskImpl()
{
    b716:	cf 92       	push	r12
    b718:	df 92       	push	r13
    b71a:	ef 92       	push	r14
    b71c:	ff 92       	push	r15
    b71e:	0f 93       	push	r16
    b720:	1f 93       	push	r17
    b722:	cf 93       	push	r28
    b724:	df 93       	push	r29
    b726:	cd b7       	in	r28, 0x3d	; 61
    b728:	de b7       	in	r29, 0x3e	; 62
    b72a:	28 97       	sbiw	r28, 0x08	; 8
    b72c:	0f b6       	in	r0, 0x3f	; 63
    b72e:	f8 94       	cli
    b730:	de bf       	out	0x3e, r29	; 62
    b732:	0f be       	out	0x3f, r0	; 63
    b734:	cd bf       	out	0x3d, r28	; 61
    b736:	8c 01       	movw	r16, r24
	int status = 0;

	//Use the radio interface to get the telemetry message from the simulator
	Message *message = NULL;
    b738:	18 86       	std	Y+8, r1	; 0x08
    b73a:	1f 82       	std	Y+7, r1	; 0x07
		
	status = radioInterface->receive(message);
    b73c:	be 01       	movw	r22, r28
    b73e:	69 5f       	subi	r22, 0xF9	; 249
    b740:	7f 4f       	sbci	r23, 0xFF	; 255
    b742:	dc 01       	movw	r26, r24
    b744:	17 96       	adiw	r26, 0x07	; 7
    b746:	8d 91       	ld	r24, X+
    b748:	9c 91       	ld	r25, X
    b74a:	18 97       	sbiw	r26, 0x08	; 8
    b74c:	0e 94 4a 1d 	call	0x3a94	; 0x3a94 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>
    b750:	7c 01       	movw	r14, r24
		
	if (status == 0 && message != NULL)
    b752:	00 97       	sbiw	r24, 0x00	; 0
    b754:	09 f0       	breq	.+2      	; 0xb758 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x42>
    b756:	40 c4       	rjmp	.+2176   	; 0xbfd8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8c2>
    b758:	cf 80       	ldd	r12, Y+7	; 0x07
    b75a:	d8 84       	ldd	r13, Y+8	; 0x08
    b75c:	c1 14       	cp	r12, r1
    b75e:	d1 04       	cpc	r13, r1
    b760:	09 f4       	brne	.+2      	; 0xb764 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4e>
    b762:	11 c4       	rjmp	.+2082   	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
				/**
				 * Returns the identifier of this message.
				 */
				byte getType()
				{
					return msgType;
    b764:	f6 01       	movw	r30, r12
    b766:	82 81       	ldd	r24, Z+2	; 0x02
	{
		if (message->getType() == SystemTelemetryMessage::MessageType)
    b768:	82 30       	cpi	r24, 0x02	; 2
    b76a:	09 f0       	breq	.+2      	; 0xb76e <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x58>
    b76c:	3f c1       	rjmp	.+638    	; 0xb9ec <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2d6>
		{
			SystemTelemetryMessage *telemMsg = (SystemTelemetryMessage*) message;
				
			//Update the model using the new data received from the simulator.
			telemMsg->updateModelFromMessageFromSimulator(model);
    b76e:	d8 01       	movw	r26, r16
    b770:	19 96       	adiw	r26, 0x09	; 9
    b772:	6d 91       	ld	r22, X+
    b774:	7c 91       	ld	r23, X
    b776:	1a 97       	sbiw	r26, 0x0a	; 10
    b778:	c6 01       	movw	r24, r12
    b77a:	0e 94 a3 3d 	call	0x7b46	; 0x7b46 <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    b77e:	f6 01       	movw	r30, r12
    b780:	85 89       	ldd	r24, Z+21	; 0x15
    b782:	96 89       	ldd	r25, Z+22	; 0x16
    b784:	a7 89       	ldd	r26, Z+23	; 0x17
    b786:	b0 8d       	ldd	r27, Z+24	; 0x18
    b788:	f8 01       	movw	r30, r16
    b78a:	23 85       	ldd	r18, Z+11	; 0x0b
    b78c:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    b78e:	f9 01       	movw	r30, r18
    b790:	82 83       	std	Z+2, r24	; 0x02
    b792:	93 83       	std	Z+3, r25	; 0x03
    b794:	a4 83       	std	Z+4, r26	; 0x04
    b796:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    b798:	f6 01       	movw	r30, r12
    b79a:	81 8d       	ldd	r24, Z+25	; 0x19
    b79c:	92 8d       	ldd	r25, Z+26	; 0x1a
    b79e:	a3 8d       	ldd	r26, Z+27	; 0x1b
    b7a0:	b4 8d       	ldd	r27, Z+28	; 0x1c
    b7a2:	f8 01       	movw	r30, r16
    b7a4:	23 85       	ldd	r18, Z+11	; 0x0b
    b7a6:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    b7a8:	f9 01       	movw	r30, r18
    b7aa:	86 83       	std	Z+6, r24	; 0x06
    b7ac:	97 83       	std	Z+7, r25	; 0x07
    b7ae:	a0 87       	std	Z+8, r26	; 0x08
    b7b0:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    b7b2:	f6 01       	movw	r30, r12
    b7b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    b7b6:	96 8d       	ldd	r25, Z+30	; 0x1e
    b7b8:	a7 8d       	ldd	r26, Z+31	; 0x1f
    b7ba:	b0 a1       	ldd	r27, Z+32	; 0x20
    b7bc:	f8 01       	movw	r30, r16
    b7be:	23 85       	ldd	r18, Z+11	; 0x0b
    b7c0:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    b7c2:	f9 01       	movw	r30, r18
    b7c4:	82 87       	std	Z+10, r24	; 0x0a
    b7c6:	93 87       	std	Z+11, r25	; 0x0b
    b7c8:	a4 87       	std	Z+12, r26	; 0x0c
    b7ca:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    b7cc:	f6 01       	movw	r30, r12
    b7ce:	81 a1       	ldd	r24, Z+33	; 0x21
    b7d0:	92 a1       	ldd	r25, Z+34	; 0x22
    b7d2:	a3 a1       	ldd	r26, Z+35	; 0x23
    b7d4:	b4 a1       	ldd	r27, Z+36	; 0x24
    b7d6:	f8 01       	movw	r30, r16
    b7d8:	23 85       	ldd	r18, Z+11	; 0x0b
    b7da:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    b7dc:	f9 01       	movw	r30, r18
    b7de:	86 87       	std	Z+14, r24	; 0x0e
    b7e0:	97 87       	std	Z+15, r25	; 0x0f
    b7e2:	a0 8b       	std	Z+16, r26	; 0x10
    b7e4:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    b7e6:	f6 01       	movw	r30, r12
    b7e8:	ef 5b       	subi	r30, 0xBF	; 191
    b7ea:	ff 4f       	sbci	r31, 0xFF	; 255
    b7ec:	80 81       	ld	r24, Z
    b7ee:	91 81       	ldd	r25, Z+1	; 0x01
    b7f0:	a2 81       	ldd	r26, Z+2	; 0x02
    b7f2:	b3 81       	ldd	r27, Z+3	; 0x03
    b7f4:	f8 01       	movw	r30, r16
    b7f6:	23 85       	ldd	r18, Z+11	; 0x0b
    b7f8:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    b7fa:	f9 01       	movw	r30, r18
    b7fc:	82 8b       	std	Z+18, r24	; 0x12
    b7fe:	93 8b       	std	Z+19, r25	; 0x13
    b800:	a4 8b       	std	Z+20, r26	; 0x14
    b802:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    b804:	f6 01       	movw	r30, r12
    b806:	eb 5b       	subi	r30, 0xBB	; 187
    b808:	ff 4f       	sbci	r31, 0xFF	; 255
    b80a:	80 81       	ld	r24, Z
    b80c:	91 81       	ldd	r25, Z+1	; 0x01
    b80e:	a2 81       	ldd	r26, Z+2	; 0x02
    b810:	b3 81       	ldd	r27, Z+3	; 0x03
    b812:	f8 01       	movw	r30, r16
    b814:	23 85       	ldd	r18, Z+11	; 0x0b
    b816:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    b818:	f9 01       	movw	r30, r18
    b81a:	86 8b       	std	Z+22, r24	; 0x16
    b81c:	97 8b       	std	Z+23, r25	; 0x17
    b81e:	a0 8f       	std	Z+24, r26	; 0x18
    b820:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    b822:	f6 01       	movw	r30, r12
    b824:	e7 5b       	subi	r30, 0xB7	; 183
    b826:	ff 4f       	sbci	r31, 0xFF	; 255
    b828:	80 81       	ld	r24, Z
    b82a:	91 81       	ldd	r25, Z+1	; 0x01
    b82c:	a2 81       	ldd	r26, Z+2	; 0x02
    b82e:	b3 81       	ldd	r27, Z+3	; 0x03
    b830:	f8 01       	movw	r30, r16
    b832:	23 85       	ldd	r18, Z+11	; 0x0b
    b834:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    b836:	f9 01       	movw	r30, r18
    b838:	82 8f       	std	Z+26, r24	; 0x1a
    b83a:	93 8f       	std	Z+27, r25	; 0x1b
    b83c:	a4 8f       	std	Z+28, r26	; 0x1c
    b83e:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    b840:	f6 01       	movw	r30, r12
    b842:	e3 5b       	subi	r30, 0xB3	; 179
    b844:	ff 4f       	sbci	r31, 0xFF	; 255
    b846:	80 81       	ld	r24, Z
    b848:	91 81       	ldd	r25, Z+1	; 0x01
    b84a:	a2 81       	ldd	r26, Z+2	; 0x02
    b84c:	b3 81       	ldd	r27, Z+3	; 0x03
    b84e:	f8 01       	movw	r30, r16
    b850:	23 85       	ldd	r18, Z+11	; 0x0b
    b852:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    b854:	f9 01       	movw	r30, r18
    b856:	86 8f       	std	Z+30, r24	; 0x1e
    b858:	97 8f       	std	Z+31, r25	; 0x1f
    b85a:	a0 a3       	std	Z+32, r26	; 0x20
    b85c:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    b85e:	f6 01       	movw	r30, r12
    b860:	ef 5a       	subi	r30, 0xAF	; 175
    b862:	ff 4f       	sbci	r31, 0xFF	; 255
    b864:	80 81       	ld	r24, Z
    b866:	91 81       	ldd	r25, Z+1	; 0x01
    b868:	a2 81       	ldd	r26, Z+2	; 0x02
    b86a:	b3 81       	ldd	r27, Z+3	; 0x03
    b86c:	f8 01       	movw	r30, r16
    b86e:	23 85       	ldd	r18, Z+11	; 0x0b
    b870:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    b872:	f9 01       	movw	r30, r18
    b874:	82 a3       	std	Z+34, r24	; 0x22
    b876:	93 a3       	std	Z+35, r25	; 0x23
    b878:	a4 a3       	std	Z+36, r26	; 0x24
    b87a:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    b87c:	f6 01       	movw	r30, r12
    b87e:	e7 5a       	subi	r30, 0xA7	; 167
    b880:	ff 4f       	sbci	r31, 0xFF	; 255
    b882:	80 81       	ld	r24, Z
    b884:	91 81       	ldd	r25, Z+1	; 0x01
    b886:	a2 81       	ldd	r26, Z+2	; 0x02
    b888:	b3 81       	ldd	r27, Z+3	; 0x03
    b88a:	f8 01       	movw	r30, r16
    b88c:	23 85       	ldd	r18, Z+11	; 0x0b
    b88e:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    b890:	f9 01       	movw	r30, r18
    b892:	86 a3       	std	Z+38, r24	; 0x26
    b894:	97 a3       	std	Z+39, r25	; 0x27
    b896:	a0 a7       	std	Z+40, r26	; 0x28
    b898:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    b89a:	f6 01       	movw	r30, r12
    b89c:	e7 58       	subi	r30, 0x87	; 135
    b89e:	ff 4f       	sbci	r31, 0xFF	; 255
    b8a0:	80 81       	ld	r24, Z
    b8a2:	91 81       	ldd	r25, Z+1	; 0x01
    b8a4:	a2 81       	ldd	r26, Z+2	; 0x02
    b8a6:	b3 81       	ldd	r27, Z+3	; 0x03
    b8a8:	f8 01       	movw	r30, r16
    b8aa:	23 85       	ldd	r18, Z+11	; 0x0b
    b8ac:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    b8ae:	f9 01       	movw	r30, r18
    b8b0:	82 a7       	std	Z+42, r24	; 0x2a
    b8b2:	93 a7       	std	Z+43, r25	; 0x2b
    b8b4:	a4 a7       	std	Z+44, r26	; 0x2c
    b8b6:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    b8b8:	f6 01       	movw	r30, r12
    b8ba:	e3 58       	subi	r30, 0x83	; 131
    b8bc:	ff 4f       	sbci	r31, 0xFF	; 255
    b8be:	80 81       	ld	r24, Z
    b8c0:	91 81       	ldd	r25, Z+1	; 0x01
    b8c2:	a2 81       	ldd	r26, Z+2	; 0x02
    b8c4:	b3 81       	ldd	r27, Z+3	; 0x03
    b8c6:	f8 01       	movw	r30, r16
    b8c8:	23 85       	ldd	r18, Z+11	; 0x0b
    b8ca:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    b8cc:	f9 01       	movw	r30, r18
    b8ce:	86 a7       	std	Z+46, r24	; 0x2e
    b8d0:	97 a7       	std	Z+47, r25	; 0x2f
    b8d2:	a0 ab       	std	Z+48, r26	; 0x30
    b8d4:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    b8d6:	f6 01       	movw	r30, r12
    b8d8:	ef 57       	subi	r30, 0x7F	; 127
    b8da:	ff 4f       	sbci	r31, 0xFF	; 255
    b8dc:	80 81       	ld	r24, Z
    b8de:	91 81       	ldd	r25, Z+1	; 0x01
    b8e0:	a2 81       	ldd	r26, Z+2	; 0x02
    b8e2:	b3 81       	ldd	r27, Z+3	; 0x03
    b8e4:	f8 01       	movw	r30, r16
    b8e6:	23 85       	ldd	r18, Z+11	; 0x0b
    b8e8:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    b8ea:	f9 01       	movw	r30, r18
    b8ec:	82 ab       	std	Z+50, r24	; 0x32
    b8ee:	93 ab       	std	Z+51, r25	; 0x33
    b8f0:	a4 ab       	std	Z+52, r26	; 0x34
    b8f2:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    b8f4:	f6 01       	movw	r30, r12
    b8f6:	eb 57       	subi	r30, 0x7B	; 123
    b8f8:	ff 4f       	sbci	r31, 0xFF	; 255
    b8fa:	80 81       	ld	r24, Z
    b8fc:	91 81       	ldd	r25, Z+1	; 0x01
    b8fe:	a2 81       	ldd	r26, Z+2	; 0x02
    b900:	b3 81       	ldd	r27, Z+3	; 0x03
    b902:	f8 01       	movw	r30, r16
    b904:	23 85       	ldd	r18, Z+11	; 0x0b
    b906:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    b908:	f9 01       	movw	r30, r18
    b90a:	86 ab       	std	Z+54, r24	; 0x36
    b90c:	97 ab       	std	Z+55, r25	; 0x37
    b90e:	a0 af       	std	Z+56, r26	; 0x38
    b910:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    b912:	f6 01       	movw	r30, r12
    b914:	e7 57       	subi	r30, 0x77	; 119
    b916:	ff 4f       	sbci	r31, 0xFF	; 255
    b918:	80 81       	ld	r24, Z
    b91a:	91 81       	ldd	r25, Z+1	; 0x01
    b91c:	a2 81       	ldd	r26, Z+2	; 0x02
    b91e:	b3 81       	ldd	r27, Z+3	; 0x03
    b920:	f8 01       	movw	r30, r16
    b922:	23 85       	ldd	r18, Z+11	; 0x0b
    b924:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    b926:	f9 01       	movw	r30, r18
    b928:	82 af       	std	Z+58, r24	; 0x3a
    b92a:	93 af       	std	Z+59, r25	; 0x3b
    b92c:	a4 af       	std	Z+60, r26	; 0x3c
    b92e:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    b930:	f6 01       	movw	r30, r12
    b932:	ef 56       	subi	r30, 0x6F	; 111
    b934:	ff 4f       	sbci	r31, 0xFF	; 255
    b936:	80 81       	ld	r24, Z
    b938:	91 81       	ldd	r25, Z+1	; 0x01
    b93a:	a2 81       	ldd	r26, Z+2	; 0x02
    b93c:	b3 81       	ldd	r27, Z+3	; 0x03
    b93e:	f8 01       	movw	r30, r16
    b940:	23 85       	ldd	r18, Z+11	; 0x0b
    b942:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    b944:	f9 01       	movw	r30, r18
    b946:	fe 96       	adiw	r30, 0x3e	; 62
    b948:	80 83       	st	Z, r24
    b94a:	91 83       	std	Z+1, r25	; 0x01
    b94c:	a2 83       	std	Z+2, r26	; 0x02
    b94e:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    b950:	f6 01       	movw	r30, r12
    b952:	ef 54       	subi	r30, 0x4F	; 79
    b954:	ff 4f       	sbci	r31, 0xFF	; 255
    b956:	80 81       	ld	r24, Z
    b958:	91 81       	ldd	r25, Z+1	; 0x01
    b95a:	a2 81       	ldd	r26, Z+2	; 0x02
    b95c:	b3 81       	ldd	r27, Z+3	; 0x03
    b95e:	f8 01       	movw	r30, r16
    b960:	23 85       	ldd	r18, Z+11	; 0x0b
    b962:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    b964:	f9 01       	movw	r30, r18
    b966:	ee 5b       	subi	r30, 0xBE	; 190
    b968:	ff 4f       	sbci	r31, 0xFF	; 255
    b96a:	80 83       	st	Z, r24
    b96c:	91 83       	std	Z+1, r25	; 0x01
    b96e:	a2 83       	std	Z+2, r26	; 0x02
    b970:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    b972:	f6 01       	movw	r30, r12
    b974:	eb 54       	subi	r30, 0x4B	; 75
    b976:	ff 4f       	sbci	r31, 0xFF	; 255
    b978:	80 81       	ld	r24, Z
    b97a:	91 81       	ldd	r25, Z+1	; 0x01
    b97c:	a2 81       	ldd	r26, Z+2	; 0x02
    b97e:	b3 81       	ldd	r27, Z+3	; 0x03
    b980:	f8 01       	movw	r30, r16
    b982:	23 85       	ldd	r18, Z+11	; 0x0b
    b984:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    b986:	f9 01       	movw	r30, r18
    b988:	ea 5b       	subi	r30, 0xBA	; 186
    b98a:	ff 4f       	sbci	r31, 0xFF	; 255
    b98c:	80 83       	st	Z, r24
    b98e:	91 83       	std	Z+1, r25	; 0x01
    b990:	a2 83       	std	Z+2, r26	; 0x02
    b992:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    b994:	f6 01       	movw	r30, r12
    b996:	e7 54       	subi	r30, 0x47	; 71
    b998:	ff 4f       	sbci	r31, 0xFF	; 255
    b99a:	80 81       	ld	r24, Z
    b99c:	91 81       	ldd	r25, Z+1	; 0x01
    b99e:	a2 81       	ldd	r26, Z+2	; 0x02
    b9a0:	b3 81       	ldd	r27, Z+3	; 0x03
    b9a2:	f8 01       	movw	r30, r16
    b9a4:	23 85       	ldd	r18, Z+11	; 0x0b
    b9a6:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    b9a8:	f9 01       	movw	r30, r18
    b9aa:	e6 5b       	subi	r30, 0xB6	; 182
    b9ac:	ff 4f       	sbci	r31, 0xFF	; 255
    b9ae:	80 83       	st	Z, r24
    b9b0:	91 83       	std	Z+1, r25	; 0x01
    b9b2:	a2 83       	std	Z+2, r26	; 0x02
    b9b4:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    b9b6:	f6 01       	movw	r30, r12
    b9b8:	e3 54       	subi	r30, 0x43	; 67
    b9ba:	ff 4f       	sbci	r31, 0xFF	; 255
    b9bc:	80 81       	ld	r24, Z
    b9be:	91 81       	ldd	r25, Z+1	; 0x01
    b9c0:	a2 81       	ldd	r26, Z+2	; 0x02
    b9c2:	b3 81       	ldd	r27, Z+3	; 0x03
    b9c4:	f8 01       	movw	r30, r16
    b9c6:	23 85       	ldd	r18, Z+11	; 0x0b
    b9c8:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    b9ca:	f9 01       	movw	r30, r18
    b9cc:	e2 5b       	subi	r30, 0xB2	; 178
    b9ce:	ff 4f       	sbci	r31, 0xFF	; 255
    b9d0:	80 83       	st	Z, r24
    b9d2:	91 83       	std	Z+1, r25	; 0x01
    b9d4:	a2 83       	std	Z+2, r26	; 0x02
    b9d6:	b3 83       	std	Z+3, r27	; 0x03
			
			model->HasNewPressureReading = true;
    b9d8:	d8 01       	movw	r26, r16
    b9da:	19 96       	adiw	r26, 0x09	; 9
    b9dc:	ed 91       	ld	r30, X+
    b9de:	fc 91       	ld	r31, X
    b9e0:	1a 97       	sbiw	r26, 0x0a	; 10
    b9e2:	ee 5b       	subi	r30, 0xBE	; 190
    b9e4:	fe 4f       	sbci	r31, 0xFE	; 254
    b9e6:	81 e0       	ldi	r24, 0x01	; 1
    b9e8:	80 83       	st	Z, r24
    b9ea:	5b c2       	rjmp	.+1206   	; 0xbea2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
		}else if (message->getType() == SensorDataMessage::MessageType)
    b9ec:	84 30       	cpi	r24, 0x04	; 4
    b9ee:	09 f0       	breq	.+2      	; 0xb9f2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2dc>
    b9f0:	fd c0       	rjmp	.+506    	; 0xbbec <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4d6>
		{
			SensorDataMessage *sensorMsg = (SensorDataMessage*) message;
			model->XAccelFrdMss(sensorMsg->XAccelFrdMss);
    b9f2:	f6 01       	movw	r30, r12
    b9f4:	85 81       	ldd	r24, Z+5	; 0x05
    b9f6:	96 81       	ldd	r25, Z+6	; 0x06
    b9f8:	a7 81       	ldd	r26, Z+7	; 0x07
    b9fa:	b0 85       	ldd	r27, Z+8	; 0x08
    b9fc:	f8 01       	movw	r30, r16
    b9fe:	21 85       	ldd	r18, Z+9	; 0x09
    ba00:	32 85       	ldd	r19, Z+10	; 0x0a
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    ba02:	f9 01       	movw	r30, r18
    ba04:	ea 51       	subi	r30, 0x1A	; 26
    ba06:	ff 4f       	sbci	r31, 0xFF	; 255
    ba08:	80 83       	st	Z, r24
    ba0a:	91 83       	std	Z+1, r25	; 0x01
    ba0c:	a2 83       	std	Z+2, r26	; 0x02
    ba0e:	b3 83       	std	Z+3, r27	; 0x03
			model->YAccelFrdMss(sensorMsg->YAccelFrdMss);
    ba10:	f6 01       	movw	r30, r12
    ba12:	81 85       	ldd	r24, Z+9	; 0x09
    ba14:	92 85       	ldd	r25, Z+10	; 0x0a
    ba16:	a3 85       	ldd	r26, Z+11	; 0x0b
    ba18:	b4 85       	ldd	r27, Z+12	; 0x0c
    ba1a:	f8 01       	movw	r30, r16
    ba1c:	21 85       	ldd	r18, Z+9	; 0x09
    ba1e:	32 85       	ldd	r19, Z+10	; 0x0a

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    ba20:	f9 01       	movw	r30, r18
    ba22:	e6 51       	subi	r30, 0x16	; 22
    ba24:	ff 4f       	sbci	r31, 0xFF	; 255
    ba26:	80 83       	st	Z, r24
    ba28:	91 83       	std	Z+1, r25	; 0x01
    ba2a:	a2 83       	std	Z+2, r26	; 0x02
    ba2c:	b3 83       	std	Z+3, r27	; 0x03
			model->ZAccelFrdMss(sensorMsg->ZAccelFrdMss);
    ba2e:	f6 01       	movw	r30, r12
    ba30:	85 85       	ldd	r24, Z+13	; 0x0d
    ba32:	96 85       	ldd	r25, Z+14	; 0x0e
    ba34:	a7 85       	ldd	r26, Z+15	; 0x0f
    ba36:	b0 89       	ldd	r27, Z+16	; 0x10
    ba38:	f8 01       	movw	r30, r16
    ba3a:	21 85       	ldd	r18, Z+9	; 0x09
    ba3c:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    ba3e:	f9 01       	movw	r30, r18
    ba40:	e2 51       	subi	r30, 0x12	; 18
    ba42:	ff 4f       	sbci	r31, 0xFF	; 255
    ba44:	80 83       	st	Z, r24
    ba46:	91 83       	std	Z+1, r25	; 0x01
    ba48:	a2 83       	std	Z+2, r26	; 0x02
    ba4a:	b3 83       	std	Z+3, r27	; 0x03
			model->YawAngularVelocityRadsPerSecond(sensorMsg->YawAngularVelocityRadsPerSecond);
    ba4c:	f6 01       	movw	r30, r12
    ba4e:	81 89       	ldd	r24, Z+17	; 0x11
    ba50:	92 89       	ldd	r25, Z+18	; 0x12
    ba52:	a3 89       	ldd	r26, Z+19	; 0x13
    ba54:	b4 89       	ldd	r27, Z+20	; 0x14
    ba56:	f8 01       	movw	r30, r16
    ba58:	21 85       	ldd	r18, Z+9	; 0x09
    ba5a:	32 85       	ldd	r19, Z+10	; 0x0a
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    ba5c:	f9 01       	movw	r30, r18
    ba5e:	ee 51       	subi	r30, 0x1E	; 30
    ba60:	ff 4f       	sbci	r31, 0xFF	; 255
    ba62:	80 83       	st	Z, r24
    ba64:	91 83       	std	Z+1, r25	; 0x01
    ba66:	a2 83       	std	Z+2, r26	; 0x02
    ba68:	b3 83       	std	Z+3, r27	; 0x03
			model->PitchAngularVelocityRadsPerSecond(sensorMsg->PitchAngularVelocityRadsPerSecond);
    ba6a:	f6 01       	movw	r30, r12
    ba6c:	85 89       	ldd	r24, Z+21	; 0x15
    ba6e:	96 89       	ldd	r25, Z+22	; 0x16
    ba70:	a7 89       	ldd	r26, Z+23	; 0x17
    ba72:	b0 8d       	ldd	r27, Z+24	; 0x18
    ba74:	f8 01       	movw	r30, r16
    ba76:	21 85       	ldd	r18, Z+9	; 0x09
    ba78:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    ba7a:	f9 01       	movw	r30, r18
    ba7c:	e6 52       	subi	r30, 0x26	; 38
    ba7e:	ff 4f       	sbci	r31, 0xFF	; 255
    ba80:	80 83       	st	Z, r24
    ba82:	91 83       	std	Z+1, r25	; 0x01
    ba84:	a2 83       	std	Z+2, r26	; 0x02
    ba86:	b3 83       	std	Z+3, r27	; 0x03
			model->RollAngularVelocityRadsPerSecond(sensorMsg->RollAngularVelocityRadsPerSecond);
    ba88:	f6 01       	movw	r30, r12
    ba8a:	81 8d       	ldd	r24, Z+25	; 0x19
    ba8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    ba8e:	a3 8d       	ldd	r26, Z+27	; 0x1b
    ba90:	b4 8d       	ldd	r27, Z+28	; 0x1c
    ba92:	f8 01       	movw	r30, r16
    ba94:	21 85       	ldd	r18, Z+9	; 0x09
    ba96:	32 85       	ldd	r19, Z+10	; 0x0a

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    ba98:	f9 01       	movw	r30, r18
    ba9a:	e2 52       	subi	r30, 0x22	; 34
    ba9c:	ff 4f       	sbci	r31, 0xFF	; 255
    ba9e:	80 83       	st	Z, r24
    baa0:	91 83       	std	Z+1, r25	; 0x01
    baa2:	a2 83       	std	Z+2, r26	; 0x02
    baa4:	b3 83       	std	Z+3, r27	; 0x03
			model->XMagFrd(sensorMsg->XMagFrd);
    baa6:	f6 01       	movw	r30, r12
    baa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    baaa:	96 8d       	ldd	r25, Z+30	; 0x1e
    baac:	a7 8d       	ldd	r26, Z+31	; 0x1f
    baae:	b0 a1       	ldd	r27, Z+32	; 0x20
    bab0:	f8 01       	movw	r30, r16
    bab2:	21 85       	ldd	r18, Z+9	; 0x09
    bab4:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    bab6:	f9 01       	movw	r30, r18
    bab8:	ee 50       	subi	r30, 0x0E	; 14
    baba:	ff 4f       	sbci	r31, 0xFF	; 255
    babc:	80 83       	st	Z, r24
    babe:	91 83       	std	Z+1, r25	; 0x01
    bac0:	a2 83       	std	Z+2, r26	; 0x02
    bac2:	b3 83       	std	Z+3, r27	; 0x03
			model->YMagFrd(sensorMsg->YMagFrd);
    bac4:	f6 01       	movw	r30, r12
    bac6:	81 a1       	ldd	r24, Z+33	; 0x21
    bac8:	92 a1       	ldd	r25, Z+34	; 0x22
    baca:	a3 a1       	ldd	r26, Z+35	; 0x23
    bacc:	b4 a1       	ldd	r27, Z+36	; 0x24
    bace:	f8 01       	movw	r30, r16
    bad0:	21 85       	ldd	r18, Z+9	; 0x09
    bad2:	32 85       	ldd	r19, Z+10	; 0x0a

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    bad4:	f9 01       	movw	r30, r18
    bad6:	ea 50       	subi	r30, 0x0A	; 10
    bad8:	ff 4f       	sbci	r31, 0xFF	; 255
    bada:	80 83       	st	Z, r24
    badc:	91 83       	std	Z+1, r25	; 0x01
    bade:	a2 83       	std	Z+2, r26	; 0x02
    bae0:	b3 83       	std	Z+3, r27	; 0x03
			model->ZMagFrd(sensorMsg->ZMagFrd);
    bae2:	f6 01       	movw	r30, r12
    bae4:	85 a1       	ldd	r24, Z+37	; 0x25
    bae6:	96 a1       	ldd	r25, Z+38	; 0x26
    bae8:	a7 a1       	ldd	r26, Z+39	; 0x27
    baea:	b0 a5       	ldd	r27, Z+40	; 0x28
    baec:	f8 01       	movw	r30, r16
    baee:	21 85       	ldd	r18, Z+9	; 0x09
    baf0:	32 85       	ldd	r19, Z+10	; 0x0a

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    baf2:	f9 01       	movw	r30, r18
    baf4:	e6 50       	subi	r30, 0x06	; 6
    baf6:	ff 4f       	sbci	r31, 0xFF	; 255
    baf8:	80 83       	st	Z, r24
    bafa:	91 83       	std	Z+1, r25	; 0x01
    bafc:	a2 83       	std	Z+2, r26	; 0x02
    bafe:	b3 83       	std	Z+3, r27	; 0x03
			model->XEcefCm(sensorMsg->XEcefCm);
    bb00:	f6 01       	movw	r30, r12
    bb02:	81 a5       	ldd	r24, Z+41	; 0x29
    bb04:	92 a5       	ldd	r25, Z+42	; 0x2a
    bb06:	a3 a5       	ldd	r26, Z+43	; 0x2b
    bb08:	b4 a5       	ldd	r27, Z+44	; 0x2c
    bb0a:	f8 01       	movw	r30, r16
    bb0c:	21 85       	ldd	r18, Z+9	; 0x09
    bb0e:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    bb10:	f9 01       	movw	r30, r18
    bb12:	e2 50       	subi	r30, 0x02	; 2
    bb14:	ff 4f       	sbci	r31, 0xFF	; 255
    bb16:	80 83       	st	Z, r24
    bb18:	91 83       	std	Z+1, r25	; 0x01
    bb1a:	a2 83       	std	Z+2, r26	; 0x02
    bb1c:	b3 83       	std	Z+3, r27	; 0x03
			model->YEcefCm(sensorMsg->YEcefCm);
    bb1e:	f6 01       	movw	r30, r12
    bb20:	85 a5       	ldd	r24, Z+45	; 0x2d
    bb22:	96 a5       	ldd	r25, Z+46	; 0x2e
    bb24:	a7 a5       	ldd	r26, Z+47	; 0x2f
    bb26:	b0 a9       	ldd	r27, Z+48	; 0x30
    bb28:	f8 01       	movw	r30, r16
    bb2a:	21 85       	ldd	r18, Z+9	; 0x09
    bb2c:	32 85       	ldd	r19, Z+10	; 0x0a
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    bb2e:	f9 01       	movw	r30, r18
    bb30:	ee 5f       	subi	r30, 0xFE	; 254
    bb32:	fe 4f       	sbci	r31, 0xFE	; 254
    bb34:	80 83       	st	Z, r24
    bb36:	91 83       	std	Z+1, r25	; 0x01
    bb38:	a2 83       	std	Z+2, r26	; 0x02
    bb3a:	b3 83       	std	Z+3, r27	; 0x03
			model->ZEcefCm(sensorMsg->ZEcefCm);
    bb3c:	f6 01       	movw	r30, r12
    bb3e:	81 a9       	ldd	r24, Z+49	; 0x31
    bb40:	92 a9       	ldd	r25, Z+50	; 0x32
    bb42:	a3 a9       	ldd	r26, Z+51	; 0x33
    bb44:	b4 a9       	ldd	r27, Z+52	; 0x34
    bb46:	f8 01       	movw	r30, r16
    bb48:	21 85       	ldd	r18, Z+9	; 0x09
    bb4a:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    bb4c:	f9 01       	movw	r30, r18
    bb4e:	ea 5f       	subi	r30, 0xFA	; 250
    bb50:	fe 4f       	sbci	r31, 0xFE	; 254
    bb52:	80 83       	st	Z, r24
    bb54:	91 83       	std	Z+1, r25	; 0x01
    bb56:	a2 83       	std	Z+2, r26	; 0x02
    bb58:	b3 83       	std	Z+3, r27	; 0x03
			model->XVEcefCms(sensorMsg->XVEcefCms);
    bb5a:	f6 01       	movw	r30, r12
    bb5c:	85 a9       	ldd	r24, Z+53	; 0x35
    bb5e:	96 a9       	ldd	r25, Z+54	; 0x36
    bb60:	a7 a9       	ldd	r26, Z+55	; 0x37
    bb62:	b0 ad       	ldd	r27, Z+56	; 0x38
    bb64:	f8 01       	movw	r30, r16
    bb66:	21 85       	ldd	r18, Z+9	; 0x09
    bb68:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    bb6a:	f9 01       	movw	r30, r18
    bb6c:	e6 5f       	subi	r30, 0xF6	; 246
    bb6e:	fe 4f       	sbci	r31, 0xFE	; 254
    bb70:	80 83       	st	Z, r24
    bb72:	91 83       	std	Z+1, r25	; 0x01
    bb74:	a2 83       	std	Z+2, r26	; 0x02
    bb76:	b3 83       	std	Z+3, r27	; 0x03
			model->YVEcefCms(sensorMsg->YVEcefCms);
    bb78:	f6 01       	movw	r30, r12
    bb7a:	81 ad       	ldd	r24, Z+57	; 0x39
    bb7c:	92 ad       	ldd	r25, Z+58	; 0x3a
    bb7e:	a3 ad       	ldd	r26, Z+59	; 0x3b
    bb80:	b4 ad       	ldd	r27, Z+60	; 0x3c
    bb82:	f8 01       	movw	r30, r16
    bb84:	21 85       	ldd	r18, Z+9	; 0x09
    bb86:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    bb88:	f9 01       	movw	r30, r18
    bb8a:	e2 5f       	subi	r30, 0xF2	; 242
    bb8c:	fe 4f       	sbci	r31, 0xFE	; 254
    bb8e:	80 83       	st	Z, r24
    bb90:	91 83       	std	Z+1, r25	; 0x01
    bb92:	a2 83       	std	Z+2, r26	; 0x02
    bb94:	b3 83       	std	Z+3, r27	; 0x03
			model->ZVEcefCms(sensorMsg->ZVEcefCms);
    bb96:	f6 01       	movw	r30, r12
    bb98:	fd 96       	adiw	r30, 0x3d	; 61
    bb9a:	40 81       	ld	r20, Z
    bb9c:	51 81       	ldd	r21, Z+1	; 0x01
    bb9e:	62 81       	ldd	r22, Z+2	; 0x02
    bba0:	73 81       	ldd	r23, Z+3	; 0x03
    bba2:	d8 01       	movw	r26, r16
    bba4:	19 96       	adiw	r26, 0x09	; 9
    bba6:	ed 91       	ld	r30, X+
    bba8:	fc 91       	ld	r31, X
    bbaa:	1a 97       	sbiw	r26, 0x0a	; 10
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    bbac:	ee 5e       	subi	r30, 0xEE	; 238
    bbae:	fe 4f       	sbci	r31, 0xFE	; 254
    bbb0:	40 83       	st	Z, r20
    bbb2:	51 83       	std	Z+1, r21	; 0x01
    bbb4:	62 83       	std	Z+2, r22	; 0x02
    bbb6:	73 83       	std	Z+3, r23	; 0x03
			model->PressureMillibars(sensorMsg->PressureMillibars);
    bbb8:	f6 01       	movw	r30, r12
    bbba:	ef 5b       	subi	r30, 0xBF	; 191
    bbbc:	ff 4f       	sbci	r31, 0xFF	; 255
    bbbe:	40 81       	ld	r20, Z
    bbc0:	51 81       	ldd	r21, Z+1	; 0x01
    bbc2:	62 81       	ldd	r22, Z+2	; 0x02
    bbc4:	73 81       	ldd	r23, Z+3	; 0x03
    bbc6:	19 96       	adiw	r26, 0x09	; 9
    bbc8:	ed 91       	ld	r30, X+
    bbca:	fc 91       	ld	r31, X
    bbcc:	1a 97       	sbiw	r26, 0x0a	; 10
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    bbce:	ea 5e       	subi	r30, 0xEA	; 234
    bbd0:	fe 4f       	sbci	r31, 0xFE	; 254
    bbd2:	40 83       	st	Z, r20
    bbd4:	51 83       	std	Z+1, r21	; 0x01
    bbd6:	62 83       	std	Z+2, r22	; 0x02
    bbd8:	73 83       	std	Z+3, r23	; 0x03
			
			model->HasNewPressureReading = true;
    bbda:	19 96       	adiw	r26, 0x09	; 9
    bbdc:	ed 91       	ld	r30, X+
    bbde:	fc 91       	ld	r31, X
    bbe0:	1a 97       	sbiw	r26, 0x0a	; 10
    bbe2:	ee 5b       	subi	r30, 0xBE	; 190
    bbe4:	fe 4f       	sbci	r31, 0xFE	; 254
    bbe6:	81 e0       	ldi	r24, 0x01	; 1
    bbe8:	80 83       	st	Z, r24
    bbea:	5b c1       	rjmp	.+694    	; 0xbea2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
				
		}else if (message->getType() == GainsMessage::MessageType)
    bbec:	87 30       	cpi	r24, 0x07	; 7
    bbee:	09 f0       	breq	.+2      	; 0xbbf2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4dc>
    bbf0:	5e c1       	rjmp	.+700    	; 0xbeae <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
		{
			GainsMessage *telemMsg = (GainsMessage*) message;
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    bbf2:	f6 01       	movw	r30, r12
    bbf4:	85 81       	ldd	r24, Z+5	; 0x05
    bbf6:	96 81       	ldd	r25, Z+6	; 0x06
    bbf8:	a7 81       	ldd	r26, Z+7	; 0x07
    bbfa:	b0 85       	ldd	r27, Z+8	; 0x08
    bbfc:	f8 01       	movw	r30, r16
    bbfe:	23 85       	ldd	r18, Z+11	; 0x0b
    bc00:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    bc02:	f9 01       	movw	r30, r18
    bc04:	82 83       	std	Z+2, r24	; 0x02
    bc06:	93 83       	std	Z+3, r25	; 0x03
    bc08:	a4 83       	std	Z+4, r26	; 0x04
    bc0a:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    bc0c:	f6 01       	movw	r30, r12
    bc0e:	81 85       	ldd	r24, Z+9	; 0x09
    bc10:	92 85       	ldd	r25, Z+10	; 0x0a
    bc12:	a3 85       	ldd	r26, Z+11	; 0x0b
    bc14:	b4 85       	ldd	r27, Z+12	; 0x0c
    bc16:	f8 01       	movw	r30, r16
    bc18:	23 85       	ldd	r18, Z+11	; 0x0b
    bc1a:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    bc1c:	f9 01       	movw	r30, r18
    bc1e:	86 83       	std	Z+6, r24	; 0x06
    bc20:	97 83       	std	Z+7, r25	; 0x07
    bc22:	a0 87       	std	Z+8, r26	; 0x08
    bc24:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    bc26:	f6 01       	movw	r30, r12
    bc28:	85 85       	ldd	r24, Z+13	; 0x0d
    bc2a:	96 85       	ldd	r25, Z+14	; 0x0e
    bc2c:	a7 85       	ldd	r26, Z+15	; 0x0f
    bc2e:	b0 89       	ldd	r27, Z+16	; 0x10
    bc30:	f8 01       	movw	r30, r16
    bc32:	23 85       	ldd	r18, Z+11	; 0x0b
    bc34:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    bc36:	f9 01       	movw	r30, r18
    bc38:	82 87       	std	Z+10, r24	; 0x0a
    bc3a:	93 87       	std	Z+11, r25	; 0x0b
    bc3c:	a4 87       	std	Z+12, r26	; 0x0c
    bc3e:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    bc40:	f6 01       	movw	r30, r12
    bc42:	81 89       	ldd	r24, Z+17	; 0x11
    bc44:	92 89       	ldd	r25, Z+18	; 0x12
    bc46:	a3 89       	ldd	r26, Z+19	; 0x13
    bc48:	b4 89       	ldd	r27, Z+20	; 0x14
    bc4a:	f8 01       	movw	r30, r16
    bc4c:	23 85       	ldd	r18, Z+11	; 0x0b
    bc4e:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    bc50:	f9 01       	movw	r30, r18
    bc52:	86 87       	std	Z+14, r24	; 0x0e
    bc54:	97 87       	std	Z+15, r25	; 0x0f
    bc56:	a0 8b       	std	Z+16, r26	; 0x10
    bc58:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    bc5a:	f6 01       	movw	r30, r12
    bc5c:	85 89       	ldd	r24, Z+21	; 0x15
    bc5e:	96 89       	ldd	r25, Z+22	; 0x16
    bc60:	a7 89       	ldd	r26, Z+23	; 0x17
    bc62:	b0 8d       	ldd	r27, Z+24	; 0x18
    bc64:	f8 01       	movw	r30, r16
    bc66:	23 85       	ldd	r18, Z+11	; 0x0b
    bc68:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    bc6a:	f9 01       	movw	r30, r18
    bc6c:	82 8b       	std	Z+18, r24	; 0x12
    bc6e:	93 8b       	std	Z+19, r25	; 0x13
    bc70:	a4 8b       	std	Z+20, r26	; 0x14
    bc72:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    bc74:	f6 01       	movw	r30, r12
    bc76:	81 8d       	ldd	r24, Z+25	; 0x19
    bc78:	92 8d       	ldd	r25, Z+26	; 0x1a
    bc7a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    bc7c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    bc7e:	f8 01       	movw	r30, r16
    bc80:	23 85       	ldd	r18, Z+11	; 0x0b
    bc82:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    bc84:	f9 01       	movw	r30, r18
    bc86:	86 8b       	std	Z+22, r24	; 0x16
    bc88:	97 8b       	std	Z+23, r25	; 0x17
    bc8a:	a0 8f       	std	Z+24, r26	; 0x18
    bc8c:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    bc8e:	f6 01       	movw	r30, r12
    bc90:	85 8d       	ldd	r24, Z+29	; 0x1d
    bc92:	96 8d       	ldd	r25, Z+30	; 0x1e
    bc94:	a7 8d       	ldd	r26, Z+31	; 0x1f
    bc96:	b0 a1       	ldd	r27, Z+32	; 0x20
    bc98:	f8 01       	movw	r30, r16
    bc9a:	23 85       	ldd	r18, Z+11	; 0x0b
    bc9c:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    bc9e:	f9 01       	movw	r30, r18
    bca0:	82 8f       	std	Z+26, r24	; 0x1a
    bca2:	93 8f       	std	Z+27, r25	; 0x1b
    bca4:	a4 8f       	std	Z+28, r26	; 0x1c
    bca6:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    bca8:	f6 01       	movw	r30, r12
    bcaa:	81 a1       	ldd	r24, Z+33	; 0x21
    bcac:	92 a1       	ldd	r25, Z+34	; 0x22
    bcae:	a3 a1       	ldd	r26, Z+35	; 0x23
    bcb0:	b4 a1       	ldd	r27, Z+36	; 0x24
    bcb2:	f8 01       	movw	r30, r16
    bcb4:	23 85       	ldd	r18, Z+11	; 0x0b
    bcb6:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    bcb8:	f9 01       	movw	r30, r18
    bcba:	86 8f       	std	Z+30, r24	; 0x1e
    bcbc:	97 8f       	std	Z+31, r25	; 0x1f
    bcbe:	a0 a3       	std	Z+32, r26	; 0x20
    bcc0:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    bcc2:	f6 01       	movw	r30, r12
    bcc4:	85 a1       	ldd	r24, Z+37	; 0x25
    bcc6:	96 a1       	ldd	r25, Z+38	; 0x26
    bcc8:	a7 a1       	ldd	r26, Z+39	; 0x27
    bcca:	b0 a5       	ldd	r27, Z+40	; 0x28
    bccc:	f8 01       	movw	r30, r16
    bcce:	23 85       	ldd	r18, Z+11	; 0x0b
    bcd0:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    bcd2:	f9 01       	movw	r30, r18
    bcd4:	82 a3       	std	Z+34, r24	; 0x22
    bcd6:	93 a3       	std	Z+35, r25	; 0x23
    bcd8:	a4 a3       	std	Z+36, r26	; 0x24
    bcda:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    bcdc:	f6 01       	movw	r30, r12
    bcde:	81 a5       	ldd	r24, Z+41	; 0x29
    bce0:	92 a5       	ldd	r25, Z+42	; 0x2a
    bce2:	a3 a5       	ldd	r26, Z+43	; 0x2b
    bce4:	b4 a5       	ldd	r27, Z+44	; 0x2c
    bce6:	f8 01       	movw	r30, r16
    bce8:	23 85       	ldd	r18, Z+11	; 0x0b
    bcea:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    bcec:	f9 01       	movw	r30, r18
    bcee:	86 a3       	std	Z+38, r24	; 0x26
    bcf0:	97 a3       	std	Z+39, r25	; 0x27
    bcf2:	a0 a7       	std	Z+40, r26	; 0x28
    bcf4:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    bcf6:	f6 01       	movw	r30, r12
    bcf8:	85 a5       	ldd	r24, Z+45	; 0x2d
    bcfa:	96 a5       	ldd	r25, Z+46	; 0x2e
    bcfc:	a7 a5       	ldd	r26, Z+47	; 0x2f
    bcfe:	b0 a9       	ldd	r27, Z+48	; 0x30
    bd00:	f8 01       	movw	r30, r16
    bd02:	23 85       	ldd	r18, Z+11	; 0x0b
    bd04:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    bd06:	f9 01       	movw	r30, r18
    bd08:	82 a7       	std	Z+42, r24	; 0x2a
    bd0a:	93 a7       	std	Z+43, r25	; 0x2b
    bd0c:	a4 a7       	std	Z+44, r26	; 0x2c
    bd0e:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    bd10:	f6 01       	movw	r30, r12
    bd12:	81 a9       	ldd	r24, Z+49	; 0x31
    bd14:	92 a9       	ldd	r25, Z+50	; 0x32
    bd16:	a3 a9       	ldd	r26, Z+51	; 0x33
    bd18:	b4 a9       	ldd	r27, Z+52	; 0x34
    bd1a:	f8 01       	movw	r30, r16
    bd1c:	23 85       	ldd	r18, Z+11	; 0x0b
    bd1e:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    bd20:	f9 01       	movw	r30, r18
    bd22:	86 a7       	std	Z+46, r24	; 0x2e
    bd24:	97 a7       	std	Z+47, r25	; 0x2f
    bd26:	a0 ab       	std	Z+48, r26	; 0x30
    bd28:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    bd2a:	f6 01       	movw	r30, r12
    bd2c:	85 a9       	ldd	r24, Z+53	; 0x35
    bd2e:	96 a9       	ldd	r25, Z+54	; 0x36
    bd30:	a7 a9       	ldd	r26, Z+55	; 0x37
    bd32:	b0 ad       	ldd	r27, Z+56	; 0x38
    bd34:	f8 01       	movw	r30, r16
    bd36:	23 85       	ldd	r18, Z+11	; 0x0b
    bd38:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    bd3a:	f9 01       	movw	r30, r18
    bd3c:	82 ab       	std	Z+50, r24	; 0x32
    bd3e:	93 ab       	std	Z+51, r25	; 0x33
    bd40:	a4 ab       	std	Z+52, r26	; 0x34
    bd42:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    bd44:	f6 01       	movw	r30, r12
    bd46:	81 ad       	ldd	r24, Z+57	; 0x39
    bd48:	92 ad       	ldd	r25, Z+58	; 0x3a
    bd4a:	a3 ad       	ldd	r26, Z+59	; 0x3b
    bd4c:	b4 ad       	ldd	r27, Z+60	; 0x3c
    bd4e:	f8 01       	movw	r30, r16
    bd50:	23 85       	ldd	r18, Z+11	; 0x0b
    bd52:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    bd54:	f9 01       	movw	r30, r18
    bd56:	86 ab       	std	Z+54, r24	; 0x36
    bd58:	97 ab       	std	Z+55, r25	; 0x37
    bd5a:	a0 af       	std	Z+56, r26	; 0x38
    bd5c:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    bd5e:	f6 01       	movw	r30, r12
    bd60:	fd 96       	adiw	r30, 0x3d	; 61
    bd62:	80 81       	ld	r24, Z
    bd64:	91 81       	ldd	r25, Z+1	; 0x01
    bd66:	a2 81       	ldd	r26, Z+2	; 0x02
    bd68:	b3 81       	ldd	r27, Z+3	; 0x03
    bd6a:	f8 01       	movw	r30, r16
    bd6c:	23 85       	ldd	r18, Z+11	; 0x0b
    bd6e:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    bd70:	f9 01       	movw	r30, r18
    bd72:	82 af       	std	Z+58, r24	; 0x3a
    bd74:	93 af       	std	Z+59, r25	; 0x3b
    bd76:	a4 af       	std	Z+60, r26	; 0x3c
    bd78:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    bd7a:	f6 01       	movw	r30, r12
    bd7c:	ef 5b       	subi	r30, 0xBF	; 191
    bd7e:	ff 4f       	sbci	r31, 0xFF	; 255
    bd80:	80 81       	ld	r24, Z
    bd82:	91 81       	ldd	r25, Z+1	; 0x01
    bd84:	a2 81       	ldd	r26, Z+2	; 0x02
    bd86:	b3 81       	ldd	r27, Z+3	; 0x03
    bd88:	f8 01       	movw	r30, r16
    bd8a:	23 85       	ldd	r18, Z+11	; 0x0b
    bd8c:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    bd8e:	f9 01       	movw	r30, r18
    bd90:	fe 96       	adiw	r30, 0x3e	; 62
    bd92:	80 83       	st	Z, r24
    bd94:	91 83       	std	Z+1, r25	; 0x01
    bd96:	a2 83       	std	Z+2, r26	; 0x02
    bd98:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    bd9a:	f6 01       	movw	r30, r12
    bd9c:	eb 5b       	subi	r30, 0xBB	; 187
    bd9e:	ff 4f       	sbci	r31, 0xFF	; 255
    bda0:	80 81       	ld	r24, Z
    bda2:	91 81       	ldd	r25, Z+1	; 0x01
    bda4:	a2 81       	ldd	r26, Z+2	; 0x02
    bda6:	b3 81       	ldd	r27, Z+3	; 0x03
    bda8:	f8 01       	movw	r30, r16
    bdaa:	23 85       	ldd	r18, Z+11	; 0x0b
    bdac:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    bdae:	f9 01       	movw	r30, r18
    bdb0:	ee 5b       	subi	r30, 0xBE	; 190
    bdb2:	ff 4f       	sbci	r31, 0xFF	; 255
    bdb4:	80 83       	st	Z, r24
    bdb6:	91 83       	std	Z+1, r25	; 0x01
    bdb8:	a2 83       	std	Z+2, r26	; 0x02
    bdba:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    bdbc:	f6 01       	movw	r30, r12
    bdbe:	e7 5b       	subi	r30, 0xB7	; 183
    bdc0:	ff 4f       	sbci	r31, 0xFF	; 255
    bdc2:	80 81       	ld	r24, Z
    bdc4:	91 81       	ldd	r25, Z+1	; 0x01
    bdc6:	a2 81       	ldd	r26, Z+2	; 0x02
    bdc8:	b3 81       	ldd	r27, Z+3	; 0x03
    bdca:	f8 01       	movw	r30, r16
    bdcc:	23 85       	ldd	r18, Z+11	; 0x0b
    bdce:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    bdd0:	f9 01       	movw	r30, r18
    bdd2:	ea 5b       	subi	r30, 0xBA	; 186
    bdd4:	ff 4f       	sbci	r31, 0xFF	; 255
    bdd6:	80 83       	st	Z, r24
    bdd8:	91 83       	std	Z+1, r25	; 0x01
    bdda:	a2 83       	std	Z+2, r26	; 0x02
    bddc:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    bdde:	f6 01       	movw	r30, r12
    bde0:	e3 5b       	subi	r30, 0xB3	; 179
    bde2:	ff 4f       	sbci	r31, 0xFF	; 255
    bde4:	80 81       	ld	r24, Z
    bde6:	91 81       	ldd	r25, Z+1	; 0x01
    bde8:	a2 81       	ldd	r26, Z+2	; 0x02
    bdea:	b3 81       	ldd	r27, Z+3	; 0x03
    bdec:	f8 01       	movw	r30, r16
    bdee:	23 85       	ldd	r18, Z+11	; 0x0b
    bdf0:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    bdf2:	f9 01       	movw	r30, r18
    bdf4:	e6 5b       	subi	r30, 0xB6	; 182
    bdf6:	ff 4f       	sbci	r31, 0xFF	; 255
    bdf8:	80 83       	st	Z, r24
    bdfa:	91 83       	std	Z+1, r25	; 0x01
    bdfc:	a2 83       	std	Z+2, r26	; 0x02
    bdfe:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    be00:	f6 01       	movw	r30, r12
    be02:	ef 5a       	subi	r30, 0xAF	; 175
    be04:	ff 4f       	sbci	r31, 0xFF	; 255
    be06:	80 81       	ld	r24, Z
    be08:	91 81       	ldd	r25, Z+1	; 0x01
    be0a:	a2 81       	ldd	r26, Z+2	; 0x02
    be0c:	b3 81       	ldd	r27, Z+3	; 0x03
    be0e:	f8 01       	movw	r30, r16
    be10:	23 85       	ldd	r18, Z+11	; 0x0b
    be12:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    be14:	f9 01       	movw	r30, r18
    be16:	e2 5b       	subi	r30, 0xB2	; 178
    be18:	ff 4f       	sbci	r31, 0xFF	; 255
    be1a:	80 83       	st	Z, r24
    be1c:	91 83       	std	Z+1, r25	; 0x01
    be1e:	a2 83       	std	Z+2, r26	; 0x02
    be20:	b3 83       	std	Z+3, r27	; 0x03
				
			model->ReferenceMagYawRads(telemMsg->YawRefSetpoint);
    be22:	f6 01       	movw	r30, r12
    be24:	ef 59       	subi	r30, 0x9F	; 159
    be26:	ff 4f       	sbci	r31, 0xFF	; 255
    be28:	80 81       	ld	r24, Z
    be2a:	91 81       	ldd	r25, Z+1	; 0x01
    be2c:	a2 81       	ldd	r26, Z+2	; 0x02
    be2e:	b3 81       	ldd	r27, Z+3	; 0x03
    be30:	f8 01       	movw	r30, r16
    be32:	21 85       	ldd	r18, Z+9	; 0x09
    be34:	32 85       	ldd	r19, Z+10	; 0x0a
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    be36:	f9 01       	movw	r30, r18
    be38:	86 83       	std	Z+6, r24	; 0x06
    be3a:	97 83       	std	Z+7, r25	; 0x07
    be3c:	a0 87       	std	Z+8, r26	; 0x08
    be3e:	b1 87       	std	Z+9, r27	; 0x09
			model->ReferenceXNEDLocalFrameCm(telemMsg->XRefSetpoint);
    be40:	f6 01       	movw	r30, r12
    be42:	eb 5a       	subi	r30, 0xAB	; 171
    be44:	ff 4f       	sbci	r31, 0xFF	; 255
    be46:	80 81       	ld	r24, Z
    be48:	91 81       	ldd	r25, Z+1	; 0x01
    be4a:	a2 81       	ldd	r26, Z+2	; 0x02
    be4c:	b3 81       	ldd	r27, Z+3	; 0x03
    be4e:	f8 01       	movw	r30, r16
    be50:	21 85       	ldd	r18, Z+9	; 0x09
    be52:	32 85       	ldd	r19, Z+10	; 0x0a
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    be54:	f9 01       	movw	r30, r18
    be56:	86 a3       	std	Z+38, r24	; 0x26
    be58:	97 a3       	std	Z+39, r25	; 0x27
    be5a:	a0 a7       	std	Z+40, r26	; 0x28
    be5c:	b1 a7       	std	Z+41, r27	; 0x29
			model->ReferenceYNEDLocalFrameCm(telemMsg->YRefSetpoint);
    be5e:	f6 01       	movw	r30, r12
    be60:	e7 5a       	subi	r30, 0xA7	; 167
    be62:	ff 4f       	sbci	r31, 0xFF	; 255
    be64:	80 81       	ld	r24, Z
    be66:	91 81       	ldd	r25, Z+1	; 0x01
    be68:	a2 81       	ldd	r26, Z+2	; 0x02
    be6a:	b3 81       	ldd	r27, Z+3	; 0x03
    be6c:	f8 01       	movw	r30, r16
    be6e:	21 85       	ldd	r18, Z+9	; 0x09
    be70:	32 85       	ldd	r19, Z+10	; 0x0a

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    be72:	f9 01       	movw	r30, r18
    be74:	ee 5a       	subi	r30, 0xAE	; 174
    be76:	ff 4f       	sbci	r31, 0xFF	; 255
    be78:	80 83       	st	Z, r24
    be7a:	91 83       	std	Z+1, r25	; 0x01
    be7c:	a2 83       	std	Z+2, r26	; 0x02
    be7e:	b3 83       	std	Z+3, r27	; 0x03
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
    be80:	f6 01       	movw	r30, r12
    be82:	e3 5a       	subi	r30, 0xA3	; 163
    be84:	ff 4f       	sbci	r31, 0xFF	; 255
    be86:	80 81       	ld	r24, Z
    be88:	91 81       	ldd	r25, Z+1	; 0x01
    be8a:	a2 81       	ldd	r26, Z+2	; 0x02
    be8c:	b3 81       	ldd	r27, Z+3	; 0x03
    be8e:	f8 01       	movw	r30, r16
    be90:	21 85       	ldd	r18, Z+9	; 0x09
    be92:	32 85       	ldd	r19, Z+10	; 0x0a
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    be94:	f9 01       	movw	r30, r18
    be96:	ee 57       	subi	r30, 0x7E	; 126
    be98:	ff 4f       	sbci	r31, 0xFF	; 255
    be9a:	80 83       	st	Z, r24
    be9c:	91 83       	std	Z+1, r25	; 0x01
    be9e:	a2 83       	std	Z+2, r26	; 0x02
    bea0:	b3 83       	std	Z+3, r27	; 0x03
		}
			
	}
		
	if (message != NULL)
    bea2:	cf 80       	ldd	r12, Y+7	; 0x07
    bea4:	d8 84       	ldd	r13, Y+8	; 0x08
    bea6:	c1 14       	cp	r12, r1
    bea8:	d1 04       	cpc	r13, r1
    beaa:	09 f4       	brne	.+2      	; 0xbeae <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    beac:	6c c0       	rjmp	.+216    	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		delete message;
    beae:	d6 01       	movw	r26, r12
    beb0:	ed 91       	ld	r30, X+
    beb2:	fc 91       	ld	r31, X
    beb4:	02 80       	ldd	r0, Z+2	; 0x02
    beb6:	f3 81       	ldd	r31, Z+3	; 0x03
    beb8:	e0 2d       	mov	r30, r0
    beba:	c6 01       	movw	r24, r12
    bebc:	19 95       	eicall
		message = NULL;
    bebe:	18 86       	std	Y+8, r1	; 0x08
    bec0:	1f 82       	std	Y+7, r1	; 0x07
	}

	
	//Update instrumentation fields
	switch (status)
    bec2:	bd ef       	ldi	r27, 0xFD	; 253
    bec4:	eb 16       	cp	r14, r27
    bec6:	bf ef       	ldi	r27, 0xFF	; 255
    bec8:	fb 06       	cpc	r15, r27
    beca:	b9 f1       	breq	.+110    	; 0xbf3a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x824>
    becc:	3c f4       	brge	.+14     	; 0xbedc <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c6>
    bece:	fc ef       	ldi	r31, 0xFC	; 252
    bed0:	ef 16       	cp	r14, r31
    bed2:	ff ef       	ldi	r31, 0xFF	; 255
    bed4:	ff 06       	cpc	r15, r31
    bed6:	09 f0       	breq	.+2      	; 0xbeda <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c4>
    bed8:	56 c0       	rjmp	.+172    	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
    beda:	42 c0       	rjmp	.+132    	; 0xbf60 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x84a>
    bedc:	8e ef       	ldi	r24, 0xFE	; 254
    bede:	e8 16       	cp	r14, r24
    bee0:	8f ef       	ldi	r24, 0xFF	; 255
    bee2:	f8 06       	cpc	r15, r24
    bee4:	b9 f0       	breq	.+46     	; 0xbf14 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7fe>
    bee6:	ef 20       	and	r14, r15
    bee8:	e0 94       	com	r14
    beea:	09 f0       	breq	.+2      	; 0xbeee <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7d8>
    beec:	4c c0       	rjmp	.+152    	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		case 0:
		break;
		case -1:
		model->Timeouts(model->Timeouts() + 1);
    beee:	d8 01       	movw	r26, r16
    bef0:	19 96       	adiw	r26, 0x09	; 9
    bef2:	ed 91       	ld	r30, X+
    bef4:	fc 91       	ld	r31, X
    bef6:	1a 97       	sbiw	r26, 0x0a	; 10
			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
    bef8:	e6 55       	subi	r30, 0x56	; 86
    befa:	ff 4f       	sbci	r31, 0xFF	; 255
    befc:	80 81       	ld	r24, Z
    befe:	91 81       	ldd	r25, Z+1	; 0x01
    bf00:	a2 81       	ldd	r26, Z+2	; 0x02
    bf02:	b3 81       	ldd	r27, Z+3	; 0x03
    bf04:	01 96       	adiw	r24, 0x01	; 1
    bf06:	a1 1d       	adc	r26, r1
    bf08:	b1 1d       	adc	r27, r1
    bf0a:	80 83       	st	Z, r24
    bf0c:	91 83       	std	Z+1, r25	; 0x01
    bf0e:	a2 83       	std	Z+2, r26	; 0x02
    bf10:	b3 83       	std	Z+3, r27	; 0x03
    bf12:	39 c0       	rjmp	.+114    	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -2:
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns() + 1);
    bf14:	d8 01       	movw	r26, r16
    bf16:	19 96       	adiw	r26, 0x09	; 9
    bf18:	ed 91       	ld	r30, X+
    bf1a:	fc 91       	ld	r31, X
    bf1c:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    bf1e:	e6 54       	subi	r30, 0x46	; 70
    bf20:	ff 4f       	sbci	r31, 0xFF	; 255
    bf22:	80 81       	ld	r24, Z
    bf24:	91 81       	ldd	r25, Z+1	; 0x01
    bf26:	a2 81       	ldd	r26, Z+2	; 0x02
    bf28:	b3 81       	ldd	r27, Z+3	; 0x03
    bf2a:	01 96       	adiw	r24, 0x01	; 1
    bf2c:	a1 1d       	adc	r26, r1
    bf2e:	b1 1d       	adc	r27, r1
    bf30:	80 83       	st	Z, r24
    bf32:	91 83       	std	Z+1, r25	; 0x01
    bf34:	a2 83       	std	Z+2, r26	; 0x02
    bf36:	b3 83       	std	Z+3, r27	; 0x03
    bf38:	26 c0       	rjmp	.+76     	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -3:
		model->UnrecognizedMsgTypes(model->UnrecognizedMsgTypes() + 1);
    bf3a:	d8 01       	movw	r26, r16
    bf3c:	19 96       	adiw	r26, 0x09	; 9
    bf3e:	ed 91       	ld	r30, X+
    bf40:	fc 91       	ld	r31, X
    bf42:	1a 97       	sbiw	r26, 0x0a	; 10
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
    bf44:	e2 55       	subi	r30, 0x52	; 82
    bf46:	ff 4f       	sbci	r31, 0xFF	; 255
    bf48:	80 81       	ld	r24, Z
    bf4a:	91 81       	ldd	r25, Z+1	; 0x01
    bf4c:	a2 81       	ldd	r26, Z+2	; 0x02
    bf4e:	b3 81       	ldd	r27, Z+3	; 0x03
    bf50:	01 96       	adiw	r24, 0x01	; 1
    bf52:	a1 1d       	adc	r26, r1
    bf54:	b1 1d       	adc	r27, r1
    bf56:	80 83       	st	Z, r24
    bf58:	91 83       	std	Z+1, r25	; 0x01
    bf5a:	a2 83       	std	Z+2, r26	; 0x02
    bf5c:	b3 83       	std	Z+3, r27	; 0x03
    bf5e:	13 c0       	rjmp	.+38     	; 0xbf86 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -4:
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    bf60:	d8 01       	movw	r26, r16
    bf62:	19 96       	adiw	r26, 0x09	; 9
    bf64:	ed 91       	ld	r30, X+
    bf66:	fc 91       	ld	r31, X
    bf68:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    bf6a:	ee 54       	subi	r30, 0x4E	; 78
    bf6c:	ff 4f       	sbci	r31, 0xFF	; 255
    bf6e:	40 81       	ld	r20, Z
    bf70:	51 81       	ldd	r21, Z+1	; 0x01
    bf72:	62 81       	ldd	r22, Z+2	; 0x02
    bf74:	73 81       	ldd	r23, Z+3	; 0x03
    bf76:	4f 5f       	subi	r20, 0xFF	; 255
    bf78:	5f 4f       	sbci	r21, 0xFF	; 255
    bf7a:	6f 4f       	sbci	r22, 0xFF	; 255
    bf7c:	7f 4f       	sbci	r23, 0xFF	; 255
    bf7e:	40 83       	st	Z, r20
    bf80:	51 83       	std	Z+1, r21	; 0x01
    bf82:	62 83       	std	Z+2, r22	; 0x02
    bf84:	73 83       	std	Z+3, r23	; 0x03
	
	
	//Send sync message to indicate to the ground control station that we are ready to receive data.
	//Without this sync message, the GCS could send data while the FC is asleep, which would cause the data
	//to overflow the usart buffer.
	SyncMessage syncMsg(dataToReceive);
    bf86:	f8 01       	movw	r30, r16
    bf88:	25 85       	ldd	r18, Z+13	; 0x0d
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    bf8a:	83 e0       	ldi	r24, 0x03	; 3
    bf8c:	8b 83       	std	Y+3, r24	; 0x03
    bf8e:	82 e0       	ldi	r24, 0x02	; 2
    bf90:	90 e0       	ldi	r25, 0x00	; 0
    bf92:	9d 83       	std	Y+5, r25	; 0x05
    bf94:	8c 83       	std	Y+4, r24	; 0x04
				byte RequestedMessage;
							
				static const byte MessageSize =
					sizeof(msgType) + sizeof(RequestedMessage);
							
				SyncMessage(byte requestedMessage): Message(MessageType,MessageSize), RequestedMessage(requestedMessage)
    bf96:	84 e7       	ldi	r24, 0x74	; 116
    bf98:	92 e0       	ldi	r25, 0x02	; 2
    bf9a:	9a 83       	std	Y+2, r25	; 0x02
    bf9c:	89 83       	std	Y+1, r24	; 0x01
    bf9e:	2e 83       	std	Y+6, r18	; 0x06
	
	//Send this out after receiving data so if there is asynchronous processing, the system doesn't try to
	//read a partial message that might have actually been transmitted just after sending the transmit message.
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
    bfa0:	be 01       	movw	r22, r28
    bfa2:	6f 5f       	subi	r22, 0xFF	; 255
    bfa4:	7f 4f       	sbci	r23, 0xFF	; 255
    bfa6:	87 81       	ldd	r24, Z+7	; 0x07
    bfa8:	90 85       	ldd	r25, Z+8	; 0x08
    bfaa:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    bfae:	89 2b       	or	r24, r25
    bfb0:	d1 f0       	breq	.+52     	; 0xbfe6 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    bfb2:	d8 01       	movw	r26, r16
    bfb4:	19 96       	adiw	r26, 0x09	; 9
    bfb6:	ed 91       	ld	r30, X+
    bfb8:	fc 91       	ld	r31, X
    bfba:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    bfbc:	e6 54       	subi	r30, 0x46	; 70
    bfbe:	ff 4f       	sbci	r31, 0xFF	; 255
    bfc0:	80 81       	ld	r24, Z
    bfc2:	91 81       	ldd	r25, Z+1	; 0x01
    bfc4:	a2 81       	ldd	r26, Z+2	; 0x02
    bfc6:	b3 81       	ldd	r27, Z+3	; 0x03
    bfc8:	01 96       	adiw	r24, 0x01	; 1
    bfca:	a1 1d       	adc	r26, r1
    bfcc:	b1 1d       	adc	r27, r1
    bfce:	80 83       	st	Z, r24
    bfd0:	91 83       	std	Z+1, r25	; 0x01
    bfd2:	a2 83       	std	Z+2, r26	; 0x02
    bfd4:	b3 83       	std	Z+3, r27	; 0x03
    bfd6:	07 c0       	rjmp	.+14     	; 0xbfe6 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
		}
			
	}
		
	if (message != NULL)
    bfd8:	cf 80       	ldd	r12, Y+7	; 0x07
    bfda:	d8 84       	ldd	r13, Y+8	; 0x08
    bfdc:	c1 14       	cp	r12, r1
    bfde:	d1 04       	cpc	r13, r1
    bfe0:	09 f0       	breq	.+2      	; 0xbfe4 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8ce>
    bfe2:	65 cf       	rjmp	.-310    	; 0xbeae <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    bfe4:	6e cf       	rjmp	.-292    	; 0xbec2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7ac>
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
	}
}
    bfe6:	28 96       	adiw	r28, 0x08	; 8
    bfe8:	0f b6       	in	r0, 0x3f	; 63
    bfea:	f8 94       	cli
    bfec:	de bf       	out	0x3e, r29	; 62
    bfee:	0f be       	out	0x3f, r0	; 63
    bff0:	cd bf       	out	0x3d, r28	; 61
    bff2:	df 91       	pop	r29
    bff4:	cf 91       	pop	r28
    bff6:	1f 91       	pop	r17
    bff8:	0f 91       	pop	r16
    bffa:	ff 90       	pop	r15
    bffc:	ef 90       	pop	r14
    bffe:	df 90       	pop	r13
    c000:	cf 90       	pop	r12
    c002:	08 95       	ret

0000c004 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>:
#include "GainsMessage.h"

using namespace helicopter::tasks;
using namespace helicopter::messages;

SimTelemetryTask::SimTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, PIDController *pidController,  DATATORECEIVE dataToReceive, int delay, int period) :
    c004:	6f 92       	push	r6
    c006:	7f 92       	push	r7
    c008:	8f 92       	push	r8
    c00a:	9f 92       	push	r9
    c00c:	af 92       	push	r10
    c00e:	bf 92       	push	r11
    c010:	cf 92       	push	r12
    c012:	df 92       	push	r13
    c014:	ef 92       	push	r14
    c016:	ff 92       	push	r15
    c018:	0f 93       	push	r16
    c01a:	cf 93       	push	r28
    c01c:	df 93       	push	r29
    c01e:	ec 01       	movw	r28, r24
    c020:	3b 01       	movw	r6, r22
    c022:	4a 01       	movw	r8, r20
    c024:	59 01       	movw	r10, r18
    c026:	b7 01       	movw	r22, r14
    c028:	a6 01       	movw	r20, r12
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	pidController(pidController),
	dataToReceive(dataToReceive)
    c02a:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    c02e:	88 e6       	ldi	r24, 0x68	; 104
    c030:	93 e0       	ldi	r25, 0x03	; 3
    c032:	99 83       	std	Y+1, r25	; 0x01
    c034:	88 83       	st	Y, r24
    c036:	78 86       	std	Y+8, r7	; 0x08
    c038:	6f 82       	std	Y+7, r6	; 0x07
    c03a:	9a 86       	std	Y+10, r9	; 0x0a
    c03c:	89 86       	std	Y+9, r8	; 0x09
    c03e:	bc 86       	std	Y+12, r11	; 0x0c
    c040:	ab 86       	std	Y+11, r10	; 0x0b
    c042:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    c044:	df 91       	pop	r29
    c046:	cf 91       	pop	r28
    c048:	0f 91       	pop	r16
    c04a:	ff 90       	pop	r15
    c04c:	ef 90       	pop	r14
    c04e:	df 90       	pop	r13
    c050:	cf 90       	pop	r12
    c052:	bf 90       	pop	r11
    c054:	af 90       	pop	r10
    c056:	9f 90       	pop	r9
    c058:	8f 90       	pop	r8
    c05a:	7f 90       	pop	r7
    c05c:	6f 90       	pop	r6
    c05e:	08 95       	ret

0000c060 <_ZN10helicopter5tasks4Task11runTaskImplEv>:
				
			protected:
				/**
				* Implemented by subclasses for the actual logic to execute
				*/
				virtual void runTaskImpl(){;}
    c060:	08 95       	ret

0000c062 <_ZN10helicopter5tasks4TaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    c062:	26 e7       	ldi	r18, 0x76	; 118
    c064:	33 e0       	ldi	r19, 0x03	; 3
    c066:	fc 01       	movw	r30, r24
    c068:	31 83       	std	Z+1, r19	; 0x01
    c06a:	20 83       	st	Z, r18
    c06c:	08 95       	ret

0000c06e <_ZN10helicopter5tasks4Task7runTaskEv>:
{
	//Disable interrupts 
	//cli(); //removed because gps serial driver will miss a lot of bytes notifications if a task runs for a long time.
	
	//run task
	this->runTaskImpl();
    c06e:	dc 01       	movw	r26, r24
    c070:	ed 91       	ld	r30, X+
    c072:	fc 91       	ld	r31, X
    c074:	01 90       	ld	r0, Z+
    c076:	f0 81       	ld	r31, Z
    c078:	e0 2d       	mov	r30, r0
    c07a:	19 95       	eicall
    c07c:	08 95       	ret

0000c07e <_ZN10helicopter5tasks4TaskD0Ev>:
    c07e:	26 e7       	ldi	r18, 0x76	; 118
    c080:	33 e0       	ldi	r19, 0x03	; 3
    c082:	fc 01       	movw	r30, r24
    c084:	31 83       	std	Z+1, r19	; 0x01
    c086:	20 83       	st	Z, r18
    c088:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    c08c:	08 95       	ret

0000c08e <_ZN10helicopter5tasks4TaskC1Eii>:
#include <avr/interrupt.h>
#include "Task.h"

using namespace helicopter::tasks;

Task::Task(int delay, int period)
    c08e:	fc 01       	movw	r30, r24
    c090:	86 e7       	ldi	r24, 0x76	; 118
    c092:	93 e0       	ldi	r25, 0x03	; 3
    c094:	91 83       	std	Z+1, r25	; 0x01
    c096:	80 83       	st	Z, r24
{
	this->delay = delay;
    c098:	73 83       	std	Z+3, r23	; 0x03
    c09a:	62 83       	std	Z+2, r22	; 0x02
	this->period = period;
    c09c:	55 83       	std	Z+5, r21	; 0x05
    c09e:	44 83       	std	Z+4, r20	; 0x04
	this->isReadyToRun = false;
    c0a0:	16 82       	std	Z+6, r1	; 0x06
    c0a2:	08 95       	ret

0000c0a4 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>:
    c0a4:	26 e7       	ldi	r18, 0x76	; 118
    c0a6:	33 e0       	ldi	r19, 0x03	; 3
    c0a8:	fc 01       	movw	r30, r24
    c0aa:	31 83       	std	Z+1, r19	; 0x01
    c0ac:	20 83       	st	Z, r18
    c0ae:	08 95       	ret

0000c0b0 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>:
    c0b0:	26 e7       	ldi	r18, 0x76	; 118
    c0b2:	33 e0       	ldi	r19, 0x03	; 3
    c0b4:	fc 01       	movw	r30, r24
    c0b6:	31 83       	std	Z+1, r19	; 0x01
    c0b8:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class transmits flight computer telemetry information to the ground control station.
		 */
		class TransmitTelemetryTask : public Task
    c0ba:	0e 94 85 64 	call	0xc90a	; 0xc90a <_ZdlPv>
    c0be:	08 95       	ret

0000c0c0 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>:
	
}


void TransmitTelemetryTask::runTaskImpl()
{
    c0c0:	2f 92       	push	r2
    c0c2:	3f 92       	push	r3
    c0c4:	4f 92       	push	r4
    c0c6:	5f 92       	push	r5
    c0c8:	6f 92       	push	r6
    c0ca:	7f 92       	push	r7
    c0cc:	8f 92       	push	r8
    c0ce:	9f 92       	push	r9
    c0d0:	af 92       	push	r10
    c0d2:	bf 92       	push	r11
    c0d4:	cf 92       	push	r12
    c0d6:	df 92       	push	r13
    c0d8:	ef 92       	push	r14
    c0da:	ff 92       	push	r15
    c0dc:	0f 93       	push	r16
    c0de:	1f 93       	push	r17
    c0e0:	cf 93       	push	r28
    c0e2:	df 93       	push	r29
    c0e4:	cd b7       	in	r28, 0x3d	; 61
    c0e6:	de b7       	in	r29, 0x3e	; 62
    c0e8:	60 97       	sbiw	r28, 0x10	; 16
    c0ea:	0f b6       	in	r0, 0x3f	; 63
    c0ec:	f8 94       	cli
    c0ee:	de bf       	out	0x3e, r29	; 62
    c0f0:	0f be       	out	0x3f, r0	; 63
    c0f2:	cd bf       	out	0x3d, r28	; 61
    c0f4:	9c 87       	std	Y+12, r25	; 0x0c
    c0f6:	8b 87       	std	Y+11, r24	; 0x0b
		model->YawRads(yawRads);
		model->PitchRads(-asin(model->Ahrs()->dcm[2][0]));
		model->RollRads(atan2(model->Ahrs()->dcm[2][1], model->Ahrs()->dcm[2][2]));
	}*/
	
	if (dataToSend == ALLDATA)
    c0f8:	dc 01       	movw	r26, r24
    c0fa:	1b 96       	adiw	r26, 0x0b	; 11
    c0fc:	8c 91       	ld	r24, X
    c0fe:	1b 97       	sbiw	r26, 0x0b	; 11
    c100:	81 11       	cpse	r24, r1
    c102:	31 c0       	rjmp	.+98     	; 0xc166 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xa6>
	{
		//SystemTelemetryMessage *message = model->CreateTelemetryMessage();
		SystemTelemetryMessage *message = SystemTelemetryMessage::buildMessageFromModel(model);
    c104:	19 96       	adiw	r26, 0x09	; 9
    c106:	8d 91       	ld	r24, X+
    c108:	9c 91       	ld	r25, X
    c10a:	1a 97       	sbiw	r26, 0x0a	; 10
    c10c:	0e 94 22 37 	call	0x6e44	; 0x6e44 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>
    c110:	8c 01       	movw	r16, r24
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();
*/	
	
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    c112:	bc 01       	movw	r22, r24
    c114:	eb 85       	ldd	r30, Y+11	; 0x0b
    c116:	fc 85       	ldd	r31, Y+12	; 0x0c
    c118:	87 81       	ldd	r24, Z+7	; 0x07
    c11a:	90 85       	ldd	r25, Z+8	; 0x08
    c11c:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c120:	89 2b       	or	r24, r25
    c122:	a1 f0       	breq	.+40     	; 0xc14c <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x8c>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c124:	ab 85       	ldd	r26, Y+11	; 0x0b
    c126:	bc 85       	ldd	r27, Y+12	; 0x0c
    c128:	19 96       	adiw	r26, 0x09	; 9
    c12a:	ed 91       	ld	r30, X+
    c12c:	fc 91       	ld	r31, X
    c12e:	1a 97       	sbiw	r26, 0x0a	; 10
    c130:	e6 54       	subi	r30, 0x46	; 70
    c132:	ff 4f       	sbci	r31, 0xFF	; 255
    c134:	40 81       	ld	r20, Z
    c136:	51 81       	ldd	r21, Z+1	; 0x01
    c138:	62 81       	ldd	r22, Z+2	; 0x02
    c13a:	73 81       	ldd	r23, Z+3	; 0x03
    c13c:	4f 5f       	subi	r20, 0xFF	; 255
    c13e:	5f 4f       	sbci	r21, 0xFF	; 255
    c140:	6f 4f       	sbci	r22, 0xFF	; 255
    c142:	7f 4f       	sbci	r23, 0xFF	; 255
    c144:	40 83       	st	Z, r20
    c146:	51 83       	std	Z+1, r21	; 0x01
    c148:	62 83       	std	Z+2, r22	; 0x02
    c14a:	73 83       	std	Z+3, r23	; 0x03
		}
	
		delete message;
    c14c:	01 15       	cp	r16, r1
    c14e:	11 05       	cpc	r17, r1
    c150:	09 f4       	brne	.+2      	; 0xc154 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x94>
    c152:	97 c3       	rjmp	.+1838   	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c154:	d8 01       	movw	r26, r16
    c156:	ed 91       	ld	r30, X+
    c158:	fc 91       	ld	r31, X
    c15a:	02 80       	ldd	r0, Z+2	; 0x02
    c15c:	f3 81       	ldd	r31, Z+3	; 0x03
    c15e:	e0 2d       	mov	r30, r0
    c160:	c8 01       	movw	r24, r16
    c162:	19 95       	eicall
    c164:	8e c3       	rjmp	.+1820   	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
	}else if (dataToSend == CONTROLDATA)
    c166:	81 30       	cpi	r24, 0x01	; 1
    c168:	09 f0       	breq	.+2      	; 0xc16c <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xac>
    c16a:	89 c0       	rjmp	.+274    	; 0xc27e <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1be>
	{
		ControlMessage *message = new ControlMessage();
    c16c:	85 e1       	ldi	r24, 0x15	; 21
    c16e:	90 e0       	ldi	r25, 0x00	; 0
    c170:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    c174:	8c 01       	movw	r16, r24
    c176:	85 e0       	ldi	r24, 0x05	; 5
    c178:	f8 01       	movw	r30, r16
    c17a:	82 83       	std	Z+2, r24	; 0x02
    c17c:	81 e1       	ldi	r24, 0x11	; 17
    c17e:	90 e0       	ldi	r25, 0x00	; 0
    c180:	94 83       	std	Z+4, r25	; 0x04
    c182:	83 83       	std	Z+3, r24	; 0x03
				
				ControlMessage(): Message(MessageType,MessageSize),
					MainRotorCollectiveControl(0),
					YawControl(0),
					LongitudeControl(0),
					LateralControl(0)
    c184:	88 e3       	ldi	r24, 0x38	; 56
    c186:	92 e0       	ldi	r25, 0x02	; 2
    c188:	91 83       	std	Z+1, r25	; 0x01
    c18a:	80 83       	st	Z, r24
    c18c:	15 82       	std	Z+5, r1	; 0x05
    c18e:	16 82       	std	Z+6, r1	; 0x06
    c190:	17 82       	std	Z+7, r1	; 0x07
    c192:	10 86       	std	Z+8, r1	; 0x08
    c194:	11 86       	std	Z+9, r1	; 0x09
    c196:	12 86       	std	Z+10, r1	; 0x0a
    c198:	13 86       	std	Z+11, r1	; 0x0b
    c19a:	14 86       	std	Z+12, r1	; 0x0c
    c19c:	15 86       	std	Z+13, r1	; 0x0d
    c19e:	16 86       	std	Z+14, r1	; 0x0e
    c1a0:	17 86       	std	Z+15, r1	; 0x0f
    c1a2:	10 8a       	std	Z+16, r1	; 0x10
    c1a4:	11 8a       	std	Z+17, r1	; 0x11
    c1a6:	12 8a       	std	Z+18, r1	; 0x12
    c1a8:	13 8a       	std	Z+19, r1	; 0x13
    c1aa:	14 8a       	std	Z+20, r1	; 0x14
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    c1ac:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1ae:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1b0:	19 96       	adiw	r26, 0x09	; 9
    c1b2:	ed 91       	ld	r30, X+
    c1b4:	fc 91       	ld	r31, X
    c1b6:	1a 97       	sbiw	r26, 0x0a	; 10
    c1b8:	e6 5a       	subi	r30, 0xA6	; 166
    c1ba:	ff 4f       	sbci	r31, 0xFF	; 255
    c1bc:	80 81       	ld	r24, Z
    c1be:	91 81       	ldd	r25, Z+1	; 0x01
    c1c0:	a2 81       	ldd	r26, Z+2	; 0x02
    c1c2:	b3 81       	ldd	r27, Z+3	; 0x03
		message->LateralControl = model->LateralControl();
    c1c4:	f8 01       	movw	r30, r16
    c1c6:	81 8b       	std	Z+17, r24	; 0x11
    c1c8:	92 8b       	std	Z+18, r25	; 0x12
    c1ca:	a3 8b       	std	Z+19, r26	; 0x13
    c1cc:	b4 8b       	std	Z+20, r27	; 0x14
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    c1ce:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1d0:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1d2:	19 96       	adiw	r26, 0x09	; 9
    c1d4:	ed 91       	ld	r30, X+
    c1d6:	fc 91       	ld	r31, X
    c1d8:	1a 97       	sbiw	r26, 0x0a	; 10
    c1da:	86 a5       	ldd	r24, Z+46	; 0x2e
    c1dc:	97 a5       	ldd	r25, Z+47	; 0x2f
    c1de:	a0 a9       	ldd	r26, Z+48	; 0x30
    c1e0:	b1 a9       	ldd	r27, Z+49	; 0x31
		message->LongitudeControl = model->LongitudeControl();
    c1e2:	f8 01       	movw	r30, r16
    c1e4:	85 87       	std	Z+13, r24	; 0x0d
    c1e6:	96 87       	std	Z+14, r25	; 0x0e
    c1e8:	a7 87       	std	Z+15, r26	; 0x0f
    c1ea:	b0 8b       	std	Z+16, r27	; 0x10

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    c1ec:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1ee:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1f0:	19 96       	adiw	r26, 0x09	; 9
    c1f2:	ed 91       	ld	r30, X+
    c1f4:	fc 91       	ld	r31, X
    c1f6:	1a 97       	sbiw	r26, 0x0a	; 10
    c1f8:	ea 57       	subi	r30, 0x7A	; 122
    c1fa:	ff 4f       	sbci	r31, 0xFF	; 255
    c1fc:	80 81       	ld	r24, Z
    c1fe:	91 81       	ldd	r25, Z+1	; 0x01
    c200:	a2 81       	ldd	r26, Z+2	; 0x02
    c202:	b3 81       	ldd	r27, Z+3	; 0x03
		message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    c204:	f8 01       	movw	r30, r16
    c206:	85 83       	std	Z+5, r24	; 0x05
    c208:	96 83       	std	Z+6, r25	; 0x06
    c20a:	a7 83       	std	Z+7, r26	; 0x07
    c20c:	b0 87       	std	Z+8, r27	; 0x08
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    c20e:	ab 85       	ldd	r26, Y+11	; 0x0b
    c210:	bc 85       	ldd	r27, Y+12	; 0x0c
    c212:	19 96       	adiw	r26, 0x09	; 9
    c214:	ed 91       	ld	r30, X+
    c216:	fc 91       	ld	r31, X
    c218:	1a 97       	sbiw	r26, 0x0a	; 10
    c21a:	42 85       	ldd	r20, Z+10	; 0x0a
    c21c:	53 85       	ldd	r21, Z+11	; 0x0b
    c21e:	64 85       	ldd	r22, Z+12	; 0x0c
    c220:	75 85       	ldd	r23, Z+13	; 0x0d
		message->YawControl = model->YawControl();
    c222:	f8 01       	movw	r30, r16
    c224:	41 87       	std	Z+9, r20	; 0x09
    c226:	52 87       	std	Z+10, r21	; 0x0a
    c228:	63 87       	std	Z+11, r22	; 0x0b
    c22a:	74 87       	std	Z+12, r23	; 0x0c
		
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    c22c:	b8 01       	movw	r22, r16
    c22e:	17 96       	adiw	r26, 0x07	; 7
    c230:	8d 91       	ld	r24, X+
    c232:	9c 91       	ld	r25, X
    c234:	18 97       	sbiw	r26, 0x08	; 8
    c236:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c23a:	89 2b       	or	r24, r25
    c23c:	99 f0       	breq	.+38     	; 0xc264 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1a4>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c23e:	ab 85       	ldd	r26, Y+11	; 0x0b
    c240:	bc 85       	ldd	r27, Y+12	; 0x0c
    c242:	19 96       	adiw	r26, 0x09	; 9
    c244:	ed 91       	ld	r30, X+
    c246:	fc 91       	ld	r31, X
    c248:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    c24a:	e6 54       	subi	r30, 0x46	; 70
    c24c:	ff 4f       	sbci	r31, 0xFF	; 255
    c24e:	80 81       	ld	r24, Z
    c250:	91 81       	ldd	r25, Z+1	; 0x01
    c252:	a2 81       	ldd	r26, Z+2	; 0x02
    c254:	b3 81       	ldd	r27, Z+3	; 0x03
    c256:	01 96       	adiw	r24, 0x01	; 1
    c258:	a1 1d       	adc	r26, r1
    c25a:	b1 1d       	adc	r27, r1
    c25c:	80 83       	st	Z, r24
    c25e:	91 83       	std	Z+1, r25	; 0x01
    c260:	a2 83       	std	Z+2, r26	; 0x02
    c262:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		delete message;		
    c264:	01 15       	cp	r16, r1
    c266:	11 05       	cpc	r17, r1
    c268:	09 f4       	brne	.+2      	; 0xc26c <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1ac>
    c26a:	0b c3       	rjmp	.+1558   	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c26c:	d8 01       	movw	r26, r16
    c26e:	ed 91       	ld	r30, X+
    c270:	fc 91       	ld	r31, X
    c272:	02 80       	ldd	r0, Z+2	; 0x02
    c274:	f3 81       	ldd	r31, Z+3	; 0x03
    c276:	e0 2d       	mov	r30, r0
    c278:	c8 01       	movw	r24, r16
    c27a:	19 95       	eicall
    c27c:	02 c3       	rjmp	.+1540   	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
		}else if (dataToSend == SIMPLEDATA)
    c27e:	82 30       	cpi	r24, 0x02	; 2
    c280:	09 f0       	breq	.+2      	; 0xc284 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1c4>
    c282:	ff c2       	rjmp	.+1534   	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
		{
			SimpleTelemetryMessage *message = new SimpleTelemetryMessage();
    c284:	8d e7       	ldi	r24, 0x7D	; 125
    c286:	90 e0       	ldi	r25, 0x00	; 0
    c288:	0e 94 82 64 	call	0xc904	; 0xc904 <_Znwj>
    c28c:	8c 01       	movw	r16, r24
    c28e:	86 e0       	ldi	r24, 0x06	; 6
    c290:	f8 01       	movw	r30, r16
    c292:	82 83       	std	Z+2, r24	; 0x02
    c294:	89 e7       	ldi	r24, 0x79	; 121
    c296:	90 e0       	ldi	r25, 0x00	; 0
    c298:	94 83       	std	Z+4, r25	; 0x04
    c29a:	83 83       	std	Z+3, r24	; 0x03
    c29c:	88 e6       	ldi	r24, 0x68	; 104
    c29e:	92 e0       	ldi	r25, 0x02	; 2
    c2a0:	91 83       	std	Z+1, r25	; 0x01
    c2a2:	80 83       	st	Z, r24
    c2a4:	15 82       	std	Z+5, r1	; 0x05
    c2a6:	16 82       	std	Z+6, r1	; 0x06
    c2a8:	17 82       	std	Z+7, r1	; 0x07
    c2aa:	10 86       	std	Z+8, r1	; 0x08
    c2ac:	11 86       	std	Z+9, r1	; 0x09
    c2ae:	12 86       	std	Z+10, r1	; 0x0a
    c2b0:	13 86       	std	Z+11, r1	; 0x0b
    c2b2:	14 86       	std	Z+12, r1	; 0x0c
    c2b4:	15 86       	std	Z+13, r1	; 0x0d
    c2b6:	16 86       	std	Z+14, r1	; 0x0e
    c2b8:	17 86       	std	Z+15, r1	; 0x0f
    c2ba:	10 8a       	std	Z+16, r1	; 0x10
    c2bc:	11 8a       	std	Z+17, r1	; 0x11
    c2be:	12 8a       	std	Z+18, r1	; 0x12
    c2c0:	13 8a       	std	Z+19, r1	; 0x13
    c2c2:	14 8a       	std	Z+20, r1	; 0x14
    c2c4:	15 8a       	std	Z+21, r1	; 0x15
    c2c6:	16 8a       	std	Z+22, r1	; 0x16
    c2c8:	17 8a       	std	Z+23, r1	; 0x17
    c2ca:	10 8e       	std	Z+24, r1	; 0x18
    c2cc:	11 8e       	std	Z+25, r1	; 0x19
    c2ce:	12 8e       	std	Z+26, r1	; 0x1a
    c2d0:	13 8e       	std	Z+27, r1	; 0x1b
    c2d2:	14 8e       	std	Z+28, r1	; 0x1c
    c2d4:	15 8e       	std	Z+29, r1	; 0x1d
    c2d6:	16 8e       	std	Z+30, r1	; 0x1e
    c2d8:	17 8e       	std	Z+31, r1	; 0x1f
    c2da:	10 a2       	std	Z+32, r1	; 0x20
    c2dc:	11 a2       	std	Z+33, r1	; 0x21
    c2de:	12 a2       	std	Z+34, r1	; 0x22
    c2e0:	13 a2       	std	Z+35, r1	; 0x23
    c2e2:	14 a2       	std	Z+36, r1	; 0x24
    c2e4:	15 a2       	std	Z+37, r1	; 0x25
    c2e6:	16 a2       	std	Z+38, r1	; 0x26
    c2e8:	17 a2       	std	Z+39, r1	; 0x27
    c2ea:	10 a6       	std	Z+40, r1	; 0x28
    c2ec:	11 a6       	std	Z+41, r1	; 0x29
    c2ee:	12 a6       	std	Z+42, r1	; 0x2a
    c2f0:	13 a6       	std	Z+43, r1	; 0x2b
    c2f2:	14 a6       	std	Z+44, r1	; 0x2c
    c2f4:	15 a6       	std	Z+45, r1	; 0x2d
    c2f6:	16 a6       	std	Z+46, r1	; 0x2e
    c2f8:	17 a6       	std	Z+47, r1	; 0x2f
    c2fa:	10 aa       	std	Z+48, r1	; 0x30
    c2fc:	11 aa       	std	Z+49, r1	; 0x31
    c2fe:	12 aa       	std	Z+50, r1	; 0x32
    c300:	13 aa       	std	Z+51, r1	; 0x33
    c302:	14 aa       	std	Z+52, r1	; 0x34
    c304:	15 aa       	std	Z+53, r1	; 0x35
    c306:	16 aa       	std	Z+54, r1	; 0x36
    c308:	17 aa       	std	Z+55, r1	; 0x37
    c30a:	10 ae       	std	Z+56, r1	; 0x38
    c30c:	11 ae       	std	Z+57, r1	; 0x39
    c30e:	12 ae       	std	Z+58, r1	; 0x3a
    c310:	13 ae       	std	Z+59, r1	; 0x3b
    c312:	14 ae       	std	Z+60, r1	; 0x3c
    c314:	c8 01       	movw	r24, r16
    c316:	cd 96       	adiw	r24, 0x3d	; 61
    c318:	9a 83       	std	Y+2, r25	; 0x02
    c31a:	89 83       	std	Y+1, r24	; 0x01
    c31c:	dc 01       	movw	r26, r24
    c31e:	1d 92       	st	X+, r1
    c320:	1d 92       	st	X+, r1
    c322:	1d 92       	st	X+, r1
    c324:	1c 92       	st	X, r1
    c326:	13 97       	sbiw	r26, 0x03	; 3
    c328:	b8 01       	movw	r22, r16
    c32a:	6f 5b       	subi	r22, 0xBF	; 191
    c32c:	7f 4f       	sbci	r23, 0xFF	; 255
    c32e:	fb 01       	movw	r30, r22
    c330:	10 82       	st	Z, r1
    c332:	11 82       	std	Z+1, r1	; 0x01
    c334:	12 82       	std	Z+2, r1	; 0x02
    c336:	13 82       	std	Z+3, r1	; 0x03
    c338:	a8 01       	movw	r20, r16
    c33a:	4b 5b       	subi	r20, 0xBB	; 187
    c33c:	5f 4f       	sbci	r21, 0xFF	; 255
    c33e:	da 01       	movw	r26, r20
    c340:	1d 92       	st	X+, r1
    c342:	1d 92       	st	X+, r1
    c344:	1d 92       	st	X+, r1
    c346:	1c 92       	st	X, r1
    c348:	13 97       	sbiw	r26, 0x03	; 3
    c34a:	98 01       	movw	r18, r16
    c34c:	27 5b       	subi	r18, 0xB7	; 183
    c34e:	3f 4f       	sbci	r19, 0xFF	; 255
    c350:	f9 01       	movw	r30, r18
    c352:	10 82       	st	Z, r1
    c354:	11 82       	std	Z+1, r1	; 0x01
    c356:	12 82       	std	Z+2, r1	; 0x02
    c358:	13 82       	std	Z+3, r1	; 0x03
    c35a:	c8 01       	movw	r24, r16
    c35c:	83 5b       	subi	r24, 0xB3	; 179
    c35e:	9f 4f       	sbci	r25, 0xFF	; 255
    c360:	9e 87       	std	Y+14, r25	; 0x0e
    c362:	8d 87       	std	Y+13, r24	; 0x0d
    c364:	dc 01       	movw	r26, r24
    c366:	1d 92       	st	X+, r1
    c368:	1d 92       	st	X+, r1
    c36a:	1d 92       	st	X+, r1
    c36c:	1c 92       	st	X, r1
    c36e:	13 97       	sbiw	r26, 0x03	; 3
    c370:	d8 01       	movw	r26, r16
    c372:	af 5a       	subi	r26, 0xAF	; 175
    c374:	bf 4f       	sbci	r27, 0xFF	; 255
    c376:	1d 92       	st	X+, r1
    c378:	1d 92       	st	X+, r1
    c37a:	1d 92       	st	X+, r1
    c37c:	1c 92       	st	X, r1
    c37e:	13 97       	sbiw	r26, 0x03	; 3
    c380:	f8 01       	movw	r30, r16
    c382:	eb 5a       	subi	r30, 0xAB	; 171
    c384:	ff 4f       	sbci	r31, 0xFF	; 255
    c386:	f8 8b       	std	Y+16, r31	; 0x10
    c388:	ef 87       	std	Y+15, r30	; 0x0f
    c38a:	10 82       	st	Z, r1
    c38c:	11 82       	std	Z+1, r1	; 0x01
    c38e:	12 82       	std	Z+2, r1	; 0x02
    c390:	13 82       	std	Z+3, r1	; 0x03
    c392:	58 01       	movw	r10, r16
    c394:	f9 e5       	ldi	r31, 0x59	; 89
    c396:	af 0e       	add	r10, r31
    c398:	b1 1c       	adc	r11, r1
    c39a:	f5 01       	movw	r30, r10
    c39c:	10 82       	st	Z, r1
    c39e:	11 82       	std	Z+1, r1	; 0x01
    c3a0:	12 82       	std	Z+2, r1	; 0x02
    c3a2:	13 82       	std	Z+3, r1	; 0x03
    c3a4:	48 01       	movw	r8, r16
    c3a6:	fd e5       	ldi	r31, 0x5D	; 93
    c3a8:	8f 0e       	add	r8, r31
    c3aa:	91 1c       	adc	r9, r1
    c3ac:	f4 01       	movw	r30, r8
    c3ae:	10 82       	st	Z, r1
    c3b0:	11 82       	std	Z+1, r1	; 0x01
    c3b2:	12 82       	std	Z+2, r1	; 0x02
    c3b4:	13 82       	std	Z+3, r1	; 0x03
    c3b6:	38 01       	movw	r6, r16
    c3b8:	f1 e6       	ldi	r31, 0x61	; 97
    c3ba:	6f 0e       	add	r6, r31
    c3bc:	71 1c       	adc	r7, r1
    c3be:	f3 01       	movw	r30, r6
    c3c0:	10 82       	st	Z, r1
    c3c2:	11 82       	std	Z+1, r1	; 0x01
    c3c4:	12 82       	std	Z+2, r1	; 0x02
    c3c6:	13 82       	std	Z+3, r1	; 0x03
    c3c8:	28 01       	movw	r4, r16
    c3ca:	f5 e6       	ldi	r31, 0x65	; 101
    c3cc:	4f 0e       	add	r4, r31
    c3ce:	51 1c       	adc	r5, r1
    c3d0:	f2 01       	movw	r30, r4
    c3d2:	10 82       	st	Z, r1
    c3d4:	11 82       	std	Z+1, r1	; 0x01
    c3d6:	12 82       	std	Z+2, r1	; 0x02
    c3d8:	13 82       	std	Z+3, r1	; 0x03
    c3da:	c8 01       	movw	r24, r16
    c3dc:	87 59       	subi	r24, 0x97	; 151
    c3de:	9f 4f       	sbci	r25, 0xFF	; 255
    c3e0:	9c 83       	std	Y+4, r25	; 0x04
    c3e2:	8b 83       	std	Y+3, r24	; 0x03
    c3e4:	fc 01       	movw	r30, r24
    c3e6:	10 82       	st	Z, r1
    c3e8:	11 82       	std	Z+1, r1	; 0x01
    c3ea:	12 82       	std	Z+2, r1	; 0x02
    c3ec:	13 82       	std	Z+3, r1	; 0x03
    c3ee:	c8 01       	movw	r24, r16
    c3f0:	83 59       	subi	r24, 0x93	; 147
    c3f2:	9f 4f       	sbci	r25, 0xFF	; 255
    c3f4:	9e 83       	std	Y+6, r25	; 0x06
    c3f6:	8d 83       	std	Y+5, r24	; 0x05
    c3f8:	fc 01       	movw	r30, r24
    c3fa:	10 82       	st	Z, r1
    c3fc:	11 82       	std	Z+1, r1	; 0x01
    c3fe:	12 82       	std	Z+2, r1	; 0x02
    c400:	13 82       	std	Z+3, r1	; 0x03
    c402:	18 01       	movw	r2, r16
    c404:	f1 e7       	ldi	r31, 0x71	; 113
    c406:	2f 0e       	add	r2, r31
    c408:	31 1c       	adc	r3, r1
    c40a:	f1 01       	movw	r30, r2
    c40c:	10 82       	st	Z, r1
    c40e:	11 82       	std	Z+1, r1	; 0x01
    c410:	12 82       	std	Z+2, r1	; 0x02
    c412:	13 82       	std	Z+3, r1	; 0x03
    c414:	c8 01       	movw	r24, r16
    c416:	8b 58       	subi	r24, 0x8B	; 139
    c418:	9f 4f       	sbci	r25, 0xFF	; 255
    c41a:	98 87       	std	Y+8, r25	; 0x08
    c41c:	8f 83       	std	Y+7, r24	; 0x07
    c41e:	fc 01       	movw	r30, r24
    c420:	10 82       	st	Z, r1
    c422:	11 82       	std	Z+1, r1	; 0x01
    c424:	12 82       	std	Z+2, r1	; 0x02
    c426:	13 82       	std	Z+3, r1	; 0x03
    c428:	c8 01       	movw	r24, r16
    c42a:	87 58       	subi	r24, 0x87	; 135
    c42c:	9f 4f       	sbci	r25, 0xFF	; 255
    c42e:	9a 87       	std	Y+10, r25	; 0x0a
    c430:	89 87       	std	Y+9, r24	; 0x09
    c432:	fc 01       	movw	r30, r24
    c434:	10 82       	st	Z, r1
    c436:	11 82       	std	Z+1, r1	; 0x01
    c438:	12 82       	std	Z+2, r1	; 0x02
    c43a:	13 82       	std	Z+3, r1	; 0x03
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    c43c:	eb 85       	ldd	r30, Y+11	; 0x0b
    c43e:	fc 85       	ldd	r31, Y+12	; 0x0c
    c440:	c1 84       	ldd	r12, Z+9	; 0x09
    c442:	d2 84       	ldd	r13, Z+10	; 0x0a
    c444:	f2 ed       	ldi	r31, 0xD2	; 210
    c446:	cf 0e       	add	r12, r31
    c448:	d1 1c       	adc	r13, r1
    c44a:	f6 01       	movw	r30, r12
    c44c:	c0 80       	ld	r12, Z
    c44e:	d1 80       	ldd	r13, Z+1	; 0x01
    c450:	e2 80       	ldd	r14, Z+2	; 0x02
    c452:	f3 80       	ldd	r15, Z+3	; 0x03
			
			message->PitchRads = model->PitchRads();
    c454:	f8 01       	movw	r30, r16
    c456:	c5 86       	std	Z+13, r12	; 0x0d
    c458:	d6 86       	std	Z+14, r13	; 0x0e
    c45a:	e7 86       	std	Z+15, r14	; 0x0f
    c45c:	f0 8a       	std	Z+16, r15	; 0x10
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    c45e:	eb 85       	ldd	r30, Y+11	; 0x0b
    c460:	fc 85       	ldd	r31, Y+12	; 0x0c
    c462:	c1 84       	ldd	r12, Z+9	; 0x09
    c464:	d2 84       	ldd	r13, Z+10	; 0x0a
    c466:	f6 01       	movw	r30, r12
    c468:	c2 a0       	ldd	r12, Z+34	; 0x22
    c46a:	d3 a0       	ldd	r13, Z+35	; 0x23
    c46c:	e4 a0       	ldd	r14, Z+36	; 0x24
    c46e:	f5 a0       	ldd	r15, Z+37	; 0x25
			message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    c470:	f8 01       	movw	r30, r16
    c472:	c5 82       	std	Z+5, r12	; 0x05
    c474:	d6 82       	std	Z+6, r13	; 0x06
    c476:	e7 82       	std	Z+7, r14	; 0x07
    c478:	f0 86       	std	Z+8, r15	; 0x08
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    c47a:	eb 85       	ldd	r30, Y+11	; 0x0b
    c47c:	fc 85       	ldd	r31, Y+12	; 0x0c
    c47e:	c1 84       	ldd	r12, Z+9	; 0x09
    c480:	d2 84       	ldd	r13, Z+10	; 0x0a
    c482:	f6 01       	movw	r30, r12
    c484:	c2 a8       	ldd	r12, Z+50	; 0x32
    c486:	d3 a8       	ldd	r13, Z+51	; 0x33
    c488:	e4 a8       	ldd	r14, Z+52	; 0x34
    c48a:	f5 a8       	ldd	r15, Z+53	; 0x35
//message->XNEDLocalFrame = model->LateralControl();			
			message->XVelocityFRDCms = model->XVelocityFRDCms();
    c48c:	f8 01       	movw	r30, r16
    c48e:	c1 86       	std	Z+9, r12	; 0x09
    c490:	d2 86       	std	Z+10, r13	; 0x0a
    c492:	e3 86       	std	Z+11, r14	; 0x0b
    c494:	f4 86       	std	Z+12, r15	; 0x0c
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    c496:	eb 85       	ldd	r30, Y+11	; 0x0b
    c498:	fc 85       	ldd	r31, Y+12	; 0x0c
    c49a:	c1 84       	ldd	r12, Z+9	; 0x09
    c49c:	d2 84       	ldd	r13, Z+10	; 0x0a
    c49e:	fe ec       	ldi	r31, 0xCE	; 206
    c4a0:	cf 0e       	add	r12, r31
    c4a2:	d1 1c       	adc	r13, r1
    c4a4:	f6 01       	movw	r30, r12
    c4a6:	c0 80       	ld	r12, Z
    c4a8:	d1 80       	ldd	r13, Z+1	; 0x01
    c4aa:	e2 80       	ldd	r14, Z+2	; 0x02
    c4ac:	f3 80       	ldd	r15, Z+3	; 0x03

			
			message->RollRads = model->RollRads();
    c4ae:	f8 01       	movw	r30, r16
    c4b0:	c1 8e       	std	Z+25, r12	; 0x19
    c4b2:	d2 8e       	std	Z+26, r13	; 0x1a
    c4b4:	e3 8e       	std	Z+27, r14	; 0x1b
    c4b6:	f4 8e       	std	Z+28, r15	; 0x1c
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    c4b8:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4ba:	fc 85       	ldd	r31, Y+12	; 0x0c
    c4bc:	c1 84       	ldd	r12, Z+9	; 0x09
    c4be:	d2 84       	ldd	r13, Z+10	; 0x0a
    c4c0:	fe e4       	ldi	r31, 0x4E	; 78
    c4c2:	cf 0e       	add	r12, r31
    c4c4:	d1 1c       	adc	r13, r1
    c4c6:	f6 01       	movw	r30, r12
    c4c8:	c0 80       	ld	r12, Z
    c4ca:	d1 80       	ldd	r13, Z+1	; 0x01
    c4cc:	e2 80       	ldd	r14, Z+2	; 0x02
    c4ce:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    c4d0:	f8 01       	movw	r30, r16
    c4d2:	c1 8a       	std	Z+17, r12	; 0x11
    c4d4:	d2 8a       	std	Z+18, r13	; 0x12
    c4d6:	e3 8a       	std	Z+19, r14	; 0x13
    c4d8:	f4 8a       	std	Z+20, r15	; 0x14
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    c4da:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4dc:	fc 85       	ldd	r31, Y+12	; 0x0c
    c4de:	c1 84       	ldd	r12, Z+9	; 0x09
    c4e0:	d2 84       	ldd	r13, Z+10	; 0x0a
    c4e2:	fe e5       	ldi	r31, 0x5E	; 94
    c4e4:	cf 0e       	add	r12, r31
    c4e6:	d1 1c       	adc	r13, r1
    c4e8:	f6 01       	movw	r30, r12
    c4ea:	c0 80       	ld	r12, Z
    c4ec:	d1 80       	ldd	r13, Z+1	; 0x01
    c4ee:	e2 80       	ldd	r14, Z+2	; 0x02
    c4f0:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YVelocityFRDCms = model->YVelocityFRDCms();
    c4f2:	f8 01       	movw	r30, r16
    c4f4:	c5 8a       	std	Z+21, r12	; 0x15
    c4f6:	d6 8a       	std	Z+22, r13	; 0x16
    c4f8:	e7 8a       	std	Z+23, r14	; 0x17
    c4fa:	f0 8e       	std	Z+24, r15	; 0x18
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    c4fc:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4fe:	fc 85       	ldd	r31, Y+12	; 0x0c
    c500:	c1 84       	ldd	r12, Z+9	; 0x09
    c502:	d2 84       	ldd	r13, Z+10	; 0x0a
    c504:	f6 ed       	ldi	r31, 0xD6	; 214
    c506:	cf 0e       	add	r12, r31
    c508:	d1 1c       	adc	r13, r1
    c50a:	f6 01       	movw	r30, r12
    c50c:	c0 80       	ld	r12, Z
    c50e:	d1 80       	ldd	r13, Z+1	; 0x01
    c510:	e2 80       	ldd	r14, Z+2	; 0x02
    c512:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			
			message->YawRads = model->YawRads();
    c514:	f8 01       	movw	r30, r16
    c516:	c1 a2       	std	Z+33, r12	; 0x21
    c518:	d2 a2       	std	Z+34, r13	; 0x22
    c51a:	e3 a2       	std	Z+35, r14	; 0x23
    c51c:	f4 a2       	std	Z+36, r15	; 0x24
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    c51e:	eb 85       	ldd	r30, Y+11	; 0x0b
    c520:	fc 85       	ldd	r31, Y+12	; 0x0c
    c522:	c1 84       	ldd	r12, Z+9	; 0x09
    c524:	d2 84       	ldd	r13, Z+10	; 0x0a
    c526:	fe e8       	ldi	r31, 0x8E	; 142
    c528:	cf 0e       	add	r12, r31
    c52a:	d1 1c       	adc	r13, r1
    c52c:	f6 01       	movw	r30, r12
    c52e:	c0 80       	ld	r12, Z
    c530:	d1 80       	ldd	r13, Z+1	; 0x01
    c532:	e2 80       	ldd	r14, Z+2	; 0x02
    c534:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    c536:	f8 01       	movw	r30, r16
    c538:	c5 8e       	std	Z+29, r12	; 0x1d
    c53a:	d6 8e       	std	Z+30, r13	; 0x1e
    c53c:	e7 8e       	std	Z+31, r14	; 0x1f
    c53e:	f0 a2       	std	Z+32, r15	; 0x20
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    c540:	eb 85       	ldd	r30, Y+11	; 0x0b
    c542:	fc 85       	ldd	r31, Y+12	; 0x0c
    c544:	c1 84       	ldd	r12, Z+9	; 0x09
    c546:	d2 84       	ldd	r13, Z+10	; 0x0a
    c548:	fe e7       	ldi	r31, 0x7E	; 126
    c54a:	cf 0e       	add	r12, r31
    c54c:	d1 1c       	adc	r13, r1
    c54e:	f6 01       	movw	r30, r12
    c550:	c0 80       	ld	r12, Z
    c552:	d1 80       	ldd	r13, Z+1	; 0x01
    c554:	e2 80       	ldd	r14, Z+2	; 0x02
    c556:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    c558:	f8 01       	movw	r30, r16
    c55a:	c5 a2       	std	Z+37, r12	; 0x25
    c55c:	d6 a2       	std	Z+38, r13	; 0x26
    c55e:	e7 a2       	std	Z+39, r14	; 0x27
    c560:	f0 a6       	std	Z+40, r15	; 0x28

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    c562:	eb 85       	ldd	r30, Y+11	; 0x0b
    c564:	fc 85       	ldd	r31, Y+12	; 0x0c
    c566:	c1 84       	ldd	r12, Z+9	; 0x09
    c568:	d2 84       	ldd	r13, Z+10	; 0x0a
    c56a:	f6 ee       	ldi	r31, 0xE6	; 230
    c56c:	cf 0e       	add	r12, r31
    c56e:	d1 1c       	adc	r13, r1
    c570:	f6 01       	movw	r30, r12
    c572:	c0 80       	ld	r12, Z
    c574:	d1 80       	ldd	r13, Z+1	; 0x01
    c576:	e2 80       	ldd	r14, Z+2	; 0x02
    c578:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			
			message->XAccelFrdMss = model->XAccelFrdMss();
    c57a:	f8 01       	movw	r30, r16
    c57c:	c1 a6       	std	Z+41, r12	; 0x29
    c57e:	d2 a6       	std	Z+42, r13	; 0x2a
    c580:	e3 a6       	std	Z+43, r14	; 0x2b
    c582:	f4 a6       	std	Z+44, r15	; 0x2c
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    c584:	eb 85       	ldd	r30, Y+11	; 0x0b
    c586:	fc 85       	ldd	r31, Y+12	; 0x0c
    c588:	c1 84       	ldd	r12, Z+9	; 0x09
    c58a:	d2 84       	ldd	r13, Z+10	; 0x0a
    c58c:	fa ee       	ldi	r31, 0xEA	; 234
    c58e:	cf 0e       	add	r12, r31
    c590:	d1 1c       	adc	r13, r1
    c592:	f6 01       	movw	r30, r12
    c594:	c0 80       	ld	r12, Z
    c596:	d1 80       	ldd	r13, Z+1	; 0x01
    c598:	e2 80       	ldd	r14, Z+2	; 0x02
    c59a:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YAccelFrdMss = model->YAccelFrdMss();
    c59c:	f8 01       	movw	r30, r16
    c59e:	c5 a6       	std	Z+45, r12	; 0x2d
    c5a0:	d6 a6       	std	Z+46, r13	; 0x2e
    c5a2:	e7 a6       	std	Z+47, r14	; 0x2f
    c5a4:	f0 aa       	std	Z+48, r15	; 0x30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    c5a6:	eb 85       	ldd	r30, Y+11	; 0x0b
    c5a8:	fc 85       	ldd	r31, Y+12	; 0x0c
    c5aa:	c1 84       	ldd	r12, Z+9	; 0x09
    c5ac:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5ae:	fe ee       	ldi	r31, 0xEE	; 238
    c5b0:	cf 0e       	add	r12, r31
    c5b2:	d1 1c       	adc	r13, r1
    c5b4:	f6 01       	movw	r30, r12
    c5b6:	c0 80       	ld	r12, Z
    c5b8:	d1 80       	ldd	r13, Z+1	; 0x01
    c5ba:	e2 80       	ldd	r14, Z+2	; 0x02
    c5bc:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZAccelFrdMss = model->ZAccelFrdMss();
    c5be:	f8 01       	movw	r30, r16
    c5c0:	c1 aa       	std	Z+49, r12	; 0x31
    c5c2:	d2 aa       	std	Z+50, r13	; 0x32
    c5c4:	e3 aa       	std	Z+51, r14	; 0x33
    c5c6:	f4 aa       	std	Z+52, r15	; 0x34
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    c5c8:	eb 85       	ldd	r30, Y+11	; 0x0b
    c5ca:	fc 85       	ldd	r31, Y+12	; 0x0c
    c5cc:	c1 84       	ldd	r12, Z+9	; 0x09
    c5ce:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5d0:	f2 ee       	ldi	r31, 0xE2	; 226
    c5d2:	cf 0e       	add	r12, r31
    c5d4:	d1 1c       	adc	r13, r1
    c5d6:	f6 01       	movw	r30, r12
    c5d8:	c0 80       	ld	r12, Z
    c5da:	d1 80       	ldd	r13, Z+1	; 0x01
    c5dc:	e2 80       	ldd	r14, Z+2	; 0x02
    c5de:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    c5e0:	f8 01       	movw	r30, r16
    c5e2:	c5 aa       	std	Z+53, r12	; 0x35
    c5e4:	d6 aa       	std	Z+54, r13	; 0x36
    c5e6:	e7 aa       	std	Z+55, r14	; 0x37
    c5e8:	f0 ae       	std	Z+56, r15	; 0x38
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    c5ea:	eb 85       	ldd	r30, Y+11	; 0x0b
    c5ec:	fc 85       	ldd	r31, Y+12	; 0x0c
    c5ee:	c1 84       	ldd	r12, Z+9	; 0x09
    c5f0:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5f2:	fa ed       	ldi	r31, 0xDA	; 218
    c5f4:	cf 0e       	add	r12, r31
    c5f6:	d1 1c       	adc	r13, r1
    c5f8:	f6 01       	movw	r30, r12
    c5fa:	c0 80       	ld	r12, Z
    c5fc:	d1 80       	ldd	r13, Z+1	; 0x01
    c5fe:	e2 80       	ldd	r14, Z+2	; 0x02
    c600:	f3 80       	ldd	r15, Z+3	; 0x03
			message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    c602:	f8 01       	movw	r30, r16
    c604:	c1 ae       	std	Z+57, r12	; 0x39
    c606:	d2 ae       	std	Z+58, r13	; 0x3a
    c608:	e3 ae       	std	Z+59, r14	; 0x3b
    c60a:	f4 ae       	std	Z+60, r15	; 0x3c
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    c60c:	eb 85       	ldd	r30, Y+11	; 0x0b
    c60e:	fc 85       	ldd	r31, Y+12	; 0x0c
    c610:	c1 84       	ldd	r12, Z+9	; 0x09
    c612:	d2 84       	ldd	r13, Z+10	; 0x0a
    c614:	fe ed       	ldi	r31, 0xDE	; 222
    c616:	cf 0e       	add	r12, r31
    c618:	d1 1c       	adc	r13, r1
    c61a:	f6 01       	movw	r30, r12
    c61c:	c0 80       	ld	r12, Z
    c61e:	d1 80       	ldd	r13, Z+1	; 0x01
    c620:	e2 80       	ldd	r14, Z+2	; 0x02
    c622:	f3 80       	ldd	r15, Z+3	; 0x03
			message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    c624:	e9 81       	ldd	r30, Y+1	; 0x01
    c626:	fa 81       	ldd	r31, Y+2	; 0x02
    c628:	c0 82       	st	Z, r12
    c62a:	d1 82       	std	Z+1, r13	; 0x01
    c62c:	e2 82       	std	Z+2, r14	; 0x02
    c62e:	f3 82       	std	Z+3, r15	; 0x03
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    c630:	eb 85       	ldd	r30, Y+11	; 0x0b
    c632:	fc 85       	ldd	r31, Y+12	; 0x0c
    c634:	e1 84       	ldd	r14, Z+9	; 0x09
    c636:	f2 84       	ldd	r15, Z+10	; 0x0a
    c638:	f2 ef       	ldi	r31, 0xF2	; 242
    c63a:	ef 0e       	add	r14, r31
    c63c:	f1 1c       	adc	r15, r1
    c63e:	f7 01       	movw	r30, r14
    c640:	c0 80       	ld	r12, Z
    c642:	d1 80       	ldd	r13, Z+1	; 0x01
    c644:	e2 80       	ldd	r14, Z+2	; 0x02
    c646:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			message->XMagFrd = model->XMagFrd();
    c648:	fb 01       	movw	r30, r22
    c64a:	c0 82       	st	Z, r12
    c64c:	d1 82       	std	Z+1, r13	; 0x01
    c64e:	e2 82       	std	Z+2, r14	; 0x02
    c650:	f3 82       	std	Z+3, r15	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    c652:	eb 85       	ldd	r30, Y+11	; 0x0b
    c654:	fc 85       	ldd	r31, Y+12	; 0x0c
    c656:	61 85       	ldd	r22, Z+9	; 0x09
    c658:	72 85       	ldd	r23, Z+10	; 0x0a
    c65a:	6a 50       	subi	r22, 0x0A	; 10
    c65c:	7f 4f       	sbci	r23, 0xFF	; 255
    c65e:	fb 01       	movw	r30, r22
    c660:	c0 80       	ld	r12, Z
    c662:	d1 80       	ldd	r13, Z+1	; 0x01
    c664:	e2 80       	ldd	r14, Z+2	; 0x02
    c666:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YMagFrd = model->YMagFrd();
    c668:	fa 01       	movw	r30, r20
    c66a:	c0 82       	st	Z, r12
    c66c:	d1 82       	std	Z+1, r13	; 0x01
    c66e:	e2 82       	std	Z+2, r14	; 0x02
    c670:	f3 82       	std	Z+3, r15	; 0x03
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    c672:	eb 85       	ldd	r30, Y+11	; 0x0b
    c674:	fc 85       	ldd	r31, Y+12	; 0x0c
    c676:	41 85       	ldd	r20, Z+9	; 0x09
    c678:	52 85       	ldd	r21, Z+10	; 0x0a
    c67a:	46 50       	subi	r20, 0x06	; 6
    c67c:	5f 4f       	sbci	r21, 0xFF	; 255
    c67e:	fa 01       	movw	r30, r20
    c680:	40 81       	ld	r20, Z
    c682:	51 81       	ldd	r21, Z+1	; 0x01
    c684:	62 81       	ldd	r22, Z+2	; 0x02
    c686:	73 81       	ldd	r23, Z+3	; 0x03
			message->ZMagFrd = model->ZMagFrd();
    c688:	f9 01       	movw	r30, r18
    c68a:	40 83       	st	Z, r20
    c68c:	51 83       	std	Z+1, r21	; 0x01
    c68e:	62 83       	std	Z+2, r22	; 0x02
    c690:	73 83       	std	Z+3, r23	; 0x03
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    c692:	eb 85       	ldd	r30, Y+11	; 0x0b
    c694:	fc 85       	ldd	r31, Y+12	; 0x0c
    c696:	21 85       	ldd	r18, Z+9	; 0x09
    c698:	32 85       	ldd	r19, Z+10	; 0x0a
    c69a:	22 50       	subi	r18, 0x02	; 2
    c69c:	3f 4f       	sbci	r19, 0xFF	; 255
    c69e:	f9 01       	movw	r30, r18
    c6a0:	40 81       	ld	r20, Z
    c6a2:	51 81       	ldd	r21, Z+1	; 0x01
    c6a4:	62 81       	ldd	r22, Z+2	; 0x02
    c6a6:	73 81       	ldd	r23, Z+3	; 0x03
/*
message->XMagFrd = model->off1();
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();			
*/
			message->XEcefCm = model->XEcefCm();
    c6a8:	ed 85       	ldd	r30, Y+13	; 0x0d
    c6aa:	fe 85       	ldd	r31, Y+14	; 0x0e
    c6ac:	40 83       	st	Z, r20
    c6ae:	51 83       	std	Z+1, r21	; 0x01
    c6b0:	62 83       	std	Z+2, r22	; 0x02
    c6b2:	73 83       	std	Z+3, r23	; 0x03
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    c6b4:	eb 85       	ldd	r30, Y+11	; 0x0b
    c6b6:	fc 85       	ldd	r31, Y+12	; 0x0c
    c6b8:	81 85       	ldd	r24, Z+9	; 0x09
    c6ba:	92 85       	ldd	r25, Z+10	; 0x0a
    c6bc:	8e 5f       	subi	r24, 0xFE	; 254
    c6be:	9e 4f       	sbci	r25, 0xFE	; 254
    c6c0:	fc 01       	movw	r30, r24
    c6c2:	40 81       	ld	r20, Z
    c6c4:	51 81       	ldd	r21, Z+1	; 0x01
    c6c6:	62 81       	ldd	r22, Z+2	; 0x02
    c6c8:	73 81       	ldd	r23, Z+3	; 0x03
			message->YEcefCm = model->YEcefCm();
    c6ca:	4d 93       	st	X+, r20
    c6cc:	5d 93       	st	X+, r21
    c6ce:	6d 93       	st	X+, r22
    c6d0:	7c 93       	st	X, r23
    c6d2:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    c6d4:	eb 85       	ldd	r30, Y+11	; 0x0b
    c6d6:	fc 85       	ldd	r31, Y+12	; 0x0c
    c6d8:	a1 85       	ldd	r26, Z+9	; 0x09
    c6da:	b2 85       	ldd	r27, Z+10	; 0x0a
    c6dc:	aa 5f       	subi	r26, 0xFA	; 250
    c6de:	be 4f       	sbci	r27, 0xFE	; 254
    c6e0:	8d 91       	ld	r24, X+
    c6e2:	9d 91       	ld	r25, X+
    c6e4:	0d 90       	ld	r0, X+
    c6e6:	bc 91       	ld	r27, X
    c6e8:	a0 2d       	mov	r26, r0
			message->ZEcefCm = model->ZEcefCm();
    c6ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    c6ec:	f8 89       	ldd	r31, Y+16	; 0x10
    c6ee:	80 83       	st	Z, r24
    c6f0:	91 83       	std	Z+1, r25	; 0x01
    c6f2:	a2 83       	std	Z+2, r26	; 0x02
    c6f4:	b3 83       	std	Z+3, r27	; 0x03
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    c6f6:	ab 85       	ldd	r26, Y+11	; 0x0b
    c6f8:	bc 85       	ldd	r27, Y+12	; 0x0c
    c6fa:	19 96       	adiw	r26, 0x09	; 9
    c6fc:	ed 91       	ld	r30, X+
    c6fe:	fc 91       	ld	r31, X
    c700:	1a 97       	sbiw	r26, 0x0a	; 10
    c702:	e6 5f       	subi	r30, 0xF6	; 246
    c704:	fe 4f       	sbci	r31, 0xFE	; 254
    c706:	80 81       	ld	r24, Z
    c708:	91 81       	ldd	r25, Z+1	; 0x01
    c70a:	a2 81       	ldd	r26, Z+2	; 0x02
    c70c:	b3 81       	ldd	r27, Z+3	; 0x03
			message->XVEcefCms = model->XVEcefCms();
    c70e:	f5 01       	movw	r30, r10
    c710:	80 83       	st	Z, r24
    c712:	91 83       	std	Z+1, r25	; 0x01
    c714:	a2 83       	std	Z+2, r26	; 0x02
    c716:	b3 83       	std	Z+3, r27	; 0x03
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    c718:	ab 85       	ldd	r26, Y+11	; 0x0b
    c71a:	bc 85       	ldd	r27, Y+12	; 0x0c
    c71c:	19 96       	adiw	r26, 0x09	; 9
    c71e:	ed 91       	ld	r30, X+
    c720:	fc 91       	ld	r31, X
    c722:	1a 97       	sbiw	r26, 0x0a	; 10
    c724:	e2 5f       	subi	r30, 0xF2	; 242
    c726:	fe 4f       	sbci	r31, 0xFE	; 254
    c728:	80 81       	ld	r24, Z
    c72a:	91 81       	ldd	r25, Z+1	; 0x01
    c72c:	a2 81       	ldd	r26, Z+2	; 0x02
    c72e:	b3 81       	ldd	r27, Z+3	; 0x03
			message->YVEcefCms = model->YVEcefCms();
    c730:	f4 01       	movw	r30, r8
    c732:	80 83       	st	Z, r24
    c734:	91 83       	std	Z+1, r25	; 0x01
    c736:	a2 83       	std	Z+2, r26	; 0x02
    c738:	b3 83       	std	Z+3, r27	; 0x03
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    c73a:	ab 85       	ldd	r26, Y+11	; 0x0b
    c73c:	bc 85       	ldd	r27, Y+12	; 0x0c
    c73e:	19 96       	adiw	r26, 0x09	; 9
    c740:	ed 91       	ld	r30, X+
    c742:	fc 91       	ld	r31, X
    c744:	1a 97       	sbiw	r26, 0x0a	; 10
    c746:	ee 5e       	subi	r30, 0xEE	; 238
    c748:	fe 4f       	sbci	r31, 0xFE	; 254
    c74a:	80 81       	ld	r24, Z
    c74c:	91 81       	ldd	r25, Z+1	; 0x01
    c74e:	a2 81       	ldd	r26, Z+2	; 0x02
    c750:	b3 81       	ldd	r27, Z+3	; 0x03
			message->ZVEcefCms = model->ZVEcefCms();
    c752:	f3 01       	movw	r30, r6
    c754:	80 83       	st	Z, r24
    c756:	91 83       	std	Z+1, r25	; 0x01
    c758:	a2 83       	std	Z+2, r26	; 0x02
    c75a:	b3 83       	std	Z+3, r27	; 0x03
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    c75c:	ab 85       	ldd	r26, Y+11	; 0x0b
    c75e:	bc 85       	ldd	r27, Y+12	; 0x0c
    c760:	19 96       	adiw	r26, 0x09	; 9
    c762:	ed 91       	ld	r30, X+
    c764:	fc 91       	ld	r31, X
    c766:	1a 97       	sbiw	r26, 0x0a	; 10
    c768:	ea 5e       	subi	r30, 0xEA	; 234
    c76a:	fe 4f       	sbci	r31, 0xFE	; 254
    c76c:	80 81       	ld	r24, Z
    c76e:	91 81       	ldd	r25, Z+1	; 0x01
    c770:	a2 81       	ldd	r26, Z+2	; 0x02
    c772:	b3 81       	ldd	r27, Z+3	; 0x03
			message->PressureMillibars = model->PressureMillibars();
    c774:	f2 01       	movw	r30, r4
    c776:	80 83       	st	Z, r24
    c778:	91 83       	std	Z+1, r25	; 0x01
    c77a:	a2 83       	std	Z+2, r26	; 0x02
    c77c:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    c77e:	ab 85       	ldd	r26, Y+11	; 0x0b
    c780:	bc 85       	ldd	r27, Y+12	; 0x0c
    c782:	19 96       	adiw	r26, 0x09	; 9
    c784:	ed 91       	ld	r30, X+
    c786:	fc 91       	ld	r31, X
    c788:	1a 97       	sbiw	r26, 0x0a	; 10
    c78a:	ee 54       	subi	r30, 0x4E	; 78
    c78c:	ff 4f       	sbci	r31, 0xFF	; 255
    c78e:	80 81       	ld	r24, Z
    c790:	91 81       	ldd	r25, Z+1	; 0x01
    c792:	a2 81       	ldd	r26, Z+2	; 0x02
    c794:	b3 81       	ldd	r27, Z+3	; 0x03
			
			
			
			message->ChecksumErrors = model->ChecksumErrors();
    c796:	f1 01       	movw	r30, r2
    c798:	80 83       	st	Z, r24
    c79a:	91 83       	std	Z+1, r25	; 0x01
    c79c:	a2 83       	std	Z+2, r26	; 0x02
    c79e:	b3 83       	std	Z+3, r27	; 0x03

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    c7a0:	ab 85       	ldd	r26, Y+11	; 0x0b
    c7a2:	bc 85       	ldd	r27, Y+12	; 0x0c
    c7a4:	19 96       	adiw	r26, 0x09	; 9
    c7a6:	ed 91       	ld	r30, X+
    c7a8:	fc 91       	ld	r31, X
    c7aa:	1a 97       	sbiw	r26, 0x0a	; 10
    c7ac:	e6 55       	subi	r30, 0x56	; 86
    c7ae:	ff 4f       	sbci	r31, 0xFF	; 255
    c7b0:	80 81       	ld	r24, Z
    c7b2:	91 81       	ldd	r25, Z+1	; 0x01
    c7b4:	a2 81       	ldd	r26, Z+2	; 0x02
    c7b6:	b3 81       	ldd	r27, Z+3	; 0x03
			message->Timeouts = model->Timeouts();
    c7b8:	eb 81       	ldd	r30, Y+3	; 0x03
    c7ba:	fc 81       	ldd	r31, Y+4	; 0x04
    c7bc:	80 83       	st	Z, r24
    c7be:	91 83       	std	Z+1, r25	; 0x01
    c7c0:	a2 83       	std	Z+2, r26	; 0x02
    c7c2:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    c7c4:	ab 85       	ldd	r26, Y+11	; 0x0b
    c7c6:	bc 85       	ldd	r27, Y+12	; 0x0c
    c7c8:	19 96       	adiw	r26, 0x09	; 9
    c7ca:	ed 91       	ld	r30, X+
    c7cc:	fc 91       	ld	r31, X
    c7ce:	1a 97       	sbiw	r26, 0x0a	; 10
    c7d0:	e2 55       	subi	r30, 0x52	; 82
    c7d2:	ff 4f       	sbci	r31, 0xFF	; 255
    c7d4:	80 81       	ld	r24, Z
    c7d6:	91 81       	ldd	r25, Z+1	; 0x01
    c7d8:	a2 81       	ldd	r26, Z+2	; 0x02
    c7da:	b3 81       	ldd	r27, Z+3	; 0x03
			message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    c7dc:	ed 81       	ldd	r30, Y+5	; 0x05
    c7de:	fe 81       	ldd	r31, Y+6	; 0x06
    c7e0:	80 83       	st	Z, r24
    c7e2:	91 83       	std	Z+1, r25	; 0x01
    c7e4:	a2 83       	std	Z+2, r26	; 0x02
    c7e6:	b3 83       	std	Z+3, r27	; 0x03
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    c7e8:	ab 85       	ldd	r26, Y+11	; 0x0b
    c7ea:	bc 85       	ldd	r27, Y+12	; 0x0c
    c7ec:	19 96       	adiw	r26, 0x09	; 9
    c7ee:	ed 91       	ld	r30, X+
    c7f0:	fc 91       	ld	r31, X
    c7f2:	1a 97       	sbiw	r26, 0x0a	; 10
    c7f4:	ea 54       	subi	r30, 0x4A	; 74
    c7f6:	ff 4f       	sbci	r31, 0xFF	; 255
    c7f8:	80 81       	ld	r24, Z
    c7fa:	91 81       	ldd	r25, Z+1	; 0x01
    c7fc:	a2 81       	ldd	r26, Z+2	; 0x02
    c7fe:	b3 81       	ldd	r27, Z+3	; 0x03
			message->NumOfBlownFrames = model->BlownFrames();
    c800:	ef 81       	ldd	r30, Y+7	; 0x07
    c802:	f8 85       	ldd	r31, Y+8	; 0x08
    c804:	80 83       	st	Z, r24
    c806:	91 83       	std	Z+1, r25	; 0x01
    c808:	a2 83       	std	Z+2, r26	; 0x02
    c80a:	b3 83       	std	Z+3, r27	; 0x03
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    c80c:	ab 85       	ldd	r26, Y+11	; 0x0b
    c80e:	bc 85       	ldd	r27, Y+12	; 0x0c
    c810:	19 96       	adiw	r26, 0x09	; 9
    c812:	ed 91       	ld	r30, X+
    c814:	fc 91       	ld	r31, X
    c816:	1a 97       	sbiw	r26, 0x0a	; 10
    c818:	e6 54       	subi	r30, 0x46	; 70
    c81a:	ff 4f       	sbci	r31, 0xFF	; 255
    c81c:	80 81       	ld	r24, Z
    c81e:	91 81       	ldd	r25, Z+1	; 0x01
    c820:	a2 81       	ldd	r26, Z+2	; 0x02
    c822:	b3 81       	ldd	r27, Z+3	; 0x03
			message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    c824:	e9 85       	ldd	r30, Y+9	; 0x09
    c826:	fa 85       	ldd	r31, Y+10	; 0x0a
    c828:	80 83       	st	Z, r24
    c82a:	91 83       	std	Z+1, r25	; 0x01
    c82c:	a2 83       	std	Z+2, r26	; 0x02
    c82e:	b3 83       	std	Z+3, r27	; 0x03
			
			if (radioInterface->transmit(message) != 0)
    c830:	b8 01       	movw	r22, r16
    c832:	ab 85       	ldd	r26, Y+11	; 0x0b
    c834:	bc 85       	ldd	r27, Y+12	; 0x0c
    c836:	17 96       	adiw	r26, 0x07	; 7
    c838:	8d 91       	ld	r24, X+
    c83a:	9c 91       	ld	r25, X
    c83c:	18 97       	sbiw	r26, 0x08	; 8
    c83e:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c842:	89 2b       	or	r24, r25
    c844:	99 f0       	breq	.+38     	; 0xc86c <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7ac>
			{
				model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c846:	ab 85       	ldd	r26, Y+11	; 0x0b
    c848:	bc 85       	ldd	r27, Y+12	; 0x0c
    c84a:	19 96       	adiw	r26, 0x09	; 9
    c84c:	ed 91       	ld	r30, X+
    c84e:	fc 91       	ld	r31, X
    c850:	1a 97       	sbiw	r26, 0x0a	; 10
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    c852:	e6 54       	subi	r30, 0x46	; 70
    c854:	ff 4f       	sbci	r31, 0xFF	; 255
    c856:	80 81       	ld	r24, Z
    c858:	91 81       	ldd	r25, Z+1	; 0x01
    c85a:	a2 81       	ldd	r26, Z+2	; 0x02
    c85c:	b3 81       	ldd	r27, Z+3	; 0x03
    c85e:	01 96       	adiw	r24, 0x01	; 1
    c860:	a1 1d       	adc	r26, r1
    c862:	b1 1d       	adc	r27, r1
    c864:	80 83       	st	Z, r24
    c866:	91 83       	std	Z+1, r25	; 0x01
    c868:	a2 83       	std	Z+2, r26	; 0x02
    c86a:	b3 83       	std	Z+3, r27	; 0x03
			}
	
			delete message;
    c86c:	01 15       	cp	r16, r1
    c86e:	11 05       	cpc	r17, r1
    c870:	41 f0       	breq	.+16     	; 0xc882 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c872:	d8 01       	movw	r26, r16
    c874:	ed 91       	ld	r30, X+
    c876:	fc 91       	ld	r31, X
    c878:	02 80       	ldd	r0, Z+2	; 0x02
    c87a:	f3 81       	ldd	r31, Z+3	; 0x03
    c87c:	e0 2d       	mov	r30, r0
    c87e:	c8 01       	movw	r24, r16
    c880:	19 95       	eicall
		}
    c882:	60 96       	adiw	r28, 0x10	; 16
    c884:	0f b6       	in	r0, 0x3f	; 63
    c886:	f8 94       	cli
    c888:	de bf       	out	0x3e, r29	; 62
    c88a:	0f be       	out	0x3f, r0	; 63
    c88c:	cd bf       	out	0x3d, r28	; 61
    c88e:	df 91       	pop	r29
    c890:	cf 91       	pop	r28
    c892:	1f 91       	pop	r17
    c894:	0f 91       	pop	r16
    c896:	ff 90       	pop	r15
    c898:	ef 90       	pop	r14
    c89a:	df 90       	pop	r13
    c89c:	cf 90       	pop	r12
    c89e:	bf 90       	pop	r11
    c8a0:	af 90       	pop	r10
    c8a2:	9f 90       	pop	r9
    c8a4:	8f 90       	pop	r8
    c8a6:	7f 90       	pop	r7
    c8a8:	6f 90       	pop	r6
    c8aa:	5f 90       	pop	r5
    c8ac:	4f 90       	pop	r4
    c8ae:	3f 90       	pop	r3
    c8b0:	2f 90       	pop	r2
    c8b2:	08 95       	ret

0000c8b4 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>:

#include <math.h>
#include <avr/io.h>
using namespace helicopter::tasks;

TransmitTelemetryTask::TransmitTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, DATATOSEND dataToSend, int delay, int period) :
    c8b4:	9f 92       	push	r9
    c8b6:	af 92       	push	r10
    c8b8:	bf 92       	push	r11
    c8ba:	cf 92       	push	r12
    c8bc:	df 92       	push	r13
    c8be:	ef 92       	push	r14
    c8c0:	ff 92       	push	r15
    c8c2:	0f 93       	push	r16
    c8c4:	1f 93       	push	r17
    c8c6:	cf 93       	push	r28
    c8c8:	df 93       	push	r29
    c8ca:	ec 01       	movw	r28, r24
    c8cc:	5b 01       	movw	r10, r22
    c8ce:	6a 01       	movw	r12, r20
    c8d0:	92 2e       	mov	r9, r18
    c8d2:	b8 01       	movw	r22, r16
    c8d4:	a7 01       	movw	r20, r14
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	dataToSend(dataToSend)
    c8d6:	0e 94 47 60 	call	0xc08e	; 0xc08e <_ZN10helicopter5tasks4TaskC1Eii>
    c8da:	84 e8       	ldi	r24, 0x84	; 132
    c8dc:	93 e0       	ldi	r25, 0x03	; 3
    c8de:	99 83       	std	Y+1, r25	; 0x01
    c8e0:	88 83       	st	Y, r24
    c8e2:	b8 86       	std	Y+8, r11	; 0x08
    c8e4:	af 82       	std	Y+7, r10	; 0x07
    c8e6:	da 86       	std	Y+10, r13	; 0x0a
    c8e8:	c9 86       	std	Y+9, r12	; 0x09
    c8ea:	9b 86       	std	Y+11, r9	; 0x0b
{
	
}
    c8ec:	df 91       	pop	r29
    c8ee:	cf 91       	pop	r28
    c8f0:	1f 91       	pop	r17
    c8f2:	0f 91       	pop	r16
    c8f4:	ff 90       	pop	r15
    c8f6:	ef 90       	pop	r14
    c8f8:	df 90       	pop	r13
    c8fa:	cf 90       	pop	r12
    c8fc:	bf 90       	pop	r11
    c8fe:	af 90       	pop	r10
    c900:	9f 90       	pop	r9
    c902:	08 95       	ret

0000c904 <_Znwj>:
#include <CommonHeader.h>


void * operator new(size_t size)
{
	return malloc(size);
    c904:	0e 94 2b 70 	call	0xe056	; 0xe056 <malloc>
}
    c908:	08 95       	ret

0000c90a <_ZdlPv>:

void operator delete(void * ptr)
{
	if (ptr != NULL)
    c90a:	00 97       	sbiw	r24, 0x00	; 0
    c90c:	11 f0       	breq	.+4      	; 0xc912 <_ZdlPv+0x8>
	{
		free(ptr);
    c90e:	0e 94 c6 70 	call	0xe18c	; 0xe18c <free>
    c912:	08 95       	ret

0000c914 <_Znaj>:
	}
}

void * operator new[](size_t size)
{
	return malloc(size);
    c914:	0e 94 2b 70 	call	0xe056	; 0xe056 <malloc>
}
    c918:	08 95       	ret

0000c91a <_ZdaPv>:

void operator delete[](void * ptr)
{
	if(ptr != NULL)
    c91a:	00 97       	sbiw	r24, 0x00	; 0
    c91c:	11 f0       	breq	.+4      	; 0xc922 <_ZdaPv+0x8>
	{
		free(ptr);
    c91e:	0e 94 c6 70 	call	0xe18c	; 0xe18c <free>
    c922:	08 95       	ret

0000c924 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>:


const float CoordinateUtil::PIOVER180 = M_PI / 180.0f;

void CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(float latitudeDegrees, float longitudeDegrees, float  (&ecefToLocalNEDRotationMatrix)[3][3])
{
    c924:	4f 92       	push	r4
    c926:	5f 92       	push	r5
    c928:	6f 92       	push	r6
    c92a:	7f 92       	push	r7
    c92c:	8f 92       	push	r8
    c92e:	9f 92       	push	r9
    c930:	af 92       	push	r10
    c932:	bf 92       	push	r11
    c934:	cf 92       	push	r12
    c936:	df 92       	push	r13
    c938:	ef 92       	push	r14
    c93a:	ff 92       	push	r15
    c93c:	0f 93       	push	r16
    c93e:	1f 93       	push	r17
    c940:	cf 93       	push	r28
    c942:	df 93       	push	r29
    c944:	00 d0       	rcall	.+0      	; 0xc946 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f+0x22>
    c946:	1f 92       	push	r1
    c948:	cd b7       	in	r28, 0x3d	; 61
    c94a:	de b7       	in	r29, 0x3e	; 62
    c94c:	49 01       	movw	r8, r18
    c94e:	5a 01       	movw	r10, r20
				/**
				 * Converts degrees to radians
				 */
				inline static float DegreesToRad(float valueDegrees)
				{
					return valueDegrees * PIOVER180;
    c950:	25 e3       	ldi	r18, 0x35	; 53
    c952:	3a ef       	ldi	r19, 0xFA	; 250
    c954:	4e e8       	ldi	r20, 0x8E	; 142
    c956:	5c e3       	ldi	r21, 0x3C	; 60
    c958:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    c95c:	c6 2e       	mov	r12, r22
    c95e:	d7 2e       	mov	r13, r23
    c960:	e8 2e       	mov	r14, r24
    c962:	f9 2e       	mov	r15, r25
    c964:	25 e3       	ldi	r18, 0x35	; 53
    c966:	3a ef       	ldi	r19, 0xFA	; 250
    c968:	4e e8       	ldi	r20, 0x8E	; 142
    c96a:	5c e3       	ldi	r21, 0x3C	; 60
    c96c:	c5 01       	movw	r24, r10
    c96e:	b4 01       	movw	r22, r8
    c970:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    c974:	86 2e       	mov	r8, r22
    c976:	97 2e       	mov	r9, r23
    c978:	a8 2e       	mov	r10, r24
    c97a:	b9 2e       	mov	r11, r25
	float radLat = DegreesToRad(latitudeDegrees);
	float radLong = DegreesToRad(longitudeDegrees);
	
	float sinLat = sin(radLat);
    c97c:	6c 2d       	mov	r22, r12
    c97e:	7d 2d       	mov	r23, r13
    c980:	8e 2d       	mov	r24, r14
    c982:	9f 2d       	mov	r25, r15
    c984:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    c988:	2b 01       	movw	r4, r22
    c98a:	3c 01       	movw	r6, r24
	float cosLat = cos(radLat);
    c98c:	6c 2d       	mov	r22, r12
    c98e:	7d 2d       	mov	r23, r13
    c990:	8e 2d       	mov	r24, r14
    c992:	9f 2d       	mov	r25, r15
    c994:	0e 94 52 6b 	call	0xd6a4	; 0xd6a4 <cos>
    c998:	69 83       	std	Y+1, r22	; 0x01
    c99a:	7a 83       	std	Y+2, r23	; 0x02
    c99c:	8b 83       	std	Y+3, r24	; 0x03
    c99e:	9c 83       	std	Y+4, r25	; 0x04
	
	float sinLong = sin(radLong);
    c9a0:	68 2d       	mov	r22, r8
    c9a2:	79 2d       	mov	r23, r9
    c9a4:	8a 2d       	mov	r24, r10
    c9a6:	9b 2d       	mov	r25, r11
    c9a8:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    c9ac:	6b 01       	movw	r12, r22
    c9ae:	7c 01       	movw	r14, r24
	float cosLong = cos(radLong);
    c9b0:	68 2d       	mov	r22, r8
    c9b2:	79 2d       	mov	r23, r9
    c9b4:	8a 2d       	mov	r24, r10
    c9b6:	9b 2d       	mov	r25, r11
    c9b8:	0e 94 52 6b 	call	0xd6a4	; 0xd6a4 <cos>
    c9bc:	4b 01       	movw	r8, r22
    c9be:	5c 01       	movw	r10, r24

	//Create a rotation matrix for rotating earth-centered-earth-fixed coordinates
	//into Local North-East-Down coordinates.
	ecefToLocalNEDRotationMatrix[0][0] = -1 * sinLat * cosLong;
    c9c0:	77 fa       	bst	r7, 7
    c9c2:	70 94       	com	r7
    c9c4:	77 f8       	bld	r7, 7
    c9c6:	70 94       	com	r7
    c9c8:	9b 01       	movw	r18, r22
    c9ca:	ac 01       	movw	r20, r24
    c9cc:	c3 01       	movw	r24, r6
    c9ce:	b2 01       	movw	r22, r4
    c9d0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    c9d4:	d8 01       	movw	r26, r16
    c9d6:	6d 93       	st	X+, r22
    c9d8:	7d 93       	st	X+, r23
    c9da:	8d 93       	st	X+, r24
    c9dc:	9c 93       	st	X, r25
    c9de:	13 97       	sbiw	r26, 0x03	; 3
	ecefToLocalNEDRotationMatrix[0][1] = -1 * sinLat * sinLong;
    c9e0:	a3 01       	movw	r20, r6
    c9e2:	92 01       	movw	r18, r4
    c9e4:	c7 01       	movw	r24, r14
    c9e6:	b6 01       	movw	r22, r12
    c9e8:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    c9ec:	f8 01       	movw	r30, r16
    c9ee:	64 83       	std	Z+4, r22	; 0x04
    c9f0:	75 83       	std	Z+5, r23	; 0x05
    c9f2:	86 83       	std	Z+6, r24	; 0x06
    c9f4:	97 83       	std	Z+7, r25	; 0x07
	ecefToLocalNEDRotationMatrix[0][2] = cosLat;
    c9f6:	89 81       	ldd	r24, Y+1	; 0x01
    c9f8:	9a 81       	ldd	r25, Y+2	; 0x02
    c9fa:	ab 81       	ldd	r26, Y+3	; 0x03
    c9fc:	bc 81       	ldd	r27, Y+4	; 0x04
    c9fe:	80 87       	std	Z+8, r24	; 0x08
    ca00:	91 87       	std	Z+9, r25	; 0x09
    ca02:	a2 87       	std	Z+10, r26	; 0x0a
    ca04:	b3 87       	std	Z+11, r27	; 0x0b
	ecefToLocalNEDRotationMatrix[1][0] = -1 * sinLong;
    ca06:	d7 01       	movw	r26, r14
    ca08:	c6 01       	movw	r24, r12
    ca0a:	b0 58       	subi	r27, 0x80	; 128
    ca0c:	84 87       	std	Z+12, r24	; 0x0c
    ca0e:	95 87       	std	Z+13, r25	; 0x0d
    ca10:	a6 87       	std	Z+14, r26	; 0x0e
    ca12:	b7 87       	std	Z+15, r27	; 0x0f
	ecefToLocalNEDRotationMatrix[1][1] = cosLong;
    ca14:	80 8a       	std	Z+16, r8	; 0x10
    ca16:	91 8a       	std	Z+17, r9	; 0x11
    ca18:	a2 8a       	std	Z+18, r10	; 0x12
    ca1a:	b3 8a       	std	Z+19, r11	; 0x13
	ecefToLocalNEDRotationMatrix[1][2] = 0;
    ca1c:	14 8a       	std	Z+20, r1	; 0x14
    ca1e:	15 8a       	std	Z+21, r1	; 0x15
    ca20:	16 8a       	std	Z+22, r1	; 0x16
    ca22:	17 8a       	std	Z+23, r1	; 0x17
	ecefToLocalNEDRotationMatrix[2][0] = -1 * cosLat * cosLong;
    ca24:	89 81       	ldd	r24, Y+1	; 0x01
    ca26:	9a 81       	ldd	r25, Y+2	; 0x02
    ca28:	ab 81       	ldd	r26, Y+3	; 0x03
    ca2a:	bc 81       	ldd	r27, Y+4	; 0x04
    ca2c:	b0 58       	subi	r27, 0x80	; 128
    ca2e:	89 83       	std	Y+1, r24	; 0x01
    ca30:	9a 83       	std	Y+2, r25	; 0x02
    ca32:	ab 83       	std	Y+3, r26	; 0x03
    ca34:	bc 83       	std	Y+4, r27	; 0x04
    ca36:	a5 01       	movw	r20, r10
    ca38:	94 01       	movw	r18, r8
    ca3a:	bc 01       	movw	r22, r24
    ca3c:	cd 01       	movw	r24, r26
    ca3e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    ca42:	d8 01       	movw	r26, r16
    ca44:	58 96       	adiw	r26, 0x18	; 24
    ca46:	6d 93       	st	X+, r22
    ca48:	7d 93       	st	X+, r23
    ca4a:	8d 93       	st	X+, r24
    ca4c:	9c 93       	st	X, r25
    ca4e:	5b 97       	sbiw	r26, 0x1b	; 27
	ecefToLocalNEDRotationMatrix[2][1] = -1 * cosLat * sinLong;
    ca50:	29 81       	ldd	r18, Y+1	; 0x01
    ca52:	3a 81       	ldd	r19, Y+2	; 0x02
    ca54:	4b 81       	ldd	r20, Y+3	; 0x03
    ca56:	5c 81       	ldd	r21, Y+4	; 0x04
    ca58:	c7 01       	movw	r24, r14
    ca5a:	b6 01       	movw	r22, r12
    ca5c:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    ca60:	f8 01       	movw	r30, r16
    ca62:	64 8f       	std	Z+28, r22	; 0x1c
    ca64:	75 8f       	std	Z+29, r23	; 0x1d
    ca66:	86 8f       	std	Z+30, r24	; 0x1e
    ca68:	97 8f       	std	Z+31, r25	; 0x1f
	ecefToLocalNEDRotationMatrix[2][2] = -1 * sinLat;
    ca6a:	40 a2       	std	Z+32, r4	; 0x20
    ca6c:	51 a2       	std	Z+33, r5	; 0x21
    ca6e:	62 a2       	std	Z+34, r6	; 0x22
    ca70:	73 a2       	std	Z+35, r7	; 0x23
}
    ca72:	0f 90       	pop	r0
    ca74:	0f 90       	pop	r0
    ca76:	0f 90       	pop	r0
    ca78:	0f 90       	pop	r0
    ca7a:	df 91       	pop	r29
    ca7c:	cf 91       	pop	r28
    ca7e:	1f 91       	pop	r17
    ca80:	0f 91       	pop	r16
    ca82:	ff 90       	pop	r15
    ca84:	ef 90       	pop	r14
    ca86:	df 90       	pop	r13
    ca88:	cf 90       	pop	r12
    ca8a:	bf 90       	pop	r11
    ca8c:	af 90       	pop	r10
    ca8e:	9f 90       	pop	r9
    ca90:	8f 90       	pop	r8
    ca92:	7f 90       	pop	r7
    ca94:	6f 90       	pop	r6
    ca96:	5f 90       	pop	r5
    ca98:	4f 90       	pop	r4
    ca9a:	08 95       	ret

0000ca9c <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>:


void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
    ca9c:	4f 92       	push	r4
    ca9e:	5f 92       	push	r5
    caa0:	6f 92       	push	r6
    caa2:	7f 92       	push	r7
    caa4:	af 92       	push	r10
    caa6:	bf 92       	push	r11
    caa8:	cf 92       	push	r12
    caaa:	df 92       	push	r13
    caac:	ef 92       	push	r14
    caae:	ff 92       	push	r15
    cab0:	0f 93       	push	r16
    cab2:	1f 93       	push	r17
    cab4:	cf 93       	push	r28
    cab6:	df 93       	push	r29
    cab8:	cd b7       	in	r28, 0x3d	; 61
    caba:	de b7       	in	r29, 0x3e	; 62
    cabc:	6c 97       	sbiw	r28, 0x1c	; 28
    cabe:	0f b6       	in	r0, 0x3f	; 63
    cac0:	f8 94       	cli
    cac2:	de bf       	out	0x3e, r29	; 62
    cac4:	0f be       	out	0x3f, r0	; 63
    cac6:	cd bf       	out	0x3d, r28	; 61
    cac8:	29 8f       	std	Y+25, r18	; 0x19
    caca:	3a 8f       	std	Y+26, r19	; 0x1a
    cacc:	4b 8f       	std	Y+27, r20	; 0x1b
    cace:	5c 8f       	std	Y+28, r21	; 0x1c
    cad0:	27 01       	movw	r4, r14
    cad2:	38 01       	movw	r6, r16
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
    cad4:	8e 01       	movw	r16, r28
    cad6:	03 5f       	subi	r16, 0xF3	; 243
    cad8:	1f 4f       	sbci	r17, 0xFF	; 255
    cada:	2c e0       	ldi	r18, 0x0C	; 12
    cadc:	f8 01       	movw	r30, r16
    cade:	11 92       	st	Z+, r1
    cae0:	2a 95       	dec	r18
    cae2:	e9 f7       	brne	.-6      	; 0xcade <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_+0x42>
void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
    cae4:	a6 01       	movw	r20, r12
    cae6:	95 01       	movw	r18, r10
    cae8:	26 1b       	sub	r18, r22
    caea:	37 0b       	sbc	r19, r23
    caec:	48 0b       	sbc	r20, r24
    caee:	59 0b       	sbc	r21, r25
    caf0:	ca 01       	movw	r24, r20
    caf2:	b9 01       	movw	r22, r18
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    caf4:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    caf8:	69 83       	std	Y+1, r22	; 0x01
    cafa:	7a 83       	std	Y+2, r23	; 0x02
    cafc:	8b 83       	std	Y+3, r24	; 0x03
    cafe:	9c 83       	std	Y+4, r25	; 0x04
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
    cb00:	8e a5       	ldd	r24, Y+46	; 0x2e
    cb02:	9f a5       	ldd	r25, Y+47	; 0x2f
    cb04:	a8 a9       	ldd	r26, Y+48	; 0x30
    cb06:	b9 a9       	ldd	r27, Y+49	; 0x31
    cb08:	bc 01       	movw	r22, r24
    cb0a:	cd 01       	movw	r24, r26
    cb0c:	29 8d       	ldd	r18, Y+25	; 0x19
    cb0e:	3a 8d       	ldd	r19, Y+26	; 0x1a
    cb10:	4b 8d       	ldd	r20, Y+27	; 0x1b
    cb12:	5c 8d       	ldd	r21, Y+28	; 0x1c
    cb14:	62 1b       	sub	r22, r18
    cb16:	73 0b       	sbc	r23, r19
    cb18:	84 0b       	sbc	r24, r20
    cb1a:	95 0b       	sbc	r25, r21
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    cb1c:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    cb20:	6d 83       	std	Y+5, r22	; 0x05
    cb22:	7e 83       	std	Y+6, r23	; 0x06
    cb24:	8f 83       	std	Y+7, r24	; 0x07
    cb26:	98 87       	std	Y+8, r25	; 0x08
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
    cb28:	8a a9       	ldd	r24, Y+50	; 0x32
    cb2a:	9b a9       	ldd	r25, Y+51	; 0x33
    cb2c:	ac a9       	ldd	r26, Y+52	; 0x34
    cb2e:	bd a9       	ldd	r27, Y+53	; 0x35
    cb30:	bc 01       	movw	r22, r24
    cb32:	cd 01       	movw	r24, r26
    cb34:	64 19       	sub	r22, r4
    cb36:	75 09       	sbc	r23, r5
    cb38:	86 09       	sbc	r24, r6
    cb3a:	97 09       	sbc	r25, r7
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    cb3c:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    cb40:	69 87       	std	Y+9, r22	; 0x09
    cb42:	7a 87       	std	Y+10, r23	; 0x0a
    cb44:	8b 87       	std	Y+11, r24	; 0x0b
    cb46:	9c 87       	std	Y+12, r25	; 0x0c
	
	//Rotate the current ecef position from earth centered earth fixed (ECEF) into North-East-Down(NED).
	//Iterate through the rows of the rotation matrix
	MatrixUtil::RotateMatrix(ecefToLocalNEDRotationMatrix,positionMatrix,rotatedMatrix);
    cb48:	a8 01       	movw	r20, r16
    cb4a:	be 01       	movw	r22, r28
    cb4c:	6f 5f       	subi	r22, 0xFF	; 255
    cb4e:	7f 4f       	sbci	r23, 0xFF	; 255
    cb50:	8e a9       	ldd	r24, Y+54	; 0x36
    cb52:	9f a9       	ldd	r25, Y+55	; 0x37
    cb54:	0e 94 40 69 	call	0xd280	; 0xd280 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
	
	localNEDX = rotatedMatrix[0];
    cb58:	8d 85       	ldd	r24, Y+13	; 0x0d
    cb5a:	9e 85       	ldd	r25, Y+14	; 0x0e
    cb5c:	af 85       	ldd	r26, Y+15	; 0x0f
    cb5e:	b8 89       	ldd	r27, Y+16	; 0x10
    cb60:	e8 ad       	ldd	r30, Y+56	; 0x38
    cb62:	f9 ad       	ldd	r31, Y+57	; 0x39
    cb64:	80 83       	st	Z, r24
    cb66:	91 83       	std	Z+1, r25	; 0x01
    cb68:	a2 83       	std	Z+2, r26	; 0x02
    cb6a:	b3 83       	std	Z+3, r27	; 0x03
	localNEDY = rotatedMatrix[1];
    cb6c:	89 89       	ldd	r24, Y+17	; 0x11
    cb6e:	9a 89       	ldd	r25, Y+18	; 0x12
    cb70:	ab 89       	ldd	r26, Y+19	; 0x13
    cb72:	bc 89       	ldd	r27, Y+20	; 0x14
    cb74:	ea ad       	ldd	r30, Y+58	; 0x3a
    cb76:	fb ad       	ldd	r31, Y+59	; 0x3b
    cb78:	80 83       	st	Z, r24
    cb7a:	91 83       	std	Z+1, r25	; 0x01
    cb7c:	a2 83       	std	Z+2, r26	; 0x02
    cb7e:	b3 83       	std	Z+3, r27	; 0x03
	localNEDZ = rotatedMatrix[2];
    cb80:	8d 89       	ldd	r24, Y+21	; 0x15
    cb82:	9e 89       	ldd	r25, Y+22	; 0x16
    cb84:	af 89       	ldd	r26, Y+23	; 0x17
    cb86:	b8 8d       	ldd	r27, Y+24	; 0x18
    cb88:	ec ad       	ldd	r30, Y+60	; 0x3c
    cb8a:	fd ad       	ldd	r31, Y+61	; 0x3d
    cb8c:	80 83       	st	Z, r24
    cb8e:	91 83       	std	Z+1, r25	; 0x01
    cb90:	a2 83       	std	Z+2, r26	; 0x02
    cb92:	b3 83       	std	Z+3, r27	; 0x03
}
    cb94:	6c 96       	adiw	r28, 0x1c	; 28
    cb96:	0f b6       	in	r0, 0x3f	; 63
    cb98:	f8 94       	cli
    cb9a:	de bf       	out	0x3e, r29	; 62
    cb9c:	0f be       	out	0x3f, r0	; 63
    cb9e:	cd bf       	out	0x3d, r28	; 61
    cba0:	df 91       	pop	r29
    cba2:	cf 91       	pop	r28
    cba4:	1f 91       	pop	r17
    cba6:	0f 91       	pop	r16
    cba8:	ff 90       	pop	r15
    cbaa:	ef 90       	pop	r14
    cbac:	df 90       	pop	r13
    cbae:	cf 90       	pop	r12
    cbb0:	bf 90       	pop	r11
    cbb2:	af 90       	pop	r10
    cbb4:	7f 90       	pop	r7
    cbb6:	6f 90       	pop	r6
    cbb8:	5f 90       	pop	r5
    cbba:	4f 90       	pop	r4
    cbbc:	08 95       	ret

0000cbbe <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>:
//float MatrixUtil::sinTable[91] = {0};
	
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
    cbbe:	0f 93       	push	r16
    cbc0:	1f 93       	push	r17
    cbc2:	cf 93       	push	r28
    cbc4:	df 93       	push	r29
    cbc6:	02 e3       	ldi	r16, 0x32	; 50
    cbc8:	14 e0       	ldi	r17, 0x04	; 4
	
	for (int i = 0; i <= max; i++)
    cbca:	c0 e0       	ldi	r28, 0x00	; 0
    cbcc:	d0 e0       	ldi	r29, 0x00	; 0
	{
		sinTable[i] = sin((float)i/(float)RESOLUTION);
    cbce:	be 01       	movw	r22, r28
    cbd0:	88 27       	eor	r24, r24
    cbd2:	77 fd       	sbrc	r23, 7
    cbd4:	80 95       	com	r24
    cbd6:	98 2f       	mov	r25, r24
    cbd8:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    cbdc:	20 e0       	ldi	r18, 0x00	; 0
    cbde:	30 e0       	ldi	r19, 0x00	; 0
    cbe0:	4a ef       	ldi	r20, 0xFA	; 250
    cbe2:	53 e4       	ldi	r21, 0x43	; 67
    cbe4:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    cbe8:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    cbec:	f8 01       	movw	r30, r16
    cbee:	61 93       	st	Z+, r22
    cbf0:	71 93       	st	Z+, r23
    cbf2:	81 93       	st	Z+, r24
    cbf4:	91 93       	st	Z+, r25
    cbf6:	8f 01       	movw	r16, r30
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
	
	for (int i = 0; i <= max; i++)
    cbf8:	21 96       	adiw	r28, 0x01	; 1
    cbfa:	c2 31       	cpi	r28, 0x12	; 18
    cbfc:	f3 e0       	ldi	r31, 0x03	; 3
    cbfe:	df 07       	cpc	r29, r31
    cc00:	31 f7       	brne	.-52     	; 0xcbce <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv+0x10>
	for (int i = 1; i <= 1000; i++)
	{
		sinTable[i-1] = sin(M_PI * i / 1000.0);
	}
	*/
}
    cc02:	df 91       	pop	r29
    cc04:	cf 91       	pop	r28
    cc06:	1f 91       	pop	r17
    cc08:	0f 91       	pop	r16
    cc0a:	08 95       	ret

0000cc0c <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>:
	*/
}


void MatrixUtil::CrossProduct(float vector1[3], float vector2[3], float (&crossProduct)[3])
{
    cc0c:	af 92       	push	r10
    cc0e:	bf 92       	push	r11
    cc10:	cf 92       	push	r12
    cc12:	df 92       	push	r13
    cc14:	ef 92       	push	r14
    cc16:	ff 92       	push	r15
    cc18:	0f 93       	push	r16
    cc1a:	1f 93       	push	r17
    cc1c:	cf 93       	push	r28
    cc1e:	df 93       	push	r29
    cc20:	ec 01       	movw	r28, r24
    cc22:	8b 01       	movw	r16, r22
    cc24:	5a 01       	movw	r10, r20
	crossProduct[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
    cc26:	fb 01       	movw	r30, r22
    cc28:	20 85       	ldd	r18, Z+8	; 0x08
    cc2a:	31 85       	ldd	r19, Z+9	; 0x09
    cc2c:	42 85       	ldd	r20, Z+10	; 0x0a
    cc2e:	53 85       	ldd	r21, Z+11	; 0x0b
    cc30:	6c 81       	ldd	r22, Y+4	; 0x04
    cc32:	7d 81       	ldd	r23, Y+5	; 0x05
    cc34:	8e 81       	ldd	r24, Y+6	; 0x06
    cc36:	9f 81       	ldd	r25, Y+7	; 0x07
    cc38:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cc3c:	6b 01       	movw	r12, r22
    cc3e:	7c 01       	movw	r14, r24
    cc40:	f8 01       	movw	r30, r16
    cc42:	24 81       	ldd	r18, Z+4	; 0x04
    cc44:	35 81       	ldd	r19, Z+5	; 0x05
    cc46:	46 81       	ldd	r20, Z+6	; 0x06
    cc48:	57 81       	ldd	r21, Z+7	; 0x07
    cc4a:	68 85       	ldd	r22, Y+8	; 0x08
    cc4c:	79 85       	ldd	r23, Y+9	; 0x09
    cc4e:	8a 85       	ldd	r24, Y+10	; 0x0a
    cc50:	9b 85       	ldd	r25, Y+11	; 0x0b
    cc52:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cc56:	9b 01       	movw	r18, r22
    cc58:	ac 01       	movw	r20, r24
    cc5a:	c7 01       	movw	r24, r14
    cc5c:	b6 01       	movw	r22, r12
    cc5e:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    cc62:	f5 01       	movw	r30, r10
    cc64:	60 83       	st	Z, r22
    cc66:	71 83       	std	Z+1, r23	; 0x01
    cc68:	82 83       	std	Z+2, r24	; 0x02
    cc6a:	93 83       	std	Z+3, r25	; 0x03
	crossProduct[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];//-1 * (vector1[0] * vector2[2] - vector1[2]*vector2[0]);
    cc6c:	f8 01       	movw	r30, r16
    cc6e:	20 81       	ld	r18, Z
    cc70:	31 81       	ldd	r19, Z+1	; 0x01
    cc72:	42 81       	ldd	r20, Z+2	; 0x02
    cc74:	53 81       	ldd	r21, Z+3	; 0x03
    cc76:	68 85       	ldd	r22, Y+8	; 0x08
    cc78:	79 85       	ldd	r23, Y+9	; 0x09
    cc7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    cc7c:	9b 85       	ldd	r25, Y+11	; 0x0b
    cc7e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cc82:	6b 01       	movw	r12, r22
    cc84:	7c 01       	movw	r14, r24
    cc86:	f8 01       	movw	r30, r16
    cc88:	20 85       	ldd	r18, Z+8	; 0x08
    cc8a:	31 85       	ldd	r19, Z+9	; 0x09
    cc8c:	42 85       	ldd	r20, Z+10	; 0x0a
    cc8e:	53 85       	ldd	r21, Z+11	; 0x0b
    cc90:	68 81       	ld	r22, Y
    cc92:	79 81       	ldd	r23, Y+1	; 0x01
    cc94:	8a 81       	ldd	r24, Y+2	; 0x02
    cc96:	9b 81       	ldd	r25, Y+3	; 0x03
    cc98:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cc9c:	9b 01       	movw	r18, r22
    cc9e:	ac 01       	movw	r20, r24
    cca0:	c7 01       	movw	r24, r14
    cca2:	b6 01       	movw	r22, r12
    cca4:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    cca8:	f5 01       	movw	r30, r10
    ccaa:	64 83       	std	Z+4, r22	; 0x04
    ccac:	75 83       	std	Z+5, r23	; 0x05
    ccae:	86 83       	std	Z+6, r24	; 0x06
    ccb0:	97 83       	std	Z+7, r25	; 0x07
	crossProduct[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
    ccb2:	f8 01       	movw	r30, r16
    ccb4:	24 81       	ldd	r18, Z+4	; 0x04
    ccb6:	35 81       	ldd	r19, Z+5	; 0x05
    ccb8:	46 81       	ldd	r20, Z+6	; 0x06
    ccba:	57 81       	ldd	r21, Z+7	; 0x07
    ccbc:	68 81       	ld	r22, Y
    ccbe:	79 81       	ldd	r23, Y+1	; 0x01
    ccc0:	8a 81       	ldd	r24, Y+2	; 0x02
    ccc2:	9b 81       	ldd	r25, Y+3	; 0x03
    ccc4:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    ccc8:	6b 01       	movw	r12, r22
    ccca:	7c 01       	movw	r14, r24
    cccc:	f8 01       	movw	r30, r16
    ccce:	20 81       	ld	r18, Z
    ccd0:	31 81       	ldd	r19, Z+1	; 0x01
    ccd2:	42 81       	ldd	r20, Z+2	; 0x02
    ccd4:	53 81       	ldd	r21, Z+3	; 0x03
    ccd6:	6c 81       	ldd	r22, Y+4	; 0x04
    ccd8:	7d 81       	ldd	r23, Y+5	; 0x05
    ccda:	8e 81       	ldd	r24, Y+6	; 0x06
    ccdc:	9f 81       	ldd	r25, Y+7	; 0x07
    ccde:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cce2:	9b 01       	movw	r18, r22
    cce4:	ac 01       	movw	r20, r24
    cce6:	c7 01       	movw	r24, r14
    cce8:	b6 01       	movw	r22, r12
    ccea:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    ccee:	f5 01       	movw	r30, r10
    ccf0:	60 87       	std	Z+8, r22	; 0x08
    ccf2:	71 87       	std	Z+9, r23	; 0x09
    ccf4:	82 87       	std	Z+10, r24	; 0x0a
    ccf6:	93 87       	std	Z+11, r25	; 0x0b
}
    ccf8:	df 91       	pop	r29
    ccfa:	cf 91       	pop	r28
    ccfc:	1f 91       	pop	r17
    ccfe:	0f 91       	pop	r16
    cd00:	ff 90       	pop	r15
    cd02:	ef 90       	pop	r14
    cd04:	df 90       	pop	r13
    cd06:	cf 90       	pop	r12
    cd08:	bf 90       	pop	r11
    cd0a:	af 90       	pop	r10
    cd0c:	08 95       	ret

0000cd0e <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>:

void MatrixUtil::Normalize(float (&vector)[3])
{
    cd0e:	4f 92       	push	r4
    cd10:	5f 92       	push	r5
    cd12:	6f 92       	push	r6
    cd14:	7f 92       	push	r7
    cd16:	8f 92       	push	r8
    cd18:	9f 92       	push	r9
    cd1a:	af 92       	push	r10
    cd1c:	bf 92       	push	r11
    cd1e:	cf 92       	push	r12
    cd20:	df 92       	push	r13
    cd22:	ef 92       	push	r14
    cd24:	ff 92       	push	r15
    cd26:	0f 93       	push	r16
    cd28:	1f 93       	push	r17
    cd2a:	cf 93       	push	r28
    cd2c:	df 93       	push	r29
    cd2e:	00 d0       	rcall	.+0      	; 0xcd30 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f+0x22>
    cd30:	1f 92       	push	r1
    cd32:	cd b7       	in	r28, 0x3d	; 61
    cd34:	de b7       	in	r29, 0x3e	; 62
    cd36:	8c 01       	movw	r16, r24
	float magnitude = 0;
	
	//Square each vector value and add it to the magnitude
	for (int i = 0; i < 3; i++)
	{
		magnitude += vector[i] * vector[i];
    cd38:	dc 01       	movw	r26, r24
    cd3a:	8d 91       	ld	r24, X+
    cd3c:	9d 91       	ld	r25, X+
    cd3e:	0d 90       	ld	r0, X+
    cd40:	bc 91       	ld	r27, X
    cd42:	a0 2d       	mov	r26, r0
    cd44:	89 83       	std	Y+1, r24	; 0x01
    cd46:	9a 83       	std	Y+2, r25	; 0x02
    cd48:	ab 83       	std	Y+3, r26	; 0x03
    cd4a:	bc 83       	std	Y+4, r27	; 0x04
    cd4c:	9c 01       	movw	r18, r24
    cd4e:	ad 01       	movw	r20, r26
    cd50:	bc 01       	movw	r22, r24
    cd52:	cd 01       	movw	r24, r26
    cd54:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cd58:	20 e0       	ldi	r18, 0x00	; 0
    cd5a:	30 e0       	ldi	r19, 0x00	; 0
    cd5c:	a9 01       	movw	r20, r18
    cd5e:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    cd62:	c6 2e       	mov	r12, r22
    cd64:	d7 2e       	mov	r13, r23
    cd66:	e8 2e       	mov	r14, r24
    cd68:	f9 2e       	mov	r15, r25
    cd6a:	f8 01       	movw	r30, r16
    cd6c:	44 80       	ldd	r4, Z+4	; 0x04
    cd6e:	55 80       	ldd	r5, Z+5	; 0x05
    cd70:	66 80       	ldd	r6, Z+6	; 0x06
    cd72:	77 80       	ldd	r7, Z+7	; 0x07
    cd74:	a3 01       	movw	r20, r6
    cd76:	92 01       	movw	r18, r4
    cd78:	c3 01       	movw	r24, r6
    cd7a:	b2 01       	movw	r22, r4
    cd7c:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cd80:	9b 01       	movw	r18, r22
    cd82:	ac 01       	movw	r20, r24
    cd84:	6c 2d       	mov	r22, r12
    cd86:	7d 2d       	mov	r23, r13
    cd88:	8e 2d       	mov	r24, r14
    cd8a:	9f 2d       	mov	r25, r15
    cd8c:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    cd90:	86 2e       	mov	r8, r22
    cd92:	97 2e       	mov	r9, r23
    cd94:	a8 2e       	mov	r10, r24
    cd96:	b9 2e       	mov	r11, r25
    cd98:	d8 01       	movw	r26, r16
    cd9a:	18 96       	adiw	r26, 0x08	; 8
    cd9c:	cd 90       	ld	r12, X+
    cd9e:	dd 90       	ld	r13, X+
    cda0:	ed 90       	ld	r14, X+
    cda2:	fc 90       	ld	r15, X
    cda4:	1b 97       	sbiw	r26, 0x0b	; 11
    cda6:	a7 01       	movw	r20, r14
    cda8:	96 01       	movw	r18, r12
    cdaa:	c7 01       	movw	r24, r14
    cdac:	b6 01       	movw	r22, r12
    cdae:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cdb2:	28 2d       	mov	r18, r8
    cdb4:	39 2d       	mov	r19, r9
    cdb6:	4a 2d       	mov	r20, r10
    cdb8:	5b 2d       	mov	r21, r11
    cdba:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
	}
	
	magnitude = sqrt(magnitude);
    cdbe:	0e 94 8c 6e 	call	0xdd18	; 0xdd18 <sqrt>
    cdc2:	4b 01       	movw	r8, r22
    cdc4:	5c 01       	movw	r10, r24
	
	for (int i = 0; i < 3; i++)
	{
		vector[i] = vector[i] / magnitude;
    cdc6:	9b 01       	movw	r18, r22
    cdc8:	ac 01       	movw	r20, r24
    cdca:	69 81       	ldd	r22, Y+1	; 0x01
    cdcc:	7a 81       	ldd	r23, Y+2	; 0x02
    cdce:	8b 81       	ldd	r24, Y+3	; 0x03
    cdd0:	9c 81       	ldd	r25, Y+4	; 0x04
    cdd2:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    cdd6:	f8 01       	movw	r30, r16
    cdd8:	60 83       	st	Z, r22
    cdda:	71 83       	std	Z+1, r23	; 0x01
    cddc:	82 83       	std	Z+2, r24	; 0x02
    cdde:	93 83       	std	Z+3, r25	; 0x03
    cde0:	a5 01       	movw	r20, r10
    cde2:	94 01       	movw	r18, r8
    cde4:	c3 01       	movw	r24, r6
    cde6:	b2 01       	movw	r22, r4
    cde8:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    cdec:	d8 01       	movw	r26, r16
    cdee:	14 96       	adiw	r26, 0x04	; 4
    cdf0:	6d 93       	st	X+, r22
    cdf2:	7d 93       	st	X+, r23
    cdf4:	8d 93       	st	X+, r24
    cdf6:	9c 93       	st	X, r25
    cdf8:	17 97       	sbiw	r26, 0x07	; 7
    cdfa:	a5 01       	movw	r20, r10
    cdfc:	94 01       	movw	r18, r8
    cdfe:	c7 01       	movw	r24, r14
    ce00:	b6 01       	movw	r22, r12
    ce02:	0e 94 55 6b 	call	0xd6aa	; 0xd6aa <__divsf3>
    ce06:	f8 01       	movw	r30, r16
    ce08:	60 87       	std	Z+8, r22	; 0x08
    ce0a:	71 87       	std	Z+9, r23	; 0x09
    ce0c:	82 87       	std	Z+10, r24	; 0x0a
    ce0e:	93 87       	std	Z+11, r25	; 0x0b
	}
}
    ce10:	0f 90       	pop	r0
    ce12:	0f 90       	pop	r0
    ce14:	0f 90       	pop	r0
    ce16:	0f 90       	pop	r0
    ce18:	df 91       	pop	r29
    ce1a:	cf 91       	pop	r28
    ce1c:	1f 91       	pop	r17
    ce1e:	0f 91       	pop	r16
    ce20:	ff 90       	pop	r15
    ce22:	ef 90       	pop	r14
    ce24:	df 90       	pop	r13
    ce26:	cf 90       	pop	r12
    ce28:	bf 90       	pop	r11
    ce2a:	af 90       	pop	r10
    ce2c:	9f 90       	pop	r9
    ce2e:	8f 90       	pop	r8
    ce30:	7f 90       	pop	r7
    ce32:	6f 90       	pop	r6
    ce34:	5f 90       	pop	r5
    ce36:	4f 90       	pop	r4
    ce38:	08 95       	ret

0000ce3a <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>:
		}
	}
}

void MatrixUtil::CreateRotationMatrix( float phiRotationAboutXRads, float thetaRotationAboutYRads, float saiRotationAboutZRads, float (&rotationMatrix)[3][3] )
{
    ce3a:	2f 92       	push	r2
    ce3c:	3f 92       	push	r3
    ce3e:	4f 92       	push	r4
    ce40:	5f 92       	push	r5
    ce42:	6f 92       	push	r6
    ce44:	7f 92       	push	r7
    ce46:	8f 92       	push	r8
    ce48:	9f 92       	push	r9
    ce4a:	af 92       	push	r10
    ce4c:	bf 92       	push	r11
    ce4e:	cf 92       	push	r12
    ce50:	df 92       	push	r13
    ce52:	ef 92       	push	r14
    ce54:	ff 92       	push	r15
    ce56:	0f 93       	push	r16
    ce58:	1f 93       	push	r17
    ce5a:	cf 93       	push	r28
    ce5c:	df 93       	push	r29
    ce5e:	cd b7       	in	r28, 0x3d	; 61
    ce60:	de b7       	in	r29, 0x3e	; 62
    ce62:	66 97       	sbiw	r28, 0x16	; 22
    ce64:	0f b6       	in	r0, 0x3f	; 63
    ce66:	f8 94       	cli
    ce68:	de bf       	out	0x3e, r29	; 62
    ce6a:	0f be       	out	0x3f, r0	; 63
    ce6c:	cd bf       	out	0x3d, r28	; 61
    ce6e:	4b 01       	movw	r8, r22
    ce70:	5c 01       	movw	r10, r24
    ce72:	29 01       	movw	r4, r18
    ce74:	3a 01       	movw	r6, r20
    ce76:	e9 82       	std	Y+1, r14	; 0x01
    ce78:	fa 82       	std	Y+2, r15	; 0x02
    ce7a:	0b 83       	std	Y+3, r16	; 0x03
    ce7c:	1c 83       	std	Y+4, r17	; 0x04
    ce7e:	de 8a       	std	Y+22, r13	; 0x16
    ce80:	cd 8a       	std	Y+21, r12	; 0x15
	rotationMatrix[2][1] = sin(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	rotationMatrix[2][2] = cos(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	*/
	
	
	float sinSai = sin(saiRotationAboutZRads);
    ce82:	c8 01       	movw	r24, r16
    ce84:	b7 01       	movw	r22, r14
    ce86:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    ce8a:	6d 83       	std	Y+5, r22	; 0x05
    ce8c:	7e 83       	std	Y+6, r23	; 0x06
    ce8e:	8f 83       	std	Y+7, r24	; 0x07
    ce90:	98 87       	std	Y+8, r25	; 0x08
	float sinTheta = sin(thetaRotationAboutYRads);
    ce92:	c3 01       	movw	r24, r6
    ce94:	b2 01       	movw	r22, r4
    ce96:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    ce9a:	6d 87       	std	Y+13, r22	; 0x0d
    ce9c:	7e 87       	std	Y+14, r23	; 0x0e
    ce9e:	8f 87       	std	Y+15, r24	; 0x0f
    cea0:	98 8b       	std	Y+16, r25	; 0x10
	float sinPhi = sin(phiRotationAboutXRads);
    cea2:	c5 01       	movw	r24, r10
    cea4:	b4 01       	movw	r22, r8
    cea6:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <sin>
    ceaa:	69 87       	std	Y+9, r22	; 0x09
    ceac:	7a 87       	std	Y+10, r23	; 0x0a
    ceae:	8b 87       	std	Y+11, r24	; 0x0b
    ceb0:	9c 87       	std	Y+12, r25	; 0x0c
	
	float cosSai = cos(saiRotationAboutZRads);
    ceb2:	c8 01       	movw	r24, r16
    ceb4:	b7 01       	movw	r22, r14
    ceb6:	0e 94 52 6b 	call	0xd6a4	; 0xd6a4 <cos>
    ceba:	6b 01       	movw	r12, r22
    cebc:	7c 01       	movw	r14, r24
	float cosTheta = cos(thetaRotationAboutYRads);
    cebe:	c3 01       	movw	r24, r6
    cec0:	b2 01       	movw	r22, r4
    cec2:	0e 94 52 6b 	call	0xd6a4	; 0xd6a4 <cos>
    cec6:	69 83       	std	Y+1, r22	; 0x01
    cec8:	7a 83       	std	Y+2, r23	; 0x02
    ceca:	8b 83       	std	Y+3, r24	; 0x03
    cecc:	9c 83       	std	Y+4, r25	; 0x04
	float cosPhi = cos(phiRotationAboutXRads);	
    cece:	c5 01       	movw	r24, r10
    ced0:	b4 01       	movw	r22, r8
    ced2:	0e 94 52 6b 	call	0xd6a4	; 0xd6a4 <cos>
    ced6:	4b 01       	movw	r8, r22
    ced8:	5c 01       	movw	r10, r24
	float cosTheta = fcos(thetaRotationAboutYRads);
	float cosPhi = fcos(phiRotationAboutXRads);
*/
	
	
	rotationMatrix[0][0] = cosTheta*cosSai;
    ceda:	a7 01       	movw	r20, r14
    cedc:	96 01       	movw	r18, r12
    cede:	69 81       	ldd	r22, Y+1	; 0x01
    cee0:	7a 81       	ldd	r23, Y+2	; 0x02
    cee2:	8b 81       	ldd	r24, Y+3	; 0x03
    cee4:	9c 81       	ldd	r25, Y+4	; 0x04
    cee6:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    ceea:	ed 89       	ldd	r30, Y+21	; 0x15
    ceec:	fe 89       	ldd	r31, Y+22	; 0x16
    ceee:	60 83       	st	Z, r22
    cef0:	71 83       	std	Z+1, r23	; 0x01
    cef2:	82 83       	std	Z+2, r24	; 0x02
    cef4:	93 83       	std	Z+3, r25	; 0x03
	rotationMatrix[0][1] = sinPhi*sinTheta*cosSai - cosPhi*sinSai;
    cef6:	2d 85       	ldd	r18, Y+13	; 0x0d
    cef8:	3e 85       	ldd	r19, Y+14	; 0x0e
    cefa:	4f 85       	ldd	r20, Y+15	; 0x0f
    cefc:	58 89       	ldd	r21, Y+16	; 0x10
    cefe:	69 85       	ldd	r22, Y+9	; 0x09
    cf00:	7a 85       	ldd	r23, Y+10	; 0x0a
    cf02:	8b 85       	ldd	r24, Y+11	; 0x0b
    cf04:	9c 85       	ldd	r25, Y+12	; 0x0c
    cf06:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf0a:	36 2e       	mov	r3, r22
    cf0c:	27 2e       	mov	r2, r23
    cf0e:	89 8b       	std	Y+17, r24	; 0x11
    cf10:	9a 8b       	std	Y+18, r25	; 0x12
    cf12:	a7 01       	movw	r20, r14
    cf14:	96 01       	movw	r18, r12
    cf16:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf1a:	2b 01       	movw	r4, r22
    cf1c:	3c 01       	movw	r6, r24
    cf1e:	2d 81       	ldd	r18, Y+5	; 0x05
    cf20:	3e 81       	ldd	r19, Y+6	; 0x06
    cf22:	4f 81       	ldd	r20, Y+7	; 0x07
    cf24:	58 85       	ldd	r21, Y+8	; 0x08
    cf26:	c5 01       	movw	r24, r10
    cf28:	b4 01       	movw	r22, r8
    cf2a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf2e:	9b 01       	movw	r18, r22
    cf30:	ac 01       	movw	r20, r24
    cf32:	c3 01       	movw	r24, r6
    cf34:	b2 01       	movw	r22, r4
    cf36:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    cf3a:	ed 89       	ldd	r30, Y+21	; 0x15
    cf3c:	fe 89       	ldd	r31, Y+22	; 0x16
    cf3e:	64 83       	std	Z+4, r22	; 0x04
    cf40:	75 83       	std	Z+5, r23	; 0x05
    cf42:	86 83       	std	Z+6, r24	; 0x06
    cf44:	97 83       	std	Z+7, r25	; 0x07
	rotationMatrix[0][2] = cosPhi*sinTheta*cosSai + sinPhi*sinSai;
    cf46:	2d 85       	ldd	r18, Y+13	; 0x0d
    cf48:	3e 85       	ldd	r19, Y+14	; 0x0e
    cf4a:	4f 85       	ldd	r20, Y+15	; 0x0f
    cf4c:	58 89       	ldd	r21, Y+16	; 0x10
    cf4e:	c5 01       	movw	r24, r10
    cf50:	b4 01       	movw	r22, r8
    cf52:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf56:	06 2f       	mov	r16, r22
    cf58:	17 2f       	mov	r17, r23
    cf5a:	8b 8b       	std	Y+19, r24	; 0x13
    cf5c:	9c 8b       	std	Y+20, r25	; 0x14
    cf5e:	a7 01       	movw	r20, r14
    cf60:	96 01       	movw	r18, r12
    cf62:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf66:	2b 01       	movw	r4, r22
    cf68:	3c 01       	movw	r6, r24
    cf6a:	2d 81       	ldd	r18, Y+5	; 0x05
    cf6c:	3e 81       	ldd	r19, Y+6	; 0x06
    cf6e:	4f 81       	ldd	r20, Y+7	; 0x07
    cf70:	58 85       	ldd	r21, Y+8	; 0x08
    cf72:	69 85       	ldd	r22, Y+9	; 0x09
    cf74:	7a 85       	ldd	r23, Y+10	; 0x0a
    cf76:	8b 85       	ldd	r24, Y+11	; 0x0b
    cf78:	9c 85       	ldd	r25, Y+12	; 0x0c
    cf7a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cf7e:	9b 01       	movw	r18, r22
    cf80:	ac 01       	movw	r20, r24
    cf82:	c3 01       	movw	r24, r6
    cf84:	b2 01       	movw	r22, r4
    cf86:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    cf8a:	ed 89       	ldd	r30, Y+21	; 0x15
    cf8c:	fe 89       	ldd	r31, Y+22	; 0x16
    cf8e:	60 87       	std	Z+8, r22	; 0x08
    cf90:	71 87       	std	Z+9, r23	; 0x09
    cf92:	82 87       	std	Z+10, r24	; 0x0a
    cf94:	93 87       	std	Z+11, r25	; 0x0b
	rotationMatrix[1][0] = cosTheta*sinSai;
    cf96:	2d 81       	ldd	r18, Y+5	; 0x05
    cf98:	3e 81       	ldd	r19, Y+6	; 0x06
    cf9a:	4f 81       	ldd	r20, Y+7	; 0x07
    cf9c:	58 85       	ldd	r21, Y+8	; 0x08
    cf9e:	69 81       	ldd	r22, Y+1	; 0x01
    cfa0:	7a 81       	ldd	r23, Y+2	; 0x02
    cfa2:	8b 81       	ldd	r24, Y+3	; 0x03
    cfa4:	9c 81       	ldd	r25, Y+4	; 0x04
    cfa6:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cfaa:	ed 89       	ldd	r30, Y+21	; 0x15
    cfac:	fe 89       	ldd	r31, Y+22	; 0x16
    cfae:	64 87       	std	Z+12, r22	; 0x0c
    cfb0:	75 87       	std	Z+13, r23	; 0x0d
    cfb2:	86 87       	std	Z+14, r24	; 0x0e
    cfb4:	97 87       	std	Z+15, r25	; 0x0f
	rotationMatrix[1][1] = sinPhi*sinTheta*sinSai + cosPhi*cosSai;
    cfb6:	99 89       	ldd	r25, Y+17	; 0x11
    cfb8:	8a 89       	ldd	r24, Y+18	; 0x12
    cfba:	23 2d       	mov	r18, r3
    cfbc:	32 2d       	mov	r19, r2
    cfbe:	49 2f       	mov	r20, r25
    cfc0:	58 2f       	mov	r21, r24
    cfc2:	6d 81       	ldd	r22, Y+5	; 0x05
    cfc4:	7e 81       	ldd	r23, Y+6	; 0x06
    cfc6:	8f 81       	ldd	r24, Y+7	; 0x07
    cfc8:	98 85       	ldd	r25, Y+8	; 0x08
    cfca:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cfce:	2b 01       	movw	r4, r22
    cfd0:	3c 01       	movw	r6, r24
    cfd2:	a7 01       	movw	r20, r14
    cfd4:	96 01       	movw	r18, r12
    cfd6:	c5 01       	movw	r24, r10
    cfd8:	b4 01       	movw	r22, r8
    cfda:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    cfde:	9b 01       	movw	r18, r22
    cfe0:	ac 01       	movw	r20, r24
    cfe2:	c3 01       	movw	r24, r6
    cfe4:	b2 01       	movw	r22, r4
    cfe6:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    cfea:	ed 89       	ldd	r30, Y+21	; 0x15
    cfec:	fe 89       	ldd	r31, Y+22	; 0x16
    cfee:	60 8b       	std	Z+16, r22	; 0x10
    cff0:	71 8b       	std	Z+17, r23	; 0x11
    cff2:	82 8b       	std	Z+18, r24	; 0x12
    cff4:	93 8b       	std	Z+19, r25	; 0x13
	rotationMatrix[1][2] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
    cff6:	9b 89       	ldd	r25, Y+19	; 0x13
    cff8:	8c 89       	ldd	r24, Y+20	; 0x14
    cffa:	20 2f       	mov	r18, r16
    cffc:	31 2f       	mov	r19, r17
    cffe:	49 2f       	mov	r20, r25
    d000:	58 2f       	mov	r21, r24
    d002:	6d 81       	ldd	r22, Y+5	; 0x05
    d004:	7e 81       	ldd	r23, Y+6	; 0x06
    d006:	8f 81       	ldd	r24, Y+7	; 0x07
    d008:	98 85       	ldd	r25, Y+8	; 0x08
    d00a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d00e:	2b 01       	movw	r4, r22
    d010:	3c 01       	movw	r6, r24
    d012:	a7 01       	movw	r20, r14
    d014:	96 01       	movw	r18, r12
    d016:	69 85       	ldd	r22, Y+9	; 0x09
    d018:	7a 85       	ldd	r23, Y+10	; 0x0a
    d01a:	8b 85       	ldd	r24, Y+11	; 0x0b
    d01c:	9c 85       	ldd	r25, Y+12	; 0x0c
    d01e:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d022:	9b 01       	movw	r18, r22
    d024:	ac 01       	movw	r20, r24
    d026:	c3 01       	movw	r24, r6
    d028:	b2 01       	movw	r22, r4
    d02a:	0e 94 70 6a 	call	0xd4e0	; 0xd4e0 <__subsf3>
    d02e:	ed 89       	ldd	r30, Y+21	; 0x15
    d030:	fe 89       	ldd	r31, Y+22	; 0x16
    d032:	64 8b       	std	Z+20, r22	; 0x14
    d034:	75 8b       	std	Z+21, r23	; 0x15
    d036:	86 8b       	std	Z+22, r24	; 0x16
    d038:	97 8b       	std	Z+23, r25	; 0x17
	rotationMatrix[2][0] = -sinTheta;
    d03a:	8d 85       	ldd	r24, Y+13	; 0x0d
    d03c:	9e 85       	ldd	r25, Y+14	; 0x0e
    d03e:	af 85       	ldd	r26, Y+15	; 0x0f
    d040:	b8 89       	ldd	r27, Y+16	; 0x10
    d042:	b0 58       	subi	r27, 0x80	; 128
    d044:	80 8f       	std	Z+24, r24	; 0x18
    d046:	91 8f       	std	Z+25, r25	; 0x19
    d048:	a2 8f       	std	Z+26, r26	; 0x1a
    d04a:	b3 8f       	std	Z+27, r27	; 0x1b
	rotationMatrix[2][1] = sinPhi*cosTheta;
    d04c:	29 81       	ldd	r18, Y+1	; 0x01
    d04e:	3a 81       	ldd	r19, Y+2	; 0x02
    d050:	4b 81       	ldd	r20, Y+3	; 0x03
    d052:	5c 81       	ldd	r21, Y+4	; 0x04
    d054:	69 85       	ldd	r22, Y+9	; 0x09
    d056:	7a 85       	ldd	r23, Y+10	; 0x0a
    d058:	8b 85       	ldd	r24, Y+11	; 0x0b
    d05a:	9c 85       	ldd	r25, Y+12	; 0x0c
    d05c:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d060:	ed 89       	ldd	r30, Y+21	; 0x15
    d062:	fe 89       	ldd	r31, Y+22	; 0x16
    d064:	64 8f       	std	Z+28, r22	; 0x1c
    d066:	75 8f       	std	Z+29, r23	; 0x1d
    d068:	86 8f       	std	Z+30, r24	; 0x1e
    d06a:	97 8f       	std	Z+31, r25	; 0x1f
	rotationMatrix[2][2] = cosPhi*cosTheta;
    d06c:	29 81       	ldd	r18, Y+1	; 0x01
    d06e:	3a 81       	ldd	r19, Y+2	; 0x02
    d070:	4b 81       	ldd	r20, Y+3	; 0x03
    d072:	5c 81       	ldd	r21, Y+4	; 0x04
    d074:	c5 01       	movw	r24, r10
    d076:	b4 01       	movw	r22, r8
    d078:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d07c:	ed 89       	ldd	r30, Y+21	; 0x15
    d07e:	fe 89       	ldd	r31, Y+22	; 0x16
    d080:	60 a3       	std	Z+32, r22	; 0x20
    d082:	71 a3       	std	Z+33, r23	; 0x21
    d084:	82 a3       	std	Z+34, r24	; 0x22
    d086:	93 a3       	std	Z+35, r25	; 0x23
}
    d088:	66 96       	adiw	r28, 0x16	; 22
    d08a:	0f b6       	in	r0, 0x3f	; 63
    d08c:	f8 94       	cli
    d08e:	de bf       	out	0x3e, r29	; 62
    d090:	0f be       	out	0x3f, r0	; 63
    d092:	cd bf       	out	0x3d, r28	; 61
    d094:	df 91       	pop	r29
    d096:	cf 91       	pop	r28
    d098:	1f 91       	pop	r17
    d09a:	0f 91       	pop	r16
    d09c:	ff 90       	pop	r15
    d09e:	ef 90       	pop	r14
    d0a0:	df 90       	pop	r13
    d0a2:	cf 90       	pop	r12
    d0a4:	bf 90       	pop	r11
    d0a6:	af 90       	pop	r10
    d0a8:	9f 90       	pop	r9
    d0aa:	8f 90       	pop	r8
    d0ac:	7f 90       	pop	r7
    d0ae:	6f 90       	pop	r6
    d0b0:	5f 90       	pop	r5
    d0b2:	4f 90       	pop	r4
    d0b4:	3f 90       	pop	r3
    d0b6:	2f 90       	pop	r2
    d0b8:	08 95       	ret

0000d0ba <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>:
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d0ba:	4f 92       	push	r4
    d0bc:	5f 92       	push	r5
    d0be:	6f 92       	push	r6
    d0c0:	7f 92       	push	r7
    d0c2:	8f 92       	push	r8
    d0c4:	9f 92       	push	r9
    d0c6:	af 92       	push	r10
    d0c8:	bf 92       	push	r11
    d0ca:	cf 92       	push	r12
    d0cc:	df 92       	push	r13
    d0ce:	ef 92       	push	r14
    d0d0:	ff 92       	push	r15
    d0d2:	0f 93       	push	r16
    d0d4:	1f 93       	push	r17
    d0d6:	cf 93       	push	r28
    d0d8:	df 93       	push	r29
    d0da:	4c 01       	movw	r8, r24
    d0dc:	46 2e       	mov	r4, r22
    d0de:	57 2e       	mov	r5, r23
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d0e0:	e4 2f       	mov	r30, r20
    d0e2:	f5 2f       	mov	r31, r21
    d0e4:	8c e0       	ldi	r24, 0x0C	; 12
    d0e6:	df 01       	movw	r26, r30
    d0e8:	1d 92       	st	X+, r1
    d0ea:	8a 95       	dec	r24
    d0ec:	e9 f7       	brne	.-6      	; 0xd0e8 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x2e>
    d0ee:	e4 2e       	mov	r14, r20
    d0f0:	f5 2e       	mov	r15, r21
    d0f2:	c1 2c       	mov	r12, r1
    d0f4:	d1 2c       	mov	r13, r1
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d0f6:	61 2c       	mov	r6, r1
    d0f8:	71 2c       	mov	r7, r1
    d0fa:	2b c0       	rjmp	.+86     	; 0xd152 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x98>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
    d0fc:	f8 01       	movw	r30, r16
    d0fe:	61 91       	ld	r22, Z+
    d100:	71 91       	ld	r23, Z+
    d102:	81 91       	ld	r24, Z+
    d104:	91 91       	ld	r25, Z+
    d106:	8f 01       	movw	r16, r30
	rotationMatrix[2][1] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d108:	f5 01       	movw	r30, r10
    d10a:	ec 0f       	add	r30, r28
    d10c:	fd 1f       	adc	r31, r29
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
    d10e:	20 81       	ld	r18, Z
    d110:	31 81       	ldd	r19, Z+1	; 0x01
    d112:	42 81       	ldd	r20, Z+2	; 0x02
    d114:	53 81       	ldd	r21, Z+3	; 0x03
    d116:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d11a:	9b 01       	movw	r18, r22
    d11c:	ac 01       	movw	r20, r24
    d11e:	d7 01       	movw	r26, r14
    d120:	6d 91       	ld	r22, X+
    d122:	7d 91       	ld	r23, X+
    d124:	8d 91       	ld	r24, X+
    d126:	9c 91       	ld	r25, X
    d128:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    d12c:	f7 01       	movw	r30, r14
    d12e:	60 83       	st	Z, r22
    d130:	71 83       	std	Z+1, r23	; 0x01
    d132:	82 83       	std	Z+2, r24	; 0x02
    d134:	93 83       	std	Z+3, r25	; 0x03
    d136:	2c 96       	adiw	r28, 0x0c	; 12
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d138:	c4 32       	cpi	r28, 0x24	; 36
    d13a:	d1 05       	cpc	r29, r1
    d13c:	f9 f6       	brne	.-66     	; 0xd0fc <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x42>
    d13e:	f4 e0       	ldi	r31, 0x04	; 4
    d140:	cf 0e       	add	r12, r31
    d142:	d1 1c       	adc	r13, r1
    d144:	84 e0       	ldi	r24, 0x04	; 4
    d146:	e8 0e       	add	r14, r24
    d148:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d14a:	ac e0       	ldi	r26, 0x0C	; 12
    d14c:	ca 16       	cp	r12, r26
    d14e:	d1 04       	cpc	r13, r1
    d150:	39 f0       	breq	.+14     	; 0xd160 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0xa6>
    d152:	04 2d       	mov	r16, r4
    d154:	15 2d       	mov	r17, r5
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d156:	e3 01       	movw	r28, r6
	rotationMatrix[2][1] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d158:	54 01       	movw	r10, r8
    d15a:	ac 0c       	add	r10, r12
    d15c:	bd 1c       	adc	r11, r13
    d15e:	ce cf       	rjmp	.-100    	; 0xd0fc <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x42>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}
    d160:	df 91       	pop	r29
    d162:	cf 91       	pop	r28
    d164:	1f 91       	pop	r17
    d166:	0f 91       	pop	r16
    d168:	ff 90       	pop	r15
    d16a:	ef 90       	pop	r14
    d16c:	df 90       	pop	r13
    d16e:	cf 90       	pop	r12
    d170:	bf 90       	pop	r11
    d172:	af 90       	pop	r10
    d174:	9f 90       	pop	r9
    d176:	8f 90       	pop	r8
    d178:	7f 90       	pop	r7
    d17a:	6f 90       	pop	r6
    d17c:	5f 90       	pop	r5
    d17e:	4f 90       	pop	r4
    d180:	08 95       	ret

0000d182 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
{
    d182:	2f 92       	push	r2
    d184:	3f 92       	push	r3
    d186:	4f 92       	push	r4
    d188:	5f 92       	push	r5
    d18a:	6f 92       	push	r6
    d18c:	7f 92       	push	r7
    d18e:	8f 92       	push	r8
    d190:	9f 92       	push	r9
    d192:	af 92       	push	r10
    d194:	bf 92       	push	r11
    d196:	cf 92       	push	r12
    d198:	df 92       	push	r13
    d19a:	ef 92       	push	r14
    d19c:	ff 92       	push	r15
    d19e:	0f 93       	push	r16
    d1a0:	1f 93       	push	r17
    d1a2:	cf 93       	push	r28
    d1a4:	df 93       	push	r29
    d1a6:	00 d0       	rcall	.+0      	; 0xd1a8 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x26>
    d1a8:	1f 92       	push	r1
    d1aa:	cd b7       	in	r28, 0x3d	; 61
    d1ac:	de b7       	in	r29, 0x3e	; 62
    d1ae:	4c 01       	movw	r8, r24
    d1b0:	69 83       	std	Y+1, r22	; 0x01
    d1b2:	7a 83       	std	Y+2, r23	; 0x02
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d1b4:	e4 2f       	mov	r30, r20
    d1b6:	f5 2f       	mov	r31, r21
    d1b8:	8c e0       	ldi	r24, 0x0C	; 12
    d1ba:	df 01       	movw	r26, r30
    d1bc:	1d 92       	st	X+, r1
    d1be:	8a 95       	dec	r24
    d1c0:	e9 f7       	brne	.-6      	; 0xd1bc <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x3a>
    d1c2:	e4 2e       	mov	r14, r20
    d1c4:	f5 2e       	mov	r15, r21
    d1c6:	a1 2c       	mov	r10, r1
    d1c8:	b1 2c       	mov	r11, r1
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
    d1ca:	0f 2e       	mov	r0, r31
    d1cc:	f3 e0       	ldi	r31, 0x03	; 3
    d1ce:	2f 2e       	mov	r2, r31
    d1d0:	31 2c       	mov	r3, r1
    d1d2:	f0 2d       	mov	r31, r0
    d1d4:	36 c0       	rjmp	.+108    	; 0xd242 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xc0>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    d1d6:	f6 01       	movw	r30, r12
    d1d8:	41 90       	ld	r4, Z+
    d1da:	51 90       	ld	r5, Z+
    d1dc:	61 90       	ld	r6, Z+
    d1de:	71 90       	ld	r7, Z+
    d1e0:	6f 01       	movw	r12, r30
    d1e2:	d8 01       	movw	r26, r16
    d1e4:	6d 91       	ld	r22, X+
    d1e6:	7d 91       	ld	r23, X+
    d1e8:	8d 01       	movw	r16, r26
    d1ea:	88 27       	eor	r24, r24
    d1ec:	77 fd       	sbrc	r23, 7
    d1ee:	80 95       	com	r24
    d1f0:	98 2f       	mov	r25, r24
    d1f2:	0e 94 f0 6b 	call	0xd7e0	; 0xd7e0 <__floatsisf>
    d1f6:	9b 01       	movw	r18, r22
    d1f8:	ac 01       	movw	r20, r24
    d1fa:	c3 01       	movw	r24, r6
    d1fc:	b2 01       	movw	r22, r4
    d1fe:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d202:	9b 01       	movw	r18, r22
    d204:	ac 01       	movw	r20, r24
    d206:	f7 01       	movw	r30, r14
    d208:	60 81       	ld	r22, Z
    d20a:	71 81       	ldd	r23, Z+1	; 0x01
    d20c:	82 81       	ldd	r24, Z+2	; 0x02
    d20e:	93 81       	ldd	r25, Z+3	; 0x03
    d210:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    d214:	d7 01       	movw	r26, r14
    d216:	6d 93       	st	X+, r22
    d218:	7d 93       	st	X+, r23
    d21a:	8d 93       	st	X+, r24
    d21c:	9c 93       	st	X, r25
    d21e:	13 97       	sbiw	r26, 0x03	; 3
    d220:	eb 81       	ldd	r30, Y+3	; 0x03
    d222:	fc 81       	ldd	r31, Y+4	; 0x04
    d224:	31 97       	sbiw	r30, 0x01	; 1
    d226:	fc 83       	std	Y+4, r31	; 0x04
    d228:	eb 83       	std	Y+3, r30	; 0x03
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d22a:	ef 2b       	or	r30, r31
    d22c:	a1 f6       	brne	.-88     	; 0xd1d6 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x54>
    d22e:	fc e0       	ldi	r31, 0x0C	; 12
    d230:	af 0e       	add	r10, r31
    d232:	b1 1c       	adc	r11, r1
    d234:	84 e0       	ldi	r24, 0x04	; 4
    d236:	e8 0e       	add	r14, r24
    d238:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d23a:	94 e2       	ldi	r25, 0x24	; 36
    d23c:	a9 16       	cp	r10, r25
    d23e:	b1 04       	cpc	r11, r1
    d240:	41 f0       	breq	.+16     	; 0xd252 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xd0>
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
    d242:	64 01       	movw	r12, r8
    d244:	ca 0c       	add	r12, r10
    d246:	db 1c       	adc	r13, r11
    d248:	09 81       	ldd	r16, Y+1	; 0x01
    d24a:	1a 81       	ldd	r17, Y+2	; 0x02
    d24c:	3c 82       	std	Y+4, r3	; 0x04
    d24e:	2b 82       	std	Y+3, r2	; 0x03
    d250:	c2 cf       	rjmp	.-124    	; 0xd1d6 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x54>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    d252:	0f 90       	pop	r0
    d254:	0f 90       	pop	r0
    d256:	0f 90       	pop	r0
    d258:	0f 90       	pop	r0
    d25a:	df 91       	pop	r29
    d25c:	cf 91       	pop	r28
    d25e:	1f 91       	pop	r17
    d260:	0f 91       	pop	r16
    d262:	ff 90       	pop	r15
    d264:	ef 90       	pop	r14
    d266:	df 90       	pop	r13
    d268:	cf 90       	pop	r12
    d26a:	bf 90       	pop	r11
    d26c:	af 90       	pop	r10
    d26e:	9f 90       	pop	r9
    d270:	8f 90       	pop	r8
    d272:	7f 90       	pop	r7
    d274:	6f 90       	pop	r6
    d276:	5f 90       	pop	r5
    d278:	4f 90       	pop	r4
    d27a:	3f 90       	pop	r3
    d27c:	2f 90       	pop	r2
    d27e:	08 95       	ret

0000d280 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d280:	4f 92       	push	r4
    d282:	5f 92       	push	r5
    d284:	6f 92       	push	r6
    d286:	7f 92       	push	r7
    d288:	8f 92       	push	r8
    d28a:	9f 92       	push	r9
    d28c:	af 92       	push	r10
    d28e:	bf 92       	push	r11
    d290:	cf 92       	push	r12
    d292:	df 92       	push	r13
    d294:	ef 92       	push	r14
    d296:	ff 92       	push	r15
    d298:	0f 93       	push	r16
    d29a:	1f 93       	push	r17
    d29c:	cf 93       	push	r28
    d29e:	df 93       	push	r29
    d2a0:	4c 01       	movw	r8, r24
    d2a2:	46 2e       	mov	r4, r22
    d2a4:	57 2e       	mov	r5, r23
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d2a6:	e4 2f       	mov	r30, r20
    d2a8:	f5 2f       	mov	r31, r21
    d2aa:	8c e0       	ldi	r24, 0x0C	; 12
    d2ac:	df 01       	movw	r26, r30
    d2ae:	1d 92       	st	X+, r1
    d2b0:	8a 95       	dec	r24
    d2b2:	e9 f7       	brne	.-6      	; 0xd2ae <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x2e>
    d2b4:	e4 2e       	mov	r14, r20
    d2b6:	f5 2e       	mov	r15, r21
    d2b8:	a1 2c       	mov	r10, r1
    d2ba:	b1 2c       	mov	r11, r1
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d2bc:	0f 2e       	mov	r0, r31
    d2be:	f3 e0       	ldi	r31, 0x03	; 3
    d2c0:	6f 2e       	mov	r6, r31
    d2c2:	71 2c       	mov	r7, r1
    d2c4:	f0 2d       	mov	r31, r0
    d2c6:	29 c0       	rjmp	.+82     	; 0xd31a <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x9a>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    d2c8:	f6 01       	movw	r30, r12
    d2ca:	61 91       	ld	r22, Z+
    d2cc:	71 91       	ld	r23, Z+
    d2ce:	81 91       	ld	r24, Z+
    d2d0:	91 91       	ld	r25, Z+
    d2d2:	6f 01       	movw	r12, r30
    d2d4:	d8 01       	movw	r26, r16
    d2d6:	2d 91       	ld	r18, X+
    d2d8:	3d 91       	ld	r19, X+
    d2da:	4d 91       	ld	r20, X+
    d2dc:	5d 91       	ld	r21, X+
    d2de:	8d 01       	movw	r16, r26
    d2e0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d2e4:	9b 01       	movw	r18, r22
    d2e6:	ac 01       	movw	r20, r24
    d2e8:	f7 01       	movw	r30, r14
    d2ea:	60 81       	ld	r22, Z
    d2ec:	71 81       	ldd	r23, Z+1	; 0x01
    d2ee:	82 81       	ldd	r24, Z+2	; 0x02
    d2f0:	93 81       	ldd	r25, Z+3	; 0x03
    d2f2:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    d2f6:	d7 01       	movw	r26, r14
    d2f8:	6d 93       	st	X+, r22
    d2fa:	7d 93       	st	X+, r23
    d2fc:	8d 93       	st	X+, r24
    d2fe:	9c 93       	st	X, r25
    d300:	13 97       	sbiw	r26, 0x03	; 3
    d302:	21 97       	sbiw	r28, 0x01	; 1
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d304:	09 f7       	brne	.-62     	; 0xd2c8 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x48>
    d306:	bc e0       	ldi	r27, 0x0C	; 12
    d308:	ab 0e       	add	r10, r27
    d30a:	b1 1c       	adc	r11, r1
    d30c:	e4 e0       	ldi	r30, 0x04	; 4
    d30e:	ee 0e       	add	r14, r30
    d310:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d312:	f4 e2       	ldi	r31, 0x24	; 36
    d314:	af 16       	cp	r10, r31
    d316:	b1 04       	cpc	r11, r1
    d318:	39 f0       	breq	.+14     	; 0xd328 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0xa8>
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d31a:	64 01       	movw	r12, r8
    d31c:	ca 0c       	add	r12, r10
    d31e:	db 1c       	adc	r13, r11
    d320:	04 2d       	mov	r16, r4
    d322:	15 2d       	mov	r17, r5
    d324:	e3 01       	movw	r28, r6
    d326:	d0 cf       	rjmp	.-96     	; 0xd2c8 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x48>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    d328:	df 91       	pop	r29
    d32a:	cf 91       	pop	r28
    d32c:	1f 91       	pop	r17
    d32e:	0f 91       	pop	r16
    d330:	ff 90       	pop	r15
    d332:	ef 90       	pop	r14
    d334:	df 90       	pop	r13
    d336:	cf 90       	pop	r12
    d338:	bf 90       	pop	r11
    d33a:	af 90       	pop	r10
    d33c:	9f 90       	pop	r9
    d33e:	8f 90       	pop	r8
    d340:	7f 90       	pop	r7
    d342:	6f 90       	pop	r6
    d344:	5f 90       	pop	r5
    d346:	4f 90       	pop	r4
    d348:	08 95       	ret

0000d34a <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>:
	RotateMatrix(rotationMatrix, valuesToRotate, rotatedValues);
}


float MatrixUtil::DotProduct( float vector1[3], float vector2[3] )
{
    d34a:	cf 92       	push	r12
    d34c:	df 92       	push	r13
    d34e:	ef 92       	push	r14
    d350:	ff 92       	push	r15
    d352:	0f 93       	push	r16
    d354:	1f 93       	push	r17
    d356:	cf 93       	push	r28
    d358:	df 93       	push	r29
    d35a:	ec 01       	movw	r28, r24
    d35c:	8b 01       	movw	r16, r22
	return vector1[0]*vector2[0] + vector1[1]*vector2[1] + vector1[2]*vector2[2];
    d35e:	fb 01       	movw	r30, r22
    d360:	20 81       	ld	r18, Z
    d362:	31 81       	ldd	r19, Z+1	; 0x01
    d364:	42 81       	ldd	r20, Z+2	; 0x02
    d366:	53 81       	ldd	r21, Z+3	; 0x03
    d368:	68 81       	ld	r22, Y
    d36a:	79 81       	ldd	r23, Y+1	; 0x01
    d36c:	8a 81       	ldd	r24, Y+2	; 0x02
    d36e:	9b 81       	ldd	r25, Y+3	; 0x03
    d370:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d374:	6b 01       	movw	r12, r22
    d376:	7c 01       	movw	r14, r24
    d378:	f8 01       	movw	r30, r16
    d37a:	24 81       	ldd	r18, Z+4	; 0x04
    d37c:	35 81       	ldd	r19, Z+5	; 0x05
    d37e:	46 81       	ldd	r20, Z+6	; 0x06
    d380:	57 81       	ldd	r21, Z+7	; 0x07
    d382:	6c 81       	ldd	r22, Y+4	; 0x04
    d384:	7d 81       	ldd	r23, Y+5	; 0x05
    d386:	8e 81       	ldd	r24, Y+6	; 0x06
    d388:	9f 81       	ldd	r25, Y+7	; 0x07
    d38a:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d38e:	9b 01       	movw	r18, r22
    d390:	ac 01       	movw	r20, r24
    d392:	c7 01       	movw	r24, r14
    d394:	b6 01       	movw	r22, r12
    d396:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
    d39a:	6b 01       	movw	r12, r22
    d39c:	7c 01       	movw	r14, r24
    d39e:	f8 01       	movw	r30, r16
    d3a0:	20 85       	ldd	r18, Z+8	; 0x08
    d3a2:	31 85       	ldd	r19, Z+9	; 0x09
    d3a4:	42 85       	ldd	r20, Z+10	; 0x0a
    d3a6:	53 85       	ldd	r21, Z+11	; 0x0b
    d3a8:	68 85       	ldd	r22, Y+8	; 0x08
    d3aa:	79 85       	ldd	r23, Y+9	; 0x09
    d3ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    d3ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    d3b0:	0e 94 d3 6d 	call	0xdba6	; 0xdba6 <__mulsf3>
    d3b4:	9b 01       	movw	r18, r22
    d3b6:	ac 01       	movw	r20, r24
    d3b8:	c7 01       	movw	r24, r14
    d3ba:	b6 01       	movw	r22, r12
    d3bc:	0e 94 71 6a 	call	0xd4e2	; 0xd4e2 <__addsf3>
}
    d3c0:	df 91       	pop	r29
    d3c2:	cf 91       	pop	r28
    d3c4:	1f 91       	pop	r17
    d3c6:	0f 91       	pop	r16
    d3c8:	ff 90       	pop	r15
    d3ca:	ef 90       	pop	r14
    d3cc:	df 90       	pop	r13
    d3ce:	cf 90       	pop	r12
    d3d0:	08 95       	ret

0000d3d2 <_ZN10helicopter4util5Timer11hasTimedoutEv>:
{
	//Check the Timer Interrupt Flags Register (TIFR) to determine if the flag was set indicating
	//that the timer has timed out.
	//return (TIFR0 & (1<<OCF0A)) != 0;
	
	return timeoutCounter>=numberOfTimeouts;
    d3d2:	61 e0       	ldi	r22, 0x01	; 1
    d3d4:	fc 01       	movw	r30, r24
    d3d6:	40 85       	ldd	r20, Z+8	; 0x08
    d3d8:	51 85       	ldd	r21, Z+9	; 0x09
    d3da:	20 91 7a 10 	lds	r18, 0x107A
    d3de:	30 91 7b 10 	lds	r19, 0x107B
    d3e2:	24 17       	cp	r18, r20
    d3e4:	35 07       	cpc	r19, r21
    d3e6:	0c f4       	brge	.+2      	; 0xd3ea <_ZN10helicopter4util5Timer11hasTimedoutEv+0x18>
    d3e8:	60 e0       	ldi	r22, 0x00	; 0
}
    d3ea:	86 2f       	mov	r24, r22
    d3ec:	08 95       	ret

0000d3ee <_ZN10helicopter4util5Timer9stopTimerEv>:

void Timer::stopTimer()
{
	//Disable interrupt.
	TIMSK0 &= ~(1 << OCIE0A);
    d3ee:	ee e6       	ldi	r30, 0x6E	; 110
    d3f0:	f0 e0       	ldi	r31, 0x00	; 0
    d3f2:	80 81       	ld	r24, Z
    d3f4:	8d 7f       	andi	r24, 0xFD	; 253
    d3f6:	80 83       	st	Z, r24
	
	//stop the timer
	TCCR0B = 0;
    d3f8:	15 bc       	out	0x25, r1	; 37
	
	//Then clear the timer counter (sets the count back to 0 so when the timer starts again, it starts from 0). 
	//Clear after stopping in order to avoid missing a compare match.
	TCNT0 = 0;
    d3fa:	16 bc       	out	0x26, r1	; 38
	
	//clear the timeout flag.
	TIFR0 |= (1<<OCF0A);
    d3fc:	a9 9a       	sbi	0x15, 1	; 21
	
	timeoutCounter = 0;
    d3fe:	10 92 7b 10 	sts	0x107B, r1
    d402:	10 92 7a 10 	sts	0x107A, r1
    d406:	08 95       	ret

0000d408 <_ZN10helicopter4util5Timer10startTimerEv>:

int Timer::timeoutCounter = 0;


void Timer::startTimer()
{
    d408:	cf 93       	push	r28
    d40a:	df 93       	push	r29
    d40c:	ec 01       	movw	r28, r24
	//stop timer in case it was already started.
	stopTimer();
    d40e:	0e 94 f7 69 	call	0xd3ee	; 0xd3ee <_ZN10helicopter4util5Timer9stopTimerEv>
	//setup timer.
	//set the output compare register so that when the Timer Counter (TCNT) matches this output register
	//it indicates that the timer has timed out.
	OCR0A = ((cpuSpeed /  timerPrescaler) / frequency);
	*/ 
	OCR0A = ((cpuSpeed /  timerPrescaler) / 100); //fire off every 10 ms. 
    d412:	2c 81       	ldd	r18, Y+4	; 0x04
    d414:	3d 81       	ldd	r19, Y+5	; 0x05
    d416:	44 27       	eor	r20, r20
    d418:	37 fd       	sbrc	r19, 7
    d41a:	40 95       	com	r20
    d41c:	54 2f       	mov	r21, r20
    d41e:	68 81       	ld	r22, Y
    d420:	79 81       	ldd	r23, Y+1	; 0x01
    d422:	8a 81       	ldd	r24, Y+2	; 0x02
    d424:	9b 81       	ldd	r25, Y+3	; 0x03
    d426:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    d42a:	ca 01       	movw	r24, r20
    d42c:	b9 01       	movw	r22, r18
    d42e:	24 e6       	ldi	r18, 0x64	; 100
    d430:	30 e0       	ldi	r19, 0x00	; 0
    d432:	40 e0       	ldi	r20, 0x00	; 0
    d434:	50 e0       	ldi	r21, 0x00	; 0
    d436:	0e 94 72 6f 	call	0xdee4	; 0xdee4 <__udivmodsi4>
    d43a:	27 bd       	out	0x27, r18	; 39
	timeoutCounter = 0;
    d43c:	10 92 7b 10 	sts	0x107B, r1
    d440:	10 92 7a 10 	sts	0x107A, r1
		
	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
	//note, this is different than the 8 bit timer which sets wgmn1 on tccrna to set CTC.
	TCCR0A |= (1 << WGM01); 
    d444:	84 b5       	in	r24, 0x24	; 36
    d446:	82 60       	ori	r24, 0x02	; 2
    d448:	84 bd       	out	0x24, r24	; 36
		
	//TCCR3A |= (1 << WGM31);	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
		
	
	
	TIMSK0 |= (1 << OCIE0A); //enable ctc interrupt for OCR0A
    d44a:	ee e6       	ldi	r30, 0x6E	; 110
    d44c:	f0 e0       	ldi	r31, 0x00	; 0
    d44e:	80 81       	ld	r24, Z
    d450:	82 60       	ori	r24, 0x02	; 2
    d452:	80 83       	st	Z, r24
		
		
		
	//Set the Timer Counter Control Register (TCCR) with the appropriate prescaller
	//which causes the timer counter to start (i.e. the timer starts).
	switch(timerPrescaler)
    d454:	8c 81       	ldd	r24, Y+4	; 0x04
    d456:	9d 81       	ldd	r25, Y+5	; 0x05
    d458:	80 34       	cpi	r24, 0x40	; 64
    d45a:	91 05       	cpc	r25, r1
    d45c:	b9 f0       	breq	.+46     	; 0xd48c <_ZN10helicopter4util5Timer10startTimerEv+0x84>
    d45e:	34 f4       	brge	.+12     	; 0xd46c <_ZN10helicopter4util5Timer10startTimerEv+0x64>
    d460:	81 30       	cpi	r24, 0x01	; 1
    d462:	91 05       	cpc	r25, r1
    d464:	59 f0       	breq	.+22     	; 0xd47c <_ZN10helicopter4util5Timer10startTimerEv+0x74>
    d466:	08 97       	sbiw	r24, 0x08	; 8
    d468:	e9 f4       	brne	.+58     	; 0xd4a4 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
    d46a:	0c c0       	rjmp	.+24     	; 0xd484 <_ZN10helicopter4util5Timer10startTimerEv+0x7c>
    d46c:	81 15       	cp	r24, r1
    d46e:	21 e0       	ldi	r18, 0x01	; 1
    d470:	92 07       	cpc	r25, r18
    d472:	81 f0       	breq	.+32     	; 0xd494 <_ZN10helicopter4util5Timer10startTimerEv+0x8c>
    d474:	81 15       	cp	r24, r1
    d476:	94 40       	sbci	r25, 0x04	; 4
    d478:	a9 f4       	brne	.+42     	; 0xd4a4 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
    d47a:	10 c0       	rjmp	.+32     	; 0xd49c <_ZN10helicopter4util5Timer10startTimerEv+0x94>
	{
		case NO_PRESCALER:
		TCCR0B |= NoPrescaling;
    d47c:	85 b5       	in	r24, 0x25	; 37
    d47e:	81 60       	ori	r24, 0x01	; 1
    d480:	85 bd       	out	0x25, r24	; 37
		break;
    d482:	13 c0       	rjmp	.+38     	; 0xd4aa <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_EIGHT:
		TCCR0B |= PrescaleByEight;
    d484:	85 b5       	in	r24, 0x25	; 37
    d486:	82 60       	ori	r24, 0x02	; 2
    d488:	85 bd       	out	0x25, r24	; 37
		break;
    d48a:	0f c0       	rjmp	.+30     	; 0xd4aa <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_SIXTYFOUR:
		TCCR0B |= PrescaleBySixtyFour;
    d48c:	85 b5       	in	r24, 0x25	; 37
    d48e:	83 60       	ori	r24, 0x03	; 3
    d490:	85 bd       	out	0x25, r24	; 37
		break;
    d492:	0b c0       	rjmp	.+22     	; 0xd4aa <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TWOFIFTYSIX:
		TCCR0B |= PrescaleByTwofiftysix;
    d494:	85 b5       	in	r24, 0x25	; 37
    d496:	84 60       	ori	r24, 0x04	; 4
    d498:	85 bd       	out	0x25, r24	; 37
		break;
    d49a:	07 c0       	rjmp	.+14     	; 0xd4aa <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TENTWENTYFOUR:
		TCCR0B |= PrescaleByTentwentyfour;
    d49c:	85 b5       	in	r24, 0x25	; 37
    d49e:	85 60       	ori	r24, 0x05	; 5
    d4a0:	85 bd       	out	0x25, r24	; 37
		break;
    d4a2:	03 c0       	rjmp	.+6      	; 0xd4aa <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		default:
		TCCR0B |= NoPrescaling;
    d4a4:	85 b5       	in	r24, 0x25	; 37
    d4a6:	81 60       	ori	r24, 0x01	; 1
    d4a8:	85 bd       	out	0x25, r24	; 37
	}
	
	sei();
    d4aa:	78 94       	sei
}
    d4ac:	df 91       	pop	r29
    d4ae:	cf 91       	pop	r28
    d4b0:	08 95       	ret

0000d4b2 <__vector_21>:
	
	timeoutCounter = 0;
}

ISR(TIMER0_COMPA_vect)
{
    d4b2:	1f 92       	push	r1
    d4b4:	0f 92       	push	r0
    d4b6:	0f b6       	in	r0, 0x3f	; 63
    d4b8:	0f 92       	push	r0
    d4ba:	11 24       	eor	r1, r1
    d4bc:	8f 93       	push	r24
    d4be:	9f 93       	push	r25
	Timer::timeoutCounter++;
    d4c0:	80 91 7a 10 	lds	r24, 0x107A
    d4c4:	90 91 7b 10 	lds	r25, 0x107B
    d4c8:	01 96       	adiw	r24, 0x01	; 1
    d4ca:	90 93 7b 10 	sts	0x107B, r25
    d4ce:	80 93 7a 10 	sts	0x107A, r24
    d4d2:	9f 91       	pop	r25
    d4d4:	8f 91       	pop	r24
    d4d6:	0f 90       	pop	r0
    d4d8:	0f be       	out	0x3f, r0	; 63
    d4da:	0f 90       	pop	r0
    d4dc:	1f 90       	pop	r1
    d4de:	18 95       	reti

0000d4e0 <__subsf3>:
    d4e0:	50 58       	subi	r21, 0x80	; 128

0000d4e2 <__addsf3>:
    d4e2:	bb 27       	eor	r27, r27
    d4e4:	aa 27       	eor	r26, r26
    d4e6:	0e d0       	rcall	.+28     	; 0xd504 <__addsf3x>
    d4e8:	a6 c2       	rjmp	.+1356   	; 0xda36 <__fp_round>
    d4ea:	6f d2       	rcall	.+1246   	; 0xd9ca <__fp_pscA>
    d4ec:	30 f0       	brcs	.+12     	; 0xd4fa <__addsf3+0x18>
    d4ee:	74 d2       	rcall	.+1256   	; 0xd9d8 <__fp_pscB>
    d4f0:	20 f0       	brcs	.+8      	; 0xd4fa <__addsf3+0x18>
    d4f2:	31 f4       	brne	.+12     	; 0xd500 <__addsf3+0x1e>
    d4f4:	9f 3f       	cpi	r25, 0xFF	; 255
    d4f6:	11 f4       	brne	.+4      	; 0xd4fc <__addsf3+0x1a>
    d4f8:	1e f4       	brtc	.+6      	; 0xd500 <__addsf3+0x1e>
    d4fa:	2e c2       	rjmp	.+1116   	; 0xd958 <__fp_nan>
    d4fc:	0e f4       	brtc	.+2      	; 0xd500 <__addsf3+0x1e>
    d4fe:	e0 95       	com	r30
    d500:	e7 fb       	bst	r30, 7
    d502:	fb c1       	rjmp	.+1014   	; 0xd8fa <__fp_inf>

0000d504 <__addsf3x>:
    d504:	e9 2f       	mov	r30, r25
    d506:	b9 d2       	rcall	.+1394   	; 0xda7a <__fp_split3>
    d508:	80 f3       	brcs	.-32     	; 0xd4ea <__addsf3+0x8>
    d50a:	ba 17       	cp	r27, r26
    d50c:	62 07       	cpc	r22, r18
    d50e:	73 07       	cpc	r23, r19
    d510:	84 07       	cpc	r24, r20
    d512:	95 07       	cpc	r25, r21
    d514:	18 f0       	brcs	.+6      	; 0xd51c <__addsf3x+0x18>
    d516:	71 f4       	brne	.+28     	; 0xd534 <__addsf3x+0x30>
    d518:	9e f5       	brtc	.+102    	; 0xd580 <__addsf3x+0x7c>
    d51a:	e8 c2       	rjmp	.+1488   	; 0xdaec <__fp_zero>
    d51c:	0e f4       	brtc	.+2      	; 0xd520 <__addsf3x+0x1c>
    d51e:	e0 95       	com	r30
    d520:	0b 2e       	mov	r0, r27
    d522:	ba 2f       	mov	r27, r26
    d524:	a0 2d       	mov	r26, r0
    d526:	0b 01       	movw	r0, r22
    d528:	b9 01       	movw	r22, r18
    d52a:	90 01       	movw	r18, r0
    d52c:	0c 01       	movw	r0, r24
    d52e:	ca 01       	movw	r24, r20
    d530:	a0 01       	movw	r20, r0
    d532:	11 24       	eor	r1, r1
    d534:	ff 27       	eor	r31, r31
    d536:	59 1b       	sub	r21, r25
    d538:	99 f0       	breq	.+38     	; 0xd560 <__addsf3x+0x5c>
    d53a:	59 3f       	cpi	r21, 0xF9	; 249
    d53c:	50 f4       	brcc	.+20     	; 0xd552 <__addsf3x+0x4e>
    d53e:	50 3e       	cpi	r21, 0xE0	; 224
    d540:	68 f1       	brcs	.+90     	; 0xd59c <__addsf3x+0x98>
    d542:	1a 16       	cp	r1, r26
    d544:	f0 40       	sbci	r31, 0x00	; 0
    d546:	a2 2f       	mov	r26, r18
    d548:	23 2f       	mov	r18, r19
    d54a:	34 2f       	mov	r19, r20
    d54c:	44 27       	eor	r20, r20
    d54e:	58 5f       	subi	r21, 0xF8	; 248
    d550:	f3 cf       	rjmp	.-26     	; 0xd538 <__addsf3x+0x34>
    d552:	46 95       	lsr	r20
    d554:	37 95       	ror	r19
    d556:	27 95       	ror	r18
    d558:	a7 95       	ror	r26
    d55a:	f0 40       	sbci	r31, 0x00	; 0
    d55c:	53 95       	inc	r21
    d55e:	c9 f7       	brne	.-14     	; 0xd552 <__addsf3x+0x4e>
    d560:	7e f4       	brtc	.+30     	; 0xd580 <__addsf3x+0x7c>
    d562:	1f 16       	cp	r1, r31
    d564:	ba 0b       	sbc	r27, r26
    d566:	62 0b       	sbc	r22, r18
    d568:	73 0b       	sbc	r23, r19
    d56a:	84 0b       	sbc	r24, r20
    d56c:	ba f0       	brmi	.+46     	; 0xd59c <__addsf3x+0x98>
    d56e:	91 50       	subi	r25, 0x01	; 1
    d570:	a1 f0       	breq	.+40     	; 0xd59a <__addsf3x+0x96>
    d572:	ff 0f       	add	r31, r31
    d574:	bb 1f       	adc	r27, r27
    d576:	66 1f       	adc	r22, r22
    d578:	77 1f       	adc	r23, r23
    d57a:	88 1f       	adc	r24, r24
    d57c:	c2 f7       	brpl	.-16     	; 0xd56e <__addsf3x+0x6a>
    d57e:	0e c0       	rjmp	.+28     	; 0xd59c <__addsf3x+0x98>
    d580:	ba 0f       	add	r27, r26
    d582:	62 1f       	adc	r22, r18
    d584:	73 1f       	adc	r23, r19
    d586:	84 1f       	adc	r24, r20
    d588:	48 f4       	brcc	.+18     	; 0xd59c <__addsf3x+0x98>
    d58a:	87 95       	ror	r24
    d58c:	77 95       	ror	r23
    d58e:	67 95       	ror	r22
    d590:	b7 95       	ror	r27
    d592:	f7 95       	ror	r31
    d594:	9e 3f       	cpi	r25, 0xFE	; 254
    d596:	08 f0       	brcs	.+2      	; 0xd59a <__addsf3x+0x96>
    d598:	b3 cf       	rjmp	.-154    	; 0xd500 <__addsf3+0x1e>
    d59a:	93 95       	inc	r25
    d59c:	88 0f       	add	r24, r24
    d59e:	08 f0       	brcs	.+2      	; 0xd5a2 <__addsf3x+0x9e>
    d5a0:	99 27       	eor	r25, r25
    d5a2:	ee 0f       	add	r30, r30
    d5a4:	97 95       	ror	r25
    d5a6:	87 95       	ror	r24
    d5a8:	08 95       	ret

0000d5aa <asin>:
    d5aa:	9f 93       	push	r25
    d5ac:	9f 77       	andi	r25, 0x7F	; 127
    d5ae:	ee e3       	ldi	r30, 0x3E	; 62
    d5b0:	89 37       	cpi	r24, 0x79	; 121
    d5b2:	9e 07       	cpc	r25, r30
    d5b4:	20 f4       	brcc	.+8      	; 0xd5be <asin+0x14>
    d5b6:	e4 ee       	ldi	r30, 0xE4	; 228
    d5b8:	f0 e0       	ldi	r31, 0x00	; 0
    d5ba:	f6 d1       	rcall	.+1004   	; 0xd9a8 <__fp_powsodd>
    d5bc:	09 c0       	rjmp	.+18     	; 0xd5d0 <asin+0x26>
    d5be:	5e d1       	rcall	.+700    	; 0xd87c <__fp_arccos>
    d5c0:	90 58       	subi	r25, 0x80	; 128
    d5c2:	a2 ea       	ldi	r26, 0xA2	; 162
    d5c4:	2a ed       	ldi	r18, 0xDA	; 218
    d5c6:	3f e0       	ldi	r19, 0x0F	; 15
    d5c8:	49 ec       	ldi	r20, 0xC9	; 201
    d5ca:	5f e3       	ldi	r21, 0x3F	; 63
    d5cc:	9b df       	rcall	.-202    	; 0xd504 <__addsf3x>
    d5ce:	33 d2       	rcall	.+1126   	; 0xda36 <__fp_round>
    d5d0:	0f 90       	pop	r0
    d5d2:	07 fc       	sbrc	r0, 7
    d5d4:	90 58       	subi	r25, 0x80	; 128
    d5d6:	08 95       	ret
    d5d8:	f8 d1       	rcall	.+1008   	; 0xd9ca <__fp_pscA>
    d5da:	58 f0       	brcs	.+22     	; 0xd5f2 <asin+0x48>
    d5dc:	80 e8       	ldi	r24, 0x80	; 128
    d5de:	91 e0       	ldi	r25, 0x01	; 1
    d5e0:	09 f4       	brne	.+2      	; 0xd5e4 <asin+0x3a>
    d5e2:	9e ef       	ldi	r25, 0xFE	; 254
    d5e4:	f9 d1       	rcall	.+1010   	; 0xd9d8 <__fp_pscB>
    d5e6:	28 f0       	brcs	.+10     	; 0xd5f2 <asin+0x48>
    d5e8:	40 e8       	ldi	r20, 0x80	; 128
    d5ea:	51 e0       	ldi	r21, 0x01	; 1
    d5ec:	59 f4       	brne	.+22     	; 0xd604 <atan2+0xe>
    d5ee:	5e ef       	ldi	r21, 0xFE	; 254
    d5f0:	09 c0       	rjmp	.+18     	; 0xd604 <atan2+0xe>
    d5f2:	b2 c1       	rjmp	.+868    	; 0xd958 <__fp_nan>
    d5f4:	7b c2       	rjmp	.+1270   	; 0xdaec <__fp_zero>

0000d5f6 <atan2>:
    d5f6:	e9 2f       	mov	r30, r25
    d5f8:	e0 78       	andi	r30, 0x80	; 128
    d5fa:	3f d2       	rcall	.+1150   	; 0xda7a <__fp_split3>
    d5fc:	68 f3       	brcs	.-38     	; 0xd5d8 <asin+0x2e>
    d5fe:	09 2e       	mov	r0, r25
    d600:	05 2a       	or	r0, r21
    d602:	c1 f3       	breq	.-16     	; 0xd5f4 <asin+0x4a>
    d604:	26 17       	cp	r18, r22
    d606:	37 07       	cpc	r19, r23
    d608:	48 07       	cpc	r20, r24
    d60a:	59 07       	cpc	r21, r25
    d60c:	38 f0       	brcs	.+14     	; 0xd61c <atan2+0x26>
    d60e:	0e 2e       	mov	r0, r30
    d610:	07 f8       	bld	r0, 7
    d612:	e0 25       	eor	r30, r0
    d614:	69 f0       	breq	.+26     	; 0xd630 <atan2+0x3a>
    d616:	e0 25       	eor	r30, r0
    d618:	e0 64       	ori	r30, 0x40	; 64
    d61a:	0a c0       	rjmp	.+20     	; 0xd630 <atan2+0x3a>
    d61c:	ef 63       	ori	r30, 0x3F	; 63
    d61e:	07 f8       	bld	r0, 7
    d620:	00 94       	com	r0
    d622:	07 fa       	bst	r0, 7
    d624:	db 01       	movw	r26, r22
    d626:	b9 01       	movw	r22, r18
    d628:	9d 01       	movw	r18, r26
    d62a:	dc 01       	movw	r26, r24
    d62c:	ca 01       	movw	r24, r20
    d62e:	ad 01       	movw	r20, r26
    d630:	ef 93       	push	r30
    d632:	4a d0       	rcall	.+148    	; 0xd6c8 <__divsf3_pse>
    d634:	00 d2       	rcall	.+1024   	; 0xda36 <__fp_round>
    d636:	0a d0       	rcall	.+20     	; 0xd64c <atan>
    d638:	5f 91       	pop	r21
    d63a:	55 23       	and	r21, r21
    d63c:	31 f0       	breq	.+12     	; 0xd64a <atan2+0x54>
    d63e:	2b ed       	ldi	r18, 0xDB	; 219
    d640:	3f e0       	ldi	r19, 0x0F	; 15
    d642:	49 e4       	ldi	r20, 0x49	; 73
    d644:	50 fd       	sbrc	r21, 0
    d646:	49 ec       	ldi	r20, 0xC9	; 201
    d648:	4c cf       	rjmp	.-360    	; 0xd4e2 <__addsf3>
    d64a:	08 95       	ret

0000d64c <atan>:
    d64c:	df 93       	push	r29
    d64e:	dd 27       	eor	r29, r29
    d650:	b9 2f       	mov	r27, r25
    d652:	bf 77       	andi	r27, 0x7F	; 127
    d654:	40 e8       	ldi	r20, 0x80	; 128
    d656:	5f e3       	ldi	r21, 0x3F	; 63
    d658:	16 16       	cp	r1, r22
    d65a:	17 06       	cpc	r1, r23
    d65c:	48 07       	cpc	r20, r24
    d65e:	5b 07       	cpc	r21, r27
    d660:	10 f4       	brcc	.+4      	; 0xd666 <atan+0x1a>
    d662:	d9 2f       	mov	r29, r25
    d664:	4e d2       	rcall	.+1180   	; 0xdb02 <inverse>
    d666:	9f 93       	push	r25
    d668:	8f 93       	push	r24
    d66a:	7f 93       	push	r23
    d66c:	6f 93       	push	r22
    d66e:	92 d3       	rcall	.+1828   	; 0xdd94 <square>
    d670:	e8 ef       	ldi	r30, 0xF8	; 248
    d672:	f0 e0       	ldi	r31, 0x00	; 0
    d674:	74 d1       	rcall	.+744    	; 0xd95e <__fp_powser>
    d676:	df d1       	rcall	.+958    	; 0xda36 <__fp_round>
    d678:	2f 91       	pop	r18
    d67a:	3f 91       	pop	r19
    d67c:	4f 91       	pop	r20
    d67e:	5f 91       	pop	r21
    d680:	9e d2       	rcall	.+1340   	; 0xdbbe <__mulsf3x>
    d682:	dd 23       	and	r29, r29
    d684:	49 f0       	breq	.+18     	; 0xd698 <atan+0x4c>
    d686:	90 58       	subi	r25, 0x80	; 128
    d688:	a2 ea       	ldi	r26, 0xA2	; 162
    d68a:	2a ed       	ldi	r18, 0xDA	; 218
    d68c:	3f e0       	ldi	r19, 0x0F	; 15
    d68e:	49 ec       	ldi	r20, 0xC9	; 201
    d690:	5f e3       	ldi	r21, 0x3F	; 63
    d692:	d0 78       	andi	r29, 0x80	; 128
    d694:	5d 27       	eor	r21, r29
    d696:	36 df       	rcall	.-404    	; 0xd504 <__addsf3x>
    d698:	df 91       	pop	r29
    d69a:	cd c1       	rjmp	.+922    	; 0xda36 <__fp_round>

0000d69c <__cmpsf2>:
    d69c:	0a d1       	rcall	.+532    	; 0xd8b2 <__fp_cmp>
    d69e:	08 f4       	brcc	.+2      	; 0xd6a2 <__cmpsf2+0x6>
    d6a0:	81 e0       	ldi	r24, 0x01	; 1
    d6a2:	08 95       	ret

0000d6a4 <cos>:
    d6a4:	a1 d1       	rcall	.+834    	; 0xd9e8 <__fp_rempio2>
    d6a6:	e3 95       	inc	r30
    d6a8:	d7 c1       	rjmp	.+942    	; 0xda58 <__fp_sinus>

0000d6aa <__divsf3>:
    d6aa:	0c d0       	rcall	.+24     	; 0xd6c4 <__divsf3x>
    d6ac:	c4 c1       	rjmp	.+904    	; 0xda36 <__fp_round>
    d6ae:	94 d1       	rcall	.+808    	; 0xd9d8 <__fp_pscB>
    d6b0:	40 f0       	brcs	.+16     	; 0xd6c2 <__divsf3+0x18>
    d6b2:	8b d1       	rcall	.+790    	; 0xd9ca <__fp_pscA>
    d6b4:	30 f0       	brcs	.+12     	; 0xd6c2 <__divsf3+0x18>
    d6b6:	21 f4       	brne	.+8      	; 0xd6c0 <__divsf3+0x16>
    d6b8:	5f 3f       	cpi	r21, 0xFF	; 255
    d6ba:	19 f0       	breq	.+6      	; 0xd6c2 <__divsf3+0x18>
    d6bc:	1e c1       	rjmp	.+572    	; 0xd8fa <__fp_inf>
    d6be:	51 11       	cpse	r21, r1
    d6c0:	16 c2       	rjmp	.+1068   	; 0xdaee <__fp_szero>
    d6c2:	4a c1       	rjmp	.+660    	; 0xd958 <__fp_nan>

0000d6c4 <__divsf3x>:
    d6c4:	da d1       	rcall	.+948    	; 0xda7a <__fp_split3>
    d6c6:	98 f3       	brcs	.-26     	; 0xd6ae <__divsf3+0x4>

0000d6c8 <__divsf3_pse>:
    d6c8:	99 23       	and	r25, r25
    d6ca:	c9 f3       	breq	.-14     	; 0xd6be <__divsf3+0x14>
    d6cc:	55 23       	and	r21, r21
    d6ce:	b1 f3       	breq	.-20     	; 0xd6bc <__divsf3+0x12>
    d6d0:	95 1b       	sub	r25, r21
    d6d2:	55 0b       	sbc	r21, r21
    d6d4:	bb 27       	eor	r27, r27
    d6d6:	aa 27       	eor	r26, r26
    d6d8:	62 17       	cp	r22, r18
    d6da:	73 07       	cpc	r23, r19
    d6dc:	84 07       	cpc	r24, r20
    d6de:	38 f0       	brcs	.+14     	; 0xd6ee <__divsf3_pse+0x26>
    d6e0:	9f 5f       	subi	r25, 0xFF	; 255
    d6e2:	5f 4f       	sbci	r21, 0xFF	; 255
    d6e4:	22 0f       	add	r18, r18
    d6e6:	33 1f       	adc	r19, r19
    d6e8:	44 1f       	adc	r20, r20
    d6ea:	aa 1f       	adc	r26, r26
    d6ec:	a9 f3       	breq	.-22     	; 0xd6d8 <__divsf3_pse+0x10>
    d6ee:	33 d0       	rcall	.+102    	; 0xd756 <__divsf3_pse+0x8e>
    d6f0:	0e 2e       	mov	r0, r30
    d6f2:	3a f0       	brmi	.+14     	; 0xd702 <__divsf3_pse+0x3a>
    d6f4:	e0 e8       	ldi	r30, 0x80	; 128
    d6f6:	30 d0       	rcall	.+96     	; 0xd758 <__divsf3_pse+0x90>
    d6f8:	91 50       	subi	r25, 0x01	; 1
    d6fa:	50 40       	sbci	r21, 0x00	; 0
    d6fc:	e6 95       	lsr	r30
    d6fe:	00 1c       	adc	r0, r0
    d700:	ca f7       	brpl	.-14     	; 0xd6f4 <__divsf3_pse+0x2c>
    d702:	29 d0       	rcall	.+82     	; 0xd756 <__divsf3_pse+0x8e>
    d704:	fe 2f       	mov	r31, r30
    d706:	27 d0       	rcall	.+78     	; 0xd756 <__divsf3_pse+0x8e>
    d708:	66 0f       	add	r22, r22
    d70a:	77 1f       	adc	r23, r23
    d70c:	88 1f       	adc	r24, r24
    d70e:	bb 1f       	adc	r27, r27
    d710:	26 17       	cp	r18, r22
    d712:	37 07       	cpc	r19, r23
    d714:	48 07       	cpc	r20, r24
    d716:	ab 07       	cpc	r26, r27
    d718:	b0 e8       	ldi	r27, 0x80	; 128
    d71a:	09 f0       	breq	.+2      	; 0xd71e <__divsf3_pse+0x56>
    d71c:	bb 0b       	sbc	r27, r27
    d71e:	80 2d       	mov	r24, r0
    d720:	bf 01       	movw	r22, r30
    d722:	ff 27       	eor	r31, r31
    d724:	93 58       	subi	r25, 0x83	; 131
    d726:	5f 4f       	sbci	r21, 0xFF	; 255
    d728:	2a f0       	brmi	.+10     	; 0xd734 <__divsf3_pse+0x6c>
    d72a:	9e 3f       	cpi	r25, 0xFE	; 254
    d72c:	51 05       	cpc	r21, r1
    d72e:	68 f0       	brcs	.+26     	; 0xd74a <__divsf3_pse+0x82>
    d730:	e4 c0       	rjmp	.+456    	; 0xd8fa <__fp_inf>
    d732:	dd c1       	rjmp	.+954    	; 0xdaee <__fp_szero>
    d734:	5f 3f       	cpi	r21, 0xFF	; 255
    d736:	ec f3       	brlt	.-6      	; 0xd732 <__divsf3_pse+0x6a>
    d738:	98 3e       	cpi	r25, 0xE8	; 232
    d73a:	dc f3       	brlt	.-10     	; 0xd732 <__divsf3_pse+0x6a>
    d73c:	86 95       	lsr	r24
    d73e:	77 95       	ror	r23
    d740:	67 95       	ror	r22
    d742:	b7 95       	ror	r27
    d744:	f7 95       	ror	r31
    d746:	9f 5f       	subi	r25, 0xFF	; 255
    d748:	c9 f7       	brne	.-14     	; 0xd73c <__divsf3_pse+0x74>
    d74a:	88 0f       	add	r24, r24
    d74c:	91 1d       	adc	r25, r1
    d74e:	96 95       	lsr	r25
    d750:	87 95       	ror	r24
    d752:	97 f9       	bld	r25, 7
    d754:	08 95       	ret
    d756:	e1 e0       	ldi	r30, 0x01	; 1
    d758:	66 0f       	add	r22, r22
    d75a:	77 1f       	adc	r23, r23
    d75c:	88 1f       	adc	r24, r24
    d75e:	bb 1f       	adc	r27, r27
    d760:	62 17       	cp	r22, r18
    d762:	73 07       	cpc	r23, r19
    d764:	84 07       	cpc	r24, r20
    d766:	ba 07       	cpc	r27, r26
    d768:	20 f0       	brcs	.+8      	; 0xd772 <__divsf3_pse+0xaa>
    d76a:	62 1b       	sub	r22, r18
    d76c:	73 0b       	sbc	r23, r19
    d76e:	84 0b       	sbc	r24, r20
    d770:	ba 0b       	sbc	r27, r26
    d772:	ee 1f       	adc	r30, r30
    d774:	88 f7       	brcc	.-30     	; 0xd758 <__divsf3_pse+0x90>
    d776:	e0 95       	com	r30
    d778:	08 95       	ret

0000d77a <__fixsfsi>:
    d77a:	04 d0       	rcall	.+8      	; 0xd784 <__fixunssfsi>
    d77c:	68 94       	set
    d77e:	b1 11       	cpse	r27, r1
    d780:	b6 c1       	rjmp	.+876    	; 0xdaee <__fp_szero>
    d782:	08 95       	ret

0000d784 <__fixunssfsi>:
    d784:	82 d1       	rcall	.+772    	; 0xda8a <__fp_splitA>
    d786:	88 f0       	brcs	.+34     	; 0xd7aa <__fixunssfsi+0x26>
    d788:	9f 57       	subi	r25, 0x7F	; 127
    d78a:	90 f0       	brcs	.+36     	; 0xd7b0 <__fixunssfsi+0x2c>
    d78c:	b9 2f       	mov	r27, r25
    d78e:	99 27       	eor	r25, r25
    d790:	b7 51       	subi	r27, 0x17	; 23
    d792:	a0 f0       	brcs	.+40     	; 0xd7bc <__fixunssfsi+0x38>
    d794:	d1 f0       	breq	.+52     	; 0xd7ca <__fixunssfsi+0x46>
    d796:	66 0f       	add	r22, r22
    d798:	77 1f       	adc	r23, r23
    d79a:	88 1f       	adc	r24, r24
    d79c:	99 1f       	adc	r25, r25
    d79e:	1a f0       	brmi	.+6      	; 0xd7a6 <__fixunssfsi+0x22>
    d7a0:	ba 95       	dec	r27
    d7a2:	c9 f7       	brne	.-14     	; 0xd796 <__fixunssfsi+0x12>
    d7a4:	12 c0       	rjmp	.+36     	; 0xd7ca <__fixunssfsi+0x46>
    d7a6:	b1 30       	cpi	r27, 0x01	; 1
    d7a8:	81 f0       	breq	.+32     	; 0xd7ca <__fixunssfsi+0x46>
    d7aa:	a0 d1       	rcall	.+832    	; 0xdaec <__fp_zero>
    d7ac:	b1 e0       	ldi	r27, 0x01	; 1
    d7ae:	08 95       	ret
    d7b0:	9d c1       	rjmp	.+826    	; 0xdaec <__fp_zero>
    d7b2:	67 2f       	mov	r22, r23
    d7b4:	78 2f       	mov	r23, r24
    d7b6:	88 27       	eor	r24, r24
    d7b8:	b8 5f       	subi	r27, 0xF8	; 248
    d7ba:	39 f0       	breq	.+14     	; 0xd7ca <__fixunssfsi+0x46>
    d7bc:	b9 3f       	cpi	r27, 0xF9	; 249
    d7be:	cc f3       	brlt	.-14     	; 0xd7b2 <__fixunssfsi+0x2e>
    d7c0:	86 95       	lsr	r24
    d7c2:	77 95       	ror	r23
    d7c4:	67 95       	ror	r22
    d7c6:	b3 95       	inc	r27
    d7c8:	d9 f7       	brne	.-10     	; 0xd7c0 <__fixunssfsi+0x3c>
    d7ca:	3e f4       	brtc	.+14     	; 0xd7da <__fixunssfsi+0x56>
    d7cc:	90 95       	com	r25
    d7ce:	80 95       	com	r24
    d7d0:	70 95       	com	r23
    d7d2:	61 95       	neg	r22
    d7d4:	7f 4f       	sbci	r23, 0xFF	; 255
    d7d6:	8f 4f       	sbci	r24, 0xFF	; 255
    d7d8:	9f 4f       	sbci	r25, 0xFF	; 255
    d7da:	08 95       	ret

0000d7dc <__floatunsisf>:
    d7dc:	e8 94       	clt
    d7de:	09 c0       	rjmp	.+18     	; 0xd7f2 <__floatsisf+0x12>

0000d7e0 <__floatsisf>:
    d7e0:	97 fb       	bst	r25, 7
    d7e2:	3e f4       	brtc	.+14     	; 0xd7f2 <__floatsisf+0x12>
    d7e4:	90 95       	com	r25
    d7e6:	80 95       	com	r24
    d7e8:	70 95       	com	r23
    d7ea:	61 95       	neg	r22
    d7ec:	7f 4f       	sbci	r23, 0xFF	; 255
    d7ee:	8f 4f       	sbci	r24, 0xFF	; 255
    d7f0:	9f 4f       	sbci	r25, 0xFF	; 255
    d7f2:	99 23       	and	r25, r25
    d7f4:	a9 f0       	breq	.+42     	; 0xd820 <__floatsisf+0x40>
    d7f6:	f9 2f       	mov	r31, r25
    d7f8:	96 e9       	ldi	r25, 0x96	; 150
    d7fa:	bb 27       	eor	r27, r27
    d7fc:	93 95       	inc	r25
    d7fe:	f6 95       	lsr	r31
    d800:	87 95       	ror	r24
    d802:	77 95       	ror	r23
    d804:	67 95       	ror	r22
    d806:	b7 95       	ror	r27
    d808:	f1 11       	cpse	r31, r1
    d80a:	f8 cf       	rjmp	.-16     	; 0xd7fc <__floatsisf+0x1c>
    d80c:	fa f4       	brpl	.+62     	; 0xd84c <__floatsisf+0x6c>
    d80e:	bb 0f       	add	r27, r27
    d810:	11 f4       	brne	.+4      	; 0xd816 <__floatsisf+0x36>
    d812:	60 ff       	sbrs	r22, 0
    d814:	1b c0       	rjmp	.+54     	; 0xd84c <__floatsisf+0x6c>
    d816:	6f 5f       	subi	r22, 0xFF	; 255
    d818:	7f 4f       	sbci	r23, 0xFF	; 255
    d81a:	8f 4f       	sbci	r24, 0xFF	; 255
    d81c:	9f 4f       	sbci	r25, 0xFF	; 255
    d81e:	16 c0       	rjmp	.+44     	; 0xd84c <__floatsisf+0x6c>
    d820:	88 23       	and	r24, r24
    d822:	11 f0       	breq	.+4      	; 0xd828 <__floatsisf+0x48>
    d824:	96 e9       	ldi	r25, 0x96	; 150
    d826:	11 c0       	rjmp	.+34     	; 0xd84a <__floatsisf+0x6a>
    d828:	77 23       	and	r23, r23
    d82a:	21 f0       	breq	.+8      	; 0xd834 <__floatsisf+0x54>
    d82c:	9e e8       	ldi	r25, 0x8E	; 142
    d82e:	87 2f       	mov	r24, r23
    d830:	76 2f       	mov	r23, r22
    d832:	05 c0       	rjmp	.+10     	; 0xd83e <__floatsisf+0x5e>
    d834:	66 23       	and	r22, r22
    d836:	71 f0       	breq	.+28     	; 0xd854 <__floatsisf+0x74>
    d838:	96 e8       	ldi	r25, 0x86	; 134
    d83a:	86 2f       	mov	r24, r22
    d83c:	70 e0       	ldi	r23, 0x00	; 0
    d83e:	60 e0       	ldi	r22, 0x00	; 0
    d840:	2a f0       	brmi	.+10     	; 0xd84c <__floatsisf+0x6c>
    d842:	9a 95       	dec	r25
    d844:	66 0f       	add	r22, r22
    d846:	77 1f       	adc	r23, r23
    d848:	88 1f       	adc	r24, r24
    d84a:	da f7       	brpl	.-10     	; 0xd842 <__floatsisf+0x62>
    d84c:	88 0f       	add	r24, r24
    d84e:	96 95       	lsr	r25
    d850:	87 95       	ror	r24
    d852:	97 f9       	bld	r25, 7
    d854:	08 95       	ret

0000d856 <floor>:
    d856:	33 d1       	rcall	.+614    	; 0xdabe <__fp_trunc>
    d858:	80 f0       	brcs	.+32     	; 0xd87a <floor+0x24>
    d85a:	9f 37       	cpi	r25, 0x7F	; 127
    d85c:	40 f4       	brcc	.+16     	; 0xd86e <floor+0x18>
    d85e:	91 11       	cpse	r25, r1
    d860:	0e f0       	brts	.+2      	; 0xd864 <floor+0xe>
    d862:	45 c1       	rjmp	.+650    	; 0xdaee <__fp_szero>
    d864:	60 e0       	ldi	r22, 0x00	; 0
    d866:	70 e0       	ldi	r23, 0x00	; 0
    d868:	80 e8       	ldi	r24, 0x80	; 128
    d86a:	9f eb       	ldi	r25, 0xBF	; 191
    d86c:	08 95       	ret
    d86e:	26 f4       	brtc	.+8      	; 0xd878 <floor+0x22>
    d870:	1b 16       	cp	r1, r27
    d872:	61 1d       	adc	r22, r1
    d874:	71 1d       	adc	r23, r1
    d876:	81 1d       	adc	r24, r1
    d878:	46 c0       	rjmp	.+140    	; 0xd906 <__fp_mintl>
    d87a:	60 c0       	rjmp	.+192    	; 0xd93c <__fp_mpack>

0000d87c <__fp_arccos>:
    d87c:	df 93       	push	r29
    d87e:	cf 93       	push	r28
    d880:	1f 93       	push	r17
    d882:	0f 93       	push	r16
    d884:	8b 01       	movw	r16, r22
    d886:	ec 01       	movw	r28, r24
    d888:	e5 e2       	ldi	r30, 0x25	; 37
    d88a:	f1 e0       	ldi	r31, 0x01	; 1
    d88c:	68 d0       	rcall	.+208    	; 0xd95e <__fp_powser>
    d88e:	d3 d0       	rcall	.+422    	; 0xda36 <__fp_round>
    d890:	98 01       	movw	r18, r16
    d892:	ae 01       	movw	r20, r28
    d894:	8b 01       	movw	r16, r22
    d896:	ec 01       	movw	r28, r24
    d898:	60 e0       	ldi	r22, 0x00	; 0
    d89a:	70 e0       	ldi	r23, 0x00	; 0
    d89c:	80 e8       	ldi	r24, 0x80	; 128
    d89e:	9f e3       	ldi	r25, 0x3F	; 63
    d8a0:	1f de       	rcall	.-962    	; 0xd4e0 <__subsf3>
    d8a2:	3a d2       	rcall	.+1140   	; 0xdd18 <sqrt>
    d8a4:	98 01       	movw	r18, r16
    d8a6:	ae 01       	movw	r20, r28
    d8a8:	0f 91       	pop	r16
    d8aa:	1f 91       	pop	r17
    d8ac:	cf 91       	pop	r28
    d8ae:	df 91       	pop	r29
    d8b0:	86 c1       	rjmp	.+780    	; 0xdbbe <__mulsf3x>

0000d8b2 <__fp_cmp>:
    d8b2:	99 0f       	add	r25, r25
    d8b4:	00 08       	sbc	r0, r0
    d8b6:	55 0f       	add	r21, r21
    d8b8:	aa 0b       	sbc	r26, r26
    d8ba:	e0 e8       	ldi	r30, 0x80	; 128
    d8bc:	fe ef       	ldi	r31, 0xFE	; 254
    d8be:	16 16       	cp	r1, r22
    d8c0:	17 06       	cpc	r1, r23
    d8c2:	e8 07       	cpc	r30, r24
    d8c4:	f9 07       	cpc	r31, r25
    d8c6:	c0 f0       	brcs	.+48     	; 0xd8f8 <__fp_cmp+0x46>
    d8c8:	12 16       	cp	r1, r18
    d8ca:	13 06       	cpc	r1, r19
    d8cc:	e4 07       	cpc	r30, r20
    d8ce:	f5 07       	cpc	r31, r21
    d8d0:	98 f0       	brcs	.+38     	; 0xd8f8 <__fp_cmp+0x46>
    d8d2:	62 1b       	sub	r22, r18
    d8d4:	73 0b       	sbc	r23, r19
    d8d6:	84 0b       	sbc	r24, r20
    d8d8:	95 0b       	sbc	r25, r21
    d8da:	39 f4       	brne	.+14     	; 0xd8ea <__fp_cmp+0x38>
    d8dc:	0a 26       	eor	r0, r26
    d8de:	61 f0       	breq	.+24     	; 0xd8f8 <__fp_cmp+0x46>
    d8e0:	23 2b       	or	r18, r19
    d8e2:	24 2b       	or	r18, r20
    d8e4:	25 2b       	or	r18, r21
    d8e6:	21 f4       	brne	.+8      	; 0xd8f0 <__fp_cmp+0x3e>
    d8e8:	08 95       	ret
    d8ea:	0a 26       	eor	r0, r26
    d8ec:	09 f4       	brne	.+2      	; 0xd8f0 <__fp_cmp+0x3e>
    d8ee:	a1 40       	sbci	r26, 0x01	; 1
    d8f0:	a6 95       	lsr	r26
    d8f2:	8f ef       	ldi	r24, 0xFF	; 255
    d8f4:	81 1d       	adc	r24, r1
    d8f6:	81 1d       	adc	r24, r1
    d8f8:	08 95       	ret

0000d8fa <__fp_inf>:
    d8fa:	97 f9       	bld	r25, 7
    d8fc:	9f 67       	ori	r25, 0x7F	; 127
    d8fe:	80 e8       	ldi	r24, 0x80	; 128
    d900:	70 e0       	ldi	r23, 0x00	; 0
    d902:	60 e0       	ldi	r22, 0x00	; 0
    d904:	08 95       	ret

0000d906 <__fp_mintl>:
    d906:	88 23       	and	r24, r24
    d908:	71 f4       	brne	.+28     	; 0xd926 <__fp_mintl+0x20>
    d90a:	77 23       	and	r23, r23
    d90c:	21 f0       	breq	.+8      	; 0xd916 <__fp_mintl+0x10>
    d90e:	98 50       	subi	r25, 0x08	; 8
    d910:	87 2b       	or	r24, r23
    d912:	76 2f       	mov	r23, r22
    d914:	07 c0       	rjmp	.+14     	; 0xd924 <__fp_mintl+0x1e>
    d916:	66 23       	and	r22, r22
    d918:	11 f4       	brne	.+4      	; 0xd91e <__fp_mintl+0x18>
    d91a:	99 27       	eor	r25, r25
    d91c:	0d c0       	rjmp	.+26     	; 0xd938 <__fp_mintl+0x32>
    d91e:	90 51       	subi	r25, 0x10	; 16
    d920:	86 2b       	or	r24, r22
    d922:	70 e0       	ldi	r23, 0x00	; 0
    d924:	60 e0       	ldi	r22, 0x00	; 0
    d926:	2a f0       	brmi	.+10     	; 0xd932 <__fp_mintl+0x2c>
    d928:	9a 95       	dec	r25
    d92a:	66 0f       	add	r22, r22
    d92c:	77 1f       	adc	r23, r23
    d92e:	88 1f       	adc	r24, r24
    d930:	da f7       	brpl	.-10     	; 0xd928 <__fp_mintl+0x22>
    d932:	88 0f       	add	r24, r24
    d934:	96 95       	lsr	r25
    d936:	87 95       	ror	r24
    d938:	97 f9       	bld	r25, 7
    d93a:	08 95       	ret

0000d93c <__fp_mpack>:
    d93c:	9f 3f       	cpi	r25, 0xFF	; 255
    d93e:	31 f0       	breq	.+12     	; 0xd94c <__fp_mpack_finite+0xc>

0000d940 <__fp_mpack_finite>:
    d940:	91 50       	subi	r25, 0x01	; 1
    d942:	20 f4       	brcc	.+8      	; 0xd94c <__fp_mpack_finite+0xc>
    d944:	87 95       	ror	r24
    d946:	77 95       	ror	r23
    d948:	67 95       	ror	r22
    d94a:	b7 95       	ror	r27
    d94c:	88 0f       	add	r24, r24
    d94e:	91 1d       	adc	r25, r1
    d950:	96 95       	lsr	r25
    d952:	87 95       	ror	r24
    d954:	97 f9       	bld	r25, 7
    d956:	08 95       	ret

0000d958 <__fp_nan>:
    d958:	9f ef       	ldi	r25, 0xFF	; 255
    d95a:	80 ec       	ldi	r24, 0xC0	; 192
    d95c:	08 95       	ret

0000d95e <__fp_powser>:
    d95e:	df 93       	push	r29
    d960:	cf 93       	push	r28
    d962:	1f 93       	push	r17
    d964:	0f 93       	push	r16
    d966:	ff 92       	push	r15
    d968:	ef 92       	push	r14
    d96a:	df 92       	push	r13
    d96c:	7b 01       	movw	r14, r22
    d96e:	8c 01       	movw	r16, r24
    d970:	68 94       	set
    d972:	05 c0       	rjmp	.+10     	; 0xd97e <__fp_powser+0x20>
    d974:	da 2e       	mov	r13, r26
    d976:	ef 01       	movw	r28, r30
    d978:	22 d1       	rcall	.+580    	; 0xdbbe <__mulsf3x>
    d97a:	fe 01       	movw	r30, r28
    d97c:	e8 94       	clt
    d97e:	a5 91       	lpm	r26, Z+
    d980:	25 91       	lpm	r18, Z+
    d982:	35 91       	lpm	r19, Z+
    d984:	45 91       	lpm	r20, Z+
    d986:	55 91       	lpm	r21, Z+
    d988:	ae f3       	brts	.-22     	; 0xd974 <__fp_powser+0x16>
    d98a:	ef 01       	movw	r28, r30
    d98c:	bb dd       	rcall	.-1162   	; 0xd504 <__addsf3x>
    d98e:	fe 01       	movw	r30, r28
    d990:	97 01       	movw	r18, r14
    d992:	a8 01       	movw	r20, r16
    d994:	da 94       	dec	r13
    d996:	79 f7       	brne	.-34     	; 0xd976 <__fp_powser+0x18>
    d998:	df 90       	pop	r13
    d99a:	ef 90       	pop	r14
    d99c:	ff 90       	pop	r15
    d99e:	0f 91       	pop	r16
    d9a0:	1f 91       	pop	r17
    d9a2:	cf 91       	pop	r28
    d9a4:	df 91       	pop	r29
    d9a6:	08 95       	ret

0000d9a8 <__fp_powsodd>:
    d9a8:	9f 93       	push	r25
    d9aa:	8f 93       	push	r24
    d9ac:	7f 93       	push	r23
    d9ae:	6f 93       	push	r22
    d9b0:	ff 93       	push	r31
    d9b2:	ef 93       	push	r30
    d9b4:	9b 01       	movw	r18, r22
    d9b6:	ac 01       	movw	r20, r24
    d9b8:	f6 d0       	rcall	.+492    	; 0xdba6 <__mulsf3>
    d9ba:	ef 91       	pop	r30
    d9bc:	ff 91       	pop	r31
    d9be:	cf df       	rcall	.-98     	; 0xd95e <__fp_powser>
    d9c0:	2f 91       	pop	r18
    d9c2:	3f 91       	pop	r19
    d9c4:	4f 91       	pop	r20
    d9c6:	5f 91       	pop	r21
    d9c8:	ee c0       	rjmp	.+476    	; 0xdba6 <__mulsf3>

0000d9ca <__fp_pscA>:
    d9ca:	00 24       	eor	r0, r0
    d9cc:	0a 94       	dec	r0
    d9ce:	16 16       	cp	r1, r22
    d9d0:	17 06       	cpc	r1, r23
    d9d2:	18 06       	cpc	r1, r24
    d9d4:	09 06       	cpc	r0, r25
    d9d6:	08 95       	ret

0000d9d8 <__fp_pscB>:
    d9d8:	00 24       	eor	r0, r0
    d9da:	0a 94       	dec	r0
    d9dc:	12 16       	cp	r1, r18
    d9de:	13 06       	cpc	r1, r19
    d9e0:	14 06       	cpc	r1, r20
    d9e2:	05 06       	cpc	r0, r21
    d9e4:	08 95       	ret
    d9e6:	b8 cf       	rjmp	.-144    	; 0xd958 <__fp_nan>

0000d9e8 <__fp_rempio2>:
    d9e8:	50 d0       	rcall	.+160    	; 0xda8a <__fp_splitA>
    d9ea:	e8 f3       	brcs	.-6      	; 0xd9e6 <__fp_pscB+0xe>
    d9ec:	e8 94       	clt
    d9ee:	e0 e0       	ldi	r30, 0x00	; 0
    d9f0:	bb 27       	eor	r27, r27
    d9f2:	9f 57       	subi	r25, 0x7F	; 127
    d9f4:	f0 f0       	brcs	.+60     	; 0xda32 <__fp_rempio2+0x4a>
    d9f6:	2a ed       	ldi	r18, 0xDA	; 218
    d9f8:	3f e0       	ldi	r19, 0x0F	; 15
    d9fa:	49 ec       	ldi	r20, 0xC9	; 201
    d9fc:	06 c0       	rjmp	.+12     	; 0xda0a <__fp_rempio2+0x22>
    d9fe:	ee 0f       	add	r30, r30
    da00:	bb 0f       	add	r27, r27
    da02:	66 1f       	adc	r22, r22
    da04:	77 1f       	adc	r23, r23
    da06:	88 1f       	adc	r24, r24
    da08:	28 f0       	brcs	.+10     	; 0xda14 <__fp_rempio2+0x2c>
    da0a:	b2 3a       	cpi	r27, 0xA2	; 162
    da0c:	62 07       	cpc	r22, r18
    da0e:	73 07       	cpc	r23, r19
    da10:	84 07       	cpc	r24, r20
    da12:	28 f0       	brcs	.+10     	; 0xda1e <__fp_rempio2+0x36>
    da14:	b2 5a       	subi	r27, 0xA2	; 162
    da16:	62 0b       	sbc	r22, r18
    da18:	73 0b       	sbc	r23, r19
    da1a:	84 0b       	sbc	r24, r20
    da1c:	e3 95       	inc	r30
    da1e:	9a 95       	dec	r25
    da20:	72 f7       	brpl	.-36     	; 0xd9fe <__fp_rempio2+0x16>
    da22:	80 38       	cpi	r24, 0x80	; 128
    da24:	30 f4       	brcc	.+12     	; 0xda32 <__fp_rempio2+0x4a>
    da26:	9a 95       	dec	r25
    da28:	bb 0f       	add	r27, r27
    da2a:	66 1f       	adc	r22, r22
    da2c:	77 1f       	adc	r23, r23
    da2e:	88 1f       	adc	r24, r24
    da30:	d2 f7       	brpl	.-12     	; 0xda26 <__fp_rempio2+0x3e>
    da32:	90 48       	sbci	r25, 0x80	; 128
    da34:	85 cf       	rjmp	.-246    	; 0xd940 <__fp_mpack_finite>

0000da36 <__fp_round>:
    da36:	09 2e       	mov	r0, r25
    da38:	03 94       	inc	r0
    da3a:	00 0c       	add	r0, r0
    da3c:	11 f4       	brne	.+4      	; 0xda42 <__fp_round+0xc>
    da3e:	88 23       	and	r24, r24
    da40:	52 f0       	brmi	.+20     	; 0xda56 <__fp_round+0x20>
    da42:	bb 0f       	add	r27, r27
    da44:	40 f4       	brcc	.+16     	; 0xda56 <__fp_round+0x20>
    da46:	bf 2b       	or	r27, r31
    da48:	11 f4       	brne	.+4      	; 0xda4e <__fp_round+0x18>
    da4a:	60 ff       	sbrs	r22, 0
    da4c:	04 c0       	rjmp	.+8      	; 0xda56 <__fp_round+0x20>
    da4e:	6f 5f       	subi	r22, 0xFF	; 255
    da50:	7f 4f       	sbci	r23, 0xFF	; 255
    da52:	8f 4f       	sbci	r24, 0xFF	; 255
    da54:	9f 4f       	sbci	r25, 0xFF	; 255
    da56:	08 95       	ret

0000da58 <__fp_sinus>:
    da58:	ef 93       	push	r30
    da5a:	e0 ff       	sbrs	r30, 0
    da5c:	06 c0       	rjmp	.+12     	; 0xda6a <__fp_sinus+0x12>
    da5e:	a2 ea       	ldi	r26, 0xA2	; 162
    da60:	2a ed       	ldi	r18, 0xDA	; 218
    da62:	3f e0       	ldi	r19, 0x0F	; 15
    da64:	49 ec       	ldi	r20, 0xC9	; 201
    da66:	5f eb       	ldi	r21, 0xBF	; 191
    da68:	4d dd       	rcall	.-1382   	; 0xd504 <__addsf3x>
    da6a:	e5 df       	rcall	.-54     	; 0xda36 <__fp_round>
    da6c:	0f 90       	pop	r0
    da6e:	03 94       	inc	r0
    da70:	01 fc       	sbrc	r0, 1
    da72:	90 58       	subi	r25, 0x80	; 128
    da74:	ed e4       	ldi	r30, 0x4D	; 77
    da76:	f1 e0       	ldi	r31, 0x01	; 1
    da78:	97 cf       	rjmp	.-210    	; 0xd9a8 <__fp_powsodd>

0000da7a <__fp_split3>:
    da7a:	57 fd       	sbrc	r21, 7
    da7c:	90 58       	subi	r25, 0x80	; 128
    da7e:	44 0f       	add	r20, r20
    da80:	55 1f       	adc	r21, r21
    da82:	59 f0       	breq	.+22     	; 0xda9a <__fp_splitA+0x10>
    da84:	5f 3f       	cpi	r21, 0xFF	; 255
    da86:	71 f0       	breq	.+28     	; 0xdaa4 <__fp_splitA+0x1a>
    da88:	47 95       	ror	r20

0000da8a <__fp_splitA>:
    da8a:	88 0f       	add	r24, r24
    da8c:	97 fb       	bst	r25, 7
    da8e:	99 1f       	adc	r25, r25
    da90:	61 f0       	breq	.+24     	; 0xdaaa <__fp_splitA+0x20>
    da92:	9f 3f       	cpi	r25, 0xFF	; 255
    da94:	79 f0       	breq	.+30     	; 0xdab4 <__fp_splitA+0x2a>
    da96:	87 95       	ror	r24
    da98:	08 95       	ret
    da9a:	12 16       	cp	r1, r18
    da9c:	13 06       	cpc	r1, r19
    da9e:	14 06       	cpc	r1, r20
    daa0:	55 1f       	adc	r21, r21
    daa2:	f2 cf       	rjmp	.-28     	; 0xda88 <__fp_split3+0xe>
    daa4:	46 95       	lsr	r20
    daa6:	f1 df       	rcall	.-30     	; 0xda8a <__fp_splitA>
    daa8:	08 c0       	rjmp	.+16     	; 0xdaba <__fp_splitA+0x30>
    daaa:	16 16       	cp	r1, r22
    daac:	17 06       	cpc	r1, r23
    daae:	18 06       	cpc	r1, r24
    dab0:	99 1f       	adc	r25, r25
    dab2:	f1 cf       	rjmp	.-30     	; 0xda96 <__fp_splitA+0xc>
    dab4:	86 95       	lsr	r24
    dab6:	71 05       	cpc	r23, r1
    dab8:	61 05       	cpc	r22, r1
    daba:	08 94       	sec
    dabc:	08 95       	ret

0000dabe <__fp_trunc>:
    dabe:	e5 df       	rcall	.-54     	; 0xda8a <__fp_splitA>
    dac0:	a0 f0       	brcs	.+40     	; 0xdaea <__fp_trunc+0x2c>
    dac2:	be e7       	ldi	r27, 0x7E	; 126
    dac4:	b9 17       	cp	r27, r25
    dac6:	88 f4       	brcc	.+34     	; 0xdaea <__fp_trunc+0x2c>
    dac8:	bb 27       	eor	r27, r27
    daca:	9f 38       	cpi	r25, 0x8F	; 143
    dacc:	60 f4       	brcc	.+24     	; 0xdae6 <__fp_trunc+0x28>
    dace:	16 16       	cp	r1, r22
    dad0:	b1 1d       	adc	r27, r1
    dad2:	67 2f       	mov	r22, r23
    dad4:	78 2f       	mov	r23, r24
    dad6:	88 27       	eor	r24, r24
    dad8:	98 5f       	subi	r25, 0xF8	; 248
    dada:	f7 cf       	rjmp	.-18     	; 0xdaca <__fp_trunc+0xc>
    dadc:	86 95       	lsr	r24
    dade:	77 95       	ror	r23
    dae0:	67 95       	ror	r22
    dae2:	b1 1d       	adc	r27, r1
    dae4:	93 95       	inc	r25
    dae6:	96 39       	cpi	r25, 0x96	; 150
    dae8:	c8 f3       	brcs	.-14     	; 0xdadc <__fp_trunc+0x1e>
    daea:	08 95       	ret

0000daec <__fp_zero>:
    daec:	e8 94       	clt

0000daee <__fp_szero>:
    daee:	bb 27       	eor	r27, r27
    daf0:	66 27       	eor	r22, r22
    daf2:	77 27       	eor	r23, r23
    daf4:	cb 01       	movw	r24, r22
    daf6:	97 f9       	bld	r25, 7
    daf8:	08 95       	ret

0000dafa <__gesf2>:
    dafa:	db de       	rcall	.-586    	; 0xd8b2 <__fp_cmp>
    dafc:	08 f4       	brcc	.+2      	; 0xdb00 <__gesf2+0x6>
    dafe:	8f ef       	ldi	r24, 0xFF	; 255
    db00:	08 95       	ret

0000db02 <inverse>:
    db02:	9b 01       	movw	r18, r22
    db04:	ac 01       	movw	r20, r24
    db06:	60 e0       	ldi	r22, 0x00	; 0
    db08:	70 e0       	ldi	r23, 0x00	; 0
    db0a:	80 e8       	ldi	r24, 0x80	; 128
    db0c:	9f e3       	ldi	r25, 0x3F	; 63
    db0e:	cd cd       	rjmp	.-1126   	; 0xd6aa <__divsf3>

0000db10 <log10>:
    db10:	0a d0       	rcall	.+20     	; 0xdb26 <log>
    db12:	29 ed       	ldi	r18, 0xD9	; 217
    db14:	3b e5       	ldi	r19, 0x5B	; 91
    db16:	4e ed       	ldi	r20, 0xDE	; 222
    db18:	5e e3       	ldi	r21, 0x3E	; 62
    db1a:	45 c0       	rjmp	.+138    	; 0xdba6 <__mulsf3>
    db1c:	0e f0       	brts	.+2      	; 0xdb20 <log10+0x10>
    db1e:	0e cf       	rjmp	.-484    	; 0xd93c <__fp_mpack>
    db20:	1b cf       	rjmp	.-458    	; 0xd958 <__fp_nan>
    db22:	68 94       	set
    db24:	ea ce       	rjmp	.-556    	; 0xd8fa <__fp_inf>

0000db26 <log>:
    db26:	b1 df       	rcall	.-158    	; 0xda8a <__fp_splitA>
    db28:	c8 f3       	brcs	.-14     	; 0xdb1c <log10+0xc>
    db2a:	99 23       	and	r25, r25
    db2c:	d1 f3       	breq	.-12     	; 0xdb22 <log10+0x12>
    db2e:	c6 f3       	brts	.-16     	; 0xdb20 <log10+0x10>
    db30:	df 93       	push	r29
    db32:	cf 93       	push	r28
    db34:	1f 93       	push	r17
    db36:	0f 93       	push	r16
    db38:	ff 92       	push	r15
    db3a:	c9 2f       	mov	r28, r25
    db3c:	dd 27       	eor	r29, r29
    db3e:	88 23       	and	r24, r24
    db40:	2a f0       	brmi	.+10     	; 0xdb4c <log+0x26>
    db42:	21 97       	sbiw	r28, 0x01	; 1
    db44:	66 0f       	add	r22, r22
    db46:	77 1f       	adc	r23, r23
    db48:	88 1f       	adc	r24, r24
    db4a:	da f7       	brpl	.-10     	; 0xdb42 <log+0x1c>
    db4c:	20 e0       	ldi	r18, 0x00	; 0
    db4e:	30 e0       	ldi	r19, 0x00	; 0
    db50:	40 e8       	ldi	r20, 0x80	; 128
    db52:	5f eb       	ldi	r21, 0xBF	; 191
    db54:	9f e3       	ldi	r25, 0x3F	; 63
    db56:	88 39       	cpi	r24, 0x98	; 152
    db58:	20 f0       	brcs	.+8      	; 0xdb62 <log+0x3c>
    db5a:	80 3e       	cpi	r24, 0xE0	; 224
    db5c:	30 f0       	brcs	.+12     	; 0xdb6a <log+0x44>
    db5e:	21 96       	adiw	r28, 0x01	; 1
    db60:	8f 77       	andi	r24, 0x7F	; 127
    db62:	bf dc       	rcall	.-1666   	; 0xd4e2 <__addsf3>
    db64:	eb e6       	ldi	r30, 0x6B	; 107
    db66:	f1 e0       	ldi	r31, 0x01	; 1
    db68:	03 c0       	rjmp	.+6      	; 0xdb70 <log+0x4a>
    db6a:	bb dc       	rcall	.-1674   	; 0xd4e2 <__addsf3>
    db6c:	e8 e9       	ldi	r30, 0x98	; 152
    db6e:	f1 e0       	ldi	r31, 0x01	; 1
    db70:	f6 de       	rcall	.-532    	; 0xd95e <__fp_powser>
    db72:	8b 01       	movw	r16, r22
    db74:	be 01       	movw	r22, r28
    db76:	ec 01       	movw	r28, r24
    db78:	fb 2e       	mov	r15, r27
    db7a:	6f 57       	subi	r22, 0x7F	; 127
    db7c:	71 09       	sbc	r23, r1
    db7e:	75 95       	asr	r23
    db80:	77 1f       	adc	r23, r23
    db82:	88 0b       	sbc	r24, r24
    db84:	99 0b       	sbc	r25, r25
    db86:	2c de       	rcall	.-936    	; 0xd7e0 <__floatsisf>
    db88:	28 e1       	ldi	r18, 0x18	; 24
    db8a:	32 e7       	ldi	r19, 0x72	; 114
    db8c:	41 e3       	ldi	r20, 0x31	; 49
    db8e:	5f e3       	ldi	r21, 0x3F	; 63
    db90:	16 d0       	rcall	.+44     	; 0xdbbe <__mulsf3x>
    db92:	af 2d       	mov	r26, r15
    db94:	98 01       	movw	r18, r16
    db96:	ae 01       	movw	r20, r28
    db98:	ff 90       	pop	r15
    db9a:	0f 91       	pop	r16
    db9c:	1f 91       	pop	r17
    db9e:	cf 91       	pop	r28
    dba0:	df 91       	pop	r29
    dba2:	b0 dc       	rcall	.-1696   	; 0xd504 <__addsf3x>
    dba4:	48 cf       	rjmp	.-368    	; 0xda36 <__fp_round>

0000dba6 <__mulsf3>:
    dba6:	0b d0       	rcall	.+22     	; 0xdbbe <__mulsf3x>
    dba8:	46 cf       	rjmp	.-372    	; 0xda36 <__fp_round>
    dbaa:	0f df       	rcall	.-482    	; 0xd9ca <__fp_pscA>
    dbac:	28 f0       	brcs	.+10     	; 0xdbb8 <__mulsf3+0x12>
    dbae:	14 df       	rcall	.-472    	; 0xd9d8 <__fp_pscB>
    dbb0:	18 f0       	brcs	.+6      	; 0xdbb8 <__mulsf3+0x12>
    dbb2:	95 23       	and	r25, r21
    dbb4:	09 f0       	breq	.+2      	; 0xdbb8 <__mulsf3+0x12>
    dbb6:	a1 ce       	rjmp	.-702    	; 0xd8fa <__fp_inf>
    dbb8:	cf ce       	rjmp	.-610    	; 0xd958 <__fp_nan>
    dbba:	11 24       	eor	r1, r1
    dbbc:	98 cf       	rjmp	.-208    	; 0xdaee <__fp_szero>

0000dbbe <__mulsf3x>:
    dbbe:	5d df       	rcall	.-326    	; 0xda7a <__fp_split3>
    dbc0:	a0 f3       	brcs	.-24     	; 0xdbaa <__mulsf3+0x4>

0000dbc2 <__mulsf3_pse>:
    dbc2:	95 9f       	mul	r25, r21
    dbc4:	d1 f3       	breq	.-12     	; 0xdbba <__mulsf3+0x14>
    dbc6:	95 0f       	add	r25, r21
    dbc8:	50 e0       	ldi	r21, 0x00	; 0
    dbca:	55 1f       	adc	r21, r21
    dbcc:	62 9f       	mul	r22, r18
    dbce:	f0 01       	movw	r30, r0
    dbd0:	72 9f       	mul	r23, r18
    dbd2:	bb 27       	eor	r27, r27
    dbd4:	f0 0d       	add	r31, r0
    dbd6:	b1 1d       	adc	r27, r1
    dbd8:	63 9f       	mul	r22, r19
    dbda:	aa 27       	eor	r26, r26
    dbdc:	f0 0d       	add	r31, r0
    dbde:	b1 1d       	adc	r27, r1
    dbe0:	aa 1f       	adc	r26, r26
    dbe2:	64 9f       	mul	r22, r20
    dbe4:	66 27       	eor	r22, r22
    dbe6:	b0 0d       	add	r27, r0
    dbe8:	a1 1d       	adc	r26, r1
    dbea:	66 1f       	adc	r22, r22
    dbec:	82 9f       	mul	r24, r18
    dbee:	22 27       	eor	r18, r18
    dbf0:	b0 0d       	add	r27, r0
    dbf2:	a1 1d       	adc	r26, r1
    dbf4:	62 1f       	adc	r22, r18
    dbf6:	73 9f       	mul	r23, r19
    dbf8:	b0 0d       	add	r27, r0
    dbfa:	a1 1d       	adc	r26, r1
    dbfc:	62 1f       	adc	r22, r18
    dbfe:	83 9f       	mul	r24, r19
    dc00:	a0 0d       	add	r26, r0
    dc02:	61 1d       	adc	r22, r1
    dc04:	22 1f       	adc	r18, r18
    dc06:	74 9f       	mul	r23, r20
    dc08:	33 27       	eor	r19, r19
    dc0a:	a0 0d       	add	r26, r0
    dc0c:	61 1d       	adc	r22, r1
    dc0e:	23 1f       	adc	r18, r19
    dc10:	84 9f       	mul	r24, r20
    dc12:	60 0d       	add	r22, r0
    dc14:	21 1d       	adc	r18, r1
    dc16:	82 2f       	mov	r24, r18
    dc18:	76 2f       	mov	r23, r22
    dc1a:	6a 2f       	mov	r22, r26
    dc1c:	11 24       	eor	r1, r1
    dc1e:	9f 57       	subi	r25, 0x7F	; 127
    dc20:	50 40       	sbci	r21, 0x00	; 0
    dc22:	8a f0       	brmi	.+34     	; 0xdc46 <__mulsf3_pse+0x84>
    dc24:	e1 f0       	breq	.+56     	; 0xdc5e <__mulsf3_pse+0x9c>
    dc26:	88 23       	and	r24, r24
    dc28:	4a f0       	brmi	.+18     	; 0xdc3c <__mulsf3_pse+0x7a>
    dc2a:	ee 0f       	add	r30, r30
    dc2c:	ff 1f       	adc	r31, r31
    dc2e:	bb 1f       	adc	r27, r27
    dc30:	66 1f       	adc	r22, r22
    dc32:	77 1f       	adc	r23, r23
    dc34:	88 1f       	adc	r24, r24
    dc36:	91 50       	subi	r25, 0x01	; 1
    dc38:	50 40       	sbci	r21, 0x00	; 0
    dc3a:	a9 f7       	brne	.-22     	; 0xdc26 <__mulsf3_pse+0x64>
    dc3c:	9e 3f       	cpi	r25, 0xFE	; 254
    dc3e:	51 05       	cpc	r21, r1
    dc40:	70 f0       	brcs	.+28     	; 0xdc5e <__mulsf3_pse+0x9c>
    dc42:	5b ce       	rjmp	.-842    	; 0xd8fa <__fp_inf>
    dc44:	54 cf       	rjmp	.-344    	; 0xdaee <__fp_szero>
    dc46:	5f 3f       	cpi	r21, 0xFF	; 255
    dc48:	ec f3       	brlt	.-6      	; 0xdc44 <__mulsf3_pse+0x82>
    dc4a:	98 3e       	cpi	r25, 0xE8	; 232
    dc4c:	dc f3       	brlt	.-10     	; 0xdc44 <__mulsf3_pse+0x82>
    dc4e:	86 95       	lsr	r24
    dc50:	77 95       	ror	r23
    dc52:	67 95       	ror	r22
    dc54:	b7 95       	ror	r27
    dc56:	f7 95       	ror	r31
    dc58:	e7 95       	ror	r30
    dc5a:	9f 5f       	subi	r25, 0xFF	; 255
    dc5c:	c1 f7       	brne	.-16     	; 0xdc4e <__mulsf3_pse+0x8c>
    dc5e:	fe 2b       	or	r31, r30
    dc60:	88 0f       	add	r24, r24
    dc62:	91 1d       	adc	r25, r1
    dc64:	96 95       	lsr	r25
    dc66:	87 95       	ror	r24
    dc68:	97 f9       	bld	r25, 7
    dc6a:	08 95       	ret

0000dc6c <pow>:
    dc6c:	fa 01       	movw	r30, r20
    dc6e:	ee 0f       	add	r30, r30
    dc70:	ff 1f       	adc	r31, r31
    dc72:	30 96       	adiw	r30, 0x00	; 0
    dc74:	21 05       	cpc	r18, r1
    dc76:	31 05       	cpc	r19, r1
    dc78:	99 f1       	breq	.+102    	; 0xdce0 <pow+0x74>
    dc7a:	61 15       	cp	r22, r1
    dc7c:	71 05       	cpc	r23, r1
    dc7e:	61 f4       	brne	.+24     	; 0xdc98 <pow+0x2c>
    dc80:	80 38       	cpi	r24, 0x80	; 128
    dc82:	bf e3       	ldi	r27, 0x3F	; 63
    dc84:	9b 07       	cpc	r25, r27
    dc86:	49 f1       	breq	.+82     	; 0xdcda <pow+0x6e>
    dc88:	68 94       	set
    dc8a:	90 38       	cpi	r25, 0x80	; 128
    dc8c:	81 05       	cpc	r24, r1
    dc8e:	61 f0       	breq	.+24     	; 0xdca8 <pow+0x3c>
    dc90:	80 38       	cpi	r24, 0x80	; 128
    dc92:	bf ef       	ldi	r27, 0xFF	; 255
    dc94:	9b 07       	cpc	r25, r27
    dc96:	41 f0       	breq	.+16     	; 0xdca8 <pow+0x3c>
    dc98:	99 23       	and	r25, r25
    dc9a:	42 f5       	brpl	.+80     	; 0xdcec <pow+0x80>
    dc9c:	ff 3f       	cpi	r31, 0xFF	; 255
    dc9e:	e1 05       	cpc	r30, r1
    dca0:	31 05       	cpc	r19, r1
    dca2:	21 05       	cpc	r18, r1
    dca4:	11 f1       	breq	.+68     	; 0xdcea <pow+0x7e>
    dca6:	e8 94       	clt
    dca8:	08 94       	sec
    dcaa:	e7 95       	ror	r30
    dcac:	d9 01       	movw	r26, r18
    dcae:	aa 23       	and	r26, r26
    dcb0:	29 f4       	brne	.+10     	; 0xdcbc <pow+0x50>
    dcb2:	ab 2f       	mov	r26, r27
    dcb4:	be 2f       	mov	r27, r30
    dcb6:	f8 5f       	subi	r31, 0xF8	; 248
    dcb8:	d0 f3       	brcs	.-12     	; 0xdcae <pow+0x42>
    dcba:	10 c0       	rjmp	.+32     	; 0xdcdc <pow+0x70>
    dcbc:	ff 5f       	subi	r31, 0xFF	; 255
    dcbe:	70 f4       	brcc	.+28     	; 0xdcdc <pow+0x70>
    dcc0:	a6 95       	lsr	r26
    dcc2:	e0 f7       	brcc	.-8      	; 0xdcbc <pow+0x50>
    dcc4:	f7 39       	cpi	r31, 0x97	; 151
    dcc6:	50 f0       	brcs	.+20     	; 0xdcdc <pow+0x70>
    dcc8:	19 f0       	breq	.+6      	; 0xdcd0 <pow+0x64>
    dcca:	ff 3a       	cpi	r31, 0xAF	; 175
    dccc:	38 f4       	brcc	.+14     	; 0xdcdc <pow+0x70>
    dcce:	9f 77       	andi	r25, 0x7F	; 127
    dcd0:	9f 93       	push	r25
    dcd2:	0c d0       	rcall	.+24     	; 0xdcec <pow+0x80>
    dcd4:	0f 90       	pop	r0
    dcd6:	07 fc       	sbrc	r0, 7
    dcd8:	90 58       	subi	r25, 0x80	; 128
    dcda:	08 95       	ret
    dcdc:	3e f0       	brts	.+14     	; 0xdcec <pow+0x80>
    dcde:	3c ce       	rjmp	.-904    	; 0xd958 <__fp_nan>
    dce0:	60 e0       	ldi	r22, 0x00	; 0
    dce2:	70 e0       	ldi	r23, 0x00	; 0
    dce4:	80 e8       	ldi	r24, 0x80	; 128
    dce6:	9f e3       	ldi	r25, 0x3F	; 63
    dce8:	08 95       	ret
    dcea:	4f e7       	ldi	r20, 0x7F	; 127
    dcec:	9f 77       	andi	r25, 0x7F	; 127
    dcee:	5f 93       	push	r21
    dcf0:	4f 93       	push	r20
    dcf2:	3f 93       	push	r19
    dcf4:	2f 93       	push	r18
    dcf6:	17 df       	rcall	.-466    	; 0xdb26 <log>
    dcf8:	2f 91       	pop	r18
    dcfa:	3f 91       	pop	r19
    dcfc:	4f 91       	pop	r20
    dcfe:	5f 91       	pop	r21
    dd00:	52 df       	rcall	.-348    	; 0xdba6 <__mulsf3>
    dd02:	54 c0       	rjmp	.+168    	; 0xddac <exp>

0000dd04 <sin>:
    dd04:	9f 93       	push	r25
    dd06:	70 de       	rcall	.-800    	; 0xd9e8 <__fp_rempio2>
    dd08:	0f 90       	pop	r0
    dd0a:	07 fc       	sbrc	r0, 7
    dd0c:	ee 5f       	subi	r30, 0xFE	; 254
    dd0e:	a4 ce       	rjmp	.-696    	; 0xda58 <__fp_sinus>
    dd10:	11 f4       	brne	.+4      	; 0xdd16 <sin+0x12>
    dd12:	0e f4       	brtc	.+2      	; 0xdd16 <sin+0x12>
    dd14:	21 ce       	rjmp	.-958    	; 0xd958 <__fp_nan>
    dd16:	12 ce       	rjmp	.-988    	; 0xd93c <__fp_mpack>

0000dd18 <sqrt>:
    dd18:	b8 de       	rcall	.-656    	; 0xda8a <__fp_splitA>
    dd1a:	d0 f3       	brcs	.-12     	; 0xdd10 <sin+0xc>
    dd1c:	99 23       	and	r25, r25
    dd1e:	d9 f3       	breq	.-10     	; 0xdd16 <sin+0x12>
    dd20:	ce f3       	brts	.-14     	; 0xdd14 <sin+0x10>
    dd22:	9f 57       	subi	r25, 0x7F	; 127
    dd24:	55 0b       	sbc	r21, r21
    dd26:	87 ff       	sbrs	r24, 7
    dd28:	6d d0       	rcall	.+218    	; 0xde04 <__fp_norm2>
    dd2a:	00 24       	eor	r0, r0
    dd2c:	a0 e6       	ldi	r26, 0x60	; 96
    dd2e:	40 ea       	ldi	r20, 0xA0	; 160
    dd30:	90 01       	movw	r18, r0
    dd32:	80 58       	subi	r24, 0x80	; 128
    dd34:	56 95       	lsr	r21
    dd36:	97 95       	ror	r25
    dd38:	28 f4       	brcc	.+10     	; 0xdd44 <sqrt+0x2c>
    dd3a:	80 5c       	subi	r24, 0xC0	; 192
    dd3c:	66 0f       	add	r22, r22
    dd3e:	77 1f       	adc	r23, r23
    dd40:	88 1f       	adc	r24, r24
    dd42:	20 f0       	brcs	.+8      	; 0xdd4c <sqrt+0x34>
    dd44:	26 17       	cp	r18, r22
    dd46:	37 07       	cpc	r19, r23
    dd48:	48 07       	cpc	r20, r24
    dd4a:	30 f4       	brcc	.+12     	; 0xdd58 <sqrt+0x40>
    dd4c:	62 1b       	sub	r22, r18
    dd4e:	73 0b       	sbc	r23, r19
    dd50:	84 0b       	sbc	r24, r20
    dd52:	20 29       	or	r18, r0
    dd54:	31 29       	or	r19, r1
    dd56:	4a 2b       	or	r20, r26
    dd58:	a6 95       	lsr	r26
    dd5a:	17 94       	ror	r1
    dd5c:	07 94       	ror	r0
    dd5e:	20 25       	eor	r18, r0
    dd60:	31 25       	eor	r19, r1
    dd62:	4a 27       	eor	r20, r26
    dd64:	58 f7       	brcc	.-42     	; 0xdd3c <sqrt+0x24>
    dd66:	66 0f       	add	r22, r22
    dd68:	77 1f       	adc	r23, r23
    dd6a:	88 1f       	adc	r24, r24
    dd6c:	20 f0       	brcs	.+8      	; 0xdd76 <sqrt+0x5e>
    dd6e:	26 17       	cp	r18, r22
    dd70:	37 07       	cpc	r19, r23
    dd72:	48 07       	cpc	r20, r24
    dd74:	30 f4       	brcc	.+12     	; 0xdd82 <sqrt+0x6a>
    dd76:	62 0b       	sbc	r22, r18
    dd78:	73 0b       	sbc	r23, r19
    dd7a:	84 0b       	sbc	r24, r20
    dd7c:	20 0d       	add	r18, r0
    dd7e:	31 1d       	adc	r19, r1
    dd80:	41 1d       	adc	r20, r1
    dd82:	a0 95       	com	r26
    dd84:	81 f7       	brne	.-32     	; 0xdd66 <sqrt+0x4e>
    dd86:	b9 01       	movw	r22, r18
    dd88:	84 2f       	mov	r24, r20
    dd8a:	91 58       	subi	r25, 0x81	; 129
    dd8c:	88 0f       	add	r24, r24
    dd8e:	96 95       	lsr	r25
    dd90:	87 95       	ror	r24
    dd92:	08 95       	ret

0000dd94 <square>:
    dd94:	9b 01       	movw	r18, r22
    dd96:	ac 01       	movw	r20, r24
    dd98:	06 cf       	rjmp	.-500    	; 0xdba6 <__mulsf3>

0000dd9a <__unordsf2>:
    dd9a:	8b dd       	rcall	.-1258   	; 0xd8b2 <__fp_cmp>
    dd9c:	88 0b       	sbc	r24, r24
    dd9e:	99 0b       	sbc	r25, r25
    dda0:	08 95       	ret
    dda2:	19 f4       	brne	.+6      	; 0xddaa <__unordsf2+0x10>
    dda4:	0e f0       	brts	.+2      	; 0xdda8 <__unordsf2+0xe>
    dda6:	a9 cd       	rjmp	.-1198   	; 0xd8fa <__fp_inf>
    dda8:	a1 ce       	rjmp	.-702    	; 0xdaec <__fp_zero>
    ddaa:	d6 cd       	rjmp	.-1108   	; 0xd958 <__fp_nan>

0000ddac <exp>:
    ddac:	6e de       	rcall	.-804    	; 0xda8a <__fp_splitA>
    ddae:	c8 f3       	brcs	.-14     	; 0xdda2 <__unordsf2+0x8>
    ddb0:	96 38       	cpi	r25, 0x86	; 134
    ddb2:	c0 f7       	brcc	.-16     	; 0xdda4 <__unordsf2+0xa>
    ddb4:	07 f8       	bld	r0, 7
    ddb6:	0f 92       	push	r0
    ddb8:	e8 94       	clt
    ddba:	2b e3       	ldi	r18, 0x3B	; 59
    ddbc:	3a ea       	ldi	r19, 0xAA	; 170
    ddbe:	48 eb       	ldi	r20, 0xB8	; 184
    ddc0:	5f e7       	ldi	r21, 0x7F	; 127
    ddc2:	ff de       	rcall	.-514    	; 0xdbc2 <__mulsf3_pse>
    ddc4:	0f 92       	push	r0
    ddc6:	0f 92       	push	r0
    ddc8:	0f 92       	push	r0
    ddca:	4d b7       	in	r20, 0x3d	; 61
    ddcc:	5e b7       	in	r21, 0x3e	; 62
    ddce:	0f 92       	push	r0
    ddd0:	56 d0       	rcall	.+172    	; 0xde7e <modf>
    ddd2:	e5 ec       	ldi	r30, 0xC5	; 197
    ddd4:	f1 e0       	ldi	r31, 0x01	; 1
    ddd6:	c3 dd       	rcall	.-1146   	; 0xd95e <__fp_powser>
    ddd8:	4f 91       	pop	r20
    ddda:	5f 91       	pop	r21
    dddc:	ef 91       	pop	r30
    ddde:	ff 91       	pop	r31
    dde0:	e5 95       	asr	r30
    dde2:	ee 1f       	adc	r30, r30
    dde4:	ff 1f       	adc	r31, r31
    dde6:	49 f0       	breq	.+18     	; 0xddfa <exp+0x4e>
    dde8:	fe 57       	subi	r31, 0x7E	; 126
    ddea:	e0 68       	ori	r30, 0x80	; 128
    ddec:	44 27       	eor	r20, r20
    ddee:	ee 0f       	add	r30, r30
    ddf0:	44 1f       	adc	r20, r20
    ddf2:	fa 95       	dec	r31
    ddf4:	e1 f7       	brne	.-8      	; 0xddee <exp+0x42>
    ddf6:	41 95       	neg	r20
    ddf8:	55 0b       	sbc	r21, r21
    ddfa:	0d d0       	rcall	.+26     	; 0xde16 <ldexp>
    ddfc:	0f 90       	pop	r0
    ddfe:	07 fe       	sbrs	r0, 7
    de00:	80 ce       	rjmp	.-768    	; 0xdb02 <inverse>
    de02:	08 95       	ret

0000de04 <__fp_norm2>:
    de04:	91 50       	subi	r25, 0x01	; 1
    de06:	50 40       	sbci	r21, 0x00	; 0
    de08:	66 0f       	add	r22, r22
    de0a:	77 1f       	adc	r23, r23
    de0c:	88 1f       	adc	r24, r24
    de0e:	d2 f7       	brpl	.-12     	; 0xde04 <__fp_norm2>
    de10:	08 95       	ret
    de12:	73 cd       	rjmp	.-1306   	; 0xd8fa <__fp_inf>
    de14:	93 cd       	rjmp	.-1242   	; 0xd93c <__fp_mpack>

0000de16 <ldexp>:
    de16:	39 de       	rcall	.-910    	; 0xda8a <__fp_splitA>
    de18:	e8 f3       	brcs	.-6      	; 0xde14 <__fp_norm2+0x10>
    de1a:	99 23       	and	r25, r25
    de1c:	d9 f3       	breq	.-10     	; 0xde14 <__fp_norm2+0x10>
    de1e:	94 0f       	add	r25, r20
    de20:	51 1d       	adc	r21, r1
    de22:	bb f3       	brvs	.-18     	; 0xde12 <__fp_norm2+0xe>
    de24:	91 50       	subi	r25, 0x01	; 1
    de26:	50 40       	sbci	r21, 0x00	; 0
    de28:	94 f0       	brlt	.+36     	; 0xde4e <ldexp+0x38>
    de2a:	59 f0       	breq	.+22     	; 0xde42 <ldexp+0x2c>
    de2c:	88 23       	and	r24, r24
    de2e:	32 f0       	brmi	.+12     	; 0xde3c <ldexp+0x26>
    de30:	66 0f       	add	r22, r22
    de32:	77 1f       	adc	r23, r23
    de34:	88 1f       	adc	r24, r24
    de36:	91 50       	subi	r25, 0x01	; 1
    de38:	50 40       	sbci	r21, 0x00	; 0
    de3a:	c1 f7       	brne	.-16     	; 0xde2c <ldexp+0x16>
    de3c:	9e 3f       	cpi	r25, 0xFE	; 254
    de3e:	51 05       	cpc	r21, r1
    de40:	44 f7       	brge	.-48     	; 0xde12 <__fp_norm2+0xe>
    de42:	88 0f       	add	r24, r24
    de44:	91 1d       	adc	r25, r1
    de46:	96 95       	lsr	r25
    de48:	87 95       	ror	r24
    de4a:	97 f9       	bld	r25, 7
    de4c:	08 95       	ret
    de4e:	5f 3f       	cpi	r21, 0xFF	; 255
    de50:	ac f0       	brlt	.+42     	; 0xde7c <ldexp+0x66>
    de52:	98 3e       	cpi	r25, 0xE8	; 232
    de54:	9c f0       	brlt	.+38     	; 0xde7c <ldexp+0x66>
    de56:	bb 27       	eor	r27, r27
    de58:	86 95       	lsr	r24
    de5a:	77 95       	ror	r23
    de5c:	67 95       	ror	r22
    de5e:	b7 95       	ror	r27
    de60:	08 f4       	brcc	.+2      	; 0xde64 <ldexp+0x4e>
    de62:	b1 60       	ori	r27, 0x01	; 1
    de64:	93 95       	inc	r25
    de66:	c1 f7       	brne	.-16     	; 0xde58 <ldexp+0x42>
    de68:	bb 0f       	add	r27, r27
    de6a:	58 f7       	brcc	.-42     	; 0xde42 <ldexp+0x2c>
    de6c:	11 f4       	brne	.+4      	; 0xde72 <ldexp+0x5c>
    de6e:	60 ff       	sbrs	r22, 0
    de70:	e8 cf       	rjmp	.-48     	; 0xde42 <ldexp+0x2c>
    de72:	6f 5f       	subi	r22, 0xFF	; 255
    de74:	7f 4f       	sbci	r23, 0xFF	; 255
    de76:	8f 4f       	sbci	r24, 0xFF	; 255
    de78:	9f 4f       	sbci	r25, 0xFF	; 255
    de7a:	e3 cf       	rjmp	.-58     	; 0xde42 <ldexp+0x2c>
    de7c:	38 ce       	rjmp	.-912    	; 0xdaee <__fp_szero>

0000de7e <modf>:
    de7e:	fa 01       	movw	r30, r20
    de80:	dc 01       	movw	r26, r24
    de82:	aa 0f       	add	r26, r26
    de84:	bb 1f       	adc	r27, r27
    de86:	9b 01       	movw	r18, r22
    de88:	ac 01       	movw	r20, r24
    de8a:	bf 57       	subi	r27, 0x7F	; 127
    de8c:	28 f4       	brcc	.+10     	; 0xde98 <modf+0x1a>
    de8e:	22 27       	eor	r18, r18
    de90:	33 27       	eor	r19, r19
    de92:	44 27       	eor	r20, r20
    de94:	50 78       	andi	r21, 0x80	; 128
    de96:	1f c0       	rjmp	.+62     	; 0xded6 <modf+0x58>
    de98:	b7 51       	subi	r27, 0x17	; 23
    de9a:	88 f4       	brcc	.+34     	; 0xdebe <modf+0x40>
    de9c:	ab 2f       	mov	r26, r27
    de9e:	00 24       	eor	r0, r0
    dea0:	46 95       	lsr	r20
    dea2:	37 95       	ror	r19
    dea4:	27 95       	ror	r18
    dea6:	01 1c       	adc	r0, r1
    dea8:	a3 95       	inc	r26
    deaa:	d2 f3       	brmi	.-12     	; 0xdea0 <modf+0x22>
    deac:	00 20       	and	r0, r0
    deae:	69 f0       	breq	.+26     	; 0xdeca <modf+0x4c>
    deb0:	22 0f       	add	r18, r18
    deb2:	33 1f       	adc	r19, r19
    deb4:	44 1f       	adc	r20, r20
    deb6:	b3 95       	inc	r27
    deb8:	da f3       	brmi	.-10     	; 0xdeb0 <modf+0x32>
    deba:	0d d0       	rcall	.+26     	; 0xded6 <modf+0x58>
    debc:	11 cb       	rjmp	.-2526   	; 0xd4e0 <__subsf3>
    debe:	61 30       	cpi	r22, 0x01	; 1
    dec0:	71 05       	cpc	r23, r1
    dec2:	a0 e8       	ldi	r26, 0x80	; 128
    dec4:	8a 07       	cpc	r24, r26
    dec6:	b9 46       	sbci	r27, 0x69	; 105
    dec8:	30 f4       	brcc	.+12     	; 0xded6 <modf+0x58>
    deca:	9b 01       	movw	r18, r22
    decc:	ac 01       	movw	r20, r24
    dece:	66 27       	eor	r22, r22
    ded0:	77 27       	eor	r23, r23
    ded2:	88 27       	eor	r24, r24
    ded4:	90 78       	andi	r25, 0x80	; 128
    ded6:	30 96       	adiw	r30, 0x00	; 0
    ded8:	21 f0       	breq	.+8      	; 0xdee2 <modf+0x64>
    deda:	20 83       	st	Z, r18
    dedc:	31 83       	std	Z+1, r19	; 0x01
    dede:	42 83       	std	Z+2, r20	; 0x02
    dee0:	53 83       	std	Z+3, r21	; 0x03
    dee2:	08 95       	ret

0000dee4 <__udivmodsi4>:
    dee4:	a1 e2       	ldi	r26, 0x21	; 33
    dee6:	1a 2e       	mov	r1, r26
    dee8:	aa 1b       	sub	r26, r26
    deea:	bb 1b       	sub	r27, r27
    deec:	fd 01       	movw	r30, r26
    deee:	0d c0       	rjmp	.+26     	; 0xdf0a <__udivmodsi4_ep>

0000def0 <__udivmodsi4_loop>:
    def0:	aa 1f       	adc	r26, r26
    def2:	bb 1f       	adc	r27, r27
    def4:	ee 1f       	adc	r30, r30
    def6:	ff 1f       	adc	r31, r31
    def8:	a2 17       	cp	r26, r18
    defa:	b3 07       	cpc	r27, r19
    defc:	e4 07       	cpc	r30, r20
    defe:	f5 07       	cpc	r31, r21
    df00:	20 f0       	brcs	.+8      	; 0xdf0a <__udivmodsi4_ep>
    df02:	a2 1b       	sub	r26, r18
    df04:	b3 0b       	sbc	r27, r19
    df06:	e4 0b       	sbc	r30, r20
    df08:	f5 0b       	sbc	r31, r21

0000df0a <__udivmodsi4_ep>:
    df0a:	66 1f       	adc	r22, r22
    df0c:	77 1f       	adc	r23, r23
    df0e:	88 1f       	adc	r24, r24
    df10:	99 1f       	adc	r25, r25
    df12:	1a 94       	dec	r1
    df14:	69 f7       	brne	.-38     	; 0xdef0 <__udivmodsi4_loop>
    df16:	60 95       	com	r22
    df18:	70 95       	com	r23
    df1a:	80 95       	com	r24
    df1c:	90 95       	com	r25
    df1e:	9b 01       	movw	r18, r22
    df20:	ac 01       	movw	r20, r24
    df22:	bd 01       	movw	r22, r26
    df24:	cf 01       	movw	r24, r30
    df26:	08 95       	ret

0000df28 <__muldi3>:
    df28:	df 93       	push	r29
    df2a:	cf 93       	push	r28
    df2c:	1f 93       	push	r17
    df2e:	0f 93       	push	r16
    df30:	9a 9d       	mul	r25, r10
    df32:	f0 2d       	mov	r31, r0
    df34:	21 9f       	mul	r18, r17
    df36:	f0 0d       	add	r31, r0
    df38:	8b 9d       	mul	r24, r11
    df3a:	f0 0d       	add	r31, r0
    df3c:	8a 9d       	mul	r24, r10
    df3e:	e0 2d       	mov	r30, r0
    df40:	f1 0d       	add	r31, r1
    df42:	03 9f       	mul	r16, r19
    df44:	f0 0d       	add	r31, r0
    df46:	02 9f       	mul	r16, r18
    df48:	e0 0d       	add	r30, r0
    df4a:	f1 1d       	adc	r31, r1
    df4c:	4e 9d       	mul	r20, r14
    df4e:	e0 0d       	add	r30, r0
    df50:	f1 1d       	adc	r31, r1
    df52:	5e 9d       	mul	r21, r14
    df54:	f0 0d       	add	r31, r0
    df56:	4f 9d       	mul	r20, r15
    df58:	f0 0d       	add	r31, r0
    df5a:	7f 93       	push	r23
    df5c:	6f 93       	push	r22
    df5e:	bf 92       	push	r11
    df60:	af 92       	push	r10
    df62:	5f 93       	push	r21
    df64:	4f 93       	push	r20
    df66:	d5 01       	movw	r26, r10
    df68:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    df6c:	8b 01       	movw	r16, r22
    df6e:	ac 01       	movw	r20, r24
    df70:	d7 01       	movw	r26, r14
    df72:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    df76:	eb 01       	movw	r28, r22
    df78:	e8 0f       	add	r30, r24
    df7a:	f9 1f       	adc	r31, r25
    df7c:	d6 01       	movw	r26, r12
    df7e:	22 d0       	rcall	.+68     	; 0xdfc4 <__muldi3_6>
    df80:	2f 91       	pop	r18
    df82:	3f 91       	pop	r19
    df84:	d6 01       	movw	r26, r12
    df86:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    df8a:	c6 0f       	add	r28, r22
    df8c:	d7 1f       	adc	r29, r23
    df8e:	e8 1f       	adc	r30, r24
    df90:	f9 1f       	adc	r31, r25
    df92:	af 91       	pop	r26
    df94:	bf 91       	pop	r27
    df96:	16 d0       	rcall	.+44     	; 0xdfc4 <__muldi3_6>
    df98:	2f 91       	pop	r18
    df9a:	3f 91       	pop	r19
    df9c:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    dfa0:	c6 0f       	add	r28, r22
    dfa2:	d7 1f       	adc	r29, r23
    dfa4:	e8 1f       	adc	r30, r24
    dfa6:	f9 1f       	adc	r31, r25
    dfa8:	d6 01       	movw	r26, r12
    dfaa:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    dfae:	e6 0f       	add	r30, r22
    dfb0:	f7 1f       	adc	r31, r23
    dfb2:	98 01       	movw	r18, r16
    dfb4:	be 01       	movw	r22, r28
    dfb6:	cf 01       	movw	r24, r30
    dfb8:	11 24       	eor	r1, r1
    dfba:	0f 91       	pop	r16
    dfbc:	1f 91       	pop	r17
    dfbe:	cf 91       	pop	r28
    dfc0:	df 91       	pop	r29
    dfc2:	08 95       	ret

0000dfc4 <__muldi3_6>:
    dfc4:	0e 94 1f 70 	call	0xe03e	; 0xe03e <__umulhisi3>
    dfc8:	46 0f       	add	r20, r22
    dfca:	57 1f       	adc	r21, r23
    dfcc:	c8 1f       	adc	r28, r24
    dfce:	d9 1f       	adc	r29, r25
    dfd0:	08 f4       	brcc	.+2      	; 0xdfd4 <__muldi3_6+0x10>
    dfd2:	31 96       	adiw	r30, 0x01	; 1
    dfd4:	08 95       	ret

0000dfd6 <__tablejump_elpm__>:
    dfd6:	07 90       	elpm	r0, Z+
    dfd8:	f6 91       	elpm	r31, Z
    dfda:	e0 2d       	mov	r30, r0
    dfdc:	19 94       	eijmp

0000dfde <__ashldi3>:
    dfde:	0f 93       	push	r16
    dfe0:	0f 73       	andi	r16, 0x3F	; 63
    dfe2:	51 f0       	breq	.+20     	; 0xdff8 <__ashldi3+0x1a>
    dfe4:	22 0f       	add	r18, r18
    dfe6:	33 1f       	adc	r19, r19
    dfe8:	44 1f       	adc	r20, r20
    dfea:	55 1f       	adc	r21, r21
    dfec:	66 1f       	adc	r22, r22
    dfee:	77 1f       	adc	r23, r23
    dff0:	88 1f       	adc	r24, r24
    dff2:	99 1f       	adc	r25, r25
    dff4:	0a 95       	dec	r16
    dff6:	b1 f7       	brne	.-20     	; 0xdfe4 <__ashldi3+0x6>
    dff8:	0f 91       	pop	r16
    dffa:	08 95       	ret

0000dffc <__ashrdi3>:
    dffc:	0f 93       	push	r16
    dffe:	0f 73       	andi	r16, 0x3F	; 63
    e000:	51 f0       	breq	.+20     	; 0xe016 <__ashrdi3+0x1a>
    e002:	95 95       	asr	r25
    e004:	87 95       	ror	r24
    e006:	77 95       	ror	r23
    e008:	67 95       	ror	r22
    e00a:	57 95       	ror	r21
    e00c:	47 95       	ror	r20
    e00e:	37 95       	ror	r19
    e010:	27 95       	ror	r18
    e012:	0a 95       	dec	r16
    e014:	b1 f7       	brne	.-20     	; 0xe002 <__ashrdi3+0x6>
    e016:	0f 91       	pop	r16
    e018:	08 95       	ret

0000e01a <__adddi3>:
    e01a:	2a 0d       	add	r18, r10
    e01c:	3b 1d       	adc	r19, r11
    e01e:	4c 1d       	adc	r20, r12
    e020:	5d 1d       	adc	r21, r13
    e022:	6e 1d       	adc	r22, r14
    e024:	7f 1d       	adc	r23, r15
    e026:	80 1f       	adc	r24, r16
    e028:	91 1f       	adc	r25, r17
    e02a:	08 95       	ret

0000e02c <__subdi3>:
    e02c:	2a 19       	sub	r18, r10
    e02e:	3b 09       	sbc	r19, r11
    e030:	4c 09       	sbc	r20, r12
    e032:	5d 09       	sbc	r21, r13
    e034:	6e 09       	sbc	r22, r14
    e036:	7f 09       	sbc	r23, r15
    e038:	80 0b       	sbc	r24, r16
    e03a:	91 0b       	sbc	r25, r17
    e03c:	08 95       	ret

0000e03e <__umulhisi3>:
    e03e:	a2 9f       	mul	r26, r18
    e040:	b0 01       	movw	r22, r0
    e042:	b3 9f       	mul	r27, r19
    e044:	c0 01       	movw	r24, r0
    e046:	a3 9f       	mul	r26, r19
    e048:	01 d0       	rcall	.+2      	; 0xe04c <__umulhisi3+0xe>
    e04a:	b2 9f       	mul	r27, r18
    e04c:	70 0d       	add	r23, r0
    e04e:	81 1d       	adc	r24, r1
    e050:	11 24       	eor	r1, r1
    e052:	91 1d       	adc	r25, r1
    e054:	08 95       	ret

0000e056 <malloc>:
    e056:	0f 93       	push	r16
    e058:	1f 93       	push	r17
    e05a:	cf 93       	push	r28
    e05c:	df 93       	push	r29
    e05e:	82 30       	cpi	r24, 0x02	; 2
    e060:	91 05       	cpc	r25, r1
    e062:	10 f4       	brcc	.+4      	; 0xe068 <malloc+0x12>
    e064:	82 e0       	ldi	r24, 0x02	; 2
    e066:	90 e0       	ldi	r25, 0x00	; 0
    e068:	e0 91 7e 10 	lds	r30, 0x107E
    e06c:	f0 91 7f 10 	lds	r31, 0x107F
    e070:	20 e0       	ldi	r18, 0x00	; 0
    e072:	30 e0       	ldi	r19, 0x00	; 0
    e074:	c0 e0       	ldi	r28, 0x00	; 0
    e076:	d0 e0       	ldi	r29, 0x00	; 0
    e078:	23 c0       	rjmp	.+70     	; 0xe0c0 <malloc+0x6a>
    e07a:	40 81       	ld	r20, Z
    e07c:	51 81       	ldd	r21, Z+1	; 0x01
    e07e:	48 17       	cp	r20, r24
    e080:	59 07       	cpc	r21, r25
    e082:	a8 f0       	brcs	.+42     	; 0xe0ae <malloc+0x58>
    e084:	48 17       	cp	r20, r24
    e086:	59 07       	cpc	r21, r25
    e088:	61 f4       	brne	.+24     	; 0xe0a2 <malloc+0x4c>
    e08a:	82 81       	ldd	r24, Z+2	; 0x02
    e08c:	93 81       	ldd	r25, Z+3	; 0x03
    e08e:	20 97       	sbiw	r28, 0x00	; 0
    e090:	19 f0       	breq	.+6      	; 0xe098 <malloc+0x42>
    e092:	9b 83       	std	Y+3, r25	; 0x03
    e094:	8a 83       	std	Y+2, r24	; 0x02
    e096:	2e c0       	rjmp	.+92     	; 0xe0f4 <malloc+0x9e>
    e098:	90 93 7f 10 	sts	0x107F, r25
    e09c:	80 93 7e 10 	sts	0x107E, r24
    e0a0:	29 c0       	rjmp	.+82     	; 0xe0f4 <malloc+0x9e>
    e0a2:	21 15       	cp	r18, r1
    e0a4:	31 05       	cpc	r19, r1
    e0a6:	29 f0       	breq	.+10     	; 0xe0b2 <malloc+0x5c>
    e0a8:	42 17       	cp	r20, r18
    e0aa:	53 07       	cpc	r21, r19
    e0ac:	10 f0       	brcs	.+4      	; 0xe0b2 <malloc+0x5c>
    e0ae:	a9 01       	movw	r20, r18
    e0b0:	02 c0       	rjmp	.+4      	; 0xe0b6 <malloc+0x60>
    e0b2:	be 01       	movw	r22, r28
    e0b4:	df 01       	movw	r26, r30
    e0b6:	02 81       	ldd	r16, Z+2	; 0x02
    e0b8:	13 81       	ldd	r17, Z+3	; 0x03
    e0ba:	ef 01       	movw	r28, r30
    e0bc:	9a 01       	movw	r18, r20
    e0be:	f8 01       	movw	r30, r16
    e0c0:	30 97       	sbiw	r30, 0x00	; 0
    e0c2:	d9 f6       	brne	.-74     	; 0xe07a <malloc+0x24>
    e0c4:	21 15       	cp	r18, r1
    e0c6:	31 05       	cpc	r19, r1
    e0c8:	09 f1       	breq	.+66     	; 0xe10c <malloc+0xb6>
    e0ca:	28 1b       	sub	r18, r24
    e0cc:	39 0b       	sbc	r19, r25
    e0ce:	24 30       	cpi	r18, 0x04	; 4
    e0d0:	31 05       	cpc	r19, r1
    e0d2:	90 f4       	brcc	.+36     	; 0xe0f8 <malloc+0xa2>
    e0d4:	12 96       	adiw	r26, 0x02	; 2
    e0d6:	8d 91       	ld	r24, X+
    e0d8:	9c 91       	ld	r25, X
    e0da:	13 97       	sbiw	r26, 0x03	; 3
    e0dc:	61 15       	cp	r22, r1
    e0de:	71 05       	cpc	r23, r1
    e0e0:	21 f0       	breq	.+8      	; 0xe0ea <malloc+0x94>
    e0e2:	fb 01       	movw	r30, r22
    e0e4:	93 83       	std	Z+3, r25	; 0x03
    e0e6:	82 83       	std	Z+2, r24	; 0x02
    e0e8:	04 c0       	rjmp	.+8      	; 0xe0f2 <malloc+0x9c>
    e0ea:	90 93 7f 10 	sts	0x107F, r25
    e0ee:	80 93 7e 10 	sts	0x107E, r24
    e0f2:	fd 01       	movw	r30, r26
    e0f4:	32 96       	adiw	r30, 0x02	; 2
    e0f6:	44 c0       	rjmp	.+136    	; 0xe180 <malloc+0x12a>
    e0f8:	fd 01       	movw	r30, r26
    e0fa:	e2 0f       	add	r30, r18
    e0fc:	f3 1f       	adc	r31, r19
    e0fe:	81 93       	st	Z+, r24
    e100:	91 93       	st	Z+, r25
    e102:	22 50       	subi	r18, 0x02	; 2
    e104:	31 09       	sbc	r19, r1
    e106:	2d 93       	st	X+, r18
    e108:	3c 93       	st	X, r19
    e10a:	3a c0       	rjmp	.+116    	; 0xe180 <malloc+0x12a>
    e10c:	20 91 7c 10 	lds	r18, 0x107C
    e110:	30 91 7d 10 	lds	r19, 0x107D
    e114:	23 2b       	or	r18, r19
    e116:	41 f4       	brne	.+16     	; 0xe128 <malloc+0xd2>
    e118:	20 91 02 02 	lds	r18, 0x0202
    e11c:	30 91 03 02 	lds	r19, 0x0203
    e120:	30 93 7d 10 	sts	0x107D, r19
    e124:	20 93 7c 10 	sts	0x107C, r18
    e128:	20 91 00 02 	lds	r18, 0x0200
    e12c:	30 91 01 02 	lds	r19, 0x0201
    e130:	21 15       	cp	r18, r1
    e132:	31 05       	cpc	r19, r1
    e134:	41 f4       	brne	.+16     	; 0xe146 <malloc+0xf0>
    e136:	2d b7       	in	r18, 0x3d	; 61
    e138:	3e b7       	in	r19, 0x3e	; 62
    e13a:	40 91 04 02 	lds	r20, 0x0204
    e13e:	50 91 05 02 	lds	r21, 0x0205
    e142:	24 1b       	sub	r18, r20
    e144:	35 0b       	sbc	r19, r21
    e146:	e0 91 7c 10 	lds	r30, 0x107C
    e14a:	f0 91 7d 10 	lds	r31, 0x107D
    e14e:	e2 17       	cp	r30, r18
    e150:	f3 07       	cpc	r31, r19
    e152:	a0 f4       	brcc	.+40     	; 0xe17c <malloc+0x126>
    e154:	2e 1b       	sub	r18, r30
    e156:	3f 0b       	sbc	r19, r31
    e158:	28 17       	cp	r18, r24
    e15a:	39 07       	cpc	r19, r25
    e15c:	78 f0       	brcs	.+30     	; 0xe17c <malloc+0x126>
    e15e:	ac 01       	movw	r20, r24
    e160:	4e 5f       	subi	r20, 0xFE	; 254
    e162:	5f 4f       	sbci	r21, 0xFF	; 255
    e164:	24 17       	cp	r18, r20
    e166:	35 07       	cpc	r19, r21
    e168:	48 f0       	brcs	.+18     	; 0xe17c <malloc+0x126>
    e16a:	4e 0f       	add	r20, r30
    e16c:	5f 1f       	adc	r21, r31
    e16e:	50 93 7d 10 	sts	0x107D, r21
    e172:	40 93 7c 10 	sts	0x107C, r20
    e176:	81 93       	st	Z+, r24
    e178:	91 93       	st	Z+, r25
    e17a:	02 c0       	rjmp	.+4      	; 0xe180 <malloc+0x12a>
    e17c:	e0 e0       	ldi	r30, 0x00	; 0
    e17e:	f0 e0       	ldi	r31, 0x00	; 0
    e180:	cf 01       	movw	r24, r30
    e182:	df 91       	pop	r29
    e184:	cf 91       	pop	r28
    e186:	1f 91       	pop	r17
    e188:	0f 91       	pop	r16
    e18a:	08 95       	ret

0000e18c <free>:
    e18c:	ef 92       	push	r14
    e18e:	ff 92       	push	r15
    e190:	0f 93       	push	r16
    e192:	1f 93       	push	r17
    e194:	cf 93       	push	r28
    e196:	df 93       	push	r29
    e198:	00 97       	sbiw	r24, 0x00	; 0
    e19a:	09 f4       	brne	.+2      	; 0xe19e <free+0x12>
    e19c:	8f c0       	rjmp	.+286    	; 0xe2bc <free+0x130>
    e19e:	dc 01       	movw	r26, r24
    e1a0:	12 97       	sbiw	r26, 0x02	; 2
    e1a2:	13 96       	adiw	r26, 0x03	; 3
    e1a4:	1c 92       	st	X, r1
    e1a6:	1e 92       	st	-X, r1
    e1a8:	12 97       	sbiw	r26, 0x02	; 2
    e1aa:	e0 90 7e 10 	lds	r14, 0x107E
    e1ae:	f0 90 7f 10 	lds	r15, 0x107F
    e1b2:	e1 14       	cp	r14, r1
    e1b4:	f1 04       	cpc	r15, r1
    e1b6:	89 f4       	brne	.+34     	; 0xe1da <free+0x4e>
    e1b8:	2d 91       	ld	r18, X+
    e1ba:	3c 91       	ld	r19, X
    e1bc:	11 97       	sbiw	r26, 0x01	; 1
    e1be:	28 0f       	add	r18, r24
    e1c0:	39 1f       	adc	r19, r25
    e1c2:	80 91 7c 10 	lds	r24, 0x107C
    e1c6:	90 91 7d 10 	lds	r25, 0x107D
    e1ca:	82 17       	cp	r24, r18
    e1cc:	93 07       	cpc	r25, r19
    e1ce:	89 f5       	brne	.+98     	; 0xe232 <free+0xa6>
    e1d0:	b0 93 7d 10 	sts	0x107D, r27
    e1d4:	a0 93 7c 10 	sts	0x107C, r26
    e1d8:	71 c0       	rjmp	.+226    	; 0xe2bc <free+0x130>
    e1da:	e7 01       	movw	r28, r14
    e1dc:	20 e0       	ldi	r18, 0x00	; 0
    e1de:	30 e0       	ldi	r19, 0x00	; 0
    e1e0:	01 c0       	rjmp	.+2      	; 0xe1e4 <free+0x58>
    e1e2:	ea 01       	movw	r28, r20
    e1e4:	ca 17       	cp	r28, r26
    e1e6:	db 07       	cpc	r29, r27
    e1e8:	38 f4       	brcc	.+14     	; 0xe1f8 <free+0x6c>
    e1ea:	4a 81       	ldd	r20, Y+2	; 0x02
    e1ec:	5b 81       	ldd	r21, Y+3	; 0x03
    e1ee:	9e 01       	movw	r18, r28
    e1f0:	41 15       	cp	r20, r1
    e1f2:	51 05       	cpc	r21, r1
    e1f4:	b1 f7       	brne	.-20     	; 0xe1e2 <free+0x56>
    e1f6:	22 c0       	rjmp	.+68     	; 0xe23c <free+0xb0>
    e1f8:	bc 01       	movw	r22, r24
    e1fa:	62 50       	subi	r22, 0x02	; 2
    e1fc:	71 09       	sbc	r23, r1
    e1fe:	fb 01       	movw	r30, r22
    e200:	d3 83       	std	Z+3, r29	; 0x03
    e202:	c2 83       	std	Z+2, r28	; 0x02
    e204:	00 81       	ld	r16, Z
    e206:	11 81       	ldd	r17, Z+1	; 0x01
    e208:	ac 01       	movw	r20, r24
    e20a:	40 0f       	add	r20, r16
    e20c:	51 1f       	adc	r21, r17
    e20e:	4c 17       	cp	r20, r28
    e210:	5d 07       	cpc	r21, r29
    e212:	61 f4       	brne	.+24     	; 0xe22c <free+0xa0>
    e214:	48 81       	ld	r20, Y
    e216:	59 81       	ldd	r21, Y+1	; 0x01
    e218:	40 0f       	add	r20, r16
    e21a:	51 1f       	adc	r21, r17
    e21c:	4e 5f       	subi	r20, 0xFE	; 254
    e21e:	5f 4f       	sbci	r21, 0xFF	; 255
    e220:	51 83       	std	Z+1, r21	; 0x01
    e222:	40 83       	st	Z, r20
    e224:	4a 81       	ldd	r20, Y+2	; 0x02
    e226:	5b 81       	ldd	r21, Y+3	; 0x03
    e228:	53 83       	std	Z+3, r21	; 0x03
    e22a:	42 83       	std	Z+2, r20	; 0x02
    e22c:	21 15       	cp	r18, r1
    e22e:	31 05       	cpc	r19, r1
    e230:	29 f4       	brne	.+10     	; 0xe23c <free+0xb0>
    e232:	b0 93 7f 10 	sts	0x107F, r27
    e236:	a0 93 7e 10 	sts	0x107E, r26
    e23a:	40 c0       	rjmp	.+128    	; 0xe2bc <free+0x130>
    e23c:	f9 01       	movw	r30, r18
    e23e:	b3 83       	std	Z+3, r27	; 0x03
    e240:	a2 83       	std	Z+2, r26	; 0x02
    e242:	e9 01       	movw	r28, r18
    e244:	69 91       	ld	r22, Y+
    e246:	79 91       	ld	r23, Y+
    e248:	c6 0f       	add	r28, r22
    e24a:	d7 1f       	adc	r29, r23
    e24c:	ac 17       	cp	r26, r28
    e24e:	bd 07       	cpc	r27, r29
    e250:	79 f4       	brne	.+30     	; 0xe270 <free+0xe4>
    e252:	dc 01       	movw	r26, r24
    e254:	5e 91       	ld	r21, -X
    e256:	4e 91       	ld	r20, -X
    e258:	46 0f       	add	r20, r22
    e25a:	57 1f       	adc	r21, r23
    e25c:	4e 5f       	subi	r20, 0xFE	; 254
    e25e:	5f 4f       	sbci	r21, 0xFF	; 255
    e260:	51 83       	std	Z+1, r21	; 0x01
    e262:	40 83       	st	Z, r20
    e264:	12 96       	adiw	r26, 0x02	; 2
    e266:	8d 91       	ld	r24, X+
    e268:	9c 91       	ld	r25, X
    e26a:	13 97       	sbiw	r26, 0x03	; 3
    e26c:	93 83       	std	Z+3, r25	; 0x03
    e26e:	82 83       	std	Z+2, r24	; 0x02
    e270:	a0 e0       	ldi	r26, 0x00	; 0
    e272:	b0 e0       	ldi	r27, 0x00	; 0
    e274:	02 c0       	rjmp	.+4      	; 0xe27a <free+0xee>
    e276:	d7 01       	movw	r26, r14
    e278:	7c 01       	movw	r14, r24
    e27a:	f7 01       	movw	r30, r14
    e27c:	82 81       	ldd	r24, Z+2	; 0x02
    e27e:	93 81       	ldd	r25, Z+3	; 0x03
    e280:	00 97       	sbiw	r24, 0x00	; 0
    e282:	c9 f7       	brne	.-14     	; 0xe276 <free+0xea>
    e284:	c7 01       	movw	r24, r14
    e286:	02 96       	adiw	r24, 0x02	; 2
    e288:	20 81       	ld	r18, Z
    e28a:	31 81       	ldd	r19, Z+1	; 0x01
    e28c:	82 0f       	add	r24, r18
    e28e:	93 1f       	adc	r25, r19
    e290:	20 91 7c 10 	lds	r18, 0x107C
    e294:	30 91 7d 10 	lds	r19, 0x107D
    e298:	28 17       	cp	r18, r24
    e29a:	39 07       	cpc	r19, r25
    e29c:	79 f4       	brne	.+30     	; 0xe2bc <free+0x130>
    e29e:	10 97       	sbiw	r26, 0x00	; 0
    e2a0:	29 f4       	brne	.+10     	; 0xe2ac <free+0x120>
    e2a2:	10 92 7f 10 	sts	0x107F, r1
    e2a6:	10 92 7e 10 	sts	0x107E, r1
    e2aa:	04 c0       	rjmp	.+8      	; 0xe2b4 <free+0x128>
    e2ac:	13 96       	adiw	r26, 0x03	; 3
    e2ae:	1c 92       	st	X, r1
    e2b0:	1e 92       	st	-X, r1
    e2b2:	12 97       	sbiw	r26, 0x02	; 2
    e2b4:	f0 92 7d 10 	sts	0x107D, r15
    e2b8:	e0 92 7c 10 	sts	0x107C, r14
    e2bc:	df 91       	pop	r29
    e2be:	cf 91       	pop	r28
    e2c0:	1f 91       	pop	r17
    e2c2:	0f 91       	pop	r16
    e2c4:	ff 90       	pop	r15
    e2c6:	ef 90       	pop	r14
    e2c8:	08 95       	ret

0000e2ca <memcpy>:
    e2ca:	fb 01       	movw	r30, r22
    e2cc:	dc 01       	movw	r26, r24
    e2ce:	02 c0       	rjmp	.+4      	; 0xe2d4 <memcpy+0xa>
    e2d0:	01 90       	ld	r0, Z+
    e2d2:	0d 92       	st	X+, r0
    e2d4:	41 50       	subi	r20, 0x01	; 1
    e2d6:	50 40       	sbci	r21, 0x00	; 0
    e2d8:	d8 f7       	brcc	.-10     	; 0xe2d0 <memcpy+0x6>
    e2da:	08 95       	ret

0000e2dc <memset>:
    e2dc:	dc 01       	movw	r26, r24
    e2de:	01 c0       	rjmp	.+2      	; 0xe2e2 <memset+0x6>
    e2e0:	6d 93       	st	X+, r22
    e2e2:	41 50       	subi	r20, 0x01	; 1
    e2e4:	50 40       	sbci	r21, 0x00	; 0
    e2e6:	e0 f7       	brcc	.-8      	; 0xe2e0 <memset+0x4>
    e2e8:	08 95       	ret

0000e2ea <__do_global_dtors>:
    e2ea:	13 e0       	ldi	r17, 0x03	; 3
    e2ec:	c8 e3       	ldi	r28, 0x38	; 56
    e2ee:	d3 e0       	ldi	r29, 0x03	; 3
    e2f0:	00 e0       	ldi	r16, 0x00	; 0
    e2f2:	06 c0       	rjmp	.+12     	; 0xe300 <__do_global_dtors+0x16>
    e2f4:	22 97       	sbiw	r28, 0x02	; 2
    e2f6:	01 09       	sbc	r16, r1
    e2f8:	fe 01       	movw	r30, r28
    e2fa:	0b bf       	out	0x3b, r16	; 59
    e2fc:	0e 94 eb 6f 	call	0xdfd6	; 0xdfd6 <__tablejump_elpm__>
    e300:	ca 33       	cpi	r28, 0x3A	; 58
    e302:	d1 07       	cpc	r29, r17
    e304:	80 e0       	ldi	r24, 0x00	; 0
    e306:	08 07       	cpc	r16, r24
    e308:	a9 f7       	brne	.-22     	; 0xe2f4 <__do_global_dtors+0xa>
    e30a:	f8 94       	cli

0000e30c <__stop_program>:
    e30c:	ff cf       	rjmp	.-2      	; 0xe30c <__stop_program>
