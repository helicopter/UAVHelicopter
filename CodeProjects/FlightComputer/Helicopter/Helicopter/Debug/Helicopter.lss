
Helicopter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000018e  00800200  0000dbb8  0000dc4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000dbb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cf2  0080038e  0080038e  0000ddda  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000ddda  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000b50  00000000  00000000  0000de0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00044e22  00000000  00000000  0000e95a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000082da  00000000  00000000  0005377c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005e5a  00000000  00000000  0005ba56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00002ce8  00000000  00000000  000618b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000bd74  00000000  00000000  00064598  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0001d5c2  00000000  00000000  0007030c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000d98  00000000  00000000  0008d8ce  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__dtors_end>
       4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
       8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
       c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      10:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      14:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      18:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      1c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      20:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      24:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      28:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      2c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      30:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      34:	0c 94 5c 40 	jmp	0x80b8	; 0x80b8 <__vector_13>
      38:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      3c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      40:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      44:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      48:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      4c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      50:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      54:	0c 94 a3 66 	jmp	0xcd46	; 0xcd46 <__vector_21>
      58:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      5c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      60:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      64:	0c 94 91 0d 	jmp	0x1b22	; 0x1b22 <__vector_25>
      68:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <__vector_26>
      6c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      70:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      74:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      78:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      7c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      80:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      84:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      88:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      8c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      90:	0c 94 39 49 	jmp	0x9272	; 0x9272 <__vector_36>
      94:	0c 94 fd 0d 	jmp	0x1bfa	; 0x1bfa <__vector_37>
      98:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      9c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      ac:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b8:	0c 94 66 1d 	jmp	0x3acc	; 0x3acc <__vector_46>
      bc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      cc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      dc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e4:	03 6e       	ori	r16, 0xE3	; 227
      e6:	db 36       	cpi	r29, 0x6B	; 107
      e8:	3d 9a       	sbi	0x07, 5	; 7
      ea:	99 99       	sbic	0x13, 1	; 19
      ec:	99 3d       	cpi	r25, 0xD9	; 217
      ee:	ab aa       	std	Y+51, r10	; 0x33
      f0:	aa 2a       	or	r10, r26
      f2:	3e 00       	.word	0x003e	; ????
      f4:	00 00       	nop
      f6:	80 3f       	cpi	r24, 0xF0	; 240
      f8:	08 4a       	sbci	r16, 0xA8	; 168
      fa:	d7 3b       	cpi	r29, 0xB7	; 183
      fc:	3b ce       	rjmp	.-906    	; 0xfffffd74 <__eeprom_end+0xff7efd74>
      fe:	01 6e       	ori	r16, 0xE1	; 225
     100:	84 bc       	out	0x24, r8	; 36
     102:	bf fd       	.word	0xfdbf	; ????
     104:	c1 2f       	mov	r28, r17
     106:	3d 6c       	ori	r19, 0xCD	; 205
     108:	74 31       	cpi	r23, 0x14	; 20
     10a:	9a bd       	out	0x2a, r25	; 42
     10c:	56 83       	std	Z+6, r21	; 0x06
     10e:	3d da       	rcall	.-2950   	; 0xfffff58a <__eeprom_end+0xff7ef58a>
     110:	3d 00       	.word	0x003d	; ????
     112:	c7 7f       	andi	r28, 0xF7	; 247
     114:	11 be       	out	0x31, r1	; 49
     116:	d9 e4       	ldi	r29, 0x49	; 73
     118:	bb 4c       	sbci	r27, 0xCB	; 203
     11a:	3e 91       	ld	r19, -X
     11c:	6b aa       	std	Y+51, r6	; 0x33
     11e:	aa be       	out	0x3a, r10	; 58
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	3f 07       	cpc	r19, r31
     126:	2c 7a       	andi	r18, 0xAC	; 172
     128:	a5 ba       	out	0x15, r10	; 21
     12a:	6c c5       	rjmp	.+2776   	; 0xc04 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf+0xa2>
     12c:	90 da       	rcall	.-2784   	; 0xfffff64e <__eeprom_end+0xff7ef64e>
     12e:	3b 93       	.word	0x933b	; ????
     130:	65 fc       	sbrc	r6, 5
     132:	8b bc       	out	0x2b, r8	; 43
     134:	53 f8       	bld	r5, 3
     136:	10 fd       	sbrc	r17, 0
     138:	3c 56       	subi	r19, 0x6C	; 108
     13a:	92 83       	std	Z+2, r25	; 0x02
     13c:	4d bd       	out	0x2d, r20	; 45
     13e:	87 9d       	mul	r24, r7
     140:	3a b6       	in	r3, 0x3a	; 58
     142:	3d cb       	rjmp	.-2438   	; 0xfffff7be <__eeprom_end+0xff7ef7be>
     144:	c9 bf       	out	0x39, r28	; 57
     146:	5b be       	out	0x3b, r5	; 59
     148:	73 da       	rcall	.-2842   	; 0xfffff630 <__eeprom_end+0xff7ef630>
     14a:	0f c9       	rjmp	.-3554   	; 0xfffff36a <__eeprom_end+0xff7ef36a>
     14c:	3f 05       	cpc	r19, r15
     14e:	a8 4c       	sbci	r26, 0xC8	; 200
     150:	cd b2       	in	r12, 0x1d	; 29
     152:	d4 4e       	sbci	r29, 0xE4	; 228
     154:	b9 38       	cpi	r27, 0x89	; 137
     156:	36 a9       	ldd	r19, Z+54	; 0x36
     158:	02 0c       	add	r0, r2
     15a:	50 b9       	out	0x00, r21	; 0
     15c:	91 86       	std	Z+9, r9	; 0x09
     15e:	88 08       	sbc	r8, r8
     160:	3c a6       	std	Y+44, r3	; 0x2c
     162:	aa aa       	std	Y+50, r10	; 0x32
     164:	2a be       	out	0x3a, r2	; 58
     166:	00 00       	nop
     168:	00 80       	ld	r0, Z
     16a:	3f 08       	sbc	r3, r15
     16c:	00 00       	nop
     16e:	00 be       	out	0x30, r0	; 48
     170:	92 24       	eor	r9, r2
     172:	49 12       	cpse	r4, r25
     174:	3e ab       	std	Y+54, r19	; 0x36
     176:	aa aa       	std	Y+50, r10	; 0x32
     178:	2a be       	out	0x3a, r2	; 58
     17a:	cd cc       	rjmp	.-1638   	; 0xfffffb16 <__eeprom_end+0xff7efb16>
     17c:	cc 4c       	sbci	r28, 0xCC	; 204
     17e:	3e 00       	.word	0x003e	; ????
     180:	00 00       	nop
     182:	80 be       	out	0x30, r8	; 48
     184:	ab aa       	std	Y+51, r10	; 0x33
     186:	aa aa       	std	Y+50, r10	; 0x32
     188:	3e 00       	.word	0x003e	; ????
     18a:	00 00       	nop
     18c:	00 bf       	out	0x30, r16	; 48
     18e:	00 00       	nop
     190:	00 80       	ld	r0, Z
     192:	3f 00       	.word	0x003f	; ????
     194:	00 00       	nop
     196:	00 00       	nop
     198:	08 41       	sbci	r16, 0x18	; 24
     19a:	78 d3       	rcall	.+1776   	; 0x88c <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x226>
     19c:	bb 43       	sbci	r27, 0x3B	; 59
     19e:	87 d1       	rcall	.+782    	; 0x4ae <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x2>
     1a0:	13 3d       	cpi	r17, 0xD3	; 211
     1a2:	19 0e       	add	r1, r25
     1a4:	3c c3       	rjmp	.+1656   	; 0x81e <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x1b8>
     1a6:	bd 42       	sbci	r27, 0x2D	; 45
     1a8:	82 ad       	ldd	r24, Z+58	; 0x3a
     1aa:	2b 3e       	cpi	r18, 0xEB	; 235
     1ac:	68 ec       	ldi	r22, 0xC8	; 200
     1ae:	82 76       	andi	r24, 0x62	; 98
     1b0:	be d9       	rcall	.-3204   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     1b2:	8f e1       	ldi	r24, 0x1F	; 31
     1b4:	a9 3e       	cpi	r26, 0xE9	; 233
     1b6:	4c 80       	ldd	r4, Y+4	; 0x04
     1b8:	ef ff       	.word	0xffef	; ????
     1ba:	be 01       	movw	r22, r28
     1bc:	c4 ff       	sbrs	r28, 4
     1be:	7f 3f       	cpi	r23, 0xFF	; 255
     1c0:	00 00       	nop
     1c2:	00 00       	nop
     1c4:	00 07       	cpc	r16, r16
     1c6:	63 42       	sbci	r22, 0x23	; 35
     1c8:	36 b7       	in	r19, 0x36	; 54
     1ca:	9b d8       	rcall	.-3786   	; 0xfffff302 <__eeprom_end+0xff7ef302>
     1cc:	a7 1a       	sub	r10, r23
     1ce:	39 68       	ori	r19, 0x89	; 137
     1d0:	56 18       	sub	r5, r6
     1d2:	ae ba       	out	0x1e, r10	; 30
     1d4:	ab 55       	subi	r26, 0x5B	; 91
     1d6:	8c 1d       	adc	r24, r12
     1d8:	3c b7       	in	r19, 0x3c	; 60
     1da:	cc 57       	subi	r28, 0x7C	; 124
     1dc:	63 bd       	out	0x23, r22	; 35
     1de:	6d ed       	ldi	r22, 0xDD	; 221
     1e0:	fd 75       	andi	r31, 0x5D	; 93
     1e2:	3e f6       	brtc	.-114    	; 0x172 <__SREG__+0x133>
     1e4:	17 72       	andi	r17, 0x27	; 39
     1e6:	31 bf       	out	0x31, r19	; 49
     1e8:	00 00       	nop
     1ea:	00 80       	ld	r0, Z
     1ec:	3f 00       	.word	0x003f	; ????

000001ee <__trampolines_start>:
     1ee:	0c 94 ac 57 	jmp	0xaf58	; 0xaf58 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>
     1f2:	0c 94 cc 51 	jmp	0xa398	; 0xa398 <_ZN10helicopter5tasks14NavigationTaskD1Ev>
     1f6:	0c 94 fd 25 	jmp	0x4bfa	; 0x4bfa <_ZN10helicopter8messages7MessageD0Ev>
     1fa:	0c 94 d2 51 	jmp	0xa3a4	; 0xa3a4 <_ZN10helicopter5tasks14NavigationTaskD0Ev>
     1fe:	0c 94 ca 27 	jmp	0x4f94	; 0x4f94 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>
     202:	0c 94 fc 52 	jmp	0xa5f8	; 0xa5f8 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>
     206:	0c 94 9a 0f 	jmp	0x1f34	; 0x1f34 <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>
     20a:	0c 94 42 23 	jmp	0x4684	; 0x4684 <_ZN10helicopter8messages12GainsMessage8getBytesEv>
     20e:	0c 94 5c 53 	jmp	0xa6b8	; 0xa6b8 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>
     212:	0c 94 56 53 	jmp	0xa6ac	; 0xa6ac <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>
     216:	0c 94 5b 0a 	jmp	0x14b6	; 0x14b6 <_ZN10helicopter7drivers12SerialDriver8transmitEl>
     21a:	0c 94 d0 5c 	jmp	0xb9a0	; 0xb9a0 <_ZN10helicopter5tasks4TaskD0Ev>
     21e:	0c 94 1c 58 	jmp	0xb038	; 0xb038 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>
     222:	0c 94 ac 0a 	jmp	0x1558	; 0x1558 <_ZN10helicopter7drivers12SerialDriver8transmitEx>
     226:	0c 94 aa 09 	jmp	0x1354	; 0x1354 <_ZN10helicopter7drivers12SerialDriverD1Ev>
     22a:	0c 94 0a 53 	jmp	0xa614	; 0xa614 <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>
     22e:	0c 94 d7 22 	jmp	0x45ae	; 0x45ae <_ZN10helicopter8messages14ControlMessage8getBytesEv>
     232:	0c 94 a8 0b 	jmp	0x1750	; 0x1750 <_ZN10helicopter7drivers12SerialDriverD0Ev>
     236:	0c 94 8e 56 	jmp	0xad1c	; 0xad1c <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>
     23a:	0c 94 ef 09 	jmp	0x13de	; 0x13de <_ZN10helicopter7drivers12SerialDriver8transmitEi>
     23e:	0c 94 0e 0a 	jmp	0x141c	; 0x141c <_ZN10helicopter7drivers12SerialDriver8transmitEm>
     242:	0c 94 b1 0c 	jmp	0x1962	; 0x1962 <_ZN10helicopter7drivers12SerialDriver7receiveERh>
     246:	0c 94 f3 25 	jmp	0x4be6	; 0x4be6 <_ZN10helicopter8messages7MessageD1Ev>
     24a:	0c 94 94 56 	jmp	0xad28	; 0xad28 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>
     24e:	0c 94 e9 5c 	jmp	0xb9d2	; 0xb9d2 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>
     252:	0c 94 05 23 	jmp	0x460a	; 0x460a <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>
     256:	0c 94 bc 27 	jmp	0x4f78	; 0x4f78 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>
     25a:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <_ZN10helicopter7drivers12SerialDriver4initEv>
     25e:	0c 94 3b 53 	jmp	0xa676	; 0xa676 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>
     262:	0c 94 33 57 	jmp	0xae66	; 0xae66 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>
     266:	0c 94 c1 5c 	jmp	0xb982	; 0xb982 <_ZN10helicopter5tasks4Task11runTaskImplEv>
     26a:	0c 94 50 24 	jmp	0x48a0	; 0x48a0 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
     26e:	0c 94 2b 57 	jmp	0xae56	; 0xae56 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>
     272:	0c 94 64 53 	jmp	0xa6c8	; 0xa6c8 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>
     276:	0c 94 f1 5c 	jmp	0xb9e2	; 0xb9e2 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>
     27a:	0c 94 3d 0e 	jmp	0x1c7a	; 0x1c7a <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     27e:	0c 94 9e 57 	jmp	0xaf3c	; 0xaf3c <_ZN10helicopter5tasks16ServoControlTaskD1Ev>
     282:	0c 94 f9 25 	jmp	0x4bf2	; 0x4bf2 <_ZN10helicopter8messages7Message8getBytesEv>
     286:	0c 94 ef 55 	jmp	0xabde	; 0xabde <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>
     28a:	0c 94 17 26 	jmp	0x4c2e	; 0x4c2e <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>
     28e:	0c 94 fc 25 	jmp	0x4bf8	; 0x4bf8 <_ZN10helicopter8messages7Message12buildMessageEPh>
     292:	0c 94 c2 5c 	jmp	0xb984	; 0xb984 <_ZN10helicopter5tasks4TaskD1Ev>
     296:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <_ZN10helicopter7drivers12SerialDriver8transmitEf>
     29a:	0c 94 94 0f 	jmp	0x1f28	; 0x1f28 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>
     29e:	0c 94 cb 51 	jmp	0xa396	; 0xa396 <_ZN10helicopter5tasks4Task4initEv>
     2a2:	0c 94 0e 58 	jmp	0xb01c	; 0xb01c <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>
     2a6:	0c 94 3a 23 	jmp	0x4674	; 0x4674 <_ZN10helicopter8messages12GainsMessageD0Ev>
     2aa:	0c 94 c2 27 	jmp	0x4f84	; 0x4f84 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>
     2ae:	0c 94 78 2b 	jmp	0x56f0	; 0x56f0 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>
     2b2:	0c 94 5b 2b 	jmp	0x56b6	; 0x56b6 <_ZN10helicopter8messages11SyncMessage8getBytesEv>
     2b6:	0c 94 f7 55 	jmp	0xabee	; 0xabee <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>
     2ba:	0c 94 02 53 	jmp	0xa604	; 0xa604 <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>
     2be:	0c 94 6a 2b 	jmp	0x56d4	; 0x56d4 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>
     2c2:	0c 94 2d 53 	jmp	0xa65a	; 0xa65a <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>
     2c6:	0c 94 a4 57 	jmp	0xaf48	; 0xaf48 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>
     2ca:	0c 94 14 58 	jmp	0xb028	; 0xb028 <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>
     2ce:	0c 94 53 2b 	jmp	0x56a6	; 0x56a6 <_ZN10helicopter8messages11SyncMessageD0Ev>
     2d2:	0c 94 da 51 	jmp	0xa3b4	; 0xa3b4 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>
     2d6:	0c 94 09 26 	jmp	0x4c12	; 0x4c12 <_ZN10helicopter8messages17SensorDataMessageD1Ev>
     2da:	0c 94 33 53 	jmp	0xa666	; 0xa666 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>
     2de:	0c 94 41 2b 	jmp	0x5682	; 0x5682 <_ZN10helicopter8messages11SyncMessageD1Ev>
     2e2:	0c 94 34 23 	jmp	0x4668	; 0x4668 <_ZN10helicopter8messages12GainsMessageD1Ev>
     2e6:	0c 94 65 0f 	jmp	0x1eca	; 0x1eca <_ZN10helicopter5tasks12FlashLEDTask4initEv>
     2ea:	0c 94 cf 22 	jmp	0x459e	; 0x459e <_ZN10helicopter8messages14ControlMessageD0Ev>
     2ee:	0c 94 47 2b 	jmp	0x568e	; 0x568e <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>
     2f2:	0c 94 0f 26 	jmp	0x4c1e	; 0x4c1e <_ZN10helicopter8messages17SensorDataMessageD0Ev>
     2f6:	0c 94 6a 55 	jmp	0xaad4	; 0xaad4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>
     2fa:	0c 94 ac 26 	jmp	0x4d58	; 0x4d58 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
     2fe:	0c 94 c9 22 	jmp	0x4592	; 0x4592 <_ZN10helicopter8messages14ControlMessageD1Ev>
     302:	0c 94 64 55 	jmp	0xaac8	; 0xaac8 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>
     306:	0c 94 c8 5c 	jmp	0xb990	; 0xb990 <_ZN10helicopter5tasks4Task7runTaskEv>
     30a:	0c 94 25 57 	jmp	0xae4a	; 0xae4a <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>
     30e:	0c 94 72 55 	jmp	0xaae4	; 0xaae4 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>
     312:	0c 94 5f 0c 	jmp	0x18be	; 0x18be <_ZN10helicopter7drivers12SerialDriver8transmitEh>
     316:	0c 94 72 0f 	jmp	0x1ee4	; 0x1ee4 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>
     31a:	0c 94 70 2b 	jmp	0x56e0	; 0x56e0 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>
     31e:	0c 94 4a 0e 	jmp	0x1c94	; 0x1c94 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     322:	0c 94 e9 55 	jmp	0xabd2	; 0xabd2 <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>
     326:	0c 94 9c 56 	jmp	0xad38	; 0xad38 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>
     32a:	0c 94 e3 5c 	jmp	0xb9c6	; 0xb9c6 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>
     32e:	0c 94 32 29 	jmp	0x5264	; 0x5264 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
     332:	0c 94 83 2f 	jmp	0x5f06	; 0x5f06 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>

00000336 <__ctors_start>:
     336:	3d 0e       	add	r3, r29

00000338 <__ctors_end>:
     338:	4a 0e       	add	r4, r26

0000033a <__dtors_end>:
     33a:	11 24       	eor	r1, r1
     33c:	1f be       	out	0x3f, r1	; 63
     33e:	cf ef       	ldi	r28, 0xFF	; 255
     340:	d1 e2       	ldi	r29, 0x21	; 33
     342:	de bf       	out	0x3e, r29	; 62
     344:	cd bf       	out	0x3d, r28	; 61
     346:	00 e0       	ldi	r16, 0x00	; 0
     348:	0c bf       	out	0x3c, r16	; 60

0000034a <__do_copy_data>:
     34a:	13 e0       	ldi	r17, 0x03	; 3
     34c:	a0 e0       	ldi	r26, 0x00	; 0
     34e:	b2 e0       	ldi	r27, 0x02	; 2
     350:	e8 eb       	ldi	r30, 0xB8	; 184
     352:	fb ed       	ldi	r31, 0xDB	; 219
     354:	00 e0       	ldi	r16, 0x00	; 0
     356:	0b bf       	out	0x3b, r16	; 59
     358:	02 c0       	rjmp	.+4      	; 0x35e <__do_copy_data+0x14>
     35a:	07 90       	elpm	r0, Z+
     35c:	0d 92       	st	X+, r0
     35e:	ae 38       	cpi	r26, 0x8E	; 142
     360:	b1 07       	cpc	r27, r17
     362:	d9 f7       	brne	.-10     	; 0x35a <__do_copy_data+0x10>

00000364 <__do_clear_bss>:
     364:	20 e1       	ldi	r18, 0x10	; 16
     366:	ae e8       	ldi	r26, 0x8E	; 142
     368:	b3 e0       	ldi	r27, 0x03	; 3
     36a:	01 c0       	rjmp	.+2      	; 0x36e <.do_clear_bss_start>

0000036c <.do_clear_bss_loop>:
     36c:	1d 92       	st	X+, r1

0000036e <.do_clear_bss_start>:
     36e:	a0 38       	cpi	r26, 0x80	; 128
     370:	b2 07       	cpc	r27, r18
     372:	e1 f7       	brne	.-8      	; 0x36c <.do_clear_bss_loop>

00000374 <__do_global_ctors>:
     374:	13 e0       	ldi	r17, 0x03	; 3
     376:	c8 e3       	ldi	r28, 0x38	; 56
     378:	d3 e0       	ldi	r29, 0x03	; 3
     37a:	00 e0       	ldi	r16, 0x00	; 0
     37c:	06 c0       	rjmp	.+12     	; 0x38a <__do_global_ctors+0x16>
     37e:	22 97       	sbiw	r28, 0x02	; 2
     380:	01 09       	sbc	r16, r1
     382:	fe 01       	movw	r30, r28
     384:	0b bf       	out	0x3b, r16	; 59
     386:	0e 94 37 6c 	call	0xd86e	; 0xd86e <__tablejump_elpm__>
     38a:	c6 33       	cpi	r28, 0x36	; 54
     38c:	d1 07       	cpc	r29, r17
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	08 07       	cpc	r16, r24
     392:	a9 f7       	brne	.-22     	; 0x37e <__do_global_ctors+0xa>
     394:	0e 94 95 12 	call	0x252a	; 0x252a <main>
     398:	0c 94 ca 6d 	jmp	0xdb94	; 0xdb94 <__do_global_dtors>

0000039c <__bad_interrupt>:
     39c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>:
#include <avr/interrupt.h>

using namespace helicopter::buffer;

bool CircularBuffer::enqueue(byte val)
{	
     3a0:	fc 01       	movw	r30, r24
	PORTA &= ~(1<<PA5);
}
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     3a2:	20 85       	ldd	r18, Z+8	; 0x08
     3a4:	31 85       	ldd	r19, Z+9	; 0x09
     3a6:	82 81       	ldd	r24, Z+2	; 0x02
     3a8:	93 81       	ldd	r25, Z+3	; 0x03
     3aa:	28 17       	cp	r18, r24
     3ac:	39 07       	cpc	r19, r25
     3ae:	fc f4       	brge	.+62     	; 0x3ee <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x4e>
	{
		return false;
	}
cli();		
     3b0:	f8 94       	cli
	buffer[tailIndex++] = val;
     3b2:	20 81       	ld	r18, Z
     3b4:	31 81       	ldd	r19, Z+1	; 0x01
     3b6:	86 81       	ldd	r24, Z+6	; 0x06
     3b8:	97 81       	ldd	r25, Z+7	; 0x07
     3ba:	ac 01       	movw	r20, r24
     3bc:	4f 5f       	subi	r20, 0xFF	; 255
     3be:	5f 4f       	sbci	r21, 0xFF	; 255
     3c0:	57 83       	std	Z+7, r21	; 0x07
     3c2:	46 83       	std	Z+6, r20	; 0x06
     3c4:	d9 01       	movw	r26, r18
     3c6:	a8 0f       	add	r26, r24
     3c8:	b9 1f       	adc	r27, r25
     3ca:	6c 93       	st	X, r22
	
	if (tailIndex >= bufferSize)
     3cc:	26 81       	ldd	r18, Z+6	; 0x06
     3ce:	37 81       	ldd	r19, Z+7	; 0x07
     3d0:	82 81       	ldd	r24, Z+2	; 0x02
     3d2:	93 81       	ldd	r25, Z+3	; 0x03
     3d4:	28 17       	cp	r18, r24
     3d6:	39 07       	cpc	r19, r25
     3d8:	14 f0       	brlt	.+4      	; 0x3de <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x3e>
	{
		tailIndex = 0;
     3da:	17 82       	std	Z+7, r1	; 0x07
     3dc:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     3de:	80 85       	ldd	r24, Z+8	; 0x08
     3e0:	91 85       	ldd	r25, Z+9	; 0x09
     3e2:	01 96       	adiw	r24, 0x01	; 1
     3e4:	91 87       	std	Z+9, r25	; 0x09
     3e6:	80 87       	std	Z+8, r24	; 0x08
	
	
sei();
     3e8:	78 94       	sei
	return true;
     3ea:	81 e0       	ldi	r24, 0x01	; 1
     3ec:	08 95       	ret
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     3ee:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	
sei();
	return true;
}
     3f0:	08 95       	ret

000003f2 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>:

bool CircularBuffer::dequeue(byte &val)
{
     3f2:	fc 01       	movw	r30, r24
if ((tailIndex == headIndex) && bytesInQueue != 0)
{
	PORTA &= ~(1<<PA5);
}
*/
	val = 0;
     3f4:	db 01       	movw	r26, r22
     3f6:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     3f8:	80 85       	ldd	r24, Z+8	; 0x08
     3fa:	91 85       	ldd	r25, Z+9	; 0x09
     3fc:	89 2b       	or	r24, r25
     3fe:	09 f1       	breq	.+66     	; 0x442 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x50>
	{
		return false;
	}
	cli();	
     400:	f8 94       	cli
	val = buffer[headIndex++];
     402:	20 81       	ld	r18, Z
     404:	31 81       	ldd	r19, Z+1	; 0x01
     406:	84 81       	ldd	r24, Z+4	; 0x04
     408:	95 81       	ldd	r25, Z+5	; 0x05
     40a:	ac 01       	movw	r20, r24
     40c:	4f 5f       	subi	r20, 0xFF	; 255
     40e:	5f 4f       	sbci	r21, 0xFF	; 255
     410:	55 83       	std	Z+5, r21	; 0x05
     412:	44 83       	std	Z+4, r20	; 0x04
     414:	d9 01       	movw	r26, r18
     416:	a8 0f       	add	r26, r24
     418:	b9 1f       	adc	r27, r25
     41a:	8c 91       	ld	r24, X
     41c:	db 01       	movw	r26, r22
     41e:	8c 93       	st	X, r24
	
	if (headIndex >= bufferSize)
     420:	24 81       	ldd	r18, Z+4	; 0x04
     422:	35 81       	ldd	r19, Z+5	; 0x05
     424:	82 81       	ldd	r24, Z+2	; 0x02
     426:	93 81       	ldd	r25, Z+3	; 0x03
     428:	28 17       	cp	r18, r24
     42a:	39 07       	cpc	r19, r25
     42c:	14 f0       	brlt	.+4      	; 0x432 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x40>
	{
		headIndex = 0;
     42e:	15 82       	std	Z+5, r1	; 0x05
     430:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     432:	80 85       	ldd	r24, Z+8	; 0x08
     434:	91 85       	ldd	r25, Z+9	; 0x09
     436:	01 97       	sbiw	r24, 0x01	; 1
     438:	91 87       	std	Z+9, r25	; 0x09
     43a:	80 87       	std	Z+8, r24	; 0x08
	
	sei();
     43c:	78 94       	sei
	return true;
     43e:	81 e0       	ldi	r24, 0x01	; 1
     440:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     442:	80 e0       	ldi	r24, 0x00	; 0
	
	bytesInQueue--;
	
	sei();
	return true;
}
     444:	08 95       	ret

00000446 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>:



bool CircularBuffer::enqueueInt(byte val)
{
     446:	fc 01       	movw	r30, r24

	if ((tailIndex == headIndex) && bytesInQueue != 0)
     448:	26 81       	ldd	r18, Z+6	; 0x06
     44a:	37 81       	ldd	r19, Z+7	; 0x07
     44c:	84 81       	ldd	r24, Z+4	; 0x04
     44e:	95 81       	ldd	r25, Z+5	; 0x05
     450:	28 17       	cp	r18, r24
     452:	39 07       	cpc	r19, r25
     454:	29 f4       	brne	.+10     	; 0x460 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
     456:	80 85       	ldd	r24, Z+8	; 0x08
     458:	91 85       	ldd	r25, Z+9	; 0x09
     45a:	89 2b       	or	r24, r25
     45c:	09 f0       	breq	.+2      	; 0x460 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     45e:	15 98       	cbi	0x02, 5	; 2
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     460:	20 85       	ldd	r18, Z+8	; 0x08
     462:	31 85       	ldd	r19, Z+9	; 0x09
     464:	82 81       	ldd	r24, Z+2	; 0x02
     466:	93 81       	ldd	r25, Z+3	; 0x03
     468:	28 17       	cp	r18, r24
     46a:	39 07       	cpc	r19, r25
     46c:	ec f4       	brge	.+58     	; 0x4a8 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x62>
	{
		return false;
	}
	
	buffer[tailIndex++] = val;
     46e:	20 81       	ld	r18, Z
     470:	31 81       	ldd	r19, Z+1	; 0x01
     472:	86 81       	ldd	r24, Z+6	; 0x06
     474:	97 81       	ldd	r25, Z+7	; 0x07
     476:	ac 01       	movw	r20, r24
     478:	4f 5f       	subi	r20, 0xFF	; 255
     47a:	5f 4f       	sbci	r21, 0xFF	; 255
     47c:	57 83       	std	Z+7, r21	; 0x07
     47e:	46 83       	std	Z+6, r20	; 0x06
     480:	d9 01       	movw	r26, r18
     482:	a8 0f       	add	r26, r24
     484:	b9 1f       	adc	r27, r25
     486:	6c 93       	st	X, r22
	
	if (tailIndex >= bufferSize)
     488:	26 81       	ldd	r18, Z+6	; 0x06
     48a:	37 81       	ldd	r19, Z+7	; 0x07
     48c:	82 81       	ldd	r24, Z+2	; 0x02
     48e:	93 81       	ldd	r25, Z+3	; 0x03
     490:	28 17       	cp	r18, r24
     492:	39 07       	cpc	r19, r25
     494:	14 f0       	brlt	.+4      	; 0x49a <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x54>
	{
		tailIndex = 0;
     496:	17 82       	std	Z+7, r1	; 0x07
     498:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     49a:	80 85       	ldd	r24, Z+8	; 0x08
     49c:	91 85       	ldd	r25, Z+9	; 0x09
     49e:	01 96       	adiw	r24, 0x01	; 1
     4a0:	91 87       	std	Z+9, r25	; 0x09
     4a2:	80 87       	std	Z+8, r24	; 0x08
	
	

	return true;
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	08 95       	ret
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     4a8:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	

	return true;
}
     4aa:	08 95       	ret

000004ac <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>:

bool CircularBuffer::dequeueInt(byte &val)
{
     4ac:	fc 01       	movw	r30, r24
	if ((tailIndex == headIndex) && bytesInQueue != 0)
     4ae:	26 81       	ldd	r18, Z+6	; 0x06
     4b0:	37 81       	ldd	r19, Z+7	; 0x07
     4b2:	84 81       	ldd	r24, Z+4	; 0x04
     4b4:	95 81       	ldd	r25, Z+5	; 0x05
     4b6:	28 17       	cp	r18, r24
     4b8:	39 07       	cpc	r19, r25
     4ba:	29 f4       	brne	.+10     	; 0x4c6 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
     4bc:	80 85       	ldd	r24, Z+8	; 0x08
     4be:	91 85       	ldd	r25, Z+9	; 0x09
     4c0:	89 2b       	or	r24, r25
     4c2:	09 f0       	breq	.+2      	; 0x4c6 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     4c4:	15 98       	cbi	0x02, 5	; 2
	}
	val = 0;
     4c6:	db 01       	movw	r26, r22
     4c8:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     4ca:	80 85       	ldd	r24, Z+8	; 0x08
     4cc:	91 85       	ldd	r25, Z+9	; 0x09
     4ce:	89 2b       	or	r24, r25
     4d0:	f9 f0       	breq	.+62     	; 0x510 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x64>
	{
		return false;
	}
	
	val = buffer[headIndex++];
     4d2:	20 81       	ld	r18, Z
     4d4:	31 81       	ldd	r19, Z+1	; 0x01
     4d6:	84 81       	ldd	r24, Z+4	; 0x04
     4d8:	95 81       	ldd	r25, Z+5	; 0x05
     4da:	ac 01       	movw	r20, r24
     4dc:	4f 5f       	subi	r20, 0xFF	; 255
     4de:	5f 4f       	sbci	r21, 0xFF	; 255
     4e0:	55 83       	std	Z+5, r21	; 0x05
     4e2:	44 83       	std	Z+4, r20	; 0x04
     4e4:	d9 01       	movw	r26, r18
     4e6:	a8 0f       	add	r26, r24
     4e8:	b9 1f       	adc	r27, r25
     4ea:	8c 91       	ld	r24, X
     4ec:	db 01       	movw	r26, r22
     4ee:	8c 93       	st	X, r24
	
	if (headIndex >= bufferSize)
     4f0:	24 81       	ldd	r18, Z+4	; 0x04
     4f2:	35 81       	ldd	r19, Z+5	; 0x05
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	28 17       	cp	r18, r24
     4fa:	39 07       	cpc	r19, r25
     4fc:	14 f0       	brlt	.+4      	; 0x502 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x56>
	{
		headIndex = 0;
     4fe:	15 82       	std	Z+5, r1	; 0x05
     500:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     502:	80 85       	ldd	r24, Z+8	; 0x08
     504:	91 85       	ldd	r25, Z+9	; 0x09
     506:	01 97       	sbiw	r24, 0x01	; 1
     508:	91 87       	std	Z+9, r25	; 0x09
     50a:	80 87       	std	Z+8, r24	; 0x08
	
	return true;
     50c:	81 e0       	ldi	r24, 0x01	; 1
     50e:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     510:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	bytesInQueue--;
	
	return true;
}
     512:	08 95       	ret

00000514 <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>:
#include "MatrixUtil.h"

using namespace helicopter::controller;
using namespace helicopter::util;

PIDController::PIDController(SystemModel *model): 
     514:	fc 01       	movw	r30, r24
minMainRotorServoControlValue(0),
maxMainRotorServoControlValue(0),

intervalPeriodSecs(0),
controlMaxValue(0),
controlMinValue(0)
     516:	71 83       	std	Z+1, r23	; 0x01
     518:	60 83       	st	Z, r22
     51a:	12 82       	std	Z+2, r1	; 0x02
     51c:	13 82       	std	Z+3, r1	; 0x03
     51e:	14 82       	std	Z+4, r1	; 0x04
     520:	15 82       	std	Z+5, r1	; 0x05
     522:	16 82       	std	Z+6, r1	; 0x06
     524:	17 82       	std	Z+7, r1	; 0x07
     526:	10 86       	std	Z+8, r1	; 0x08
     528:	11 86       	std	Z+9, r1	; 0x09
     52a:	12 86       	std	Z+10, r1	; 0x0a
     52c:	13 86       	std	Z+11, r1	; 0x0b
     52e:	14 86       	std	Z+12, r1	; 0x0c
     530:	15 86       	std	Z+13, r1	; 0x0d
     532:	16 86       	std	Z+14, r1	; 0x0e
     534:	17 86       	std	Z+15, r1	; 0x0f
     536:	10 8a       	std	Z+16, r1	; 0x10
     538:	11 8a       	std	Z+17, r1	; 0x11
     53a:	12 8a       	std	Z+18, r1	; 0x12
     53c:	13 8a       	std	Z+19, r1	; 0x13
     53e:	14 8a       	std	Z+20, r1	; 0x14
     540:	15 8a       	std	Z+21, r1	; 0x15
     542:	16 8a       	std	Z+22, r1	; 0x16
     544:	17 8a       	std	Z+23, r1	; 0x17
     546:	10 8e       	std	Z+24, r1	; 0x18
     548:	11 8e       	std	Z+25, r1	; 0x19
     54a:	12 8e       	std	Z+26, r1	; 0x1a
     54c:	13 8e       	std	Z+27, r1	; 0x1b
     54e:	14 8e       	std	Z+28, r1	; 0x1c
     550:	15 8e       	std	Z+29, r1	; 0x1d
     552:	16 8e       	std	Z+30, r1	; 0x1e
     554:	17 8e       	std	Z+31, r1	; 0x1f
     556:	10 a2       	std	Z+32, r1	; 0x20
     558:	11 a2       	std	Z+33, r1	; 0x21
     55a:	12 a2       	std	Z+34, r1	; 0x22
     55c:	13 a2       	std	Z+35, r1	; 0x23
     55e:	14 a2       	std	Z+36, r1	; 0x24
     560:	15 a2       	std	Z+37, r1	; 0x25
     562:	12 a6       	std	Z+42, r1	; 0x2a
     564:	13 a6       	std	Z+43, r1	; 0x2b
     566:	14 a6       	std	Z+44, r1	; 0x2c
     568:	15 a6       	std	Z+45, r1	; 0x2d
     56a:	16 a6       	std	Z+46, r1	; 0x2e
     56c:	17 a6       	std	Z+47, r1	; 0x2f
     56e:	10 aa       	std	Z+48, r1	; 0x30
     570:	11 aa       	std	Z+49, r1	; 0x31
     572:	12 aa       	std	Z+50, r1	; 0x32
     574:	13 aa       	std	Z+51, r1	; 0x33
     576:	14 aa       	std	Z+52, r1	; 0x34
     578:	15 aa       	std	Z+53, r1	; 0x35
     57a:	16 aa       	std	Z+54, r1	; 0x36
     57c:	17 aa       	std	Z+55, r1	; 0x37
     57e:	10 ae       	std	Z+56, r1	; 0x38
     580:	11 ae       	std	Z+57, r1	; 0x39
     582:	12 ae       	std	Z+58, r1	; 0x3a
     584:	13 ae       	std	Z+59, r1	; 0x3b
     586:	14 ae       	std	Z+60, r1	; 0x3c
     588:	15 ae       	std	Z+61, r1	; 0x3d
     58a:	dc 01       	movw	r26, r24
     58c:	ae 5b       	subi	r26, 0xBE	; 190
     58e:	bf 4f       	sbci	r27, 0xFF	; 255
     590:	1d 92       	st	X+, r1
     592:	1d 92       	st	X+, r1
     594:	1d 92       	st	X+, r1
     596:	1c 92       	st	X, r1
     598:	13 97       	sbiw	r26, 0x03	; 3
     59a:	14 96       	adiw	r26, 0x04	; 4
     59c:	1d 92       	st	X+, r1
     59e:	1d 92       	st	X+, r1
     5a0:	1d 92       	st	X+, r1
     5a2:	1c 92       	st	X, r1
     5a4:	13 97       	sbiw	r26, 0x03	; 3
     5a6:	14 96       	adiw	r26, 0x04	; 4
     5a8:	1d 92       	st	X+, r1
     5aa:	1d 92       	st	X+, r1
     5ac:	1d 92       	st	X+, r1
     5ae:	1c 92       	st	X, r1
     5b0:	13 97       	sbiw	r26, 0x03	; 3
     5b2:	14 96       	adiw	r26, 0x04	; 4
     5b4:	1d 92       	st	X+, r1
     5b6:	1d 92       	st	X+, r1
     5b8:	1d 92       	st	X+, r1
     5ba:	1c 92       	st	X, r1
     5bc:	13 97       	sbiw	r26, 0x03	; 3
     5be:	14 96       	adiw	r26, 0x04	; 4
     5c0:	1d 92       	st	X+, r1
     5c2:	1d 92       	st	X+, r1
     5c4:	1d 92       	st	X+, r1
     5c6:	1c 92       	st	X, r1
     5c8:	13 97       	sbiw	r26, 0x03	; 3
     5ca:	14 96       	adiw	r26, 0x04	; 4
     5cc:	1d 92       	st	X+, r1
     5ce:	1d 92       	st	X+, r1
     5d0:	1d 92       	st	X+, r1
     5d2:	1c 92       	st	X, r1
     5d4:	13 97       	sbiw	r26, 0x03	; 3
     5d6:	14 96       	adiw	r26, 0x04	; 4
     5d8:	1d 92       	st	X+, r1
     5da:	1d 92       	st	X+, r1
     5dc:	1d 92       	st	X+, r1
     5de:	1c 92       	st	X, r1
     5e0:	13 97       	sbiw	r26, 0x03	; 3
     5e2:	14 96       	adiw	r26, 0x04	; 4
     5e4:	1d 92       	st	X+, r1
     5e6:	1d 92       	st	X+, r1
     5e8:	1d 92       	st	X+, r1
     5ea:	1c 92       	st	X, r1
     5ec:	13 97       	sbiw	r26, 0x03	; 3
     5ee:	14 96       	adiw	r26, 0x04	; 4
     5f0:	1d 92       	st	X+, r1
     5f2:	1d 92       	st	X+, r1
     5f4:	1d 92       	st	X+, r1
     5f6:	1c 92       	st	X, r1
     5f8:	13 97       	sbiw	r26, 0x03	; 3
     5fa:	14 96       	adiw	r26, 0x04	; 4
     5fc:	1d 92       	st	X+, r1
     5fe:	1d 92       	st	X+, r1
     600:	1d 92       	st	X+, r1
     602:	1c 92       	st	X, r1
     604:	13 97       	sbiw	r26, 0x03	; 3
     606:	14 96       	adiw	r26, 0x04	; 4
     608:	1d 92       	st	X+, r1
     60a:	1d 92       	st	X+, r1
     60c:	1d 92       	st	X+, r1
     60e:	1c 92       	st	X, r1
     610:	13 97       	sbiw	r26, 0x03	; 3
     612:	14 96       	adiw	r26, 0x04	; 4
     614:	1d 92       	st	X+, r1
     616:	1d 92       	st	X+, r1
     618:	1d 92       	st	X+, r1
     61a:	1c 92       	st	X, r1
     61c:	13 97       	sbiw	r26, 0x03	; 3
     61e:	54 96       	adiw	r26, 0x14	; 20
     620:	1d 92       	st	X+, r1
     622:	1d 92       	st	X+, r1
     624:	1d 92       	st	X+, r1
     626:	1c 92       	st	X, r1
     628:	13 97       	sbiw	r26, 0x03	; 3
     62a:	14 96       	adiw	r26, 0x04	; 4
     62c:	1d 92       	st	X+, r1
     62e:	1d 92       	st	X+, r1
     630:	1d 92       	st	X+, r1
     632:	1c 92       	st	X, r1
     634:	13 97       	sbiw	r26, 0x03	; 3
     636:	e6 57       	subi	r30, 0x76	; 118
     638:	ff 4f       	sbci	r31, 0xFF	; 255
     63a:	10 82       	st	Z, r1
     63c:	11 82       	std	Z+1, r1	; 0x01
     63e:	12 82       	std	Z+2, r1	; 0x02
     640:	13 82       	std	Z+3, r1	; 0x03
     642:	08 95       	ret

00000644 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>:


//TODO WTF IS THIS DOING HERE?? THIS IS THE WRONG CONTROLLER!!
void PIDController::addBlownFrame()
{
	model->BlownFrames(model->BlownFrames() + 1);
     644:	dc 01       	movw	r26, r24
     646:	ed 91       	ld	r30, X+
     648:	fc 91       	ld	r31, X
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
     64a:	ea 54       	subi	r30, 0x4A	; 74
     64c:	ff 4f       	sbci	r31, 0xFF	; 255
     64e:	80 81       	ld	r24, Z
     650:	91 81       	ldd	r25, Z+1	; 0x01
     652:	a2 81       	ldd	r26, Z+2	; 0x02
     654:	b3 81       	ldd	r27, Z+3	; 0x03
     656:	01 96       	adiw	r24, 0x01	; 1
     658:	a1 1d       	adc	r26, r1
     65a:	b1 1d       	adc	r27, r1
     65c:	80 83       	st	Z, r24
     65e:	91 83       	std	Z+1, r25	; 0x01
     660:	a2 83       	std	Z+2, r26	; 0x02
     662:	b3 83       	std	Z+3, r27	; 0x03
     664:	08 95       	ret

00000666 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>:
	}
}


void PIDController::tailRotorCollectiveOuterLoopUpdate()
{
     666:	2f 92       	push	r2
     668:	3f 92       	push	r3
     66a:	4f 92       	push	r4
     66c:	5f 92       	push	r5
     66e:	6f 92       	push	r6
     670:	7f 92       	push	r7
     672:	8f 92       	push	r8
     674:	9f 92       	push	r9
     676:	af 92       	push	r10
     678:	bf 92       	push	r11
     67a:	cf 92       	push	r12
     67c:	df 92       	push	r13
     67e:	ef 92       	push	r14
     680:	ff 92       	push	r15
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	cd b7       	in	r28, 0x3d	; 61
     68c:	de b7       	in	r29, 0x3e	; 62
     68e:	2c 97       	sbiw	r28, 0x0c	; 12
     690:	0f b6       	in	r0, 0x3f	; 63
     692:	f8 94       	cli
     694:	de bf       	out	0x3e, r29	; 62
     696:	0f be       	out	0x3f, r0	; 63
     698:	cd bf       	out	0x3d, r28	; 61
     69a:	9c 87       	std	Y+12, r25	; 0x0c
     69c:	8b 87       	std	Y+11, r24	; 0x0b
	float yawProportional = calculateProportional(model->YawRads(), model->ReferenceMagYawRads());
     69e:	dc 01       	movw	r26, r24
     6a0:	0d 91       	ld	r16, X+
     6a2:	1c 91       	ld	r17, X
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
     6a4:	f8 01       	movw	r30, r16
     6a6:	ea 52       	subi	r30, 0x2A	; 42
     6a8:	ff 4f       	sbci	r31, 0xFF	; 255
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
     6aa:	d8 01       	movw	r26, r16
     6ac:	16 96       	adiw	r26, 0x06	; 6
     6ae:	2d 91       	ld	r18, X+
     6b0:	3d 91       	ld	r19, X+
     6b2:	4d 91       	ld	r20, X+
     6b4:	5c 91       	ld	r21, X
     6b6:	19 97       	sbiw	r26, 0x09	; 9
     6b8:	60 81       	ld	r22, Z
     6ba:	71 81       	ldd	r23, Z+1	; 0x01
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     6c4:	6b 01       	movw	r12, r22
     6c6:	7c 01       	movw	r14, r24
				/**
				 * Converts the error from 0-360, to -180 - 180 (in the equivalent of rads - i.e. yawError should be rads).
				 */
				inline float convertYawErrorFrom2PitoPlusMinusPi( float  yawErrorRads )
				{
					if (yawErrorRads >= M_PI)
     6c8:	2b ed       	ldi	r18, 0xDB	; 219
     6ca:	3f e0       	ldi	r19, 0x0F	; 15
     6cc:	49 e4       	ldi	r20, 0x49	; 73
     6ce:	50 e4       	ldi	r21, 0x40	; 64
     6d0:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
     6d4:	88 23       	and	r24, r24
     6d6:	5c f0       	brlt	.+22     	; 0x6ee <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x88>
					{
						yawErrorRads = yawErrorRads - (2 * M_PI);
     6d8:	2b ed       	ldi	r18, 0xDB	; 219
     6da:	3f e0       	ldi	r19, 0x0F	; 15
     6dc:	49 ec       	ldi	r20, 0xC9	; 201
     6de:	50 e4       	ldi	r21, 0x40	; 64
     6e0:	c7 01       	movw	r24, r14
     6e2:	b6 01       	movw	r22, r12
     6e4:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     6e8:	6b 01       	movw	r12, r22
     6ea:	7c 01       	movw	r14, r24
     6ec:	14 c0       	rjmp	.+40     	; 0x716 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xb0>
					}
					else if (yawErrorRads < -M_PI)
     6ee:	2b ed       	ldi	r18, 0xDB	; 219
     6f0:	3f e0       	ldi	r19, 0x0F	; 15
     6f2:	49 e4       	ldi	r20, 0x49	; 73
     6f4:	50 ec       	ldi	r21, 0xC0	; 192
     6f6:	c7 01       	movw	r24, r14
     6f8:	b6 01       	movw	r22, r12
     6fa:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
     6fe:	88 23       	and	r24, r24
     700:	54 f4       	brge	.+20     	; 0x716 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xb0>
					{
						yawErrorRads = yawErrorRads + (2 * M_PI);
     702:	2b ed       	ldi	r18, 0xDB	; 219
     704:	3f e0       	ldi	r19, 0x0F	; 15
     706:	49 ec       	ldi	r20, 0xC9	; 201
     708:	50 e4       	ldi	r21, 0x40	; 64
     70a:	c7 01       	movw	r24, r14
     70c:	b6 01       	movw	r22, r12
     70e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     712:	6b 01       	movw	r12, r22
     714:	7c 01       	movw	r14, r24
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     716:	f8 01       	movw	r30, r16
     718:	26 85       	ldd	r18, Z+14	; 0x0e
     71a:	37 85       	ldd	r19, Z+15	; 0x0f
     71c:	40 89       	ldd	r20, Z+16	; 0x10
     71e:	51 89       	ldd	r21, Z+17	; 0x11
     720:	62 85       	ldd	r22, Z+10	; 0x0a
     722:	73 85       	ldd	r23, Z+11	; 0x0b
     724:	84 85       	ldd	r24, Z+12	; 0x0c
     726:	95 85       	ldd	r25, Z+13	; 0x0d
     728:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     72c:	ab 85       	ldd	r26, Y+11	; 0x0b
     72e:	bc 85       	ldd	r27, Y+12	; 0x0c
     730:	1e 96       	adiw	r26, 0x0e	; 14
     732:	2d 91       	ld	r18, X+
     734:	3d 91       	ld	r19, X+
     736:	4d 91       	ld	r20, X+
     738:	5c 91       	ld	r21, X
     73a:	51 97       	sbiw	r26, 0x11	; 17
     73c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     740:	4b 01       	movw	r8, r22
     742:	5c 01       	movw	r10, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     744:	eb 85       	ldd	r30, Y+11	; 0x0b
     746:	fc 85       	ldd	r31, Y+12	; 0x0c
     748:	22 81       	ldd	r18, Z+2	; 0x02
     74a:	33 81       	ldd	r19, Z+3	; 0x03
     74c:	44 81       	ldd	r20, Z+4	; 0x04
     74e:	55 81       	ldd	r21, Z+5	; 0x05
     750:	c7 01       	movw	r24, r14
     752:	b6 01       	movw	r22, r12
     754:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     758:	9b 01       	movw	r18, r22
     75a:	ac 01       	movw	r20, r24
     75c:	c5 01       	movw	r24, r10
     75e:	b4 01       	movw	r22, r8
     760:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     764:	eb 85       	ldd	r30, Y+11	; 0x0b
     766:	fc 85       	ldd	r31, Y+12	; 0x0c
     768:	ee 57       	subi	r30, 0x7E	; 126
     76a:	ff 4f       	sbci	r31, 0xFF	; 255
     76c:	20 81       	ld	r18, Z
     76e:	31 81       	ldd	r19, Z+1	; 0x01
     770:	42 81       	ldd	r20, Z+2	; 0x02
     772:	53 81       	ldd	r21, Z+3	; 0x03
     774:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     778:	d8 01       	movw	r26, r16
     77a:	56 96       	adiw	r26, 0x16	; 22
     77c:	2d 91       	ld	r18, X+
     77e:	3d 91       	ld	r19, X+
     780:	4d 91       	ld	r20, X+
     782:	5c 91       	ld	r21, X
     784:	59 97       	sbiw	r26, 0x19	; 25
     786:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     78a:	4b 01       	movw	r8, r22
     78c:	5c 01       	movw	r10, r24
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     78e:	f8 01       	movw	r30, r16
     790:	22 89       	ldd	r18, Z+18	; 0x12
     792:	33 89       	ldd	r19, Z+19	; 0x13
     794:	44 89       	ldd	r20, Z+20	; 0x14
     796:	55 89       	ldd	r21, Z+21	; 0x15
     798:	ee 51       	subi	r30, 0x1E	; 30
     79a:	ff 4f       	sbci	r31, 0xFF	; 255
     79c:	60 81       	ld	r22, Z
     79e:	71 81       	ldd	r23, Z+1	; 0x01
     7a0:	82 81       	ldd	r24, Z+2	; 0x02
     7a2:	93 81       	ldd	r25, Z+3	; 0x03
     7a4:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     7a8:	6b 83       	std	Y+3, r22	; 0x03
     7aa:	7c 83       	std	Y+4, r23	; 0x04
     7ac:	8d 83       	std	Y+5, r24	; 0x05
     7ae:	9e 83       	std	Y+6, r25	; 0x06

float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     7b0:	ab 85       	ldd	r26, Y+11	; 0x0b
     7b2:	bc 85       	ldd	r27, Y+12	; 0x0c
     7b4:	1a 96       	adiw	r26, 0x0a	; 10
     7b6:	2d 91       	ld	r18, X+
     7b8:	3d 91       	ld	r19, X+
     7ba:	4d 91       	ld	r20, X+
     7bc:	5c 91       	ld	r21, X
     7be:	1d 97       	sbiw	r26, 0x0d	; 13
     7c0:	c7 01       	movw	r24, r14
     7c2:	b6 01       	movw	r22, r12
     7c4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     7c8:	9b 01       	movw	r18, r22
     7ca:	ac 01       	movw	r20, r24
     7cc:	c5 01       	movw	r24, r10
     7ce:	b4 01       	movw	r22, r8
     7d0:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     7d4:	2b 01       	movw	r4, r22
     7d6:	3c 01       	movw	r6, r24
     7d8:	eb 85       	ldd	r30, Y+11	; 0x0b
     7da:	fc 85       	ldd	r31, Y+12	; 0x0c
     7dc:	26 81       	ldd	r18, Z+6	; 0x06
     7de:	37 81       	ldd	r19, Z+7	; 0x07
     7e0:	40 85       	ldd	r20, Z+8	; 0x08
     7e2:	51 85       	ldd	r21, Z+9	; 0x09
     7e4:	6b 81       	ldd	r22, Y+3	; 0x03
     7e6:	7c 81       	ldd	r23, Y+4	; 0x04
     7e8:	8d 81       	ldd	r24, Y+5	; 0x05
     7ea:	9e 81       	ldd	r25, Y+6	; 0x06
     7ec:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     7f0:	9b 01       	movw	r18, r22
     7f2:	ac 01       	movw	r20, r24
     7f4:	c3 01       	movw	r24, r6
     7f6:	b2 01       	movw	r22, r4
     7f8:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     7fc:	69 83       	std	Y+1, r22	; 0x01
     7fe:	7a 83       	std	Y+2, r23	; 0x02
     800:	38 2e       	mov	r3, r24
     802:	29 2e       	mov	r2, r25
	
	float yawIntegralAntiWindup = calculateIntegralAntiWindup(model->YawControlBeforeServoLimitsAdjustment(), model->YawControl(), yawAntiWindupGain);
	float weightedYawIntegral = calculateIntegral(yawProportional, model->YawIntegral(), yawIntegralAntiWindup, yawIntegralGain);
	float yawDerivativeError = calculateVelocityError(model->YawAngularVelocityRadsPerSecond(), model->ReferenceYawVelocityRadsPerSecond());
	float yawControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(yawProportional, yawDerivativeError, weightedYawIntegral, yawProportionalGain, yawDerivativeGain, 1);
	float yawControl = adjustControlForServoLimits(yawControlBeforeServoLimitsAdjustment, minYawServoControlValue, maxYawServoControlValue);
     804:	eb 85       	ldd	r30, Y+11	; 0x0b
     806:	fc 85       	ldd	r31, Y+12	; 0x0c
     808:	ea 5a       	subi	r30, 0xAA	; 170
     80a:	ff 4f       	sbci	r31, 0xFF	; 255
     80c:	40 80       	ld	r4, Z
     80e:	51 80       	ldd	r5, Z+1	; 0x01
     810:	62 80       	ldd	r6, Z+2	; 0x02
     812:	73 80       	ldd	r7, Z+3	; 0x03
     814:	eb 85       	ldd	r30, Y+11	; 0x0b
     816:	fc 85       	ldd	r31, Y+12	; 0x0c
     818:	ee 5a       	subi	r30, 0xAE	; 174
     81a:	ff 4f       	sbci	r31, 0xFF	; 255
     81c:	80 81       	ld	r24, Z
     81e:	8f 83       	std	Y+7, r24	; 0x07
     820:	91 81       	ldd	r25, Z+1	; 0x01
     822:	98 87       	std	Y+8, r25	; 0x08
     824:	a2 81       	ldd	r26, Z+2	; 0x02
     826:	a9 87       	std	Y+9, r26	; 0x09
     828:	b3 81       	ldd	r27, Z+3	; 0x03
     82a:	ba 87       	std	Y+10, r27	; 0x0a

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
     82c:	26 2f       	mov	r18, r22
     82e:	37 2f       	mov	r19, r23
     830:	43 2d       	mov	r20, r3
     832:	52 2d       	mov	r21, r2
     834:	c3 01       	movw	r24, r6
     836:	b2 01       	movw	r22, r4
     838:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
     83c:	88 23       	and	r24, r24
     83e:	ac f0       	brlt	.+42     	; 0x86a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x204>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
     840:	29 81       	ldd	r18, Y+1	; 0x01
     842:	3a 81       	ldd	r19, Y+2	; 0x02
     844:	43 2d       	mov	r20, r3
     846:	52 2d       	mov	r21, r2
     848:	6f 81       	ldd	r22, Y+7	; 0x07
     84a:	78 85       	ldd	r23, Y+8	; 0x08
     84c:	89 85       	ldd	r24, Y+9	; 0x09
     84e:	9a 85       	ldd	r25, Y+10	; 0x0a
     850:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
     854:	18 16       	cp	r1, r24
     856:	2c f0       	brlt	.+10     	; 0x862 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x1fc>
     858:	49 80       	ldd	r4, Y+1	; 0x01
     85a:	5a 80       	ldd	r5, Y+2	; 0x02
     85c:	63 2c       	mov	r6, r3
     85e:	72 2c       	mov	r7, r2
     860:	04 c0       	rjmp	.+8      	; 0x86a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x204>
	{
		controlValueToAdjust = minServoControlValue;
     862:	4f 80       	ldd	r4, Y+7	; 0x07
     864:	58 84       	ldd	r5, Y+8	; 0x08
     866:	69 84       	ldd	r6, Y+9	; 0x09
     868:	7a 84       	ldd	r7, Y+10	; 0x0a
	float yawControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(yawProportional, yawDerivativeError, weightedYawIntegral, yawProportionalGain, yawDerivativeGain, 1);
	float yawControl = adjustControlForServoLimits(yawControlBeforeServoLimitsAdjustment, minYawServoControlValue, maxYawServoControlValue);
	
	//model->YawControl(yawControl);
	//Multiply by -1 because in the simulator, +1 results in counter clockwise yaw, but on the helicopter, it's a clockwise yaw. 
	model->YawControl(yawControl * -1);
     86a:	77 fa       	bst	r7, 7
     86c:	70 94       	com	r7
     86e:	77 f8       	bld	r7, 7
     870:	70 94       	com	r7
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
			void YawControl(float val) { yawControl = val;}
     872:	f8 01       	movw	r30, r16
     874:	42 86       	std	Z+10, r4	; 0x0a
     876:	53 86       	std	Z+11, r5	; 0x0b
     878:	64 86       	std	Z+12, r6	; 0x0c
     87a:	75 86       	std	Z+13, r7	; 0x0d
	model->YawControlBeforeServoLimitsAdjustment(yawControlBeforeServoLimitsAdjustment);
     87c:	ab 85       	ldd	r26, Y+11	; 0x0b
     87e:	bc 85       	ldd	r27, Y+12	; 0x0c
     880:	2d 91       	ld	r18, X+
     882:	3c 91       	ld	r19, X
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
     884:	89 81       	ldd	r24, Y+1	; 0x01
     886:	9a 81       	ldd	r25, Y+2	; 0x02
     888:	a3 2d       	mov	r26, r3
     88a:	b2 2d       	mov	r27, r2
     88c:	f9 01       	movw	r30, r18
     88e:	86 87       	std	Z+14, r24	; 0x0e
     890:	97 87       	std	Z+15, r25	; 0x0f
     892:	a0 8b       	std	Z+16, r26	; 0x10
     894:	b1 8b       	std	Z+17, r27	; 0x11
	model->YawIntegral(weightedYawIntegral);
     896:	ab 85       	ldd	r26, Y+11	; 0x0b
     898:	bc 85       	ldd	r27, Y+12	; 0x0c
     89a:	ed 91       	ld	r30, X+
     89c:	fc 91       	ld	r31, X
     89e:	11 97       	sbiw	r26, 0x01	; 1
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
			void YawIntegral(float val) { yawIntegral = val;}
     8a0:	86 8a       	std	Z+22, r8	; 0x16
     8a2:	97 8a       	std	Z+23, r9	; 0x17
     8a4:	a0 8e       	std	Z+24, r10	; 0x18
     8a6:	b1 8e       	std	Z+25, r11	; 0x19
	model->YawProportional(yawProportional);
     8a8:	ed 91       	ld	r30, X+
     8aa:	fc 91       	ld	r31, X
     8ac:	11 97       	sbiw	r26, 0x01	; 1

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}
     8ae:	c2 8e       	std	Z+26, r12	; 0x1a
     8b0:	d3 8e       	std	Z+27, r13	; 0x1b
     8b2:	e4 8e       	std	Z+28, r14	; 0x1c
     8b4:	f5 8e       	std	Z+29, r15	; 0x1d
	model->YawDerivativeError(yawDerivativeError);
     8b6:	ed 91       	ld	r30, X+
     8b8:	fc 91       	ld	r31, X

			float YawDerivativeError() const {return yawDerivativeError;}
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
     8ba:	8b 81       	ldd	r24, Y+3	; 0x03
     8bc:	9c 81       	ldd	r25, Y+4	; 0x04
     8be:	ad 81       	ldd	r26, Y+5	; 0x05
     8c0:	be 81       	ldd	r27, Y+6	; 0x06
     8c2:	86 8f       	std	Z+30, r24	; 0x1e
     8c4:	97 8f       	std	Z+31, r25	; 0x1f
     8c6:	a0 a3       	std	Z+32, r26	; 0x20
     8c8:	b1 a3       	std	Z+33, r27	; 0x21
}
     8ca:	2c 96       	adiw	r28, 0x0c	; 12
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	f8 94       	cli
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	cd bf       	out	0x3d, r28	; 61
     8d6:	df 91       	pop	r29
     8d8:	cf 91       	pop	r28
     8da:	1f 91       	pop	r17
     8dc:	0f 91       	pop	r16
     8de:	ff 90       	pop	r15
     8e0:	ef 90       	pop	r14
     8e2:	df 90       	pop	r13
     8e4:	cf 90       	pop	r12
     8e6:	bf 90       	pop	r11
     8e8:	af 90       	pop	r10
     8ea:	9f 90       	pop	r9
     8ec:	8f 90       	pop	r8
     8ee:	7f 90       	pop	r7
     8f0:	6f 90       	pop	r6
     8f2:	5f 90       	pop	r5
     8f4:	4f 90       	pop	r4
     8f6:	3f 90       	pop	r3
     8f8:	2f 90       	pop	r2
     8fa:	08 95       	ret

000008fc <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>:

void PIDController::mainRotorCollectiveOuterLoopUpdate(float zProportional)
{
     8fc:	2f 92       	push	r2
     8fe:	3f 92       	push	r3
     900:	4f 92       	push	r4
     902:	5f 92       	push	r5
     904:	6f 92       	push	r6
     906:	7f 92       	push	r7
     908:	8f 92       	push	r8
     90a:	9f 92       	push	r9
     90c:	af 92       	push	r10
     90e:	bf 92       	push	r11
     910:	cf 92       	push	r12
     912:	df 92       	push	r13
     914:	ef 92       	push	r14
     916:	ff 92       	push	r15
     918:	0f 93       	push	r16
     91a:	1f 93       	push	r17
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	cd b7       	in	r28, 0x3d	; 61
     922:	de b7       	in	r29, 0x3e	; 62
     924:	2c 97       	sbiw	r28, 0x0c	; 12
     926:	0f b6       	in	r0, 0x3f	; 63
     928:	f8 94       	cli
     92a:	de bf       	out	0x3e, r29	; 62
     92c:	0f be       	out	0x3f, r0	; 63
     92e:	cd bf       	out	0x3d, r28	; 61
     930:	9c 87       	std	Y+12, r25	; 0x0c
     932:	8b 87       	std	Y+11, r24	; 0x0b
     934:	4a 01       	movw	r8, r20
     936:	5b 01       	movw	r10, r22

	//float zProportional = calculateProportional(model->ZNEDLocalFrame(), model->ReferenceZNEDLocalFrameMeters());
	
	float zIntegralAntiWindup = calculateIntegralAntiWindup(model->MainRotorControlBeforeServoLimitsAdjustment(), model->MainRotorCollectiveControl(), zAntiWindupGain);
     938:	dc 01       	movw	r26, r24
     93a:	2d 90       	ld	r2, X+
     93c:	3c 90       	ld	r3, X
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
     93e:	81 01       	movw	r16, r2
     940:	0a 56       	subi	r16, 0x6A	; 106
     942:	1f 4f       	sbci	r17, 0xFF	; 255
     944:	7c 01       	movw	r14, r24
     946:	be e4       	ldi	r27, 0x4E	; 78
     948:	eb 0e       	add	r14, r27
     94a:	f1 1c       	adc	r15, r1

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
     94c:	f1 01       	movw	r30, r2
     94e:	ea 57       	subi	r30, 0x7A	; 122
     950:	ff 4f       	sbci	r31, 0xFF	; 255
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
     952:	d1 01       	movw	r26, r2
     954:	a6 57       	subi	r26, 0x76	; 118
     956:	bf 4f       	sbci	r27, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     958:	2d 91       	ld	r18, X+
     95a:	3d 91       	ld	r19, X+
     95c:	4d 91       	ld	r20, X+
     95e:	5c 91       	ld	r21, X
     960:	60 81       	ld	r22, Z
     962:	71 81       	ldd	r23, Z+1	; 0x01
     964:	82 81       	ldd	r24, Z+2	; 0x02
     966:	93 81       	ldd	r25, Z+3	; 0x03
     968:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     96c:	f7 01       	movw	r30, r14
     96e:	20 81       	ld	r18, Z
     970:	31 81       	ldd	r19, Z+1	; 0x01
     972:	42 81       	ldd	r20, Z+2	; 0x02
     974:	53 81       	ldd	r21, Z+3	; 0x03
     976:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     97a:	6b 01       	movw	r12, r22
     97c:	7c 01       	movw	r14, r24
	float weightedZIntegral = calculateIntegral(zProportional, model->ZIntegral(), zIntegralAntiWindup, zIntegralGain);
     97e:	eb 85       	ldd	r30, Y+11	; 0x0b
     980:	fc 85       	ldd	r31, Y+12	; 0x0c
     982:	ee 5b       	subi	r30, 0xBE	; 190
     984:	ff 4f       	sbci	r31, 0xFF	; 255
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     986:	20 81       	ld	r18, Z
     988:	31 81       	ldd	r19, Z+1	; 0x01
     98a:	42 81       	ldd	r20, Z+2	; 0x02
     98c:	53 81       	ldd	r21, Z+3	; 0x03
     98e:	c5 01       	movw	r24, r10
     990:	b4 01       	movw	r22, r8
     992:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     996:	9b 01       	movw	r18, r22
     998:	ac 01       	movw	r20, r24
     99a:	c7 01       	movw	r24, r14
     99c:	b6 01       	movw	r22, r12
     99e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     9a2:	eb 85       	ldd	r30, Y+11	; 0x0b
     9a4:	fc 85       	ldd	r31, Y+12	; 0x0c
     9a6:	ee 57       	subi	r30, 0x7E	; 126
     9a8:	ff 4f       	sbci	r31, 0xFF	; 255
     9aa:	20 81       	ld	r18, Z
     9ac:	31 81       	ldd	r19, Z+1	; 0x01
     9ae:	42 81       	ldd	r20, Z+2	; 0x02
     9b0:	53 81       	ldd	r21, Z+3	; 0x03
     9b2:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     9b6:	d8 01       	movw	r26, r16
     9b8:	2d 91       	ld	r18, X+
     9ba:	3d 91       	ld	r19, X+
     9bc:	4d 91       	ld	r20, X+
     9be:	5c 91       	ld	r21, X
     9c0:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     9c4:	6b 83       	std	Y+3, r22	; 0x03
     9c6:	7c 83       	std	Y+4, r23	; 0x04
     9c8:	8d 83       	std	Y+5, r24	; 0x05
     9ca:	9e 83       	std	Y+6, r25	; 0x06
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
     9cc:	f1 01       	movw	r30, r2
     9ce:	e2 57       	subi	r30, 0x72	; 114
     9d0:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
     9d2:	d1 01       	movw	r26, r2
     9d4:	ae 56       	subi	r26, 0x6E	; 110
     9d6:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     9d8:	2d 91       	ld	r18, X+
     9da:	3d 91       	ld	r19, X+
     9dc:	4d 91       	ld	r20, X+
     9de:	5c 91       	ld	r21, X
     9e0:	60 81       	ld	r22, Z
     9e2:	71 81       	ldd	r23, Z+1	; 0x01
     9e4:	82 81       	ldd	r24, Z+2	; 0x02
     9e6:	93 81       	ldd	r25, Z+3	; 0x03
     9e8:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     9ec:	6b 01       	movw	r12, r22
     9ee:	7c 01       	movw	r14, r24
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
     9f0:	eb 85       	ldd	r30, Y+11	; 0x0b
     9f2:	fc 85       	ldd	r31, Y+12	; 0x0c
     9f4:	e6 5b       	subi	r30, 0xB6	; 182
     9f6:	ff 4f       	sbci	r31, 0xFF	; 255

float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     9f8:	20 81       	ld	r18, Z
     9fa:	31 81       	ldd	r19, Z+1	; 0x01
     9fc:	42 81       	ldd	r20, Z+2	; 0x02
     9fe:	53 81       	ldd	r21, Z+3	; 0x03
     a00:	c5 01       	movw	r24, r10
     a02:	b4 01       	movw	r22, r8
     a04:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     a08:	9b 01       	movw	r18, r22
     a0a:	ac 01       	movw	r20, r24
     a0c:	6b 81       	ldd	r22, Y+3	; 0x03
     a0e:	7c 81       	ldd	r23, Y+4	; 0x04
     a10:	8d 81       	ldd	r24, Y+5	; 0x05
     a12:	9e 81       	ldd	r25, Y+6	; 0x06
     a14:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     a18:	2b 01       	movw	r4, r22
     a1a:	3c 01       	movw	r6, r24
	//float zProportional = calculateProportional(model->ZNEDLocalFrame(), model->ReferenceZNEDLocalFrameMeters());
	
	float zIntegralAntiWindup = calculateIntegralAntiWindup(model->MainRotorControlBeforeServoLimitsAdjustment(), model->MainRotorCollectiveControl(), zAntiWindupGain);
	float weightedZIntegral = calculateIntegral(zProportional, model->ZIntegral(), zIntegralAntiWindup, zIntegralGain);
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
     a1c:	eb 85       	ldd	r30, Y+11	; 0x0b
     a1e:	fc 85       	ldd	r31, Y+12	; 0x0c
     a20:	ea 5b       	subi	r30, 0xBA	; 186
     a22:	ff 4f       	sbci	r31, 0xFF	; 255

float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     a24:	20 81       	ld	r18, Z
     a26:	31 81       	ldd	r19, Z+1	; 0x01
     a28:	42 81       	ldd	r20, Z+2	; 0x02
     a2a:	53 81       	ldd	r21, Z+3	; 0x03
     a2c:	c7 01       	movw	r24, r14
     a2e:	b6 01       	movw	r22, r12
     a30:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     a34:	9b 01       	movw	r18, r22
     a36:	ac 01       	movw	r20, r24
     a38:	c3 01       	movw	r24, r6
     a3a:	b2 01       	movw	r22, r4
     a3c:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     a40:	46 2e       	mov	r4, r22
     a42:	57 2e       	mov	r5, r23
     a44:	68 2e       	mov	r6, r24
     a46:	79 2e       	mov	r7, r25
	
	float zIntegralAntiWindup = calculateIntegralAntiWindup(model->MainRotorControlBeforeServoLimitsAdjustment(), model->MainRotorCollectiveControl(), zAntiWindupGain);
	float weightedZIntegral = calculateIntegral(zProportional, model->ZIntegral(), zIntegralAntiWindup, zIntegralGain);
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
	float mainRotorControl = adjustControlForServoLimits(mainRotorControlBeforeServoLimitsAdjustment, minMainRotorServoControlValue, maxMainRotorServoControlValue);
     a48:	eb 85       	ldd	r30, Y+11	; 0x0b
     a4a:	fc 85       	ldd	r31, Y+12	; 0x0c
     a4c:	e2 59       	subi	r30, 0x92	; 146
     a4e:	ff 4f       	sbci	r31, 0xFF	; 255
     a50:	10 81       	ld	r17, Z
     a52:	01 81       	ldd	r16, Z+1	; 0x01
     a54:	b2 81       	ldd	r27, Z+2	; 0x02
     a56:	b9 83       	std	Y+1, r27	; 0x01
     a58:	83 81       	ldd	r24, Z+3	; 0x03
     a5a:	8a 83       	std	Y+2, r24	; 0x02
     a5c:	eb 85       	ldd	r30, Y+11	; 0x0b
     a5e:	fc 85       	ldd	r31, Y+12	; 0x0c
     a60:	e6 59       	subi	r30, 0x96	; 150
     a62:	ff 4f       	sbci	r31, 0xFF	; 255
     a64:	90 81       	ld	r25, Z
     a66:	9f 83       	std	Y+7, r25	; 0x07
     a68:	a1 81       	ldd	r26, Z+1	; 0x01
     a6a:	a8 87       	std	Y+8, r26	; 0x08
     a6c:	b2 81       	ldd	r27, Z+2	; 0x02
     a6e:	b9 87       	std	Y+9, r27	; 0x09
     a70:	83 81       	ldd	r24, Z+3	; 0x03
     a72:	8a 87       	std	Y+10, r24	; 0x0a

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
     a74:	24 2d       	mov	r18, r4
     a76:	35 2d       	mov	r19, r5
     a78:	46 2d       	mov	r20, r6
     a7a:	57 2d       	mov	r21, r7
     a7c:	61 2f       	mov	r22, r17
     a7e:	70 2f       	mov	r23, r16
     a80:	89 81       	ldd	r24, Y+1	; 0x01
     a82:	9a 81       	ldd	r25, Y+2	; 0x02
     a84:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
     a88:	88 23       	and	r24, r24
     a8a:	bc f0       	brlt	.+46     	; 0xaba <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf+0x1be>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
     a8c:	24 2d       	mov	r18, r4
     a8e:	35 2d       	mov	r19, r5
     a90:	46 2d       	mov	r20, r6
     a92:	57 2d       	mov	r21, r7
     a94:	6f 81       	ldd	r22, Y+7	; 0x07
     a96:	78 85       	ldd	r23, Y+8	; 0x08
     a98:	89 85       	ldd	r24, Y+9	; 0x09
     a9a:	9a 85       	ldd	r25, Y+10	; 0x0a
     a9c:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
     aa0:	18 16       	cp	r1, r24
     aa2:	2c f0       	brlt	.+10     	; 0xaae <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf+0x1b2>
     aa4:	14 2d       	mov	r17, r4
     aa6:	05 2d       	mov	r16, r5
     aa8:	69 82       	std	Y+1, r6	; 0x01
     aaa:	7a 82       	std	Y+2, r7	; 0x02
     aac:	06 c0       	rjmp	.+12     	; 0xaba <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf+0x1be>
	{
		controlValueToAdjust = minServoControlValue;
     aae:	1f 81       	ldd	r17, Y+7	; 0x07
     ab0:	08 85       	ldd	r16, Y+8	; 0x08
     ab2:	99 85       	ldd	r25, Y+9	; 0x09
     ab4:	99 83       	std	Y+1, r25	; 0x01
     ab6:	aa 85       	ldd	r26, Y+10	; 0x0a
     ab8:	aa 83       	std	Y+2, r26	; 0x02
			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}
     aba:	b6 e8       	ldi	r27, 0x86	; 134
     abc:	2b 0e       	add	r2, r27
     abe:	31 1c       	adc	r3, r1
     ac0:	81 2f       	mov	r24, r17
     ac2:	90 2f       	mov	r25, r16
     ac4:	a9 81       	ldd	r26, Y+1	; 0x01
     ac6:	ba 81       	ldd	r27, Y+2	; 0x02
     ac8:	f1 01       	movw	r30, r2
     aca:	80 83       	st	Z, r24
     acc:	91 83       	std	Z+1, r25	; 0x01
     ace:	a2 83       	std	Z+2, r26	; 0x02
     ad0:	b3 83       	std	Z+3, r27	; 0x03
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
	float mainRotorControl = adjustControlForServoLimits(mainRotorControlBeforeServoLimitsAdjustment, minMainRotorServoControlValue, maxMainRotorServoControlValue);
	
	model->MainRotorCollectiveControl(mainRotorControl);
	model->MainRotorControlBeforeServoLimitsAdjustment(mainRotorControlBeforeServoLimitsAdjustment);
     ad2:	ab 85       	ldd	r26, Y+11	; 0x0b
     ad4:	bc 85       	ldd	r27, Y+12	; 0x0c
     ad6:	ed 91       	ld	r30, X+
     ad8:	fc 91       	ld	r31, X

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}
     ada:	e6 57       	subi	r30, 0x76	; 118
     adc:	ff 4f       	sbci	r31, 0xFF	; 255
     ade:	84 2d       	mov	r24, r4
     ae0:	95 2d       	mov	r25, r5
     ae2:	a6 2d       	mov	r26, r6
     ae4:	b7 2d       	mov	r27, r7
     ae6:	80 83       	st	Z, r24
     ae8:	91 83       	std	Z+1, r25	; 0x01
     aea:	a2 83       	std	Z+2, r26	; 0x02
     aec:	b3 83       	std	Z+3, r27	; 0x03
	model->ZIntegral(weightedZIntegral);
     aee:	ab 85       	ldd	r26, Y+11	; 0x0b
     af0:	bc 85       	ldd	r27, Y+12	; 0x0c
     af2:	ed 91       	ld	r30, X+
     af4:	fc 91       	ld	r31, X

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
			void ZIntegral(float val) { zIntegral = val;}
     af6:	ea 56       	subi	r30, 0x6A	; 106
     af8:	ff 4f       	sbci	r31, 0xFF	; 255
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	ad 81       	ldd	r26, Y+5	; 0x05
     b00:	be 81       	ldd	r27, Y+6	; 0x06
     b02:	80 83       	st	Z, r24
     b04:	91 83       	std	Z+1, r25	; 0x01
     b06:	a2 83       	std	Z+2, r26	; 0x02
     b08:	b3 83       	std	Z+3, r27	; 0x03
	model->ZProportional(zProportional);
     b0a:	ab 85       	ldd	r26, Y+11	; 0x0b
     b0c:	bc 85       	ldd	r27, Y+12	; 0x0c
     b0e:	ed 91       	ld	r30, X+
     b10:	fc 91       	ld	r31, X
     b12:	11 97       	sbiw	r26, 0x01	; 1

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}
     b14:	e6 56       	subi	r30, 0x66	; 102
     b16:	ff 4f       	sbci	r31, 0xFF	; 255
     b18:	80 82       	st	Z, r8
     b1a:	91 82       	std	Z+1, r9	; 0x01
     b1c:	a2 82       	std	Z+2, r10	; 0x02
     b1e:	b3 82       	std	Z+3, r11	; 0x03
	model->ZDerivativeError(zDerivativeError);
     b20:	ed 91       	ld	r30, X+
     b22:	fc 91       	ld	r31, X

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
     b24:	e2 56       	subi	r30, 0x62	; 98
     b26:	ff 4f       	sbci	r31, 0xFF	; 255
     b28:	c0 82       	st	Z, r12
     b2a:	d1 82       	std	Z+1, r13	; 0x01
     b2c:	e2 82       	std	Z+2, r14	; 0x02
     b2e:	f3 82       	std	Z+3, r15	; 0x03
}
     b30:	2c 96       	adiw	r28, 0x0c	; 12
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	f8 94       	cli
     b36:	de bf       	out	0x3e, r29	; 62
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	cd bf       	out	0x3d, r28	; 61
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	ff 90       	pop	r15
     b46:	ef 90       	pop	r14
     b48:	df 90       	pop	r13
     b4a:	cf 90       	pop	r12
     b4c:	bf 90       	pop	r11
     b4e:	af 90       	pop	r10
     b50:	9f 90       	pop	r9
     b52:	8f 90       	pop	r8
     b54:	7f 90       	pop	r7
     b56:	6f 90       	pop	r6
     b58:	5f 90       	pop	r5
     b5a:	4f 90       	pop	r4
     b5c:	3f 90       	pop	r3
     b5e:	2f 90       	pop	r2
     b60:	08 95       	ret

00000b62 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>:

void PIDController::cyclicLongitudeOuterLoopUpdate(float xProportional)
{
     b62:	2f 92       	push	r2
     b64:	3f 92       	push	r3
     b66:	4f 92       	push	r4
     b68:	5f 92       	push	r5
     b6a:	6f 92       	push	r6
     b6c:	7f 92       	push	r7
     b6e:	8f 92       	push	r8
     b70:	9f 92       	push	r9
     b72:	af 92       	push	r10
     b74:	bf 92       	push	r11
     b76:	cf 92       	push	r12
     b78:	df 92       	push	r13
     b7a:	ef 92       	push	r14
     b7c:	ff 92       	push	r15
     b7e:	0f 93       	push	r16
     b80:	1f 93       	push	r17
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
     b8a:	2c 97       	sbiw	r28, 0x0c	; 12
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	de bf       	out	0x3e, r29	; 62
     b92:	0f be       	out	0x3f, r0	; 63
     b94:	cd bf       	out	0x3d, r28	; 61
     b96:	9c 87       	std	Y+12, r25	; 0x0c
     b98:	8b 87       	std	Y+11, r24	; 0x0b
     b9a:	4a 01       	movw	r8, r20
     b9c:	5b 01       	movw	r10, r22
	//float xProportional = calculateProportional(model->XNEDLocalFrame(), model->ReferenceXNEDLocalFrame());
	float xIntegralAntiWindup = calculateIntegralAntiWindup(model->LongitudeControlBeforeServoLimitsAdjustment(), model->LongitudeControl(), xAntiWindupGain);
     b9e:	dc 01       	movw	r26, r24
     ba0:	2d 90       	ld	r2, X+
     ba2:	3c 90       	ld	r3, X
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
     ba4:	81 01       	movw	r16, r2
     ba6:	0e 5b       	subi	r16, 0xBE	; 190
     ba8:	1f 4f       	sbci	r17, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     baa:	f1 01       	movw	r30, r2
     bac:	22 a5       	ldd	r18, Z+42	; 0x2a
     bae:	33 a5       	ldd	r19, Z+43	; 0x2b
     bb0:	44 a5       	ldd	r20, Z+44	; 0x2c
     bb2:	55 a5       	ldd	r21, Z+45	; 0x2d
     bb4:	66 a5       	ldd	r22, Z+46	; 0x2e
     bb6:	77 a5       	ldd	r23, Z+47	; 0x2f
     bb8:	80 a9       	ldd	r24, Z+48	; 0x30
     bba:	91 a9       	ldd	r25, Z+49	; 0x31
     bbc:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     bc0:	ab 85       	ldd	r26, Y+11	; 0x0b
     bc2:	bc 85       	ldd	r27, Y+12	; 0x0c
     bc4:	5e 96       	adiw	r26, 0x1e	; 30
     bc6:	2d 91       	ld	r18, X+
     bc8:	3d 91       	ld	r19, X+
     bca:	4d 91       	ld	r20, X+
     bcc:	5c 91       	ld	r21, X
     bce:	91 97       	sbiw	r26, 0x21	; 33
     bd0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     bd4:	6b 01       	movw	r12, r22
     bd6:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     bd8:	eb 85       	ldd	r30, Y+11	; 0x0b
     bda:	fc 85       	ldd	r31, Y+12	; 0x0c
     bdc:	22 89       	ldd	r18, Z+18	; 0x12
     bde:	33 89       	ldd	r19, Z+19	; 0x13
     be0:	44 89       	ldd	r20, Z+20	; 0x14
     be2:	55 89       	ldd	r21, Z+21	; 0x15
     be4:	c5 01       	movw	r24, r10
     be6:	b4 01       	movw	r22, r8
     be8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     bec:	9b 01       	movw	r18, r22
     bee:	ac 01       	movw	r20, r24
     bf0:	c7 01       	movw	r24, r14
     bf2:	b6 01       	movw	r22, r12
     bf4:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     bf8:	eb 85       	ldd	r30, Y+11	; 0x0b
     bfa:	fc 85       	ldd	r31, Y+12	; 0x0c
     bfc:	ee 57       	subi	r30, 0x7E	; 126
     bfe:	ff 4f       	sbci	r31, 0xFF	; 255
     c00:	20 81       	ld	r18, Z
     c02:	31 81       	ldd	r19, Z+1	; 0x01
     c04:	42 81       	ldd	r20, Z+2	; 0x02
     c06:	53 81       	ldd	r21, Z+3	; 0x03
     c08:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     c0c:	d8 01       	movw	r26, r16
     c0e:	2d 91       	ld	r18, X+
     c10:	3d 91       	ld	r19, X+
     c12:	4d 91       	ld	r20, X+
     c14:	5c 91       	ld	r21, X
     c16:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     c1a:	69 83       	std	Y+1, r22	; 0x01
     c1c:	7a 83       	std	Y+2, r23	; 0x02
     c1e:	8b 83       	std	Y+3, r24	; 0x03
     c20:	9c 83       	std	Y+4, r25	; 0x04
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     c22:	f1 01       	movw	r30, r2
     c24:	26 a9       	ldd	r18, Z+54	; 0x36
     c26:	37 a9       	ldd	r19, Z+55	; 0x37
     c28:	40 ad       	ldd	r20, Z+56	; 0x38
     c2a:	51 ad       	ldd	r21, Z+57	; 0x39
     c2c:	62 a9       	ldd	r22, Z+50	; 0x32
     c2e:	73 a9       	ldd	r23, Z+51	; 0x33
     c30:	84 a9       	ldd	r24, Z+52	; 0x34
     c32:	95 a9       	ldd	r25, Z+53	; 0x35
     c34:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     c38:	6b 01       	movw	r12, r22
     c3a:	7c 01       	movw	r14, r24

float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     c3c:	ab 85       	ldd	r26, Y+11	; 0x0b
     c3e:	bc 85       	ldd	r27, Y+12	; 0x0c
     c40:	5a 96       	adiw	r26, 0x1a	; 26
     c42:	2d 91       	ld	r18, X+
     c44:	3d 91       	ld	r19, X+
     c46:	4d 91       	ld	r20, X+
     c48:	5c 91       	ld	r21, X
     c4a:	5d 97       	sbiw	r26, 0x1d	; 29
     c4c:	c5 01       	movw	r24, r10
     c4e:	b4 01       	movw	r22, r8
     c50:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     c54:	9b 01       	movw	r18, r22
     c56:	ac 01       	movw	r20, r24
     c58:	69 81       	ldd	r22, Y+1	; 0x01
     c5a:	7a 81       	ldd	r23, Y+2	; 0x02
     c5c:	8b 81       	ldd	r24, Y+3	; 0x03
     c5e:	9c 81       	ldd	r25, Y+4	; 0x04
     c60:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     c64:	2b 01       	movw	r4, r22
     c66:	3c 01       	movw	r6, r24
     c68:	eb 85       	ldd	r30, Y+11	; 0x0b
     c6a:	fc 85       	ldd	r31, Y+12	; 0x0c
     c6c:	26 89       	ldd	r18, Z+22	; 0x16
     c6e:	37 89       	ldd	r19, Z+23	; 0x17
     c70:	40 8d       	ldd	r20, Z+24	; 0x18
     c72:	51 8d       	ldd	r21, Z+25	; 0x19
     c74:	c7 01       	movw	r24, r14
     c76:	b6 01       	movw	r22, r12
     c78:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     c7c:	9b 01       	movw	r18, r22
     c7e:	ac 01       	movw	r20, r24
     c80:	c3 01       	movw	r24, r6
     c82:	b2 01       	movw	r22, r4
     c84:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     c88:	16 2f       	mov	r17, r22
     c8a:	07 2f       	mov	r16, r23
     c8c:	8d 83       	std	Y+5, r24	; 0x05
     c8e:	9e 83       	std	Y+6, r25	; 0x06
	float xDerivativeError = calculateVelocityError(model->XVelocityFRDCms(), model->ReferenceXVelocityCms());
	float xLongitudinalOuterLoopSetpoint = calculateOuterLoopControlValue(xProportional, xDerivativeError, weightedXIntegral, xProportionalGain, xDerivativeGain, 1);

	
	
	xLongitudinalOuterLoopSetpoint = adjustForSetpointLimits(xLongitudinalOuterLoopSetpoint, minPitchSetpointRads, maxPitchSetpointRads);
     c90:	eb 85       	ldd	r30, Y+11	; 0x0b
     c92:	fc 85       	ldd	r31, Y+12	; 0x0c
     c94:	ea 58       	subi	r30, 0x8A	; 138
     c96:	ff 4f       	sbci	r31, 0xFF	; 255
     c98:	80 81       	ld	r24, Z
     c9a:	8f 83       	std	Y+7, r24	; 0x07
     c9c:	91 81       	ldd	r25, Z+1	; 0x01
     c9e:	98 87       	std	Y+8, r25	; 0x08
     ca0:	a2 81       	ldd	r26, Z+2	; 0x02
     ca2:	a9 87       	std	Y+9, r26	; 0x09
     ca4:	b3 81       	ldd	r27, Z+3	; 0x03
     ca6:	ba 87       	std	Y+10, r27	; 0x0a
     ca8:	eb 85       	ldd	r30, Y+11	; 0x0b
     caa:	fc 85       	ldd	r31, Y+12	; 0x0c
     cac:	ee 58       	subi	r30, 0x8E	; 142
     cae:	ff 4f       	sbci	r31, 0xFF	; 255
     cb0:	40 80       	ld	r4, Z
     cb2:	51 80       	ldd	r5, Z+1	; 0x01
     cb4:	62 80       	ldd	r6, Z+2	; 0x02
     cb6:	73 80       	ldd	r7, Z+3	; 0x03
}


float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
	if (outerLoopControlSetpoint < minSetpointLimitRads)
     cb8:	21 2f       	mov	r18, r17
     cba:	30 2f       	mov	r19, r16
     cbc:	4d 81       	ldd	r20, Y+5	; 0x05
     cbe:	5e 81       	ldd	r21, Y+6	; 0x06
     cc0:	64 2d       	mov	r22, r4
     cc2:	75 2d       	mov	r23, r5
     cc4:	86 2d       	mov	r24, r6
     cc6:	97 2d       	mov	r25, r7
     cc8:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
     ccc:	18 16       	cp	r1, r24
     cce:	ac f0       	brlt	.+42     	; 0xcfa <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf+0x198>
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
     cd0:	21 2f       	mov	r18, r17
     cd2:	30 2f       	mov	r19, r16
     cd4:	4d 81       	ldd	r20, Y+5	; 0x05
     cd6:	5e 81       	ldd	r21, Y+6	; 0x06
     cd8:	6f 81       	ldd	r22, Y+7	; 0x07
     cda:	78 85       	ldd	r23, Y+8	; 0x08
     cdc:	89 85       	ldd	r24, Y+9	; 0x09
     cde:	9a 85       	ldd	r25, Y+10	; 0x0a
     ce0:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
     ce4:	88 23       	and	r24, r24
     ce6:	2c f0       	brlt	.+10     	; 0xcf2 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf+0x190>
     ce8:	41 2e       	mov	r4, r17
     cea:	50 2e       	mov	r5, r16
     cec:	6d 80       	ldd	r6, Y+5	; 0x05
     cee:	7e 80       	ldd	r7, Y+6	; 0x06
     cf0:	04 c0       	rjmp	.+8      	; 0xcfa <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf+0x198>
	{
		outerLoopControlSetpoint = maxSetpointLimitRads;
     cf2:	4f 80       	ldd	r4, Y+7	; 0x07
     cf4:	58 84       	ldd	r5, Y+8	; 0x08
     cf6:	69 84       	ldd	r6, Y+9	; 0x09
     cf8:	7a 84       	ldd	r7, Y+10	; 0x0a
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
     cfa:	84 2d       	mov	r24, r4
     cfc:	95 2d       	mov	r25, r5
     cfe:	a6 2d       	mov	r26, r6
     d00:	b7 2d       	mov	r27, r7
     d02:	f1 01       	movw	r30, r2
     d04:	82 af       	std	Z+58, r24	; 0x3a
     d06:	93 af       	std	Z+59, r25	; 0x3b
     d08:	a4 af       	std	Z+60, r26	; 0x3c
     d0a:	b5 af       	std	Z+61, r27	; 0x3d
	
	
	xLongitudinalOuterLoopSetpoint = adjustForSetpointLimits(xLongitudinalOuterLoopSetpoint, minPitchSetpointRads, maxPitchSetpointRads);

	model->XLongitudeOuterLoopSetpoint(xLongitudinalOuterLoopSetpoint);
	model->XIntegral(weightedXIntegral);
     d0c:	ab 85       	ldd	r26, Y+11	; 0x0b
     d0e:	bc 85       	ldd	r27, Y+12	; 0x0c
     d10:	ed 91       	ld	r30, X+
     d12:	fc 91       	ld	r31, X
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
     d14:	ee 5b       	subi	r30, 0xBE	; 190
     d16:	ff 4f       	sbci	r31, 0xFF	; 255
     d18:	89 81       	ldd	r24, Y+1	; 0x01
     d1a:	9a 81       	ldd	r25, Y+2	; 0x02
     d1c:	ab 81       	ldd	r26, Y+3	; 0x03
     d1e:	bc 81       	ldd	r27, Y+4	; 0x04
     d20:	80 83       	st	Z, r24
     d22:	91 83       	std	Z+1, r25	; 0x01
     d24:	a2 83       	std	Z+2, r26	; 0x02
     d26:	b3 83       	std	Z+3, r27	; 0x03
	model->XProportional(xProportional);
     d28:	ab 85       	ldd	r26, Y+11	; 0x0b
     d2a:	bc 85       	ldd	r27, Y+12	; 0x0c
     d2c:	ed 91       	ld	r30, X+
     d2e:	fc 91       	ld	r31, X
     d30:	11 97       	sbiw	r26, 0x01	; 1
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
     d32:	fe 96       	adiw	r30, 0x3e	; 62
     d34:	80 82       	st	Z, r8
     d36:	91 82       	std	Z+1, r9	; 0x01
     d38:	a2 82       	std	Z+2, r10	; 0x02
     d3a:	b3 82       	std	Z+3, r11	; 0x03
	model->XDerivativeError(xDerivativeError);
     d3c:	ed 91       	ld	r30, X+
     d3e:	fc 91       	ld	r31, X
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
			void XDerivativeError(float val) { xDerivativeError = val;}
     d40:	ea 5b       	subi	r30, 0xBA	; 186
     d42:	ff 4f       	sbci	r31, 0xFF	; 255
     d44:	c0 82       	st	Z, r12
     d46:	d1 82       	std	Z+1, r13	; 0x01
     d48:	e2 82       	std	Z+2, r14	; 0x02
     d4a:	f3 82       	std	Z+3, r15	; 0x03
}
     d4c:	2c 96       	adiw	r28, 0x0c	; 12
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	df 91       	pop	r29
     d5a:	cf 91       	pop	r28
     d5c:	1f 91       	pop	r17
     d5e:	0f 91       	pop	r16
     d60:	ff 90       	pop	r15
     d62:	ef 90       	pop	r14
     d64:	df 90       	pop	r13
     d66:	cf 90       	pop	r12
     d68:	bf 90       	pop	r11
     d6a:	af 90       	pop	r10
     d6c:	9f 90       	pop	r9
     d6e:	8f 90       	pop	r8
     d70:	7f 90       	pop	r7
     d72:	6f 90       	pop	r6
     d74:	5f 90       	pop	r5
     d76:	4f 90       	pop	r4
     d78:	3f 90       	pop	r3
     d7a:	2f 90       	pop	r2
     d7c:	08 95       	ret

00000d7e <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>:

void PIDController::cyclicLateralOuterLoopUpdate(float yProportional)
{
     d7e:	2f 92       	push	r2
     d80:	3f 92       	push	r3
     d82:	4f 92       	push	r4
     d84:	5f 92       	push	r5
     d86:	6f 92       	push	r6
     d88:	7f 92       	push	r7
     d8a:	8f 92       	push	r8
     d8c:	9f 92       	push	r9
     d8e:	af 92       	push	r10
     d90:	bf 92       	push	r11
     d92:	cf 92       	push	r12
     d94:	df 92       	push	r13
     d96:	ef 92       	push	r14
     d98:	ff 92       	push	r15
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
     da6:	2c 97       	sbiw	r28, 0x0c	; 12
     da8:	0f b6       	in	r0, 0x3f	; 63
     daa:	f8 94       	cli
     dac:	de bf       	out	0x3e, r29	; 62
     dae:	0f be       	out	0x3f, r0	; 63
     db0:	cd bf       	out	0x3d, r28	; 61
     db2:	9c 87       	std	Y+12, r25	; 0x0c
     db4:	8b 87       	std	Y+11, r24	; 0x0b
     db6:	6a 01       	movw	r12, r20
     db8:	7b 01       	movw	r14, r22
	//float yProportional = calculateProportional(model->YNEDLocalFrame(), model->ReferenceYNEDLocalFrame());
	float yIntegralAntiWindup = calculateIntegralAntiWindup(model->LateralControlBeforeServoLimitsAdjustment(), model->LateralControl(), yAntiWindupGain);
     dba:	dc 01       	movw	r26, r24
     dbc:	0d 91       	ld	r16, X+
     dbe:	1c 91       	ld	r17, X
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
     dc0:	38 01       	movw	r6, r16
     dc2:	be e6       	ldi	r27, 0x6E	; 110
     dc4:	6b 0e       	add	r6, r27
     dc6:	71 1c       	adc	r7, r1
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
     dc8:	f8 01       	movw	r30, r16
     dca:	e6 5a       	subi	r30, 0xA6	; 166
     dcc:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
     dce:	d8 01       	movw	r26, r16
     dd0:	aa 5a       	subi	r26, 0xAA	; 170
     dd2:	bf 4f       	sbci	r27, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     dd4:	2d 91       	ld	r18, X+
     dd6:	3d 91       	ld	r19, X+
     dd8:	4d 91       	ld	r20, X+
     dda:	5c 91       	ld	r21, X
     ddc:	60 81       	ld	r22, Z
     dde:	71 81       	ldd	r23, Z+1	; 0x01
     de0:	82 81       	ldd	r24, Z+2	; 0x02
     de2:	93 81       	ldd	r25, Z+3	; 0x03
     de4:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     de8:	eb 85       	ldd	r30, Y+11	; 0x0b
     dea:	fc 85       	ldd	r31, Y+12	; 0x0c
     dec:	26 a9       	ldd	r18, Z+54	; 0x36
     dee:	37 a9       	ldd	r19, Z+55	; 0x37
     df0:	40 ad       	ldd	r20, Z+56	; 0x38
     df2:	51 ad       	ldd	r21, Z+57	; 0x39
     df4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     df8:	4b 01       	movw	r8, r22
     dfa:	5c 01       	movw	r10, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     dfc:	ab 85       	ldd	r26, Y+11	; 0x0b
     dfe:	bc 85       	ldd	r27, Y+12	; 0x0c
     e00:	9a 96       	adiw	r26, 0x2a	; 42
     e02:	2d 91       	ld	r18, X+
     e04:	3d 91       	ld	r19, X+
     e06:	4d 91       	ld	r20, X+
     e08:	5c 91       	ld	r21, X
     e0a:	9d 97       	sbiw	r26, 0x2d	; 45
     e0c:	c7 01       	movw	r24, r14
     e0e:	b6 01       	movw	r22, r12
     e10:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     e14:	9b 01       	movw	r18, r22
     e16:	ac 01       	movw	r20, r24
     e18:	c5 01       	movw	r24, r10
     e1a:	b4 01       	movw	r22, r8
     e1c:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     e20:	eb 85       	ldd	r30, Y+11	; 0x0b
     e22:	fc 85       	ldd	r31, Y+12	; 0x0c
     e24:	ee 57       	subi	r30, 0x7E	; 126
     e26:	ff 4f       	sbci	r31, 0xFF	; 255
     e28:	20 81       	ld	r18, Z
     e2a:	31 81       	ldd	r19, Z+1	; 0x01
     e2c:	42 81       	ldd	r20, Z+2	; 0x02
     e2e:	53 81       	ldd	r21, Z+3	; 0x03
     e30:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     e34:	f3 01       	movw	r30, r6
     e36:	20 81       	ld	r18, Z
     e38:	31 81       	ldd	r19, Z+1	; 0x01
     e3a:	42 81       	ldd	r20, Z+2	; 0x02
     e3c:	53 81       	ldd	r21, Z+3	; 0x03
     e3e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     e42:	4b 01       	movw	r8, r22
     e44:	5c 01       	movw	r10, r24
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
     e46:	f8 01       	movw	r30, r16
     e48:	e2 5a       	subi	r30, 0xA2	; 162
     e4a:	ff 4f       	sbci	r31, 0xFF	; 255
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
     e4c:	d8 01       	movw	r26, r16
     e4e:	ae 59       	subi	r26, 0x9E	; 158
     e50:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     e52:	2d 91       	ld	r18, X+
     e54:	3d 91       	ld	r19, X+
     e56:	4d 91       	ld	r20, X+
     e58:	5c 91       	ld	r21, X
     e5a:	60 81       	ld	r22, Z
     e5c:	71 81       	ldd	r23, Z+1	; 0x01
     e5e:	82 81       	ldd	r24, Z+2	; 0x02
     e60:	93 81       	ldd	r25, Z+3	; 0x03
     e62:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
     e66:	6d 83       	std	Y+5, r22	; 0x05
     e68:	7e 83       	std	Y+6, r23	; 0x06
     e6a:	8f 83       	std	Y+7, r24	; 0x07
     e6c:	98 87       	std	Y+8, r25	; 0x08

float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     e6e:	ab 85       	ldd	r26, Y+11	; 0x0b
     e70:	bc 85       	ldd	r27, Y+12	; 0x0c
     e72:	d2 96       	adiw	r26, 0x32	; 50
     e74:	2d 91       	ld	r18, X+
     e76:	3d 91       	ld	r19, X+
     e78:	4d 91       	ld	r20, X+
     e7a:	5c 91       	ld	r21, X
     e7c:	d5 97       	sbiw	r26, 0x35	; 53
     e7e:	c7 01       	movw	r24, r14
     e80:	b6 01       	movw	r22, r12
     e82:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     e86:	9b 01       	movw	r18, r22
     e88:	ac 01       	movw	r20, r24
     e8a:	c5 01       	movw	r24, r10
     e8c:	b4 01       	movw	r22, r8
     e8e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     e92:	2b 01       	movw	r4, r22
     e94:	3c 01       	movw	r6, r24
     e96:	eb 85       	ldd	r30, Y+11	; 0x0b
     e98:	fc 85       	ldd	r31, Y+12	; 0x0c
     e9a:	26 a5       	ldd	r18, Z+46	; 0x2e
     e9c:	37 a5       	ldd	r19, Z+47	; 0x2f
     e9e:	40 a9       	ldd	r20, Z+48	; 0x30
     ea0:	51 a9       	ldd	r21, Z+49	; 0x31
     ea2:	6d 81       	ldd	r22, Y+5	; 0x05
     ea4:	7e 81       	ldd	r23, Y+6	; 0x06
     ea6:	8f 81       	ldd	r24, Y+7	; 0x07
     ea8:	98 85       	ldd	r25, Y+8	; 0x08
     eaa:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
     eae:	9b 01       	movw	r18, r22
     eb0:	ac 01       	movw	r20, r24
     eb2:	c3 01       	movw	r24, r6
     eb4:	b2 01       	movw	r22, r4
     eb6:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
     eba:	9b 01       	movw	r18, r22
     ebc:	ac 01       	movw	r20, r24
     ebe:	50 58       	subi	r21, 0x80	; 128
     ec0:	29 83       	std	Y+1, r18	; 0x01
     ec2:	3a 83       	std	Y+2, r19	; 0x02
     ec4:	4b 83       	std	Y+3, r20	; 0x03
     ec6:	5c 83       	std	Y+4, r21	; 0x04
	//the proportional error will correctly be positive (in a North-east-down coordinate system), but the helicopter will have to roll counter clockwise
	//to return to the desired position. This differs from if the helicopter was directly north of the desired position. The x proportional would be positive
	//(in NED), but it would take a positive pitch angle setpoint to get the helicopter to return to the desired position.
	float yLateralOuterLoopSetpoint = calculateOuterLoopControlValue(yProportional, yDerivativeError, weightedYIntegral, yProportionalGain, yDerivativeGain, -1);

	yLateralOuterLoopSetpoint = adjustForSetpointLimits(yLateralOuterLoopSetpoint, minRollSetpointRads, maxRollSetpointRads);
     ec8:	eb 85       	ldd	r30, Y+11	; 0x0b
     eca:	fc 85       	ldd	r31, Y+12	; 0x0c
     ecc:	e2 58       	subi	r30, 0x82	; 130
     ece:	ff 4f       	sbci	r31, 0xFF	; 255
     ed0:	30 80       	ld	r3, Z
     ed2:	21 80       	ldd	r2, Z+1	; 0x01
     ed4:	32 81       	ldd	r19, Z+2	; 0x02
     ed6:	39 87       	std	Y+9, r19	; 0x09
     ed8:	43 81       	ldd	r20, Z+3	; 0x03
     eda:	4a 87       	std	Y+10, r20	; 0x0a
     edc:	eb 85       	ldd	r30, Y+11	; 0x0b
     ede:	fc 85       	ldd	r31, Y+12	; 0x0c
     ee0:	e6 58       	subi	r30, 0x86	; 134
     ee2:	ff 4f       	sbci	r31, 0xFF	; 255
     ee4:	40 80       	ld	r4, Z
     ee6:	51 80       	ldd	r5, Z+1	; 0x01
     ee8:	62 80       	ldd	r6, Z+2	; 0x02
     eea:	73 80       	ldd	r7, Z+3	; 0x03
}


float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
	if (outerLoopControlSetpoint < minSetpointLimitRads)
     eec:	29 81       	ldd	r18, Y+1	; 0x01
     eee:	3a 81       	ldd	r19, Y+2	; 0x02
     ef0:	4b 81       	ldd	r20, Y+3	; 0x03
     ef2:	5c 81       	ldd	r21, Y+4	; 0x04
     ef4:	64 2d       	mov	r22, r4
     ef6:	75 2d       	mov	r23, r5
     ef8:	86 2d       	mov	r24, r6
     efa:	97 2d       	mov	r25, r7
     efc:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
     f00:	18 16       	cp	r1, r24
     f02:	ac f0       	brlt	.+42     	; 0xf2e <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf+0x1b0>
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
     f04:	29 81       	ldd	r18, Y+1	; 0x01
     f06:	3a 81       	ldd	r19, Y+2	; 0x02
     f08:	4b 81       	ldd	r20, Y+3	; 0x03
     f0a:	5c 81       	ldd	r21, Y+4	; 0x04
     f0c:	63 2d       	mov	r22, r3
     f0e:	72 2d       	mov	r23, r2
     f10:	89 85       	ldd	r24, Y+9	; 0x09
     f12:	9a 85       	ldd	r25, Y+10	; 0x0a
     f14:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
     f18:	88 23       	and	r24, r24
     f1a:	2c f0       	brlt	.+10     	; 0xf26 <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf+0x1a8>
     f1c:	49 80       	ldd	r4, Y+1	; 0x01
     f1e:	5a 80       	ldd	r5, Y+2	; 0x02
     f20:	6b 80       	ldd	r6, Y+3	; 0x03
     f22:	7c 80       	ldd	r7, Y+4	; 0x04
     f24:	04 c0       	rjmp	.+8      	; 0xf2e <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf+0x1b0>
	{
		outerLoopControlSetpoint = maxSetpointLimitRads;
     f26:	43 2c       	mov	r4, r3
     f28:	52 2c       	mov	r5, r2
     f2a:	69 84       	ldd	r6, Y+9	; 0x09
     f2c:	7a 84       	ldd	r7, Y+10	; 0x0a
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}
     f2e:	f8 01       	movw	r30, r16
     f30:	ea 59       	subi	r30, 0x9A	; 154
     f32:	ff 4f       	sbci	r31, 0xFF	; 255
     f34:	84 2d       	mov	r24, r4
     f36:	95 2d       	mov	r25, r5
     f38:	a6 2d       	mov	r26, r6
     f3a:	b7 2d       	mov	r27, r7
     f3c:	80 83       	st	Z, r24
     f3e:	91 83       	std	Z+1, r25	; 0x01
     f40:	a2 83       	std	Z+2, r26	; 0x02
     f42:	b3 83       	std	Z+3, r27	; 0x03
	float yLateralOuterLoopSetpoint = calculateOuterLoopControlValue(yProportional, yDerivativeError, weightedYIntegral, yProportionalGain, yDerivativeGain, -1);

	yLateralOuterLoopSetpoint = adjustForSetpointLimits(yLateralOuterLoopSetpoint, minRollSetpointRads, maxRollSetpointRads);
	
	model->YLateralOuterLoopSetpoint(yLateralOuterLoopSetpoint);
	model->YIntegral(weightedYIntegral);
     f44:	ab 85       	ldd	r26, Y+11	; 0x0b
     f46:	bc 85       	ldd	r27, Y+12	; 0x0c
     f48:	ed 91       	ld	r30, X+
     f4a:	fc 91       	ld	r31, X
     f4c:	11 97       	sbiw	r26, 0x01	; 1

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}
     f4e:	e2 59       	subi	r30, 0x92	; 146
     f50:	ff 4f       	sbci	r31, 0xFF	; 255
     f52:	80 82       	st	Z, r8
     f54:	91 82       	std	Z+1, r9	; 0x01
     f56:	a2 82       	std	Z+2, r10	; 0x02
     f58:	b3 82       	std	Z+3, r11	; 0x03
	model->YProportional(yProportional);
     f5a:	ed 91       	ld	r30, X+
     f5c:	fc 91       	ld	r31, X
     f5e:	11 97       	sbiw	r26, 0x01	; 1

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}
     f60:	e6 59       	subi	r30, 0x96	; 150
     f62:	ff 4f       	sbci	r31, 0xFF	; 255
     f64:	c0 82       	st	Z, r12
     f66:	d1 82       	std	Z+1, r13	; 0x01
     f68:	e2 82       	std	Z+2, r14	; 0x02
     f6a:	f3 82       	std	Z+3, r15	; 0x03
	model->YDerivativeError(yDerivativeError);
     f6c:	ed 91       	ld	r30, X+
     f6e:	fc 91       	ld	r31, X

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
			void YDerivativeError(float val) { yDerivativeError = val;}
     f70:	ee 58       	subi	r30, 0x8E	; 142
     f72:	ff 4f       	sbci	r31, 0xFF	; 255
     f74:	2d 81       	ldd	r18, Y+5	; 0x05
     f76:	3e 81       	ldd	r19, Y+6	; 0x06
     f78:	4f 81       	ldd	r20, Y+7	; 0x07
     f7a:	58 85       	ldd	r21, Y+8	; 0x08
     f7c:	20 83       	st	Z, r18
     f7e:	31 83       	std	Z+1, r19	; 0x01
     f80:	42 83       	std	Z+2, r20	; 0x02
     f82:	53 83       	std	Z+3, r21	; 0x03
}
     f84:	2c 96       	adiw	r28, 0x0c	; 12
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	f8 94       	cli
     f8a:	de bf       	out	0x3e, r29	; 62
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	cd bf       	out	0x3d, r28	; 61
     f90:	df 91       	pop	r29
     f92:	cf 91       	pop	r28
     f94:	1f 91       	pop	r17
     f96:	0f 91       	pop	r16
     f98:	ff 90       	pop	r15
     f9a:	ef 90       	pop	r14
     f9c:	df 90       	pop	r13
     f9e:	cf 90       	pop	r12
     fa0:	bf 90       	pop	r11
     fa2:	af 90       	pop	r10
     fa4:	9f 90       	pop	r9
     fa6:	8f 90       	pop	r8
     fa8:	7f 90       	pop	r7
     faa:	6f 90       	pop	r6
     fac:	5f 90       	pop	r5
     fae:	4f 90       	pop	r4
     fb0:	3f 90       	pop	r3
     fb2:	2f 90       	pop	r2
     fb4:	08 95       	ret

00000fb6 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>:




void PIDController::outerLoopUpdate()
{
     fb6:	2f 92       	push	r2
     fb8:	3f 92       	push	r3
     fba:	4f 92       	push	r4
     fbc:	5f 92       	push	r5
     fbe:	6f 92       	push	r6
     fc0:	7f 92       	push	r7
     fc2:	8f 92       	push	r8
     fc4:	9f 92       	push	r9
     fc6:	af 92       	push	r10
     fc8:	bf 92       	push	r11
     fca:	cf 92       	push	r12
     fcc:	df 92       	push	r13
     fce:	ef 92       	push	r14
     fd0:	ff 92       	push	r15
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	68 97       	sbiw	r28, 0x18	; 24
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	8c 01       	movw	r16, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
     fec:	fc 01       	movw	r30, r24
     fee:	20 80       	ld	r2, Z
     ff0:	31 80       	ldd	r3, Z+1	; 0x01
     ff2:	f1 01       	movw	r30, r2
     ff4:	82 81       	ldd	r24, Z+2	; 0x02
     ff6:	81 30       	cpi	r24, 0x01	; 1
     ff8:	09 f0       	breq	.+2      	; 0xffc <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x46>
     ffa:	64 c0       	rjmp	.+200    	; 0x10c4 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x10e>
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
     ffc:	26 a1       	ldd	r18, Z+38	; 0x26
     ffe:	37 a1       	ldd	r19, Z+39	; 0x27
    1000:	40 a5       	ldd	r20, Z+40	; 0x28
    1002:	51 a5       	ldd	r21, Z+41	; 0x29
    1004:	62 a1       	ldd	r22, Z+34	; 0x22
    1006:	73 a1       	ldd	r23, Z+35	; 0x23
    1008:	84 a1       	ldd	r24, Z+36	; 0x24
    100a:	95 a1       	ldd	r25, Z+37	; 0x25
    100c:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1010:	2b 01       	movw	r4, r22
    1012:	3c 01       	movw	r6, r24
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    1014:	f1 01       	movw	r30, r2
    1016:	e2 5b       	subi	r30, 0xB2	; 178
    1018:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    101a:	d1 01       	movw	r26, r2
    101c:	ae 5a       	subi	r26, 0xAE	; 174
    101e:	bf 4f       	sbci	r27, 0xFF	; 255
    1020:	2d 91       	ld	r18, X+
    1022:	3d 91       	ld	r19, X+
    1024:	4d 91       	ld	r20, X+
    1026:	5c 91       	ld	r21, X
    1028:	60 81       	ld	r22, Z
    102a:	71 81       	ldd	r23, Z+1	; 0x01
    102c:	82 81       	ldd	r24, Z+2	; 0x02
    102e:	93 81       	ldd	r25, Z+3	; 0x03
    1030:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1034:	4b 01       	movw	r8, r22
    1036:	5c 01       	movw	r10, r24
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    1038:	f1 01       	movw	r30, r2
    103a:	e2 58       	subi	r30, 0x82	; 130
    103c:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    103e:	d1 01       	movw	r26, r2
    1040:	ae 57       	subi	r26, 0x7E	; 126
    1042:	bf 4f       	sbci	r27, 0xFF	; 255
    1044:	2d 91       	ld	r18, X+
    1046:	3d 91       	ld	r19, X+
    1048:	4d 91       	ld	r20, X+
    104a:	5c 91       	ld	r21, X
    104c:	60 81       	ld	r22, Z
    104e:	71 81       	ldd	r23, Z+1	; 0x01
    1050:	82 81       	ldd	r24, Z+2	; 0x02
    1052:	93 81       	ldd	r25, Z+3	; 0x03
    1054:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1058:	6b 01       	movw	r12, r22
    105a:	7c 01       	movw	r14, r24
		float yErrorNED = calculateProportional(model->YNEDLocalFrameCm(), model->ReferenceYNEDLocalFrameCm());
		float zErrorNED = calculateProportional(model->ZNEDLocalFrameCm(), model->ReferenceZNEDLocalFrameCm());
	
	
		//convert position error from NED to FRD Body frame.
		float bodyFrameErrors[3] = {};
    105c:	ae 01       	movw	r20, r28
    105e:	43 5f       	subi	r20, 0xF3	; 243
    1060:	5f 4f       	sbci	r21, 0xFF	; 255
    1062:	8c e0       	ldi	r24, 0x0C	; 12
    1064:	fa 01       	movw	r30, r20
    1066:	11 92       	st	Z+, r1
    1068:	8a 95       	dec	r24
    106a:	e9 f7       	brne	.-6      	; 0x1066 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0xb0>
		float nedToBodyFrameRotationMatrix[3][3] = {};
		float positionErrorsLocalNED[3] = {xErrorNED, yErrorNED, zErrorNED};
    106c:	49 82       	std	Y+1, r4	; 0x01
    106e:	5a 82       	std	Y+2, r5	; 0x02
    1070:	6b 82       	std	Y+3, r6	; 0x03
    1072:	7c 82       	std	Y+4, r7	; 0x04
    1074:	8d 82       	std	Y+5, r8	; 0x05
    1076:	9e 82       	std	Y+6, r9	; 0x06
    1078:	af 82       	std	Y+7, r10	; 0x07
    107a:	b8 86       	std	Y+8, r11	; 0x08
    107c:	c9 86       	std	Y+9, r12	; 0x09
    107e:	da 86       	std	Y+10, r13	; 0x0a
    1080:	eb 86       	std	Y+11, r14	; 0x0b
    1082:	fc 86       	std	Y+12, r15	; 0x0c
	
		//MatrixUtil::CreateRotationMatrixTransposed(model->RollRads(), model->PitchRads(), model->YawRads(), nedToBodyFrameRotationMatrix);
		//MatrixUtil::RotateMatrix(nedToBodyFrameRotationMatrix, positionErrorsLocalNED, bodyFrameErrors);
	
	
		MatrixUtil::RotateMatrixT(model->Ahrs()->dcm, positionErrorsLocalNED, bodyFrameErrors);
    1084:	f1 01       	movw	r30, r2
    1086:	80 81       	ld	r24, Z
    1088:	91 81       	ldd	r25, Z+1	; 0x01
    108a:	be 01       	movw	r22, r28
    108c:	6f 5f       	subi	r22, 0xFF	; 255
    108e:	7f 4f       	sbci	r23, 0xFF	; 255
    1090:	80 5c       	subi	r24, 0xC0	; 192
    1092:	9f 4f       	sbci	r25, 0xFF	; 255
    1094:	0e 94 bf 64 	call	0xc97e	; 0xc97e <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	

		this->cyclicLongitudeOuterLoopUpdate(bodyFrameErrors[0]);
    1098:	4d 85       	ldd	r20, Y+13	; 0x0d
    109a:	5e 85       	ldd	r21, Y+14	; 0x0e
    109c:	6f 85       	ldd	r22, Y+15	; 0x0f
    109e:	78 89       	ldd	r23, Y+16	; 0x10
    10a0:	c8 01       	movw	r24, r16
    10a2:	0e 94 b1 05 	call	0xb62	; 0xb62 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>
		this->cyclicLateralOuterLoopUpdate(bodyFrameErrors[1]);	
    10a6:	49 89       	ldd	r20, Y+17	; 0x11
    10a8:	5a 89       	ldd	r21, Y+18	; 0x12
    10aa:	6b 89       	ldd	r22, Y+19	; 0x13
    10ac:	7c 89       	ldd	r23, Y+20	; 0x14
    10ae:	c8 01       	movw	r24, r16
    10b0:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>
//		this->mainRotorCollectiveOuterLoopUpdate(bodyFrameErrors[2]);	
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
    10b4:	b7 01       	movw	r22, r14
    10b6:	a6 01       	movw	r20, r12
    10b8:	c8 01       	movw	r24, r16
    10ba:	0e 94 7e 04 	call	0x8fc	; 0x8fc <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>
		this->tailRotorCollectiveOuterLoopUpdate();
    10be:	c8 01       	movw	r24, r16
    10c0:	0e 94 33 03 	call	0x666	; 0x666 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>
		this->cyclicLongitudeOuterLoopUpdate(xErrorNED);
		this->cyclicLateralOuterLoopUpdate(yErrorNED);
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
		this->tailRotorCollectiveOuterLoopUpdate();*/
	}
}
    10c4:	68 96       	adiw	r28, 0x18	; 24
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	de bf       	out	0x3e, r29	; 62
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	cd bf       	out	0x3d, r28	; 61
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	1f 91       	pop	r17
    10d6:	0f 91       	pop	r16
    10d8:	ff 90       	pop	r15
    10da:	ef 90       	pop	r14
    10dc:	df 90       	pop	r13
    10de:	cf 90       	pop	r12
    10e0:	bf 90       	pop	r11
    10e2:	af 90       	pop	r10
    10e4:	9f 90       	pop	r9
    10e6:	8f 90       	pop	r8
    10e8:	7f 90       	pop	r7
    10ea:	6f 90       	pop	r6
    10ec:	5f 90       	pop	r5
    10ee:	4f 90       	pop	r4
    10f0:	3f 90       	pop	r3
    10f2:	2f 90       	pop	r2
    10f4:	08 95       	ret

000010f6 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>:
	model->YProportional(yProportional);
	model->YDerivativeError(yDerivativeError);
}

void PIDController::cyclicLongitudeInnerLoopUpdate()
{
    10f6:	4f 92       	push	r4
    10f8:	5f 92       	push	r5
    10fa:	6f 92       	push	r6
    10fc:	7f 92       	push	r7
    10fe:	8f 92       	push	r8
    1100:	9f 92       	push	r9
    1102:	af 92       	push	r10
    1104:	bf 92       	push	r11
    1106:	cf 92       	push	r12
    1108:	df 92       	push	r13
    110a:	ef 92       	push	r14
    110c:	ff 92       	push	r15
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1118:	08 81       	ld	r16, Y
    111a:	19 81       	ldd	r17, Y+1	; 0x01
    111c:	f8 01       	movw	r30, r16
    111e:	82 81       	ldd	r24, Z+2	; 0x02
    1120:	81 30       	cpi	r24, 0x01	; 1
    1122:	09 f0       	breq	.+2      	; 0x1126 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0x30>
    1124:	6a c0       	rjmp	.+212    	; 0x11fa <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0x104>
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    1126:	ee 52       	subi	r30, 0x2E	; 46
    1128:	ff 4f       	sbci	r31, 0xFF	; 255
}


float calculateInnerLoopControlValue( float outerLoopSetpoint, float measuredValue, float gain, float angularVelocity, float angularVelocityGain )
{
	return (gain * (outerLoopSetpoint - measuredValue)) - (angularVelocity * angularVelocityGain);
    112a:	20 81       	ld	r18, Z
    112c:	31 81       	ldd	r19, Z+1	; 0x01
    112e:	42 81       	ldd	r20, Z+2	; 0x02
    1130:	53 81       	ldd	r21, Z+3	; 0x03
    1132:	f8 01       	movw	r30, r16
    1134:	62 ad       	ldd	r22, Z+58	; 0x3a
    1136:	73 ad       	ldd	r23, Z+59	; 0x3b
    1138:	84 ad       	ldd	r24, Z+60	; 0x3c
    113a:	95 ad       	ldd	r25, Z+61	; 0x3d
    113c:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1140:	2a a1       	ldd	r18, Y+34	; 0x22
    1142:	3b a1       	ldd	r19, Y+35	; 0x23
    1144:	4c a1       	ldd	r20, Y+36	; 0x24
    1146:	5d a1       	ldd	r21, Y+37	; 0x25
    1148:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    114c:	6b 01       	movw	r12, r22
    114e:	7c 01       	movw	r14, r24
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    1150:	f8 01       	movw	r30, r16
    1152:	e6 52       	subi	r30, 0x26	; 38
    1154:	ff 4f       	sbci	r31, 0xFF	; 255
    1156:	20 81       	ld	r18, Z
    1158:	31 81       	ldd	r19, Z+1	; 0x01
    115a:	42 81       	ldd	r20, Z+2	; 0x02
    115c:	53 81       	ldd	r21, Z+3	; 0x03
    115e:	6e a1       	ldd	r22, Y+38	; 0x26
    1160:	7f a1       	ldd	r23, Y+39	; 0x27
    1162:	88 a5       	ldd	r24, Y+40	; 0x28
    1164:	99 a5       	ldd	r25, Y+41	; 0x29
    1166:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    116a:	9b 01       	movw	r18, r22
    116c:	ac 01       	movw	r20, r24
    116e:	c7 01       	movw	r24, r14
    1170:	b6 01       	movw	r22, r12
    1172:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1176:	86 2e       	mov	r8, r22
    1178:	97 2e       	mov	r9, r23
    117a:	a8 2e       	mov	r10, r24
    117c:	b9 2e       	mov	r11, r25
{
	if (model->OperationalState() == SystemModel::AutoPilot)
	{
		float xLongitudinalInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->XLongitudeOuterLoopSetpoint(), model->PitchRads(), longitudeInnerLoopGain, model->PitchAngularVelocityRadsPerSecond(), pitchAngularVelocityGain);
		
		float xLongitudinalInnerLoopControl = adjustControlForServoLimits(xLongitudinalInnerLoopControlBeforeServoLimits, minLongitudeServoControlValue, maxLongitudeServoControlValue);
    117e:	fe 01       	movw	r30, r28
    1180:	e2 5a       	subi	r30, 0xA2	; 162
    1182:	ff 4f       	sbci	r31, 0xFF	; 255
    1184:	c0 80       	ld	r12, Z
    1186:	d1 80       	ldd	r13, Z+1	; 0x01
    1188:	e2 80       	ldd	r14, Z+2	; 0x02
    118a:	f3 80       	ldd	r15, Z+3	; 0x03
    118c:	34 97       	sbiw	r30, 0x04	; 4
    118e:	40 80       	ld	r4, Z
    1190:	51 80       	ldd	r5, Z+1	; 0x01
    1192:	62 80       	ldd	r6, Z+2	; 0x02
    1194:	73 80       	ldd	r7, Z+3	; 0x03

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
    1196:	26 2f       	mov	r18, r22
    1198:	37 2f       	mov	r19, r23
    119a:	48 2f       	mov	r20, r24
    119c:	59 2f       	mov	r21, r25
    119e:	c7 01       	movw	r24, r14
    11a0:	b6 01       	movw	r22, r12
    11a2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    11a6:	88 23       	and	r24, r24
    11a8:	ac f0       	brlt	.+42     	; 0x11d4 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0xde>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
    11aa:	28 2d       	mov	r18, r8
    11ac:	39 2d       	mov	r19, r9
    11ae:	4a 2d       	mov	r20, r10
    11b0:	5b 2d       	mov	r21, r11
    11b2:	64 2d       	mov	r22, r4
    11b4:	75 2d       	mov	r23, r5
    11b6:	86 2d       	mov	r24, r6
    11b8:	97 2d       	mov	r25, r7
    11ba:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    11be:	18 16       	cp	r1, r24
    11c0:	2c f0       	brlt	.+10     	; 0x11cc <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0xd6>
    11c2:	c8 2c       	mov	r12, r8
    11c4:	d9 2c       	mov	r13, r9
    11c6:	ea 2c       	mov	r14, r10
    11c8:	fb 2c       	mov	r15, r11
    11ca:	04 c0       	rjmp	.+8      	; 0x11d4 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0xde>
	{
		controlValueToAdjust = minServoControlValue;
    11cc:	c4 2c       	mov	r12, r4
    11ce:	d5 2c       	mov	r13, r5
    11d0:	e6 2c       	mov	r14, r6
    11d2:	f7 2c       	mov	r15, r7
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}
    11d4:	48 2d       	mov	r20, r8
    11d6:	59 2d       	mov	r21, r9
    11d8:	6a 2d       	mov	r22, r10
    11da:	7b 2d       	mov	r23, r11
    11dc:	f8 01       	movw	r30, r16
    11de:	42 a7       	std	Z+42, r20	; 0x2a
    11e0:	53 a7       	std	Z+43, r21	; 0x2b
    11e2:	64 a7       	std	Z+44, r22	; 0x2c
    11e4:	75 a7       	std	Z+45, r23	; 0x2d
		model->LongitudeControlBeforeServoLimitsAdjustment(xLongitudinalInnerLoopControlBeforeServoLimits);
	
//		model->LongitudeControl(xLongitudinalInnerLoopControl);

		//Multiply by -1 because in the simulator, a control value of +1 results in the helicopter pitching up, but the real helicopter pitches down.
		model->LongitudeControl(xLongitudinalInnerLoopControl * -1);
    11e6:	e8 81       	ld	r30, Y
    11e8:	f9 81       	ldd	r31, Y+1	; 0x01
    11ea:	f7 fa       	bst	r15, 7
    11ec:	f0 94       	com	r15
    11ee:	f7 f8       	bld	r15, 7
    11f0:	f0 94       	com	r15

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
    11f2:	c6 a6       	std	Z+46, r12	; 0x2e
    11f4:	d7 a6       	std	Z+47, r13	; 0x2f
    11f6:	e0 aa       	std	Z+48, r14	; 0x30
    11f8:	f1 aa       	std	Z+49, r15	; 0x31
	}
}
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	1f 91       	pop	r17
    1200:	0f 91       	pop	r16
    1202:	ff 90       	pop	r15
    1204:	ef 90       	pop	r14
    1206:	df 90       	pop	r13
    1208:	cf 90       	pop	r12
    120a:	bf 90       	pop	r11
    120c:	af 90       	pop	r10
    120e:	9f 90       	pop	r9
    1210:	8f 90       	pop	r8
    1212:	7f 90       	pop	r7
    1214:	6f 90       	pop	r6
    1216:	5f 90       	pop	r5
    1218:	4f 90       	pop	r4
    121a:	08 95       	ret

0000121c <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>:

void PIDController::cyclicLateralInnerLoopUpdate()
{
    121c:	4f 92       	push	r4
    121e:	5f 92       	push	r5
    1220:	6f 92       	push	r6
    1222:	7f 92       	push	r7
    1224:	8f 92       	push	r8
    1226:	9f 92       	push	r9
    1228:	af 92       	push	r10
    122a:	bf 92       	push	r11
    122c:	cf 92       	push	r12
    122e:	df 92       	push	r13
    1230:	ef 92       	push	r14
    1232:	ff 92       	push	r15
    1234:	0f 93       	push	r16
    1236:	1f 93       	push	r17
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
    123c:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    123e:	08 81       	ld	r16, Y
    1240:	19 81       	ldd	r17, Y+1	; 0x01
    1242:	f8 01       	movw	r30, r16
    1244:	82 81       	ldd	r24, Z+2	; 0x02
    1246:	81 30       	cpi	r24, 0x01	; 1
    1248:	09 f0       	breq	.+2      	; 0x124c <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0x30>
    124a:	73 c0       	rjmp	.+230    	; 0x1332 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0x116>
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    124c:	e2 53       	subi	r30, 0x32	; 50
    124e:	ff 4f       	sbci	r31, 0xFF	; 255
}


float calculateInnerLoopControlValue( float outerLoopSetpoint, float measuredValue, float gain, float angularVelocity, float angularVelocityGain )
{
	return (gain * (outerLoopSetpoint - measuredValue)) - (angularVelocity * angularVelocityGain);
    1250:	20 81       	ld	r18, Z
    1252:	31 81       	ldd	r19, Z+1	; 0x01
    1254:	42 81       	ldd	r20, Z+2	; 0x02
    1256:	53 81       	ldd	r21, Z+3	; 0x03
    1258:	e8 56       	subi	r30, 0x68	; 104
    125a:	f1 09       	sbc	r31, r1
    125c:	60 81       	ld	r22, Z
    125e:	71 81       	ldd	r23, Z+1	; 0x01
    1260:	82 81       	ldd	r24, Z+2	; 0x02
    1262:	93 81       	ldd	r25, Z+3	; 0x03
    1264:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    1268:	2a ad       	ldd	r18, Y+58	; 0x3a
    126a:	3b ad       	ldd	r19, Y+59	; 0x3b
    126c:	4c ad       	ldd	r20, Y+60	; 0x3c
    126e:	5d ad       	ldd	r21, Y+61	; 0x3d
    1270:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    1274:	6b 01       	movw	r12, r22
    1276:	7c 01       	movw	r14, r24
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    1278:	f8 01       	movw	r30, r16
    127a:	e2 52       	subi	r30, 0x22	; 34
    127c:	ff 4f       	sbci	r31, 0xFF	; 255
    127e:	20 81       	ld	r18, Z
    1280:	31 81       	ldd	r19, Z+1	; 0x01
    1282:	42 81       	ldd	r20, Z+2	; 0x02
    1284:	53 81       	ldd	r21, Z+3	; 0x03
    1286:	fe 01       	movw	r30, r28
    1288:	fe 96       	adiw	r30, 0x3e	; 62
    128a:	60 81       	ld	r22, Z
    128c:	71 81       	ldd	r23, Z+1	; 0x01
    128e:	82 81       	ldd	r24, Z+2	; 0x02
    1290:	93 81       	ldd	r25, Z+3	; 0x03
    1292:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    1296:	9b 01       	movw	r18, r22
    1298:	ac 01       	movw	r20, r24
    129a:	c7 01       	movw	r24, r14
    129c:	b6 01       	movw	r22, r12
    129e:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    12a2:	c6 2e       	mov	r12, r22
    12a4:	d7 2e       	mov	r13, r23
    12a6:	e8 2e       	mov	r14, r24
    12a8:	f9 2e       	mov	r15, r25
{
	if (model->OperationalState() == SystemModel::AutoPilot)
	{
		float yLateralInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->YLateralOuterLoopSetpoint(), model->RollRads(), lateralInnerLoopGain, model->RollAngularVelocityRadsPerSecond(), rollAngularVelocityGain);
		
		float yLateralInnerLoopControl = adjustControlForServoLimits(yLateralInnerLoopControlBeforeServoLimits, minLateralServoControlValue, maxLateralServoControlValue);
    12aa:	fe 01       	movw	r30, r28
    12ac:	ea 59       	subi	r30, 0x9A	; 154
    12ae:	ff 4f       	sbci	r31, 0xFF	; 255
    12b0:	80 80       	ld	r8, Z
    12b2:	91 80       	ldd	r9, Z+1	; 0x01
    12b4:	a2 80       	ldd	r10, Z+2	; 0x02
    12b6:	b3 80       	ldd	r11, Z+3	; 0x03
    12b8:	34 97       	sbiw	r30, 0x04	; 4
    12ba:	40 80       	ld	r4, Z
    12bc:	51 80       	ldd	r5, Z+1	; 0x01
    12be:	62 80       	ldd	r6, Z+2	; 0x02
    12c0:	73 80       	ldd	r7, Z+3	; 0x03

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
    12c2:	26 2f       	mov	r18, r22
    12c4:	37 2f       	mov	r19, r23
    12c6:	48 2f       	mov	r20, r24
    12c8:	59 2f       	mov	r21, r25
    12ca:	68 2d       	mov	r22, r8
    12cc:	79 2d       	mov	r23, r9
    12ce:	8a 2d       	mov	r24, r10
    12d0:	9b 2d       	mov	r25, r11
    12d2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    12d6:	88 23       	and	r24, r24
    12d8:	ac f0       	brlt	.+42     	; 0x1304 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0xe8>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
    12da:	2c 2d       	mov	r18, r12
    12dc:	3d 2d       	mov	r19, r13
    12de:	4e 2d       	mov	r20, r14
    12e0:	5f 2d       	mov	r21, r15
    12e2:	64 2d       	mov	r22, r4
    12e4:	75 2d       	mov	r23, r5
    12e6:	86 2d       	mov	r24, r6
    12e8:	97 2d       	mov	r25, r7
    12ea:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    12ee:	18 16       	cp	r1, r24
    12f0:	2c f0       	brlt	.+10     	; 0x12fc <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0xe0>
    12f2:	8c 2c       	mov	r8, r12
    12f4:	9d 2c       	mov	r9, r13
    12f6:	ae 2c       	mov	r10, r14
    12f8:	bf 2c       	mov	r11, r15
    12fa:	04 c0       	rjmp	.+8      	; 0x1304 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0xe8>
	{
		controlValueToAdjust = minServoControlValue;
    12fc:	84 2c       	mov	r8, r4
    12fe:	95 2c       	mov	r9, r5
    1300:	a6 2c       	mov	r10, r6
    1302:	b7 2c       	mov	r11, r7

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}
    1304:	f8 01       	movw	r30, r16
    1306:	ea 5a       	subi	r30, 0xAA	; 170
    1308:	ff 4f       	sbci	r31, 0xFF	; 255
    130a:	8c 2d       	mov	r24, r12
    130c:	9d 2d       	mov	r25, r13
    130e:	ae 2d       	mov	r26, r14
    1310:	bf 2d       	mov	r27, r15
    1312:	80 83       	st	Z, r24
    1314:	91 83       	std	Z+1, r25	; 0x01
    1316:	a2 83       	std	Z+2, r26	; 0x02
    1318:	b3 83       	std	Z+3, r27	; 0x03
		
		float yLateralInnerLoopControl = adjustControlForServoLimits(yLateralInnerLoopControlBeforeServoLimits, minLateralServoControlValue, maxLateralServoControlValue);
		
		model->LateralControlBeforeServoLimitsAdjustment(yLateralInnerLoopControlBeforeServoLimits);
		
		model->LateralControl(yLateralInnerLoopControl);		
    131a:	e8 81       	ld	r30, Y
    131c:	f9 81       	ldd	r31, Y+1	; 0x01

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}
    131e:	e6 5a       	subi	r30, 0xA6	; 166
    1320:	ff 4f       	sbci	r31, 0xFF	; 255
    1322:	88 2d       	mov	r24, r8
    1324:	99 2d       	mov	r25, r9
    1326:	aa 2d       	mov	r26, r10
    1328:	bb 2d       	mov	r27, r11
    132a:	80 83       	st	Z, r24
    132c:	91 83       	std	Z+1, r25	; 0x01
    132e:	a2 83       	std	Z+2, r26	; 0x02
    1330:	b3 83       	std	Z+3, r27	; 0x03
	}
}
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	ef 90       	pop	r14
    133e:	df 90       	pop	r13
    1340:	cf 90       	pop	r12
    1342:	bf 90       	pop	r11
    1344:	af 90       	pop	r10
    1346:	9f 90       	pop	r9
    1348:	8f 90       	pop	r8
    134a:	7f 90       	pop	r7
    134c:	6f 90       	pop	r6
    134e:	5f 90       	pop	r5
    1350:	4f 90       	pop	r4
    1352:	08 95       	ret

00001354 <_ZN10helicopter7drivers12SerialDriverD1Ev>:
				{

				}
						
				virtual ~SerialDriver()
				{
    1354:	22 e1       	ldi	r18, 0x12	; 18
    1356:	32 e0       	ldi	r19, 0x02	; 2
    1358:	fc 01       	movw	r30, r24
    135a:	31 83       	std	Z+1, r19	; 0x01
    135c:	20 83       	st	Z, r18
    135e:	08 95       	ret

00001360 <_ZN10helicopter7drivers12SerialDriver8transmitEf>:
		sei();
	}
}

int SerialDriver::transmit(float valueToSend)
{
    1360:	bf 92       	push	r11
    1362:	cf 92       	push	r12
    1364:	df 92       	push	r13
    1366:	ef 92       	push	r14
    1368:	ff 92       	push	r15
    136a:	0f 93       	push	r16
    136c:	1f 93       	push	r17
    136e:	cf 93       	push	r28
    1370:	df 93       	push	r29
    1372:	ec 01       	movw	r28, r24
    1374:	05 2f       	mov	r16, r21
    1376:	16 2f       	mov	r17, r22
    1378:	b7 2e       	mov	r11, r23
	
	//Memcpy the float into an array of bytes because the compiler doesn't like
	//bit shifting floats. 
	memcpy(bytes, (void*) &valueToSend, 4);
	
	status1 = transmit(bytes[0]);
    137a:	e8 81       	ld	r30, Y
    137c:	f9 81       	ldd	r31, Y+1	; 0x01
    137e:	06 80       	ldd	r0, Z+6	; 0x06
    1380:	f7 81       	ldd	r31, Z+7	; 0x07
    1382:	e0 2d       	mov	r30, r0
    1384:	64 2f       	mov	r22, r20
    1386:	19 95       	eicall
    1388:	7c 01       	movw	r14, r24
	status2 = transmit(bytes[1]);
    138a:	e8 81       	ld	r30, Y
    138c:	f9 81       	ldd	r31, Y+1	; 0x01
    138e:	06 80       	ldd	r0, Z+6	; 0x06
    1390:	f7 81       	ldd	r31, Z+7	; 0x07
    1392:	e0 2d       	mov	r30, r0
    1394:	60 2f       	mov	r22, r16
    1396:	ce 01       	movw	r24, r28
    1398:	19 95       	eicall
    139a:	6c 01       	movw	r12, r24
	status3 = transmit(bytes[2]);
    139c:	e8 81       	ld	r30, Y
    139e:	f9 81       	ldd	r31, Y+1	; 0x01
    13a0:	06 80       	ldd	r0, Z+6	; 0x06
    13a2:	f7 81       	ldd	r31, Z+7	; 0x07
    13a4:	e0 2d       	mov	r30, r0
    13a6:	61 2f       	mov	r22, r17
    13a8:	ce 01       	movw	r24, r28
    13aa:	19 95       	eicall
    13ac:	8c 01       	movw	r16, r24
	status4 = transmit(bytes[3]);
    13ae:	e8 81       	ld	r30, Y
    13b0:	f9 81       	ldd	r31, Y+1	; 0x01
    13b2:	06 80       	ldd	r0, Z+6	; 0x06
    13b4:	f7 81       	ldd	r31, Z+7	; 0x07
    13b6:	e0 2d       	mov	r30, r0
    13b8:	6b 2d       	mov	r22, r11
    13ba:	ce 01       	movw	r24, r28
    13bc:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    13be:	ec 28       	or	r14, r12
    13c0:	fd 28       	or	r15, r13
    13c2:	0e 29       	or	r16, r14
    13c4:	1f 29       	or	r17, r15
}
    13c6:	80 2b       	or	r24, r16
    13c8:	91 2b       	or	r25, r17
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	1f 91       	pop	r17
    13d0:	0f 91       	pop	r16
    13d2:	ff 90       	pop	r15
    13d4:	ef 90       	pop	r14
    13d6:	df 90       	pop	r13
    13d8:	cf 90       	pop	r12
    13da:	bf 90       	pop	r11
    13dc:	08 95       	ret

000013de <_ZN10helicopter7drivers12SerialDriver8transmitEi>:

int SerialDriver::transmit(int valueToSend)
{
    13de:	ff 92       	push	r15
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	ec 01       	movw	r28, r24
    13ea:	f6 2e       	mov	r15, r22
    13ec:	67 2f       	mov	r22, r23
	int status1 = 0;
	int status2 = 0;
	
	status1 = transmit((byte)((valueToSend >> 8) & 0xFF));
    13ee:	e8 81       	ld	r30, Y
    13f0:	f9 81       	ldd	r31, Y+1	; 0x01
    13f2:	06 80       	ldd	r0, Z+6	; 0x06
    13f4:	f7 81       	ldd	r31, Z+7	; 0x07
    13f6:	e0 2d       	mov	r30, r0
    13f8:	19 95       	eicall
    13fa:	8c 01       	movw	r16, r24
	status2 = transmit((byte)valueToSend);	
    13fc:	e8 81       	ld	r30, Y
    13fe:	f9 81       	ldd	r31, Y+1	; 0x01
    1400:	06 80       	ldd	r0, Z+6	; 0x06
    1402:	f7 81       	ldd	r31, Z+7	; 0x07
    1404:	e0 2d       	mov	r30, r0
    1406:	6f 2d       	mov	r22, r15
    1408:	ce 01       	movw	r24, r28
    140a:	19 95       	eicall
	
	return status1 | status2;
}
    140c:	80 2b       	or	r24, r16
    140e:	91 2b       	or	r25, r17
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	1f 91       	pop	r17
    1416:	0f 91       	pop	r16
    1418:	ff 90       	pop	r15
    141a:	08 95       	ret

0000141c <_ZN10helicopter7drivers12SerialDriver8transmitEm>:

int SerialDriver::transmit(unsigned long valueToSend)
{
    141c:	8f 92       	push	r8
    141e:	9f 92       	push	r9
    1420:	af 92       	push	r10
    1422:	bf 92       	push	r11
    1424:	cf 92       	push	r12
    1426:	df 92       	push	r13
    1428:	ef 92       	push	r14
    142a:	ff 92       	push	r15
    142c:	0f 93       	push	r16
    142e:	1f 93       	push	r17
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	ec 01       	movw	r28, r24
    1436:	4a 01       	movw	r8, r20
    1438:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    143a:	e8 81       	ld	r30, Y
    143c:	f9 81       	ldd	r31, Y+1	; 0x01
    143e:	67 2f       	mov	r22, r23
    1440:	77 27       	eor	r23, r23
    1442:	88 27       	eor	r24, r24
    1444:	99 27       	eor	r25, r25
    1446:	06 80       	ldd	r0, Z+6	; 0x06
    1448:	f7 81       	ldd	r31, Z+7	; 0x07
    144a:	e0 2d       	mov	r30, r0
    144c:	ce 01       	movw	r24, r28
    144e:	19 95       	eicall
    1450:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    1452:	e8 81       	ld	r30, Y
    1454:	f9 81       	ldd	r31, Y+1	; 0x01
    1456:	b5 01       	movw	r22, r10
    1458:	88 27       	eor	r24, r24
    145a:	99 27       	eor	r25, r25
    145c:	06 80       	ldd	r0, Z+6	; 0x06
    145e:	f7 81       	ldd	r31, Z+7	; 0x07
    1460:	e0 2d       	mov	r30, r0
    1462:	ce 01       	movw	r24, r28
    1464:	19 95       	eicall
    1466:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1468:	e8 81       	ld	r30, Y
    146a:	f9 81       	ldd	r31, Y+1	; 0x01
    146c:	99 27       	eor	r25, r25
    146e:	8b 2d       	mov	r24, r11
    1470:	7a 2d       	mov	r23, r10
    1472:	69 2d       	mov	r22, r9
    1474:	06 80       	ldd	r0, Z+6	; 0x06
    1476:	f7 81       	ldd	r31, Z+7	; 0x07
    1478:	e0 2d       	mov	r30, r0
    147a:	ce 01       	movw	r24, r28
    147c:	19 95       	eicall
    147e:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    1480:	e8 81       	ld	r30, Y
    1482:	f9 81       	ldd	r31, Y+1	; 0x01
    1484:	06 80       	ldd	r0, Z+6	; 0x06
    1486:	f7 81       	ldd	r31, Z+7	; 0x07
    1488:	e0 2d       	mov	r30, r0
    148a:	68 2d       	mov	r22, r8
    148c:	ce 01       	movw	r24, r28
    148e:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    1490:	ec 28       	or	r14, r12
    1492:	fd 28       	or	r15, r13
    1494:	0e 29       	or	r16, r14
    1496:	1f 29       	or	r17, r15
}
    1498:	80 2b       	or	r24, r16
    149a:	91 2b       	or	r25, r17
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	ff 90       	pop	r15
    14a6:	ef 90       	pop	r14
    14a8:	df 90       	pop	r13
    14aa:	cf 90       	pop	r12
    14ac:	bf 90       	pop	r11
    14ae:	af 90       	pop	r10
    14b0:	9f 90       	pop	r9
    14b2:	8f 90       	pop	r8
    14b4:	08 95       	ret

000014b6 <_ZN10helicopter7drivers12SerialDriver8transmitEl>:

int SerialDriver::transmit(long valueToSend)
{
    14b6:	8f 92       	push	r8
    14b8:	9f 92       	push	r9
    14ba:	af 92       	push	r10
    14bc:	bf 92       	push	r11
    14be:	cf 92       	push	r12
    14c0:	df 92       	push	r13
    14c2:	ef 92       	push	r14
    14c4:	ff 92       	push	r15
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	ec 01       	movw	r28, r24
    14d0:	4a 01       	movw	r8, r20
    14d2:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    14d4:	e8 81       	ld	r30, Y
    14d6:	f9 81       	ldd	r31, Y+1	; 0x01
    14d8:	67 2f       	mov	r22, r23
    14da:	77 27       	eor	r23, r23
    14dc:	88 27       	eor	r24, r24
    14de:	99 27       	eor	r25, r25
    14e0:	06 80       	ldd	r0, Z+6	; 0x06
    14e2:	f7 81       	ldd	r31, Z+7	; 0x07
    14e4:	e0 2d       	mov	r30, r0
    14e6:	ce 01       	movw	r24, r28
    14e8:	19 95       	eicall
    14ea:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    14ec:	e8 81       	ld	r30, Y
    14ee:	f9 81       	ldd	r31, Y+1	; 0x01
    14f0:	b5 01       	movw	r22, r10
    14f2:	99 27       	eor	r25, r25
    14f4:	77 fd       	sbrc	r23, 7
    14f6:	90 95       	com	r25
    14f8:	89 2f       	mov	r24, r25
    14fa:	06 80       	ldd	r0, Z+6	; 0x06
    14fc:	f7 81       	ldd	r31, Z+7	; 0x07
    14fe:	e0 2d       	mov	r30, r0
    1500:	ce 01       	movw	r24, r28
    1502:	19 95       	eicall
    1504:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1506:	e8 81       	ld	r30, Y
    1508:	f9 81       	ldd	r31, Y+1	; 0x01
    150a:	99 27       	eor	r25, r25
    150c:	b7 fc       	sbrc	r11, 7
    150e:	9a 95       	dec	r25
    1510:	8b 2d       	mov	r24, r11
    1512:	7a 2d       	mov	r23, r10
    1514:	69 2d       	mov	r22, r9
    1516:	06 80       	ldd	r0, Z+6	; 0x06
    1518:	f7 81       	ldd	r31, Z+7	; 0x07
    151a:	e0 2d       	mov	r30, r0
    151c:	ce 01       	movw	r24, r28
    151e:	19 95       	eicall
    1520:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    1522:	e8 81       	ld	r30, Y
    1524:	f9 81       	ldd	r31, Y+1	; 0x01
    1526:	06 80       	ldd	r0, Z+6	; 0x06
    1528:	f7 81       	ldd	r31, Z+7	; 0x07
    152a:	e0 2d       	mov	r30, r0
    152c:	68 2d       	mov	r22, r8
    152e:	ce 01       	movw	r24, r28
    1530:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    1532:	ec 28       	or	r14, r12
    1534:	fd 28       	or	r15, r13
    1536:	0e 29       	or	r16, r14
    1538:	1f 29       	or	r17, r15
}
    153a:	80 2b       	or	r24, r16
    153c:	91 2b       	or	r25, r17
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	1f 91       	pop	r17
    1544:	0f 91       	pop	r16
    1546:	ff 90       	pop	r15
    1548:	ef 90       	pop	r14
    154a:	df 90       	pop	r13
    154c:	cf 90       	pop	r12
    154e:	bf 90       	pop	r11
    1550:	af 90       	pop	r10
    1552:	9f 90       	pop	r9
    1554:	8f 90       	pop	r8
    1556:	08 95       	ret

00001558 <_ZN10helicopter7drivers12SerialDriver8transmitEx>:

int SerialDriver::transmit(int64_t valueToSend)
{
    1558:	3f 92       	push	r3
    155a:	4f 92       	push	r4
    155c:	5f 92       	push	r5
    155e:	6f 92       	push	r6
    1560:	7f 92       	push	r7
    1562:	8f 92       	push	r8
    1564:	9f 92       	push	r9
    1566:	af 92       	push	r10
    1568:	bf 92       	push	r11
    156a:	cf 92       	push	r12
    156c:	df 92       	push	r13
    156e:	ef 92       	push	r14
    1570:	ff 92       	push	r15
    1572:	0f 93       	push	r16
    1574:	1f 93       	push	r17
    1576:	cf 93       	push	r28
    1578:	df 93       	push	r29
    157a:	cd b7       	in	r28, 0x3d	; 61
    157c:	de b7       	in	r29, 0x3e	; 62
    157e:	28 97       	sbiw	r28, 0x08	; 8
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	de bf       	out	0x3e, r29	; 62
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	cd bf       	out	0x3d, r28	; 61
    158a:	98 87       	std	Y+8, r25	; 0x08
    158c:	8f 83       	std	Y+7, r24	; 0x07
    158e:	70 2e       	mov	r7, r16
    1590:	32 2e       	mov	r3, r18
    1592:	43 2e       	mov	r4, r19
    1594:	54 2e       	mov	r5, r20
    1596:	65 2e       	mov	r6, r21
    1598:	e6 2e       	mov	r14, r22
    159a:	f7 2e       	mov	r15, r23
	int status5 = 0;
	int status6 = 0;
	int status7 = 0;
	int status8 = 0;	

	status1 = transmit((byte)((valueToSend >> 56) & 0xFF));
    159c:	dc 01       	movw	r26, r24
    159e:	ed 91       	ld	r30, X+
    15a0:	fc 91       	ld	r31, X
    15a2:	11 97       	sbiw	r26, 0x01	; 1
    15a4:	20 2f       	mov	r18, r16
    15a6:	31 2f       	mov	r19, r17
    15a8:	43 2d       	mov	r20, r3
    15aa:	54 2d       	mov	r21, r4
    15ac:	65 2d       	mov	r22, r5
    15ae:	76 2d       	mov	r23, r6
    15b0:	8e 2d       	mov	r24, r14
    15b2:	9f 2d       	mov	r25, r15
    15b4:	08 e3       	ldi	r16, 0x38	; 56
    15b6:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    15ba:	06 80       	ldd	r0, Z+6	; 0x06
    15bc:	f7 81       	ldd	r31, Z+7	; 0x07
    15be:	e0 2d       	mov	r30, r0
    15c0:	62 2f       	mov	r22, r18
    15c2:	cd 01       	movw	r24, r26
    15c4:	19 95       	eicall
    15c6:	5c 01       	movw	r10, r24
	status2 = transmit((byte)((valueToSend >> 48) & 0xFF));
    15c8:	af 81       	ldd	r26, Y+7	; 0x07
    15ca:	b8 85       	ldd	r27, Y+8	; 0x08
    15cc:	ed 91       	ld	r30, X+
    15ce:	fc 91       	ld	r31, X
    15d0:	11 97       	sbiw	r26, 0x01	; 1
    15d2:	27 2d       	mov	r18, r7
    15d4:	31 2f       	mov	r19, r17
    15d6:	43 2d       	mov	r20, r3
    15d8:	54 2d       	mov	r21, r4
    15da:	65 2d       	mov	r22, r5
    15dc:	76 2d       	mov	r23, r6
    15de:	8e 2d       	mov	r24, r14
    15e0:	9f 2d       	mov	r25, r15
    15e2:	00 e3       	ldi	r16, 0x30	; 48
    15e4:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    15e8:	06 80       	ldd	r0, Z+6	; 0x06
    15ea:	f7 81       	ldd	r31, Z+7	; 0x07
    15ec:	e0 2d       	mov	r30, r0
    15ee:	62 2f       	mov	r22, r18
    15f0:	cd 01       	movw	r24, r26
    15f2:	19 95       	eicall
    15f4:	4c 01       	movw	r8, r24
	status3 = transmit((byte)((valueToSend >> 40) & 0xFF));
    15f6:	af 81       	ldd	r26, Y+7	; 0x07
    15f8:	b8 85       	ldd	r27, Y+8	; 0x08
    15fa:	ed 91       	ld	r30, X+
    15fc:	fc 91       	ld	r31, X
    15fe:	11 97       	sbiw	r26, 0x01	; 1
    1600:	27 2d       	mov	r18, r7
    1602:	31 2f       	mov	r19, r17
    1604:	43 2d       	mov	r20, r3
    1606:	54 2d       	mov	r21, r4
    1608:	65 2d       	mov	r22, r5
    160a:	76 2d       	mov	r23, r6
    160c:	8e 2d       	mov	r24, r14
    160e:	9f 2d       	mov	r25, r15
    1610:	08 e2       	ldi	r16, 0x28	; 40
    1612:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    1616:	06 80       	ldd	r0, Z+6	; 0x06
    1618:	f7 81       	ldd	r31, Z+7	; 0x07
    161a:	e0 2d       	mov	r30, r0
    161c:	62 2f       	mov	r22, r18
    161e:	cd 01       	movw	r24, r26
    1620:	19 95       	eicall
    1622:	9a 83       	std	Y+2, r25	; 0x02
    1624:	89 83       	std	Y+1, r24	; 0x01
	status4 = transmit((byte)((valueToSend >> 32) & 0xFF));
    1626:	af 81       	ldd	r26, Y+7	; 0x07
    1628:	b8 85       	ldd	r27, Y+8	; 0x08
    162a:	ed 91       	ld	r30, X+
    162c:	fc 91       	ld	r31, X
    162e:	11 97       	sbiw	r26, 0x01	; 1
    1630:	27 2d       	mov	r18, r7
    1632:	31 2f       	mov	r19, r17
    1634:	43 2d       	mov	r20, r3
    1636:	54 2d       	mov	r21, r4
    1638:	65 2d       	mov	r22, r5
    163a:	76 2d       	mov	r23, r6
    163c:	8e 2d       	mov	r24, r14
    163e:	9f 2d       	mov	r25, r15
    1640:	00 e2       	ldi	r16, 0x20	; 32
    1642:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    1646:	06 80       	ldd	r0, Z+6	; 0x06
    1648:	f7 81       	ldd	r31, Z+7	; 0x07
    164a:	e0 2d       	mov	r30, r0
    164c:	62 2f       	mov	r22, r18
    164e:	cd 01       	movw	r24, r26
    1650:	19 95       	eicall
    1652:	9c 83       	std	Y+4, r25	; 0x04
    1654:	8b 83       	std	Y+3, r24	; 0x03
	status5 = transmit((byte)((valueToSend >> 24) & 0xFF));
    1656:	af 81       	ldd	r26, Y+7	; 0x07
    1658:	b8 85       	ldd	r27, Y+8	; 0x08
    165a:	ed 91       	ld	r30, X+
    165c:	fc 91       	ld	r31, X
    165e:	11 97       	sbiw	r26, 0x01	; 1
    1660:	27 2d       	mov	r18, r7
    1662:	31 2f       	mov	r19, r17
    1664:	43 2d       	mov	r20, r3
    1666:	54 2d       	mov	r21, r4
    1668:	65 2d       	mov	r22, r5
    166a:	76 2d       	mov	r23, r6
    166c:	8e 2d       	mov	r24, r14
    166e:	9f 2d       	mov	r25, r15
    1670:	08 e1       	ldi	r16, 0x18	; 24
    1672:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    1676:	06 80       	ldd	r0, Z+6	; 0x06
    1678:	f7 81       	ldd	r31, Z+7	; 0x07
    167a:	e0 2d       	mov	r30, r0
    167c:	62 2f       	mov	r22, r18
    167e:	cd 01       	movw	r24, r26
    1680:	19 95       	eicall
    1682:	9e 83       	std	Y+6, r25	; 0x06
    1684:	8d 83       	std	Y+5, r24	; 0x05
	status6 = transmit((byte)((valueToSend >> 16) & 0xFF));
    1686:	af 81       	ldd	r26, Y+7	; 0x07
    1688:	b8 85       	ldd	r27, Y+8	; 0x08
    168a:	ed 91       	ld	r30, X+
    168c:	fc 91       	ld	r31, X
    168e:	11 97       	sbiw	r26, 0x01	; 1
    1690:	27 2d       	mov	r18, r7
    1692:	31 2f       	mov	r19, r17
    1694:	43 2d       	mov	r20, r3
    1696:	54 2d       	mov	r21, r4
    1698:	65 2d       	mov	r22, r5
    169a:	76 2d       	mov	r23, r6
    169c:	8e 2d       	mov	r24, r14
    169e:	9f 2d       	mov	r25, r15
    16a0:	00 e1       	ldi	r16, 0x10	; 16
    16a2:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    16a6:	06 80       	ldd	r0, Z+6	; 0x06
    16a8:	f7 81       	ldd	r31, Z+7	; 0x07
    16aa:	e0 2d       	mov	r30, r0
    16ac:	62 2f       	mov	r22, r18
    16ae:	cd 01       	movw	r24, r26
    16b0:	19 95       	eicall
    16b2:	6c 01       	movw	r12, r24
	status7 = transmit((byte)((valueToSend >> 8) & 0xFF));
    16b4:	af 81       	ldd	r26, Y+7	; 0x07
    16b6:	b8 85       	ldd	r27, Y+8	; 0x08
    16b8:	ed 91       	ld	r30, X+
    16ba:	fc 91       	ld	r31, X
    16bc:	11 97       	sbiw	r26, 0x01	; 1
    16be:	27 2d       	mov	r18, r7
    16c0:	31 2f       	mov	r19, r17
    16c2:	43 2d       	mov	r20, r3
    16c4:	54 2d       	mov	r21, r4
    16c6:	65 2d       	mov	r22, r5
    16c8:	76 2d       	mov	r23, r6
    16ca:	8e 2d       	mov	r24, r14
    16cc:	9f 2d       	mov	r25, r15
    16ce:	08 e0       	ldi	r16, 0x08	; 8
    16d0:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    16d4:	06 80       	ldd	r0, Z+6	; 0x06
    16d6:	f7 81       	ldd	r31, Z+7	; 0x07
    16d8:	e0 2d       	mov	r30, r0
    16da:	62 2f       	mov	r22, r18
    16dc:	cd 01       	movw	r24, r26
    16de:	19 95       	eicall
    16e0:	7c 01       	movw	r14, r24
	status8 = transmit((byte)(valueToSend & 0xFF));
    16e2:	af 81       	ldd	r26, Y+7	; 0x07
    16e4:	b8 85       	ldd	r27, Y+8	; 0x08
    16e6:	ed 91       	ld	r30, X+
    16e8:	fc 91       	ld	r31, X
    16ea:	11 97       	sbiw	r26, 0x01	; 1
    16ec:	06 80       	ldd	r0, Z+6	; 0x06
    16ee:	f7 81       	ldd	r31, Z+7	; 0x07
    16f0:	e0 2d       	mov	r30, r0
    16f2:	67 2d       	mov	r22, r7
    16f4:	cd 01       	movw	r24, r26
    16f6:	19 95       	eicall
	
	return status1 | status2 | status3 | status4 | status5 | status6 | status7 | status8;
    16f8:	a8 28       	or	r10, r8
    16fa:	b9 28       	or	r11, r9
    16fc:	e9 81       	ldd	r30, Y+1	; 0x01
    16fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1700:	ae 2a       	or	r10, r30
    1702:	bf 2a       	or	r11, r31
    1704:	2b 81       	ldd	r18, Y+3	; 0x03
    1706:	3c 81       	ldd	r19, Y+4	; 0x04
    1708:	a2 2a       	or	r10, r18
    170a:	b3 2a       	or	r11, r19
    170c:	ad 81       	ldd	r26, Y+5	; 0x05
    170e:	be 81       	ldd	r27, Y+6	; 0x06
    1710:	aa 2a       	or	r10, r26
    1712:	bb 2a       	or	r11, r27
    1714:	ca 28       	or	r12, r10
    1716:	db 28       	or	r13, r11
    1718:	ec 28       	or	r14, r12
    171a:	fd 28       	or	r15, r13
}
    171c:	8e 29       	or	r24, r14
    171e:	9f 29       	or	r25, r15
    1720:	28 96       	adiw	r28, 0x08	; 8
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	df 91       	pop	r29
    172e:	cf 91       	pop	r28
    1730:	1f 91       	pop	r17
    1732:	0f 91       	pop	r16
    1734:	ff 90       	pop	r15
    1736:	ef 90       	pop	r14
    1738:	df 90       	pop	r13
    173a:	cf 90       	pop	r12
    173c:	bf 90       	pop	r11
    173e:	af 90       	pop	r10
    1740:	9f 90       	pop	r9
    1742:	8f 90       	pop	r8
    1744:	7f 90       	pop	r7
    1746:	6f 90       	pop	r6
    1748:	5f 90       	pop	r5
    174a:	4f 90       	pop	r4
    174c:	3f 90       	pop	r3
    174e:	08 95       	ret

00001750 <_ZN10helicopter7drivers12SerialDriverD0Ev>:
    1750:	22 e1       	ldi	r18, 0x12	; 18
    1752:	32 e0       	ldi	r19, 0x02	; 2
    1754:	fc 01       	movw	r30, r24
    1756:	31 83       	std	Z+1, r19	; 0x01
    1758:	20 83       	st	Z, r18
					
				}
    175a:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    175e:	08 95       	ret

00001760 <_ZN10helicopter7drivers12SerialDriver4initEv>:
		timer->stopTimer();
	}
}

void SerialDriver::init()
{
    1760:	cf 93       	push	r28
    1762:	df 93       	push	r29
    1764:	ec 01       	movw	r28, r24
	unsigned int baudPrescaller = 0;
	
	if (useDoubleSpeedMode)
    1766:	8f 81       	ldd	r24, Y+7	; 0x07
    1768:	88 23       	and	r24, r24
    176a:	29 f1       	breq	.+74     	; 0x17b6 <_ZN10helicopter7drivers12SerialDriver4initEv+0x56>
	{
		baudPrescaller = floor((((F_CPU / (baudRate * 8UL))) - 1UL));
    176c:	8a 81       	ldd	r24, Y+2	; 0x02
    176e:	9b 81       	ldd	r25, Y+3	; 0x03
    1770:	ac 81       	ldd	r26, Y+4	; 0x04
    1772:	bd 81       	ldd	r27, Y+5	; 0x05
    1774:	88 0f       	add	r24, r24
    1776:	99 1f       	adc	r25, r25
    1778:	aa 1f       	adc	r26, r26
    177a:	bb 1f       	adc	r27, r27
    177c:	88 0f       	add	r24, r24
    177e:	99 1f       	adc	r25, r25
    1780:	aa 1f       	adc	r26, r26
    1782:	bb 1f       	adc	r27, r27
    1784:	9c 01       	movw	r18, r24
    1786:	ad 01       	movw	r20, r26
    1788:	22 0f       	add	r18, r18
    178a:	33 1f       	adc	r19, r19
    178c:	44 1f       	adc	r20, r20
    178e:	55 1f       	adc	r21, r21
    1790:	60 e0       	ldi	r22, 0x00	; 0
    1792:	74 e2       	ldi	r23, 0x24	; 36
    1794:	84 ef       	ldi	r24, 0xF4	; 244
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    179c:	ca 01       	movw	r24, r20
    179e:	b9 01       	movw	r22, r18
    17a0:	61 50       	subi	r22, 0x01	; 1
    17a2:	71 09       	sbc	r23, r1
    17a4:	81 09       	sbc	r24, r1
    17a6:	91 09       	sbc	r25, r1
    17a8:	0e 94 38 68 	call	0xd070	; 0xd070 <__floatunsisf>
    17ac:	0e 94 75 68 	call	0xd0ea	; 0xd0ea <floor>
    17b0:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    17b4:	28 c0       	rjmp	.+80     	; 0x1806 <_ZN10helicopter7drivers12SerialDriver4initEv+0xa6>
	}else
	{
		//Calculation for the baud prescaller 
		baudPrescaller = floor((((F_CPU / (baudRate * 16UL))) - 1UL));
    17b6:	8a 81       	ldd	r24, Y+2	; 0x02
    17b8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ba:	ac 81       	ldd	r26, Y+4	; 0x04
    17bc:	bd 81       	ldd	r27, Y+5	; 0x05
    17be:	88 0f       	add	r24, r24
    17c0:	99 1f       	adc	r25, r25
    17c2:	aa 1f       	adc	r26, r26
    17c4:	bb 1f       	adc	r27, r27
    17c6:	88 0f       	add	r24, r24
    17c8:	99 1f       	adc	r25, r25
    17ca:	aa 1f       	adc	r26, r26
    17cc:	bb 1f       	adc	r27, r27
    17ce:	9c 01       	movw	r18, r24
    17d0:	ad 01       	movw	r20, r26
    17d2:	22 0f       	add	r18, r18
    17d4:	33 1f       	adc	r19, r19
    17d6:	44 1f       	adc	r20, r20
    17d8:	55 1f       	adc	r21, r21
    17da:	22 0f       	add	r18, r18
    17dc:	33 1f       	adc	r19, r19
    17de:	44 1f       	adc	r20, r20
    17e0:	55 1f       	adc	r21, r21
    17e2:	60 e0       	ldi	r22, 0x00	; 0
    17e4:	74 e2       	ldi	r23, 0x24	; 36
    17e6:	84 ef       	ldi	r24, 0xF4	; 244
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    17ee:	ca 01       	movw	r24, r20
    17f0:	b9 01       	movw	r22, r18
    17f2:	61 50       	subi	r22, 0x01	; 1
    17f4:	71 09       	sbc	r23, r1
    17f6:	81 09       	sbc	r24, r1
    17f8:	91 09       	sbc	r25, r1
    17fa:	0e 94 38 68 	call	0xd070	; 0xd070 <__floatunsisf>
    17fe:	0e 94 75 68 	call	0xd0ea	; 0xd0ea <floor>
    1802:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
	}
	
	
	if (uartPort == Zero)
    1806:	8e 81       	ldd	r24, Y+6	; 0x06
    1808:	81 11       	cpse	r24, r1
    180a:	20 c0       	rjmp	.+64     	; 0x184c <_ZN10helicopter7drivers12SerialDriver4initEv+0xec>
	{
		/* Set baud rate */
		UBRR0 = baudPrescaller;
    180c:	70 93 c5 00 	sts	0x00C5, r23
    1810:	60 93 c4 00 	sts	0x00C4, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);
    1814:	e2 ec       	ldi	r30, 0xC2	; 194
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	80 81       	ld	r24, Z
    181a:	86 60       	ori	r24, 0x06	; 6
    181c:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    181e:	8f 81       	ldd	r24, Y+7	; 0x07
    1820:	88 23       	and	r24, r24
    1822:	31 f0       	breq	.+12     	; 0x1830 <_ZN10helicopter7drivers12SerialDriver4initEv+0xd0>
		{
			UCSR0A |= (1<<U2X0);
    1824:	e0 ec       	ldi	r30, 0xC0	; 192
    1826:	f0 e0       	ldi	r31, 0x00	; 0
    1828:	80 81       	ld	r24, Z
    182a:	82 60       	ori	r24, 0x02	; 2
    182c:	80 83       	st	Z, r24
    182e:	05 c0       	rjmp	.+10     	; 0x183a <_ZN10helicopter7drivers12SerialDriver4initEv+0xda>
		}else
		{
			UCSR0A &= ~(1<<U2X0);
    1830:	e0 ec       	ldi	r30, 0xC0	; 192
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	80 81       	ld	r24, Z
    1836:	8d 7f       	andi	r24, 0xFD	; 253
    1838:	80 83       	st	Z, r24
		}
		
		//The spec says to set this flag to 0 whenever UCSR0A is set if you are going to be using it.  
		UCSR0B &= ~(1<<UDRIE0);
    183a:	e1 ec       	ldi	r30, 0xC1	; 193
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	80 81       	ld	r24, Z
    1840:	8f 7d       	andi	r24, 0xDF	; 223
    1842:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR0B |= (1<<RXEN0) | (1<<TXEN0);
    1844:	80 81       	ld	r24, Z
    1846:	88 61       	ori	r24, 0x18	; 24
    1848:	80 83       	st	Z, r24
    184a:	21 c0       	rjmp	.+66     	; 0x188e <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	} else if (uartPort == One)
    184c:	81 30       	cpi	r24, 0x01	; 1
    184e:	f9 f4       	brne	.+62     	; 0x188e <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	{	
		
				
		/* Set baud rate */
		UBRR1 = baudPrescaller;
    1850:	70 93 cd 00 	sts	0x00CD, r23
    1854:	60 93 cc 00 	sts	0x00CC, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR1C |= (1<<UCSZ11)|(1<<UCSZ10);
    1858:	ea ec       	ldi	r30, 0xCA	; 202
    185a:	f0 e0       	ldi	r31, 0x00	; 0
    185c:	80 81       	ld	r24, Z
    185e:	86 60       	ori	r24, 0x06	; 6
    1860:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    1862:	8f 81       	ldd	r24, Y+7	; 0x07
    1864:	88 23       	and	r24, r24
    1866:	31 f0       	breq	.+12     	; 0x1874 <_ZN10helicopter7drivers12SerialDriver4initEv+0x114>
		{
			UCSR1A |= (1<<U2X1);
    1868:	e8 ec       	ldi	r30, 0xC8	; 200
    186a:	f0 e0       	ldi	r31, 0x00	; 0
    186c:	80 81       	ld	r24, Z
    186e:	82 60       	ori	r24, 0x02	; 2
    1870:	80 83       	st	Z, r24
    1872:	05 c0       	rjmp	.+10     	; 0x187e <_ZN10helicopter7drivers12SerialDriver4initEv+0x11e>
		}else
		{
			UCSR1A &= ~(1<<U2X1);
    1874:	e8 ec       	ldi	r30, 0xC8	; 200
    1876:	f0 e0       	ldi	r31, 0x00	; 0
    1878:	80 81       	ld	r24, Z
    187a:	8d 7f       	andi	r24, 0xFD	; 253
    187c:	80 83       	st	Z, r24
		}
		
		UCSR1B &= ~(1<<UDRIE1);
    187e:	e9 ec       	ldi	r30, 0xC9	; 201
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	80 81       	ld	r24, Z
    1884:	8f 7d       	andi	r24, 0xDF	; 223
    1886:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR1B |= (1<<RXEN1) | (1<<TXEN1);		
    1888:	80 81       	ld	r24, Z
    188a:	88 61       	ori	r24, 0x18	; 24
    188c:	80 83       	st	Z, r24
	}
	
	
	if (asyncReceiveTransmitData)
    188e:	88 85       	ldd	r24, Y+8	; 0x08
    1890:	88 23       	and	r24, r24
    1892:	91 f0       	breq	.+36     	; 0x18b8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x158>
	{
		cli();
    1894:	f8 94       	cli
		//enable interrupts for asynchronously receiving/transmitting data. 
		if (uartPort == Zero)
    1896:	8e 81       	ldd	r24, Y+6	; 0x06
    1898:	81 11       	cpse	r24, r1
    189a:	06 c0       	rjmp	.+12     	; 0x18a8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x148>
		{
			UCSR0B |= (1<<RXCIE0);
    189c:	e1 ec       	ldi	r30, 0xC1	; 193
    189e:	f0 e0       	ldi	r31, 0x00	; 0
    18a0:	80 81       	ld	r24, Z
    18a2:	80 68       	ori	r24, 0x80	; 128
    18a4:	80 83       	st	Z, r24
    18a6:	07 c0       	rjmp	.+14     	; 0x18b6 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		}
		else if (uartPort == One)
    18a8:	81 30       	cpi	r24, 0x01	; 1
    18aa:	29 f4       	brne	.+10     	; 0x18b6 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		{
			UCSR1B |= (1<<RXCIE1);
    18ac:	e9 ec       	ldi	r30, 0xC9	; 201
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	80 81       	ld	r24, Z
    18b2:	80 68       	ori	r24, 0x80	; 128
    18b4:	80 83       	st	Z, r24
		}
		
		sei();
    18b6:	78 94       	sei
	}
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	08 95       	ret

000018be <_ZN10helicopter7drivers12SerialDriver8transmitEh>:
	
	return status;
}

int SerialDriver::transmit(byte valueToSend)
{
    18be:	ff 92       	push	r15
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	ec 01       	movw	r28, r24
    18ca:	f6 2e       	mov	r15, r22
	
	if (asyncReceiveTransmitData)
    18cc:	88 85       	ldd	r24, Y+8	; 0x08
    18ce:	88 23       	and	r24, r24
    18d0:	59 f0       	breq	.+22     	; 0x18e8 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x2a>
	{
		bool status = transmitBuffer.enqueue(valueToSend);
    18d2:	8e e8       	ldi	r24, 0x8E	; 142
    18d4:	93 e0       	ldi	r25, 0x03	; 3
    18d6:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>

		if (!status)
    18da:	91 e0       	ldi	r25, 0x01	; 1
    18dc:	89 27       	eor	r24, r25
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	91 95       	neg	r25
    18e2:	81 95       	neg	r24
    18e4:	91 09       	sbc	r25, r1
    18e6:	37 c0       	rjmp	.+110    	; 0x1956 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x98>
		
	
	int status = 0;

	
	if (uartPort == Zero)
    18e8:	8e 81       	ldd	r24, Y+6	; 0x06
    18ea:	81 11       	cpse	r24, r1
    18ec:	10 c0       	rjmp	.+32     	; 0x190e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x50>
	{

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    18ee:	00 ec       	ldi	r16, 0xC0	; 192
    18f0:	10 e0       	ldi	r17, 0x00	; 0
    18f2:	08 c0       	rjmp	.+16     	; 0x1904 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x46>
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    18f4:	89 85       	ldd	r24, Y+9	; 0x09
    18f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    18f8:	00 97       	sbiw	r24, 0x00	; 0
    18fa:	21 f0       	breq	.+8      	; 0x1904 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x46>
    18fc:	0e 94 33 66 	call	0xcc66	; 0xcc66 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1900:	81 11       	cpse	r24, r1
    1902:	17 c0       	rjmp	.+46     	; 0x1932 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x74>
	
	if (uartPort == Zero)
	{

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    1904:	f8 01       	movw	r30, r16
    1906:	80 81       	ld	r24, Z
    1908:	85 ff       	sbrs	r24, 5
    190a:	f4 cf       	rjmp	.-24     	; 0x18f4 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x36>
    190c:	1b c0       	rjmp	.+54     	; 0x1944 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x86>
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;
		}

	}else if (uartPort == One)
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	99 f4       	brne	.+38     	; 0x1938 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x7a>
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
    1912:	08 ec       	ldi	r16, 0xC8	; 200
    1914:	10 e0       	ldi	r17, 0x00	; 0
    1916:	08 c0       	rjmp	.+16     	; 0x1928 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    1918:	89 85       	ldd	r24, Y+9	; 0x09
    191a:	9a 85       	ldd	r25, Y+10	; 0x0a
    191c:	00 97       	sbiw	r24, 0x00	; 0
    191e:	21 f0       	breq	.+8      	; 0x1928 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
    1920:	0e 94 33 66 	call	0xcc66	; 0xcc66 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1924:	81 11       	cpse	r24, r1
    1926:	0b c0       	rjmp	.+22     	; 0x193e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x80>
		}

	}else if (uartPort == One)
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
    1928:	f8 01       	movw	r30, r16
    192a:	80 81       	ld	r24, Z
    192c:	85 ff       	sbrs	r24, 5
    192e:	f4 cf       	rjmp	.-24     	; 0x1918 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x5a>
    1930:	0e c0       	rjmp	.+28     	; 0x194e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x90>
		while ( !( UCSR0A & (1<<UDRE0)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1932:	8f ef       	ldi	r24, 0xFF	; 255
    1934:	9f ef       	ldi	r25, 0xFF	; 255
    1936:	0f c0       	rjmp	.+30     	; 0x1956 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x98>
		return 0;
	}
	
		
	
	int status = 0;
    1938:	80 e0       	ldi	r24, 0x00	; 0
    193a:	90 e0       	ldi	r25, 0x00	; 0
    193c:	0c c0       	rjmp	.+24     	; 0x1956 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x98>
		while ( !( UCSR1A & (1<<UDRE1)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    193e:	8f ef       	ldi	r24, 0xFF	; 255
    1940:	9f ef       	ldi	r25, 0xFF	; 255
    1942:	09 c0       	rjmp	.+18     	; 0x1956 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x98>
//
			//// Stop interrupts
			//cli();
			
			/* Put data into buffer, sends the data */
			UDR0 = valueToSend;			
    1944:	f0 92 c6 00 	sts	0x00C6, r15
    1948:	80 e0       	ldi	r24, 0x00	; 0
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	04 c0       	rjmp	.+8      	; 0x1956 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x98>
//
			//// Stop interrupts
			//cli();
						
			/* Put data into buffer, sends the data */
			UDR1 = valueToSend;
    194e:	f0 92 ce 00 	sts	0x00CE, r15
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	90 e0       	ldi	r25, 0x00	; 0
		}		
	}
	

	return status;
}
    1956:	df 91       	pop	r29
    1958:	cf 91       	pop	r28
    195a:	1f 91       	pop	r17
    195c:	0f 91       	pop	r16
    195e:	ff 90       	pop	r15
    1960:	08 95       	ret

00001962 <_ZN10helicopter7drivers12SerialDriver7receiveERh>:

int SerialDriver::receive(byte &receivedByte)
{
    1962:	ef 92       	push	r14
    1964:	ff 92       	push	r15
    1966:	0f 93       	push	r16
    1968:	1f 93       	push	r17
    196a:	cf 93       	push	r28
    196c:	df 93       	push	r29
    196e:	ec 01       	movw	r28, r24
    1970:	7b 01       	movw	r14, r22
	int status = 0;
	
	if (asyncReceiveTransmitData)
    1972:	88 85       	ldd	r24, Y+8	; 0x08
    1974:	88 23       	and	r24, r24
    1976:	59 f0       	breq	.+22     	; 0x198e <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x2c>
	{
		bool status = receiveBuffer.dequeue(receivedByte);
    1978:	88 e9       	ldi	r24, 0x98	; 152
    197a:	93 e0       	ldi	r25, 0x03	; 3
    197c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>
		
		if (!status)
    1980:	91 e0       	ldi	r25, 0x01	; 1
    1982:	89 27       	eor	r24, r25
    1984:	90 e0       	ldi	r25, 0x00	; 0
    1986:	91 95       	neg	r25
    1988:	81 95       	neg	r24
    198a:	91 09       	sbc	r25, r1
    198c:	4e c0       	rjmp	.+156    	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
		}
		
		return 0;
	}
	
	if (uartPort == Zero)
    198e:	8e 81       	ldd	r24, Y+6	; 0x06
    1990:	81 11       	cpse	r24, r1
    1992:	19 c0       	rjmp	.+50     	; 0x19c6 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x64>
		
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
    1994:	00 ec       	ldi	r16, 0xC0	; 192
    1996:	10 e0       	ldi	r17, 0x00	; 0
    1998:	08 c0       	rjmp	.+16     	; 0x19aa <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x48>
		{
			if (timer != NULL && timer->hasTimedout())
    199a:	89 85       	ldd	r24, Y+9	; 0x09
    199c:	9a 85       	ldd	r25, Y+10	; 0x0a
    199e:	00 97       	sbiw	r24, 0x00	; 0
    19a0:	21 f0       	breq	.+8      	; 0x19aa <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x48>
    19a2:	0e 94 33 66 	call	0xcc66	; 0xcc66 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    19a6:	81 11       	cpse	r24, r1
    19a8:	29 c0       	rjmp	.+82     	; 0x19fc <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x9a>
		
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
    19aa:	f8 01       	movw	r30, r16
    19ac:	80 81       	ld	r24, Z
    19ae:	88 23       	and	r24, r24
    19b0:	a4 f7       	brge	.-24     	; 0x199a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x38>
    19b2:	2d c0       	rjmp	.+90     	; 0x1a0e <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xac>
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
			{
				status = -2;
    19b4:	3e ef       	ldi	r19, 0xFE	; 254
    19b6:	2f ef       	ldi	r18, 0xFF	; 255

			//// Stop interrupts
			//cli();
		
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR0;
    19b8:	80 91 c6 00 	lds	r24, 0x00C6
    19bc:	f7 01       	movw	r30, r14
    19be:	80 83       	st	Z, r24
    19c0:	83 2f       	mov	r24, r19
    19c2:	92 2f       	mov	r25, r18
    19c4:	32 c0       	rjmp	.+100    	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
			
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;			
		}
	} else if (uartPort == One)
    19c6:	81 30       	cpi	r24, 0x01	; 1
    19c8:	e1 f4       	brne	.+56     	; 0x1a02 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa0>
			
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
    19ca:	08 ec       	ldi	r16, 0xC8	; 200
    19cc:	10 e0       	ldi	r17, 0x00	; 0
    19ce:	08 c0       	rjmp	.+16     	; 0x19e0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
		{
			if (timer != NULL && timer->hasTimedout())
    19d0:	89 85       	ldd	r24, Y+9	; 0x09
    19d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    19d4:	00 97       	sbiw	r24, 0x00	; 0
    19d6:	21 f0       	breq	.+8      	; 0x19e0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
    19d8:	0e 94 33 66 	call	0xcc66	; 0xcc66 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    19dc:	81 11       	cpse	r24, r1
    19de:	14 c0       	rjmp	.+40     	; 0x1a08 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
			
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
    19e0:	f8 01       	movw	r30, r16
    19e2:	80 81       	ld	r24, Z
    19e4:	88 23       	and	r24, r24
    19e6:	a4 f7       	brge	.-24     	; 0x19d0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x6e>
    19e8:	19 c0       	rjmp	.+50     	; 0x1a1c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xba>
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
			{
				status = -2;
    19ea:	3e ef       	ldi	r19, 0xFE	; 254
    19ec:	2f ef       	ldi	r18, 0xFF	; 255
			//// Stop interrupts
			//cli();
						
				
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR1;
    19ee:	80 91 ce 00 	lds	r24, 0x00CE
    19f2:	f7 01       	movw	r30, r14
    19f4:	80 83       	st	Z, r24
    19f6:	83 2f       	mov	r24, r19
    19f8:	92 2f       	mov	r25, r18
    19fa:	17 c0       	rjmp	.+46     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
		*/
		while ( !(UCSR0A & (1<<RXC0)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    19fc:	8f ef       	ldi	r24, 0xFF	; 255
    19fe:	9f ef       	ldi	r25, 0xFF	; 255
    1a00:	14 c0       	rjmp	.+40     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
	return status;
}

int SerialDriver::receive(byte &receivedByte)
{
	int status = 0;
    1a02:	80 e0       	ldi	r24, 0x00	; 0
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	11 c0       	rjmp	.+34     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
		*/
		while ( !(UCSR1A & (1<<RXC1)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1a08:	8f ef       	ldi	r24, 0xFF	; 255
    1a0a:	9f ef       	ldi	r25, 0xFF	; 255
    1a0c:	0e c0       	rjmp	.+28     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
			* Determine if there has been:
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
    1a0e:	80 91 c0 00 	lds	r24, 0x00C0
    1a12:	8c 71       	andi	r24, 0x1C	; 28
    1a14:	79 f6       	brne	.-98     	; 0x19b4 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x52>
    1a16:	30 e0       	ldi	r19, 0x00	; 0
    1a18:	20 e0       	ldi	r18, 0x00	; 0
    1a1a:	ce cf       	rjmp	.-100    	; 0x19b8 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x56>
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
    1a1c:	80 91 c8 00 	lds	r24, 0x00C8
    1a20:	8c 71       	andi	r24, 0x1C	; 28
    1a22:	19 f7       	brne	.-58     	; 0x19ea <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x88>
    1a24:	30 e0       	ldi	r19, 0x00	; 0
    1a26:	20 e0       	ldi	r18, 0x00	; 0
    1a28:	e2 cf       	rjmp	.-60     	; 0x19ee <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x8c>
			//SREG = SREG_tmp;			
		}
	}

	return status;
}
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	ff 90       	pop	r15
    1a34:	ef 90       	pop	r14
    1a36:	08 95       	ret

00001a38 <_ZN10helicopter6buffer14CircularBufferC1Ei>:
				int headIndex;
				int tailIndex;
				int bytesInQueue;
			
			public:
				CircularBuffer(int bufferSize) :  buffer(NULL), bufferSize(bufferSize), headIndex(0), tailIndex(0), bytesInQueue(0)
    1a38:	0f 93       	push	r16
    1a3a:	1f 93       	push	r17
    1a3c:	cf 93       	push	r28
    1a3e:	df 93       	push	r29
    1a40:	ec 01       	movw	r28, r24
    1a42:	8b 01       	movw	r16, r22
    1a44:	19 82       	std	Y+1, r1	; 0x01
    1a46:	18 82       	st	Y, r1
    1a48:	7b 83       	std	Y+3, r23	; 0x03
    1a4a:	6a 83       	std	Y+2, r22	; 0x02
    1a4c:	1d 82       	std	Y+5, r1	; 0x05
    1a4e:	1c 82       	std	Y+4, r1	; 0x04
    1a50:	1f 82       	std	Y+7, r1	; 0x07
    1a52:	1e 82       	std	Y+6, r1	; 0x06
    1a54:	19 86       	std	Y+9, r1	; 0x09
    1a56:	18 86       	std	Y+8, r1	; 0x08
				{
					buffer = new byte[bufferSize];
    1a58:	cb 01       	movw	r24, r22
    1a5a:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    1a5e:	99 83       	std	Y+1, r25	; 0x01
    1a60:	88 83       	st	Y, r24
					
					memset(buffer, 0, bufferSize);
    1a62:	a8 01       	movw	r20, r16
    1a64:	60 e0       	ldi	r22, 0x00	; 0
    1a66:	70 e0       	ldi	r23, 0x00	; 0
    1a68:	0e 94 c3 6d 	call	0xdb86	; 0xdb86 <memset>
				}
    1a6c:	df 91       	pop	r29
    1a6e:	cf 91       	pop	r28
    1a70:	1f 91       	pop	r17
    1a72:	0f 91       	pop	r16
    1a74:	08 95       	ret

00001a76 <_ZN10helicopter7drivers12SerialDriver10startTimerEv>:
CircularBuffer SerialDriver::receiveBuffer(1000);
CircularBuffer SerialDriver::transmitBuffer(1000);

void SerialDriver::startTimer()
{
	if (timer != NULL)
    1a76:	fc 01       	movw	r30, r24
    1a78:	81 85       	ldd	r24, Z+9	; 0x09
    1a7a:	92 85       	ldd	r25, Z+10	; 0x0a
    1a7c:	00 97       	sbiw	r24, 0x00	; 0
    1a7e:	11 f0       	breq	.+4      	; 0x1a84 <_ZN10helicopter7drivers12SerialDriver10startTimerEv+0xe>
	{
		timer->startTimer();
    1a80:	0e 94 4e 66 	call	0xcc9c	; 0xcc9c <_ZN10helicopter4util5Timer10startTimerEv>
    1a84:	08 95       	ret

00001a86 <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>:
	
}

void SerialDriver::stopTimer()
{
	if (timer != NULL)
    1a86:	fc 01       	movw	r30, r24
    1a88:	81 85       	ldd	r24, Z+9	; 0x09
    1a8a:	92 85       	ldd	r25, Z+10	; 0x0a
    1a8c:	00 97       	sbiw	r24, 0x00	; 0
    1a8e:	11 f0       	breq	.+4      	; 0x1a94 <_ZN10helicopter7drivers12SerialDriver9stopTimerEv+0xe>
	{
		timer->stopTimer();
    1a90:	0e 94 41 66 	call	0xcc82	; 0xcc82 <_ZN10helicopter4util5Timer9stopTimerEv>
    1a94:	08 95       	ret

00001a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>:
	
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
    1a96:	ef 92       	push	r14
    1a98:	ff 92       	push	r15
    1a9a:	0f 93       	push	r16
    1a9c:	1f 93       	push	r17
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
    1aa2:	8c 01       	movw	r16, r24
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1aa4:	14 16       	cp	r1, r20
    1aa6:	15 06       	cpc	r1, r21
    1aa8:	9c f4       	brge	.+38     	; 0x1ad0 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x3a>
    1aaa:	eb 01       	movw	r28, r22
    1aac:	7b 01       	movw	r14, r22
    1aae:	e4 0e       	add	r14, r20
    1ab0:	f5 1e       	adc	r15, r21
	{
		status = transmit((byte) buffer[i]);
    1ab2:	69 91       	ld	r22, Y+
    1ab4:	d8 01       	movw	r26, r16
    1ab6:	ed 91       	ld	r30, X+
    1ab8:	fc 91       	ld	r31, X
    1aba:	06 80       	ldd	r0, Z+6	; 0x06
    1abc:	f7 81       	ldd	r31, Z+7	; 0x07
    1abe:	e0 2d       	mov	r30, r0
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	19 95       	eicall

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1ac4:	ce 15       	cp	r28, r14
    1ac6:	df 05       	cpc	r29, r15
    1ac8:	29 f0       	breq	.+10     	; 0x1ad4 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x3e>
    1aca:	00 97       	sbiw	r24, 0x00	; 0
    1acc:	91 f3       	breq	.-28     	; 0x1ab2 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x1c>
    1ace:	02 c0       	rjmp	.+4      	; 0x1ad4 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x3e>
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
	{
		status = transmit((byte) buffer[i]);
	}
	
	return status;
}
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	ff 90       	pop	r15
    1ade:	ef 90       	pop	r14
    1ae0:	08 95       	ret

00001ae2 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>:

void SerialDriver::clearBuffer()
{
	byte dummy = 0;
	
	if (uartPort == Zero)
    1ae2:	fc 01       	movw	r30, r24
    1ae4:	86 81       	ldd	r24, Z+6	; 0x06
    1ae6:	81 11       	cpse	r24, r1
    1ae8:	0d c0       	rjmp	.+26     	; 0x1b04 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x22>
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1aea:	80 91 c0 00 	lds	r24, 0x00C0
    1aee:	88 23       	and	r24, r24
    1af0:	bc f4       	brge	.+46     	; 0x1b20 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR0;
    1af2:	a6 ec       	ldi	r26, 0xC6	; 198
    1af4:	b0 e0       	ldi	r27, 0x00	; 0
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1af6:	e0 ec       	ldi	r30, 0xC0	; 192
    1af8:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR0;
    1afa:	8c 91       	ld	r24, X
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1afc:	80 81       	ld	r24, Z
    1afe:	88 23       	and	r24, r24
    1b00:	e4 f3       	brlt	.-8      	; 0x1afa <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x18>
    1b02:	08 95       	ret
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
    1b04:	81 30       	cpi	r24, 0x01	; 1
    1b06:	61 f4       	brne	.+24     	; 0x1b20 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
	{
		while (UCSR1A & (1<<RXC1) )
    1b08:	80 91 c8 00 	lds	r24, 0x00C8
    1b0c:	88 23       	and	r24, r24
    1b0e:	44 f4       	brge	.+16     	; 0x1b20 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR1;
    1b10:	ae ec       	ldi	r26, 0xCE	; 206
    1b12:	b0 e0       	ldi	r27, 0x00	; 0
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1b14:	e8 ec       	ldi	r30, 0xC8	; 200
    1b16:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR1;
    1b18:	8c 91       	ld	r24, X
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1b1a:	80 81       	ld	r24, Z
    1b1c:	88 23       	and	r24, r24
    1b1e:	e4 f3       	brlt	.-8      	; 0x1b18 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x36>
    1b20:	08 95       	ret

00001b22 <__vector_25>:
}


//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART0_RX_vect)
{
    1b22:	1f 92       	push	r1
    1b24:	0f 92       	push	r0
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	0f 92       	push	r0
    1b2a:	11 24       	eor	r1, r1
    1b2c:	0b b6       	in	r0, 0x3b	; 59
    1b2e:	0f 92       	push	r0
    1b30:	2f 93       	push	r18
    1b32:	3f 93       	push	r19
    1b34:	4f 93       	push	r20
    1b36:	5f 93       	push	r21
    1b38:	6f 93       	push	r22
    1b3a:	7f 93       	push	r23
    1b3c:	8f 93       	push	r24
    1b3e:	9f 93       	push	r25
    1b40:	af 93       	push	r26
    1b42:	bf 93       	push	r27
    1b44:	ef 93       	push	r30
    1b46:	ff 93       	push	r31
{
	PORTA &= ~(1<<PA5);
}	
*/		
			
	byte b = UDR0;
    1b48:	60 91 c6 00 	lds	r22, 0x00C6
	SerialDriver::receiveBuffer.enqueueInt(b);
    1b4c:	88 e9       	ldi	r24, 0x98	; 152
    1b4e:	93 e0       	ldi	r25, 0x03	; 3
    1b50:	0e 94 23 02 	call	0x446	; 0x446 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>
}
    1b54:	ff 91       	pop	r31
    1b56:	ef 91       	pop	r30
    1b58:	bf 91       	pop	r27
    1b5a:	af 91       	pop	r26
    1b5c:	9f 91       	pop	r25
    1b5e:	8f 91       	pop	r24
    1b60:	7f 91       	pop	r23
    1b62:	6f 91       	pop	r22
    1b64:	5f 91       	pop	r21
    1b66:	4f 91       	pop	r20
    1b68:	3f 91       	pop	r19
    1b6a:	2f 91       	pop	r18
    1b6c:	0f 90       	pop	r0
    1b6e:	0b be       	out	0x3b, r0	; 59
    1b70:	0f 90       	pop	r0
    1b72:	0f be       	out	0x3f, r0	; 63
    1b74:	0f 90       	pop	r0
    1b76:	1f 90       	pop	r1
    1b78:	18 95       	reti

00001b7a <__vector_26>:

ISR(USART0_UDRE_vect)
{
    1b7a:	1f 92       	push	r1
    1b7c:	0f 92       	push	r0
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	0f 92       	push	r0
    1b82:	11 24       	eor	r1, r1
    1b84:	0b b6       	in	r0, 0x3b	; 59
    1b86:	0f 92       	push	r0
    1b88:	2f 93       	push	r18
    1b8a:	3f 93       	push	r19
    1b8c:	4f 93       	push	r20
    1b8e:	5f 93       	push	r21
    1b90:	6f 93       	push	r22
    1b92:	7f 93       	push	r23
    1b94:	8f 93       	push	r24
    1b96:	9f 93       	push	r25
    1b98:	af 93       	push	r26
    1b9a:	bf 93       	push	r27
    1b9c:	ef 93       	push	r30
    1b9e:	ff 93       	push	r31
    1ba0:	cf 93       	push	r28
    1ba2:	df 93       	push	r29
    1ba4:	1f 92       	push	r1
    1ba6:	cd b7       	in	r28, 0x3d	; 61
    1ba8:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1baa:	be 01       	movw	r22, r28
    1bac:	6f 5f       	subi	r22, 0xFF	; 255
    1bae:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb0:	8e e8       	ldi	r24, 0x8E	; 142
    1bb2:	93 e0       	ldi	r25, 0x03	; 3
    1bb4:	0e 94 56 02 	call	0x4ac	; 0x4ac <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1bb8:	88 23       	and	r24, r24
    1bba:	21 f0       	breq	.+8      	; 0x1bc4 <__vector_26+0x4a>
	{
		UDR0 = val;
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	80 93 c6 00 	sts	0x00C6, r24
    1bc2:	05 c0       	rjmp	.+10     	; 0x1bce <__vector_26+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR0B &= ~(1<<UDRIE0);
    1bc4:	e1 ec       	ldi	r30, 0xC1	; 193
    1bc6:	f0 e0       	ldi	r31, 0x00	; 0
    1bc8:	80 81       	ld	r24, Z
    1bca:	8f 7d       	andi	r24, 0xDF	; 223
    1bcc:	80 83       	st	Z, r24
	}
}
    1bce:	0f 90       	pop	r0
    1bd0:	df 91       	pop	r29
    1bd2:	cf 91       	pop	r28
    1bd4:	ff 91       	pop	r31
    1bd6:	ef 91       	pop	r30
    1bd8:	bf 91       	pop	r27
    1bda:	af 91       	pop	r26
    1bdc:	9f 91       	pop	r25
    1bde:	8f 91       	pop	r24
    1be0:	7f 91       	pop	r23
    1be2:	6f 91       	pop	r22
    1be4:	5f 91       	pop	r21
    1be6:	4f 91       	pop	r20
    1be8:	3f 91       	pop	r19
    1bea:	2f 91       	pop	r18
    1bec:	0f 90       	pop	r0
    1bee:	0b be       	out	0x3b, r0	; 59
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	0f 90       	pop	r0
    1bf6:	1f 90       	pop	r1
    1bf8:	18 95       	reti

00001bfa <__vector_37>:
ISR(USART1_UDRE_vect)
{
    1bfa:	1f 92       	push	r1
    1bfc:	0f 92       	push	r0
    1bfe:	0f b6       	in	r0, 0x3f	; 63
    1c00:	0f 92       	push	r0
    1c02:	11 24       	eor	r1, r1
    1c04:	0b b6       	in	r0, 0x3b	; 59
    1c06:	0f 92       	push	r0
    1c08:	2f 93       	push	r18
    1c0a:	3f 93       	push	r19
    1c0c:	4f 93       	push	r20
    1c0e:	5f 93       	push	r21
    1c10:	6f 93       	push	r22
    1c12:	7f 93       	push	r23
    1c14:	8f 93       	push	r24
    1c16:	9f 93       	push	r25
    1c18:	af 93       	push	r26
    1c1a:	bf 93       	push	r27
    1c1c:	ef 93       	push	r30
    1c1e:	ff 93       	push	r31
    1c20:	cf 93       	push	r28
    1c22:	df 93       	push	r29
    1c24:	1f 92       	push	r1
    1c26:	cd b7       	in	r28, 0x3d	; 61
    1c28:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1c2a:	be 01       	movw	r22, r28
    1c2c:	6f 5f       	subi	r22, 0xFF	; 255
    1c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c30:	8e e8       	ldi	r24, 0x8E	; 142
    1c32:	93 e0       	ldi	r25, 0x03	; 3
    1c34:	0e 94 56 02 	call	0x4ac	; 0x4ac <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1c38:	88 23       	and	r24, r24
    1c3a:	21 f0       	breq	.+8      	; 0x1c44 <__vector_37+0x4a>
	{
		UDR1 = val;
    1c3c:	89 81       	ldd	r24, Y+1	; 0x01
    1c3e:	80 93 ce 00 	sts	0x00CE, r24
    1c42:	05 c0       	rjmp	.+10     	; 0x1c4e <__vector_37+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR1B &= ~(1<<UDRIE1);
    1c44:	e9 ec       	ldi	r30, 0xC9	; 201
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	80 81       	ld	r24, Z
    1c4a:	8f 7d       	andi	r24, 0xDF	; 223
    1c4c:	80 83       	st	Z, r24
	}	
    1c4e:	0f 90       	pop	r0
    1c50:	df 91       	pop	r29
    1c52:	cf 91       	pop	r28
    1c54:	ff 91       	pop	r31
    1c56:	ef 91       	pop	r30
    1c58:	bf 91       	pop	r27
    1c5a:	af 91       	pop	r26
    1c5c:	9f 91       	pop	r25
    1c5e:	8f 91       	pop	r24
    1c60:	7f 91       	pop	r23
    1c62:	6f 91       	pop	r22
    1c64:	5f 91       	pop	r21
    1c66:	4f 91       	pop	r20
    1c68:	3f 91       	pop	r19
    1c6a:	2f 91       	pop	r18
    1c6c:	0f 90       	pop	r0
    1c6e:	0b be       	out	0x3b, r0	; 59
    1c70:	0f 90       	pop	r0
    1c72:	0f be       	out	0x3f, r0	; 63
    1c74:	0f 90       	pop	r0
    1c76:	1f 90       	pop	r1
    1c78:	18 95       	reti

00001c7a <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
#include "SerialDriver.h"
#include "CommonHeader.h"

using namespace helicopter::drivers;

CircularBuffer SerialDriver::receiveBuffer(1000);
    1c7a:	68 ee       	ldi	r22, 0xE8	; 232
    1c7c:	73 e0       	ldi	r23, 0x03	; 3
    1c7e:	88 e9       	ldi	r24, 0x98	; 152
    1c80:	93 e0       	ldi	r25, 0x03	; 3
    1c82:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <_ZN10helicopter6buffer14CircularBufferC1Ei>
CircularBuffer SerialDriver::transmitBuffer(1000);
    1c86:	68 ee       	ldi	r22, 0xE8	; 232
    1c88:	73 e0       	ldi	r23, 0x03	; 3
    1c8a:	8e e8       	ldi	r24, 0x8E	; 142
    1c8c:	93 e0       	ldi	r25, 0x03	; 3
    1c8e:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <_ZN10helicopter6buffer14CircularBufferC1Ei>
    1c92:	08 95       	ret

00001c94 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
				~CircularBuffer()
				{
					delete [] buffer;
    1c94:	80 91 8e 03 	lds	r24, 0x038E
    1c98:	90 91 8f 03 	lds	r25, 0x038F
    1c9c:	00 97       	sbiw	r24, 0x00	; 0
    1c9e:	11 f0       	breq	.+4      	; 0x1ca4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE+0x10>
    1ca0:	0e 94 11 61 	call	0xc222	; 0xc222 <_ZdaPv>
    1ca4:	80 91 98 03 	lds	r24, 0x0398
    1ca8:	90 91 99 03 	lds	r25, 0x0399
    1cac:	00 97       	sbiw	r24, 0x00	; 0
    1cae:	11 f0       	breq	.+4      	; 0x1cb4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE+0x20>
    1cb0:	0e 94 11 61 	call	0xc222	; 0xc222 <_ZdaPv>
    1cb4:	08 95       	ret

00001cb6 <_ZN10helicopter7drivers9SPIDriver4initEv>:
{
	/**
	* Configure the MOSI (DDB2) pin, SCK (DDB1), and SS (DDB0) pin (the SS pin for the accelerometer/IMU)
	* as output
	*/
	DDRB = (1<<DDB2) | (1<<DDB1) | (1<<DDB0);
    1cb6:	87 e0       	ldi	r24, 0x07	; 7
    1cb8:	84 b9       	out	0x04, r24	; 4
	
	/**
	 * Configure the SS pin for the barometer as output
	 */
	DDRG |= (1<<DDG1);
    1cba:	99 9a       	sbi	0x13, 1	; 19
	//Set the slave select lines 'high', therefore freeing up the SPI line. (This would otherwise default to 0, making this device
	//hold onto the SPI line). This turns the line 'off' to 'end' any current transactions. These lines
	//default to low (active) so they have to be pulled high in order to free up the SS lines so a device
	//can communicate on the line.
	//Note: Slave Select for the IMU (accelerometer, etc) is PB0, while slave select for the barometer is PG1.
	PORTB |= (1<<PB0);
    1cbc:	28 9a       	sbi	0x05, 0	; 5
	PORTG |= (1<<PG1);
    1cbe:	a1 9a       	sbi	0x14, 1	; 20
	 * SPI Control Register (SPCR)
	 * Enable SPI (1<<SPE)
	 * Set this device as the master device on the SPI line (1<<MSTR)
	 * Set clock frequency to Fosc / 16 (1<<SPR0) (clock speed divided by 16)
	 */
	SPCR |= (1<<SPE) | (1<<MSTR) | (1<<SPR0);
    1cc0:	8c b5       	in	r24, 0x2c	; 44
    1cc2:	81 65       	ori	r24, 0x51	; 81
    1cc4:	8c bd       	out	0x2c, r24	; 44
    1cc6:	08 95       	ret

00001cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>:
{
	/**
	* Set the Slave Select to 0 indicating that the master will be sending
	* data across the SPI line.
	*/
	if (ssLine == SPIDriver::SS_B)
    1cc8:	fc 01       	movw	r30, r24
    1cca:	80 81       	ld	r24, Z
    1ccc:	81 30       	cpi	r24, 0x01	; 1
    1cce:	11 f4       	brne	.+4      	; 0x1cd4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0xc>
	{	
		PORTB &= ~(1<<PB0);
    1cd0:	28 98       	cbi	0x05, 0	; 5
    1cd2:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1cd4:	82 30       	cpi	r24, 0x02	; 2
    1cd6:	09 f4       	brne	.+2      	; 0x1cda <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0x12>
	{
		PORTG &= ~(1<<PG1);
    1cd8:	a1 98       	cbi	0x14, 1	; 20
    1cda:	08 95       	ret

00001cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>:
{
	/**
	 * Set the Slave Select line to 1 indicating that the master
	 * is finished communicating (release the SPI line)
	 */
	if (ssLine == SPIDriver::SS_B)
    1cdc:	fc 01       	movw	r30, r24
    1cde:	80 81       	ld	r24, Z
    1ce0:	81 30       	cpi	r24, 0x01	; 1
    1ce2:	11 f4       	brne	.+4      	; 0x1ce8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0xc>
	{	
		PORTB |= (1<<PB0);	
    1ce4:	28 9a       	sbi	0x05, 0	; 5
    1ce6:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1ce8:	82 30       	cpi	r24, 0x02	; 2
    1cea:	09 f4       	brne	.+2      	; 0x1cee <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0x12>
	{
		PORTG |= (1<<PG1);	
    1cec:	a1 9a       	sbi	0x14, 1	; 20
    1cee:	08 95       	ret

00001cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>:
	 * we are communicating with, uses the same clock cycles that are used
	 * to push each bit in the message we put into the register, to send
	 * this device data. 1 clock cycle used to push data to the device
	 * is also used to push data to THIS device.
	 */
	SPDR = 0;
    1cf0:	1e bc       	out	0x2e, r1	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1cf2:	0d b4       	in	r0, 0x2d	; 45
    1cf4:	07 fe       	sbrs	r0, 7
    1cf6:	fd cf       	rjmp	.-6      	; 0x1cf2 <_ZN10helicopter7drivers9SPIDriver8readByteEv+0x2>
	
	/**
	 * Return the value of SPDR because now the data register
	 * contains the data that was sent to us by the device.
	 */
	return SPDR;
    1cf8:	8e b5       	in	r24, 0x2e	; 46
}
    1cfa:	08 95       	ret

00001cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>:
		PORTG |= (1<<PG1);	
	}
}

int SPIDriver::readInt()
{
    1cfc:	1f 93       	push	r17
    1cfe:	cf 93       	push	r28
    1d00:	df 93       	push	r29
    1d02:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1d04:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1d08:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1d0a:	ce 01       	movw	r24, r28
    1d0c:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	
	return  ((int) highByte<<8) | lowByte;
    1d10:	21 2f       	mov	r18, r17
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	32 2f       	mov	r19, r18
    1d16:	22 27       	eor	r18, r18
}
    1d18:	a9 01       	movw	r20, r18
    1d1a:	48 2b       	or	r20, r24
    1d1c:	ca 01       	movw	r24, r20
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	1f 91       	pop	r17
    1d24:	08 95       	ret

00001d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>:

unsigned int SPIDriver::readUInt()
{
    1d26:	1f 93       	push	r17
    1d28:	cf 93       	push	r28
    1d2a:	df 93       	push	r29
    1d2c:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1d2e:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1d32:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1d34:	ce 01       	movw	r24, r28
    1d36:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	//
	//return hb | lb;
	
	unsigned int returnValue = 0;
	
	returnValue = (highByte << 8) | lowByte;
    1d3a:	21 2f       	mov	r18, r17
    1d3c:	30 e0       	ldi	r19, 0x00	; 0
    1d3e:	32 2f       	mov	r19, r18
    1d40:	22 27       	eor	r18, r18
	
	return returnValue;
	
	
//	return  (((unsigned int) highByte)<<8) | lowByte;
}
    1d42:	a9 01       	movw	r20, r18
    1d44:	48 2b       	or	r20, r24
    1d46:	ca 01       	movw	r24, r20
    1d48:	df 91       	pop	r29
    1d4a:	cf 91       	pop	r28
    1d4c:	1f 91       	pop	r17
    1d4e:	08 95       	ret

00001d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>:
void SPIDriver::write( byte data )
{
	/**
	 * Write the byte to SPI Data Register
	 */
	SPDR = data;
    1d50:	6e bd       	out	0x2e, r22	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1d52:	0d b4       	in	r0, 0x2d	; 45
    1d54:	07 fe       	sbrs	r0, 7
    1d56:	fd cf       	rjmp	.-6      	; 0x1d52 <_ZN10helicopter7drivers9SPIDriver5writeEh+0x2>
}
    1d58:	08 95       	ret

00001d5a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>:

void SPIDriver::transactionWrite( byte data )
{
    1d5a:	1f 93       	push	r17
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	ec 01       	movw	r28, r24
    1d62:	16 2f       	mov	r17, r22
	beginTransaction();
    1d64:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(data);
    1d68:	61 2f       	mov	r22, r17
    1d6a:	ce 01       	movw	r24, r28
    1d6c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1d70:	ce 01       	movw	r24, r28
    1d72:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1d76:	df 91       	pop	r29
    1d78:	cf 91       	pop	r28
    1d7a:	1f 91       	pop	r17
    1d7c:	08 95       	ret

00001d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>:
	write(commandAddress);
	write(commandValue);
}

void SPIDriver::transactionWrite( byte commandAddress, byte commandValue )
{
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
    1d82:	cf 93       	push	r28
    1d84:	df 93       	push	r29
    1d86:	ec 01       	movw	r28, r24
    1d88:	06 2f       	mov	r16, r22
    1d8a:	14 2f       	mov	r17, r20
	beginTransaction();
    1d8c:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(commandAddress);
    1d90:	60 2f       	mov	r22, r16
    1d92:	ce 01       	movw	r24, r28
    1d94:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	write(commandValue);
    1d98:	61 2f       	mov	r22, r17
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1da0:	ce 01       	movw	r24, r28
    1da2:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1da6:	df 91       	pop	r29
    1da8:	cf 91       	pop	r28
    1daa:	1f 91       	pop	r17
    1dac:	0f 91       	pop	r16
    1dae:	08 95       	ret

00001db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>:


void TWIDriver::stop()
{
	//Send the stop condition.
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    1db0:	ec eb       	ldi	r30, 0xBC	; 188
    1db2:	f0 e0       	ldi	r31, 0x00	; 0
    1db4:	84 e9       	ldi	r24, 0x94	; 148
    1db6:	80 83       	st	Z, r24
using namespace helicopter::drivers;

void TWIDriver::reset()
{
	this->stop();
	TWCR &= ~(1<<TWEN);
    1db8:	80 81       	ld	r24, Z
    1dba:	8b 7f       	andi	r24, 0xFB	; 251
    1dbc:	80 83       	st	Z, r24
    1dbe:	08 95       	ret

00001dc0 <_ZN10helicopter7drivers9TWIDriver4initEv>:
	 * because if you run it in conjunction with the servo radio controller, it'll cause the wait for twint to wait forever
	 * if you don't set up the bit rate.
	 */	
	
	//Set the data line and clock line to output. 
	DDRD |= (1<<PD0);
    1dc0:	50 9a       	sbi	0x0a, 0	; 10
	DDRD |= (1<<PD1);
    1dc2:	51 9a       	sbi	0x0a, 1	; 10

	//Set the prescaler for twi to 1
	TWSR &= ~(1<<TWPS0);
    1dc4:	e9 eb       	ldi	r30, 0xB9	; 185
    1dc6:	f0 e0       	ldi	r31, 0x00	; 0
    1dc8:	80 81       	ld	r24, Z
    1dca:	8e 7f       	andi	r24, 0xFE	; 254
    1dcc:	80 83       	st	Z, r24
	TWSR &= ~(1<<TWPS1);
    1dce:	80 81       	ld	r24, Z
    1dd0:	8d 7f       	andi	r24, 0xFD	; 253
    1dd2:	80 83       	st	Z, r24

	//set the bit rate (page 248 of atmega2560 data sheet)
	//this is 200khz clock rate. 
	//equation is here http://www.ermicro.com/blog/?p=744
	//SCL freq = cpu clock freq / (16 + 2(TWBR) * prescaler)
	TWBR = ((16000000UL / 400000UL) - 16UL) / 2UL;
    1dd4:	8c e0       	ldi	r24, 0x0C	; 12
    1dd6:	80 93 b8 00 	sts	0x00B8, r24
    1dda:	08 95       	ret

00001ddc <_ZN10helicopter7drivers9TWIDriver5startEv>:
}

bool TWIDriver::start()
{
	//Send the Start condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    1ddc:	84 ea       	ldi	r24, 0xA4	; 164
    1dde:	80 93 bc 00 	sts	0x00BC, r24
    1de2:	84 e6       	ldi	r24, 0x64	; 100
    1de4:	90 e0       	ldi	r25, 0x00	; 0

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1de6:	ec eb       	ldi	r30, 0xBC	; 188
    1de8:	f0 e0       	ldi	r31, 0x00	; 0
    1dea:	20 81       	ld	r18, Z
    1dec:	22 23       	and	r18, r18
    1dee:	bc f4       	brge	.+46     	; 0x1e1e <_ZN10helicopter7drivers9TWIDriver5startEv+0x42>
    1df0:	11 c0       	rjmp	.+34     	; 0x1e14 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
	}
	
	
	
	//Verify that start condition was successfully sent.
	int status = TWSR & 0xF8;
    1df2:	20 91 b9 00 	lds	r18, 0x00B9
    1df6:	28 7f       	andi	r18, 0xF8	; 248
    1df8:	30 e0       	ldi	r19, 0x00	; 0
	
	if (status == START ||
    1dfa:	28 30       	cpi	r18, 0x08	; 8
    1dfc:	31 05       	cpc	r19, r1
    1dfe:	31 f0       	breq	.+12     	; 0x1e0c <_ZN10helicopter7drivers9TWIDriver5startEv+0x30>
    1e00:	81 e0       	ldi	r24, 0x01	; 1
    1e02:	20 31       	cpi	r18, 0x10	; 16
    1e04:	31 05       	cpc	r19, r1
    1e06:	79 f0       	breq	.+30     	; 0x1e26 <_ZN10helicopter7drivers9TWIDriver5startEv+0x4a>
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	08 95       	ret
	 status == REPEATED_START)
	{	
		return true;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    1e10:	80 e0       	ldi	r24, 0x00	; 0
    1e12:	08 95       	ret
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    1e14:	80 91 bc 00 	lds	r24, 0x00BC
    1e18:	88 23       	and	r24, r24
    1e1a:	d4 f7       	brge	.-12     	; 0x1e10 <_ZN10helicopter7drivers9TWIDriver5startEv+0x34>
    1e1c:	ea cf       	rjmp	.-44     	; 0x1df2 <_ZN10helicopter7drivers9TWIDriver5startEv+0x16>
    1e1e:	01 97       	sbiw	r24, 0x01	; 1

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1e20:	00 97       	sbiw	r24, 0x00	; 0
    1e22:	c1 f3       	breq	.-16     	; 0x1e14 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
    1e24:	e2 cf       	rjmp	.-60     	; 0x1dea <_ZN10helicopter7drivers9TWIDriver5startEv+0xe>
		return true;
	}

	
	return false;
}
    1e26:	08 95       	ret

00001e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>:


void TWIDriver::stop()
{
	//Send the stop condition.
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    1e28:	84 e9       	ldi	r24, 0x94	; 148
    1e2a:	80 93 bc 00 	sts	0x00BC, r24
    1e2e:	08 95       	ret

00001e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>:
}

bool TWIDriver::write( byte data, byte acknowledgeValue)
{
	//Place data onto the Two Wire Data Register
	TWDR = data; 
    1e30:	60 93 bb 00 	sts	0x00BB, r22

	//Start the transmission of the data.
	//Writing 1 to TWINT clears TWINT. Otherwise, TWINT could hold the SCL line low so that other transmissions
	//arn't allowed. Writing 1 clears it so transmissions are allowed. 
	//Setting TWEN free's up the pin so that the clock can take control of it for managing clock cycles between the two devices. 
	TWCR = (1<<TWINT) | (1<<TWEN); 
    1e34:	84 e8       	ldi	r24, 0x84	; 132
    1e36:	80 93 bc 00 	sts	0x00BC, r24
    1e3a:	84 e6       	ldi	r24, 0x64	; 100
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1e3e:	ec eb       	ldi	r30, 0xBC	; 188
    1e40:	f0 e0       	ldi	r31, 0x00	; 0
    1e42:	20 81       	ld	r18, Z
    1e44:	22 23       	and	r18, r18
    1e46:	cc f4       	brge	.+50     	; 0x1e7a <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x4a>
    1e48:	13 c0       	rjmp	.+38     	; 0x1e70 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>

	
	//If an acknowledgment value was given,
	//check to ensure that the ack value received from TW matched
	//the parameter
	if (acknowledgeValue != 0 && 
    1e4a:	44 23       	and	r20, r20
    1e4c:	59 f0       	breq	.+22     	; 0x1e64 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x34>
		((TWSR & TWI_STATUS_MASK) != acknowledgeValue))
    1e4e:	20 91 b9 00 	lds	r18, 0x00B9
    1e52:	28 7f       	andi	r18, 0xF8	; 248
    1e54:	30 e0       	ldi	r19, 0x00	; 0
    1e56:	50 e0       	ldi	r21, 0x00	; 0

	
	//If an acknowledgment value was given,
	//check to ensure that the ack value received from TW matched
	//the parameter
	if (acknowledgeValue != 0 && 
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	24 17       	cp	r18, r20
    1e5c:	35 07       	cpc	r19, r21
    1e5e:	19 f4       	brne	.+6      	; 0x1e66 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    1e60:	80 e0       	ldi	r24, 0x00	; 0
    1e62:	01 c0       	rjmp	.+2      	; 0x1e66 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    1e64:	80 e0       	ldi	r24, 0x00	; 0
    1e66:	91 e0       	ldi	r25, 0x01	; 1
    1e68:	89 27       	eor	r24, r25
    1e6a:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    1e6c:	80 e0       	ldi	r24, 0x00	; 0
    1e6e:	08 95       	ret
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    1e70:	80 91 bc 00 	lds	r24, 0x00BC
    1e74:	88 23       	and	r24, r24
    1e76:	d4 f7       	brge	.-12     	; 0x1e6c <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x3c>
    1e78:	e8 cf       	rjmp	.-48     	; 0x1e4a <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x1a>
    1e7a:	01 97       	sbiw	r24, 0x01	; 1
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1e7c:	00 97       	sbiw	r24, 0x00	; 0
    1e7e:	c1 f3       	breq	.-16     	; 0x1e70 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>
    1e80:	e0 cf       	rjmp	.-64     	; 0x1e42 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x12>

00001e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>:

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
	//Clear the interrupt to start receiving data (why acknowledge?)*** clocks out data??
	//TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
	if (acknowledge)
    1e82:	66 23       	and	r22, r22
    1e84:	21 f0       	breq	.+8      	; 0x1e8e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0xc>
	{
		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
    1e86:	84 ec       	ldi	r24, 0xC4	; 196
    1e88:	80 93 bc 00 	sts	0x00BC, r24
    1e8c:	03 c0       	rjmp	.+6      	; 0x1e94 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x12>
	}else
	{
		TWCR = (1<<TWINT) | (1<<TWEN);
    1e8e:	84 e8       	ldi	r24, 0x84	; 132
    1e90:	80 93 bc 00 	sts	0x00BC, r24
	
	return true;
}

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
    1e94:	84 e6       	ldi	r24, 0x64	; 100
    1e96:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1e98:	ec eb       	ldi	r30, 0xBC	; 188
    1e9a:	f0 e0       	ldi	r31, 0x00	; 0
    1e9c:	20 81       	ld	r18, Z
    1e9e:	22 23       	and	r18, r18
    1ea0:	84 f4       	brge	.+32     	; 0x1ec2 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x40>
    1ea2:	0a c0       	rjmp	.+20     	; 0x1eb8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
	{
		val = 0;
    1ea4:	fa 01       	movw	r30, r20
    1ea6:	10 82       	st	Z, r1
		return false;
    1ea8:	80 e0       	ldi	r24, 0x00	; 0
    1eaa:	08 95       	ret
	}

	
	//Read the data.
	//byte receivedValue = TWDR;
	val = TWDR;
    1eac:	80 91 bb 00 	lds	r24, 0x00BB
    1eb0:	fa 01       	movw	r30, r20
    1eb2:	80 83       	st	Z, r24
	
	//return receivedValue;
	return true;
    1eb4:	81 e0       	ldi	r24, 0x01	; 1
    1eb6:	08 95       	ret
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
    1eb8:	80 91 bc 00 	lds	r24, 0x00BC
    1ebc:	88 23       	and	r24, r24
    1ebe:	94 f7       	brge	.-28     	; 0x1ea4 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x22>
    1ec0:	f5 cf       	rjmp	.-22     	; 0x1eac <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x2a>
    1ec2:	01 97       	sbiw	r24, 0x01	; 1
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1ec4:	00 97       	sbiw	r24, 0x00	; 0
    1ec6:	c1 f3       	breq	.-16     	; 0x1eb8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
    1ec8:	e9 cf       	rjmp	.-46     	; 0x1e9c <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x1a>

00001eca <_ZN10helicopter5tasks12FlashLEDTask4initEv>:
					
			}
	
			void init()
			{
				DDRA |= (1<<ledToBlink);
    1eca:	41 b1       	in	r20, 0x01	; 1
    1ecc:	21 e0       	ldi	r18, 0x01	; 1
    1ece:	30 e0       	ldi	r19, 0x00	; 0
    1ed0:	fc 01       	movw	r30, r24
    1ed2:	00 84       	ldd	r0, Z+8	; 0x08
    1ed4:	02 c0       	rjmp	.+4      	; 0x1eda <_ZN10helicopter5tasks12FlashLEDTask4initEv+0x10>
    1ed6:	22 0f       	add	r18, r18
    1ed8:	33 1f       	adc	r19, r19
    1eda:	0a 94       	dec	r0
    1edc:	e2 f7       	brpl	.-8      	; 0x1ed6 <_ZN10helicopter5tasks12FlashLEDTask4initEv+0xc>
    1ede:	24 2b       	or	r18, r20
    1ee0:	21 b9       	out	0x01, r18	; 1
    1ee2:	08 95       	ret

00001ee4 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>:
			}
	
			/**
				* Flashes the LED
				*/
			void runTaskImpl() {
    1ee4:	fc 01       	movw	r30, r24
				if (isOff)
    1ee6:	87 81       	ldd	r24, Z+7	; 0x07
    1ee8:	88 23       	and	r24, r24
    1eea:	79 f0       	breq	.+30     	; 0x1f0a <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x26>
				{
					//Turn On the LED
					PORTA &= ~(1<<ledToBlink);
    1eec:	42 b1       	in	r20, 0x02	; 2
    1eee:	21 e0       	ldi	r18, 0x01	; 1
    1ef0:	30 e0       	ldi	r19, 0x00	; 0
    1ef2:	c9 01       	movw	r24, r18
    1ef4:	00 84       	ldd	r0, Z+8	; 0x08
    1ef6:	02 c0       	rjmp	.+4      	; 0x1efc <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x18>
    1ef8:	88 0f       	add	r24, r24
    1efa:	99 1f       	adc	r25, r25
    1efc:	0a 94       	dec	r0
    1efe:	e2 f7       	brpl	.-8      	; 0x1ef8 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x14>
    1f00:	80 95       	com	r24
    1f02:	84 23       	and	r24, r20
    1f04:	82 b9       	out	0x02, r24	; 2
					isOff = false;
    1f06:	17 82       	std	Z+7, r1	; 0x07
    1f08:	08 95       	ret
				}else
				{
					//Turn Off the LED
					PORTA |= (1<<ledToBlink);
    1f0a:	42 b1       	in	r20, 0x02	; 2
    1f0c:	21 e0       	ldi	r18, 0x01	; 1
    1f0e:	30 e0       	ldi	r19, 0x00	; 0
    1f10:	c9 01       	movw	r24, r18
    1f12:	00 84       	ldd	r0, Z+8	; 0x08
    1f14:	02 c0       	rjmp	.+4      	; 0x1f1a <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x36>
    1f16:	88 0f       	add	r24, r24
    1f18:	99 1f       	adc	r25, r25
    1f1a:	0a 94       	dec	r0
    1f1c:	e2 f7       	brpl	.-8      	; 0x1f16 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x32>
    1f1e:	84 2b       	or	r24, r20
    1f20:	82 b9       	out	0x02, r24	; 2
					isOff = true;
    1f22:	81 e0       	ldi	r24, 0x01	; 1
    1f24:	87 83       	std	Z+7, r24	; 0x07
    1f26:	08 95       	ret

00001f28 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    1f28:	26 e7       	ldi	r18, 0x76	; 118
    1f2a:	33 e0       	ldi	r19, 0x03	; 3
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	31 83       	std	Z+1, r19	; 0x01
    1f30:	20 83       	st	Z, r18
    1f32:	08 95       	ret

00001f34 <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>:
    1f34:	26 e7       	ldi	r18, 0x76	; 118
    1f36:	33 e0       	ldi	r19, 0x03	; 3
    1f38:	fc 01       	movw	r30, r24
    1f3a:	31 83       	std	Z+1, r19	; 0x01
    1f3c:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
			* This task is used to periodically flash an LED on the flight computer.
			*/
		class FlashLEDTask : public Task
    1f3e:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    1f42:	08 95       	ret

00001f44 <_ZN10helicopter5model11SystemModelC1Ev>:
			
			float EcefToLocalNEDRotationMatrix[3][3];
			
			bool HasNewPressureReading;
			
			SystemModel():
    1f44:	fc 01       	movw	r30, r24
				xVEcefCms(0),
				yVEcefCms(0),
				zVEcefCms(0),
				pressureMillibars(0),
				auxChannelValue(0),
				HasNewPressureReading(false)				
    1f46:	11 82       	std	Z+1, r1	; 0x01
    1f48:	10 82       	st	Z, r1
    1f4a:	12 82       	std	Z+2, r1	; 0x02
    1f4c:	13 82       	std	Z+3, r1	; 0x03
    1f4e:	14 82       	std	Z+4, r1	; 0x04
    1f50:	15 82       	std	Z+5, r1	; 0x05
    1f52:	16 82       	std	Z+6, r1	; 0x06
    1f54:	17 82       	std	Z+7, r1	; 0x07
    1f56:	10 86       	std	Z+8, r1	; 0x08
    1f58:	11 86       	std	Z+9, r1	; 0x09
    1f5a:	12 86       	std	Z+10, r1	; 0x0a
    1f5c:	13 86       	std	Z+11, r1	; 0x0b
    1f5e:	14 86       	std	Z+12, r1	; 0x0c
    1f60:	15 86       	std	Z+13, r1	; 0x0d
    1f62:	16 86       	std	Z+14, r1	; 0x0e
    1f64:	17 86       	std	Z+15, r1	; 0x0f
    1f66:	10 8a       	std	Z+16, r1	; 0x10
    1f68:	11 8a       	std	Z+17, r1	; 0x11
    1f6a:	12 8a       	std	Z+18, r1	; 0x12
    1f6c:	13 8a       	std	Z+19, r1	; 0x13
    1f6e:	14 8a       	std	Z+20, r1	; 0x14
    1f70:	15 8a       	std	Z+21, r1	; 0x15
    1f72:	16 8a       	std	Z+22, r1	; 0x16
    1f74:	17 8a       	std	Z+23, r1	; 0x17
    1f76:	10 8e       	std	Z+24, r1	; 0x18
    1f78:	11 8e       	std	Z+25, r1	; 0x19
    1f7a:	12 8e       	std	Z+26, r1	; 0x1a
    1f7c:	13 8e       	std	Z+27, r1	; 0x1b
    1f7e:	14 8e       	std	Z+28, r1	; 0x1c
    1f80:	15 8e       	std	Z+29, r1	; 0x1d
    1f82:	16 8e       	std	Z+30, r1	; 0x1e
    1f84:	17 8e       	std	Z+31, r1	; 0x1f
    1f86:	10 a2       	std	Z+32, r1	; 0x20
    1f88:	11 a2       	std	Z+33, r1	; 0x21
    1f8a:	12 a2       	std	Z+34, r1	; 0x22
    1f8c:	13 a2       	std	Z+35, r1	; 0x23
    1f8e:	14 a2       	std	Z+36, r1	; 0x24
    1f90:	15 a2       	std	Z+37, r1	; 0x25
    1f92:	16 a2       	std	Z+38, r1	; 0x26
    1f94:	17 a2       	std	Z+39, r1	; 0x27
    1f96:	10 a6       	std	Z+40, r1	; 0x28
    1f98:	11 a6       	std	Z+41, r1	; 0x29
    1f9a:	12 a6       	std	Z+42, r1	; 0x2a
    1f9c:	13 a6       	std	Z+43, r1	; 0x2b
    1f9e:	14 a6       	std	Z+44, r1	; 0x2c
    1fa0:	15 a6       	std	Z+45, r1	; 0x2d
    1fa2:	16 a6       	std	Z+46, r1	; 0x2e
    1fa4:	17 a6       	std	Z+47, r1	; 0x2f
    1fa6:	10 aa       	std	Z+48, r1	; 0x30
    1fa8:	11 aa       	std	Z+49, r1	; 0x31
    1faa:	12 aa       	std	Z+50, r1	; 0x32
    1fac:	13 aa       	std	Z+51, r1	; 0x33
    1fae:	14 aa       	std	Z+52, r1	; 0x34
    1fb0:	15 aa       	std	Z+53, r1	; 0x35
    1fb2:	16 aa       	std	Z+54, r1	; 0x36
    1fb4:	17 aa       	std	Z+55, r1	; 0x37
    1fb6:	10 ae       	std	Z+56, r1	; 0x38
    1fb8:	11 ae       	std	Z+57, r1	; 0x39
    1fba:	12 ae       	std	Z+58, r1	; 0x3a
    1fbc:	13 ae       	std	Z+59, r1	; 0x3b
    1fbe:	14 ae       	std	Z+60, r1	; 0x3c
    1fc0:	15 ae       	std	Z+61, r1	; 0x3d
    1fc2:	dc 01       	movw	r26, r24
    1fc4:	de 96       	adiw	r26, 0x3e	; 62
    1fc6:	1d 92       	st	X+, r1
    1fc8:	1d 92       	st	X+, r1
    1fca:	1d 92       	st	X+, r1
    1fcc:	1c 92       	st	X, r1
    1fce:	13 97       	sbiw	r26, 0x03	; 3
    1fd0:	14 96       	adiw	r26, 0x04	; 4
    1fd2:	1d 92       	st	X+, r1
    1fd4:	1d 92       	st	X+, r1
    1fd6:	1d 92       	st	X+, r1
    1fd8:	1c 92       	st	X, r1
    1fda:	13 97       	sbiw	r26, 0x03	; 3
    1fdc:	14 96       	adiw	r26, 0x04	; 4
    1fde:	1d 92       	st	X+, r1
    1fe0:	1d 92       	st	X+, r1
    1fe2:	1d 92       	st	X+, r1
    1fe4:	1c 92       	st	X, r1
    1fe6:	13 97       	sbiw	r26, 0x03	; 3
    1fe8:	14 96       	adiw	r26, 0x04	; 4
    1fea:	1d 92       	st	X+, r1
    1fec:	1d 92       	st	X+, r1
    1fee:	1d 92       	st	X+, r1
    1ff0:	1c 92       	st	X, r1
    1ff2:	13 97       	sbiw	r26, 0x03	; 3
    1ff4:	14 96       	adiw	r26, 0x04	; 4
    1ff6:	1d 92       	st	X+, r1
    1ff8:	1d 92       	st	X+, r1
    1ffa:	1d 92       	st	X+, r1
    1ffc:	1c 92       	st	X, r1
    1ffe:	13 97       	sbiw	r26, 0x03	; 3
    2000:	14 96       	adiw	r26, 0x04	; 4
    2002:	1d 92       	st	X+, r1
    2004:	1d 92       	st	X+, r1
    2006:	1d 92       	st	X+, r1
    2008:	1c 92       	st	X, r1
    200a:	13 97       	sbiw	r26, 0x03	; 3
    200c:	14 96       	adiw	r26, 0x04	; 4
    200e:	1d 92       	st	X+, r1
    2010:	1d 92       	st	X+, r1
    2012:	1d 92       	st	X+, r1
    2014:	1c 92       	st	X, r1
    2016:	13 97       	sbiw	r26, 0x03	; 3
    2018:	14 96       	adiw	r26, 0x04	; 4
    201a:	1d 92       	st	X+, r1
    201c:	1d 92       	st	X+, r1
    201e:	1d 92       	st	X+, r1
    2020:	1c 92       	st	X, r1
    2022:	13 97       	sbiw	r26, 0x03	; 3
    2024:	14 96       	adiw	r26, 0x04	; 4
    2026:	1d 92       	st	X+, r1
    2028:	1d 92       	st	X+, r1
    202a:	1d 92       	st	X+, r1
    202c:	1c 92       	st	X, r1
    202e:	13 97       	sbiw	r26, 0x03	; 3
    2030:	14 96       	adiw	r26, 0x04	; 4
    2032:	1d 92       	st	X+, r1
    2034:	1d 92       	st	X+, r1
    2036:	1d 92       	st	X+, r1
    2038:	1c 92       	st	X, r1
    203a:	13 97       	sbiw	r26, 0x03	; 3
    203c:	14 96       	adiw	r26, 0x04	; 4
    203e:	1d 92       	st	X+, r1
    2040:	1d 92       	st	X+, r1
    2042:	1d 92       	st	X+, r1
    2044:	1c 92       	st	X, r1
    2046:	13 97       	sbiw	r26, 0x03	; 3
    2048:	14 96       	adiw	r26, 0x04	; 4
    204a:	1d 92       	st	X+, r1
    204c:	1d 92       	st	X+, r1
    204e:	1d 92       	st	X+, r1
    2050:	1c 92       	st	X, r1
    2052:	13 97       	sbiw	r26, 0x03	; 3
    2054:	14 96       	adiw	r26, 0x04	; 4
    2056:	1d 92       	st	X+, r1
    2058:	1d 92       	st	X+, r1
    205a:	1d 92       	st	X+, r1
    205c:	1c 92       	st	X, r1
    205e:	13 97       	sbiw	r26, 0x03	; 3
    2060:	14 96       	adiw	r26, 0x04	; 4
    2062:	1d 92       	st	X+, r1
    2064:	1d 92       	st	X+, r1
    2066:	1d 92       	st	X+, r1
    2068:	1c 92       	st	X, r1
    206a:	13 97       	sbiw	r26, 0x03	; 3
    206c:	14 96       	adiw	r26, 0x04	; 4
    206e:	1d 92       	st	X+, r1
    2070:	1d 92       	st	X+, r1
    2072:	1d 92       	st	X+, r1
    2074:	1c 92       	st	X, r1
    2076:	13 97       	sbiw	r26, 0x03	; 3
    2078:	14 96       	adiw	r26, 0x04	; 4
    207a:	1d 92       	st	X+, r1
    207c:	1d 92       	st	X+, r1
    207e:	1d 92       	st	X+, r1
    2080:	1c 92       	st	X, r1
    2082:	13 97       	sbiw	r26, 0x03	; 3
    2084:	14 96       	adiw	r26, 0x04	; 4
    2086:	1d 92       	st	X+, r1
    2088:	1d 92       	st	X+, r1
    208a:	1d 92       	st	X+, r1
    208c:	1c 92       	st	X, r1
    208e:	13 97       	sbiw	r26, 0x03	; 3
    2090:	14 96       	adiw	r26, 0x04	; 4
    2092:	1d 92       	st	X+, r1
    2094:	1d 92       	st	X+, r1
    2096:	1d 92       	st	X+, r1
    2098:	1c 92       	st	X, r1
    209a:	13 97       	sbiw	r26, 0x03	; 3
    209c:	14 96       	adiw	r26, 0x04	; 4
    209e:	1d 92       	st	X+, r1
    20a0:	1d 92       	st	X+, r1
    20a2:	1d 92       	st	X+, r1
    20a4:	1c 92       	st	X, r1
    20a6:	13 97       	sbiw	r26, 0x03	; 3
    20a8:	14 96       	adiw	r26, 0x04	; 4
    20aa:	1d 92       	st	X+, r1
    20ac:	1d 92       	st	X+, r1
    20ae:	1d 92       	st	X+, r1
    20b0:	1c 92       	st	X, r1
    20b2:	13 97       	sbiw	r26, 0x03	; 3
    20b4:	14 96       	adiw	r26, 0x04	; 4
    20b6:	1d 92       	st	X+, r1
    20b8:	1d 92       	st	X+, r1
    20ba:	1d 92       	st	X+, r1
    20bc:	1c 92       	st	X, r1
    20be:	13 97       	sbiw	r26, 0x03	; 3
    20c0:	14 96       	adiw	r26, 0x04	; 4
    20c2:	1d 92       	st	X+, r1
    20c4:	1d 92       	st	X+, r1
    20c6:	1d 92       	st	X+, r1
    20c8:	1c 92       	st	X, r1
    20ca:	13 97       	sbiw	r26, 0x03	; 3
    20cc:	14 96       	adiw	r26, 0x04	; 4
    20ce:	1d 92       	st	X+, r1
    20d0:	1d 92       	st	X+, r1
    20d2:	1d 92       	st	X+, r1
    20d4:	1c 92       	st	X, r1
    20d6:	13 97       	sbiw	r26, 0x03	; 3
    20d8:	14 96       	adiw	r26, 0x04	; 4
    20da:	1d 92       	st	X+, r1
    20dc:	1d 92       	st	X+, r1
    20de:	1d 92       	st	X+, r1
    20e0:	1c 92       	st	X, r1
    20e2:	13 97       	sbiw	r26, 0x03	; 3
    20e4:	14 96       	adiw	r26, 0x04	; 4
    20e6:	1d 92       	st	X+, r1
    20e8:	1d 92       	st	X+, r1
    20ea:	1d 92       	st	X+, r1
    20ec:	1c 92       	st	X, r1
    20ee:	13 97       	sbiw	r26, 0x03	; 3
    20f0:	14 96       	adiw	r26, 0x04	; 4
    20f2:	1d 92       	st	X+, r1
    20f4:	1d 92       	st	X+, r1
    20f6:	1d 92       	st	X+, r1
    20f8:	1c 92       	st	X, r1
    20fa:	13 97       	sbiw	r26, 0x03	; 3
    20fc:	14 96       	adiw	r26, 0x04	; 4
    20fe:	1d 92       	st	X+, r1
    2100:	1d 92       	st	X+, r1
    2102:	1d 92       	st	X+, r1
    2104:	1c 92       	st	X, r1
    2106:	13 97       	sbiw	r26, 0x03	; 3
    2108:	14 96       	adiw	r26, 0x04	; 4
    210a:	1d 92       	st	X+, r1
    210c:	1d 92       	st	X+, r1
    210e:	1d 92       	st	X+, r1
    2110:	1c 92       	st	X, r1
    2112:	13 97       	sbiw	r26, 0x03	; 3
    2114:	14 96       	adiw	r26, 0x04	; 4
    2116:	1d 92       	st	X+, r1
    2118:	1d 92       	st	X+, r1
    211a:	1d 92       	st	X+, r1
    211c:	1c 92       	st	X, r1
    211e:	13 97       	sbiw	r26, 0x03	; 3
    2120:	14 96       	adiw	r26, 0x04	; 4
    2122:	1d 92       	st	X+, r1
    2124:	1d 92       	st	X+, r1
    2126:	1d 92       	st	X+, r1
    2128:	1c 92       	st	X, r1
    212a:	13 97       	sbiw	r26, 0x03	; 3
    212c:	14 96       	adiw	r26, 0x04	; 4
    212e:	1d 92       	st	X+, r1
    2130:	1d 92       	st	X+, r1
    2132:	1d 92       	st	X+, r1
    2134:	1c 92       	st	X, r1
    2136:	13 97       	sbiw	r26, 0x03	; 3
    2138:	14 96       	adiw	r26, 0x04	; 4
    213a:	1d 92       	st	X+, r1
    213c:	1d 92       	st	X+, r1
    213e:	1d 92       	st	X+, r1
    2140:	1c 92       	st	X, r1
    2142:	13 97       	sbiw	r26, 0x03	; 3
    2144:	14 96       	adiw	r26, 0x04	; 4
    2146:	1d 92       	st	X+, r1
    2148:	1d 92       	st	X+, r1
    214a:	1d 92       	st	X+, r1
    214c:	1c 92       	st	X, r1
    214e:	13 97       	sbiw	r26, 0x03	; 3
    2150:	14 96       	adiw	r26, 0x04	; 4
    2152:	1d 92       	st	X+, r1
    2154:	1d 92       	st	X+, r1
    2156:	1d 92       	st	X+, r1
    2158:	1c 92       	st	X, r1
    215a:	13 97       	sbiw	r26, 0x03	; 3
    215c:	14 96       	adiw	r26, 0x04	; 4
    215e:	1d 92       	st	X+, r1
    2160:	1d 92       	st	X+, r1
    2162:	1d 92       	st	X+, r1
    2164:	1c 92       	st	X, r1
    2166:	13 97       	sbiw	r26, 0x03	; 3
    2168:	18 96       	adiw	r26, 0x08	; 8
    216a:	1d 92       	st	X+, r1
    216c:	1d 92       	st	X+, r1
    216e:	1d 92       	st	X+, r1
    2170:	1c 92       	st	X, r1
    2172:	13 97       	sbiw	r26, 0x03	; 3
    2174:	14 96       	adiw	r26, 0x04	; 4
    2176:	1d 92       	st	X+, r1
    2178:	1d 92       	st	X+, r1
    217a:	1d 92       	st	X+, r1
    217c:	1c 92       	st	X, r1
    217e:	13 97       	sbiw	r26, 0x03	; 3
    2180:	14 96       	adiw	r26, 0x04	; 4
    2182:	1d 92       	st	X+, r1
    2184:	1d 92       	st	X+, r1
    2186:	1d 92       	st	X+, r1
    2188:	1c 92       	st	X, r1
    218a:	13 97       	sbiw	r26, 0x03	; 3
    218c:	14 96       	adiw	r26, 0x04	; 4
    218e:	1d 92       	st	X+, r1
    2190:	1d 92       	st	X+, r1
    2192:	1d 92       	st	X+, r1
    2194:	1c 92       	st	X, r1
    2196:	13 97       	sbiw	r26, 0x03	; 3
    2198:	14 96       	adiw	r26, 0x04	; 4
    219a:	1d 92       	st	X+, r1
    219c:	1d 92       	st	X+, r1
    219e:	1d 92       	st	X+, r1
    21a0:	1c 92       	st	X, r1
    21a2:	13 97       	sbiw	r26, 0x03	; 3
    21a4:	14 96       	adiw	r26, 0x04	; 4
    21a6:	1d 92       	st	X+, r1
    21a8:	1d 92       	st	X+, r1
    21aa:	1d 92       	st	X+, r1
    21ac:	1c 92       	st	X, r1
    21ae:	13 97       	sbiw	r26, 0x03	; 3
    21b0:	14 96       	adiw	r26, 0x04	; 4
    21b2:	1d 92       	st	X+, r1
    21b4:	1d 92       	st	X+, r1
    21b6:	1d 92       	st	X+, r1
    21b8:	1c 92       	st	X, r1
    21ba:	13 97       	sbiw	r26, 0x03	; 3
    21bc:	14 96       	adiw	r26, 0x04	; 4
    21be:	1d 92       	st	X+, r1
    21c0:	1d 92       	st	X+, r1
    21c2:	1d 92       	st	X+, r1
    21c4:	1c 92       	st	X, r1
    21c6:	13 97       	sbiw	r26, 0x03	; 3
    21c8:	14 96       	adiw	r26, 0x04	; 4
    21ca:	1d 92       	st	X+, r1
    21cc:	1d 92       	st	X+, r1
    21ce:	1d 92       	st	X+, r1
    21d0:	1c 92       	st	X, r1
    21d2:	13 97       	sbiw	r26, 0x03	; 3
    21d4:	14 96       	adiw	r26, 0x04	; 4
    21d6:	1d 92       	st	X+, r1
    21d8:	1d 92       	st	X+, r1
    21da:	1d 92       	st	X+, r1
    21dc:	1c 92       	st	X, r1
    21de:	13 97       	sbiw	r26, 0x03	; 3
    21e0:	14 96       	adiw	r26, 0x04	; 4
    21e2:	1d 92       	st	X+, r1
    21e4:	1d 92       	st	X+, r1
    21e6:	1d 92       	st	X+, r1
    21e8:	1c 92       	st	X, r1
    21ea:	13 97       	sbiw	r26, 0x03	; 3
    21ec:	14 96       	adiw	r26, 0x04	; 4
    21ee:	1d 92       	st	X+, r1
    21f0:	1d 92       	st	X+, r1
    21f2:	1d 92       	st	X+, r1
    21f4:	1c 92       	st	X, r1
    21f6:	13 97       	sbiw	r26, 0x03	; 3
    21f8:	14 96       	adiw	r26, 0x04	; 4
    21fa:	1d 92       	st	X+, r1
    21fc:	1d 92       	st	X+, r1
    21fe:	1d 92       	st	X+, r1
    2200:	1c 92       	st	X, r1
    2202:	13 97       	sbiw	r26, 0x03	; 3
    2204:	14 96       	adiw	r26, 0x04	; 4
    2206:	1d 92       	st	X+, r1
    2208:	1d 92       	st	X+, r1
    220a:	1d 92       	st	X+, r1
    220c:	1c 92       	st	X, r1
    220e:	13 97       	sbiw	r26, 0x03	; 3
    2210:	14 96       	adiw	r26, 0x04	; 4
    2212:	1d 92       	st	X+, r1
    2214:	1d 92       	st	X+, r1
    2216:	1d 92       	st	X+, r1
    2218:	1c 92       	st	X, r1
    221a:	13 97       	sbiw	r26, 0x03	; 3
    221c:	14 96       	adiw	r26, 0x04	; 4
    221e:	1d 92       	st	X+, r1
    2220:	1d 92       	st	X+, r1
    2222:	1d 92       	st	X+, r1
    2224:	1c 92       	st	X, r1
    2226:	13 97       	sbiw	r26, 0x03	; 3
    2228:	14 96       	adiw	r26, 0x04	; 4
    222a:	1d 92       	st	X+, r1
    222c:	1d 92       	st	X+, r1
    222e:	1d 92       	st	X+, r1
    2230:	1c 92       	st	X, r1
    2232:	13 97       	sbiw	r26, 0x03	; 3
    2234:	14 96       	adiw	r26, 0x04	; 4
    2236:	1d 92       	st	X+, r1
    2238:	1d 92       	st	X+, r1
    223a:	1d 92       	st	X+, r1
    223c:	1c 92       	st	X, r1
    223e:	13 97       	sbiw	r26, 0x03	; 3
    2240:	14 96       	adiw	r26, 0x04	; 4
    2242:	1d 92       	st	X+, r1
    2244:	1d 92       	st	X+, r1
    2246:	1d 92       	st	X+, r1
    2248:	1c 92       	st	X, r1
    224a:	13 97       	sbiw	r26, 0x03	; 3
    224c:	14 96       	adiw	r26, 0x04	; 4
    224e:	1d 92       	st	X+, r1
    2250:	1d 92       	st	X+, r1
    2252:	1d 92       	st	X+, r1
    2254:	1c 92       	st	X, r1
    2256:	13 97       	sbiw	r26, 0x03	; 3
    2258:	98 96       	adiw	r26, 0x28	; 40
    225a:	1c 92       	st	X, r1
			{
				EcefToLocalNEDRotationMatrix[0][0] = 0;
    225c:	94 97       	sbiw	r26, 0x24	; 36
    225e:	1d 92       	st	X+, r1
    2260:	1d 92       	st	X+, r1
    2262:	1d 92       	st	X+, r1
    2264:	1c 92       	st	X, r1
    2266:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][1] = 0;
    2268:	14 96       	adiw	r26, 0x04	; 4
    226a:	1d 92       	st	X+, r1
    226c:	1d 92       	st	X+, r1
    226e:	1d 92       	st	X+, r1
    2270:	1c 92       	st	X, r1
    2272:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][2] = 0;
    2274:	14 96       	adiw	r26, 0x04	; 4
    2276:	1d 92       	st	X+, r1
    2278:	1d 92       	st	X+, r1
    227a:	1d 92       	st	X+, r1
    227c:	1c 92       	st	X, r1
    227e:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][0] = 0;
    2280:	14 96       	adiw	r26, 0x04	; 4
    2282:	1d 92       	st	X+, r1
    2284:	1d 92       	st	X+, r1
    2286:	1d 92       	st	X+, r1
    2288:	1c 92       	st	X, r1
    228a:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][1] = 0;
    228c:	14 96       	adiw	r26, 0x04	; 4
    228e:	1d 92       	st	X+, r1
    2290:	1d 92       	st	X+, r1
    2292:	1d 92       	st	X+, r1
    2294:	1c 92       	st	X, r1
    2296:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][2] = 0;
    2298:	14 96       	adiw	r26, 0x04	; 4
    229a:	1d 92       	st	X+, r1
    229c:	1d 92       	st	X+, r1
    229e:	1d 92       	st	X+, r1
    22a0:	1c 92       	st	X, r1
    22a2:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
    22a4:	14 96       	adiw	r26, 0x04	; 4
    22a6:	1d 92       	st	X+, r1
    22a8:	1d 92       	st	X+, r1
    22aa:	1d 92       	st	X+, r1
    22ac:	1c 92       	st	X, r1
    22ae:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][1] = 0;
    22b0:	14 96       	adiw	r26, 0x04	; 4
    22b2:	1d 92       	st	X+, r1
    22b4:	1d 92       	st	X+, r1
    22b6:	1d 92       	st	X+, r1
    22b8:	1c 92       	st	X, r1
    22ba:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
    22bc:	e2 5c       	subi	r30, 0xC2	; 194
    22be:	fe 4f       	sbci	r31, 0xFE	; 254
    22c0:	10 82       	st	Z, r1
    22c2:	11 82       	std	Z+1, r1	; 0x01
    22c4:	12 82       	std	Z+2, r1	; 0x02
    22c6:	13 82       	std	Z+3, r1	; 0x03
    22c8:	08 95       	ret

000022ca <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>:
using namespace helicopter::util;
using namespace helicopter::sensors;
using namespace helicopter::navigation;

void setupDefaultsandReferencePosition(SystemModel *model, PIDController *pidController)
{	
    22ca:	0f 93       	push	r16
    22cc:	1f 93       	push	r17
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	dc 01       	movw	r26, r24
    22d4:	fb 01       	movw	r30, r22
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    22d6:	16 96       	adiw	r26, 0x06	; 6
    22d8:	1d 92       	st	X+, r1
    22da:	1d 92       	st	X+, r1
    22dc:	1d 92       	st	X+, r1
    22de:	1c 92       	st	X, r1
    22e0:	19 97       	sbiw	r26, 0x09	; 9
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
    22e2:	52 96       	adiw	r26, 0x12	; 18
    22e4:	1d 92       	st	X+, r1
    22e6:	1d 92       	st	X+, r1
    22e8:	1d 92       	st	X+, r1
    22ea:	1c 92       	st	X, r1
    22ec:	55 97       	sbiw	r26, 0x15	; 21
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    22ee:	ec 01       	movw	r28, r24
    22f0:	ce 57       	subi	r28, 0x7E	; 126
    22f2:	df 4f       	sbci	r29, 0xFF	; 255
    22f4:	46 e6       	ldi	r20, 0x66	; 102
    22f6:	56 e6       	ldi	r21, 0x66	; 102
    22f8:	68 e9       	ldi	r22, 0x98	; 152
    22fa:	74 ec       	ldi	r23, 0xC4	; 196
    22fc:	48 83       	st	Y, r20
    22fe:	59 83       	std	Y+1, r21	; 0x01
    2300:	6a 83       	std	Y+2, r22	; 0x02
    2302:	7b 83       	std	Y+3, r23	; 0x03

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}
    2304:	60 96       	adiw	r28, 0x10	; 16
    2306:	18 82       	st	Y, r1
    2308:	19 82       	std	Y+1, r1	; 0x01
    230a:	1a 82       	std	Y+2, r1	; 0x02
    230c:	1b 82       	std	Y+3, r1	; 0x03
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    230e:	96 96       	adiw	r26, 0x26	; 38
    2310:	1d 92       	st	X+, r1
    2312:	1d 92       	st	X+, r1
    2314:	1d 92       	st	X+, r1
    2316:	1c 92       	st	X, r1
    2318:	99 97       	sbiw	r26, 0x29	; 41
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
    231a:	d6 96       	adiw	r26, 0x36	; 54
    231c:	1d 92       	st	X+, r1
    231e:	1d 92       	st	X+, r1
    2320:	1d 92       	st	X+, r1
    2322:	1c 92       	st	X, r1
    2324:	d9 97       	sbiw	r26, 0x39	; 57

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    2326:	c0 54       	subi	r28, 0x40	; 64
    2328:	d1 09       	sbc	r29, r1
    232a:	18 82       	st	Y, r1
    232c:	19 82       	std	Y+1, r1	; 0x01
    232e:	1a 82       	std	Y+2, r1	; 0x02
    2330:	1b 82       	std	Y+3, r1	; 0x03

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}
    2332:	ae 59       	subi	r26, 0x9E	; 158
    2334:	bf 4f       	sbci	r27, 0xFF	; 255
    2336:	1d 92       	st	X+, r1
    2338:	1d 92       	st	X+, r1
    233a:	1d 92       	st	X+, r1
    233c:	1c 92       	st	X, r1
    233e:	13 97       	sbiw	r26, 0x03	; 3
					xDerivativeGain = val;
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    2340:	82 e7       	ldi	r24, 0x72	; 114
    2342:	93 e3       	ldi	r25, 0x33	; 51
    2344:	ac e5       	ldi	r26, 0x5C	; 92
    2346:	b9 e3       	ldi	r27, 0x39	; 57
    2348:	82 8f       	std	Z+26, r24	; 0x1a
    234a:	93 8f       	std	Z+27, r25	; 0x1b
    234c:	a4 8f       	std	Z+28, r26	; 0x1c
    234e:	b5 8f       	std	Z+29, r27	; 0x1d
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    2350:	12 8a       	std	Z+18, r1	; 0x12
    2352:	13 8a       	std	Z+19, r1	; 0x13
    2354:	14 8a       	std	Z+20, r1	; 0x14
    2356:	15 8a       	std	Z+21, r1	; 0x15
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    2358:	85 e4       	ldi	r24, 0x45	; 69
    235a:	95 ef       	ldi	r25, 0xF5	; 245
    235c:	a6 ed       	ldi	r26, 0xD6	; 214
    235e:	b9 e3       	ldi	r27, 0x39	; 57
    2360:	86 8b       	std	Z+22, r24	; 0x16
    2362:	97 8b       	std	Z+23, r25	; 0x17
    2364:	a0 8f       	std	Z+24, r26	; 0x18
    2366:	b1 8f       	std	Z+25, r27	; 0x19
					xProportionalGain = val;
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    2368:	16 8e       	std	Z+30, r1	; 0x1e
    236a:	17 8e       	std	Z+31, r1	; 0x1f
    236c:	10 a2       	std	Z+32, r1	; 0x20
    236e:	11 a2       	std	Z+33, r1	; 0x21
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    2370:	80 e0       	ldi	r24, 0x00	; 0
    2372:	90 e0       	ldi	r25, 0x00	; 0
    2374:	a0 e8       	ldi	r26, 0x80	; 128
    2376:	bf e3       	ldi	r27, 0x3F	; 63
    2378:	82 a3       	std	Z+34, r24	; 0x22
    237a:	93 a3       	std	Z+35, r25	; 0x23
    237c:	a4 a3       	std	Z+36, r26	; 0x24
    237e:	b5 a3       	std	Z+37, r27	; 0x25
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    2380:	16 a2       	std	Z+38, r1	; 0x26
    2382:	17 a2       	std	Z+39, r1	; 0x27
    2384:	10 a6       	std	Z+40, r1	; 0x28
    2386:	11 a6       	std	Z+41, r1	; 0x29
					yDerivativeGain = val;
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    2388:	4f e6       	ldi	r20, 0x6F	; 111
    238a:	52 e1       	ldi	r21, 0x12	; 18
    238c:	63 e8       	ldi	r22, 0x83	; 131
    238e:	79 e3       	ldi	r23, 0x39	; 57
    2390:	42 ab       	std	Z+50, r20	; 0x32
    2392:	53 ab       	std	Z+51, r21	; 0x33
    2394:	64 ab       	std	Z+52, r22	; 0x34
    2396:	75 ab       	std	Z+53, r23	; 0x35
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    2398:	12 a6       	std	Z+42, r1	; 0x2a
    239a:	13 a6       	std	Z+43, r1	; 0x2b
    239c:	14 a6       	std	Z+44, r1	; 0x2c
    239e:	15 a6       	std	Z+45, r1	; 0x2d
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    23a0:	4a e8       	ldi	r20, 0x8A	; 138
    23a2:	55 e5       	ldi	r21, 0x55	; 85
    23a4:	63 e0       	ldi	r22, 0x03	; 3
    23a6:	7a e3       	ldi	r23, 0x3A	; 58
    23a8:	46 a7       	std	Z+46, r20	; 0x2e
    23aa:	57 a7       	std	Z+47, r21	; 0x2f
    23ac:	60 ab       	std	Z+48, r22	; 0x30
    23ae:	71 ab       	std	Z+49, r23	; 0x31
					yProportionalGain = val;
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    23b0:	16 aa       	std	Z+54, r1	; 0x36
    23b2:	17 aa       	std	Z+55, r1	; 0x37
    23b4:	10 ae       	std	Z+56, r1	; 0x38
    23b6:	11 ae       	std	Z+57, r1	; 0x39
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    23b8:	82 af       	std	Z+58, r24	; 0x3a
    23ba:	93 af       	std	Z+59, r25	; 0x3b
    23bc:	a4 af       	std	Z+60, r26	; 0x3c
    23be:	b5 af       	std	Z+61, r27	; 0x3d
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    23c0:	ef 01       	movw	r28, r30
    23c2:	ee 96       	adiw	r28, 0x3e	; 62
    23c4:	18 82       	st	Y, r1
    23c6:	19 82       	std	Y+1, r1	; 0x01
    23c8:	1a 82       	std	Y+2, r1	; 0x02
    23ca:	1b 82       	std	Y+3, r1	; 0x03
					zDerivativeGain = val;
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    23cc:	2c 96       	adiw	r28, 0x0c	; 12
    23ce:	4f e6       	ldi	r20, 0x6F	; 111
    23d0:	52 e1       	ldi	r21, 0x12	; 18
    23d2:	63 e0       	ldi	r22, 0x03	; 3
    23d4:	7b e3       	ldi	r23, 0x3B	; 59
    23d6:	48 83       	st	Y, r20
    23d8:	59 83       	std	Y+1, r21	; 0x01
    23da:	6a 83       	std	Y+2, r22	; 0x02
    23dc:	7b 83       	std	Y+3, r23	; 0x03
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    23de:	28 97       	sbiw	r28, 0x08	; 8
    23e0:	18 82       	st	Y, r1
    23e2:	19 82       	std	Y+1, r1	; 0x01
    23e4:	1a 82       	std	Y+2, r1	; 0x02
    23e6:	1b 82       	std	Y+3, r1	; 0x03
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    23e8:	24 96       	adiw	r28, 0x04	; 4
    23ea:	46 ea       	ldi	r20, 0xA6	; 166
    23ec:	5b e9       	ldi	r21, 0x9B	; 155
    23ee:	64 ec       	ldi	r22, 0xC4	; 196
    23f0:	7a e3       	ldi	r23, 0x3A	; 58
    23f2:	48 83       	st	Y, r20
    23f4:	59 83       	std	Y+1, r21	; 0x01
    23f6:	6a 83       	std	Y+2, r22	; 0x02
    23f8:	7b 83       	std	Y+3, r23	; 0x03
					zProportionalGain = val;
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    23fa:	28 96       	adiw	r28, 0x08	; 8
    23fc:	18 82       	st	Y, r1
    23fe:	19 82       	std	Y+1, r1	; 0x01
    2400:	1a 82       	std	Y+2, r1	; 0x02
    2402:	1b 82       	std	Y+3, r1	; 0x03
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    2404:	4d e3       	ldi	r20, 0x3D	; 61
    2406:	5a e0       	ldi	r21, 0x0A	; 10
    2408:	67 ed       	ldi	r22, 0xD7	; 215
    240a:	7e e3       	ldi	r23, 0x3E	; 62
    240c:	42 87       	std	Z+10, r20	; 0x0a
    240e:	53 87       	std	Z+11, r21	; 0x0b
    2410:	64 87       	std	Z+12, r22	; 0x0c
    2412:	75 87       	std	Z+13, r23	; 0x0d
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    2414:	12 82       	std	Z+2, r1	; 0x02
    2416:	13 82       	std	Z+3, r1	; 0x03
    2418:	14 82       	std	Z+4, r1	; 0x04
    241a:	15 82       	std	Z+5, r1	; 0x05
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    241c:	4a e0       	ldi	r20, 0x0A	; 10
    241e:	57 ed       	ldi	r21, 0xD7	; 215
    2420:	63 e2       	ldi	r22, 0x23	; 35
    2422:	7d e3       	ldi	r23, 0x3D	; 61
    2424:	46 83       	std	Z+6, r20	; 0x06
    2426:	57 83       	std	Z+7, r21	; 0x07
    2428:	60 87       	std	Z+8, r22	; 0x08
    242a:	71 87       	std	Z+9, r23	; 0x09
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    242c:	16 86       	std	Z+14, r1	; 0x0e
    242e:	17 86       	std	Z+15, r1	; 0x0f
    2430:	10 8a       	std	Z+16, r1	; 0x10
    2432:	11 8a       	std	Z+17, r1	; 0x11
				 * The number of seconds between pid controller updates. This number
				 * should generally be less than 1. Like .05 for a 20 hz rate.
				 */
				void setIntervalPeriodSecs(float intervalPeriodSecs)
				{
					this->intervalPeriodSecs = intervalPeriodSecs;
    2434:	e4 96       	adiw	r28, 0x34	; 52
    2436:	4d ec       	ldi	r20, 0xCD	; 205
    2438:	5c ec       	ldi	r21, 0xCC	; 204
    243a:	6c e4       	ldi	r22, 0x4C	; 76
    243c:	7d e3       	ldi	r23, 0x3D	; 61
    243e:	48 83       	st	Y, r20
    2440:	59 83       	std	Y+1, r21	; 0x01
    2442:	6a 83       	std	Y+2, r22	; 0x02
    2444:	7b 83       	std	Y+3, r23	; 0x03
				 * This is the maximum possible output value for a control signal.
				 * Generally, this should be set to 1.
				 */
				void setControlMaxValue(float controlMaxValue)
				{
					this->controlMaxValue = controlMaxValue;
    2446:	24 96       	adiw	r28, 0x04	; 4
    2448:	88 83       	st	Y, r24
    244a:	99 83       	std	Y+1, r25	; 0x01
    244c:	aa 83       	std	Y+2, r26	; 0x02
    244e:	bb 83       	std	Y+3, r27	; 0x03
				 * This is the minimum possible value for a control signal.
				 * Generally, this should be set to -1.
				 */
				void setControlMinValue(float controlMinValue)
				{
					this->controlMinValue = controlMinValue;
    2450:	24 96       	adiw	r28, 0x04	; 4
    2452:	40 e0       	ldi	r20, 0x00	; 0
    2454:	50 e0       	ldi	r21, 0x00	; 0
    2456:	60 e8       	ldi	r22, 0x80	; 128
    2458:	7f eb       	ldi	r23, 0xBF	; 191
    245a:	48 83       	st	Y, r20
    245c:	59 83       	std	Y+1, r21	; 0x01
    245e:	6a 83       	std	Y+2, r22	; 0x02
    2460:	7b 83       	std	Y+3, r23	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no smaller than the controlMinValue (e.g. no less than -1)
				 */
				void setMinYawServoControl(float minYawServoControlValue)
				{
					this->minYawServoControlValue = minYawServoControlValue;
    2462:	e8 97       	sbiw	r28, 0x38	; 56
    2464:	0f e8       	ldi	r16, 0x8F	; 143
    2466:	12 ec       	ldi	r17, 0xC2	; 194
    2468:	25 e7       	ldi	r18, 0x75	; 117
    246a:	3f eb       	ldi	r19, 0xBF	; 191
    246c:	08 83       	st	Y, r16
    246e:	19 83       	std	Y+1, r17	; 0x01
    2470:	2a 83       	std	Y+2, r18	; 0x02
    2472:	3b 83       	std	Y+3, r19	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no larger than the controlMaxValue (e.g. no greater than 1)
				 */
				void setMaxYawServoControl(float maxYawServoControlValue)
				{
					this->maxYawServoControlValue = maxYawServoControlValue;
    2474:	24 96       	adiw	r28, 0x04	; 4
    2476:	0f e8       	ldi	r16, 0x8F	; 143
    2478:	12 ec       	ldi	r17, 0xC2	; 194
    247a:	25 e7       	ldi	r18, 0x75	; 117
    247c:	3f e3       	ldi	r19, 0x3F	; 63
    247e:	08 83       	st	Y, r16
    2480:	19 83       	std	Y+1, r17	; 0x01
    2482:	2a 83       	std	Y+2, r18	; 0x02
    2484:	3b 83       	std	Y+3, r19	; 0x03
					minLongitudeServoControlValue = val;
				}
				
				void setMaxLongitudeServoControlValue(float val)
				{
					maxLongitudeServoControlValue = val;
    2486:	28 96       	adiw	r28, 0x08	; 8
    2488:	88 83       	st	Y, r24
    248a:	99 83       	std	Y+1, r25	; 0x01
    248c:	aa 83       	std	Y+2, r26	; 0x02
    248e:	bb 83       	std	Y+3, r27	; 0x03
					pitchAngularVelocityGain = val;
				}
				
				void setMinLongitudeServoControlValue(float val)
				{
					minLongitudeServoControlValue = val;
    2490:	24 97       	sbiw	r28, 0x04	; 4
    2492:	48 83       	st	Y, r20
    2494:	59 83       	std	Y+1, r21	; 0x01
    2496:	6a 83       	std	Y+2, r22	; 0x02
    2498:	7b 83       	std	Y+3, r23	; 0x03
					minLateralServoControlValue = val;
				}
				
				void setMaxLateralServoControlValue(float val)
				{
					maxLateralServoControlValue = val;
    249a:	2c 96       	adiw	r28, 0x0c	; 12
    249c:	88 83       	st	Y, r24
    249e:	99 83       	std	Y+1, r25	; 0x01
    24a0:	aa 83       	std	Y+2, r26	; 0x02
    24a2:	bb 83       	std	Y+3, r27	; 0x03
					rollAngularVelocityGain = val;
				}
				
				void setMinLateralServoControlValue(float val)
				{
					minLateralServoControlValue = val;
    24a4:	df 01       	movw	r26, r30
    24a6:	ae 59       	subi	r26, 0x9E	; 158
    24a8:	bf 4f       	sbci	r27, 0xFF	; 255
    24aa:	4d 93       	st	X+, r20
    24ac:	5d 93       	st	X+, r21
    24ae:	6d 93       	st	X+, r22
    24b0:	7c 93       	st	X, r23
    24b2:	13 97       	sbiw	r26, 0x03	; 3
					minMainRotorServoControlValue = val;
				}
				
				void setMaxMainRotorServoControlValue(float val)
				{
					maxMainRotorServoControlValue = val;
    24b4:	28 96       	adiw	r28, 0x08	; 8
    24b6:	80 e0       	ldi	r24, 0x00	; 0
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	a0 e0       	ldi	r26, 0x00	; 0
    24bc:	bf e3       	ldi	r27, 0x3F	; 63
    24be:	88 83       	st	Y, r24
    24c0:	99 83       	std	Y+1, r25	; 0x01
    24c2:	aa 83       	std	Y+2, r26	; 0x02
    24c4:	bb 83       	std	Y+3, r27	; 0x03
					zAntiWindupGain = val;
				}
				
				void setMinMainRotorServoControlValue(float val)
				{
					minMainRotorServoControlValue = val;
    24c6:	df 01       	movw	r26, r30
    24c8:	a6 59       	subi	r26, 0x96	; 150
    24ca:	bf 4f       	sbci	r27, 0xFF	; 255
    24cc:	1d 92       	st	X+, r1
    24ce:	1d 92       	st	X+, r1
    24d0:	1d 92       	st	X+, r1
    24d2:	1c 92       	st	X, r1
    24d4:	13 97       	sbiw	r26, 0x03	; 3
				}


				void setMaxRollSetpointRads(float val)
				{
					maxRollSetpointRads = val;
    24d6:	60 96       	adiw	r28, 0x10	; 16
    24d8:	82 ec       	ldi	r24, 0xC2	; 194
    24da:	98 eb       	ldi	r25, 0xB8	; 184
    24dc:	a2 eb       	ldi	r26, 0xB2	; 178
    24de:	bd e3       	ldi	r27, 0x3D	; 61
    24e0:	88 83       	st	Y, r24
    24e2:	99 83       	std	Y+1, r25	; 0x01
    24e4:	aa 83       	std	Y+2, r26	; 0x02
    24e6:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinRollSetpointRads(float val)
				{
					minRollSetpointRads = val;
    24e8:	24 97       	sbiw	r28, 0x04	; 4
    24ea:	82 ec       	ldi	r24, 0xC2	; 194
    24ec:	98 eb       	ldi	r25, 0xB8	; 184
    24ee:	a2 eb       	ldi	r26, 0xB2	; 178
    24f0:	bd eb       	ldi	r27, 0xBD	; 189
    24f2:	88 83       	st	Y, r24
    24f4:	99 83       	std	Y+1, r25	; 0x01
    24f6:	aa 83       	std	Y+2, r26	; 0x02
    24f8:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMaxPitchSetpointRads(float val)
				{
					maxPitchSetpointRads = val;
    24fa:	24 97       	sbiw	r28, 0x04	; 4
    24fc:	86 e9       	ldi	r24, 0x96	; 150
    24fe:	96 e5       	ldi	r25, 0x56	; 86
    2500:	a8 e6       	ldi	r26, 0x68	; 104
    2502:	be e3       	ldi	r27, 0x3E	; 62
    2504:	88 83       	st	Y, r24
    2506:	99 83       	std	Y+1, r25	; 0x01
    2508:	aa 83       	std	Y+2, r26	; 0x02
    250a:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinPitchSetpointRads(float val)
				{	
					minPitchSetpointRads = val;
    250c:	ee 58       	subi	r30, 0x8E	; 142
    250e:	ff 4f       	sbci	r31, 0xFF	; 255
    2510:	86 e9       	ldi	r24, 0x96	; 150
    2512:	96 e5       	ldi	r25, 0x56	; 86
    2514:	a8 e6       	ldi	r26, 0x68	; 104
    2516:	be eb       	ldi	r27, 0xBE	; 190
    2518:	80 83       	st	Z, r24
    251a:	91 83       	std	Z+1, r25	; 0x01
    251c:	a2 83       	std	Z+2, r26	; 0x02
    251e:	b3 83       	std	Z+3, r27	; 0x03
	pidController->setMaxPitchSetpointRads(0.226892803);
	pidController->setMinPitchSetpointRads(-0.226892803);	
	
	
	
}
    2520:	df 91       	pop	r29
    2522:	cf 91       	pop	r28
    2524:	1f 91       	pop	r17
    2526:	0f 91       	pop	r16
    2528:	08 95       	ret

0000252a <main>:

//SystemModel *publicModel = NULL;
//static SystemModel *publicModel = new SystemModel();

int main(void)
{	
    252a:	cf 93       	push	r28
    252c:	df 93       	push	r29
    252e:	cd b7       	in	r28, 0x3d	; 61
    2530:	de b7       	in	r29, 0x3e	; 62
    2532:	a8 97       	sbiw	r28, 0x28	; 40
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	f8 94       	cli
    2538:	de bf       	out	0x3e, r29	; 62
    253a:	0f be       	out	0x3f, r0	; 63
    253c:	cd bf       	out	0x3d, r28	; 61
	
	
	DDRA |= (1<<PA4);
    253e:	0c 9a       	sbi	0x01, 4	; 1
	PORTA &= ~(1<<PA4);
    2540:	14 98       	cbi	0x02, 4	; 2
	
	MatrixUtil::createLookupTables();
    2542:	0e 94 57 62 	call	0xc4ae	; 0xc4ae <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>

	
	bool sendControlToServos = false;
	bool receiveGains = false;
	
	Scheduler *scheduler = Scheduler::getScheduler();
    2546:	0e 94 68 3f 	call	0x7ed0	; 0x7ed0 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    254a:	98 a7       	std	Y+40, r25	; 0x28
    254c:	8f a3       	std	Y+39, r24	; 0x27
	
	SystemModel *model = new SystemModel();
    254e:	8f e4       	ldi	r24, 0x4F	; 79
    2550:	91 e0       	ldi	r25, 0x01	; 1
    2552:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2556:	4c 01       	movw	r8, r24
    2558:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <_ZN10helicopter5model11SystemModelC1Ev>
	SystemModel::publicModel = model;
    255c:	90 92 a5 03 	sts	0x03A5, r9
    2560:	80 92 a4 03 	sts	0x03A4, r8
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
			void FlightMode( FlightModes val ) { flightMode = val;}
    2564:	83 e0       	ldi	r24, 0x03	; 3
    2566:	d4 01       	movw	r26, r8
    2568:	13 96       	adiw	r26, 0x03	; 3
    256a:	8c 93       	st	X, r24
    256c:	13 97       	sbiw	r26, 0x03	; 3
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
    256e:	81 e0       	ldi	r24, 0x01	; 1
    2570:	14 96       	adiw	r26, 0x04	; 4
    2572:	8c 93       	st	X, r24
    2574:	14 97       	sbiw	r26, 0x04	; 4
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
    2576:	15 96       	adiw	r26, 0x05	; 5
    2578:	8c 93       	st	X, r24
	}
	
	

	
	PIDController *pidController = new PIDController(model);
    257a:	8e e8       	ldi	r24, 0x8E	; 142
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2582:	1c 01       	movw	r2, r24
    2584:	b4 01       	movw	r22, r8
    2586:	0e 94 8a 02 	call	0x514	; 0x514 <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>
	
	setupDefaultsandReferencePosition(model, pidController);
    258a:	b1 01       	movw	r22, r2
    258c:	c4 01       	movw	r24, r8
    258e:	0e 94 65 11 	call	0x22ca	; 0x22ca <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>
			void FlightMode( FlightModes val ) { flightMode = val;}
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
    2592:	f4 01       	movw	r30, r8
    2594:	85 81       	ldd	r24, Z+5	; 0x05
	Timer *timer = NULL;
	
	unsigned long serialDriverBaudRate = 0;
	
		
	if (model->CommunicationMethod() == SystemModel::USB)
    2596:	81 11       	cpse	r24, r1
    2598:	34 c0       	rjmp	.+104    	; 0x2602 <main+0xd8>
	{
		serialDriverBaudRate = 250000;
		
		//Timer *timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 100); //Good timeout when using the USB
		timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 50); //Good timeout when using the USB
    259a:	8a e0       	ldi	r24, 0x0A	; 10
    259c:	90 e0       	ldi	r25, 0x00	; 0
    259e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    25a2:	8c 01       	movw	r16, r24
				 * Now that this is using an 8 bit timer, prescaler has to be 1024, and timeout millizeconds
				 * has to be divisible by 10 and greater than 10. E.g. 10, 20, 30, 200, etc. 
				 */
				Timer (unsigned long cpuSpeed, PRESCALER timerPrescaler, unsigned long timeoutMilliseconds):
					cpuSpeed(cpuSpeed), timerPrescaler(timerPrescaler), timeoutMilliseconds(timeoutMilliseconds),
					numberOfTimeouts(timeoutMilliseconds / 10)
    25a4:	80 e0       	ldi	r24, 0x00	; 0
    25a6:	94 e2       	ldi	r25, 0x24	; 36
    25a8:	a4 ef       	ldi	r26, 0xF4	; 244
    25aa:	b0 e0       	ldi	r27, 0x00	; 0
    25ac:	f8 01       	movw	r30, r16
    25ae:	80 83       	st	Z, r24
    25b0:	91 83       	std	Z+1, r25	; 0x01
    25b2:	a2 83       	std	Z+2, r26	; 0x02
    25b4:	b3 83       	std	Z+3, r27	; 0x03
    25b6:	80 e0       	ldi	r24, 0x00	; 0
    25b8:	94 e0       	ldi	r25, 0x04	; 4
    25ba:	95 83       	std	Z+5, r25	; 0x05
    25bc:	84 83       	std	Z+4, r24	; 0x04
    25be:	82 e3       	ldi	r24, 0x32	; 50
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	97 83       	std	Z+7, r25	; 0x07
    25c4:	86 83       	std	Z+6, r24	; 0x06
    25c6:	85 e0       	ldi	r24, 0x05	; 5
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	91 87       	std	Z+9, r25	; 0x09
    25cc:	80 87       	std	Z+8, r24	; 0x08
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, timer);//MOSTRECENT
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, true, timer); //latest 12/3/2014
    25ce:	8b e0       	ldi	r24, 0x0B	; 11
    25d0:	90 e0       	ldi	r25, 0x00	; 0
    25d2:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    25d6:	2c 01       	movw	r4, r24
					Timer *timer = NULL) :
				baudRate(baudRate),
				uartPort(uartPort),
				useDoubleSpeedMode(useDoubleSpeedMode),
				asyncReceiveTransmitData(asyncReceiveTransmitData),
				timer(timer)
    25d8:	82 e1       	ldi	r24, 0x12	; 18
    25da:	92 e0       	ldi	r25, 0x02	; 2
    25dc:	d2 01       	movw	r26, r4
    25de:	8d 93       	st	X+, r24
    25e0:	9c 93       	st	X, r25
    25e2:	80 e9       	ldi	r24, 0x90	; 144
    25e4:	90 ed       	ldi	r25, 0xD0	; 208
    25e6:	a3 e0       	ldi	r26, 0x03	; 3
    25e8:	b0 e0       	ldi	r27, 0x00	; 0
    25ea:	f2 01       	movw	r30, r4
    25ec:	82 83       	std	Z+2, r24	; 0x02
    25ee:	93 83       	std	Z+3, r25	; 0x03
    25f0:	a4 83       	std	Z+4, r26	; 0x04
    25f2:	b5 83       	std	Z+5, r27	; 0x05
    25f4:	16 82       	std	Z+6, r1	; 0x06
    25f6:	17 82       	std	Z+7, r1	; 0x07
    25f8:	81 e0       	ldi	r24, 0x01	; 1
    25fa:	80 87       	std	Z+8, r24	; 0x08
    25fc:	12 87       	std	Z+10, r17	; 0x0a
    25fe:	01 87       	std	Z+9, r16	; 0x09
    2600:	38 c0       	rjmp	.+112    	; 0x2672 <main+0x148>
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, false, timer);
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, NULL);
	}else if (model->CommunicationMethod() == SystemModel::Radio)
    2602:	81 30       	cpi	r24, 0x01	; 1
    2604:	a1 f5       	brne	.+104    	; 0x266e <main+0x144>
	{
		//serialDriverBaudRate = 57600;
		serialDriverBaudRate = 115200;
		//timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,75); //Good timeout when using the radio
		
		timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,200);//unfortunately for radio, the initial setup is a huge amount of data which takes a long time.
    2606:	8a e0       	ldi	r24, 0x0A	; 10
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    260e:	8c 01       	movw	r16, r24
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	94 e2       	ldi	r25, 0x24	; 36
    2614:	a4 ef       	ldi	r26, 0xF4	; 244
    2616:	b0 e0       	ldi	r27, 0x00	; 0
    2618:	f8 01       	movw	r30, r16
    261a:	80 83       	st	Z, r24
    261c:	91 83       	std	Z+1, r25	; 0x01
    261e:	a2 83       	std	Z+2, r26	; 0x02
    2620:	b3 83       	std	Z+3, r27	; 0x03
    2622:	80 e0       	ldi	r24, 0x00	; 0
    2624:	94 e0       	ldi	r25, 0x04	; 4
    2626:	95 83       	std	Z+5, r25	; 0x05
    2628:	84 83       	std	Z+4, r24	; 0x04
    262a:	88 ec       	ldi	r24, 0xC8	; 200
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	97 83       	std	Z+7, r25	; 0x07
    2630:	86 83       	std	Z+6, r24	; 0x06
    2632:	84 e1       	ldi	r24, 0x14	; 20
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	91 87       	std	Z+9, r25	; 0x09
    2638:	80 87       	std	Z+8, r24	; 0x08
			
		//Use a slower baud rate because the real helicopter uses the radio for communication
		//which is slower than USB.
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
    263a:	8b e0       	ldi	r24, 0x0B	; 11
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2642:	2c 01       	movw	r4, r24
    2644:	82 e1       	ldi	r24, 0x12	; 18
    2646:	92 e0       	ldi	r25, 0x02	; 2
    2648:	d2 01       	movw	r26, r4
    264a:	8d 93       	st	X+, r24
    264c:	9c 93       	st	X, r25
    264e:	80 e0       	ldi	r24, 0x00	; 0
    2650:	92 ec       	ldi	r25, 0xC2	; 194
    2652:	a1 e0       	ldi	r26, 0x01	; 1
    2654:	b0 e0       	ldi	r27, 0x00	; 0
    2656:	f2 01       	movw	r30, r4
    2658:	82 83       	std	Z+2, r24	; 0x02
    265a:	93 83       	std	Z+3, r25	; 0x03
    265c:	a4 83       	std	Z+4, r26	; 0x04
    265e:	b5 83       	std	Z+5, r27	; 0x05
    2660:	16 82       	std	Z+6, r1	; 0x06
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	87 83       	std	Z+7, r24	; 0x07
    2666:	80 87       	std	Z+8, r24	; 0x08
    2668:	12 87       	std	Z+10, r17	; 0x0a
    266a:	01 87       	std	Z+9, r16	; 0x09
    266c:	02 c0       	rjmp	.+4      	; 0x2672 <main+0x148>
	setupDefaultsandReferencePosition(model, pidController);
	
	//Create a driver for communicating with the Ground Control Station (GCS).
	//SerialDriver *serialDriver = new SerialDriver(57600, SerialDriver::Zero, timer, true, true);
	//SerialDriver *serialDriver = new SerialDriver(76800, SerialDriver::Zero, true);
	SerialDriver *serialDriver = NULL;
    266e:	41 2c       	mov	r4, r1
    2670:	51 2c       	mov	r5, r1
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
		
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, false, timer);
	}
	
	serialDriver->init();
    2672:	d2 01       	movw	r26, r4
    2674:	ed 91       	ld	r30, X+
    2676:	fc 91       	ld	r31, X
    2678:	04 80       	ldd	r0, Z+4	; 0x04
    267a:	f5 81       	ldd	r31, Z+5	; 0x05
    267c:	e0 2d       	mov	r30, r0
    267e:	c2 01       	movw	r24, r4
    2680:	19 95       	eicall
	//SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, false, gpsTimer);
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, gpsTimer);//LATEST
	
	//Don't care about gps timer anymore since it's only used on initialization. 
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, NULL);
	SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, true, false, NULL);
    2682:	8b e0       	ldi	r24, 0x0B	; 11
    2684:	90 e0       	ldi	r25, 0x00	; 0
    2686:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    268a:	9e 83       	std	Y+6, r25	; 0x06
    268c:	8d 83       	std	Y+5, r24	; 0x05
    268e:	82 e1       	ldi	r24, 0x12	; 18
    2690:	92 e0       	ldi	r25, 0x02	; 2
    2692:	ed 81       	ldd	r30, Y+5	; 0x05
    2694:	fe 81       	ldd	r31, Y+6	; 0x06
    2696:	91 83       	std	Z+1, r25	; 0x01
    2698:	80 83       	st	Z, r24
    269a:	80 e0       	ldi	r24, 0x00	; 0
    269c:	96 e9       	ldi	r25, 0x96	; 150
    269e:	a0 e0       	ldi	r26, 0x00	; 0
    26a0:	b0 e0       	ldi	r27, 0x00	; 0
    26a2:	82 83       	std	Z+2, r24	; 0x02
    26a4:	93 83       	std	Z+3, r25	; 0x03
    26a6:	a4 83       	std	Z+4, r26	; 0x04
    26a8:	b5 83       	std	Z+5, r27	; 0x05
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	86 83       	std	Z+6, r24	; 0x06
    26ae:	87 83       	std	Z+7, r24	; 0x07
    26b0:	10 86       	std	Z+8, r1	; 0x08
    26b2:	12 86       	std	Z+10, r1	; 0x0a
    26b4:	11 86       	std	Z+9, r1	; 0x09
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, false, gpsTimer);
	gpsSerialDriver->init();
    26b6:	cf 01       	movw	r24, r30
    26b8:	0e 94 b0 0b 	call	0x1760	; 0x1760 <_ZN10helicopter7drivers12SerialDriver4initEv>

	
	
	
	
	TWIDriver *twiDriver = new TWIDriver();
    26bc:	81 e0       	ldi	r24, 0x01	; 1
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    26c4:	9c 8b       	std	Y+20, r25	; 0x14
    26c6:	8b 8b       	std	Y+19, r24	; 0x13
	twiDriver->init();
    26c8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <_ZN10helicopter7drivers9TWIDriver4initEv>

	
	
	GroundControlStationInterface *gcsInterface = new GroundControlStationInterface(serialDriver);
    26cc:	82 e0       	ldi	r24, 0x02	; 2
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    26d4:	5c 01       	movw	r10, r24
				 * as receiving a byte.
				 * @param serialDriver the driver used to communicate with the serial port
				 * which is used to communicate with the Ground Control Station.
				 */
				GroundControlStationInterface(SerialDriver *serialDriver):
					serialDriver(serialDriver)
    26d6:	dc 01       	movw	r26, r24
    26d8:	4d 92       	st	X+, r4
    26da:	5c 92       	st	X, r5
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
    26dc:	f4 01       	movw	r30, r8
    26de:	83 81       	ldd	r24, Z+3	; 0x03
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;

	if (model->FlightMode() == SystemModel::RealFlightTest)
    26e0:	81 30       	cpi	r24, 0x01	; 1
    26e2:	a9 f5       	brne	.+106    	; 0x274e <main+0x224>
		barometerInitReadings = 1300;
		sensorInitReadings = 100;
		*/
		
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    26e4:	8c e0       	ldi	r24, 0x0C	; 12
    26e6:	90 e0       	ldi	r25, 0x00	; 0
    26e8:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    26ec:	9c 87       	std	Y+12, r25	; 0x0c
    26ee:	8b 87       	std	Y+11, r24	; 0x0b
    26f0:	0f 2e       	mov	r0, r31
    26f2:	f4 e6       	ldi	r31, 0x64	; 100
    26f4:	ef 2e       	mov	r14, r31
    26f6:	f1 2c       	mov	r15, r1
    26f8:	f0 2d       	mov	r31, r0
    26fa:	01 e0       	ldi	r16, 0x01	; 1
    26fc:	10 e0       	ldi	r17, 0x00	; 0
    26fe:	22 e0       	ldi	r18, 0x02	; 2
    2700:	a4 01       	movw	r20, r8
    2702:	b5 01       	movw	r22, r10
    2704:	0e 94 de 60 	call	0xc1bc	; 0xc1bc <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2708:	8e e0       	ldi	r24, 0x0E	; 14
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2710:	9a 83       	std	Y+2, r25	; 0x02
    2712:	89 83       	std	Y+1, r24	; 0x01
    2714:	0f 2e       	mov	r0, r31
    2716:	f4 e6       	ldi	r31, 0x64	; 100
    2718:	cf 2e       	mov	r12, r31
    271a:	d1 2c       	mov	r13, r1
    271c:	f0 2d       	mov	r31, r0
    271e:	e1 2c       	mov	r14, r1
    2720:	f1 2c       	mov	r15, r1
    2722:	91 01       	movw	r18, r2
    2724:	a4 01       	movw	r20, r8
    2726:	b5 01       	movw	r22, r10
    2728:	0e 94 93 5c 	call	0xb926	; 0xb926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    272c:	24 e6       	ldi	r18, 0x64	; 100
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	3c 8f       	std	Y+28, r19	; 0x1c
    2732:	2b 8f       	std	Y+27, r18	; 0x1b
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2734:	45 e0       	ldi	r20, 0x05	; 5
    2736:	50 e0       	ldi	r21, 0x00	; 0
    2738:	5e 8b       	std	Y+22, r21	; 0x16
    273a:	4d 8b       	std	Y+21, r20	; 0x15
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    273c:	80 e2       	ldi	r24, 0x20	; 32
    273e:	9e e4       	ldi	r25, 0x4E	; 78
    2740:	a0 e0       	ldi	r26, 0x00	; 0
    2742:	b0 e0       	ldi	r27, 0x00	; 0
    2744:	8f 8b       	std	Y+23, r24	; 0x17
    2746:	98 8f       	std	Y+24, r25	; 0x18
    2748:	a9 8f       	std	Y+25, r26	; 0x19
    274a:	ba 8f       	std	Y+26, r27	; 0x1a
    274c:	ba c0       	rjmp	.+372    	; 0x28c2 <main+0x398>
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
    274e:	83 30       	cpi	r24, 0x03	; 3
    2750:	a9 f5       	brne	.+106    	; 0x27bc <main+0x292>
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
		
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2752:	8c e0       	ldi	r24, 0x0C	; 12
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    275a:	9c 87       	std	Y+12, r25	; 0x0c
    275c:	8b 87       	std	Y+11, r24	; 0x0b
    275e:	0f 2e       	mov	r0, r31
    2760:	f4 e6       	ldi	r31, 0x64	; 100
    2762:	ef 2e       	mov	r14, r31
    2764:	f1 2c       	mov	r15, r1
    2766:	f0 2d       	mov	r31, r0
    2768:	01 e0       	ldi	r16, 0x01	; 1
    276a:	10 e0       	ldi	r17, 0x00	; 0
    276c:	22 e0       	ldi	r18, 0x02	; 2
    276e:	a4 01       	movw	r20, r8
    2770:	b5 01       	movw	r22, r10
    2772:	0e 94 de 60 	call	0xc1bc	; 0xc1bc <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2776:	8e e0       	ldi	r24, 0x0E	; 14
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    277e:	9a 83       	std	Y+2, r25	; 0x02
    2780:	89 83       	std	Y+1, r24	; 0x01
    2782:	0f 2e       	mov	r0, r31
    2784:	f4 e6       	ldi	r31, 0x64	; 100
    2786:	cf 2e       	mov	r12, r31
    2788:	d1 2c       	mov	r13, r1
    278a:	f0 2d       	mov	r31, r0
    278c:	e1 2c       	mov	r14, r1
    278e:	f1 2c       	mov	r15, r1
    2790:	91 01       	movw	r18, r2
    2792:	a4 01       	movw	r20, r8
    2794:	b5 01       	movw	r22, r10
    2796:	0e 94 93 5c 	call	0xb926	; 0xb926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
    279a:	a4 ef       	ldi	r26, 0xF4	; 244
    279c:	b1 e0       	ldi	r27, 0x01	; 1
    279e:	bc 8f       	std	Y+28, r27	; 0x1c
    27a0:	ab 8f       	std	Y+27, r26	; 0x1b
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
    27a2:	e8 ee       	ldi	r30, 0xE8	; 232
    27a4:	f3 e0       	ldi	r31, 0x03	; 3
    27a6:	fe 8b       	std	Y+22, r31	; 0x16
    27a8:	ed 8b       	std	Y+21, r30	; 0x15
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
    27aa:	24 e8       	ldi	r18, 0x84	; 132
    27ac:	33 e0       	ldi	r19, 0x03	; 3
    27ae:	40 e0       	ldi	r20, 0x00	; 0
    27b0:	50 e0       	ldi	r21, 0x00	; 0
    27b2:	2f 8b       	std	Y+23, r18	; 0x17
    27b4:	38 8f       	std	Y+24, r19	; 0x18
    27b6:	49 8f       	std	Y+25, r20	; 0x19
    27b8:	5a 8f       	std	Y+26, r21	; 0x1a
    27ba:	83 c0       	rjmp	.+262    	; 0x28c2 <main+0x398>
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
	}else if (model->FlightMode() == SystemModel::SimulatedFlight)
    27bc:	81 11       	cpse	r24, r1
    27be:	36 c0       	rjmp	.+108    	; 0x282c <main+0x302>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05)); //latest 12/3/2014
    27c0:	8c e0       	ldi	r24, 0x0C	; 12
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    27c8:	9c 87       	std	Y+12, r25	; 0x0c
    27ca:	8b 87       	std	Y+11, r24	; 0x0b
    27cc:	0f 2e       	mov	r0, r31
    27ce:	fa e0       	ldi	r31, 0x0A	; 10
    27d0:	ef 2e       	mov	r14, r31
    27d2:	f1 2c       	mov	r15, r1
    27d4:	f0 2d       	mov	r31, r0
    27d6:	01 e0       	ldi	r16, 0x01	; 1
    27d8:	10 e0       	ldi	r17, 0x00	; 0
    27da:	20 e0       	ldi	r18, 0x00	; 0
    27dc:	a4 01       	movw	r20, r8
    27de:	b5 01       	movw	r22, r10
    27e0:	0e 94 de 60 	call	0xc1bc	; 0xc1bc <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    27e4:	8e e0       	ldi	r24, 0x0E	; 14
    27e6:	90 e0       	ldi	r25, 0x00	; 0
    27e8:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    27ec:	9a 83       	std	Y+2, r25	; 0x02
    27ee:	89 83       	std	Y+1, r24	; 0x01
    27f0:	0f 2e       	mov	r0, r31
    27f2:	fa e0       	ldi	r31, 0x0A	; 10
    27f4:	cf 2e       	mov	r12, r31
    27f6:	d1 2c       	mov	r13, r1
    27f8:	f0 2d       	mov	r31, r0
    27fa:	e1 2c       	mov	r14, r1
    27fc:	f1 2c       	mov	r15, r1
    27fe:	00 e0       	ldi	r16, 0x00	; 0
    2800:	91 01       	movw	r18, r2
    2802:	a4 01       	movw	r20, r8
    2804:	b5 01       	movw	r22, r10
    2806:	0e 94 93 5c 	call	0xb926	; 0xb926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    280a:	44 e6       	ldi	r20, 0x64	; 100
    280c:	50 e0       	ldi	r21, 0x00	; 0
    280e:	5c 8f       	std	Y+28, r21	; 0x1c
    2810:	4b 8f       	std	Y+27, r20	; 0x1b
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2812:	85 e0       	ldi	r24, 0x05	; 5
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	9e 8b       	std	Y+22, r25	; 0x16
    2818:	8d 8b       	std	Y+21, r24	; 0x15
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    281a:	20 e2       	ldi	r18, 0x20	; 32
    281c:	3e e4       	ldi	r19, 0x4E	; 78
    281e:	40 e0       	ldi	r20, 0x00	; 0
    2820:	50 e0       	ldi	r21, 0x00	; 0
    2822:	2f 8b       	std	Y+23, r18	; 0x17
    2824:	38 8f       	std	Y+24, r19	; 0x18
    2826:	49 8f       	std	Y+25, r20	; 0x19
    2828:	5a 8f       	std	Y+26, r21	; 0x1a
    282a:	4b c0       	rjmp	.+150    	; 0x28c2 <main+0x398>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
		//simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
	}else if (model->FlightMode() == SystemModel::HardwareInLoopSimulatedFlight)
    282c:	82 30       	cpi	r24, 0x02	; 2
    282e:	a9 f5       	brne	.+106    	; 0x289a <main+0x370>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
    2830:	8c e0       	ldi	r24, 0x0C	; 12
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2838:	9c 87       	std	Y+12, r25	; 0x0c
    283a:	8b 87       	std	Y+11, r24	; 0x0b
    283c:	0f 2e       	mov	r0, r31
    283e:	fa e0       	ldi	r31, 0x0A	; 10
    2840:	ef 2e       	mov	r14, r31
    2842:	f1 2c       	mov	r15, r1
    2844:	f0 2d       	mov	r31, r0
    2846:	01 e0       	ldi	r16, 0x01	; 1
    2848:	10 e0       	ldi	r17, 0x00	; 0
    284a:	21 e0       	ldi	r18, 0x01	; 1
    284c:	a4 01       	movw	r20, r8
    284e:	b5 01       	movw	r22, r10
    2850:	0e 94 de 60 	call	0xc1bc	; 0xc1bc <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    2854:	8e e0       	ldi	r24, 0x0E	; 14
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    285c:	9a 83       	std	Y+2, r25	; 0x02
    285e:	89 83       	std	Y+1, r24	; 0x01
    2860:	0f 2e       	mov	r0, r31
    2862:	fa e0       	ldi	r31, 0x0A	; 10
    2864:	cf 2e       	mov	r12, r31
    2866:	d1 2c       	mov	r13, r1
    2868:	f0 2d       	mov	r31, r0
    286a:	e1 2c       	mov	r14, r1
    286c:	f1 2c       	mov	r15, r1
    286e:	91 01       	movw	r18, r2
    2870:	a4 01       	movw	r20, r8
    2872:	b5 01       	movw	r22, r10
    2874:	0e 94 93 5c 	call	0xb926	; 0xb926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    2878:	44 e6       	ldi	r20, 0x64	; 100
    287a:	50 e0       	ldi	r21, 0x00	; 0
    287c:	5c 8f       	std	Y+28, r21	; 0x1c
    287e:	4b 8f       	std	Y+27, r20	; 0x1b
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2880:	85 e0       	ldi	r24, 0x05	; 5
    2882:	90 e0       	ldi	r25, 0x00	; 0
    2884:	9e 8b       	std	Y+22, r25	; 0x16
    2886:	8d 8b       	std	Y+21, r24	; 0x15
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2888:	20 e2       	ldi	r18, 0x20	; 32
    288a:	3e e4       	ldi	r19, 0x4E	; 78
    288c:	40 e0       	ldi	r20, 0x00	; 0
    288e:	50 e0       	ldi	r21, 0x00	; 0
    2890:	2f 8b       	std	Y+23, r18	; 0x17
    2892:	38 8f       	std	Y+24, r19	; 0x18
    2894:	49 8f       	std	Y+25, r20	; 0x19
    2896:	5a 8f       	std	Y+26, r21	; 0x1a
    2898:	14 c0       	rjmp	.+40     	; 0x28c2 <main+0x398>
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    289a:	44 e6       	ldi	r20, 0x64	; 100
    289c:	50 e0       	ldi	r21, 0x00	; 0
    289e:	5c 8f       	std	Y+28, r21	; 0x1c
    28a0:	4b 8f       	std	Y+27, r20	; 0x1b
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    28a2:	85 e0       	ldi	r24, 0x05	; 5
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	9e 8b       	std	Y+22, r25	; 0x16
    28a8:	8d 8b       	std	Y+21, r24	; 0x15
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    28aa:	20 e2       	ldi	r18, 0x20	; 32
    28ac:	3e e4       	ldi	r19, 0x4E	; 78
    28ae:	40 e0       	ldi	r20, 0x00	; 0
    28b0:	50 e0       	ldi	r21, 0x00	; 0
    28b2:	2f 8b       	std	Y+23, r18	; 0x17
    28b4:	38 8f       	std	Y+24, r19	; 0x18
    28b6:	49 8f       	std	Y+25, r20	; 0x19
    28b8:	5a 8f       	std	Y+26, r21	; 0x1a
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
    28ba:	1c 86       	std	Y+12, r1	; 0x0c
    28bc:	1b 86       	std	Y+11, r1	; 0x0b
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
    28be:	1a 82       	std	Y+2, r1	; 0x02
    28c0:	19 82       	std	Y+1, r1	; 0x01
SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,0, SCHEDULER_TICK_FREQUENCY_HZ);//execute 1 hz
TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, 0, SCHEDULER_TICK_FREQUENCY_HZ);
*/
	
	
	FlashLEDTask *flashTask = new FlashLEDTask(2, SCHEDULER_TICK_FREQUENCY_HZ);//starting at tick 2, execute once a second
    28c2:	8a e0       	ldi	r24, 0x0A	; 10
    28c4:	90 e0       	ldi	r25, 0x00	; 0
    28c6:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    28ca:	9e 8f       	std	Y+30, r25	; 0x1e
    28cc:	8d 8f       	std	Y+29, r24	; 0x1d
			public:

			FlashLEDTask (int delay, int period, int ledToBlink = BLUELED) : 
				Task(delay, period),
				isOff(false),
				ledToBlink(ledToBlink)
    28ce:	48 ec       	ldi	r20, 0xC8	; 200
    28d0:	50 e0       	ldi	r21, 0x00	; 0
    28d2:	62 e0       	ldi	r22, 0x02	; 2
    28d4:	70 e0       	ldi	r23, 0x00	; 0
    28d6:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    28da:	8a e2       	ldi	r24, 0x2A	; 42
    28dc:	92 e0       	ldi	r25, 0x02	; 2
    28de:	ad 8d       	ldd	r26, Y+29	; 0x1d
    28e0:	be 8d       	ldd	r27, Y+30	; 0x1e
    28e2:	11 96       	adiw	r26, 0x01	; 1
    28e4:	9c 93       	st	X, r25
    28e6:	8e 93       	st	-X, r24
    28e8:	17 96       	adiw	r26, 0x07	; 7
    28ea:	1c 92       	st	X, r1
    28ec:	17 97       	sbiw	r26, 0x07	; 7
    28ee:	83 e0       	ldi	r24, 0x03	; 3
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	19 96       	adiw	r26, 0x09	; 9
    28f4:	9c 93       	st	X, r25
    28f6:	8e 93       	st	-X, r24
    28f8:	18 97       	sbiw	r26, 0x08	; 8
		
//	SensorProcessingTask *sensorProcessingTask = new SensorProcessingTask(model, 5, 4);
		
	//execute the pid outer loop at the PID_OUTER_LOOP_PERIOD rate. The division is to convert the period into ticks for the scheduler.

	PIDOuterLoopTask *pidOuterLoop = new PIDOuterLoopTask(pidController, 3, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_OUTER_LOOP_PERIOD));
    28fa:	89 e0       	ldi	r24, 0x09	; 9
    28fc:	90 e0       	ldi	r25, 0x00	; 0
    28fe:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2902:	9c a3       	std	Y+36, r25	; 0x24
    2904:	8b a3       	std	Y+35, r24	; 0x23
    2906:	2a e0       	ldi	r18, 0x0A	; 10
    2908:	30 e0       	ldi	r19, 0x00	; 0
    290a:	43 e0       	ldi	r20, 0x03	; 3
    290c:	50 e0       	ldi	r21, 0x00	; 0
    290e:	b1 01       	movw	r22, r2
    2910:	0e 94 41 53 	call	0xa682	; 0xa682 <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
    2914:	89 e0       	ldi	r24, 0x09	; 9
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    291c:	9e a3       	std	Y+38, r25	; 0x26
    291e:	8d a3       	std	Y+37, r24	; 0x25
    2920:	24 e0       	ldi	r18, 0x04	; 4
    2922:	30 e0       	ldi	r19, 0x00	; 0
    2924:	44 e0       	ldi	r20, 0x04	; 4
    2926:	50 e0       	ldi	r21, 0x00	; 0
    2928:	b1 01       	movw	r22, r2
    292a:	0e 94 18 53 	call	0xa630	; 0xa630 <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>
	//float barometerSensorReadPeriod = 1/50.0f;
	float simulatorSensorReadPeriod = barometerSensorReadPeriod;
	
	float sensorReadPeriod = 0;
		
	if (model->SensorInput() == SystemModel::SimulatedSensors)
    292e:	f4 01       	movw	r30, r8
    2930:	84 81       	ldd	r24, Z+4	; 0x04
    2932:	81 11       	cpse	r24, r1
    2934:	13 c0       	rjmp	.+38     	; 0x295c <main+0x432>
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
    2936:	0f 2e       	mov	r0, r31
    2938:	fd ec       	ldi	r31, 0xCD	; 205
    293a:	cf 2e       	mov	r12, r31
    293c:	fc ec       	ldi	r31, 0xCC	; 204
    293e:	df 2e       	mov	r13, r31
    2940:	fc e4       	ldi	r31, 0x4C	; 76
    2942:	ef 2e       	mov	r14, r31
    2944:	fd e3       	ldi	r31, 0x3D	; 61
    2946:	ff 2e       	mov	r15, r31
    2948:	f0 2d       	mov	r31, r0
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
	float newBarometerSensorReadPeriod = barometerSensorReadPeriod;// how frequently NEW barometer sensor data is received. 
    294a:	cf 86       	std	Y+15, r12	; 0x0f
    294c:	d8 8a       	std	Y+16, r13	; 0x10
    294e:	e9 8a       	std	Y+17, r14	; 0x11
    2950:	fa 8a       	std	Y+18, r15	; 0x12
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
    2952:	cf 82       	std	Y+7, r12	; 0x07
    2954:	d8 86       	std	Y+8, r13	; 0x08
    2956:	e9 86       	std	Y+9, r14	; 0x09
    2958:	fa 86       	std	Y+10, r15	; 0x0a
    295a:	1a c0       	rjmp	.+52     	; 0x2990 <main+0x466>
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
		sensorReadPeriod = GYRO_SENSOR_READ_PERIOD;
    295c:	0f 2e       	mov	r0, r31
    295e:	f5 e0       	ldi	r31, 0x05	; 5
    2960:	cf 2e       	mov	r12, r31
    2962:	ff e2       	ldi	r31, 0x2F	; 47
    2964:	df 2e       	mov	r13, r31
    2966:	f7 e2       	ldi	r31, 0x27	; 39
    2968:	ef 2e       	mov	r14, r31
    296a:	fc e3       	ldi	r31, 0x3C	; 60
    296c:	ff 2e       	mov	r15, r31
    296e:	f0 2d       	mov	r31, r0
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
    2970:	20 e9       	ldi	r18, 0x90	; 144
    2972:	32 ec       	ldi	r19, 0xC2	; 194
    2974:	45 e7       	ldi	r20, 0x75	; 117
    2976:	5d e3       	ldi	r21, 0x3D	; 61
    2978:	2f 87       	std	Y+15, r18	; 0x0f
    297a:	38 8b       	std	Y+16, r19	; 0x10
    297c:	49 8b       	std	Y+17, r20	; 0x11
    297e:	5a 8b       	std	Y+18, r21	; 0x12
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    2980:	8a e0       	ldi	r24, 0x0A	; 10
    2982:	97 ed       	ldi	r25, 0xD7	; 215
    2984:	a3 ea       	ldi	r26, 0xA3	; 163
    2986:	bc e3       	ldi	r27, 0x3C	; 60
    2988:	8f 83       	std	Y+7, r24	; 0x07
    298a:	98 87       	std	Y+8, r25	; 0x08
    298c:	a9 87       	std	Y+9, r26	; 0x09
    298e:	ba 87       	std	Y+10, r27	; 0x0a
	}
	
		
	//AHRS *ahrs = new AHRS(GYRO_SENSOR_READ_PERIOD);
	//AHRS *ahrs = new AHRS(simulatorSensorReadPeriod); //for simulator angular velocity reads.
	AHRS *ahrs = new AHRS(sensorReadPeriod);
    2990:	80 e7       	ldi	r24, 0x70	; 112
    2992:	90 e0       	ldi	r25, 0x00	; 0
    2994:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2998:	5c 01       	movw	r10, r24
					yawRads(0),
					pitchRads(0),
					rollRads(0),
					linearAccelerationXMss(0),
					linearAccelerationYMss(0),
					linearAccelerationZMss(0)	
    299a:	dc 01       	movw	r26, r24
    299c:	cd 92       	st	X+, r12
    299e:	dd 92       	st	X+, r13
    29a0:	ed 92       	st	X+, r14
    29a2:	fc 92       	st	X, r15
    29a4:	13 97       	sbiw	r26, 0x03	; 3
    29a6:	fc 01       	movw	r30, r24
    29a8:	14 82       	std	Z+4, r1	; 0x04
    29aa:	15 82       	std	Z+5, r1	; 0x05
    29ac:	16 82       	std	Z+6, r1	; 0x06
    29ae:	17 82       	std	Z+7, r1	; 0x07
    29b0:	18 96       	adiw	r26, 0x08	; 8
    29b2:	1d 92       	st	X+, r1
    29b4:	1d 92       	st	X+, r1
    29b6:	1d 92       	st	X+, r1
    29b8:	1c 92       	st	X, r1
    29ba:	1b 97       	sbiw	r26, 0x0b	; 11
    29bc:	14 86       	std	Z+12, r1	; 0x0c
    29be:	15 86       	std	Z+13, r1	; 0x0d
    29c0:	16 86       	std	Z+14, r1	; 0x0e
    29c2:	17 86       	std	Z+15, r1	; 0x0f
    29c4:	50 96       	adiw	r26, 0x10	; 16
    29c6:	1d 92       	st	X+, r1
    29c8:	1d 92       	st	X+, r1
    29ca:	1d 92       	st	X+, r1
    29cc:	1c 92       	st	X, r1
    29ce:	53 97       	sbiw	r26, 0x13	; 19
    29d0:	14 8a       	std	Z+20, r1	; 0x14
    29d2:	15 8a       	std	Z+21, r1	; 0x15
    29d4:	16 8a       	std	Z+22, r1	; 0x16
    29d6:	17 8a       	std	Z+23, r1	; 0x17
    29d8:	58 96       	adiw	r26, 0x18	; 24
    29da:	1d 92       	st	X+, r1
    29dc:	1d 92       	st	X+, r1
    29de:	1d 92       	st	X+, r1
    29e0:	1c 92       	st	X, r1
    29e2:	5b 97       	sbiw	r26, 0x1b	; 27
    29e4:	14 8e       	std	Z+28, r1	; 0x1c
    29e6:	15 8e       	std	Z+29, r1	; 0x1d
    29e8:	16 8e       	std	Z+30, r1	; 0x1e
    29ea:	17 8e       	std	Z+31, r1	; 0x1f
    29ec:	90 96       	adiw	r26, 0x20	; 32
    29ee:	1d 92       	st	X+, r1
    29f0:	1d 92       	st	X+, r1
    29f2:	1d 92       	st	X+, r1
    29f4:	1c 92       	st	X, r1
    29f6:	93 97       	sbiw	r26, 0x23	; 35
    29f8:	14 a2       	std	Z+36, r1	; 0x24
    29fa:	15 a2       	std	Z+37, r1	; 0x25
    29fc:	16 a2       	std	Z+38, r1	; 0x26
    29fe:	17 a2       	std	Z+39, r1	; 0x27
    2a00:	98 96       	adiw	r26, 0x28	; 40
    2a02:	1d 92       	st	X+, r1
    2a04:	1d 92       	st	X+, r1
    2a06:	1d 92       	st	X+, r1
    2a08:	1c 92       	st	X, r1
    2a0a:	9b 97       	sbiw	r26, 0x2b	; 43
    2a0c:	14 a6       	std	Z+44, r1	; 0x2c
    2a0e:	15 a6       	std	Z+45, r1	; 0x2d
    2a10:	16 a6       	std	Z+46, r1	; 0x2e
    2a12:	17 a6       	std	Z+47, r1	; 0x2f
    2a14:	d0 96       	adiw	r26, 0x30	; 48
    2a16:	1d 92       	st	X+, r1
    2a18:	1d 92       	st	X+, r1
    2a1a:	1d 92       	st	X+, r1
    2a1c:	1c 92       	st	X, r1
    2a1e:	d3 97       	sbiw	r26, 0x33	; 51
    2a20:	14 aa       	std	Z+52, r1	; 0x34
    2a22:	15 aa       	std	Z+53, r1	; 0x35
    2a24:	16 aa       	std	Z+54, r1	; 0x36
    2a26:	17 aa       	std	Z+55, r1	; 0x37
    2a28:	d8 96       	adiw	r26, 0x38	; 56
    2a2a:	1d 92       	st	X+, r1
    2a2c:	1d 92       	st	X+, r1
    2a2e:	1d 92       	st	X+, r1
    2a30:	1c 92       	st	X, r1
    2a32:	db 97       	sbiw	r26, 0x3b	; 59
    2a34:	14 ae       	std	Z+60, r1	; 0x3c
    2a36:	15 ae       	std	Z+61, r1	; 0x3d
    2a38:	16 ae       	std	Z+62, r1	; 0x3e
    2a3a:	17 ae       	std	Z+63, r1	; 0x3f
				{
					/**
					 * Setup initial state of the DCM matrix with initial unit vectors
					 * {{1,0,0},{0,1,0},{0,0,-1}}
					 */
					dcm[0][0] = 1;
    2a3c:	e0 5c       	subi	r30, 0xC0	; 192
    2a3e:	ff 4f       	sbci	r31, 0xFF	; 255
    2a40:	80 e0       	ldi	r24, 0x00	; 0
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	a0 e8       	ldi	r26, 0x80	; 128
    2a46:	bf e3       	ldi	r27, 0x3F	; 63
    2a48:	80 83       	st	Z, r24
    2a4a:	91 83       	std	Z+1, r25	; 0x01
    2a4c:	a2 83       	std	Z+2, r26	; 0x02
    2a4e:	b3 83       	std	Z+3, r27	; 0x03
					dcm[0][1] = 0;
    2a50:	34 96       	adiw	r30, 0x04	; 4
    2a52:	10 82       	st	Z, r1
    2a54:	11 82       	std	Z+1, r1	; 0x01
    2a56:	12 82       	std	Z+2, r1	; 0x02
    2a58:	13 82       	std	Z+3, r1	; 0x03
					dcm[0][2] = 0;
    2a5a:	34 96       	adiw	r30, 0x04	; 4
    2a5c:	10 82       	st	Z, r1
    2a5e:	11 82       	std	Z+1, r1	; 0x01
    2a60:	12 82       	std	Z+2, r1	; 0x02
    2a62:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][0] = 0;
    2a64:	34 96       	adiw	r30, 0x04	; 4
    2a66:	10 82       	st	Z, r1
    2a68:	11 82       	std	Z+1, r1	; 0x01
    2a6a:	12 82       	std	Z+2, r1	; 0x02
    2a6c:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][1] = 1;
    2a6e:	34 96       	adiw	r30, 0x04	; 4
    2a70:	80 83       	st	Z, r24
    2a72:	91 83       	std	Z+1, r25	; 0x01
    2a74:	a2 83       	std	Z+2, r26	; 0x02
    2a76:	b3 83       	std	Z+3, r27	; 0x03
					dcm[1][2] = 0;
    2a78:	34 96       	adiw	r30, 0x04	; 4
    2a7a:	10 82       	st	Z, r1
    2a7c:	11 82       	std	Z+1, r1	; 0x01
    2a7e:	12 82       	std	Z+2, r1	; 0x02
    2a80:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][0] = 0;
    2a82:	34 96       	adiw	r30, 0x04	; 4
    2a84:	10 82       	st	Z, r1
    2a86:	11 82       	std	Z+1, r1	; 0x01
    2a88:	12 82       	std	Z+2, r1	; 0x02
    2a8a:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][1] = 0;
    2a8c:	34 96       	adiw	r30, 0x04	; 4
    2a8e:	10 82       	st	Z, r1
    2a90:	11 82       	std	Z+1, r1	; 0x01
    2a92:	12 82       	std	Z+2, r1	; 0x02
    2a94:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][2] = 1;
    2a96:	34 96       	adiw	r30, 0x04	; 4
    2a98:	80 83       	st	Z, r24
    2a9a:	91 83       	std	Z+1, r25	; 0x01
    2a9c:	a2 83       	std	Z+2, r26	; 0x02
    2a9e:	b3 83       	std	Z+3, r27	; 0x03
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
			void Ahrs(AHRS *val) {ahrs = val;}
    2aa0:	d4 01       	movw	r26, r8
    2aa2:	ad 92       	st	X+, r10
    2aa4:	bc 92       	st	X, r11
	NavigationTask *navTask = NULL;
	PVNavigationTask *pvNavTask = NULL;
	

	//navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * sensorReadPeriod)); //run at 98 hz.
	navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * .01f)); //run at 100 hz.
    2aa6:	8b e1       	ldi	r24, 0x1B	; 27
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2aae:	98 a3       	std	Y+32, r25	; 0x20
    2ab0:	8f 8f       	std	Y+31, r24	; 0x1f
    2ab2:	68 94       	set
    2ab4:	cc 24       	eor	r12, r12
    2ab6:	c1 f8       	bld	r12, 1
    2ab8:	d1 2c       	mov	r13, r1
    2aba:	0f 2e       	mov	r0, r31
    2abc:	f5 e0       	ldi	r31, 0x05	; 5
    2abe:	ef 2e       	mov	r14, r31
    2ac0:	f1 2c       	mov	r15, r1
    2ac2:	f0 2d       	mov	r31, r0
    2ac4:	84 01       	movw	r16, r8
    2ac6:	95 01       	movw	r18, r10
    2ac8:	4f 81       	ldd	r20, Y+7	; 0x07
    2aca:	58 85       	ldd	r21, Y+8	; 0x08
    2acc:	69 85       	ldd	r22, Y+9	; 0x09
    2ace:	7a 85       	ldd	r23, Y+10	; 0x0a
    2ad0:	0e 94 bf 52 	call	0xa57e	; 0xa57e <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>
	pvNavTask = new PVNavigationTask(newBarometerSensorReadPeriod, ahrs, model, 6, (SCHEDULER_TICK_FREQUENCY_HZ * barometerSensorReadPeriod)); //run at 50 hz
    2ad4:	8f e0       	ldi	r24, 0x0F	; 15
    2ad6:	90 e0       	ldi	r25, 0x00	; 0
    2ad8:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2adc:	9a a3       	std	Y+34, r25	; 0x22
    2ade:	89 a3       	std	Y+33, r24	; 0x21
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	48 e4       	ldi	r20, 0x48	; 72
    2ae6:	53 e4       	ldi	r21, 0x43	; 67
    2ae8:	6f 81       	ldd	r22, Y+7	; 0x07
    2aea:	78 85       	ldd	r23, Y+8	; 0x08
    2aec:	89 85       	ldd	r24, Y+9	; 0x09
    2aee:	9a 85       	ldd	r25, Y+10	; 0x0a
    2af0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    2af4:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    2af8:	6b 01       	movw	r12, r22
    2afa:	0f 2e       	mov	r0, r31
    2afc:	f6 e0       	ldi	r31, 0x06	; 6
    2afe:	ef 2e       	mov	r14, r31
    2b00:	f1 2c       	mov	r15, r1
    2b02:	f0 2d       	mov	r31, r0
    2b04:	95 01       	movw	r18, r10
    2b06:	4f 85       	ldd	r20, Y+15	; 0x0f
    2b08:	58 89       	ldd	r21, Y+16	; 0x10
    2b0a:	69 89       	ldd	r22, Y+17	; 0x11
    2b0c:	7a 89       	ldd	r23, Y+18	; 0x12
    2b0e:	89 a1       	ldd	r24, Y+33	; 0x21
    2b10:	9a a1       	ldd	r25, Y+34	; 0x22
    2b12:	0e 94 33 55 	call	0xaa66	; 0xaa66 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>



	SPIDriver *spiDriver = new SPIDriver();
    2b16:	81 e0       	ldi	r24, 0x01	; 1
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2b1e:	8c 01       	movw	r16, r24
				SLAVE_SELECT_LINE ssLine;
			
			public: 
			
				SPIDriver(SLAVE_SELECT_LINE ssLine = SS_B):
					ssLine(ssLine)
    2b20:	21 e0       	ldi	r18, 0x01	; 1
    2b22:	fc 01       	movw	r30, r24
    2b24:	20 83       	st	Z, r18
	spiDriver->init();
    2b26:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	SPIDriver *baroSpiDriver = new SPIDriver(SPIDriver::SS_G);
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2b32:	98 87       	std	Y+8, r25	; 0x08
    2b34:	8f 83       	std	Y+7, r24	; 0x07
    2b36:	82 e0       	ldi	r24, 0x02	; 2
    2b38:	af 81       	ldd	r26, Y+7	; 0x07
    2b3a:	b8 85       	ldd	r27, Y+8	; 0x08
    2b3c:	8c 93       	st	X, r24
	baroSpiDriver->init();
    2b3e:	cd 01       	movw	r24, r26
    2b40:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	IMUSensor *imuSensor = new IMUSensor(spiDriver);
    2b44:	88 e5       	ldi	r24, 0x58	; 88
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2b4c:	5c 01       	movw	r10, r24
					frdAccZMss(0),
					frdGyroXRs(0),
					frdGyroYRs(0),
					frdGyroZRs(0),
					hasBeenRead(true),
					missedRead(false)
    2b4e:	fc 01       	movw	r30, r24
    2b50:	15 a3       	std	Z+37, r17	; 0x25
    2b52:	04 a3       	std	Z+36, r16	; 0x24
    2b54:	17 a2       	std	Z+39, r1	; 0x27
    2b56:	16 a2       	std	Z+38, r1	; 0x26
    2b58:	11 a6       	std	Z+41, r1	; 0x29
    2b5a:	10 a6       	std	Z+40, r1	; 0x28
    2b5c:	13 a6       	std	Z+43, r1	; 0x2b
    2b5e:	12 a6       	std	Z+42, r1	; 0x2a
    2b60:	15 a6       	std	Z+45, r1	; 0x2d
    2b62:	14 a6       	std	Z+44, r1	; 0x2c
    2b64:	17 a6       	std	Z+47, r1	; 0x2f
    2b66:	16 a6       	std	Z+46, r1	; 0x2e
    2b68:	11 aa       	std	Z+49, r1	; 0x31
    2b6a:	10 aa       	std	Z+48, r1	; 0x30
    2b6c:	12 aa       	std	Z+50, r1	; 0x32
    2b6e:	13 aa       	std	Z+51, r1	; 0x33
    2b70:	14 aa       	std	Z+52, r1	; 0x34
    2b72:	15 aa       	std	Z+53, r1	; 0x35
    2b74:	16 aa       	std	Z+54, r1	; 0x36
    2b76:	17 aa       	std	Z+55, r1	; 0x37
    2b78:	10 ae       	std	Z+56, r1	; 0x38
    2b7a:	11 ae       	std	Z+57, r1	; 0x39
    2b7c:	12 ae       	std	Z+58, r1	; 0x3a
    2b7e:	13 ae       	std	Z+59, r1	; 0x3b
    2b80:	14 ae       	std	Z+60, r1	; 0x3c
    2b82:	15 ae       	std	Z+61, r1	; 0x3d
    2b84:	fe 96       	adiw	r30, 0x3e	; 62
    2b86:	10 82       	st	Z, r1
    2b88:	11 82       	std	Z+1, r1	; 0x01
    2b8a:	12 82       	std	Z+2, r1	; 0x02
    2b8c:	13 82       	std	Z+3, r1	; 0x03
    2b8e:	34 96       	adiw	r30, 0x04	; 4
    2b90:	10 82       	st	Z, r1
    2b92:	11 82       	std	Z+1, r1	; 0x01
    2b94:	12 82       	std	Z+2, r1	; 0x02
    2b96:	13 82       	std	Z+3, r1	; 0x03
    2b98:	34 96       	adiw	r30, 0x04	; 4
    2b9a:	10 82       	st	Z, r1
    2b9c:	11 82       	std	Z+1, r1	; 0x01
    2b9e:	12 82       	std	Z+2, r1	; 0x02
    2ba0:	13 82       	std	Z+3, r1	; 0x03
    2ba2:	34 96       	adiw	r30, 0x04	; 4
    2ba4:	b1 e0       	ldi	r27, 0x01	; 1
    2ba6:	b0 83       	st	Z, r27
    2ba8:	31 96       	adiw	r30, 0x01	; 1
    2baa:	10 82       	st	Z, r1
					/**
					 * Create a rotation matrix to rotate the accelerometer sensor data by
					 * 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
					 * clockwise on the Z axis.
					 */
					memset(imuRFUToFRDRotationMatrix,0,sizeof(imuRFUToFRDRotationMatrix));
    2bac:	84 e2       	ldi	r24, 0x24	; 36
    2bae:	f5 01       	movw	r30, r10
    2bb0:	11 92       	st	Z+, r1
    2bb2:	8a 95       	dec	r24
    2bb4:	e9 f7       	brne	.-6      	; 0x2bb0 <main+0x686>
					
					MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, (M_PI/2), imuRFUToFRDRotationMatrix);
    2bb6:	65 01       	movw	r12, r10
    2bb8:	1b ed       	ldi	r17, 0xDB	; 219
    2bba:	e1 2e       	mov	r14, r17
    2bbc:	1f e0       	ldi	r17, 0x0F	; 15
    2bbe:	f1 2e       	mov	r15, r17
    2bc0:	09 ec       	ldi	r16, 0xC9	; 201
    2bc2:	1f e3       	ldi	r17, 0x3F	; 63
    2bc4:	20 e0       	ldi	r18, 0x00	; 0
    2bc6:	30 e0       	ldi	r19, 0x00	; 0
    2bc8:	a9 01       	movw	r20, r18
    2bca:	6b ed       	ldi	r22, 0xDB	; 219
    2bcc:	7f e0       	ldi	r23, 0x0F	; 15
    2bce:	89 e4       	ldi	r24, 0x49	; 73
    2bd0:	90 e4       	ldi	r25, 0x40	; 64
    2bd2:	0e 94 8c 63 	call	0xc718	; 0xc718 <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
					
					gyroOffsets[0] = 0;
    2bd6:	f5 01       	movw	r30, r10
    2bd8:	e4 5b       	subi	r30, 0xB4	; 180
    2bda:	ff 4f       	sbci	r31, 0xFF	; 255
    2bdc:	10 82       	st	Z, r1
    2bde:	11 82       	std	Z+1, r1	; 0x01
    2be0:	12 82       	std	Z+2, r1	; 0x02
    2be2:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[1] = 0;
    2be4:	34 96       	adiw	r30, 0x04	; 4
    2be6:	10 82       	st	Z, r1
    2be8:	11 82       	std	Z+1, r1	; 0x01
    2bea:	12 82       	std	Z+2, r1	; 0x02
    2bec:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[2] = 0;
    2bee:	34 96       	adiw	r30, 0x04	; 4
    2bf0:	10 82       	st	Z, r1
    2bf2:	11 82       	std	Z+1, r1	; 0x01
    2bf4:	12 82       	std	Z+2, r1	; 0x02
    2bf6:	13 82       	std	Z+3, r1	; 0x03
	imuSensor->init();
    2bf8:	c5 01       	movw	r24, r10
    2bfa:	0e 94 e1 4a 	call	0x95c2	; 0x95c2 <_ZN10helicopter7sensors9IMUSensor4initEv>

	GPSSensor *gpsSensor = new GPSSensor(gpsSerialDriver);
    2bfe:	8b e2       	ldi	r24, 0x2B	; 43
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2c06:	3c 01       	movw	r6, r24
					positionAccuracyEstimateEcefCm (0),
					xVEcefCms(0),
					yVEcefCms(0),
					zVEcefCms(0),
					velocityAccuracyEstimateEcefCms (0),
					positionFixStatus(INVALID)
    2c08:	ed 81       	ldd	r30, Y+5	; 0x05
    2c0a:	fe 81       	ldd	r31, Y+6	; 0x06
    2c0c:	dc 01       	movw	r26, r24
    2c0e:	11 96       	adiw	r26, 0x01	; 1
    2c10:	fc 93       	st	X, r31
    2c12:	ee 93       	st	-X, r30
    2c14:	12 96       	adiw	r26, 0x02	; 2
    2c16:	1d 92       	st	X+, r1
    2c18:	1d 92       	st	X+, r1
    2c1a:	1d 92       	st	X+, r1
    2c1c:	1c 92       	st	X, r1
    2c1e:	15 97       	sbiw	r26, 0x05	; 5
    2c20:	fc 01       	movw	r30, r24
    2c22:	16 82       	std	Z+6, r1	; 0x06
    2c24:	17 82       	std	Z+7, r1	; 0x07
    2c26:	10 86       	std	Z+8, r1	; 0x08
    2c28:	11 86       	std	Z+9, r1	; 0x09
    2c2a:	1a 96       	adiw	r26, 0x0a	; 10
    2c2c:	1d 92       	st	X+, r1
    2c2e:	1d 92       	st	X+, r1
    2c30:	1d 92       	st	X+, r1
    2c32:	1c 92       	st	X, r1
    2c34:	1d 97       	sbiw	r26, 0x0d	; 13
    2c36:	16 86       	std	Z+14, r1	; 0x0e
    2c38:	17 86       	std	Z+15, r1	; 0x0f
    2c3a:	10 8a       	std	Z+16, r1	; 0x10
    2c3c:	11 8a       	std	Z+17, r1	; 0x11
    2c3e:	52 96       	adiw	r26, 0x12	; 18
    2c40:	1d 92       	st	X+, r1
    2c42:	1d 92       	st	X+, r1
    2c44:	1d 92       	st	X+, r1
    2c46:	1c 92       	st	X, r1
    2c48:	55 97       	sbiw	r26, 0x15	; 21
    2c4a:	16 8a       	std	Z+22, r1	; 0x16
    2c4c:	17 8a       	std	Z+23, r1	; 0x17
    2c4e:	10 8e       	std	Z+24, r1	; 0x18
    2c50:	11 8e       	std	Z+25, r1	; 0x19
    2c52:	5a 96       	adiw	r26, 0x1a	; 26
    2c54:	1d 92       	st	X+, r1
    2c56:	1d 92       	st	X+, r1
    2c58:	1d 92       	st	X+, r1
    2c5a:	1c 92       	st	X, r1
    2c5c:	5d 97       	sbiw	r26, 0x1d	; 29
    2c5e:	16 8e       	std	Z+30, r1	; 0x1e
    2c60:	17 8e       	std	Z+31, r1	; 0x1f
    2c62:	10 a2       	std	Z+32, r1	; 0x20
    2c64:	11 a2       	std	Z+33, r1	; 0x21
    2c66:	92 96       	adiw	r26, 0x22	; 34
    2c68:	1d 92       	st	X+, r1
    2c6a:	1d 92       	st	X+, r1
    2c6c:	1d 92       	st	X+, r1
    2c6e:	1c 92       	st	X, r1
    2c70:	95 97       	sbiw	r26, 0x25	; 37
    2c72:	16 a2       	std	Z+38, r1	; 0x26
    2c74:	17 a2       	std	Z+39, r1	; 0x27
    2c76:	10 a6       	std	Z+40, r1	; 0x28
    2c78:	11 a6       	std	Z+41, r1	; 0x29
    2c7a:	21 e0       	ldi	r18, 0x01	; 1
    2c7c:	22 a7       	std	Z+42, r18	; 0x2a
	gpsSensor->init();
    2c7e:	0e 94 a1 48 	call	0x9142	; 0x9142 <_ZN10helicopter7sensors9GPSSensor4initEv>

	BarometerSensor *baroSensor = new BarometerSensor(baroSpiDriver);
    2c82:	82 e4       	ldi	r24, 0x42	; 66
    2c84:	90 e0       	ldi	r25, 0x00	; 0
    2c86:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2c8a:	6c 01       	movw	r12, r24
					pressureSensitivity_SENSt1_C1(0),
					pressureSensitivityOffset_OFFt1_C2(0),
					temperatureCoefficientOfPressureSensitivity_TCS_C3(0),
					temperatureCoefficientOfPressureOffset_TCO_C4(0),
					referenceTemperature_Tref_C5(0),
					temperatureCoefficientOfTheTemperature_TEMPSENS_C6(0)
    2c8c:	ef 81       	ldd	r30, Y+7	; 0x07
    2c8e:	f8 85       	ldd	r31, Y+8	; 0x08
    2c90:	dc 01       	movw	r26, r24
    2c92:	11 96       	adiw	r26, 0x01	; 1
    2c94:	fc 93       	st	X, r31
    2c96:	ee 93       	st	-X, r30
    2c98:	12 96       	adiw	r26, 0x02	; 2
    2c9a:	1d 92       	st	X+, r1
    2c9c:	1d 92       	st	X+, r1
    2c9e:	1d 92       	st	X+, r1
    2ca0:	1c 92       	st	X, r1
    2ca2:	15 97       	sbiw	r26, 0x05	; 5
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	16 82       	std	Z+6, r1	; 0x06
    2ca8:	17 82       	std	Z+7, r1	; 0x07
    2caa:	10 86       	std	Z+8, r1	; 0x08
    2cac:	11 86       	std	Z+9, r1	; 0x09
    2cae:	1a 96       	adiw	r26, 0x0a	; 10
    2cb0:	1d 92       	st	X+, r1
    2cb2:	1d 92       	st	X+, r1
    2cb4:	1d 92       	st	X+, r1
    2cb6:	1c 92       	st	X, r1
    2cb8:	1d 97       	sbiw	r26, 0x0d	; 13
    2cba:	16 86       	std	Z+14, r1	; 0x0e
    2cbc:	17 86       	std	Z+15, r1	; 0x0f
    2cbe:	10 8a       	std	Z+16, r1	; 0x10
    2cc0:	11 8a       	std	Z+17, r1	; 0x11
    2cc2:	12 8a       	std	Z+18, r1	; 0x12
    2cc4:	13 8a       	std	Z+19, r1	; 0x13
    2cc6:	14 8a       	std	Z+20, r1	; 0x14
    2cc8:	15 8a       	std	Z+21, r1	; 0x15
    2cca:	16 8a       	std	Z+22, r1	; 0x16
    2ccc:	17 8a       	std	Z+23, r1	; 0x17
    2cce:	10 8e       	std	Z+24, r1	; 0x18
    2cd0:	11 8e       	std	Z+25, r1	; 0x19
    2cd2:	12 8e       	std	Z+26, r1	; 0x1a
    2cd4:	13 8e       	std	Z+27, r1	; 0x1b
    2cd6:	14 8e       	std	Z+28, r1	; 0x1c
    2cd8:	15 8e       	std	Z+29, r1	; 0x1d
    2cda:	16 8e       	std	Z+30, r1	; 0x1e
    2cdc:	17 8e       	std	Z+31, r1	; 0x1f
    2cde:	10 a2       	std	Z+32, r1	; 0x20
    2ce0:	11 a2       	std	Z+33, r1	; 0x21
    2ce2:	12 a2       	std	Z+34, r1	; 0x22
    2ce4:	13 a2       	std	Z+35, r1	; 0x23
    2ce6:	14 a2       	std	Z+36, r1	; 0x24
    2ce8:	15 a2       	std	Z+37, r1	; 0x25
    2cea:	16 a2       	std	Z+38, r1	; 0x26
    2cec:	17 a2       	std	Z+39, r1	; 0x27
    2cee:	10 a6       	std	Z+40, r1	; 0x28
    2cf0:	11 a6       	std	Z+41, r1	; 0x29
    2cf2:	12 a6       	std	Z+42, r1	; 0x2a
    2cf4:	13 a6       	std	Z+43, r1	; 0x2b
    2cf6:	14 a6       	std	Z+44, r1	; 0x2c
    2cf8:	15 a6       	std	Z+45, r1	; 0x2d
    2cfa:	16 a6       	std	Z+46, r1	; 0x2e
    2cfc:	17 a6       	std	Z+47, r1	; 0x2f
    2cfe:	10 aa       	std	Z+48, r1	; 0x30
    2d00:	11 aa       	std	Z+49, r1	; 0x31
    2d02:	12 aa       	std	Z+50, r1	; 0x32
    2d04:	13 aa       	std	Z+51, r1	; 0x33
    2d06:	14 aa       	std	Z+52, r1	; 0x34
    2d08:	15 aa       	std	Z+53, r1	; 0x35
    2d0a:	16 aa       	std	Z+54, r1	; 0x36
    2d0c:	17 aa       	std	Z+55, r1	; 0x37
    2d0e:	10 ae       	std	Z+56, r1	; 0x38
    2d10:	11 ae       	std	Z+57, r1	; 0x39
    2d12:	fa 96       	adiw	r30, 0x3a	; 58
    2d14:	da 96       	adiw	r26, 0x3a	; 58
    2d16:	1c 92       	st	X, r1
    2d18:	11 82       	std	Z+1, r1	; 0x01
    2d1a:	12 82       	std	Z+2, r1	; 0x02
    2d1c:	13 82       	std	Z+3, r1	; 0x03
    2d1e:	14 82       	std	Z+4, r1	; 0x04
    2d20:	15 82       	std	Z+5, r1	; 0x05
    2d22:	16 82       	std	Z+6, r1	; 0x06
    2d24:	17 82       	std	Z+7, r1	; 0x07
	baroSensor->init();
    2d26:	0e 94 bf 40 	call	0x817e	; 0x817e <_ZN10helicopter7sensors15BarometerSensor4initEv>
	
	MagnetometerSensor *magSensor = new MagnetometerSensor(twiDriver);
    2d2a:	88 e3       	ldi	r24, 0x38	; 56
    2d2c:	90 e0       	ldi	r25, 0x00	; 0
    2d2e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2d32:	7c 01       	movw	r14, r24
    2d34:	6b 89       	ldd	r22, Y+19	; 0x13
    2d36:	7c 89       	ldd	r23, Y+20	; 0x14
    2d38:	0e 94 36 4d 	call	0x9a6c	; 0x9a6c <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>
	magSensor->init();
    2d3c:	c7 01       	movw	r24, r14
    2d3e:	0e 94 fc 4e 	call	0x9df8	; 0x9df8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv>
	_delay_ms(200);
	*/

	
	//ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .25); //run at 4 hz
	ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .1); //run at 10 hz
    2d42:	8c e0       	ldi	r24, 0x0C	; 12
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2d4a:	9e 83       	std	Y+6, r25	; 0x06
    2d4c:	8d 83       	std	Y+5, r24	; 0x05
    2d4e:	04 e1       	ldi	r16, 0x14	; 20
    2d50:	10 e0       	ldi	r17, 0x00	; 0
    2d52:	27 e0       	ldi	r18, 0x07	; 7
    2d54:	30 e0       	ldi	r19, 0x00	; 0
    2d56:	a3 01       	movw	r20, r6
    2d58:	b4 01       	movw	r22, r8
    2d5a:	0e 94 6c 56 	call	0xacd8	; 0xacd8 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
	ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz.
    2d5e:	8b e0       	ldi	r24, 0x0B	; 11
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2d66:	98 87       	std	Y+8, r25	; 0x08
    2d68:	8f 83       	std	Y+7, r24	; 0x07
    2d6a:	02 e0       	ldi	r16, 0x02	; 2
    2d6c:	10 e0       	ldi	r17, 0x00	; 0
    2d6e:	28 e0       	ldi	r18, 0x08	; 8
    2d70:	30 e0       	ldi	r19, 0x00	; 0
    2d72:	a5 01       	movw	r20, r10
    2d74:	b4 01       	movw	r22, r8
    2d76:	0e 94 05 57 	call	0xae0a	; 0xae0a <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  2); //run at 100 hz.
	ReadBarometerSensorTask *barometerSensorTask = new ReadBarometerSensorTask(model, baroSensor, 9, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz. needs to run so that at least 10 ms is between each operation. since it's a 3 step process, this is really only executes hz/3 for a complete cycle (*** this will probably cause huge timeouts since it takes like 8ms to complete.)
    2d7a:	8d e0       	ldi	r24, 0x0D	; 13
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2d82:	5c 01       	movw	r10, r24
    2d84:	04 e0       	ldi	r16, 0x04	; 4
    2d86:	10 e0       	ldi	r17, 0x00	; 0
    2d88:	29 e0       	ldi	r18, 0x09	; 9
    2d8a:	30 e0       	ldi	r19, 0x00	; 0
    2d8c:	a6 01       	movw	r20, r12
    2d8e:	b4 01       	movw	r22, r8
    2d90:	0e 94 c7 55 	call	0xab8e	; 0xab8e <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>
	//ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz, although the sensor is reading at 75 hz.
	ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz, although the sensor is reading at 75 hz.
    2d94:	8b e0       	ldi	r24, 0x0B	; 11
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2d9c:	98 8b       	std	Y+16, r25	; 0x10
    2d9e:	8f 87       	std	Y+15, r24	; 0x0f
    2da0:	02 e0       	ldi	r16, 0x02	; 2
    2da2:	10 e0       	ldi	r17, 0x00	; 0
    2da4:	2a e0       	ldi	r18, 0x0A	; 10
    2da6:	30 e0       	ldi	r19, 0x00	; 0
    2da8:	a7 01       	movw	r20, r14
    2daa:	b4 01       	movw	r22, r8
    2dac:	0e 94 7e 57 	call	0xaefc	; 0xaefc <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>
	

	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    2db0:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    2db4:	9c 8b       	std	Y+20, r25	; 0x14
    2db6:	8b 8b       	std	Y+19, r24	; 0x13
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
				void SetSystemModel(SystemModel *val) { systemModel = val; }
    2db8:	fc 01       	movw	r30, r24
    2dba:	e9 5a       	subi	r30, 0xA9	; 169
    2dbc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dbe:	91 82       	std	Z+1, r9	; 0x01
    2dc0:	80 82       	st	Z, r8
	
	rcInterface->SetSystemModel(model);

	ServoControlTask *servoControlTask = new ServoControlTask(model, rcInterface, 11,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
    2dc2:	8b e0       	ldi	r24, 0x0B	; 11
    2dc4:	90 e0       	ldi	r25, 0x00	; 0
    2dc6:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    2dca:	7c 01       	movw	r14, r24
    2dcc:	04 e0       	ldi	r16, 0x04	; 4
    2dce:	10 e0       	ldi	r17, 0x00	; 0
    2dd0:	2b e0       	ldi	r18, 0x0B	; 11
    2dd2:	30 e0       	ldi	r19, 0x00	; 0
    2dd4:	4b 89       	ldd	r20, Y+19	; 0x13
    2dd6:	5c 89       	ldd	r21, Y+20	; 0x14
    2dd8:	b4 01       	movw	r22, r8
    2dda:	0e 94 ee 57 	call	0xafdc	; 0xafdc <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>
	
	
	scheduler->addTask(flashTask);
    2dde:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2de0:	7e 8d       	ldd	r23, Y+30	; 0x1e
    2de2:	8f a1       	ldd	r24, Y+39	; 0x27
    2de4:	98 a5       	ldd	r25, Y+40	; 0x28
    2de6:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(gpsSensorTask);
    2dea:	6d 81       	ldd	r22, Y+5	; 0x05
    2dec:	7e 81       	ldd	r23, Y+6	; 0x06
    2dee:	8f a1       	ldd	r24, Y+39	; 0x27
    2df0:	98 a5       	ldd	r25, Y+40	; 0x28
    2df2:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(imuSensorTask);
    2df6:	6f 81       	ldd	r22, Y+7	; 0x07
    2df8:	78 85       	ldd	r23, Y+8	; 0x08
    2dfa:	8f a1       	ldd	r24, Y+39	; 0x27
    2dfc:	98 a5       	ldd	r25, Y+40	; 0x28
    2dfe:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(barometerSensorTask);
    2e02:	b5 01       	movw	r22, r10
    2e04:	8f a1       	ldd	r24, Y+39	; 0x27
    2e06:	98 a5       	ldd	r25, Y+40	; 0x28
    2e08:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(magSensorTask);
    2e0c:	6f 85       	ldd	r22, Y+15	; 0x0f
    2e0e:	78 89       	ldd	r23, Y+16	; 0x10
    2e10:	8f a1       	ldd	r24, Y+39	; 0x27
    2e12:	98 a5       	ldd	r25, Y+40	; 0x28
    2e14:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>


	if (model->SensorInput() == SystemModel::SimulatedSensors || receiveGains == true)
    2e18:	f4 01       	movw	r30, r8
    2e1a:	84 81       	ldd	r24, Z+4	; 0x04
    2e1c:	81 11       	cpse	r24, r1
    2e1e:	06 c0       	rjmp	.+12     	; 0x2e2c <main+0x902>
	//if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		//Add a task to read simulator data if setup to receive sensor data from the simulator.
		scheduler->addTask(simTelemTask);
    2e20:	69 81       	ldd	r22, Y+1	; 0x01
    2e22:	7a 81       	ldd	r23, Y+2	; 0x02
    2e24:	8f a1       	ldd	r24, Y+39	; 0x27
    2e26:	98 a5       	ldd	r25, Y+40	; 0x28
    2e28:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	}
	*/
	
	
	
	scheduler->addTask(transTelemTask);
    2e2c:	6b 85       	ldd	r22, Y+11	; 0x0b
    2e2e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2e30:	8f a1       	ldd	r24, Y+39	; 0x27
    2e32:	98 a5       	ldd	r25, Y+40	; 0x28
    2e34:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidOuterLoop);
    2e38:	6b a1       	ldd	r22, Y+35	; 0x23
    2e3a:	7c a1       	ldd	r23, Y+36	; 0x24
    2e3c:	8f a1       	ldd	r24, Y+39	; 0x27
    2e3e:	98 a5       	ldd	r25, Y+40	; 0x28
    2e40:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidInnerLoop);
    2e44:	6d a1       	ldd	r22, Y+37	; 0x25
    2e46:	7e a1       	ldd	r23, Y+38	; 0x26
    2e48:	8f a1       	ldd	r24, Y+39	; 0x27
    2e4a:	98 a5       	ldd	r25, Y+40	; 0x28
    2e4c:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(navTask);
    2e50:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2e52:	78 a1       	ldd	r23, Y+32	; 0x20
    2e54:	8f a1       	ldd	r24, Y+39	; 0x27
    2e56:	98 a5       	ldd	r25, Y+40	; 0x28
    2e58:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(pvNavTask);
    2e5c:	69 a1       	ldd	r22, Y+33	; 0x21
    2e5e:	7a a1       	ldd	r23, Y+34	; 0x22
    2e60:	8f a1       	ldd	r24, Y+39	; 0x27
    2e62:	98 a5       	ldd	r25, Y+40	; 0x28
    2e64:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	
	if (sendControlToServos)
	{
		scheduler->addTask(servoControlTask);
    2e68:	b7 01       	movw	r22, r14
    2e6a:	8f a1       	ldd	r24, Y+39	; 0x27
    2e6c:	98 a5       	ldd	r25, Y+40	; 0x28
    2e6e:	0e 94 8e 3f 	call	0x7f1c	; 0x7f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    2e72:	d4 01       	movw	r26, r8
    2e74:	12 96       	adiw	r26, 0x02	; 2
    2e76:	1c 92       	st	X, r1
    2e78:	12 97       	sbiw	r26, 0x02	; 2
		model->OperationalState(SystemModel::AutoPilot);
	}
	
	

	PORTA |= (1<<PA4);
    2e7a:	14 9a       	sbi	0x02, 4	; 2
	
	//Set the red led to 'on' to indicate the system is initializing. I have this down here because there is a bug which might lock up the system when the GPS initializes, so
	//we turn on the red led after that bug can take place so we know we past that point in the init sequence. 
	DDRA |= (1<<PA5);
    2e7c:	0d 9a       	sbi	0x01, 5	; 1
	PORTA &= ~(1<<PA5);
    2e7e:	15 98       	cbi	0x02, 5	; 2
	
	
	/**
	 * Set initial position.
	 */
	if (model->SensorInput() == SystemModel::RealSensors)
    2e80:	14 96       	adiw	r26, 0x04	; 4
    2e82:	8c 91       	ld	r24, X
    2e84:	81 30       	cpi	r24, 0x01	; 1
    2e86:	09 f0       	breq	.+2      	; 0x2e8a <main+0x960>
    2e88:	34 c2       	rjmp	.+1128   	; 0x32f2 <main+0xdc8>
    2e8a:	0f a1       	ldd	r16, Y+39	; 0x27
    2e8c:	18 a5       	ldd	r17, Y+40	; 0x28
    2e8e:	80 c0       	rjmp	.+256    	; 0x2f90 <main+0xa66>
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
    2e90:	c3 01       	movw	r24, r6
    2e92:	0e 94 4f 48 	call	0x909e	; 0x909e <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
			gpsSensor->readSensorNavStatus();
    2e96:	c3 01       	movw	r24, r6
    2e98:	0e 94 18 48 	call	0x9030	; 0x9030 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>
			long status = gpsSensor->readSensorSolution();
    2e9c:	c3 01       	movw	r24, r6
    2e9e:	0e 94 58 47 	call	0x8eb0	; 0x8eb0 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>
    2ea2:	7c 01       	movw	r14, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2ea4:	bf ef       	ldi	r27, 0xFF	; 255
    2ea6:	e4 e3       	ldi	r30, 0x34	; 52
    2ea8:	fc e0       	ldi	r31, 0x0C	; 12
    2eaa:	b1 50       	subi	r27, 0x01	; 1
    2eac:	e0 40       	sbci	r30, 0x00	; 0
    2eae:	f0 40       	sbci	r31, 0x00	; 0
    2eb0:	e1 f7       	brne	.-8      	; 0x2eaa <main+0x980>
    2eb2:	00 c0       	rjmp	.+0      	; 0x2eb4 <main+0x98a>
    2eb4:	00 00       	nop
					//long status = gpsSensor->readSensorNavStatus();
					long status = gpsSensor->readSensorSolution();*/
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
    2eb6:	d2 01       	movw	r26, r4
    2eb8:	ed 91       	ld	r30, X+
    2eba:	fc 91       	ld	r31, X
    2ebc:	06 80       	ldd	r0, Z+6	; 0x06
    2ebe:	f7 81       	ldd	r31, Z+7	; 0x07
    2ec0:	e0 2d       	mov	r30, r0
    2ec2:	64 e5       	ldi	r22, 0x54	; 84
    2ec4:	c2 01       	movw	r24, r4
    2ec6:	19 95       	eicall
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    2ec8:	d2 01       	movw	r26, r4
    2eca:	ed 91       	ld	r30, X+
    2ecc:	fc 91       	ld	r31, X
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
			gpsSensor->readSensorNavStatus();
			long status = gpsSensor->readSensorSolution();
    2ece:	a7 01       	movw	r20, r14
    2ed0:	66 27       	eor	r22, r22
    2ed2:	57 fd       	sbrc	r21, 7
    2ed4:	60 95       	com	r22
    2ed6:	76 2f       	mov	r23, r22
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    2ed8:	04 84       	ldd	r0, Z+12	; 0x0c
    2eda:	f5 85       	ldd	r31, Z+13	; 0x0d
    2edc:	e0 2d       	mov	r30, r0
    2ede:	c2 01       	movw	r24, r4
    2ee0:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getLongitudeDegE7());
    2ee2:	d2 01       	movw	r26, r4
    2ee4:	ed 91       	ld	r30, X+
    2ee6:	fc 91       	ld	r31, X
    2ee8:	d3 01       	movw	r26, r6
    2eea:	16 96       	adiw	r26, 0x06	; 6
    2eec:	4d 91       	ld	r20, X+
    2eee:	5d 91       	ld	r21, X+
    2ef0:	6d 91       	ld	r22, X+
    2ef2:	7c 91       	ld	r23, X
    2ef4:	19 97       	sbiw	r26, 0x09	; 9
    2ef6:	04 84       	ldd	r0, Z+12	; 0x0c
    2ef8:	f5 85       	ldd	r31, Z+13	; 0x0d
    2efa:	e0 2d       	mov	r30, r0
    2efc:	c2 01       	movw	r24, r4
    2efe:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionAccuracyEstimateEcefCm());
    2f00:	d2 01       	movw	r26, r4
    2f02:	ed 91       	ld	r30, X+
    2f04:	fc 91       	ld	r31, X
    2f06:	d3 01       	movw	r26, r6
    2f08:	56 96       	adiw	r26, 0x16	; 22
    2f0a:	4d 91       	ld	r20, X+
    2f0c:	5d 91       	ld	r21, X+
    2f0e:	6d 91       	ld	r22, X+
    2f10:	7c 91       	ld	r23, X
    2f12:	59 97       	sbiw	r26, 0x19	; 25
    2f14:	02 84       	ldd	r0, Z+10	; 0x0a
    2f16:	f3 85       	ldd	r31, Z+11	; 0x0b
    2f18:	e0 2d       	mov	r30, r0
    2f1a:	c2 01       	movw	r24, r4
    2f1c:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionFixStatus());
    2f1e:	d2 01       	movw	r26, r4
    2f20:	ed 91       	ld	r30, X+
    2f22:	fc 91       	ld	r31, X
    2f24:	d3 01       	movw	r26, r6
    2f26:	9a 96       	adiw	r26, 0x2a	; 42
    2f28:	6c 91       	ld	r22, X
    2f2a:	70 e0       	ldi	r23, 0x00	; 0
    2f2c:	00 84       	ldd	r0, Z+8	; 0x08
    2f2e:	f1 85       	ldd	r31, Z+9	; 0x09
    2f30:	e0 2d       	mov	r30, r0
    2f32:	c2 01       	movw	r24, r4
    2f34:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getXEcefCm());
    2f36:	d2 01       	movw	r26, r4
    2f38:	ed 91       	ld	r30, X+
    2f3a:	fc 91       	ld	r31, X
    2f3c:	d3 01       	movw	r26, r6
    2f3e:	1a 96       	adiw	r26, 0x0a	; 10
    2f40:	4d 91       	ld	r20, X+
    2f42:	5d 91       	ld	r21, X+
    2f44:	6d 91       	ld	r22, X+
    2f46:	7c 91       	ld	r23, X
    2f48:	1d 97       	sbiw	r26, 0x0d	; 13
    2f4a:	04 84       	ldd	r0, Z+12	; 0x0c
    2f4c:	f5 85       	ldd	r31, Z+13	; 0x0d
    2f4e:	e0 2d       	mov	r30, r0
    2f50:	c2 01       	movw	r24, r4
    2f52:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getYEcefCm());
    2f54:	d2 01       	movw	r26, r4
    2f56:	ed 91       	ld	r30, X+
    2f58:	fc 91       	ld	r31, X
    2f5a:	d3 01       	movw	r26, r6
    2f5c:	1e 96       	adiw	r26, 0x0e	; 14
    2f5e:	4d 91       	ld	r20, X+
    2f60:	5d 91       	ld	r21, X+
    2f62:	6d 91       	ld	r22, X+
    2f64:	7c 91       	ld	r23, X
    2f66:	51 97       	sbiw	r26, 0x11	; 17
    2f68:	04 84       	ldd	r0, Z+12	; 0x0c
    2f6a:	f5 85       	ldd	r31, Z+13	; 0x0d
    2f6c:	e0 2d       	mov	r30, r0
    2f6e:	c2 01       	movw	r24, r4
    2f70:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getZEcefCm());
    2f72:	d2 01       	movw	r26, r4
    2f74:	ed 91       	ld	r30, X+
    2f76:	fc 91       	ld	r31, X
    2f78:	d3 01       	movw	r26, r6
    2f7a:	52 96       	adiw	r26, 0x12	; 18
    2f7c:	4d 91       	ld	r20, X+
    2f7e:	5d 91       	ld	r21, X+
    2f80:	6d 91       	ld	r22, X+
    2f82:	7c 91       	ld	r23, X
    2f84:	55 97       	sbiw	r26, 0x15	; 21
    2f86:	04 84       	ldd	r0, Z+12	; 0x0c
    2f88:	f5 85       	ldd	r31, Z+13	; 0x0d
    2f8a:	e0 2d       	mov	r30, r0
    2f8c:	c2 01       	movw	r24, r4
    2f8e:	19 95       	eicall
	if (model->SensorInput() == SystemModel::RealSensors)
	{		
	
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
    2f90:	c3 01       	movw	r24, r6
    2f92:	0e 94 31 49 	call	0x9262	; 0x9262 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>
    2f96:	88 23       	and	r24, r24
    2f98:	09 f4       	brne	.+2      	; 0x2f9c <main+0xa72>
    2f9a:	7a cf       	rjmp	.-268    	; 0x2e90 <main+0x966>
    2f9c:	f3 01       	movw	r30, r6
    2f9e:	86 89       	ldd	r24, Z+22	; 0x16
    2fa0:	97 89       	ldd	r25, Z+23	; 0x17
    2fa2:	a0 8d       	ldd	r26, Z+24	; 0x18
    2fa4:	b1 8d       	ldd	r27, Z+25	; 0x19
    2fa6:	2f 89       	ldd	r18, Y+23	; 0x17
    2fa8:	38 8d       	ldd	r19, Y+24	; 0x18
    2faa:	49 8d       	ldd	r20, Y+25	; 0x19
    2fac:	5a 8d       	ldd	r21, Y+26	; 0x1a
    2fae:	28 17       	cp	r18, r24
    2fb0:	39 07       	cpc	r19, r25
    2fb2:	4a 07       	cpc	r20, r26
    2fb4:	5b 07       	cpc	r21, r27
    2fb6:	08 f4       	brcc	.+2      	; 0x2fba <main+0xa90>
    2fb8:	6b cf       	rjmp	.-298    	; 0x2e90 <main+0x966>
    2fba:	18 a7       	std	Y+40, r17	; 0x28
    2fbc:	0f a3       	std	Y+39, r16	; 0x27
    2fbe:	0c c0       	rjmp	.+24     	; 0x2fd8 <main+0xaae>
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
		{
			gpsSensor->readSensorLLH();
    2fc0:	c3 01       	movw	r24, r6
    2fc2:	0e 94 4f 48 	call	0x909e	; 0x909e <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
    2fc6:	3f ef       	ldi	r19, 0xFF	; 255
    2fc8:	44 e3       	ldi	r20, 0x34	; 52
    2fca:	5c e0       	ldi	r21, 0x0C	; 12
    2fcc:	31 50       	subi	r19, 0x01	; 1
    2fce:	40 40       	sbci	r20, 0x00	; 0
    2fd0:	50 40       	sbci	r21, 0x00	; 0
    2fd2:	e1 f7       	brne	.-8      	; 0x2fcc <main+0xaa2>
    2fd4:	00 c0       	rjmp	.+0      	; 0x2fd6 <main+0xaac>
    2fd6:	00 00       	nop
		
		//Turn off interrupts so that the gps sensor doesn't auto receive gps data which would
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
    2fd8:	f3 01       	movw	r30, r6
    2fda:	82 81       	ldd	r24, Z+2	; 0x02
    2fdc:	93 81       	ldd	r25, Z+3	; 0x03
    2fde:	a4 81       	ldd	r26, Z+4	; 0x04
    2fe0:	b5 81       	ldd	r27, Z+5	; 0x05
    2fe2:	89 2b       	or	r24, r25
    2fe4:	8a 2b       	or	r24, r26
    2fe6:	8b 2b       	or	r24, r27
    2fe8:	59 f3       	breq	.-42     	; 0x2fc0 <main+0xa96>
    2fea:	86 81       	ldd	r24, Z+6	; 0x06
    2fec:	97 81       	ldd	r25, Z+7	; 0x07
    2fee:	a0 85       	ldd	r26, Z+8	; 0x08
    2ff0:	b1 85       	ldd	r27, Z+9	; 0x09
    2ff2:	89 2b       	or	r24, r25
    2ff4:	8a 2b       	or	r24, r26
    2ff6:	8b 2b       	or	r24, r27
    2ff8:	19 f3       	breq	.-58     	; 0x2fc0 <main+0xa96>
    2ffa:	18 a7       	std	Y+40, r17	; 0x28
    2ffc:	0f a3       	std	Y+39, r16	; 0x27
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    2ffe:	84 01       	movw	r16, r8
    3000:	02 54       	subi	r16, 0x42	; 66
    3002:	1f 4f       	sbci	r17, 0xFF	; 255
    3004:	62 85       	ldd	r22, Z+10	; 0x0a
    3006:	73 85       	ldd	r23, Z+11	; 0x0b
    3008:	84 85       	ldd	r24, Z+12	; 0x0c
    300a:	95 85       	ldd	r25, Z+13	; 0x0d
    300c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3010:	f8 01       	movw	r30, r16
    3012:	60 83       	st	Z, r22
    3014:	71 83       	std	Z+1, r23	; 0x01
    3016:	82 83       	std	Z+2, r24	; 0x02
    3018:	93 83       	std	Z+3, r25	; 0x03

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    301a:	0c 5f       	subi	r16, 0xFC	; 252
    301c:	1f 4f       	sbci	r17, 0xFF	; 255
    301e:	d3 01       	movw	r26, r6
    3020:	1e 96       	adiw	r26, 0x0e	; 14
    3022:	6d 91       	ld	r22, X+
    3024:	7d 91       	ld	r23, X+
    3026:	8d 91       	ld	r24, X+
    3028:	9c 91       	ld	r25, X
    302a:	51 97       	sbiw	r26, 0x11	; 17
    302c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3030:	f8 01       	movw	r30, r16
    3032:	60 83       	st	Z, r22
    3034:	71 83       	std	Z+1, r23	; 0x01
    3036:	82 83       	std	Z+2, r24	; 0x02
    3038:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    303a:	0c 5f       	subi	r16, 0xFC	; 252
    303c:	1f 4f       	sbci	r17, 0xFF	; 255
    303e:	d3 01       	movw	r26, r6
    3040:	52 96       	adiw	r26, 0x12	; 18
    3042:	6d 91       	ld	r22, X+
    3044:	7d 91       	ld	r23, X+
    3046:	8d 91       	ld	r24, X+
    3048:	9c 91       	ld	r25, X
    304a:	55 97       	sbiw	r26, 0x15	; 21
    304c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3050:	f8 01       	movw	r30, r16
    3052:	60 83       	st	Z, r22
    3054:	71 83       	std	Z+1, r23	; 0x01
    3056:	82 83       	std	Z+2, r24	; 0x02
    3058:	93 83       	std	Z+3, r25	; 0x03
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    305a:	b0 97       	sbiw	r30, 0x20	; 32
		model->InitialXPositionEcef(gpsSensor->getXEcefCm());
		model->InitialYPositionEcef(gpsSensor->getYEcefCm());
		model->InitialZPositionEcef(gpsSensor->getZEcefCm());
		
		//generate ecef to ned rotation matrix based on current lat/long			
		CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    305c:	20 81       	ld	r18, Z
    305e:	31 81       	ldd	r19, Z+1	; 0x01
    3060:	42 81       	ldd	r20, Z+2	; 0x02
    3062:	53 81       	ldd	r21, Z+3	; 0x03

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    3064:	34 97       	sbiw	r30, 0x04	; 4
    3066:	60 81       	ld	r22, Z
    3068:	71 81       	ldd	r23, Z+1	; 0x01
    306a:	82 81       	ldd	r24, Z+2	; 0x02
    306c:	93 81       	ldd	r25, Z+3	; 0x03
    306e:	08 5a       	subi	r16, 0xA8	; 168
    3070:	1f 4f       	sbci	r17, 0xFF	; 255
    3072:	0e 94 16 61 	call	0xc22c	; 0xc22c <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
    3076:	ff ef       	ldi	r31, 0xFF	; 255
    3078:	29 e6       	ldi	r18, 0x69	; 105
    307a:	38 e1       	ldi	r19, 0x18	; 24
    307c:	f1 50       	subi	r31, 0x01	; 1
    307e:	20 40       	sbci	r18, 0x00	; 0
    3080:	30 40       	sbci	r19, 0x00	; 0
    3082:	e1 f7       	brne	.-8      	; 0x307c <main+0xb52>
    3084:	00 c0       	rjmp	.+0      	; 0x3086 <main+0xb5c>
    3086:	00 00       	nop
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3088:	4d 89       	ldd	r20, Y+21	; 0x15
    308a:	5e 89       	ldd	r21, Y+22	; 0x16
    308c:	14 16       	cp	r1, r20
    308e:	15 06       	cpc	r1, r21
    3090:	0c f0       	brlt	.+2      	; 0x3094 <main+0xb6a>
    3092:	9b c1       	rjmp	.+822    	; 0x33ca <main+0xea0>
    3094:	e1 2c       	mov	r14, r1
    3096:	f1 2c       	mov	r15, r1
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    3098:	13 e0       	ldi	r17, 0x03	; 3
    309a:	00 e0       	ldi	r16, 0x00	; 0
    309c:	cf a0       	ldd	r12, Y+39	; 0x27
    309e:	d8 a4       	ldd	r13, Y+40	; 0x28
    30a0:	1d c0       	rjmp	.+58     	; 0x30dc <main+0xbb2>
		for (int i = 0; i < barometerInitReadings; i++)		
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    30a2:	d5 01       	movw	r26, r10
    30a4:	ed 91       	ld	r30, X+
    30a6:	fc 91       	ld	r31, X
    30a8:	01 90       	ld	r0, Z+
    30aa:	f0 81       	ld	r31, Z
    30ac:	e0 2d       	mov	r30, r0
    30ae:	c5 01       	movw	r24, r10
    30b0:	19 95       	eicall
    30b2:	ef e3       	ldi	r30, 0x3F	; 63
    30b4:	fc e9       	ldi	r31, 0x9C	; 156
    30b6:	31 97       	sbiw	r30, 0x01	; 1
    30b8:	f1 f7       	brne	.-4      	; 0x30b6 <main+0xb8c>
    30ba:	00 c0       	rjmp	.+0      	; 0x30bc <main+0xb92>
    30bc:	00 00       	nop
    30be:	f1 e0       	ldi	r31, 0x01	; 1
    30c0:	4f 1a       	sub	r4, r31
    30c2:	51 08       	sbc	r5, r1
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    30c4:	41 14       	cp	r4, r1
    30c6:	51 04       	cpc	r5, r1
    30c8:	61 f7       	brne	.-40     	; 0x30a2 <main+0xb78>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    30ca:	2f ef       	ldi	r18, 0xFF	; 255
    30cc:	e2 1a       	sub	r14, r18
    30ce:	f2 0a       	sbc	r15, r18
    30d0:	4d 89       	ldd	r20, Y+21	; 0x15
    30d2:	5e 89       	ldd	r21, Y+22	; 0x16
    30d4:	e4 16       	cp	r14, r20
    30d6:	f5 06       	cpc	r15, r21
    30d8:	09 f4       	brne	.+2      	; 0x30dc <main+0xbb2>
    30da:	75 c1       	rjmp	.+746    	; 0x33c6 <main+0xe9c>
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    30dc:	41 2e       	mov	r4, r17
    30de:	50 2e       	mov	r5, r16
    30e0:	e0 cf       	rjmp	.-64     	; 0x30a2 <main+0xb78>
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    30e2:	d5 01       	movw	r26, r10
    30e4:	ed 91       	ld	r30, X+
    30e6:	fc 91       	ld	r31, X
    30e8:	01 90       	ld	r0, Z+
    30ea:	f0 81       	ld	r31, Z
    30ec:	e0 2d       	mov	r30, r0
    30ee:	c5 01       	movw	r24, r10
    30f0:	19 95       	eicall
    30f2:	ef e3       	ldi	r30, 0x3F	; 63
    30f4:	fc e9       	ldi	r31, 0x9C	; 156
    30f6:	31 97       	sbiw	r30, 0x01	; 1
    30f8:	f1 f7       	brne	.-4      	; 0x30f6 <main+0xbcc>
    30fa:	00 c0       	rjmp	.+0      	; 0x30fc <main+0xbd2>
    30fc:	00 00       	nop
    30fe:	2b 85       	ldd	r18, Y+11	; 0x0b
    3100:	3c 85       	ldd	r19, Y+12	; 0x0c
    3102:	21 50       	subi	r18, 0x01	; 1
    3104:	31 09       	sbc	r19, r1
    3106:	3c 87       	std	Y+12, r19	; 0x0c
    3108:	2b 87       	std	Y+11, r18	; 0x0b
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    310a:	23 2b       	or	r18, r19
    310c:	51 f7       	brne	.-44     	; 0x30e2 <main+0xbb8>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			average +=model->PressureMillibars();
    310e:	a9 81       	ldd	r26, Y+1	; 0x01
    3110:	ba 81       	ldd	r27, Y+2	; 0x02
    3112:	2d 91       	ld	r18, X+
    3114:	3d 91       	ld	r19, X+
    3116:	4d 91       	ld	r20, X+
    3118:	5c 91       	ld	r21, X
    311a:	c7 01       	movw	r24, r14
    311c:	b6 01       	movw	r22, r12
    311e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    3122:	6b 01       	movw	r12, r22
    3124:	7c 01       	movw	r14, r24
    3126:	01 50       	subi	r16, 0x01	; 1
    3128:	11 09       	sbc	r17, r1
		}
		
		
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
    312a:	01 15       	cp	r16, r1
    312c:	11 05       	cpc	r17, r1
    312e:	21 f0       	breq	.+8      	; 0x3138 <main+0xc0e>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3130:	b3 e0       	ldi	r27, 0x03	; 3
    3132:	bb 87       	std	Y+11, r27	; 0x0b
    3134:	1c 86       	std	Y+12, r1	; 0x0c
    3136:	d5 cf       	rjmp	.-86     	; 0x30e2 <main+0xbb8>
    3138:	58 a6       	std	Y+40, r5	; 0x28
    313a:	4f a2       	std	Y+39, r4	; 0x27
			}
			average +=model->PressureMillibars();
			
		}
		
		model->PressureMillibars((float)average/((float)iterations));
    313c:	20 e0       	ldi	r18, 0x00	; 0
    313e:	30 e0       	ldi	r19, 0x00	; 0
    3140:	40 e2       	ldi	r20, 0x20	; 32
    3142:	51 e4       	ldi	r21, 0x41	; 65
    3144:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    3148:	f4 01       	movw	r30, r8
    314a:	ea 5e       	subi	r30, 0xEA	; 234
    314c:	fe 4f       	sbci	r31, 0xFE	; 254
    314e:	60 83       	st	Z, r22
    3150:	71 83       	std	Z+1, r23	; 0x01
    3152:	82 83       	std	Z+2, r24	; 0x02
    3154:	93 83       	std	Z+3, r25	; 0x03
		
		//set the initial altitude based on sensor readings.
		//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
		model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    3156:	20 e0       	ldi	r18, 0x00	; 0
    3158:	30 e5       	ldi	r19, 0x50	; 80
    315a:	4d e7       	ldi	r20, 0x7D	; 125
    315c:	54 e4       	ldi	r21, 0x44	; 68
    315e:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    3162:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <log10>
    3166:	2b e2       	ldi	r18, 0x2B	; 43
    3168:	30 e3       	ldi	r19, 0x30	; 48
    316a:	48 ea       	ldi	r20, 0xA8	; 168
    316c:	50 e4       	ldi	r21, 0x40	; 64
    316e:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    3172:	9b 01       	movw	r18, r22
    3174:	ac 01       	movw	r20, r24
    3176:	60 e0       	ldi	r22, 0x00	; 0
    3178:	70 e0       	ldi	r23, 0x00	; 0
    317a:	80 e2       	ldi	r24, 0x20	; 32
    317c:	91 e4       	ldi	r25, 0x41	; 65
    317e:	0e 94 80 6a 	call	0xd500	; 0xd500 <pow>
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    3182:	84 01       	movw	r16, r8
    3184:	06 53       	subi	r16, 0x36	; 54
    3186:	1f 4f       	sbci	r17, 0xFF	; 255
    3188:	20 e0       	ldi	r18, 0x00	; 0
    318a:	30 e0       	ldi	r19, 0x00	; 0
    318c:	40 e8       	ldi	r20, 0x80	; 128
    318e:	5f e3       	ldi	r21, 0x3F	; 63
    3190:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3194:	29 e9       	ldi	r18, 0x99	; 153
    3196:	3a e4       	ldi	r19, 0x4A	; 74
    3198:	47 e8       	ldi	r20, 0x87	; 135
    319a:	5a e4       	ldi	r21, 0x4A	; 74
    319c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    31a0:	d8 01       	movw	r26, r16
    31a2:	6d 93       	st	X+, r22
    31a4:	7d 93       	st	X+, r23
    31a6:	8d 93       	st	X+, r24
    31a8:	9c 93       	st	X, r25
    31aa:	13 97       	sbiw	r26, 0x03	; 3
		
		
		float accelGain = ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT;
    31ac:	20 91 0a 02 	lds	r18, 0x020A
    31b0:	30 91 0b 02 	lds	r19, 0x020B
    31b4:	40 91 0c 02 	lds	r20, 0x020C
    31b8:	50 91 0d 02 	lds	r21, 0x020D
    31bc:	29 83       	std	Y+1, r18	; 0x01
    31be:	3a 83       	std	Y+2, r19	; 0x02
    31c0:	4b 83       	std	Y+3, r20	; 0x03
    31c2:	5c 83       	std	Y+4, r21	; 0x04
		float magGain = ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT;
    31c4:	80 91 06 02 	lds	r24, 0x0206
    31c8:	90 91 07 02 	lds	r25, 0x0207
    31cc:	a0 91 08 02 	lds	r26, 0x0208
    31d0:	b0 91 09 02 	lds	r27, 0x0209
    31d4:	8b 87       	std	Y+11, r24	; 0x0b
    31d6:	9c 87       	std	Y+12, r25	; 0x0c
    31d8:	ad 87       	std	Y+13, r26	; 0x0d
    31da:	be 87       	std	Y+14, r27	; 0x0e
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    31dc:	8d ec       	ldi	r24, 0xCD	; 205
    31de:	9c ec       	ldi	r25, 0xCC	; 204
    31e0:	ac ec       	ldi	r26, 0xCC	; 204
    31e2:	bd e3       	ldi	r27, 0x3D	; 61
    31e4:	80 93 0a 02 	sts	0x020A, r24
    31e8:	90 93 0b 02 	sts	0x020B, r25
    31ec:	a0 93 0c 02 	sts	0x020C, r26
    31f0:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    31f4:	80 93 06 02 	sts	0x0206, r24
    31f8:	90 93 07 02 	sts	0x0207, r25
    31fc:	a0 93 08 02 	sts	0x0208, r26
    3200:	b0 93 09 02 	sts	0x0209, r27
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    3204:	e1 2c       	mov	r14, r1
    3206:	f1 2c       	mov	r15, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
    3208:	13 e0       	ldi	r17, 0x03	; 3
    320a:	00 e0       	ldi	r16, 0x00	; 0
    320c:	62 01       	movw	r12, r4
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
		{
			magSensorTask->runTaskImpl();
    320e:	af 85       	ldd	r26, Y+15	; 0x0f
    3210:	b8 89       	ldd	r27, Y+16	; 0x10
    3212:	ed 91       	ld	r30, X+
    3214:	fc 91       	ld	r31, X
    3216:	11 97       	sbiw	r26, 0x01	; 1
    3218:	01 90       	ld	r0, Z+
    321a:	f0 81       	ld	r31, Z
    321c:	e0 2d       	mov	r30, r0
    321e:	cd 01       	movw	r24, r26
    3220:	19 95       	eicall
			gpsSensorTask->runTaskImpl();
    3222:	ad 81       	ldd	r26, Y+5	; 0x05
    3224:	be 81       	ldd	r27, Y+6	; 0x06
    3226:	ed 91       	ld	r30, X+
    3228:	fc 91       	ld	r31, X
    322a:	11 97       	sbiw	r26, 0x01	; 1
    322c:	01 90       	ld	r0, Z+
    322e:	f0 81       	ld	r31, Z
    3230:	e0 2d       	mov	r30, r0
    3232:	cd 01       	movw	r24, r26
    3234:	19 95       	eicall
    3236:	81 2e       	mov	r8, r17
    3238:	90 2e       	mov	r9, r16
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    323a:	d5 01       	movw	r26, r10
    323c:	ed 91       	ld	r30, X+
    323e:	fc 91       	ld	r31, X
    3240:	01 90       	ld	r0, Z+
    3242:	f0 81       	ld	r31, Z
    3244:	e0 2d       	mov	r30, r0
    3246:	c5 01       	movw	r24, r10
    3248:	19 95       	eicall
    324a:	ef e3       	ldi	r30, 0x3F	; 63
    324c:	fc e9       	ldi	r31, 0x9C	; 156
    324e:	31 97       	sbiw	r30, 0x01	; 1
    3250:	f1 f7       	brne	.-4      	; 0x324e <main+0xd24>
    3252:	00 c0       	rjmp	.+0      	; 0x3254 <main+0xd2a>
    3254:	00 00       	nop
    3256:	f1 e0       	ldi	r31, 0x01	; 1
    3258:	8f 1a       	sub	r8, r31
    325a:	91 08       	sbc	r9, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    325c:	81 14       	cp	r8, r1
    325e:	91 04       	cpc	r9, r1
    3260:	61 f7       	brne	.-40     	; 0x323a <main+0xd10>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			
			imuSensorTask->runTaskImpl();
    3262:	af 81       	ldd	r26, Y+7	; 0x07
    3264:	b8 85       	ldd	r27, Y+8	; 0x08
    3266:	ed 91       	ld	r30, X+
    3268:	fc 91       	ld	r31, X
    326a:	11 97       	sbiw	r26, 0x01	; 1
    326c:	01 90       	ld	r0, Z+
    326e:	f0 81       	ld	r31, Z
    3270:	e0 2d       	mov	r30, r0
    3272:	cd 01       	movw	r24, r26
    3274:	19 95       	eicall
			
			navTask->runTaskImpl();
    3276:	af 8d       	ldd	r26, Y+31	; 0x1f
    3278:	b8 a1       	ldd	r27, Y+32	; 0x20
    327a:	ed 91       	ld	r30, X+
    327c:	fc 91       	ld	r31, X
    327e:	11 97       	sbiw	r26, 0x01	; 1
    3280:	01 90       	ld	r0, Z+
    3282:	f0 81       	ld	r31, Z
    3284:	e0 2d       	mov	r30, r0
    3286:	cd 01       	movw	r24, r26
    3288:	19 95       	eicall
			pvNavTask->runTaskImpl();
    328a:	a9 a1       	ldd	r26, Y+33	; 0x21
    328c:	ba a1       	ldd	r27, Y+34	; 0x22
    328e:	ed 91       	ld	r30, X+
    3290:	fc 91       	ld	r31, X
    3292:	11 97       	sbiw	r26, 0x01	; 1
    3294:	01 90       	ld	r0, Z+
    3296:	f0 81       	ld	r31, Z
    3298:	e0 2d       	mov	r30, r0
    329a:	cd 01       	movw	r24, r26
    329c:	19 95       	eicall
    329e:	ef e3       	ldi	r30, 0x3F	; 63
    32a0:	fc e9       	ldi	r31, 0x9C	; 156
    32a2:	31 97       	sbiw	r30, 0x01	; 1
    32a4:	f1 f7       	brne	.-4      	; 0x32a2 <main+0xd78>
    32a6:	00 c0       	rjmp	.+0      	; 0x32a8 <main+0xd7e>
    32a8:	00 00       	nop
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    32aa:	ff ef       	ldi	r31, 0xFF	; 255
    32ac:	ef 1a       	sub	r14, r31
    32ae:	ff 0a       	sbc	r15, r31
    32b0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    32b2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    32b4:	e2 16       	cp	r14, r18
    32b6:	f3 06       	cpc	r15, r19
    32b8:	0c f4       	brge	.+2      	; 0x32bc <main+0xd92>
    32ba:	a9 cf       	rjmp	.-174    	; 0x320e <main+0xce4>
    32bc:	d8 a6       	std	Y+40, r13	; 0x28
    32be:	cf a2       	std	Y+39, r12	; 0x27
			pvNavTask->runTaskImpl();
			
			_delay_ms(10);
		}
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = accelGain;
    32c0:	89 81       	ldd	r24, Y+1	; 0x01
    32c2:	9a 81       	ldd	r25, Y+2	; 0x02
    32c4:	ab 81       	ldd	r26, Y+3	; 0x03
    32c6:	bc 81       	ldd	r27, Y+4	; 0x04
    32c8:	80 93 0a 02 	sts	0x020A, r24
    32cc:	90 93 0b 02 	sts	0x020B, r25
    32d0:	a0 93 0c 02 	sts	0x020C, r26
    32d4:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = magGain;
    32d8:	2b 85       	ldd	r18, Y+11	; 0x0b
    32da:	3c 85       	ldd	r19, Y+12	; 0x0c
    32dc:	4d 85       	ldd	r20, Y+13	; 0x0d
    32de:	5e 85       	ldd	r21, Y+14	; 0x0e
    32e0:	20 93 06 02 	sts	0x0206, r18
    32e4:	30 93 07 02 	sts	0x0207, r19
    32e8:	40 93 08 02 	sts	0x0208, r20
    32ec:	50 93 09 02 	sts	0x0209, r21
    32f0:	f8 c0       	rjmp	.+496    	; 0x34e2 <main+0xfb8>
	}else
	{

		//SerialDriver *initSerialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, NULL);
		//GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(initSerialDriver);
		GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(serialDriver);
    32f2:	82 e0       	ldi	r24, 0x02	; 2
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    32fa:	5c 01       	movw	r10, r24
    32fc:	dc 01       	movw	r26, r24
    32fe:	4d 92       	st	X+, r4
    3300:	5c 92       	st	X, r5
		SimTelemetryTask *initSimTelemTask = new SimTelemetryTask(initGcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    3302:	8e e0       	ldi	r24, 0x0E	; 14
    3304:	90 e0       	ldi	r25, 0x00	; 0
    3306:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    330a:	2c 01       	movw	r4, r24
    330c:	0f 2e       	mov	r0, r31
    330e:	fa e0       	ldi	r31, 0x0A	; 10
    3310:	cf 2e       	mov	r12, r31
    3312:	d1 2c       	mov	r13, r1
    3314:	f0 2d       	mov	r31, r0
    3316:	e1 2c       	mov	r14, r1
    3318:	f1 2c       	mov	r15, r1
    331a:	00 e0       	ldi	r16, 0x00	; 0
    331c:	91 01       	movw	r18, r2
    331e:	a4 01       	movw	r20, r8
    3320:	b5 01       	movw	r22, r10
    3322:	0e 94 93 5c 	call	0xb926	; 0xb926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    3326:	f4 01       	movw	r30, r8
    3328:	ee 55       	subi	r30, 0x5E	; 94
    332a:	ff 4f       	sbci	r31, 0xFF	; 255
    332c:	fa 83       	std	Y+2, r31	; 0x02
    332e:	e9 83       	std	Y+1, r30	; 0x01
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    3330:	84 01       	movw	r16, r8
    3332:	0a 55       	subi	r16, 0x5A	; 90
    3334:	1f 4f       	sbci	r17, 0xFF	; 255
	
		while (!isInitialized)
		{
			initSimTelemTask->runTaskImpl();
    3336:	d2 01       	movw	r26, r4
    3338:	ed 91       	ld	r30, X+
    333a:	fc 91       	ld	r31, X
    333c:	01 90       	ld	r0, Z+
    333e:	f0 81       	ld	r31, Z
    3340:	e0 2d       	mov	r30, r0
    3342:	c2 01       	movw	r24, r4
    3344:	19 95       	eicall

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    3346:	e9 81       	ldd	r30, Y+1	; 0x01
    3348:	fa 81       	ldd	r31, Y+2	; 0x02
    334a:	c0 80       	ld	r12, Z
    334c:	d1 80       	ldd	r13, Z+1	; 0x01
    334e:	e2 80       	ldd	r14, Z+2	; 0x02
    3350:	f3 80       	ldd	r15, Z+3	; 0x03
		
			if (model->LatitudeDegrees() != 0 && model->LongitudeDegrees() != 0)
    3352:	20 e0       	ldi	r18, 0x00	; 0
    3354:	30 e0       	ldi	r19, 0x00	; 0
    3356:	a9 01       	movw	r20, r18
    3358:	c7 01       	movw	r24, r14
    335a:	b6 01       	movw	r22, r12
    335c:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    3360:	88 23       	and	r24, r24
    3362:	61 f0       	breq	.+24     	; 0x337c <main+0xe52>
    3364:	20 e0       	ldi	r18, 0x00	; 0
    3366:	30 e0       	ldi	r19, 0x00	; 0
    3368:	a9 01       	movw	r20, r18
    336a:	d8 01       	movw	r26, r16
    336c:	6d 91       	ld	r22, X+
    336e:	7d 91       	ld	r23, X+
    3370:	8d 91       	ld	r24, X+
    3372:	9c 91       	ld	r25, X
    3374:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    3378:	81 11       	cpse	r24, r1
    337a:	34 c0       	rjmp	.+104    	; 0x33e4 <main+0xeba>
    337c:	bf ef       	ldi	r27, 0xFF	; 255
    337e:	e1 ee       	ldi	r30, 0xE1	; 225
    3380:	f4 e0       	ldi	r31, 0x04	; 4
    3382:	b1 50       	subi	r27, 0x01	; 1
    3384:	e0 40       	sbci	r30, 0x00	; 0
    3386:	f0 40       	sbci	r31, 0x00	; 0
    3388:	e1 f7       	brne	.-8      	; 0x3382 <main+0xe58>
    338a:	00 c0       	rjmp	.+0      	; 0x338c <main+0xe62>
    338c:	00 00       	nop
    338e:	d3 cf       	rjmp	.-90     	; 0x3336 <main+0xe0c>
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    3390:	d2 01       	movw	r26, r4
    3392:	ed 91       	ld	r30, X+
    3394:	fc 91       	ld	r31, X
    3396:	04 80       	ldd	r0, Z+4	; 0x04
    3398:	f5 81       	ldd	r31, Z+5	; 0x05
    339a:	e0 2d       	mov	r30, r0
    339c:	c2 01       	movw	r24, r4
    339e:	19 95       	eicall
		delete initGcsInterface;
    33a0:	a1 14       	cp	r10, r1
    33a2:	b1 04       	cpc	r11, r1
    33a4:	09 f4       	brne	.+2      	; 0x33a8 <main+0xe7e>
    33a6:	9d c0       	rjmp	.+314    	; 0x34e2 <main+0xfb8>
    33a8:	c5 01       	movw	r24, r10
    33aa:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    33ae:	99 c0       	rjmp	.+306    	; 0x34e2 <main+0xfb8>
	{

	
		//Checks to see if any tasks are ready to run an executes them.
		//goes to sleep (until the next timer tick) after processing all available tasks.
		scheduler->dispatch();
    33b0:	c8 01       	movw	r24, r16
    33b2:	0e 94 e2 3f 	call	0x7fc4	; 0x7fc4 <_ZN10helicopter9scheduler9Scheduler8dispatchEv>
		
		/**
		 * Determine if the last processing frame was blown.
		 */
		if (scheduler->hasBlownFrame())
    33b6:	f8 01       	movw	r30, r16
    33b8:	80 ad       	ldd	r24, Z+56	; 0x38
    33ba:	88 23       	and	r24, r24
    33bc:	c9 f3       	breq	.-14     	; 0x33b0 <main+0xe86>
		{
			pidController->addBlownFrame();
    33be:	c1 01       	movw	r24, r2
    33c0:	0e 94 22 03 	call	0x644	; 0x644 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>
    33c4:	f5 cf       	rjmp	.-22     	; 0x33b0 <main+0xe86>
    33c6:	d8 a6       	std	Y+40, r13	; 0x28
    33c8:	cf a2       	std	Y+39, r12	; 0x27
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    33ca:	0a e0       	ldi	r16, 0x0A	; 10
    33cc:	10 e0       	ldi	r17, 0x00	; 0
    33ce:	c1 2c       	mov	r12, r1
    33d0:	d1 2c       	mov	r13, r1
    33d2:	76 01       	movw	r14, r12
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    33d4:	94 01       	movw	r18, r8
    33d6:	2a 5e       	subi	r18, 0xEA	; 234
    33d8:	3e 4f       	sbci	r19, 0xFE	; 254
    33da:	3a 83       	std	Y+2, r19	; 0x02
    33dc:	29 83       	std	Y+1, r18	; 0x01
    33de:	4f a0       	ldd	r4, Y+39	; 0x27
    33e0:	58 a4       	ldd	r5, Y+40	; 0x28
    33e2:	a6 ce       	rjmp	.-692    	; 0x3130 <main+0xc06>
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    33e4:	84 01       	movw	r16, r8
    33e6:	02 54       	subi	r16, 0x42	; 66
    33e8:	1f 4f       	sbci	r17, 0xFF	; 255
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    33ea:	f4 01       	movw	r30, r8
    33ec:	e2 50       	subi	r30, 0x02	; 2
    33ee:	ff 4f       	sbci	r31, 0xFF	; 255
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    33f0:	60 81       	ld	r22, Z
    33f2:	71 81       	ldd	r23, Z+1	; 0x01
    33f4:	82 81       	ldd	r24, Z+2	; 0x02
    33f6:	93 81       	ldd	r25, Z+3	; 0x03
    33f8:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    33fc:	d8 01       	movw	r26, r16
    33fe:	6d 93       	st	X+, r22
    3400:	7d 93       	st	X+, r23
    3402:	8d 93       	st	X+, r24
    3404:	9c 93       	st	X, r25
    3406:	13 97       	sbiw	r26, 0x03	; 3

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    3408:	0c 5f       	subi	r16, 0xFC	; 252
    340a:	1f 4f       	sbci	r17, 0xFF	; 255
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    340c:	f4 01       	movw	r30, r8
    340e:	ee 5f       	subi	r30, 0xFE	; 254
    3410:	fe 4f       	sbci	r31, 0xFE	; 254

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    3412:	60 81       	ld	r22, Z
    3414:	71 81       	ldd	r23, Z+1	; 0x01
    3416:	82 81       	ldd	r24, Z+2	; 0x02
    3418:	93 81       	ldd	r25, Z+3	; 0x03
    341a:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    341e:	f8 01       	movw	r30, r16
    3420:	60 83       	st	Z, r22
    3422:	71 83       	std	Z+1, r23	; 0x01
    3424:	82 83       	std	Z+2, r24	; 0x02
    3426:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    3428:	0c 5f       	subi	r16, 0xFC	; 252
    342a:	1f 4f       	sbci	r17, 0xFF	; 255
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    342c:	ec 5b       	subi	r30, 0xBC	; 188
    342e:	ff 4f       	sbci	r31, 0xFF	; 255

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    3430:	60 81       	ld	r22, Z
    3432:	71 81       	ldd	r23, Z+1	; 0x01
    3434:	82 81       	ldd	r24, Z+2	; 0x02
    3436:	93 81       	ldd	r25, Z+3	; 0x03
    3438:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    343c:	d8 01       	movw	r26, r16
    343e:	6d 93       	st	X+, r22
    3440:	7d 93       	st	X+, r23
    3442:	8d 93       	st	X+, r24
    3444:	9c 93       	st	X, r25
    3446:	13 97       	sbiw	r26, 0x03	; 3
				model->InitialYPositionEcef(model->YEcefCm());
				model->InitialZPositionEcef(model->ZEcefCm());
			
			
				////ecefReferenceX, ecefReferenceY, ecefReferenceZ,ecefToLocalNEDRotationMatrix,
				CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    3448:	08 5a       	subi	r16, 0xA8	; 168
    344a:	1f 4f       	sbci	r17, 0xFF	; 255
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    344c:	f4 01       	movw	r30, r8
    344e:	ea 55       	subi	r30, 0x5A	; 90
    3450:	ff 4f       	sbci	r31, 0xFF	; 255
    3452:	20 81       	ld	r18, Z
    3454:	31 81       	ldd	r19, Z+1	; 0x01
    3456:	42 81       	ldd	r20, Z+2	; 0x02
    3458:	53 81       	ldd	r21, Z+3	; 0x03
    345a:	c7 01       	movw	r24, r14
    345c:	b6 01       	movw	r22, r12
    345e:	0e 94 16 61 	call	0xc22c	; 0xc22c <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    3462:	f4 01       	movw	r30, r8
    3464:	ea 5e       	subi	r30, 0xEA	; 234
    3466:	fe 4f       	sbci	r31, 0xFE	; 254
				//multiply by -1 because in NED/FRD frame, down is positive. 
				//model->InitialAltitudeMeters(((288.15/(6.5/1000.0))*(1-(pow((model->PressureMillibars()/101325.0),(6.5/1000.0)*(287.052/9.78))))) * -1);
			
				//https://www.brisbanehotairballooning.com.au/faqs/education/113-pressure-altitude-conversion.html
				//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    3468:	20 e0       	ldi	r18, 0x00	; 0
    346a:	30 e5       	ldi	r19, 0x50	; 80
    346c:	4d e7       	ldi	r20, 0x7D	; 125
    346e:	54 e4       	ldi	r21, 0x44	; 68
    3470:	60 81       	ld	r22, Z
    3472:	71 81       	ldd	r23, Z+1	; 0x01
    3474:	82 81       	ldd	r24, Z+2	; 0x02
    3476:	93 81       	ldd	r25, Z+3	; 0x03
    3478:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    347c:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <log10>
    3480:	2b e2       	ldi	r18, 0x2B	; 43
    3482:	30 e3       	ldi	r19, 0x30	; 48
    3484:	48 ea       	ldi	r20, 0xA8	; 168
    3486:	50 e4       	ldi	r21, 0x40	; 64
    3488:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    348c:	9b 01       	movw	r18, r22
    348e:	ac 01       	movw	r20, r24
    3490:	60 e0       	ldi	r22, 0x00	; 0
    3492:	70 e0       	ldi	r23, 0x00	; 0
    3494:	80 e2       	ldi	r24, 0x20	; 32
    3496:	91 e4       	ldi	r25, 0x41	; 65
    3498:	0e 94 80 6a 	call	0xd500	; 0xd500 <pow>
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    349c:	74 01       	movw	r14, r8
    349e:	ba ec       	ldi	r27, 0xCA	; 202
    34a0:	eb 0e       	add	r14, r27
    34a2:	f1 1c       	adc	r15, r1
    34a4:	20 e0       	ldi	r18, 0x00	; 0
    34a6:	30 e0       	ldi	r19, 0x00	; 0
    34a8:	40 e8       	ldi	r20, 0x80	; 128
    34aa:	5f e3       	ldi	r21, 0x3F	; 63
    34ac:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    34b0:	29 e9       	ldi	r18, 0x99	; 153
    34b2:	3a e4       	ldi	r19, 0x4A	; 74
    34b4:	47 e8       	ldi	r20, 0x87	; 135
    34b6:	5a e4       	ldi	r21, 0x4A	; 74
    34b8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    34bc:	f7 01       	movw	r30, r14
    34be:	60 83       	st	Z, r22
    34c0:	71 83       	std	Z+1, r23	; 0x01
    34c2:	82 83       	std	Z+2, r24	; 0x02
    34c4:	93 83       	std	Z+3, r25	; 0x03
    34c6:	ff ef       	ldi	r31, 0xFF	; 255
    34c8:	21 ee       	ldi	r18, 0xE1	; 225
    34ca:	34 e0       	ldi	r19, 0x04	; 4
    34cc:	f1 50       	subi	r31, 0x01	; 1
    34ce:	20 40       	sbci	r18, 0x00	; 0
    34d0:	30 40       	sbci	r19, 0x00	; 0
    34d2:	e1 f7       	brne	.-8      	; 0x34cc <main+0xfa2>
    34d4:	00 c0       	rjmp	.+0      	; 0x34d6 <main+0xfac>
    34d6:	00 00       	nop
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    34d8:	41 14       	cp	r4, r1
    34da:	51 04       	cpc	r5, r1
    34dc:	09 f0       	breq	.+2      	; 0x34e0 <main+0xfb6>
    34de:	58 cf       	rjmp	.-336    	; 0x3390 <main+0xe66>
    34e0:	5f cf       	rjmp	.-322    	; 0x33a0 <main+0xe76>
	
	
	if (isInitialized)
	{
		//turn red LED off to indicate initialized.
		PORTA |= (1<<PA5);
    34e2:	15 9a       	sbi	0x02, 5	; 2
	}
	
	gpsSensor->start();
    34e4:	c3 01       	movw	r24, r6
    34e6:	0e 94 08 49 	call	0x9210	; 0x9210 <_ZN10helicopter7sensors9GPSSensor5startEv>

	scheduler->init(); //Sets up the timer registers, inits all tasks,
    34ea:	8f a1       	ldd	r24, Y+39	; 0x27
    34ec:	98 a5       	ldd	r25, Y+40	; 0x28
    34ee:	0e 94 a6 3f 	call	0x7f4c	; 0x7f4c <_ZN10helicopter9scheduler9Scheduler4initEv>
	
	scheduler->start();
    34f2:	8f a1       	ldd	r24, Y+39	; 0x27
    34f4:	98 a5       	ldd	r25, Y+40	; 0x28
    34f6:	0e 94 23 40 	call	0x8046	; 0x8046 <_ZN10helicopter9scheduler9Scheduler5startEv>
	

	if (sendControlToServos)
	{
		rcInterface->init();
    34fa:	8b 89       	ldd	r24, Y+19	; 0x13
    34fc:	9c 89       	ldd	r25, Y+20	; 0x14
    34fe:	0e 94 4b 1e 	call	0x3c96	; 0x3c96 <_ZN10helicopter10interfaces24RadioControllerInterface4initEv>
		rcInterface->start();
    3502:	8b 89       	ldd	r24, Y+19	; 0x13
    3504:	9c 89       	ldd	r25, Y+20	; 0x14
    3506:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <_ZN10helicopter10interfaces24RadioControllerInterface5startEv>
    350a:	0f a1       	ldd	r16, Y+39	; 0x27
    350c:	18 a5       	ldd	r17, Y+40	; 0x28
    350e:	50 cf       	rjmp	.-352    	; 0x33b0 <main+0xe86>

00003510 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>:

using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
    3510:	0f 93       	push	r16
    3512:	1f 93       	push	r17
    3514:	cf 93       	push	r28
    3516:	df 93       	push	r29
    3518:	d9 01       	movw	r26, r18
    351a:	e8 01       	movw	r28, r16
	for (int i = 0; i < payloadSize; i++)
    351c:	14 16       	cp	r1, r20
    351e:	15 06       	cpc	r1, r21
    3520:	6c f4       	brge	.+26     	; 0x353c <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x2c>
    3522:	fb 01       	movw	r30, r22
    3524:	64 0f       	add	r22, r20
    3526:	75 1f       	adc	r23, r21
	{
		byte b = msgPayload[i];
    3528:	91 91       	ld	r25, Z+
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
    352a:	8c 91       	ld	r24, X
    352c:	89 0f       	add	r24, r25
    352e:	8c 93       	st	X, r24
		checksumB = (byte) (checksumB + checksumA);
    3530:	98 81       	ld	r25, Y
    3532:	89 0f       	add	r24, r25
    3534:	88 83       	st	Y, r24
using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
	for (int i = 0; i < payloadSize; i++)
    3536:	e6 17       	cp	r30, r22
    3538:	f7 07       	cpc	r31, r23
    353a:	b1 f7       	brne	.-20     	; 0x3528 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x18>
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
		checksumB = (byte) (checksumB + checksumA);
	}
}
    353c:	df 91       	pop	r29
    353e:	cf 91       	pop	r28
    3540:	1f 91       	pop	r17
    3542:	0f 91       	pop	r16
    3544:	08 95       	ret

00003546 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>:

int GroundControlStationInterface::transmit(Message *msgToSend)
{
    3546:	2f 92       	push	r2
    3548:	3f 92       	push	r3
    354a:	4f 92       	push	r4
    354c:	5f 92       	push	r5
    354e:	6f 92       	push	r6
    3550:	7f 92       	push	r7
    3552:	8f 92       	push	r8
    3554:	9f 92       	push	r9
    3556:	af 92       	push	r10
    3558:	bf 92       	push	r11
    355a:	cf 92       	push	r12
    355c:	df 92       	push	r13
    355e:	ef 92       	push	r14
    3560:	ff 92       	push	r15
    3562:	0f 93       	push	r16
    3564:	1f 93       	push	r17
    3566:	cf 93       	push	r28
    3568:	df 93       	push	r29
    356a:	00 d0       	rcall	.+0      	; 0x356c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x26>
    356c:	1f 92       	push	r1
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
    3572:	5c 01       	movw	r10, r24
    3574:	8b 01       	movw	r16, r22
		}
	
	}
	
	return status;
}
    3576:	4d b6       	in	r4, 0x3d	; 61
    3578:	5e b6       	in	r5, 0x3e	; 62

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
	
	if (msgToSend != NULL)
    357a:	61 15       	cp	r22, r1
    357c:	71 05       	cpc	r23, r1
    357e:	09 f4       	brne	.+2      	; 0x3582 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x3c>
    3580:	96 c0       	rjmp	.+300    	; 0x36ae <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x168>
	{
		byte *msgPayload = msgToSend->getBytes();
    3582:	db 01       	movw	r26, r22
    3584:	ed 91       	ld	r30, X+
    3586:	fc 91       	ld	r31, X
    3588:	04 80       	ldd	r0, Z+4	; 0x04
    358a:	f5 81       	ldd	r31, Z+5	; 0x05
    358c:	e0 2d       	mov	r30, r0
    358e:	cb 01       	movw	r24, r22
    3590:	19 95       	eicall
    3592:	3c 01       	movw	r6, r24
    3594:	ed b7       	in	r30, 0x3d	; 61
    3596:	fe b7       	in	r31, 0x3e	; 62
    3598:	fc 83       	std	Y+4, r31	; 0x04
    359a:	eb 83       	std	Y+3, r30	; 0x03
		//check for out of memory. (shouldn't be necessary).
		//if (msgPayload != NULL)
		{
			
		
			int payloadSize = msgToSend->getMessageSize();
    359c:	c8 01       	movw	r24, r16
    359e:	0e 94 05 26 	call	0x4c0a	; 0x4c0a <_ZN10helicopter8messages7Message14getMessageSizeEv>
    35a2:	7c 01       	movw	r14, r24
		
			int completeMsgSize = payloadSize + MsgHeaderFooterSize;;
    35a4:	4c 01       	movw	r8, r24
    35a6:	f5 e0       	ldi	r31, 0x05	; 5
    35a8:	8f 0e       	add	r8, r31
    35aa:	91 1c       	adc	r9, r1

			byte completeMsg[completeMsgSize];
    35ac:	1c 01       	movw	r2, r24
    35ae:	84 e0       	ldi	r24, 0x04	; 4
    35b0:	28 0e       	add	r2, r24
    35b2:	31 1c       	adc	r3, r1
    35b4:	ad b7       	in	r26, 0x3d	; 61
    35b6:	be b7       	in	r27, 0x3e	; 62
    35b8:	a8 19       	sub	r26, r8
    35ba:	b9 09       	sbc	r27, r9
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	be bf       	out	0x3e, r27	; 62
    35c2:	0f be       	out	0x3f, r0	; 63
    35c4:	ad bf       	out	0x3d, r26	; 61
    35c6:	ed b7       	in	r30, 0x3d	; 61
    35c8:	fe b7       	in	r31, 0x3e	; 62
    35ca:	31 96       	adiw	r30, 0x01	; 1
    35cc:	6f 01       	movw	r12, r30
		
			completeMsg[0] = GroundControlStationInterface::SyncByte1;
    35ce:	85 eb       	ldi	r24, 0xB5	; 181
    35d0:	11 96       	adiw	r26, 0x01	; 1
    35d2:	8c 93       	st	X, r24
			completeMsg[1] = GroundControlStationInterface::SyncByte2;
    35d4:	82 e6       	ldi	r24, 0x62	; 98
    35d6:	81 83       	std	Z+1, r24	; 0x01
			completeMsg[2] = GroundControlStationInterface::SyncByte3;
    35d8:	87 ed       	ldi	r24, 0xD7	; 215
    35da:	82 83       	std	Z+2, r24	; 0x02
		
			memcpy(&completeMsg[3], msgPayload, payloadSize);
    35dc:	8d b7       	in	r24, 0x3d	; 61
    35de:	9e b7       	in	r25, 0x3e	; 62
    35e0:	04 96       	adiw	r24, 0x04	; 4
    35e2:	a7 01       	movw	r20, r14
    35e4:	b3 01       	movw	r22, r6
    35e6:	0e 94 ba 6d 	call	0xdb74	; 0xdb74 <memcpy>
		
			byte checksumA = 0;
    35ea:	1a 82       	std	Y+2, r1	; 0x02
			byte checksumB = 0;
    35ec:	19 82       	std	Y+1, r1	; 0x01
		
			calculateChecksum(msgPayload, payloadSize, checksumA, checksumB);
    35ee:	8e 01       	movw	r16, r28
    35f0:	0f 5f       	subi	r16, 0xFF	; 255
    35f2:	1f 4f       	sbci	r17, 0xFF	; 255
    35f4:	9e 01       	movw	r18, r28
    35f6:	2e 5f       	subi	r18, 0xFE	; 254
    35f8:	3f 4f       	sbci	r19, 0xFF	; 255
    35fa:	a7 01       	movw	r20, r14
    35fc:	b3 01       	movw	r22, r6
    35fe:	c5 01       	movw	r24, r10
    3600:	0e 94 88 1a 	call	0x3510	; 0x3510 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
		
			completeMsg[completeMsgSize - 2] = checksumA;
    3604:	f6 01       	movw	r30, r12
    3606:	ee 0d       	add	r30, r14
    3608:	ff 1d       	adc	r31, r15
    360a:	8a 81       	ldd	r24, Y+2	; 0x02
    360c:	83 83       	std	Z+3, r24	; 0x03
			completeMsg[completeMsgSize - 1] = checksumB;
    360e:	f6 01       	movw	r30, r12
    3610:	e2 0d       	add	r30, r2
    3612:	f3 1d       	adc	r31, r3
    3614:	89 81       	ldd	r24, Y+1	; 0x01
    3616:	80 83       	st	Z, r24
		
			serialDriver->startTimer();
    3618:	f5 01       	movw	r30, r10
    361a:	80 81       	ld	r24, Z
    361c:	91 81       	ldd	r25, Z+1	; 0x01
    361e:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    3622:	18 14       	cp	r1, r8
    3624:	19 04       	cpc	r1, r9
    3626:	c4 f4       	brge	.+48     	; 0x3658 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x112>
    3628:	00 e0       	ldi	r16, 0x00	; 0
    362a:	10 e0       	ldi	r17, 0x00	; 0
			{
				status = serialDriver->transmit(completeMsg[i]);
    362c:	d5 01       	movw	r26, r10
    362e:	8d 91       	ld	r24, X+
    3630:	9c 91       	ld	r25, X
    3632:	f6 01       	movw	r30, r12
    3634:	61 91       	ld	r22, Z+
    3636:	6f 01       	movw	r12, r30
    3638:	dc 01       	movw	r26, r24
    363a:	ed 91       	ld	r30, X+
    363c:	fc 91       	ld	r31, X
    363e:	06 80       	ldd	r0, Z+6	; 0x06
    3640:	f7 81       	ldd	r31, Z+7	; 0x07
    3642:	e0 2d       	mov	r30, r0
    3644:	19 95       	eicall
    3646:	7c 01       	movw	r14, r24
			completeMsg[completeMsgSize - 1] = checksumB;
		
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    3648:	0f 5f       	subi	r16, 0xFF	; 255
    364a:	1f 4f       	sbci	r17, 0xFF	; 255
    364c:	08 15       	cp	r16, r8
    364e:	19 05       	cpc	r17, r9
    3650:	2c f4       	brge	.+10     	; 0x365c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x116>
    3652:	00 97       	sbiw	r24, 0x00	; 0
    3654:	59 f3       	breq	.-42     	; 0x362c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0xe6>
    3656:	02 c0       	rjmp	.+4      	; 0x365c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x116>
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    3658:	e1 2c       	mov	r14, r1
    365a:	f1 2c       	mov	r15, r1
			for (int i = 0; i < completeMsgSize && status == 0; i++)
			{
				status = serialDriver->transmit(completeMsg[i]);
			}
		
			serialDriver->stopTimer();
    365c:	f5 01       	movw	r30, r10
    365e:	80 81       	ld	r24, Z
    3660:	91 81       	ldd	r25, Z+1	; 0x01
    3662:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
		
			delete [] msgPayload;
    3666:	61 14       	cp	r6, r1
    3668:	71 04       	cpc	r7, r1
    366a:	19 f0       	breq	.+6      	; 0x3672 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x12c>
    366c:	c3 01       	movw	r24, r6
    366e:	0e 94 11 61 	call	0xc222	; 0xc222 <_ZdaPv>
			msgPayload = NULL;
		
			
			if (serialDriver->asyncReceiveTransmitData)
    3672:	d5 01       	movw	r26, r10
    3674:	ed 91       	ld	r30, X+
    3676:	fc 91       	ld	r31, X
    3678:	80 85       	ldd	r24, Z+8	; 0x08
    367a:	88 23       	and	r24, r24
    367c:	81 f0       	breq	.+32     	; 0x369e <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x158>
			{
				//Enable data register empty interrupt so the next byte will be transmitted.
				//I added this code here because enabling interrupts after every byte caused it to not transmit all the data. the system didn't like rapidly enabling interrupts.
				if (serialDriver->uartPort == SerialDriver::Zero)
    367e:	86 81       	ldd	r24, Z+6	; 0x06
    3680:	81 11       	cpse	r24, r1
    3682:	06 c0       	rjmp	.+12     	; 0x3690 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x14a>
				{
					UCSR0B |= (1<<UDRIE0);
    3684:	e1 ec       	ldi	r30, 0xC1	; 193
    3686:	f0 e0       	ldi	r31, 0x00	; 0
    3688:	80 81       	ld	r24, Z
    368a:	80 62       	ori	r24, 0x20	; 32
    368c:	80 83       	st	Z, r24
    368e:	07 c0       	rjmp	.+14     	; 0x369e <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x158>
				}else if (serialDriver->uartPort == SerialDriver::One)
    3690:	81 30       	cpi	r24, 0x01	; 1
    3692:	29 f4       	brne	.+10     	; 0x369e <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x158>
				{
					UCSR1B |= (1<<UDRIE1);
    3694:	e9 ec       	ldi	r30, 0xC9	; 201
    3696:	f0 e0       	ldi	r31, 0x00	; 0
    3698:	80 81       	ld	r24, Z
    369a:	80 62       	ori	r24, 0x20	; 32
    369c:	80 83       	st	Z, r24
    369e:	eb 81       	ldd	r30, Y+3	; 0x03
    36a0:	fc 81       	ldd	r31, Y+4	; 0x04
    36a2:	0f b6       	in	r0, 0x3f	; 63
    36a4:	f8 94       	cli
    36a6:	fe bf       	out	0x3e, r31	; 62
    36a8:	0f be       	out	0x3f, r0	; 63
    36aa:	ed bf       	out	0x3d, r30	; 61
    36ac:	02 c0       	rjmp	.+4      	; 0x36b2 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x16c>
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    36ae:	e1 2c       	mov	r14, r1
    36b0:	f1 2c       	mov	r15, r1
		}
	
	}
	
	return status;
}
    36b2:	c7 01       	movw	r24, r14
    36b4:	0f b6       	in	r0, 0x3f	; 63
    36b6:	f8 94       	cli
    36b8:	5e be       	out	0x3e, r5	; 62
    36ba:	0f be       	out	0x3f, r0	; 63
    36bc:	4d be       	out	0x3d, r4	; 61
    36be:	0f 90       	pop	r0
    36c0:	0f 90       	pop	r0
    36c2:	0f 90       	pop	r0
    36c4:	0f 90       	pop	r0
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	1f 91       	pop	r17
    36cc:	0f 91       	pop	r16
    36ce:	ff 90       	pop	r15
    36d0:	ef 90       	pop	r14
    36d2:	df 90       	pop	r13
    36d4:	cf 90       	pop	r12
    36d6:	bf 90       	pop	r11
    36d8:	af 90       	pop	r10
    36da:	9f 90       	pop	r9
    36dc:	8f 90       	pop	r8
    36de:	7f 90       	pop	r7
    36e0:	6f 90       	pop	r6
    36e2:	5f 90       	pop	r5
    36e4:	4f 90       	pop	r4
    36e6:	3f 90       	pop	r3
    36e8:	2f 90       	pop	r2
    36ea:	08 95       	ret

000036ec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>:
 * a lot of data is constantly received before that timeout, and none of the data
 * is a sync byte, then this method will never stop receiving bytes and will
 * lock up the rest of the system. So the helicopter would crash waiting for data.
 */
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
    36ec:	2f 92       	push	r2
    36ee:	3f 92       	push	r3
    36f0:	4f 92       	push	r4
    36f2:	5f 92       	push	r5
    36f4:	6f 92       	push	r6
    36f6:	7f 92       	push	r7
    36f8:	8f 92       	push	r8
    36fa:	9f 92       	push	r9
    36fc:	af 92       	push	r10
    36fe:	bf 92       	push	r11
    3700:	cf 92       	push	r12
    3702:	df 92       	push	r13
    3704:	ef 92       	push	r14
    3706:	ff 92       	push	r15
    3708:	0f 93       	push	r16
    370a:	1f 93       	push	r17
    370c:	cf 93       	push	r28
    370e:	df 93       	push	r29
    3710:	cd b7       	in	r28, 0x3d	; 61
    3712:	de b7       	in	r29, 0x3e	; 62
    3714:	28 97       	sbiw	r28, 0x08	; 8
    3716:	0f b6       	in	r0, 0x3f	; 63
    3718:	f8 94       	cli
    371a:	de bf       	out	0x3e, r29	; 62
    371c:	0f be       	out	0x3f, r0	; 63
    371e:	cd bf       	out	0x3d, r28	; 61
    3720:	6c 01       	movw	r12, r24
    3722:	4b 01       	movw	r8, r22
	}
	
	serialDriver->stopTimer();
	
	return status;
    3724:	ad b6       	in	r10, 0x3d	; 61
    3726:	be b6       	in	r11, 0x3e	; 62
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    byte thirdSyncByte = 0;
    3728:	1e 82       	std	Y+6, r1	; 0x06
	
	/**
	 * Start the timer to prevent the system from waiting indefinitely
	 * while it receives data (thus causing the helicopter to crash)
	 */
	serialDriver->startTimer();
    372a:	dc 01       	movw	r26, r24
    372c:	8d 91       	ld	r24, X+
    372e:	9c 91       	ld	r25, X
    3730:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    3734:	00 e0       	ldi	r16, 0x00	; 0
    3736:	01 c0       	rjmp	.+2      	; 0x373a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x4e>
    3738:	01 2f       	mov	r16, r17
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
	{
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
    373a:	1e 81       	ldd	r17, Y+6	; 0x06
		status = serialDriver->receive(thirdSyncByte);
    373c:	f6 01       	movw	r30, r12
    373e:	80 81       	ld	r24, Z
    3740:	91 81       	ldd	r25, Z+1	; 0x01
    3742:	dc 01       	movw	r26, r24
    3744:	ed 91       	ld	r30, X+
    3746:	fc 91       	ld	r31, X
    3748:	02 88       	ldd	r0, Z+18	; 0x12
    374a:	f3 89       	ldd	r31, Z+19	; 0x13
    374c:	e0 2d       	mov	r30, r0
    374e:	be 01       	movw	r22, r28
    3750:	6a 5f       	subi	r22, 0xFA	; 250
    3752:	7f 4f       	sbci	r23, 0xFF	; 255
    3754:	19 95       	eicall
    3756:	7c 01       	movw	r14, r24
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3758:	05 3b       	cpi	r16, 0xB5	; 181
    375a:	29 f4       	brne	.+10     	; 0x3766 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x7a>
    375c:	12 36       	cpi	r17, 0x62	; 98
    375e:	19 f4       	brne	.+6      	; 0x3766 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x7a>
    3760:	8e 81       	ldd	r24, Y+6	; 0x06
    3762:	87 3d       	cpi	r24, 0xD7	; 215
    3764:	29 f0       	breq	.+10     	; 0x3770 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x84>
    3766:	bf ef       	ldi	r27, 0xFF	; 255
    3768:	eb 16       	cp	r14, r27
    376a:	fb 06       	cpc	r15, r27
    376c:	29 f7       	brne	.-54     	; 0x3738 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x4c>
    376e:	ee c0       	rjmp	.+476    	; 0x394c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x260>
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
		status = serialDriver->receive(thirdSyncByte);
	}
	
	if (status == 0)
    3770:	e1 14       	cp	r14, r1
    3772:	f1 04       	cpc	r15, r1
    3774:	09 f0       	breq	.+2      	; 0x3778 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x8c>
    3776:	ea c0       	rjmp	.+468    	; 0x394c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x260>
	{
		//once we have found a valid message, get the message ID
		byte msgType = 0;
    3778:	1d 82       	std	Y+5, r1	; 0x05
		
		status = serialDriver->receive(msgType);
    377a:	f6 01       	movw	r30, r12
    377c:	80 81       	ld	r24, Z
    377e:	91 81       	ldd	r25, Z+1	; 0x01
    3780:	dc 01       	movw	r26, r24
    3782:	ed 91       	ld	r30, X+
    3784:	fc 91       	ld	r31, X
    3786:	02 88       	ldd	r0, Z+18	; 0x12
    3788:	f3 89       	ldd	r31, Z+19	; 0x13
    378a:	e0 2d       	mov	r30, r0
    378c:	be 01       	movw	r22, r28
    378e:	6b 5f       	subi	r22, 0xFB	; 251
    3790:	7f 4f       	sbci	r23, 0xFF	; 255
    3792:	19 95       	eicall
    3794:	7c 01       	movw	r14, r24
		
		if (status == 0)
    3796:	00 97       	sbiw	r24, 0x00	; 0
    3798:	09 f0       	breq	.+2      	; 0x379c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xb0>
    379a:	d8 c0       	rjmp	.+432    	; 0x394c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x260>
		{
			int msgSize = 0;
			
			switch(msgType)
    379c:	8d 81       	ldd	r24, Y+5	; 0x05
    379e:	84 30       	cpi	r24, 0x04	; 4
    37a0:	09 f4       	brne	.+2      	; 0x37a4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xb8>
    37a2:	d8 c0       	rjmp	.+432    	; 0x3954 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x268>
    37a4:	18 f4       	brcc	.+6      	; 0x37ac <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xc0>
    37a6:	82 30       	cpi	r24, 0x02	; 2
    37a8:	69 f0       	breq	.+26     	; 0x37c4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xd8>
    37aa:	c7 c0       	rjmp	.+398    	; 0x393a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24e>
    37ac:	86 30       	cpi	r24, 0x06	; 6
    37ae:	09 f4       	brne	.+2      	; 0x37b2 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xc6>
    37b0:	d7 c0       	rjmp	.+430    	; 0x3960 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x274>
    37b2:	87 30       	cpi	r24, 0x07	; 7
    37b4:	09 f0       	breq	.+2      	; 0x37b8 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xcc>
    37b6:	c1 c0       	rjmp	.+386    	; 0x393a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24e>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
					break;
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
    37b8:	0f 2e       	mov	r0, r31
    37ba:	f1 e6       	ldi	r31, 0x61	; 97
    37bc:	2f 2e       	mov	r2, r31
    37be:	31 2c       	mov	r3, r1
    37c0:	f0 2d       	mov	r31, r0
					break;					
    37c2:	06 c0       	rjmp	.+12     	; 0x37d0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xe4>
			int msgSize = 0;
			
			switch(msgType)
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
    37c4:	0f 2e       	mov	r0, r31
    37c6:	fd e2       	ldi	r31, 0x2D	; 45
    37c8:	2f 2e       	mov	r2, r31
    37ca:	33 24       	eor	r3, r3
    37cc:	33 94       	inc	r3
    37ce:	f0 2d       	mov	r31, r0
    37d0:	ed b7       	in	r30, 0x3d	; 61
    37d2:	fe b7       	in	r31, 0x3e	; 62
    37d4:	f8 87       	std	Y+8, r31	; 0x08
    37d6:	ef 83       	std	Y+7, r30	; 0x07
					break;
			}
			
			if (status == 0)
			{
				byte messagePayload[msgSize];
    37d8:	2d b7       	in	r18, 0x3d	; 61
    37da:	3e b7       	in	r19, 0x3e	; 62
    37dc:	22 19       	sub	r18, r2
    37de:	33 09       	sbc	r19, r3
    37e0:	0f b6       	in	r0, 0x3f	; 63
    37e2:	f8 94       	cli
    37e4:	3e bf       	out	0x3e, r19	; 62
    37e6:	0f be       	out	0x3f, r0	; 63
    37e8:	2d bf       	out	0x3d, r18	; 61
    37ea:	ad b7       	in	r26, 0x3d	; 61
    37ec:	be b7       	in	r27, 0x3e	; 62
    37ee:	11 96       	adiw	r26, 0x01	; 1
    37f0:	2d 01       	movw	r4, r26
							
				messagePayload[0] = msgType;
    37f2:	ed b7       	in	r30, 0x3d	; 61
    37f4:	fe b7       	in	r31, 0x3e	; 62
    37f6:	81 83       	std	Z+1, r24	; 0x01
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    37f8:	f2 e0       	ldi	r31, 0x02	; 2
    37fa:	2f 16       	cp	r2, r31
    37fc:	31 04       	cpc	r3, r1
    37fe:	04 f1       	brlt	.+64     	; 0x3840 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x154>
    3800:	8d 01       	movw	r16, r26
    3802:	0f 5f       	subi	r16, 0xFF	; 255
    3804:	1f 4f       	sbci	r17, 0xFF	; 255
    3806:	3d 01       	movw	r6, r26
    3808:	62 0c       	add	r6, r2
    380a:	73 1c       	adc	r7, r3
    380c:	21 e0       	ldi	r18, 0x01	; 1
    380e:	62 1a       	sub	r6, r18
    3810:	71 08       	sbc	r7, r1
				{
					status = serialDriver->receive(messagePayload[i]);
    3812:	d6 01       	movw	r26, r12
    3814:	8d 91       	ld	r24, X+
    3816:	9c 91       	ld	r25, X
    3818:	dc 01       	movw	r26, r24
    381a:	ed 91       	ld	r30, X+
    381c:	fc 91       	ld	r31, X
    381e:	02 88       	ldd	r0, Z+18	; 0x12
    3820:	f3 89       	ldd	r31, Z+19	; 0x13
    3822:	e0 2d       	mov	r30, r0
    3824:	b8 01       	movw	r22, r16
    3826:	19 95       	eicall
    3828:	7c 01       	movw	r14, r24
							
				messagePayload[0] = msgType;
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    382a:	06 15       	cp	r16, r6
    382c:	17 05       	cpc	r17, r7
    382e:	29 f0       	breq	.+10     	; 0x383a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x14e>
    3830:	0f 5f       	subi	r16, 0xFF	; 255
    3832:	1f 4f       	sbci	r17, 0xFF	; 255
    3834:	00 97       	sbiw	r24, 0x00	; 0
    3836:	69 f3       	breq	.-38     	; 0x3812 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x126>
    3838:	78 c0       	rjmp	.+240    	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
				{
					status = serialDriver->receive(messagePayload[i]);
				}
							
				if (status == 0)
    383a:	00 97       	sbiw	r24, 0x00	; 0
    383c:	09 f0       	breq	.+2      	; 0x3840 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x154>
    383e:	75 c0       	rjmp	.+234    	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
				{
					//Read the two checksum bytes
					byte messageChecksumA = 0;
    3840:	1c 82       	std	Y+4, r1	; 0x04
					byte messageChecksumB = 0;
    3842:	1b 82       	std	Y+3, r1	; 0x03
					byte calculatedChecksumA = 0;
    3844:	1a 82       	std	Y+2, r1	; 0x02
					byte calculatedChecksumB = 0;
    3846:	19 82       	std	Y+1, r1	; 0x01
								
					status = serialDriver->receive(messageChecksumA);
    3848:	f6 01       	movw	r30, r12
    384a:	80 81       	ld	r24, Z
    384c:	91 81       	ldd	r25, Z+1	; 0x01
    384e:	dc 01       	movw	r26, r24
    3850:	ed 91       	ld	r30, X+
    3852:	fc 91       	ld	r31, X
    3854:	02 88       	ldd	r0, Z+18	; 0x12
    3856:	f3 89       	ldd	r31, Z+19	; 0x13
    3858:	e0 2d       	mov	r30, r0
    385a:	be 01       	movw	r22, r28
    385c:	6c 5f       	subi	r22, 0xFC	; 252
    385e:	7f 4f       	sbci	r23, 0xFF	; 255
    3860:	19 95       	eicall
    3862:	7c 01       	movw	r14, r24
					
					if (status == 0)
    3864:	00 97       	sbiw	r24, 0x00	; 0
    3866:	09 f0       	breq	.+2      	; 0x386a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x17e>
    3868:	60 c0       	rjmp	.+192    	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
					{
						status = serialDriver->receive(messageChecksumB);
    386a:	f6 01       	movw	r30, r12
    386c:	80 81       	ld	r24, Z
    386e:	91 81       	ldd	r25, Z+1	; 0x01
    3870:	dc 01       	movw	r26, r24
    3872:	ed 91       	ld	r30, X+
    3874:	fc 91       	ld	r31, X
    3876:	02 88       	ldd	r0, Z+18	; 0x12
    3878:	f3 89       	ldd	r31, Z+19	; 0x13
    387a:	e0 2d       	mov	r30, r0
    387c:	be 01       	movw	r22, r28
    387e:	6d 5f       	subi	r22, 0xFD	; 253
    3880:	7f 4f       	sbci	r23, 0xFF	; 255
    3882:	19 95       	eicall
    3884:	7c 01       	movw	r14, r24
						
						if (status == 0)
    3886:	00 97       	sbiw	r24, 0x00	; 0
    3888:	09 f0       	breq	.+2      	; 0x388c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1a0>
    388a:	4f c0       	rjmp	.+158    	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
						{
							//Generate checksum for the message
							calculateChecksum(messagePayload, msgSize, calculatedChecksumA, calculatedChecksumB);
    388c:	8e 01       	movw	r16, r28
    388e:	0f 5f       	subi	r16, 0xFF	; 255
    3890:	1f 4f       	sbci	r17, 0xFF	; 255
    3892:	9e 01       	movw	r18, r28
    3894:	2e 5f       	subi	r18, 0xFE	; 254
    3896:	3f 4f       	sbci	r19, 0xFF	; 255
    3898:	a1 01       	movw	r20, r2
    389a:	b2 01       	movw	r22, r4
    389c:	c6 01       	movw	r24, r12
    389e:	0e 94 88 1a 	call	0x3510	; 0x3510 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
						
							//verify that the checksum is correct
							if (calculatedChecksumA == messageChecksumA && calculatedChecksumB == messageChecksumB)
    38a2:	9a 81       	ldd	r25, Y+2	; 0x02
    38a4:	8c 81       	ldd	r24, Y+4	; 0x04
    38a6:	98 13       	cpse	r25, r24
    38a8:	2c c0       	rjmp	.+88     	; 0x3902 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x216>
    38aa:	99 81       	ldd	r25, Y+1	; 0x01
    38ac:	8b 81       	ldd	r24, Y+3	; 0x03
    38ae:	98 13       	cpse	r25, r24
    38b0:	2f c0       	rjmp	.+94     	; 0x3910 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x224>
							{
								//build the message
								switch(msgType)
    38b2:	8d 81       	ldd	r24, Y+5	; 0x05
    38b4:	84 30       	cpi	r24, 0x04	; 4
    38b6:	81 f0       	breq	.+32     	; 0x38d8 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ec>
    38b8:	18 f4       	brcc	.+6      	; 0x38c0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1d4>
    38ba:	82 30       	cpi	r24, 0x02	; 2
    38bc:	31 f0       	breq	.+12     	; 0x38ca <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1de>
    38be:	2f c0       	rjmp	.+94     	; 0x391e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x232>
    38c0:	86 30       	cpi	r24, 0x06	; 6
    38c2:	89 f0       	breq	.+34     	; 0x38e6 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1fa>
    38c4:	87 30       	cpi	r24, 0x07	; 7
    38c6:	b1 f0       	breq	.+44     	; 0x38f4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x208>
    38c8:	2a c0       	rjmp	.+84     	; 0x391e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x232>
								{
									case SystemTelemetryMessage::MessageType:
									receivedMessage = SystemTelemetryMessage::buildMessageSt(messagePayload);
    38ca:	c2 01       	movw	r24, r4
    38cc:	0e 94 34 33 	call	0x6668	; 0x6668 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>
    38d0:	f4 01       	movw	r30, r8
    38d2:	91 83       	std	Z+1, r25	; 0x01
    38d4:	80 83       	st	Z, r24
									break;
    38d6:	29 c0       	rjmp	.+82     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
									case SensorDataMessage::MessageType:
									receivedMessage = SensorDataMessage::buildMessageSt(messagePayload);
    38d8:	c2 01       	movw	r24, r4
    38da:	0e 94 5b 27 	call	0x4eb6	; 0x4eb6 <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>
    38de:	d4 01       	movw	r26, r8
    38e0:	8d 93       	st	X+, r24
    38e2:	9c 93       	st	X, r25
									break;
    38e4:	22 c0       	rjmp	.+68     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
									case SimpleTelemetryMessage::MessageType:
									receivedMessage = SimpleTelemetryMessage::buildMessageSt(messagePayload);
    38e6:	c2 01       	movw	r24, r4
    38e8:	0e 94 9a 2a 	call	0x5534	; 0x5534 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>
    38ec:	f4 01       	movw	r30, r8
    38ee:	91 83       	std	Z+1, r25	; 0x01
    38f0:	80 83       	st	Z, r24
									break;
    38f2:	1b c0       	rjmp	.+54     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
    38f4:	c2 01       	movw	r24, r4
    38f6:	0e 94 6a 25 	call	0x4ad4	; 0x4ad4 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>
    38fa:	d4 01       	movw	r26, r8
    38fc:	8d 93       	st	X+, r24
    38fe:	9c 93       	st	X, r25
									break;
    3900:	14 c0       	rjmp	.+40     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
									break;
								}
							}else
							{
								//checksum mismatch
								status = -4;
    3902:	0f 2e       	mov	r0, r31
    3904:	fc ef       	ldi	r31, 0xFC	; 252
    3906:	ef 2e       	mov	r14, r31
    3908:	ff 24       	eor	r15, r15
    390a:	fa 94       	dec	r15
    390c:	f0 2d       	mov	r31, r0
    390e:	0d c0       	rjmp	.+26     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
    3910:	0f 2e       	mov	r0, r31
    3912:	fc ef       	ldi	r31, 0xFC	; 252
    3914:	ef 2e       	mov	r14, r31
    3916:	ff 24       	eor	r15, r15
    3918:	fa 94       	dec	r15
    391a:	f0 2d       	mov	r31, r0
    391c:	06 c0       	rjmp	.+12     	; 0x392a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x23e>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
									break;
									default:
									//unrecognized message type.
									status = -3;
    391e:	0f 2e       	mov	r0, r31
    3920:	fd ef       	ldi	r31, 0xFD	; 253
    3922:	ef 2e       	mov	r14, r31
    3924:	ff 24       	eor	r15, r15
    3926:	fa 94       	dec	r15
    3928:	f0 2d       	mov	r31, r0
    392a:	ef 81       	ldd	r30, Y+7	; 0x07
    392c:	f8 85       	ldd	r31, Y+8	; 0x08
    392e:	0f b6       	in	r0, 0x3f	; 63
    3930:	f8 94       	cli
    3932:	fe bf       	out	0x3e, r31	; 62
    3934:	0f be       	out	0x3f, r0	; 63
    3936:	ed bf       	out	0x3d, r30	; 61
    3938:	06 c0       	rjmp	.+12     	; 0x3946 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x25a>
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
					break;					
				default:
					//unrecognized message type.
					status = -3;
    393a:	0f 2e       	mov	r0, r31
    393c:	fd ef       	ldi	r31, 0xFD	; 253
    393e:	ef 2e       	mov	r14, r31
    3940:	ff 24       	eor	r15, r15
    3942:	fa 94       	dec	r15
    3944:	f0 2d       	mov	r31, r0
				}
			}
		}
	}
	
	if (status != 0)
    3946:	e1 14       	cp	r14, r1
    3948:	f1 04       	cpc	r15, r1
    394a:	81 f0       	breq	.+32     	; 0x396c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x280>
	{
		receivedMessage = NULL;
    394c:	d4 01       	movw	r26, r8
    394e:	1d 92       	st	X+, r1
    3950:	1c 92       	st	X, r1
    3952:	0c c0       	rjmp	.+24     	; 0x396c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x280>
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
					break;
				case SensorDataMessage::MessageType:
					msgSize = SensorDataMessage::MessageSize;
    3954:	0f 2e       	mov	r0, r31
    3956:	f1 e4       	ldi	r31, 0x41	; 65
    3958:	2f 2e       	mov	r2, r31
    395a:	31 2c       	mov	r3, r1
    395c:	f0 2d       	mov	r31, r0
    395e:	38 cf       	rjmp	.-400    	; 0x37d0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xe4>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
    3960:	0f 2e       	mov	r0, r31
    3962:	f9 e7       	ldi	r31, 0x79	; 121
    3964:	2f 2e       	mov	r2, r31
    3966:	31 2c       	mov	r3, r1
    3968:	f0 2d       	mov	r31, r0
    396a:	32 cf       	rjmp	.-412    	; 0x37d0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xe4>
	if (status != 0)
	{
		receivedMessage = NULL;
	}
	
	serialDriver->stopTimer();
    396c:	f6 01       	movw	r30, r12
    396e:	80 81       	ld	r24, Z
    3970:	91 81       	ldd	r25, Z+1	; 0x01
    3972:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
    3976:	c7 01       	movw	r24, r14
    3978:	0f b6       	in	r0, 0x3f	; 63
    397a:	f8 94       	cli
    397c:	be be       	out	0x3e, r11	; 62
    397e:	0f be       	out	0x3f, r0	; 63
    3980:	ad be       	out	0x3d, r10	; 61
    3982:	28 96       	adiw	r28, 0x08	; 8
    3984:	0f b6       	in	r0, 0x3f	; 63
    3986:	f8 94       	cli
    3988:	de bf       	out	0x3e, r29	; 62
    398a:	0f be       	out	0x3f, r0	; 63
    398c:	cd bf       	out	0x3d, r28	; 61
    398e:	df 91       	pop	r29
    3990:	cf 91       	pop	r28
    3992:	1f 91       	pop	r17
    3994:	0f 91       	pop	r16
    3996:	ff 90       	pop	r15
    3998:	ef 90       	pop	r14
    399a:	df 90       	pop	r13
    399c:	cf 90       	pop	r12
    399e:	bf 90       	pop	r11
    39a0:	af 90       	pop	r10
    39a2:	9f 90       	pop	r9
    39a4:	8f 90       	pop	r8
    39a6:	7f 90       	pop	r7
    39a8:	6f 90       	pop	r6
    39aa:	5f 90       	pop	r5
    39ac:	4f 90       	pop	r4
    39ae:	3f 90       	pop	r3
    39b0:	2f 90       	pop	r2
    39b2:	08 95       	ret

000039b4 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>:

/**
 * Equation for scaling values new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
 */
float RadioControllerInterface::ScaleValue(long servoChannelPulseWidth) 
{
    39b4:	cf 92       	push	r12
    39b6:	df 92       	push	r13
    39b8:	ef 92       	push	r14
    39ba:	ff 92       	push	r15
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
    39bc:	cb 01       	movw	r24, r22
    39be:	ba 01       	movw	r22, r20
    39c0:	60 5d       	subi	r22, 0xD0	; 208
    39c2:	77 40       	sbci	r23, 0x07	; 7
    39c4:	81 09       	sbc	r24, r1
    39c6:	91 09       	sbc	r25, r1
    39c8:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    39cc:	2f e6       	ldi	r18, 0x6F	; 111
    39ce:	32 e1       	ldi	r19, 0x12	; 18
    39d0:	43 e8       	ldi	r20, 0x83	; 131
    39d2:	5a e3       	ldi	r21, 0x3A	; 58
    39d4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    39d8:	20 e0       	ldi	r18, 0x00	; 0
    39da:	30 e0       	ldi	r19, 0x00	; 0
    39dc:	40 e8       	ldi	r20, 0x80	; 128
    39de:	5f e3       	ldi	r21, 0x3F	; 63
    39e0:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    39e4:	6b 01       	movw	r12, r22
    39e6:	7c 01       	movw	r14, r24
			
	if (scaledValue > 1.0f)
    39e8:	20 e0       	ldi	r18, 0x00	; 0
    39ea:	30 e0       	ldi	r19, 0x00	; 0
    39ec:	40 e8       	ldi	r20, 0x80	; 128
    39ee:	5f e3       	ldi	r21, 0x3F	; 63
    39f0:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    39f4:	18 16       	cp	r1, r24
    39f6:	5c f0       	brlt	.+22     	; 0x3a0e <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x5a>
	{
		scaledValue = 1.0f;
	}else if (scaledValue < -1.0f)
    39f8:	20 e0       	ldi	r18, 0x00	; 0
    39fa:	30 e0       	ldi	r19, 0x00	; 0
    39fc:	40 e8       	ldi	r20, 0x80	; 128
    39fe:	5f eb       	ldi	r21, 0xBF	; 191
    3a00:	c7 01       	movw	r24, r14
    3a02:	b6 01       	movw	r22, r12
    3a04:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    3a08:	88 23       	and	r24, r24
    3a0a:	94 f4       	brge	.+36     	; 0x3a30 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x7c>
    3a0c:	09 c0       	rjmp	.+18     	; 0x3a20 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x6c>
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
			
	if (scaledValue > 1.0f)
	{
		scaledValue = 1.0f;
    3a0e:	0f 2e       	mov	r0, r31
    3a10:	c1 2c       	mov	r12, r1
    3a12:	d1 2c       	mov	r13, r1
    3a14:	f0 e8       	ldi	r31, 0x80	; 128
    3a16:	ef 2e       	mov	r14, r31
    3a18:	ff e3       	ldi	r31, 0x3F	; 63
    3a1a:	ff 2e       	mov	r15, r31
    3a1c:	f0 2d       	mov	r31, r0
    3a1e:	08 c0       	rjmp	.+16     	; 0x3a30 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x7c>
	}else if (scaledValue < -1.0f)
	{
		scaledValue = -1.0f;
    3a20:	0f 2e       	mov	r0, r31
    3a22:	c1 2c       	mov	r12, r1
    3a24:	d1 2c       	mov	r13, r1
    3a26:	f0 e8       	ldi	r31, 0x80	; 128
    3a28:	ef 2e       	mov	r14, r31
    3a2a:	ff eb       	ldi	r31, 0xBF	; 191
    3a2c:	ff 2e       	mov	r15, r31
    3a2e:	f0 2d       	mov	r31, r0
	}
	
	return scaledValue;
}
    3a30:	c7 01       	movw	r24, r14
    3a32:	b6 01       	movw	r22, r12
    3a34:	ff 90       	pop	r15
    3a36:	ef 90       	pop	r14
    3a38:	df 90       	pop	r13
    3a3a:	cf 90       	pop	r12
    3a3c:	08 95       	ret

00003a3e <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>:



RadioControllerInterface* RadioControllerInterface::getRadioControllerInterface()
{
	if (radioControllerInterface == NULL)
    3a3e:	80 91 a2 03 	lds	r24, 0x03A2
    3a42:	90 91 a3 03 	lds	r25, 0x03A3
    3a46:	89 2b       	or	r24, r25
    3a48:	e1 f5       	brne	.+120    	; 0x3ac2 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x84>
	{
		radioControllerInterface = new RadioControllerInterface();
    3a4a:	89 e5       	ldi	r24, 0x59	; 89
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>


				static RadioControllerInterface *radioControllerInterface;
			
				RadioControllerInterface():
				systemModel (NULL)
    3a52:	fc 01       	movw	r30, r24
    3a54:	e9 5a       	subi	r30, 0xA9	; 169
    3a56:	ff 4f       	sbci	r31, 0xFF	; 255
    3a58:	11 82       	std	Z+1, r1	; 0x01
    3a5a:	10 82       	st	Z, r1
				{
					memset(workingServoChannelPulseWidths, 0, sizeof(workingServoChannelPulseWidths));
    3a5c:	e6 55       	subi	r30, 0x56	; 86
    3a5e:	f1 09       	sbc	r31, r1
    3a60:	20 e2       	ldi	r18, 0x20	; 32
    3a62:	df 01       	movw	r26, r30
    3a64:	32 2f       	mov	r19, r18
    3a66:	1d 92       	st	X+, r1
    3a68:	3a 95       	dec	r19
    3a6a:	e9 f7       	brne	.-6      	; 0x3a66 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x28>
					memset(servoChannelPulseWidths, 0, sizeof(servoChannelPulseWidths));
    3a6c:	b0 96       	adiw	r30, 0x20	; 32
    3a6e:	df 01       	movw	r26, r30
    3a70:	1d 92       	st	X+, r1
    3a72:	2a 95       	dec	r18
    3a74:	e9 f7       	brne	.-6      	; 0x3a70 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x32>
					
					previousInputCaptureRegisterValue = 0;
    3a76:	b0 96       	adiw	r30, 0x20	; 32
    3a78:	10 82       	st	Z, r1
    3a7a:	11 82       	std	Z+1, r1	; 0x01
    3a7c:	12 82       	std	Z+2, r1	; 0x02
    3a7e:	13 82       	std	Z+3, r1	; 0x03
					
					servoChannelIndex = 0;
    3a80:	34 96       	adiw	r30, 0x04	; 4
    3a82:	11 82       	std	Z+1, r1	; 0x01
    3a84:	10 82       	st	Z, r1
					
					channel1Offset = 0;
    3a86:	32 96       	adiw	r30, 0x02	; 2
    3a88:	11 82       	std	Z+1, r1	; 0x01
    3a8a:	10 82       	st	Z, r1
					channel2Offset = 0;
    3a8c:	32 96       	adiw	r30, 0x02	; 2
    3a8e:	11 82       	std	Z+1, r1	; 0x01
    3a90:	10 82       	st	Z, r1
					channel3Offset = 0;
    3a92:	32 96       	adiw	r30, 0x02	; 2
    3a94:	11 82       	std	Z+1, r1	; 0x01
    3a96:	10 82       	st	Z, r1
					channel4Offset = 0;
    3a98:	32 96       	adiw	r30, 0x02	; 2
    3a9a:	11 82       	std	Z+1, r1	; 0x01
    3a9c:	10 82       	st	Z, r1
					channel5Offset = 0;
    3a9e:	32 96       	adiw	r30, 0x02	; 2
    3aa0:	11 82       	std	Z+1, r1	; 0x01
    3aa2:	10 82       	st	Z, r1
					channel6Offset = 0;
    3aa4:	32 96       	adiw	r30, 0x02	; 2
    3aa6:	11 82       	std	Z+1, r1	; 0x01
    3aa8:	10 82       	st	Z, r1
					channel7Offset = 0;
    3aaa:	32 96       	adiw	r30, 0x02	; 2
    3aac:	11 82       	std	Z+1, r1	; 0x01
    3aae:	10 82       	st	Z, r1
					channel8Offset = 0;		
    3ab0:	32 96       	adiw	r30, 0x02	; 2
    3ab2:	11 82       	std	Z+1, r1	; 0x01
    3ab4:	10 82       	st	Z, r1
					
					ARRAYLOCK = false;		
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	10 82       	st	Z, r1
    3aba:	90 93 a3 03 	sts	0x03A3, r25
    3abe:	80 93 a2 03 	sts	0x03A2, r24
	}

	return radioControllerInterface;
}
    3ac2:	80 91 a2 03 	lds	r24, 0x03A2
    3ac6:	90 91 a3 03 	lds	r25, 0x03A3
    3aca:	08 95       	ret

00003acc <__vector_46>:
/**
 * Interrupt service routine which is called when a PPM signal's rising edge is detected
 * on the PL1 pin.
 */
ISR(TIMER5_CAPT_vect)
{
    3acc:	1f 92       	push	r1
    3ace:	0f 92       	push	r0
    3ad0:	0f b6       	in	r0, 0x3f	; 63
    3ad2:	0f 92       	push	r0
    3ad4:	11 24       	eor	r1, r1
    3ad6:	0b b6       	in	r0, 0x3b	; 59
    3ad8:	0f 92       	push	r0
    3ada:	8f 92       	push	r8
    3adc:	9f 92       	push	r9
    3ade:	af 92       	push	r10
    3ae0:	bf 92       	push	r11
    3ae2:	cf 92       	push	r12
    3ae4:	df 92       	push	r13
    3ae6:	ef 92       	push	r14
    3ae8:	ff 92       	push	r15
    3aea:	0f 93       	push	r16
    3aec:	1f 93       	push	r17
    3aee:	2f 93       	push	r18
    3af0:	3f 93       	push	r19
    3af2:	4f 93       	push	r20
    3af4:	5f 93       	push	r21
    3af6:	6f 93       	push	r22
    3af8:	7f 93       	push	r23
    3afa:	8f 93       	push	r24
    3afc:	9f 93       	push	r25
    3afe:	af 93       	push	r26
    3b00:	bf 93       	push	r27
    3b02:	cf 93       	push	r28
    3b04:	df 93       	push	r29
    3b06:	ef 93       	push	r30
    3b08:	ff 93       	push	r31
	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    3b0a:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    3b0e:	ec 01       	movw	r28, r24
	//an interrupt happening inbetween reading the two bytes. 
	//cli(); //not necessary because intterupts are already disabled within an ISR.
	
	//The Input Capture Register is set to the value of the timer when the
	//input signal was received.
	long currentInputCaptureRegisterValue = ICR5;
    3b10:	40 91 26 01 	lds	r20, 0x0126
    3b14:	50 91 27 01 	lds	r21, 0x0127
    3b18:	60 e0       	ldi	r22, 0x00	; 0
    3b1a:	70 e0       	ldi	r23, 0x00	; 0
				 * the scope of this class, so the handlers need a static reference to
				 * this class.
				 */
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
    3b1c:	fc 01       	movw	r30, r24
    3b1e:	ef 5b       	subi	r30, 0xBF	; 191
    3b20:	ff 4f       	sbci	r31, 0xFF	; 255
    3b22:	00 81       	ld	r16, Z
    3b24:	11 81       	ldd	r17, Z+1	; 0x01
    3b26:	22 81       	ldd	r18, Z+2	; 0x02
    3b28:	33 81       	ldd	r19, Z+3	; 0x03
	
	long previousInputCaptureRegisterValue = rcInterface->PreviousInputCaptureRegisterValue();
	
	//If the current value was less, then the timer has overflowed since the last
	//time we received a pulse
	if (currentInputCaptureRegisterValue < previousInputCaptureRegisterValue)
    3b2a:	40 17       	cp	r20, r16
    3b2c:	51 07       	cpc	r21, r17
    3b2e:	62 07       	cpc	r22, r18
    3b30:	73 07       	cpc	r23, r19
    3b32:	8c f4       	brge	.+34     	; 0x3b56 <__vector_46+0x8a>
	{
		servoChannelPulseWidth = (currentInputCaptureRegisterValue + RadioControllerInterface::MAX_PPM_TIMER_VALUE) - previousInputCaptureRegisterValue;
    3b34:	6a 01       	movw	r12, r20
    3b36:	7b 01       	movw	r14, r22
    3b38:	80 e4       	ldi	r24, 0x40	; 64
    3b3a:	c8 0e       	add	r12, r24
    3b3c:	8c e9       	ldi	r24, 0x9C	; 156
    3b3e:	d8 1e       	adc	r13, r24
    3b40:	e1 1c       	adc	r14, r1
    3b42:	f1 1c       	adc	r15, r1
    3b44:	d7 01       	movw	r26, r14
    3b46:	c6 01       	movw	r24, r12
    3b48:	80 1b       	sub	r24, r16
    3b4a:	91 0b       	sbc	r25, r17
    3b4c:	a2 0b       	sbc	r26, r18
    3b4e:	b3 0b       	sbc	r27, r19
    3b50:	8c 01       	movw	r16, r24
    3b52:	9d 01       	movw	r18, r26
    3b54:	08 c0       	rjmp	.+16     	; 0x3b66 <__vector_46+0x9a>
	}else
	{
		//Calculate the width of the pulse.
		servoChannelPulseWidth = currentInputCaptureRegisterValue - previousInputCaptureRegisterValue;
    3b56:	db 01       	movw	r26, r22
    3b58:	ca 01       	movw	r24, r20
    3b5a:	80 1b       	sub	r24, r16
    3b5c:	91 0b       	sbc	r25, r17
    3b5e:	a2 0b       	sbc	r26, r18
    3b60:	b3 0b       	sbc	r27, r19
    3b62:	8c 01       	movw	r16, r24
    3b64:	9d 01       	movw	r18, r26
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
    3b66:	fe 01       	movw	r30, r28
    3b68:	ef 5b       	subi	r30, 0xBF	; 191
    3b6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3b6c:	40 83       	st	Z, r20
    3b6e:	51 83       	std	Z+1, r21	; 0x01
    3b70:	62 83       	std	Z+2, r22	; 0x02
    3b72:	73 83       	std	Z+3, r23	; 0x03
	rcInterface->PreviousInputCaptureRegisterValue(currentInputCaptureRegisterValue);
	
	//Once all the servo channels values have been sent, a sync pulse is sent indicating
	//a restart back to the first channel.
	//Detect if it's a sync pulse and rest as appropriate
	if (servoChannelPulseWidth > RadioControllerInterface::SYNCH_PULSE_WIDTH)
    3b74:	01 34       	cpi	r16, 0x41	; 65
    3b76:	9f e1       	ldi	r25, 0x1F	; 31
    3b78:	19 07       	cpc	r17, r25
    3b7a:	21 05       	cpc	r18, r1
    3b7c:	31 05       	cpc	r19, r1
    3b7e:	2c f0       	brlt	.+10     	; 0x3b8a <__vector_46+0xbe>
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    3b80:	cb 5b       	subi	r28, 0xBB	; 187
    3b82:	df 4f       	sbci	r29, 0xFF	; 255
    3b84:	19 82       	std	Y+1, r1	; 0x01
    3b86:	18 82       	st	Y, r1
    3b88:	67 c0       	rjmp	.+206    	; 0x3c58 <__vector_46+0x18c>
	{
		rcInterface->ServoChannelIndex(0);
	}else
	{
		if (servoChannelPulseWidth < RadioControllerInterface::MAX_USEABLE_PULSE_WIDTH && 
    3b8a:	b9 01       	movw	r22, r18
    3b8c:	a8 01       	movw	r20, r16
    3b8e:	47 5c       	subi	r20, 0xC7	; 199
    3b90:	57 40       	sbci	r21, 0x07	; 7
    3b92:	61 09       	sbc	r22, r1
    3b94:	71 09       	sbc	r23, r1
    3b96:	43 3e       	cpi	r20, 0xE3	; 227
    3b98:	57 40       	sbci	r21, 0x07	; 7
    3b9a:	61 05       	cpc	r22, r1
    3b9c:	71 05       	cpc	r23, r1
    3b9e:	08 f0       	brcs	.+2      	; 0x3ba2 <__vector_46+0xd6>
    3ba0:	54 c0       	rjmp	.+168    	; 0x3c4a <__vector_46+0x17e>
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
    3ba2:	fe 01       	movw	r30, r28
    3ba4:	eb 5b       	subi	r30, 0xBB	; 187
    3ba6:	ff 4f       	sbci	r31, 0xFF	; 255
    3ba8:	80 81       	ld	r24, Z
    3baa:	91 81       	ldd	r25, Z+1	; 0x01
			
			
			
			//since throttle is mechanically bypassed, set throttle to -1 (no throttle) in the array of control values, and 
			//then continue processing the received signal for the next channel (channel 1)
			if (servoChannelIndex == 0)
    3bac:	00 97       	sbiw	r24, 0x00	; 0
    3bae:	69 f4       	brne	.+26     	; 0x3bca <__vector_46+0xfe>
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    3bb0:	40 ed       	ldi	r20, 0xD0	; 208
    3bb2:	57 e0       	ldi	r21, 0x07	; 7
    3bb4:	60 e0       	ldi	r22, 0x00	; 0
    3bb6:	70 e0       	ldi	r23, 0x00	; 0
    3bb8:	49 83       	std	Y+1, r20	; 0x01
    3bba:	5a 83       	std	Y+2, r21	; 0x02
    3bbc:	6b 83       	std	Y+3, r22	; 0x03
    3bbe:	7c 83       	std	Y+4, r23	; 0x04
    3bc0:	0d 83       	std	Y+5, r16	; 0x05
    3bc2:	1e 83       	std	Y+6, r17	; 0x06
    3bc4:	2f 83       	std	Y+7, r18	; 0x07
    3bc6:	38 87       	std	Y+8, r19	; 0x08
    3bc8:	40 c0       	rjmp	.+128    	; 0x3c4a <__vector_46+0x17e>
		
		
		
		
		
			if (servoChannelIndex < RadioControllerInterface::MAX_CHANNELS)
    3bca:	88 30       	cpi	r24, 0x08	; 8
    3bcc:	91 05       	cpc	r25, r1
    3bce:	ec f5       	brge	.+122    	; 0x3c4a <__vector_46+0x17e>
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
    3bd0:	fe 01       	movw	r30, r28
    3bd2:	e9 5a       	subi	r30, 0xA9	; 169
    3bd4:	ff 4f       	sbci	r31, 0xFF	; 255
    3bd6:	e0 80       	ld	r14, Z
    3bd8:	f1 80       	ldd	r15, Z+1	; 0x01
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    3bda:	fc 01       	movw	r30, r24
    3bdc:	ee 0f       	add	r30, r30
    3bde:	ff 1f       	adc	r31, r31
    3be0:	ee 0f       	add	r30, r30
    3be2:	ff 1f       	adc	r31, r31
    3be4:	ec 0f       	add	r30, r28
    3be6:	fd 1f       	adc	r31, r29
    3be8:	01 83       	std	Z+1, r16	; 0x01
    3bea:	12 83       	std	Z+2, r17	; 0x02
    3bec:	23 83       	std	Z+3, r18	; 0x03
    3bee:	34 83       	std	Z+4, r19	; 0x04
				 * servo channel index to reset back to 0, and re-write the
				 * existing servo value. This could cause a servo control value
				 * to get sent to the wrong servo. 
				 */
				//if (servoChannelIndex >= RadioControllerInterface::MIN_RECEIVED_CHANNELS)
				if (servoChannelIndex == RadioControllerInterface::MIN_RECEIVED_CHANNELS)
    3bf0:	07 97       	sbiw	r24, 0x07	; 7
    3bf2:	59 f5       	brne	.+86     	; 0x3c4a <__vector_46+0x17e>
				{
					//Manual mode
					float auxChannelValue = rcInterface->ScaleValue(rcInterface->GetServoChannelPulseWidth(RadioControllerInterface::FLIGHT_MODE_AUX_CHANNEL));
    3bf4:	49 8d       	ldd	r20, Y+25	; 0x19
    3bf6:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3bf8:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3bfa:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3bfc:	ce 01       	movw	r24, r28
    3bfe:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>
    3c02:	4b 01       	movw	r8, r22
    3c04:	5c 01       	movw	r10, r24
					
					if (auxChannelValue
    3c06:	23 e3       	ldi	r18, 0x33	; 51
    3c08:	33 e3       	ldi	r19, 0x33	; 51
    3c0a:	43 e3       	ldi	r20, 0x33	; 51
    3c0c:	5f e3       	ldi	r21, 0x3F	; 63
    3c0e:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    3c12:	18 16       	cp	r1, r24
    3c14:	1c f0       	brlt	.+6      	; 0x3c1c <__vector_46+0x150>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    3c16:	f7 01       	movw	r30, r14
    3c18:	12 82       	std	Z+2, r1	; 0x02
    3c1a:	04 c0       	rjmp	.+8      	; 0x3c24 <__vector_46+0x158>
    3c1c:	81 e0       	ldi	r24, 0x01	; 1
    3c1e:	d7 01       	movw	r26, r14
    3c20:	12 96       	adiw	r26, 0x02	; 2
    3c22:	8c 93       	st	X, r24
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}
    3c24:	f7 01       	movw	r30, r14
    3c26:	e6 5e       	subi	r30, 0xE6	; 230
    3c28:	fe 4f       	sbci	r31, 0xFE	; 254
    3c2a:	80 82       	st	Z, r8
    3c2c:	91 82       	std	Z+1, r9	; 0x01
    3c2e:	a2 82       	std	Z+2, r10	; 0x02
    3c30:	b3 82       	std	Z+3, r11	; 0x03
						model->OperationalState(SystemModel::AutoPilot);
					}
					
					model->AuxChannelValue(auxChannelValue);
					
					if (!rcInterface->ARRAYLOCK)
    3c32:	88 81       	ld	r24, Y
    3c34:	81 11       	cpse	r24, r1
    3c36:	09 c0       	rjmp	.+18     	; 0x3c4a <__vector_46+0x17e>
					
				void controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue );
				
				void copyPulseWidthArrays()
				{
					memcpy(servoChannelPulseWidths, workingServoChannelPulseWidths, sizeof(servoChannelPulseWidths));
    3c38:	80 e2       	ldi	r24, 0x20	; 32
    3c3a:	fe 01       	movw	r30, r28
    3c3c:	31 96       	adiw	r30, 0x01	; 1
    3c3e:	de 01       	movw	r26, r28
    3c40:	91 96       	adiw	r26, 0x21	; 33
    3c42:	01 90       	ld	r0, Z+
    3c44:	0d 92       	st	X+, r0
    3c46:	8a 95       	dec	r24
    3c48:	e1 f7       	brne	.-8      	; 0x3c42 <__vector_46+0x176>
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    3c4a:	cb 5b       	subi	r28, 0xBB	; 187
    3c4c:	df 4f       	sbci	r29, 0xFF	; 255
					//rcInterface->ServoChannelIndex(0);
				}			
			}
		} 

		rcInterface->ServoChannelIndex(rcInterface->ServoChannelIndex() + 1);
    3c4e:	88 81       	ld	r24, Y
    3c50:	99 81       	ldd	r25, Y+1	; 0x01
    3c52:	01 96       	adiw	r24, 0x01	; 1
    3c54:	99 83       	std	Y+1, r25	; 0x01
    3c56:	88 83       	st	Y, r24
	}

}
    3c58:	ff 91       	pop	r31
    3c5a:	ef 91       	pop	r30
    3c5c:	df 91       	pop	r29
    3c5e:	cf 91       	pop	r28
    3c60:	bf 91       	pop	r27
    3c62:	af 91       	pop	r26
    3c64:	9f 91       	pop	r25
    3c66:	8f 91       	pop	r24
    3c68:	7f 91       	pop	r23
    3c6a:	6f 91       	pop	r22
    3c6c:	5f 91       	pop	r21
    3c6e:	4f 91       	pop	r20
    3c70:	3f 91       	pop	r19
    3c72:	2f 91       	pop	r18
    3c74:	1f 91       	pop	r17
    3c76:	0f 91       	pop	r16
    3c78:	ff 90       	pop	r15
    3c7a:	ef 90       	pop	r14
    3c7c:	df 90       	pop	r13
    3c7e:	cf 90       	pop	r12
    3c80:	bf 90       	pop	r11
    3c82:	af 90       	pop	r10
    3c84:	9f 90       	pop	r9
    3c86:	8f 90       	pop	r8
    3c88:	0f 90       	pop	r0
    3c8a:	0b be       	out	0x3b, r0	; 59
    3c8c:	0f 90       	pop	r0
    3c8e:	0f be       	out	0x3f, r0	; 63
    3c90:	0f 90       	pop	r0
    3c92:	1f 90       	pop	r1
    3c94:	18 95       	reti

00003c96 <_ZN10helicopter10interfaces24RadioControllerInterface4initEv>:
 * This counter will be used to measure the time intervals between the PPM pulses
 * to calculate the value of the control signal from the radio being sent to the servos.
 * See page 148 of atmelAVR2560_datasheet.pdf
 */
void RadioControllerInterface::init()
{
    3c96:	cf 93       	push	r28
    3c98:	df 93       	push	r29
	 * PE4      | OC3B               | Aux 2 (manual override)		| 7
	 * PE3      | OC3A               | Aux 3						| 8
	 */	
	
	//Setup pins for output.
	DDRB |= (1<<PB6) | (1<<PB5);
    3c9a:	84 b1       	in	r24, 0x04	; 4
    3c9c:	80 66       	ori	r24, 0x60	; 96
    3c9e:	84 b9       	out	0x04, r24	; 4
	DDRH |= (1<<PH5) | (1<<PH4) | (1<<PH3);
    3ca0:	e1 e0       	ldi	r30, 0x01	; 1
    3ca2:	f1 e0       	ldi	r31, 0x01	; 1
    3ca4:	80 81       	ld	r24, Z
    3ca6:	88 63       	ori	r24, 0x38	; 56
    3ca8:	80 83       	st	Z, r24
	DDRE |= (1<<PE5) | (1<<PE4) | (1<<PE3);
    3caa:	8d b1       	in	r24, 0x0d	; 13
    3cac:	88 63       	ori	r24, 0x38	; 56
    3cae:	8d b9       	out	0x0d, r24	; 13
	
	/**
	 * Setup timers for phase correct pwm.
	 * wgmn3, wgmn2, wgmn1, wgmn0 = 1,0,1,0 (page 148)
	 */
	TCCR1A |= (1<<WGM11);
    3cb0:	c0 e8       	ldi	r28, 0x80	; 128
    3cb2:	d0 e0       	ldi	r29, 0x00	; 0
    3cb4:	88 81       	ld	r24, Y
    3cb6:	82 60       	ori	r24, 0x02	; 2
    3cb8:	88 83       	st	Y, r24
	TCCR1B |= (1<<WGM13);
    3cba:	e1 e8       	ldi	r30, 0x81	; 129
    3cbc:	f0 e0       	ldi	r31, 0x00	; 0
    3cbe:	80 81       	ld	r24, Z
    3cc0:	80 61       	ori	r24, 0x10	; 16
    3cc2:	80 83       	st	Z, r24
	TCCR3A |= (1<<WGM31);
    3cc4:	a0 e9       	ldi	r26, 0x90	; 144
    3cc6:	b0 e0       	ldi	r27, 0x00	; 0
    3cc8:	8c 91       	ld	r24, X
    3cca:	82 60       	ori	r24, 0x02	; 2
    3ccc:	8c 93       	st	X, r24
	TCCR3B |= (1<<WGM33);	
    3cce:	e1 e9       	ldi	r30, 0x91	; 145
    3cd0:	f0 e0       	ldi	r31, 0x00	; 0
    3cd2:	80 81       	ld	r24, Z
    3cd4:	80 61       	ori	r24, 0x10	; 16
    3cd6:	80 83       	st	Z, r24
	TCCR4A |= (1<<WGM41);
    3cd8:	40 ea       	ldi	r20, 0xA0	; 160
    3cda:	50 e0       	ldi	r21, 0x00	; 0
    3cdc:	fa 01       	movw	r30, r20
    3cde:	80 81       	ld	r24, Z
    3ce0:	82 60       	ori	r24, 0x02	; 2
    3ce2:	80 83       	st	Z, r24
	TCCR4B |= (1<<WGM43);
    3ce4:	81 ea       	ldi	r24, 0xA1	; 161
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
    3ce8:	fc 01       	movw	r30, r24
    3cea:	20 81       	ld	r18, Z
    3cec:	20 61       	ori	r18, 0x10	; 16
    3cee:	20 83       	st	Z, r18
	
	/**
	 * Setup OC1A,B compare match when counting up on compare, clear compare match on compare when counting down.
	 */
	TCCR1A |= (1<<COM1B1) | (1<<COM1B0) | (1<<COM1A1) | (1<<COM1A0);
    3cf0:	88 81       	ld	r24, Y
    3cf2:	80 6f       	ori	r24, 0xF0	; 240
    3cf4:	88 83       	st	Y, r24
	TCCR3A |= (1<<COM3C1) | (1<<COM3C0) | (1<<COM3B1) | (1<<COM3B0) | (1<<COM3A1) | (1<<COM3A0);
    3cf6:	8c 91       	ld	r24, X
    3cf8:	8c 6f       	ori	r24, 0xFC	; 252
    3cfa:	8c 93       	st	X, r24
	TCCR4A |= (1<<COM4C1) | (1<<COM4C0) | (1<<COM4B1) | (1<<COM4B0) | (1<<COM4A1) | (1<<COM4A0);
    3cfc:	fa 01       	movw	r30, r20
    3cfe:	80 81       	ld	r24, Z
    3d00:	8c 6f       	ori	r24, 0xFC	; 252
    3d02:	80 83       	st	Z, r24
	//TODO: Set default values to '0' before initialized so that things don't power up.
	/**
	 * Set the compare value so that the servos are set to a neutral position
	 */
	//OCR1B = calculatePWMCompareMatchFromControlValue(0);
	OCR1B = calculatePWMCompareMatchFromControlValue(-1); //set throttle to -1 which is 'off'. 
    3d04:	88 e3       	ldi	r24, 0x38	; 56
    3d06:	9a e4       	ldi	r25, 0x4A	; 74
    3d08:	90 93 8b 00 	sts	0x008B, r25
    3d0c:	80 93 8a 00 	sts	0x008A, r24
	OCR1A = calculatePWMCompareMatchFromControlValue(0);
    3d10:	84 e4       	ldi	r24, 0x44	; 68
    3d12:	98 e4       	ldi	r25, 0x48	; 72
    3d14:	90 93 89 00 	sts	0x0089, r25
    3d18:	80 93 88 00 	sts	0x0088, r24
	OCR3C = calculatePWMCompareMatchFromControlValue(0);
    3d1c:	90 93 9d 00 	sts	0x009D, r25
    3d20:	80 93 9c 00 	sts	0x009C, r24
	OCR3B = calculatePWMCompareMatchFromControlValue(0);
    3d24:	90 93 9b 00 	sts	0x009B, r25
    3d28:	80 93 9a 00 	sts	0x009A, r24
	OCR3A = calculatePWMCompareMatchFromControlValue(0);
    3d2c:	90 93 99 00 	sts	0x0099, r25
    3d30:	80 93 98 00 	sts	0x0098, r24
	OCR4C = calculatePWMCompareMatchFromControlValue(0);
    3d34:	90 93 ad 00 	sts	0x00AD, r25
    3d38:	80 93 ac 00 	sts	0x00AC, r24
	OCR4B = calculatePWMCompareMatchFromControlValue(0);
    3d3c:	90 93 ab 00 	sts	0x00AB, r25
    3d40:	80 93 aa 00 	sts	0x00AA, r24
	OCR4A = calculatePWMCompareMatchFromControlValue(0);
    3d44:	90 93 a9 00 	sts	0x00A9, r25
    3d48:	80 93 a8 00 	sts	0x00A8, r24
	
	ICR1 = TIMERTOP;
    3d4c:	80 e2       	ldi	r24, 0x20	; 32
    3d4e:	9e e4       	ldi	r25, 0x4E	; 78
    3d50:	90 93 87 00 	sts	0x0087, r25
    3d54:	80 93 86 00 	sts	0x0086, r24
	ICR3 = TIMERTOP;
    3d58:	90 93 97 00 	sts	0x0097, r25
    3d5c:	80 93 96 00 	sts	0x0096, r24
	ICR4 = TIMERTOP;
    3d60:	90 93 a7 00 	sts	0x00A7, r25
    3d64:	80 93 a6 00 	sts	0x00A6, r24
	 * Setup code for receiving pulse position modulation (PPM) information and converting
	 * it to control values
	 */
	//set PL1 pin to input. This will receive the
	//pulse position modulation signal from the pwm-ppm encoder
	DDRL &= ~(1<<PL1);
    3d68:	ea e0       	ldi	r30, 0x0A	; 10
    3d6a:	f1 e0       	ldi	r31, 0x01	; 1
    3d6c:	80 81       	ld	r24, Z
    3d6e:	8d 7f       	andi	r24, 0xFD	; 253
    3d70:	80 83       	st	Z, r24
	//Setup timer for Fast Pulse Width Modulation where the top
	//of the timer (when the timer resets) is set to the 
	//value given to the OCR5A register.
	//Timer Counter Overflow (TOV) flag is set when the timer reaches the TOP
	//
	TCCR5A = (1<<WGM50)|(1<<WGM51);
    3d72:	83 e0       	ldi	r24, 0x03	; 3
    3d74:	80 93 20 01 	sts	0x0120, r24
	TCCR5B = (1<<WGM52)|(1<<WGM53);
    3d78:	e1 e2       	ldi	r30, 0x21	; 33
    3d7a:	f1 e0       	ldi	r31, 0x01	; 1
    3d7c:	88 e1       	ldi	r24, 0x18	; 24
    3d7e:	80 83       	st	Z, r24
	
	//ICES5 is the input capture edge select pin. when set to 1, it triggers a capture event on a rising edge.
	TCCR5B |= (1<<ICES5); 
    3d80:	80 81       	ld	r24, Z
    3d82:	80 64       	ori	r24, 0x40	; 64
    3d84:	80 83       	st	Z, r24
	
	//Setup the timer to reset once it reaches the MAX_PPM_TIMER_VALUE value 
	// (i.e. the timer will reset 50 times a second because the timer will reach 40,000 in 1/50th of a second)
	OCR5A = MAX_PPM_TIMER_VALUE; 
    3d86:	80 e4       	ldi	r24, 0x40	; 64
    3d88:	9c e9       	ldi	r25, 0x9C	; 156
    3d8a:	90 93 29 01 	sts	0x0129, r25
    3d8e:	80 93 28 01 	sts	0x0128, r24

	//Enable global interrupts
	sei();
    3d92:	78 94       	sei

	// Enable Input Capture interrupt so the interrupt will fire when a PPM signal is received.
	TIMSK5 |= (1<<ICIE5);
    3d94:	e3 e7       	ldi	r30, 0x73	; 115
    3d96:	f0 e0       	ldi	r31, 0x00	; 0
    3d98:	80 81       	ld	r24, Z
    3d9a:	80 62       	ori	r24, 0x20	; 32
    3d9c:	80 83       	st	Z, r24

}
    3d9e:	df 91       	pop	r29
    3da0:	cf 91       	pop	r28
    3da2:	08 95       	ret

00003da4 <_ZN10helicopter10interfaces24RadioControllerInterface5startEv>:

void RadioControllerInterface::start()
{
    3da4:	cf 92       	push	r12
    3da6:	df 92       	push	r13
    3da8:	ef 92       	push	r14
    3daa:	ff 92       	push	r15
    3dac:	0f 93       	push	r16
    3dae:	1f 93       	push	r17
    3db0:	cf 93       	push	r28
    3db2:	df 93       	push	r29
    3db4:	ec 01       	movw	r28, r24

	//Set the timer prescaler to 8. (CS = Clock Select) which starts the timer.
	//Starts the PPM input timer
	TCCR5B |= (1<<CS51);	
    3db6:	e1 e2       	ldi	r30, 0x21	; 33
    3db8:	f1 e0       	ldi	r31, 0x01	; 1
    3dba:	80 81       	ld	r24, Z
    3dbc:	82 60       	ori	r24, 0x02	; 2
    3dbe:	80 83       	st	Z, r24
	
	while (!haveInitialData)
	{
		_delay_ms(1000);

		if (servoChannelPulseWidths[MIN_RECEIVED_CHANNELS] != 0) 
    3dc0:	fe 01       	movw	r30, r28
    3dc2:	fd 96       	adiw	r30, 0x3d	; 61
    3dc4:	2f ef       	ldi	r18, 0xFF	; 255
    3dc6:	33 ed       	ldi	r19, 0xD3	; 211
    3dc8:	40 e3       	ldi	r20, 0x30	; 48
    3dca:	21 50       	subi	r18, 0x01	; 1
    3dcc:	30 40       	sbci	r19, 0x00	; 0
    3dce:	40 40       	sbci	r20, 0x00	; 0
    3dd0:	e1 f7       	brne	.-8      	; 0x3dca <_ZN10helicopter10interfaces24RadioControllerInterface5startEv+0x26>
    3dd2:	00 c0       	rjmp	.+0      	; 0x3dd4 <_ZN10helicopter10interfaces24RadioControllerInterface5startEv+0x30>
    3dd4:	00 00       	nop
    3dd6:	40 81       	ld	r20, Z
    3dd8:	51 81       	ldd	r21, Z+1	; 0x01
    3dda:	62 81       	ldd	r22, Z+2	; 0x02
    3ddc:	73 81       	ldd	r23, Z+3	; 0x03
    3dde:	45 2b       	or	r20, r21
    3de0:	46 2b       	or	r20, r22
    3de2:	47 2b       	or	r20, r23
    3de4:	79 f3       	breq	.-34     	; 0x3dc4 <_ZN10helicopter10interfaces24RadioControllerInterface5startEv+0x20>
	channel8Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
	*/
	

	//channel1Offset = negativeOnePoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);  *** //Throttle starts at -1. 
	channel1Offset = 0;//don't offset throttle. 
    3de6:	fe 01       	movw	r30, r28
    3de8:	e9 5b       	subi	r30, 0xB9	; 185
    3dea:	ff 4f       	sbci	r31, 0xFF	; 255
    3dec:	11 82       	std	Z+1, r1	; 0x01
    3dee:	10 82       	st	Z, r1
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
    3df0:	8e 01       	movw	r16, r28
    3df2:	07 5b       	subi	r16, 0xB7	; 183
    3df4:	1f 4f       	sbci	r17, 0xFF	; 255
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3df6:	0f 2e       	mov	r0, r31
    3df8:	f0 e4       	ldi	r31, 0x40	; 64
    3dfa:	cf 2e       	mov	r12, r31
    3dfc:	fc e9       	ldi	r31, 0x9C	; 156
    3dfe:	df 2e       	mov	r13, r31
    3e00:	e1 2c       	mov	r14, r1
    3e02:	f1 2c       	mov	r15, r1
    3e04:	f0 2d       	mov	r31, r0
    3e06:	8d a1       	ldd	r24, Y+37	; 0x25
    3e08:	9e a1       	ldd	r25, Y+38	; 0x26
    3e0a:	af a1       	ldd	r26, Y+39	; 0x27
    3e0c:	b8 a5       	ldd	r27, Y+40	; 0x28
    3e0e:	a7 01       	movw	r20, r14
    3e10:	96 01       	movw	r18, r12
    3e12:	28 1b       	sub	r18, r24
    3e14:	39 0b       	sbc	r19, r25
    3e16:	4a 0b       	sbc	r20, r26
    3e18:	5b 0b       	sbc	r21, r27
    3e1a:	ca 01       	movw	r24, r20
    3e1c:	b9 01       	movw	r22, r18
    3e1e:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3e22:	20 e0       	ldi	r18, 0x00	; 0
    3e24:	30 e0       	ldi	r19, 0x00	; 0
    3e26:	40 e0       	ldi	r20, 0x00	; 0
    3e28:	5f e3       	ldi	r21, 0x3F	; 63
    3e2a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3e2e:	9b 01       	movw	r18, r22
    3e30:	ac 01       	movw	r20, r24
	*/
	

	//channel1Offset = negativeOnePoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);  *** //Throttle starts at -1. 
	channel1Offset = 0;//don't offset throttle. 
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
    3e32:	60 e0       	ldi	r22, 0x00	; 0
    3e34:	70 e6       	ldi	r23, 0x60	; 96
    3e36:	8f e8       	ldi	r24, 0x8F	; 143
    3e38:	96 e4       	ldi	r25, 0x46	; 70
    3e3a:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3e3e:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3e42:	f8 01       	movw	r30, r16
    3e44:	71 83       	std	Z+1, r23	; 0x01
    3e46:	60 83       	st	Z, r22
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
    3e48:	0e 5f       	subi	r16, 0xFE	; 254
    3e4a:	1f 4f       	sbci	r17, 0xFF	; 255
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3e4c:	89 a5       	ldd	r24, Y+41	; 0x29
    3e4e:	9a a5       	ldd	r25, Y+42	; 0x2a
    3e50:	ab a5       	ldd	r26, Y+43	; 0x2b
    3e52:	bc a5       	ldd	r27, Y+44	; 0x2c
    3e54:	a7 01       	movw	r20, r14
    3e56:	96 01       	movw	r18, r12
    3e58:	28 1b       	sub	r18, r24
    3e5a:	39 0b       	sbc	r19, r25
    3e5c:	4a 0b       	sbc	r20, r26
    3e5e:	5b 0b       	sbc	r21, r27
    3e60:	ca 01       	movw	r24, r20
    3e62:	b9 01       	movw	r22, r18
    3e64:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3e68:	20 e0       	ldi	r18, 0x00	; 0
    3e6a:	30 e0       	ldi	r19, 0x00	; 0
    3e6c:	40 e0       	ldi	r20, 0x00	; 0
    3e6e:	5f e3       	ldi	r21, 0x3F	; 63
    3e70:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3e74:	9b 01       	movw	r18, r22
    3e76:	ac 01       	movw	r20, r24
	

	//channel1Offset = negativeOnePoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);  *** //Throttle starts at -1. 
	channel1Offset = 0;//don't offset throttle. 
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
    3e78:	60 e0       	ldi	r22, 0x00	; 0
    3e7a:	70 e6       	ldi	r23, 0x60	; 96
    3e7c:	8f e8       	ldi	r24, 0x8F	; 143
    3e7e:	96 ec       	ldi	r25, 0xC6	; 198
    3e80:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3e84:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3e88:	f8 01       	movw	r30, r16
    3e8a:	71 83       	std	Z+1, r23	; 0x01
    3e8c:	60 83       	st	Z, r22
	channel4Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
    3e8e:	0e 5f       	subi	r16, 0xFE	; 254
    3e90:	1f 4f       	sbci	r17, 0xFF	; 255
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3e92:	8d a5       	ldd	r24, Y+45	; 0x2d
    3e94:	9e a5       	ldd	r25, Y+46	; 0x2e
    3e96:	af a5       	ldd	r26, Y+47	; 0x2f
    3e98:	b8 a9       	ldd	r27, Y+48	; 0x30
    3e9a:	a7 01       	movw	r20, r14
    3e9c:	96 01       	movw	r18, r12
    3e9e:	28 1b       	sub	r18, r24
    3ea0:	39 0b       	sbc	r19, r25
    3ea2:	4a 0b       	sbc	r20, r26
    3ea4:	5b 0b       	sbc	r21, r27
    3ea6:	ca 01       	movw	r24, r20
    3ea8:	b9 01       	movw	r22, r18
    3eaa:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3eae:	20 e0       	ldi	r18, 0x00	; 0
    3eb0:	30 e0       	ldi	r19, 0x00	; 0
    3eb2:	40 e0       	ldi	r20, 0x00	; 0
    3eb4:	5f e3       	ldi	r21, 0x3F	; 63
    3eb6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3eba:	9b 01       	movw	r18, r22
    3ebc:	ac 01       	movw	r20, r24

	//channel1Offset = negativeOnePoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);  *** //Throttle starts at -1. 
	channel1Offset = 0;//don't offset throttle. 
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
	channel4Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
    3ebe:	60 e0       	ldi	r22, 0x00	; 0
    3ec0:	78 e8       	ldi	r23, 0x88	; 136
    3ec2:	80 e9       	ldi	r24, 0x90	; 144
    3ec4:	96 e4       	ldi	r25, 0x46	; 70
    3ec6:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3eca:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3ece:	f8 01       	movw	r30, r16
    3ed0:	71 83       	std	Z+1, r23	; 0x01
    3ed2:	60 83       	st	Z, r22
	channel5Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
    3ed4:	0e 5f       	subi	r16, 0xFE	; 254
    3ed6:	1f 4f       	sbci	r17, 0xFF	; 255
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3ed8:	89 a9       	ldd	r24, Y+49	; 0x31
    3eda:	9a a9       	ldd	r25, Y+50	; 0x32
    3edc:	ab a9       	ldd	r26, Y+51	; 0x33
    3ede:	bc a9       	ldd	r27, Y+52	; 0x34
    3ee0:	a7 01       	movw	r20, r14
    3ee2:	96 01       	movw	r18, r12
    3ee4:	28 1b       	sub	r18, r24
    3ee6:	39 0b       	sbc	r19, r25
    3ee8:	4a 0b       	sbc	r20, r26
    3eea:	5b 0b       	sbc	r21, r27
    3eec:	ca 01       	movw	r24, r20
    3eee:	b9 01       	movw	r22, r18
    3ef0:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3ef4:	20 e0       	ldi	r18, 0x00	; 0
    3ef6:	30 e0       	ldi	r19, 0x00	; 0
    3ef8:	40 e0       	ldi	r20, 0x00	; 0
    3efa:	5f e3       	ldi	r21, 0x3F	; 63
    3efc:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3f00:	9b 01       	movw	r18, r22
    3f02:	ac 01       	movw	r20, r24
	//channel1Offset = negativeOnePoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);  *** //Throttle starts at -1. 
	channel1Offset = 0;//don't offset throttle. 
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
	channel4Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
	channel5Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
    3f04:	60 e0       	ldi	r22, 0x00	; 0
    3f06:	78 e8       	ldi	r23, 0x88	; 136
    3f08:	80 e9       	ldi	r24, 0x90	; 144
    3f0a:	96 e4       	ldi	r25, 0x46	; 70
    3f0c:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3f10:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3f14:	f8 01       	movw	r30, r16
    3f16:	71 83       	std	Z+1, r23	; 0x01
    3f18:	60 83       	st	Z, r22
	channel6Offset = outPitch - convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
    3f1a:	0e 5f       	subi	r16, 0xFE	; 254
    3f1c:	1f 4f       	sbci	r17, 0xFF	; 255
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3f1e:	8d a9       	ldd	r24, Y+53	; 0x35
    3f20:	9e a9       	ldd	r25, Y+54	; 0x36
    3f22:	af a9       	ldd	r26, Y+55	; 0x37
    3f24:	b8 ad       	ldd	r27, Y+56	; 0x38
    3f26:	a7 01       	movw	r20, r14
    3f28:	96 01       	movw	r18, r12
    3f2a:	28 1b       	sub	r18, r24
    3f2c:	39 0b       	sbc	r19, r25
    3f2e:	4a 0b       	sbc	r20, r26
    3f30:	5b 0b       	sbc	r21, r27
    3f32:	ca 01       	movw	r24, r20
    3f34:	b9 01       	movw	r22, r18
    3f36:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3f3a:	20 e0       	ldi	r18, 0x00	; 0
    3f3c:	30 e0       	ldi	r19, 0x00	; 0
    3f3e:	40 e0       	ldi	r20, 0x00	; 0
    3f40:	5f e3       	ldi	r21, 0x3F	; 63
    3f42:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3f46:	9b 01       	movw	r18, r22
    3f48:	ac 01       	movw	r20, r24
	channel1Offset = 0;//don't offset throttle. 
	channel2Offset = outAileron - convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
	channel4Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
	channel5Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
	channel6Offset = outPitch - convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
    3f4a:	60 e0       	ldi	r22, 0x00	; 0
    3f4c:	70 e6       	ldi	r23, 0x60	; 96
    3f4e:	8f e8       	ldi	r24, 0x8F	; 143
    3f50:	96 ec       	ldi	r25, 0xC6	; 198
    3f52:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3f56:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3f5a:	f8 01       	movw	r30, r16
    3f5c:	71 83       	std	Z+1, r23	; 0x01
    3f5e:	60 83       	st	Z, r22
	channel7Offset = 0;//AUX don't want an offset.
    3f60:	32 96       	adiw	r30, 0x02	; 2
    3f62:	11 82       	std	Z+1, r1	; 0x01
    3f64:	10 82       	st	Z, r1
	channel8Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    3f66:	0c 5f       	subi	r16, 0xFC	; 252
    3f68:	1f 4f       	sbci	r17, 0xFF	; 255
    3f6a:	ed 96       	adiw	r28, 0x3d	; 61
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3f6c:	88 81       	ld	r24, Y
    3f6e:	99 81       	ldd	r25, Y+1	; 0x01
    3f70:	aa 81       	ldd	r26, Y+2	; 0x02
    3f72:	bb 81       	ldd	r27, Y+3	; 0x03
    3f74:	a7 01       	movw	r20, r14
    3f76:	96 01       	movw	r18, r12
    3f78:	28 1b       	sub	r18, r24
    3f7a:	39 0b       	sbc	r19, r25
    3f7c:	4a 0b       	sbc	r20, r26
    3f7e:	5b 0b       	sbc	r21, r27
    3f80:	ca 01       	movw	r24, r20
    3f82:	b9 01       	movw	r22, r18
    3f84:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    3f88:	20 e0       	ldi	r18, 0x00	; 0
    3f8a:	30 e0       	ldi	r19, 0x00	; 0
    3f8c:	40 e0       	ldi	r20, 0x00	; 0
    3f8e:	5f e3       	ldi	r21, 0x3F	; 63
    3f90:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    3f94:	9b 01       	movw	r18, r22
    3f96:	ac 01       	movw	r20, r24
	channel3Offset = outElevator - convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
	channel4Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
	channel5Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
	channel6Offset = outPitch - convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
	channel7Offset = 0;//AUX don't want an offset.
	channel8Offset = zeroPoint - convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    3f98:	60 e0       	ldi	r22, 0x00	; 0
    3f9a:	78 e8       	ldi	r23, 0x88	; 136
    3f9c:	80 e9       	ldi	r24, 0x90	; 144
    3f9e:	96 e4       	ldi	r25, 0x46	; 70
    3fa0:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    3fa4:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    3fa8:	f8 01       	movw	r30, r16
    3faa:	71 83       	std	Z+1, r23	; 0x01
    3fac:	60 83       	st	Z, r22
			
	
	

	//Starts the PWM output timers
	TCCR1B |= (1<<CS11);
    3fae:	e1 e8       	ldi	r30, 0x81	; 129
    3fb0:	f0 e0       	ldi	r31, 0x00	; 0
    3fb2:	80 81       	ld	r24, Z
    3fb4:	82 60       	ori	r24, 0x02	; 2
    3fb6:	80 83       	st	Z, r24
	TCCR3B |= (1<<CS31);
    3fb8:	e1 e9       	ldi	r30, 0x91	; 145
    3fba:	f0 e0       	ldi	r31, 0x00	; 0
    3fbc:	80 81       	ld	r24, Z
    3fbe:	82 60       	ori	r24, 0x02	; 2
    3fc0:	80 83       	st	Z, r24
	TCCR4B |= (1<<CS41);
    3fc2:	e1 ea       	ldi	r30, 0xA1	; 161
    3fc4:	f0 e0       	ldi	r31, 0x00	; 0
    3fc6:	80 81       	ld	r24, Z
    3fc8:	82 60       	ori	r24, 0x02	; 2
    3fca:	80 83       	st	Z, r24

}
    3fcc:	df 91       	pop	r29
    3fce:	cf 91       	pop	r28
    3fd0:	1f 91       	pop	r17
    3fd2:	0f 91       	pop	r16
    3fd4:	ff 90       	pop	r15
    3fd6:	ef 90       	pop	r14
    3fd8:	df 90       	pop	r13
    3fda:	cf 90       	pop	r12
    3fdc:	08 95       	ret

00003fde <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>:
	*/
	
}

void RadioControllerInterface::controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue )
{
    3fde:	2f 92       	push	r2
    3fe0:	3f 92       	push	r3
    3fe2:	4f 92       	push	r4
    3fe4:	5f 92       	push	r5
    3fe6:	6f 92       	push	r6
    3fe8:	7f 92       	push	r7
    3fea:	8f 92       	push	r8
    3fec:	9f 92       	push	r9
    3fee:	af 92       	push	r10
    3ff0:	bf 92       	push	r11
    3ff2:	cf 92       	push	r12
    3ff4:	df 92       	push	r13
    3ff6:	ef 92       	push	r14
    3ff8:	ff 92       	push	r15
    3ffa:	0f 93       	push	r16
    3ffc:	1f 93       	push	r17
    3ffe:	cf 93       	push	r28
    4000:	df 93       	push	r29
    4002:	cd b7       	in	r28, 0x3d	; 61
    4004:	de b7       	in	r29, 0x3e	; 62
    4006:	2c 97       	sbiw	r28, 0x0c	; 12
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	de bf       	out	0x3e, r29	; 62
    400e:	0f be       	out	0x3f, r0	; 63
    4010:	cd bf       	out	0x3d, r28	; 61
    4012:	1c 01       	movw	r2, r24
    4014:	49 83       	std	Y+1, r20	; 0x01
    4016:	5a 83       	std	Y+2, r21	; 0x02
    4018:	6b 83       	std	Y+3, r22	; 0x03
    401a:	7c 83       	std	Y+4, r23	; 0x04
    401c:	28 01       	movw	r4, r16
    401e:	39 01       	movw	r6, r18
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
    4020:	fc 01       	movw	r30, r24
    4022:	e9 5a       	subi	r30, 0xA9	; 169
    4024:	ff 4f       	sbci	r31, 0xFF	; 255
    4026:	01 90       	ld	r0, Z+
    4028:	f0 81       	ld	r31, Z
    402a:	e0 2d       	mov	r30, r0
    402c:	82 81       	ldd	r24, Z+2	; 0x02

	
	//If in manual control, just forward the pulse width values from the input pins to the output pins.
	if (systemModel->OperationalState() == SystemModel::ManualControl)
    402e:	81 11       	cpse	r24, r1
    4030:	e6 c0       	rjmp	.+460    	; 0x41fe <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x220>
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
		*/
		
		ARRAYLOCK = true;
    4032:	81 e0       	ldi	r24, 0x01	; 1
    4034:	f1 01       	movw	r30, r2
    4036:	80 83       	st	Z, r24
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    4038:	0f 2e       	mov	r0, r31
    403a:	f0 e4       	ldi	r31, 0x40	; 64
    403c:	cf 2e       	mov	r12, r31
    403e:	fc e9       	ldi	r31, 0x9C	; 156
    4040:	df 2e       	mov	r13, r31
    4042:	e1 2c       	mov	r14, r1
    4044:	f1 2c       	mov	r15, r1
    4046:	f0 2d       	mov	r31, r0
    4048:	81 a1       	ldd	r24, Z+33	; 0x21
    404a:	92 a1       	ldd	r25, Z+34	; 0x22
    404c:	a3 a1       	ldd	r26, Z+35	; 0x23
    404e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4050:	97 01       	movw	r18, r14
    4052:	86 01       	movw	r16, r12
    4054:	08 1b       	sub	r16, r24
    4056:	19 0b       	sbc	r17, r25
    4058:	2a 0b       	sbc	r18, r26
    405a:	3b 0b       	sbc	r19, r27
    405c:	c9 01       	movw	r24, r18
    405e:	b8 01       	movw	r22, r16
    4060:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4064:	20 e0       	ldi	r18, 0x00	; 0
    4066:	30 e0       	ldi	r19, 0x00	; 0
    4068:	40 e0       	ldi	r20, 0x00	; 0
    406a:	5f e3       	ldi	r21, 0x3F	; 63
    406c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
		*/
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    4070:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4074:	70 93 8b 00 	sts	0x008B, r23
    4078:	60 93 8a 00 	sts	0x008A, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    407c:	f1 01       	movw	r30, r2
    407e:	85 a1       	ldd	r24, Z+37	; 0x25
    4080:	96 a1       	ldd	r25, Z+38	; 0x26
    4082:	a7 a1       	ldd	r26, Z+39	; 0x27
    4084:	b0 a5       	ldd	r27, Z+40	; 0x28
    4086:	97 01       	movw	r18, r14
    4088:	86 01       	movw	r16, r12
    408a:	08 1b       	sub	r16, r24
    408c:	19 0b       	sbc	r17, r25
    408e:	2a 0b       	sbc	r18, r26
    4090:	3b 0b       	sbc	r19, r27
    4092:	c9 01       	movw	r24, r18
    4094:	b8 01       	movw	r22, r16
    4096:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    409a:	20 e0       	ldi	r18, 0x00	; 0
    409c:	30 e0       	ldi	r19, 0x00	; 0
    409e:	40 e0       	ldi	r20, 0x00	; 0
    40a0:	5f e3       	ldi	r21, 0x3F	; 63
    40a2:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
		*/
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
    40a6:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    40aa:	70 93 89 00 	sts	0x0089, r23
    40ae:	60 93 88 00 	sts	0x0088, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    40b2:	f1 01       	movw	r30, r2
    40b4:	81 a5       	ldd	r24, Z+41	; 0x29
    40b6:	92 a5       	ldd	r25, Z+42	; 0x2a
    40b8:	a3 a5       	ldd	r26, Z+43	; 0x2b
    40ba:	b4 a5       	ldd	r27, Z+44	; 0x2c
    40bc:	97 01       	movw	r18, r14
    40be:	86 01       	movw	r16, r12
    40c0:	08 1b       	sub	r16, r24
    40c2:	19 0b       	sbc	r17, r25
    40c4:	2a 0b       	sbc	r18, r26
    40c6:	3b 0b       	sbc	r19, r27
    40c8:	c9 01       	movw	r24, r18
    40ca:	b8 01       	movw	r22, r16
    40cc:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    40d0:	20 e0       	ldi	r18, 0x00	; 0
    40d2:	30 e0       	ldi	r19, 0x00	; 0
    40d4:	40 e0       	ldi	r20, 0x00	; 0
    40d6:	5f e3       	ldi	r21, 0x3F	; 63
    40d8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		*/
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
    40dc:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    40e0:	70 93 ad 00 	sts	0x00AD, r23
    40e4:	60 93 ac 00 	sts	0x00AC, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    40e8:	f1 01       	movw	r30, r2
    40ea:	85 a5       	ldd	r24, Z+45	; 0x2d
    40ec:	96 a5       	ldd	r25, Z+46	; 0x2e
    40ee:	a7 a5       	ldd	r26, Z+47	; 0x2f
    40f0:	b0 a9       	ldd	r27, Z+48	; 0x30
    40f2:	97 01       	movw	r18, r14
    40f4:	86 01       	movw	r16, r12
    40f6:	08 1b       	sub	r16, r24
    40f8:	19 0b       	sbc	r17, r25
    40fa:	2a 0b       	sbc	r18, r26
    40fc:	3b 0b       	sbc	r19, r27
    40fe:	c9 01       	movw	r24, r18
    4100:	b8 01       	movw	r22, r16
    4102:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4106:	20 e0       	ldi	r18, 0x00	; 0
    4108:	30 e0       	ldi	r19, 0x00	; 0
    410a:	40 e0       	ldi	r20, 0x00	; 0
    410c:	5f e3       	ldi	r21, 0x3F	; 63
    410e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
    4112:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4116:	70 93 ab 00 	sts	0x00AB, r23
    411a:	60 93 aa 00 	sts	0x00AA, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    411e:	f1 01       	movw	r30, r2
    4120:	81 a9       	ldd	r24, Z+49	; 0x31
    4122:	92 a9       	ldd	r25, Z+50	; 0x32
    4124:	a3 a9       	ldd	r26, Z+51	; 0x33
    4126:	b4 a9       	ldd	r27, Z+52	; 0x34
    4128:	97 01       	movw	r18, r14
    412a:	86 01       	movw	r16, r12
    412c:	08 1b       	sub	r16, r24
    412e:	19 0b       	sbc	r17, r25
    4130:	2a 0b       	sbc	r18, r26
    4132:	3b 0b       	sbc	r19, r27
    4134:	c9 01       	movw	r24, r18
    4136:	b8 01       	movw	r22, r16
    4138:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    413c:	20 e0       	ldi	r18, 0x00	; 0
    413e:	30 e0       	ldi	r19, 0x00	; 0
    4140:	40 e0       	ldi	r20, 0x00	; 0
    4142:	5f e3       	ldi	r21, 0x3F	; 63
    4144:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
    4148:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    414c:	70 93 a9 00 	sts	0x00A9, r23
    4150:	60 93 a8 00 	sts	0x00A8, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    4154:	f1 01       	movw	r30, r2
    4156:	85 a9       	ldd	r24, Z+53	; 0x35
    4158:	96 a9       	ldd	r25, Z+54	; 0x36
    415a:	a7 a9       	ldd	r26, Z+55	; 0x37
    415c:	b0 ad       	ldd	r27, Z+56	; 0x38
    415e:	97 01       	movw	r18, r14
    4160:	86 01       	movw	r16, r12
    4162:	08 1b       	sub	r16, r24
    4164:	19 0b       	sbc	r17, r25
    4166:	2a 0b       	sbc	r18, r26
    4168:	3b 0b       	sbc	r19, r27
    416a:	c9 01       	movw	r24, r18
    416c:	b8 01       	movw	r22, r16
    416e:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4172:	20 e0       	ldi	r18, 0x00	; 0
    4174:	30 e0       	ldi	r19, 0x00	; 0
    4176:	40 e0       	ldi	r20, 0x00	; 0
    4178:	5f e3       	ldi	r21, 0x3F	; 63
    417a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
    417e:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4182:	70 93 9d 00 	sts	0x009D, r23
    4186:	60 93 9c 00 	sts	0x009C, r22
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    418a:	f1 01       	movw	r30, r2
    418c:	81 ad       	ldd	r24, Z+57	; 0x39
    418e:	92 ad       	ldd	r25, Z+58	; 0x3a
    4190:	a3 ad       	ldd	r26, Z+59	; 0x3b
    4192:	b4 ad       	ldd	r27, Z+60	; 0x3c
    4194:	97 01       	movw	r18, r14
    4196:	86 01       	movw	r16, r12
    4198:	08 1b       	sub	r16, r24
    419a:	19 0b       	sbc	r17, r25
    419c:	2a 0b       	sbc	r18, r26
    419e:	3b 0b       	sbc	r19, r27
    41a0:	c9 01       	movw	r24, r18
    41a2:	b8 01       	movw	r22, r16
    41a4:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    41a8:	20 e0       	ldi	r18, 0x00	; 0
    41aa:	30 e0       	ldi	r19, 0x00	; 0
    41ac:	40 e0       	ldi	r20, 0x00	; 0
    41ae:	5f e3       	ldi	r21, 0x3F	; 63
    41b0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
    41b4:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    41b8:	70 93 9b 00 	sts	0x009B, r23
    41bc:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    41c0:	f1 01       	movw	r30, r2
    41c2:	fd 96       	adiw	r30, 0x3d	; 61
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    41c4:	80 81       	ld	r24, Z
    41c6:	91 81       	ldd	r25, Z+1	; 0x01
    41c8:	a2 81       	ldd	r26, Z+2	; 0x02
    41ca:	b3 81       	ldd	r27, Z+3	; 0x03
    41cc:	a7 01       	movw	r20, r14
    41ce:	96 01       	movw	r18, r12
    41d0:	28 1b       	sub	r18, r24
    41d2:	39 0b       	sbc	r19, r25
    41d4:	4a 0b       	sbc	r20, r26
    41d6:	5b 0b       	sbc	r21, r27
    41d8:	ca 01       	movw	r24, r20
    41da:	b9 01       	movw	r22, r18
    41dc:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    41e0:	20 e0       	ldi	r18, 0x00	; 0
    41e2:	30 e0       	ldi	r19, 0x00	; 0
    41e4:	40 e0       	ldi	r20, 0x00	; 0
    41e6:	5f e3       	ldi	r21, 0x3F	; 63
    41e8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    41ec:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    41f0:	70 93 99 00 	sts	0x0099, r23
    41f4:	60 93 98 00 	sts	0x0098, r22
		ARRAYLOCK = false;
    41f8:	f1 01       	movw	r30, r2
    41fa:	10 82       	st	Z, r1
    41fc:	b1 c1       	rjmp	.+866    	; 0x4560 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x582>
		OCR4B = (servoChannelPulseWidths[3]);
		OCR4A = (servoChannelPulseWidths[4]);
		OCR3C = (servoChannelPulseWidths[5]);
		OCR3B = (servoChannelPulseWidths[6]);
		OCR3A = (servoChannelPulseWidths[7]);*/
	} else if (systemModel->OperationalState() == SystemModel::AutoPilot)
    41fe:	81 30       	cpi	r24, 0x01	; 1
    4200:	09 f0       	breq	.+2      	; 0x4204 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x226>
    4202:	ae c1       	rjmp	.+860    	; 0x4560 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x582>
	outAileron = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective+ELEVATOR_SCALER*SWASHOFFSETELEVATORMULTIPLYER*inElevator*-1+AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
	outElevator = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective*-1 + ELEVATOR_SCALER*SWASHOFFSETELEVATORELEVATORMULTIPLYER*inElevator*-1;
	*/	
	
	
	float scaledCollectiveWithOffsets = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective;
    4204:	20 e0       	ldi	r18, 0x00	; 0
    4206:	30 e0       	ldi	r19, 0x00	; 0
    4208:	44 e1       	ldi	r20, 0x14	; 20
    420a:	53 e4       	ldi	r21, 0x43	; 67
    420c:	c7 01       	movw	r24, r14
    420e:	b6 01       	movw	r22, r12
    4210:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    4214:	20 e0       	ldi	r18, 0x00	; 0
    4216:	38 e8       	ldi	r19, 0x88	; 136
    4218:	40 e9       	ldi	r20, 0x90	; 144
    421a:	56 e4       	ldi	r21, 0x46	; 70
    421c:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    4220:	6d 83       	std	Y+5, r22	; 0x05
    4222:	7e 83       	std	Y+6, r23	; 0x06
    4224:	8f 83       	std	Y+7, r24	; 0x07
    4226:	98 87       	std	Y+8, r25	; 0x08
	float scaledElevator = ELEVATOR_SCALER*inElevator;
    4228:	20 e0       	ldi	r18, 0x00	; 0
    422a:	30 e0       	ldi	r19, 0x00	; 0
    422c:	4c e2       	ldi	r20, 0x2C	; 44
    422e:	52 e4       	ldi	r21, 0x42	; 66
    4230:	c3 01       	movw	r24, r6
    4232:	b2 01       	movw	r22, r4
    4234:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    4238:	2b 01       	movw	r4, r22
    423a:	3c 01       	movw	r6, r24
	float scaledElevatorWithOffsets = scaledElevator*SWASHOFFSETELEVATORMULTIPLYER;
    423c:	9b 01       	movw	r18, r22
    423e:	ac 01       	movw	r20, r24
    4240:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    4244:	6b 01       	movw	r12, r22
    4246:	7c 01       	movw	r14, r24
	float negativeScaledAileronWithOffsets = AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
    4248:	20 e0       	ldi	r18, 0x00	; 0
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	41 e1       	ldi	r20, 0x11	; 17
    424e:	53 e4       	ldi	r21, 0x43	; 67
    4250:	69 81       	ldd	r22, Y+1	; 0x01
    4252:	7a 81       	ldd	r23, Y+2	; 0x02
    4254:	8b 81       	ldd	r24, Y+3	; 0x03
    4256:	9c 81       	ldd	r25, Y+4	; 0x04
    4258:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    425c:	69 83       	std	Y+1, r22	; 0x01
    425e:	7a 83       	std	Y+2, r23	; 0x02
    4260:	8b 83       	std	Y+3, r24	; 0x03
    4262:	9c 83       	std	Y+4, r25	; 0x04
	
	outPitch = scaledCollectiveWithOffsets*-1 + scaledElevatorWithOffsets+negativeScaledAileronWithOffsets;
    4264:	2d 81       	ldd	r18, Y+5	; 0x05
    4266:	3e 81       	ldd	r19, Y+6	; 0x06
    4268:	4f 81       	ldd	r20, Y+7	; 0x07
    426a:	58 85       	ldd	r21, Y+8	; 0x08
    426c:	c7 01       	movw	r24, r14
    426e:	b6 01       	movw	r22, r12
    4270:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4274:	29 81       	ldd	r18, Y+1	; 0x01
    4276:	3a 81       	ldd	r19, Y+2	; 0x02
    4278:	4b 81       	ldd	r20, Y+3	; 0x03
    427a:	5c 81       	ldd	r21, Y+4	; 0x04
    427c:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4280:	69 87       	std	Y+9, r22	; 0x09
    4282:	7a 87       	std	Y+10, r23	; 0x0a
    4284:	8b 87       	std	Y+11, r24	; 0x0b
    4286:	9c 87       	std	Y+12, r25	; 0x0c
		CCPM(lateralControl, longitudeControl, mainRotorControl, outAileron, outElevator, outPitch);
		
		
		//OCR1B = calculatePWMCompareMatchFromControlValue(THROTTLE_VALUE) - channel1Offset;
		
		ARRAYLOCK = true;
    4288:	81 e0       	ldi	r24, 0x01	; 1
    428a:	f1 01       	movw	r30, r2
    428c:	80 83       	st	Z, r24
	return scaledValue;
}

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    428e:	81 a1       	ldd	r24, Z+33	; 0x21
    4290:	92 a1       	ldd	r25, Z+34	; 0x22
    4292:	a3 a1       	ldd	r26, Z+35	; 0x23
    4294:	b4 a1       	ldd	r27, Z+36	; 0x24
    4296:	40 e4       	ldi	r20, 0x40	; 64
    4298:	5c e9       	ldi	r21, 0x9C	; 156
    429a:	60 e0       	ldi	r22, 0x00	; 0
    429c:	70 e0       	ldi	r23, 0x00	; 0
    429e:	8a 01       	movw	r16, r20
    42a0:	9b 01       	movw	r18, r22
    42a2:	08 1b       	sub	r16, r24
    42a4:	19 0b       	sbc	r17, r25
    42a6:	2a 0b       	sbc	r18, r26
    42a8:	3b 0b       	sbc	r19, r27
    42aa:	c9 01       	movw	r24, r18
    42ac:	b8 01       	movw	r22, r16
    42ae:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    42b2:	20 e0       	ldi	r18, 0x00	; 0
    42b4:	30 e0       	ldi	r19, 0x00	; 0
    42b6:	40 e0       	ldi	r20, 0x00	; 0
    42b8:	5f e3       	ldi	r21, 0x3F	; 63
    42ba:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		
		
		//OCR1B = calculatePWMCompareMatchFromControlValue(THROTTLE_VALUE) - channel1Offset;
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    42be:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    42c2:	70 93 8b 00 	sts	0x008B, r23
    42c6:	60 93 8a 00 	sts	0x008A, r22
		ARRAYLOCK = false;
    42ca:	f1 01       	movw	r30, r2
    42cc:	10 82       	st	Z, r1
	float scaledElevator = ELEVATOR_SCALER*inElevator;
	float scaledElevatorWithOffsets = scaledElevator*SWASHOFFSETELEVATORMULTIPLYER;
	float negativeScaledAileronWithOffsets = AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
	
	outPitch = scaledCollectiveWithOffsets*-1 + scaledElevatorWithOffsets+negativeScaledAileronWithOffsets;
	outAileron = scaledCollectiveWithOffsets+scaledElevatorWithOffsets*-1+negativeScaledAileronWithOffsets;
    42ce:	a7 01       	movw	r20, r14
    42d0:	96 01       	movw	r18, r12
    42d2:	6d 81       	ldd	r22, Y+5	; 0x05
    42d4:	7e 81       	ldd	r23, Y+6	; 0x06
    42d6:	8f 81       	ldd	r24, Y+7	; 0x07
    42d8:	98 85       	ldd	r25, Y+8	; 0x08
    42da:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    42de:	29 81       	ldd	r18, Y+1	; 0x01
    42e0:	3a 81       	ldd	r19, Y+2	; 0x02
    42e2:	4b 81       	ldd	r20, Y+3	; 0x03
    42e4:	5c 81       	ldd	r21, Y+4	; 0x04
    42e6:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    42ea:	6b 01       	movw	r12, r22
    42ec:	7c 01       	movw	r14, r24
		
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		ARRAYLOCK = false;
		
		OCR1A = outAileron - channel2Offset;
    42ee:	f1 01       	movw	r30, r2
    42f0:	e7 5b       	subi	r30, 0xB7	; 183
    42f2:	ff 4f       	sbci	r31, 0xFF	; 255
    42f4:	60 81       	ld	r22, Z
    42f6:	71 81       	ldd	r23, Z+1	; 0x01
    42f8:	88 27       	eor	r24, r24
    42fa:	77 fd       	sbrc	r23, 7
    42fc:	80 95       	com	r24
    42fe:	98 2f       	mov	r25, r24
    4300:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4304:	9b 01       	movw	r18, r22
    4306:	ac 01       	movw	r20, r24
    4308:	c7 01       	movw	r24, r14
    430a:	b6 01       	movw	r22, r12
    430c:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4310:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4314:	70 93 89 00 	sts	0x0089, r23
    4318:	60 93 88 00 	sts	0x0088, r22
	float scaledElevatorWithOffsets = scaledElevator*SWASHOFFSETELEVATORMULTIPLYER;
	float negativeScaledAileronWithOffsets = AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
	
	outPitch = scaledCollectiveWithOffsets*-1 + scaledElevatorWithOffsets+negativeScaledAileronWithOffsets;
	outAileron = scaledCollectiveWithOffsets+scaledElevatorWithOffsets*-1+negativeScaledAileronWithOffsets;
	outElevator = scaledCollectiveWithOffsets*-1 + scaledElevator*SWASHOFFSETELEVATORELEVATORMULTIPLYER*-1;
    431c:	cd 80       	ldd	r12, Y+5	; 0x05
    431e:	de 80       	ldd	r13, Y+6	; 0x06
    4320:	ef 80       	ldd	r14, Y+7	; 0x07
    4322:	f8 84       	ldd	r15, Y+8	; 0x08
    4324:	f7 fa       	bst	r15, 7
    4326:	f0 94       	com	r15
    4328:	f7 f8       	bld	r15, 7
    432a:	f0 94       	com	r15
    432c:	20 e0       	ldi	r18, 0x00	; 0
    432e:	30 e0       	ldi	r19, 0x00	; 0
    4330:	40 e8       	ldi	r20, 0x80	; 128
    4332:	50 e4       	ldi	r21, 0x40	; 64
    4334:	c3 01       	movw	r24, r6
    4336:	b2 01       	movw	r22, r4
    4338:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    433c:	9b 01       	movw	r18, r22
    433e:	ac 01       	movw	r20, r24
    4340:	c7 01       	movw	r24, r14
    4342:	b6 01       	movw	r22, r12
    4344:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4348:	6b 01       	movw	r12, r22
    434a:	7c 01       	movw	r14, r24
		ARRAYLOCK = true;
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		ARRAYLOCK = false;
		
		OCR1A = outAileron - channel2Offset;
		OCR4C = outElevator - channel3Offset;
    434c:	f1 01       	movw	r30, r2
    434e:	e5 5b       	subi	r30, 0xB5	; 181
    4350:	ff 4f       	sbci	r31, 0xFF	; 255
    4352:	60 81       	ld	r22, Z
    4354:	71 81       	ldd	r23, Z+1	; 0x01
    4356:	88 27       	eor	r24, r24
    4358:	77 fd       	sbrc	r23, 7
    435a:	80 95       	com	r24
    435c:	98 2f       	mov	r25, r24
    435e:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4362:	9b 01       	movw	r18, r22
    4364:	ac 01       	movw	r20, r24
    4366:	c7 01       	movw	r24, r14
    4368:	b6 01       	movw	r22, r12
    436a:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    436e:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4372:	70 93 ad 00 	sts	0x00AD, r23
    4376:	60 93 ac 00 	sts	0x00AC, r22
const float RadioControllerInterface::SWASHOFFSETSAILERONMULTIPLIER = 3.37209302325581;

float RadioControllerInterface::calculatePWMCompareMatchFromControlValue(float controlValue)
{
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
    437a:	20 e0       	ldi	r18, 0x00	; 0
    437c:	30 e0       	ldi	r19, 0x00	; 0
    437e:	40 e8       	ldi	r20, 0x80	; 128
    4380:	5f e3       	ldi	r21, 0x3F	; 63
    4382:	c5 01       	movw	r24, r10
    4384:	b4 01       	movw	r22, r8
    4386:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    438a:	20 e0       	ldi	r18, 0x00	; 0
    438c:	30 e0       	ldi	r19, 0x00	; 0
    438e:	4a ef       	ldi	r20, 0xFA	; 250
    4390:	53 ec       	ldi	r21, 0xC3	; 195
    4392:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    4396:	20 e0       	ldi	r18, 0x00	; 0
    4398:	30 e7       	ldi	r19, 0x70	; 112
    439a:	44 e9       	ldi	r20, 0x94	; 148
    439c:	56 e4       	ldi	r21, 0x46	; 70
    439e:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    43a2:	6b 01       	movw	r12, r22
    43a4:	7c 01       	movw	r14, r24
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
    43a6:	20 e0       	ldi	r18, 0x00	; 0
    43a8:	30 e7       	ldi	r19, 0x70	; 112
    43aa:	44 e9       	ldi	r20, 0x94	; 148
    43ac:	56 e4       	ldi	r21, 0x46	; 70
    43ae:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    43b2:	18 16       	cp	r1, r24
    43b4:	5c f0       	brlt	.+22     	; 0x43cc <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x3ee>
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
    43b6:	20 e0       	ldi	r18, 0x00	; 0
    43b8:	30 ea       	ldi	r19, 0xA0	; 160
    43ba:	4c e8       	ldi	r20, 0x8C	; 140
    43bc:	56 e4       	ldi	r21, 0x46	; 70
    43be:	c7 01       	movw	r24, r14
    43c0:	b6 01       	movw	r22, r12
    43c2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    43c6:	88 23       	and	r24, r24
    43c8:	5c f0       	brlt	.+22     	; 0x43e0 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x402>
    43ca:	13 c0       	rjmp	.+38     	; 0x43f2 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x414>
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
    43cc:	0f 2e       	mov	r0, r31
    43ce:	c1 2c       	mov	r12, r1
    43d0:	f0 e7       	ldi	r31, 0x70	; 112
    43d2:	df 2e       	mov	r13, r31
    43d4:	f4 e9       	ldi	r31, 0x94	; 148
    43d6:	ef 2e       	mov	r14, r31
    43d8:	f6 e4       	ldi	r31, 0x46	; 70
    43da:	ff 2e       	mov	r15, r31
    43dc:	f0 2d       	mov	r31, r0
    43de:	09 c0       	rjmp	.+18     	; 0x43f2 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x414>
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MAX_TICKS;
    43e0:	0f 2e       	mov	r0, r31
    43e2:	c1 2c       	mov	r12, r1
    43e4:	f0 ea       	ldi	r31, 0xA0	; 160
    43e6:	df 2e       	mov	r13, r31
    43e8:	fc e8       	ldi	r31, 0x8C	; 140
    43ea:	ef 2e       	mov	r14, r31
    43ec:	f6 e4       	ldi	r31, 0x46	; 70
    43ee:	ff 2e       	mov	r15, r31
    43f0:	f0 2d       	mov	r31, r0
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
		ARRAYLOCK = false;
		
		OCR1A = outAileron - channel2Offset;
		OCR4C = outElevator - channel3Offset;
		OCR4B = calculatePWMCompareMatchFromControlValue(yawControl) - channel4Offset;
    43f2:	f1 01       	movw	r30, r2
    43f4:	e3 5b       	subi	r30, 0xB3	; 179
    43f6:	ff 4f       	sbci	r31, 0xFF	; 255
    43f8:	60 81       	ld	r22, Z
    43fa:	71 81       	ldd	r23, Z+1	; 0x01
    43fc:	88 27       	eor	r24, r24
    43fe:	77 fd       	sbrc	r23, 7
    4400:	80 95       	com	r24
    4402:	98 2f       	mov	r25, r24
    4404:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4408:	9b 01       	movw	r18, r22
    440a:	ac 01       	movw	r20, r24
    440c:	c7 01       	movw	r24, r14
    440e:	b6 01       	movw	r22, r12
    4410:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4414:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4418:	70 93 ab 00 	sts	0x00AB, r23
    441c:	60 93 aa 00 	sts	0x00AA, r22
		OCR4A = calculatePWMCompareMatchFromControlValue(GEAR_VALUE) - channel5Offset;
    4420:	f1 01       	movw	r30, r2
    4422:	e1 5b       	subi	r30, 0xB1	; 177
    4424:	ff 4f       	sbci	r31, 0xFF	; 255
    4426:	60 81       	ld	r22, Z
    4428:	71 81       	ldd	r23, Z+1	; 0x01
    442a:	88 27       	eor	r24, r24
    442c:	77 fd       	sbrc	r23, 7
    442e:	80 95       	com	r24
    4430:	98 2f       	mov	r25, r24
    4432:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4436:	9b 01       	movw	r18, r22
    4438:	ac 01       	movw	r20, r24
    443a:	60 e0       	ldi	r22, 0x00	; 0
    443c:	78 e8       	ldi	r23, 0x88	; 136
    443e:	80 e9       	ldi	r24, 0x90	; 144
    4440:	96 e4       	ldi	r25, 0x46	; 70
    4442:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4446:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    444a:	70 93 a9 00 	sts	0x00A9, r23
    444e:	60 93 a8 00 	sts	0x00A8, r22
		OCR3C = outPitch - channel6Offset;
    4452:	f1 01       	movw	r30, r2
    4454:	ef 5a       	subi	r30, 0xAF	; 175
    4456:	ff 4f       	sbci	r31, 0xFF	; 255
    4458:	60 81       	ld	r22, Z
    445a:	71 81       	ldd	r23, Z+1	; 0x01
    445c:	88 27       	eor	r24, r24
    445e:	77 fd       	sbrc	r23, 7
    4460:	80 95       	com	r24
    4462:	98 2f       	mov	r25, r24
    4464:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4468:	9b 01       	movw	r18, r22
    446a:	ac 01       	movw	r20, r24
    446c:	69 85       	ldd	r22, Y+9	; 0x09
    446e:	7a 85       	ldd	r23, Y+10	; 0x0a
    4470:	8b 85       	ldd	r24, Y+11	; 0x0b
    4472:	9c 85       	ldd	r25, Y+12	; 0x0c
    4474:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4478:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    447c:	70 93 9d 00 	sts	0x009D, r23
    4480:	60 93 9c 00 	sts	0x009C, r22
const float RadioControllerInterface::SWASHOFFSETSAILERONMULTIPLIER = 3.37209302325581;

float RadioControllerInterface::calculatePWMCompareMatchFromControlValue(float controlValue)
{
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
    4484:	20 e0       	ldi	r18, 0x00	; 0
    4486:	30 e0       	ldi	r19, 0x00	; 0
    4488:	40 e8       	ldi	r20, 0x80	; 128
    448a:	5f e3       	ldi	r21, 0x3F	; 63
    448c:	6a a1       	ldd	r22, Y+34	; 0x22
    448e:	7b a1       	ldd	r23, Y+35	; 0x23
    4490:	8c a1       	ldd	r24, Y+36	; 0x24
    4492:	9d a1       	ldd	r25, Y+37	; 0x25
    4494:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    4498:	20 e0       	ldi	r18, 0x00	; 0
    449a:	30 e0       	ldi	r19, 0x00	; 0
    449c:	4a ef       	ldi	r20, 0xFA	; 250
    449e:	53 ec       	ldi	r21, 0xC3	; 195
    44a0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    44a4:	20 e0       	ldi	r18, 0x00	; 0
    44a6:	30 e7       	ldi	r19, 0x70	; 112
    44a8:	44 e9       	ldi	r20, 0x94	; 148
    44aa:	56 e4       	ldi	r21, 0x46	; 70
    44ac:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    44b0:	6b 01       	movw	r12, r22
    44b2:	7c 01       	movw	r14, r24
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
    44b4:	20 e0       	ldi	r18, 0x00	; 0
    44b6:	30 e7       	ldi	r19, 0x70	; 112
    44b8:	44 e9       	ldi	r20, 0x94	; 148
    44ba:	56 e4       	ldi	r21, 0x46	; 70
    44bc:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    44c0:	18 16       	cp	r1, r24
    44c2:	5c f0       	brlt	.+22     	; 0x44da <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x4fc>
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
    44c4:	20 e0       	ldi	r18, 0x00	; 0
    44c6:	30 ea       	ldi	r19, 0xA0	; 160
    44c8:	4c e8       	ldi	r20, 0x8C	; 140
    44ca:	56 e4       	ldi	r21, 0x46	; 70
    44cc:	c7 01       	movw	r24, r14
    44ce:	b6 01       	movw	r22, r12
    44d0:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    44d4:	88 23       	and	r24, r24
    44d6:	5c f0       	brlt	.+22     	; 0x44ee <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x510>
    44d8:	13 c0       	rjmp	.+38     	; 0x4500 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x522>
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
    44da:	0f 2e       	mov	r0, r31
    44dc:	c1 2c       	mov	r12, r1
    44de:	f0 e7       	ldi	r31, 0x70	; 112
    44e0:	df 2e       	mov	r13, r31
    44e2:	f4 e9       	ldi	r31, 0x94	; 148
    44e4:	ef 2e       	mov	r14, r31
    44e6:	f6 e4       	ldi	r31, 0x46	; 70
    44e8:	ff 2e       	mov	r15, r31
    44ea:	f0 2d       	mov	r31, r0
    44ec:	09 c0       	rjmp	.+18     	; 0x4500 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x522>
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MAX_TICKS;
    44ee:	0f 2e       	mov	r0, r31
    44f0:	c1 2c       	mov	r12, r1
    44f2:	f0 ea       	ldi	r31, 0xA0	; 160
    44f4:	df 2e       	mov	r13, r31
    44f6:	fc e8       	ldi	r31, 0x8C	; 140
    44f8:	ef 2e       	mov	r14, r31
    44fa:	f6 e4       	ldi	r31, 0x46	; 70
    44fc:	ff 2e       	mov	r15, r31
    44fe:	f0 2d       	mov	r31, r0
		OCR1A = outAileron - channel2Offset;
		OCR4C = outElevator - channel3Offset;
		OCR4B = calculatePWMCompareMatchFromControlValue(yawControl) - channel4Offset;
		OCR4A = calculatePWMCompareMatchFromControlValue(GEAR_VALUE) - channel5Offset;
		OCR3C = outPitch - channel6Offset;
		OCR3B = calculatePWMCompareMatchFromControlValue(auxChannelValue) - channel7Offset;
    4500:	f1 01       	movw	r30, r2
    4502:	ed 5a       	subi	r30, 0xAD	; 173
    4504:	ff 4f       	sbci	r31, 0xFF	; 255
    4506:	60 81       	ld	r22, Z
    4508:	71 81       	ldd	r23, Z+1	; 0x01
    450a:	88 27       	eor	r24, r24
    450c:	77 fd       	sbrc	r23, 7
    450e:	80 95       	com	r24
    4510:	98 2f       	mov	r25, r24
    4512:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4516:	9b 01       	movw	r18, r22
    4518:	ac 01       	movw	r20, r24
    451a:	c7 01       	movw	r24, r14
    451c:	b6 01       	movw	r22, r12
    451e:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4522:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4526:	70 93 9b 00 	sts	0x009B, r23
    452a:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = calculatePWMCompareMatchFromControlValue(AUX3_VALUE) - channel8Offset;
    452e:	f1 01       	movw	r30, r2
    4530:	eb 5a       	subi	r30, 0xAB	; 171
    4532:	ff 4f       	sbci	r31, 0xFF	; 255
    4534:	60 81       	ld	r22, Z
    4536:	71 81       	ldd	r23, Z+1	; 0x01
    4538:	88 27       	eor	r24, r24
    453a:	77 fd       	sbrc	r23, 7
    453c:	80 95       	com	r24
    453e:	98 2f       	mov	r25, r24
    4540:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    4544:	9b 01       	movw	r18, r22
    4546:	ac 01       	movw	r20, r24
    4548:	60 e0       	ldi	r22, 0x00	; 0
    454a:	78 e8       	ldi	r23, 0x88	; 136
    454c:	80 e9       	ldi	r24, 0x90	; 144
    454e:	96 e4       	ldi	r25, 0x46	; 70
    4550:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    4554:	0e 94 0c 68 	call	0xd018	; 0xd018 <__fixunssfsi>
    4558:	70 93 99 00 	sts	0x0099, r23
    455c:	60 93 98 00 	sts	0x0098, r22
		OCR3B = calculatePWMCompareMatchFromControlValue(-.8f);
		OCR3A = calculatePWMCompareMatchFromControlValue(-.8f);*/

	}

}
    4560:	2c 96       	adiw	r28, 0x0c	; 12
    4562:	0f b6       	in	r0, 0x3f	; 63
    4564:	f8 94       	cli
    4566:	de bf       	out	0x3e, r29	; 62
    4568:	0f be       	out	0x3f, r0	; 63
    456a:	cd bf       	out	0x3d, r28	; 61
    456c:	df 91       	pop	r29
    456e:	cf 91       	pop	r28
    4570:	1f 91       	pop	r17
    4572:	0f 91       	pop	r16
    4574:	ff 90       	pop	r15
    4576:	ef 90       	pop	r14
    4578:	df 90       	pop	r13
    457a:	cf 90       	pop	r12
    457c:	bf 90       	pop	r11
    457e:	af 90       	pop	r10
    4580:	9f 90       	pop	r9
    4582:	8f 90       	pop	r8
    4584:	7f 90       	pop	r7
    4586:	6f 90       	pop	r6
    4588:	5f 90       	pop	r5
    458a:	4f 90       	pop	r4
    458c:	3f 90       	pop	r3
    458e:	2f 90       	pop	r2
    4590:	08 95       	ret

00004592 <_ZN10helicopter8messages14ControlMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4592:	20 e5       	ldi	r18, 0x50	; 80
    4594:	32 e0       	ldi	r19, 0x02	; 2
    4596:	fc 01       	movw	r30, r24
    4598:	31 83       	std	Z+1, r19	; 0x01
    459a:	20 83       	st	Z, r18
    459c:	08 95       	ret

0000459e <_ZN10helicopter8messages14ControlMessageD0Ev>:
    459e:	20 e5       	ldi	r18, 0x50	; 80
    45a0:	32 e0       	ldi	r19, 0x02	; 2
    45a2:	fc 01       	movw	r30, r24
    45a4:	31 83       	std	Z+1, r19	; 0x01
    45a6:	20 83       	st	Z, r18
					LateralControl(0)
				{
					
				}
				
				~ControlMessage() {}
    45a8:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    45ac:	08 95       	ret

000045ae <_ZN10helicopter8messages14ControlMessage8getBytesEv>:
#include "ControlMessage.h"

using namespace helicopter::messages;

byte *ControlMessage::getBytes()
{
    45ae:	cf 93       	push	r28
    45b0:	df 93       	push	r29
    45b2:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    45b4:	81 e1       	ldi	r24, 0x11	; 17
    45b6:	90 e0       	ldi	r25, 0x00	; 0
    45b8:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    45bc:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    45be:	8a 81       	ldd	r24, Y+2	; 0x02
    45c0:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    45c2:	8d 81       	ldd	r24, Y+5	; 0x05
    45c4:	9e 81       	ldd	r25, Y+6	; 0x06
    45c6:	af 81       	ldd	r26, Y+7	; 0x07
    45c8:	b8 85       	ldd	r27, Y+8	; 0x08
    45ca:	81 83       	std	Z+1, r24	; 0x01
    45cc:	92 83       	std	Z+2, r25	; 0x02
    45ce:	a3 83       	std	Z+3, r26	; 0x03
    45d0:	b4 83       	std	Z+4, r27	; 0x04
    45d2:	49 85       	ldd	r20, Y+9	; 0x09
    45d4:	5a 85       	ldd	r21, Y+10	; 0x0a
    45d6:	6b 85       	ldd	r22, Y+11	; 0x0b
    45d8:	7c 85       	ldd	r23, Y+12	; 0x0c
    45da:	45 83       	std	Z+5, r20	; 0x05
    45dc:	56 83       	std	Z+6, r21	; 0x06
    45de:	67 83       	std	Z+7, r22	; 0x07
    45e0:	70 87       	std	Z+8, r23	; 0x08
    45e2:	4d 85       	ldd	r20, Y+13	; 0x0d
    45e4:	5e 85       	ldd	r21, Y+14	; 0x0e
    45e6:	6f 85       	ldd	r22, Y+15	; 0x0f
    45e8:	78 89       	ldd	r23, Y+16	; 0x10
    45ea:	41 87       	std	Z+9, r20	; 0x09
    45ec:	52 87       	std	Z+10, r21	; 0x0a
    45ee:	63 87       	std	Z+11, r22	; 0x0b
    45f0:	74 87       	std	Z+12, r23	; 0x0c
    45f2:	49 89       	ldd	r20, Y+17	; 0x11
    45f4:	5a 89       	ldd	r21, Y+18	; 0x12
    45f6:	6b 89       	ldd	r22, Y+19	; 0x13
    45f8:	7c 89       	ldd	r23, Y+20	; 0x14
    45fa:	45 87       	std	Z+13, r20	; 0x0d
    45fc:	56 87       	std	Z+14, r21	; 0x0e
    45fe:	67 87       	std	Z+15, r22	; 0x0f
    4600:	70 8b       	std	Z+16, r23	; 0x10
	encode (msgPtr, LongitudeControl);
	encode (msgPtr, LateralControl);
	
	
	return msg;
}
    4602:	cf 01       	movw	r24, r30
    4604:	df 91       	pop	r29
    4606:	cf 91       	pop	r28
    4608:	08 95       	ret

0000460a <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>:

void ControlMessage::buildMessage(byte *message)
{
    460a:	fc 01       	movw	r30, r24
    460c:	db 01       	movw	r26, r22
	if (message != NULL)
    460e:	10 97       	sbiw	r26, 0x00	; 0
    4610:	51 f1       	breq	.+84     	; 0x4666 <_ZN10helicopter8messages14ControlMessage12buildMessageEPh+0x5c>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    4612:	8c 91       	ld	r24, X
    4614:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4616:	11 96       	adiw	r26, 0x01	; 1
    4618:	4d 91       	ld	r20, X+
    461a:	5d 91       	ld	r21, X+
    461c:	6d 91       	ld	r22, X+
    461e:	7c 91       	ld	r23, X
    4620:	14 97       	sbiw	r26, 0x04	; 4
    4622:	45 83       	std	Z+5, r20	; 0x05
    4624:	56 83       	std	Z+6, r21	; 0x06
    4626:	67 83       	std	Z+7, r22	; 0x07
    4628:	70 87       	std	Z+8, r23	; 0x08
    462a:	15 96       	adiw	r26, 0x05	; 5
    462c:	4d 91       	ld	r20, X+
    462e:	5d 91       	ld	r21, X+
    4630:	6d 91       	ld	r22, X+
    4632:	7c 91       	ld	r23, X
    4634:	18 97       	sbiw	r26, 0x08	; 8
    4636:	41 87       	std	Z+9, r20	; 0x09
    4638:	52 87       	std	Z+10, r21	; 0x0a
    463a:	63 87       	std	Z+11, r22	; 0x0b
    463c:	74 87       	std	Z+12, r23	; 0x0c
    463e:	19 96       	adiw	r26, 0x09	; 9
    4640:	4d 91       	ld	r20, X+
    4642:	5d 91       	ld	r21, X+
    4644:	6d 91       	ld	r22, X+
    4646:	7c 91       	ld	r23, X
    4648:	1c 97       	sbiw	r26, 0x0c	; 12
    464a:	45 87       	std	Z+13, r20	; 0x0d
    464c:	56 87       	std	Z+14, r21	; 0x0e
    464e:	67 87       	std	Z+15, r22	; 0x0f
    4650:	70 8b       	std	Z+16, r23	; 0x10
    4652:	1d 96       	adiw	r26, 0x0d	; 13
    4654:	4d 91       	ld	r20, X+
    4656:	5d 91       	ld	r21, X+
    4658:	6d 91       	ld	r22, X+
    465a:	7c 91       	ld	r23, X
    465c:	50 97       	sbiw	r26, 0x10	; 16
    465e:	41 8b       	std	Z+17, r20	; 0x11
    4660:	52 8b       	std	Z+18, r21	; 0x12
    4662:	63 8b       	std	Z+19, r22	; 0x13
    4664:	74 8b       	std	Z+20, r23	; 0x14
    4666:	08 95       	ret

00004668 <_ZN10helicopter8messages12GainsMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4668:	20 e5       	ldi	r18, 0x50	; 80
    466a:	32 e0       	ldi	r19, 0x02	; 2
    466c:	fc 01       	movw	r30, r24
    466e:	31 83       	std	Z+1, r19	; 0x01
    4670:	20 83       	st	Z, r18
    4672:	08 95       	ret

00004674 <_ZN10helicopter8messages12GainsMessageD0Ev>:
    4674:	20 e5       	ldi	r18, 0x50	; 80
    4676:	32 e0       	ldi	r19, 0x02	; 2
    4678:	fc 01       	movw	r30, r24
    467a:	31 83       	std	Z+1, r19	; 0x01
    467c:	20 83       	st	Z, r18
					YawRefSetpoint(0)
				{
				
				}
			
				~GainsMessage() {}
    467e:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    4682:	08 95       	ret

00004684 <_ZN10helicopter8messages12GainsMessage8getBytesEv>:

using namespace helicopter::messages;


byte *GainsMessage::getBytes()
{
    4684:	cf 93       	push	r28
    4686:	df 93       	push	r29
    4688:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    468a:	81 e6       	ldi	r24, 0x61	; 97
    468c:	90 e0       	ldi	r25, 0x00	; 0
    468e:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    4692:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4694:	8a 81       	ldd	r24, Y+2	; 0x02
    4696:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4698:	8d 81       	ldd	r24, Y+5	; 0x05
    469a:	9e 81       	ldd	r25, Y+6	; 0x06
    469c:	af 81       	ldd	r26, Y+7	; 0x07
    469e:	b8 85       	ldd	r27, Y+8	; 0x08
    46a0:	81 83       	std	Z+1, r24	; 0x01
    46a2:	92 83       	std	Z+2, r25	; 0x02
    46a4:	a3 83       	std	Z+3, r26	; 0x03
    46a6:	b4 83       	std	Z+4, r27	; 0x04
    46a8:	89 85       	ldd	r24, Y+9	; 0x09
    46aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    46ac:	ab 85       	ldd	r26, Y+11	; 0x0b
    46ae:	bc 85       	ldd	r27, Y+12	; 0x0c
    46b0:	85 83       	std	Z+5, r24	; 0x05
    46b2:	96 83       	std	Z+6, r25	; 0x06
    46b4:	a7 83       	std	Z+7, r26	; 0x07
    46b6:	b0 87       	std	Z+8, r27	; 0x08
    46b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    46ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    46bc:	af 85       	ldd	r26, Y+15	; 0x0f
    46be:	b8 89       	ldd	r27, Y+16	; 0x10
    46c0:	81 87       	std	Z+9, r24	; 0x09
    46c2:	92 87       	std	Z+10, r25	; 0x0a
    46c4:	a3 87       	std	Z+11, r26	; 0x0b
    46c6:	b4 87       	std	Z+12, r27	; 0x0c
    46c8:	89 89       	ldd	r24, Y+17	; 0x11
    46ca:	9a 89       	ldd	r25, Y+18	; 0x12
    46cc:	ab 89       	ldd	r26, Y+19	; 0x13
    46ce:	bc 89       	ldd	r27, Y+20	; 0x14
    46d0:	85 87       	std	Z+13, r24	; 0x0d
    46d2:	96 87       	std	Z+14, r25	; 0x0e
    46d4:	a7 87       	std	Z+15, r26	; 0x0f
    46d6:	b0 8b       	std	Z+16, r27	; 0x10
    46d8:	8d 89       	ldd	r24, Y+21	; 0x15
    46da:	9e 89       	ldd	r25, Y+22	; 0x16
    46dc:	af 89       	ldd	r26, Y+23	; 0x17
    46de:	b8 8d       	ldd	r27, Y+24	; 0x18
    46e0:	81 8b       	std	Z+17, r24	; 0x11
    46e2:	92 8b       	std	Z+18, r25	; 0x12
    46e4:	a3 8b       	std	Z+19, r26	; 0x13
    46e6:	b4 8b       	std	Z+20, r27	; 0x14
    46e8:	89 8d       	ldd	r24, Y+25	; 0x19
    46ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    46ec:	ab 8d       	ldd	r26, Y+27	; 0x1b
    46ee:	bc 8d       	ldd	r27, Y+28	; 0x1c
    46f0:	85 8b       	std	Z+21, r24	; 0x15
    46f2:	96 8b       	std	Z+22, r25	; 0x16
    46f4:	a7 8b       	std	Z+23, r26	; 0x17
    46f6:	b0 8f       	std	Z+24, r27	; 0x18
    46f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    46fa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    46fc:	af 8d       	ldd	r26, Y+31	; 0x1f
    46fe:	b8 a1       	ldd	r27, Y+32	; 0x20
    4700:	81 8f       	std	Z+25, r24	; 0x19
    4702:	92 8f       	std	Z+26, r25	; 0x1a
    4704:	a3 8f       	std	Z+27, r26	; 0x1b
    4706:	b4 8f       	std	Z+28, r27	; 0x1c
    4708:	89 a1       	ldd	r24, Y+33	; 0x21
    470a:	9a a1       	ldd	r25, Y+34	; 0x22
    470c:	ab a1       	ldd	r26, Y+35	; 0x23
    470e:	bc a1       	ldd	r27, Y+36	; 0x24
    4710:	85 8f       	std	Z+29, r24	; 0x1d
    4712:	96 8f       	std	Z+30, r25	; 0x1e
    4714:	a7 8f       	std	Z+31, r26	; 0x1f
    4716:	b0 a3       	std	Z+32, r27	; 0x20
    4718:	8d a1       	ldd	r24, Y+37	; 0x25
    471a:	9e a1       	ldd	r25, Y+38	; 0x26
    471c:	af a1       	ldd	r26, Y+39	; 0x27
    471e:	b8 a5       	ldd	r27, Y+40	; 0x28
    4720:	81 a3       	std	Z+33, r24	; 0x21
    4722:	92 a3       	std	Z+34, r25	; 0x22
    4724:	a3 a3       	std	Z+35, r26	; 0x23
    4726:	b4 a3       	std	Z+36, r27	; 0x24
    4728:	89 a5       	ldd	r24, Y+41	; 0x29
    472a:	9a a5       	ldd	r25, Y+42	; 0x2a
    472c:	ab a5       	ldd	r26, Y+43	; 0x2b
    472e:	bc a5       	ldd	r27, Y+44	; 0x2c
    4730:	85 a3       	std	Z+37, r24	; 0x25
    4732:	96 a3       	std	Z+38, r25	; 0x26
    4734:	a7 a3       	std	Z+39, r26	; 0x27
    4736:	b0 a7       	std	Z+40, r27	; 0x28
    4738:	8d a5       	ldd	r24, Y+45	; 0x2d
    473a:	9e a5       	ldd	r25, Y+46	; 0x2e
    473c:	af a5       	ldd	r26, Y+47	; 0x2f
    473e:	b8 a9       	ldd	r27, Y+48	; 0x30
    4740:	81 a7       	std	Z+41, r24	; 0x29
    4742:	92 a7       	std	Z+42, r25	; 0x2a
    4744:	a3 a7       	std	Z+43, r26	; 0x2b
    4746:	b4 a7       	std	Z+44, r27	; 0x2c
    4748:	89 a9       	ldd	r24, Y+49	; 0x31
    474a:	9a a9       	ldd	r25, Y+50	; 0x32
    474c:	ab a9       	ldd	r26, Y+51	; 0x33
    474e:	bc a9       	ldd	r27, Y+52	; 0x34
    4750:	85 a7       	std	Z+45, r24	; 0x2d
    4752:	96 a7       	std	Z+46, r25	; 0x2e
    4754:	a7 a7       	std	Z+47, r26	; 0x2f
    4756:	b0 ab       	std	Z+48, r27	; 0x30
    4758:	8d a9       	ldd	r24, Y+53	; 0x35
    475a:	9e a9       	ldd	r25, Y+54	; 0x36
    475c:	af a9       	ldd	r26, Y+55	; 0x37
    475e:	b8 ad       	ldd	r27, Y+56	; 0x38
    4760:	81 ab       	std	Z+49, r24	; 0x31
    4762:	92 ab       	std	Z+50, r25	; 0x32
    4764:	a3 ab       	std	Z+51, r26	; 0x33
    4766:	b4 ab       	std	Z+52, r27	; 0x34
    4768:	89 ad       	ldd	r24, Y+57	; 0x39
    476a:	9a ad       	ldd	r25, Y+58	; 0x3a
    476c:	ab ad       	ldd	r26, Y+59	; 0x3b
    476e:	bc ad       	ldd	r27, Y+60	; 0x3c
    4770:	85 ab       	std	Z+53, r24	; 0x35
    4772:	96 ab       	std	Z+54, r25	; 0x36
    4774:	a7 ab       	std	Z+55, r26	; 0x37
    4776:	b0 af       	std	Z+56, r27	; 0x38
    4778:	de 01       	movw	r26, r28
    477a:	dd 96       	adiw	r26, 0x3d	; 61
    477c:	8d 91       	ld	r24, X+
    477e:	9d 91       	ld	r25, X+
    4780:	0d 90       	ld	r0, X+
    4782:	bc 91       	ld	r27, X
    4784:	a0 2d       	mov	r26, r0
    4786:	81 af       	std	Z+57, r24	; 0x39
    4788:	92 af       	std	Z+58, r25	; 0x3a
    478a:	a3 af       	std	Z+59, r26	; 0x3b
    478c:	b4 af       	std	Z+60, r27	; 0x3c
    478e:	9f 01       	movw	r18, r30
    4790:	23 5c       	subi	r18, 0xC3	; 195
    4792:	3f 4f       	sbci	r19, 0xFF	; 255
    4794:	de 01       	movw	r26, r28
    4796:	af 5b       	subi	r26, 0xBF	; 191
    4798:	bf 4f       	sbci	r27, 0xFF	; 255
    479a:	4d 91       	ld	r20, X+
    479c:	5d 91       	ld	r21, X+
    479e:	6d 91       	ld	r22, X+
    47a0:	7c 91       	ld	r23, X
    47a2:	d9 01       	movw	r26, r18
    47a4:	4d 93       	st	X+, r20
    47a6:	5d 93       	st	X+, r21
    47a8:	6d 93       	st	X+, r22
    47aa:	7c 93       	st	X, r23
    47ac:	13 97       	sbiw	r26, 0x03	; 3
    47ae:	2c 5f       	subi	r18, 0xFC	; 252
    47b0:	3f 4f       	sbci	r19, 0xFF	; 255
    47b2:	de 01       	movw	r26, r28
    47b4:	ab 5b       	subi	r26, 0xBB	; 187
    47b6:	bf 4f       	sbci	r27, 0xFF	; 255
    47b8:	4d 91       	ld	r20, X+
    47ba:	5d 91       	ld	r21, X+
    47bc:	6d 91       	ld	r22, X+
    47be:	7c 91       	ld	r23, X
    47c0:	d9 01       	movw	r26, r18
    47c2:	4d 93       	st	X+, r20
    47c4:	5d 93       	st	X+, r21
    47c6:	6d 93       	st	X+, r22
    47c8:	7c 93       	st	X, r23
    47ca:	13 97       	sbiw	r26, 0x03	; 3
    47cc:	2c 5f       	subi	r18, 0xFC	; 252
    47ce:	3f 4f       	sbci	r19, 0xFF	; 255
    47d0:	de 01       	movw	r26, r28
    47d2:	a7 5b       	subi	r26, 0xB7	; 183
    47d4:	bf 4f       	sbci	r27, 0xFF	; 255
    47d6:	4d 91       	ld	r20, X+
    47d8:	5d 91       	ld	r21, X+
    47da:	6d 91       	ld	r22, X+
    47dc:	7c 91       	ld	r23, X
    47de:	d9 01       	movw	r26, r18
    47e0:	4d 93       	st	X+, r20
    47e2:	5d 93       	st	X+, r21
    47e4:	6d 93       	st	X+, r22
    47e6:	7c 93       	st	X, r23
    47e8:	13 97       	sbiw	r26, 0x03	; 3
    47ea:	2c 5f       	subi	r18, 0xFC	; 252
    47ec:	3f 4f       	sbci	r19, 0xFF	; 255
    47ee:	de 01       	movw	r26, r28
    47f0:	a3 5b       	subi	r26, 0xB3	; 179
    47f2:	bf 4f       	sbci	r27, 0xFF	; 255
    47f4:	4d 91       	ld	r20, X+
    47f6:	5d 91       	ld	r21, X+
    47f8:	6d 91       	ld	r22, X+
    47fa:	7c 91       	ld	r23, X
    47fc:	d9 01       	movw	r26, r18
    47fe:	4d 93       	st	X+, r20
    4800:	5d 93       	st	X+, r21
    4802:	6d 93       	st	X+, r22
    4804:	7c 93       	st	X, r23
    4806:	13 97       	sbiw	r26, 0x03	; 3
    4808:	2c 5f       	subi	r18, 0xFC	; 252
    480a:	3f 4f       	sbci	r19, 0xFF	; 255
    480c:	de 01       	movw	r26, r28
    480e:	af 5a       	subi	r26, 0xAF	; 175
    4810:	bf 4f       	sbci	r27, 0xFF	; 255
    4812:	4d 91       	ld	r20, X+
    4814:	5d 91       	ld	r21, X+
    4816:	6d 91       	ld	r22, X+
    4818:	7c 91       	ld	r23, X
    481a:	d9 01       	movw	r26, r18
    481c:	4d 93       	st	X+, r20
    481e:	5d 93       	st	X+, r21
    4820:	6d 93       	st	X+, r22
    4822:	7c 93       	st	X, r23
    4824:	13 97       	sbiw	r26, 0x03	; 3
    4826:	2c 5f       	subi	r18, 0xFC	; 252
    4828:	3f 4f       	sbci	r19, 0xFF	; 255
    482a:	de 01       	movw	r26, r28
    482c:	ab 5a       	subi	r26, 0xAB	; 171
    482e:	bf 4f       	sbci	r27, 0xFF	; 255
    4830:	4d 91       	ld	r20, X+
    4832:	5d 91       	ld	r21, X+
    4834:	6d 91       	ld	r22, X+
    4836:	7c 91       	ld	r23, X
    4838:	d9 01       	movw	r26, r18
    483a:	4d 93       	st	X+, r20
    483c:	5d 93       	st	X+, r21
    483e:	6d 93       	st	X+, r22
    4840:	7c 93       	st	X, r23
    4842:	13 97       	sbiw	r26, 0x03	; 3
    4844:	2c 5f       	subi	r18, 0xFC	; 252
    4846:	3f 4f       	sbci	r19, 0xFF	; 255
    4848:	ce 01       	movw	r24, r28
    484a:	87 5a       	subi	r24, 0xA7	; 167
    484c:	9f 4f       	sbci	r25, 0xFF	; 255
    484e:	dc 01       	movw	r26, r24
    4850:	4d 91       	ld	r20, X+
    4852:	5d 91       	ld	r21, X+
    4854:	6d 91       	ld	r22, X+
    4856:	7c 91       	ld	r23, X
    4858:	d9 01       	movw	r26, r18
    485a:	4d 93       	st	X+, r20
    485c:	5d 93       	st	X+, r21
    485e:	6d 93       	st	X+, r22
    4860:	7c 93       	st	X, r23
    4862:	13 97       	sbiw	r26, 0x03	; 3
    4864:	2c 5f       	subi	r18, 0xFC	; 252
    4866:	3f 4f       	sbci	r19, 0xFF	; 255
    4868:	04 96       	adiw	r24, 0x04	; 4
    486a:	dc 01       	movw	r26, r24
    486c:	4d 91       	ld	r20, X+
    486e:	5d 91       	ld	r21, X+
    4870:	6d 91       	ld	r22, X+
    4872:	7c 91       	ld	r23, X
    4874:	d9 01       	movw	r26, r18
    4876:	4d 93       	st	X+, r20
    4878:	5d 93       	st	X+, r21
    487a:	6d 93       	st	X+, r22
    487c:	7c 93       	st	X, r23
    487e:	13 97       	sbiw	r26, 0x03	; 3
    4880:	14 96       	adiw	r26, 0x04	; 4
    4882:	cf 59       	subi	r28, 0x9F	; 159
    4884:	df 4f       	sbci	r29, 0xFF	; 255
    4886:	48 81       	ld	r20, Y
    4888:	59 81       	ldd	r21, Y+1	; 0x01
    488a:	6a 81       	ldd	r22, Y+2	; 0x02
    488c:	7b 81       	ldd	r23, Y+3	; 0x03
    488e:	4d 93       	st	X+, r20
    4890:	5d 93       	st	X+, r21
    4892:	6d 93       	st	X+, r22
    4894:	7c 93       	st	X, r23
    4896:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, YRefSetpoint);
	encode (msgPtr, ZRefSetpoint);	
	encode (msgPtr, YawRefSetpoint);
	
	return msg;
}
    4898:	cf 01       	movw	r24, r30
    489a:	df 91       	pop	r29
    489c:	cf 91       	pop	r28
    489e:	08 95       	ret

000048a0 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>:

void GainsMessage::buildMessage(byte *message)
{
    48a0:	cf 93       	push	r28
    48a2:	df 93       	push	r29
    48a4:	fc 01       	movw	r30, r24
    48a6:	db 01       	movw	r26, r22
	if (message != NULL)
    48a8:	10 97       	sbiw	r26, 0x00	; 0
    48aa:	09 f4       	brne	.+2      	; 0x48ae <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0xe>
    48ac:	10 c1       	rjmp	.+544    	; 0x4ace <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0x22e>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    48ae:	8c 91       	ld	r24, X
    48b0:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    48b2:	11 96       	adiw	r26, 0x01	; 1
    48b4:	4d 91       	ld	r20, X+
    48b6:	5d 91       	ld	r21, X+
    48b8:	6d 91       	ld	r22, X+
    48ba:	7c 91       	ld	r23, X
    48bc:	14 97       	sbiw	r26, 0x04	; 4
    48be:	45 83       	std	Z+5, r20	; 0x05
    48c0:	56 83       	std	Z+6, r21	; 0x06
    48c2:	67 83       	std	Z+7, r22	; 0x07
    48c4:	70 87       	std	Z+8, r23	; 0x08
    48c6:	15 96       	adiw	r26, 0x05	; 5
    48c8:	4d 91       	ld	r20, X+
    48ca:	5d 91       	ld	r21, X+
    48cc:	6d 91       	ld	r22, X+
    48ce:	7c 91       	ld	r23, X
    48d0:	18 97       	sbiw	r26, 0x08	; 8
    48d2:	41 87       	std	Z+9, r20	; 0x09
    48d4:	52 87       	std	Z+10, r21	; 0x0a
    48d6:	63 87       	std	Z+11, r22	; 0x0b
    48d8:	74 87       	std	Z+12, r23	; 0x0c
    48da:	19 96       	adiw	r26, 0x09	; 9
    48dc:	4d 91       	ld	r20, X+
    48de:	5d 91       	ld	r21, X+
    48e0:	6d 91       	ld	r22, X+
    48e2:	7c 91       	ld	r23, X
    48e4:	1c 97       	sbiw	r26, 0x0c	; 12
    48e6:	45 87       	std	Z+13, r20	; 0x0d
    48e8:	56 87       	std	Z+14, r21	; 0x0e
    48ea:	67 87       	std	Z+15, r22	; 0x0f
    48ec:	70 8b       	std	Z+16, r23	; 0x10
    48ee:	1d 96       	adiw	r26, 0x0d	; 13
    48f0:	4d 91       	ld	r20, X+
    48f2:	5d 91       	ld	r21, X+
    48f4:	6d 91       	ld	r22, X+
    48f6:	7c 91       	ld	r23, X
    48f8:	50 97       	sbiw	r26, 0x10	; 16
    48fa:	41 8b       	std	Z+17, r20	; 0x11
    48fc:	52 8b       	std	Z+18, r21	; 0x12
    48fe:	63 8b       	std	Z+19, r22	; 0x13
    4900:	74 8b       	std	Z+20, r23	; 0x14
    4902:	51 96       	adiw	r26, 0x11	; 17
    4904:	4d 91       	ld	r20, X+
    4906:	5d 91       	ld	r21, X+
    4908:	6d 91       	ld	r22, X+
    490a:	7c 91       	ld	r23, X
    490c:	54 97       	sbiw	r26, 0x14	; 20
    490e:	45 8b       	std	Z+21, r20	; 0x15
    4910:	56 8b       	std	Z+22, r21	; 0x16
    4912:	67 8b       	std	Z+23, r22	; 0x17
    4914:	70 8f       	std	Z+24, r23	; 0x18
    4916:	55 96       	adiw	r26, 0x15	; 21
    4918:	4d 91       	ld	r20, X+
    491a:	5d 91       	ld	r21, X+
    491c:	6d 91       	ld	r22, X+
    491e:	7c 91       	ld	r23, X
    4920:	58 97       	sbiw	r26, 0x18	; 24
    4922:	41 8f       	std	Z+25, r20	; 0x19
    4924:	52 8f       	std	Z+26, r21	; 0x1a
    4926:	63 8f       	std	Z+27, r22	; 0x1b
    4928:	74 8f       	std	Z+28, r23	; 0x1c
    492a:	59 96       	adiw	r26, 0x19	; 25
    492c:	4d 91       	ld	r20, X+
    492e:	5d 91       	ld	r21, X+
    4930:	6d 91       	ld	r22, X+
    4932:	7c 91       	ld	r23, X
    4934:	5c 97       	sbiw	r26, 0x1c	; 28
    4936:	45 8f       	std	Z+29, r20	; 0x1d
    4938:	56 8f       	std	Z+30, r21	; 0x1e
    493a:	67 8f       	std	Z+31, r22	; 0x1f
    493c:	70 a3       	std	Z+32, r23	; 0x20
    493e:	5d 96       	adiw	r26, 0x1d	; 29
    4940:	4d 91       	ld	r20, X+
    4942:	5d 91       	ld	r21, X+
    4944:	6d 91       	ld	r22, X+
    4946:	7c 91       	ld	r23, X
    4948:	90 97       	sbiw	r26, 0x20	; 32
    494a:	41 a3       	std	Z+33, r20	; 0x21
    494c:	52 a3       	std	Z+34, r21	; 0x22
    494e:	63 a3       	std	Z+35, r22	; 0x23
    4950:	74 a3       	std	Z+36, r23	; 0x24
    4952:	91 96       	adiw	r26, 0x21	; 33
    4954:	4d 91       	ld	r20, X+
    4956:	5d 91       	ld	r21, X+
    4958:	6d 91       	ld	r22, X+
    495a:	7c 91       	ld	r23, X
    495c:	94 97       	sbiw	r26, 0x24	; 36
    495e:	45 a3       	std	Z+37, r20	; 0x25
    4960:	56 a3       	std	Z+38, r21	; 0x26
    4962:	67 a3       	std	Z+39, r22	; 0x27
    4964:	70 a7       	std	Z+40, r23	; 0x28
    4966:	95 96       	adiw	r26, 0x25	; 37
    4968:	4d 91       	ld	r20, X+
    496a:	5d 91       	ld	r21, X+
    496c:	6d 91       	ld	r22, X+
    496e:	7c 91       	ld	r23, X
    4970:	98 97       	sbiw	r26, 0x28	; 40
    4972:	41 a7       	std	Z+41, r20	; 0x29
    4974:	52 a7       	std	Z+42, r21	; 0x2a
    4976:	63 a7       	std	Z+43, r22	; 0x2b
    4978:	74 a7       	std	Z+44, r23	; 0x2c
    497a:	99 96       	adiw	r26, 0x29	; 41
    497c:	4d 91       	ld	r20, X+
    497e:	5d 91       	ld	r21, X+
    4980:	6d 91       	ld	r22, X+
    4982:	7c 91       	ld	r23, X
    4984:	9c 97       	sbiw	r26, 0x2c	; 44
    4986:	45 a7       	std	Z+45, r20	; 0x2d
    4988:	56 a7       	std	Z+46, r21	; 0x2e
    498a:	67 a7       	std	Z+47, r22	; 0x2f
    498c:	70 ab       	std	Z+48, r23	; 0x30
    498e:	9d 96       	adiw	r26, 0x2d	; 45
    4990:	4d 91       	ld	r20, X+
    4992:	5d 91       	ld	r21, X+
    4994:	6d 91       	ld	r22, X+
    4996:	7c 91       	ld	r23, X
    4998:	d0 97       	sbiw	r26, 0x30	; 48
    499a:	41 ab       	std	Z+49, r20	; 0x31
    499c:	52 ab       	std	Z+50, r21	; 0x32
    499e:	63 ab       	std	Z+51, r22	; 0x33
    49a0:	74 ab       	std	Z+52, r23	; 0x34
    49a2:	d1 96       	adiw	r26, 0x31	; 49
    49a4:	4d 91       	ld	r20, X+
    49a6:	5d 91       	ld	r21, X+
    49a8:	6d 91       	ld	r22, X+
    49aa:	7c 91       	ld	r23, X
    49ac:	d4 97       	sbiw	r26, 0x34	; 52
    49ae:	45 ab       	std	Z+53, r20	; 0x35
    49b0:	56 ab       	std	Z+54, r21	; 0x36
    49b2:	67 ab       	std	Z+55, r22	; 0x37
    49b4:	70 af       	std	Z+56, r23	; 0x38
    49b6:	d5 96       	adiw	r26, 0x35	; 53
    49b8:	4d 91       	ld	r20, X+
    49ba:	5d 91       	ld	r21, X+
    49bc:	6d 91       	ld	r22, X+
    49be:	7c 91       	ld	r23, X
    49c0:	d8 97       	sbiw	r26, 0x38	; 56
    49c2:	41 af       	std	Z+57, r20	; 0x39
    49c4:	52 af       	std	Z+58, r21	; 0x3a
    49c6:	63 af       	std	Z+59, r22	; 0x3b
    49c8:	74 af       	std	Z+60, r23	; 0x3c
    49ca:	ef 01       	movw	r28, r30
    49cc:	ed 96       	adiw	r28, 0x3d	; 61
    49ce:	d9 96       	adiw	r26, 0x39	; 57
    49d0:	4d 91       	ld	r20, X+
    49d2:	5d 91       	ld	r21, X+
    49d4:	6d 91       	ld	r22, X+
    49d6:	7c 91       	ld	r23, X
    49d8:	dc 97       	sbiw	r26, 0x3c	; 60
    49da:	48 83       	st	Y, r20
    49dc:	59 83       	std	Y+1, r21	; 0x01
    49de:	6a 83       	std	Y+2, r22	; 0x02
    49e0:	7b 83       	std	Y+3, r23	; 0x03
    49e2:	9f 01       	movw	r18, r30
    49e4:	2f 5b       	subi	r18, 0xBF	; 191
    49e6:	3f 4f       	sbci	r19, 0xFF	; 255
    49e8:	cd 01       	movw	r24, r26
    49ea:	cd 96       	adiw	r24, 0x3d	; 61
    49ec:	ec 01       	movw	r28, r24
    49ee:	48 81       	ld	r20, Y
    49f0:	59 81       	ldd	r21, Y+1	; 0x01
    49f2:	6a 81       	ldd	r22, Y+2	; 0x02
    49f4:	7b 81       	ldd	r23, Y+3	; 0x03
    49f6:	e9 01       	movw	r28, r18
    49f8:	48 83       	st	Y, r20
    49fa:	59 83       	std	Y+1, r21	; 0x01
    49fc:	6a 83       	std	Y+2, r22	; 0x02
    49fe:	7b 83       	std	Y+3, r23	; 0x03
    4a00:	2c 5f       	subi	r18, 0xFC	; 252
    4a02:	3f 4f       	sbci	r19, 0xFF	; 255
    4a04:	04 96       	adiw	r24, 0x04	; 4
    4a06:	ec 01       	movw	r28, r24
    4a08:	48 81       	ld	r20, Y
    4a0a:	59 81       	ldd	r21, Y+1	; 0x01
    4a0c:	6a 81       	ldd	r22, Y+2	; 0x02
    4a0e:	7b 81       	ldd	r23, Y+3	; 0x03
    4a10:	e9 01       	movw	r28, r18
    4a12:	48 83       	st	Y, r20
    4a14:	59 83       	std	Y+1, r21	; 0x01
    4a16:	6a 83       	std	Y+2, r22	; 0x02
    4a18:	7b 83       	std	Y+3, r23	; 0x03
    4a1a:	2c 5f       	subi	r18, 0xFC	; 252
    4a1c:	3f 4f       	sbci	r19, 0xFF	; 255
    4a1e:	04 96       	adiw	r24, 0x04	; 4
    4a20:	ec 01       	movw	r28, r24
    4a22:	48 81       	ld	r20, Y
    4a24:	59 81       	ldd	r21, Y+1	; 0x01
    4a26:	6a 81       	ldd	r22, Y+2	; 0x02
    4a28:	7b 81       	ldd	r23, Y+3	; 0x03
    4a2a:	e9 01       	movw	r28, r18
    4a2c:	48 83       	st	Y, r20
    4a2e:	59 83       	std	Y+1, r21	; 0x01
    4a30:	6a 83       	std	Y+2, r22	; 0x02
    4a32:	7b 83       	std	Y+3, r23	; 0x03
    4a34:	2c 5f       	subi	r18, 0xFC	; 252
    4a36:	3f 4f       	sbci	r19, 0xFF	; 255
    4a38:	04 96       	adiw	r24, 0x04	; 4
    4a3a:	ec 01       	movw	r28, r24
    4a3c:	48 81       	ld	r20, Y
    4a3e:	59 81       	ldd	r21, Y+1	; 0x01
    4a40:	6a 81       	ldd	r22, Y+2	; 0x02
    4a42:	7b 81       	ldd	r23, Y+3	; 0x03
    4a44:	e9 01       	movw	r28, r18
    4a46:	48 83       	st	Y, r20
    4a48:	59 83       	std	Y+1, r21	; 0x01
    4a4a:	6a 83       	std	Y+2, r22	; 0x02
    4a4c:	7b 83       	std	Y+3, r23	; 0x03
    4a4e:	2c 5f       	subi	r18, 0xFC	; 252
    4a50:	3f 4f       	sbci	r19, 0xFF	; 255
    4a52:	04 96       	adiw	r24, 0x04	; 4
    4a54:	ec 01       	movw	r28, r24
    4a56:	48 81       	ld	r20, Y
    4a58:	59 81       	ldd	r21, Y+1	; 0x01
    4a5a:	6a 81       	ldd	r22, Y+2	; 0x02
    4a5c:	7b 81       	ldd	r23, Y+3	; 0x03
    4a5e:	e9 01       	movw	r28, r18
    4a60:	48 83       	st	Y, r20
    4a62:	59 83       	std	Y+1, r21	; 0x01
    4a64:	6a 83       	std	Y+2, r22	; 0x02
    4a66:	7b 83       	std	Y+3, r23	; 0x03
    4a68:	2c 5f       	subi	r18, 0xFC	; 252
    4a6a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a6c:	04 96       	adiw	r24, 0x04	; 4
    4a6e:	ec 01       	movw	r28, r24
    4a70:	48 81       	ld	r20, Y
    4a72:	59 81       	ldd	r21, Y+1	; 0x01
    4a74:	6a 81       	ldd	r22, Y+2	; 0x02
    4a76:	7b 81       	ldd	r23, Y+3	; 0x03
    4a78:	e9 01       	movw	r28, r18
    4a7a:	48 83       	st	Y, r20
    4a7c:	59 83       	std	Y+1, r21	; 0x01
    4a7e:	6a 83       	std	Y+2, r22	; 0x02
    4a80:	7b 83       	std	Y+3, r23	; 0x03
    4a82:	2c 5f       	subi	r18, 0xFC	; 252
    4a84:	3f 4f       	sbci	r19, 0xFF	; 255
    4a86:	04 96       	adiw	r24, 0x04	; 4
    4a88:	ec 01       	movw	r28, r24
    4a8a:	48 81       	ld	r20, Y
    4a8c:	59 81       	ldd	r21, Y+1	; 0x01
    4a8e:	6a 81       	ldd	r22, Y+2	; 0x02
    4a90:	7b 81       	ldd	r23, Y+3	; 0x03
    4a92:	e9 01       	movw	r28, r18
    4a94:	48 83       	st	Y, r20
    4a96:	59 83       	std	Y+1, r21	; 0x01
    4a98:	6a 83       	std	Y+2, r22	; 0x02
    4a9a:	7b 83       	std	Y+3, r23	; 0x03
    4a9c:	2c 5f       	subi	r18, 0xFC	; 252
    4a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa0:	04 96       	adiw	r24, 0x04	; 4
    4aa2:	ec 01       	movw	r28, r24
    4aa4:	48 81       	ld	r20, Y
    4aa6:	59 81       	ldd	r21, Y+1	; 0x01
    4aa8:	6a 81       	ldd	r22, Y+2	; 0x02
    4aaa:	7b 81       	ldd	r23, Y+3	; 0x03
    4aac:	e9 01       	movw	r28, r18
    4aae:	48 83       	st	Y, r20
    4ab0:	59 83       	std	Y+1, r21	; 0x01
    4ab2:	6a 83       	std	Y+2, r22	; 0x02
    4ab4:	7b 83       	std	Y+3, r23	; 0x03
    4ab6:	ef 59       	subi	r30, 0x9F	; 159
    4ab8:	ff 4f       	sbci	r31, 0xFF	; 255
    4aba:	a3 5a       	subi	r26, 0xA3	; 163
    4abc:	bf 4f       	sbci	r27, 0xFF	; 255
    4abe:	4d 91       	ld	r20, X+
    4ac0:	5d 91       	ld	r21, X+
    4ac2:	6d 91       	ld	r22, X+
    4ac4:	7c 91       	ld	r23, X
    4ac6:	40 83       	st	Z, r20
    4ac8:	51 83       	std	Z+1, r21	; 0x01
    4aca:	62 83       	std	Z+2, r22	; 0x02
    4acc:	73 83       	std	Z+3, r23	; 0x03
		decode (message, YRefSetpoint);
		decode (message, ZRefSetpoint);
		decode (message, YawRefSetpoint);
			
	}
}
    4ace:	df 91       	pop	r29
    4ad0:	cf 91       	pop	r28
    4ad2:	08 95       	ret

00004ad4 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>:

GainsMessage* GainsMessage::buildMessageSt(byte *message)
{
    4ad4:	0f 93       	push	r16
    4ad6:	1f 93       	push	r17
    4ad8:	cf 93       	push	r28
    4ada:	df 93       	push	r29
    4adc:	8c 01       	movw	r16, r24
	GainsMessage *msg = new GainsMessage();
    4ade:	85 e6       	ldi	r24, 0x65	; 101
    4ae0:	90 e0       	ldi	r25, 0x00	; 0
    4ae2:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    4ae6:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    4ae8:	87 e0       	ldi	r24, 0x07	; 7
    4aea:	8a 83       	std	Y+2, r24	; 0x02
    4aec:	81 e6       	ldi	r24, 0x61	; 97
    4aee:	90 e0       	ldi	r25, 0x00	; 0
    4af0:	9c 83       	std	Y+4, r25	; 0x04
    4af2:	8b 83       	std	Y+3, r24	; 0x03
					ZAntiWindupGain(0),
					
					XRefSetpoint(0),
					YRefSetpoint(0),
					ZRefSetpoint(0),
					YawRefSetpoint(0)
    4af4:	84 e4       	ldi	r24, 0x44	; 68
    4af6:	92 e0       	ldi	r25, 0x02	; 2
    4af8:	99 83       	std	Y+1, r25	; 0x01
    4afa:	88 83       	st	Y, r24
    4afc:	1d 82       	std	Y+5, r1	; 0x05
    4afe:	1e 82       	std	Y+6, r1	; 0x06
    4b00:	1f 82       	std	Y+7, r1	; 0x07
    4b02:	18 86       	std	Y+8, r1	; 0x08
    4b04:	19 86       	std	Y+9, r1	; 0x09
    4b06:	1a 86       	std	Y+10, r1	; 0x0a
    4b08:	1b 86       	std	Y+11, r1	; 0x0b
    4b0a:	1c 86       	std	Y+12, r1	; 0x0c
    4b0c:	1d 86       	std	Y+13, r1	; 0x0d
    4b0e:	1e 86       	std	Y+14, r1	; 0x0e
    4b10:	1f 86       	std	Y+15, r1	; 0x0f
    4b12:	18 8a       	std	Y+16, r1	; 0x10
    4b14:	19 8a       	std	Y+17, r1	; 0x11
    4b16:	1a 8a       	std	Y+18, r1	; 0x12
    4b18:	1b 8a       	std	Y+19, r1	; 0x13
    4b1a:	1c 8a       	std	Y+20, r1	; 0x14
    4b1c:	1d 8a       	std	Y+21, r1	; 0x15
    4b1e:	1e 8a       	std	Y+22, r1	; 0x16
    4b20:	1f 8a       	std	Y+23, r1	; 0x17
    4b22:	18 8e       	std	Y+24, r1	; 0x18
    4b24:	19 8e       	std	Y+25, r1	; 0x19
    4b26:	1a 8e       	std	Y+26, r1	; 0x1a
    4b28:	1b 8e       	std	Y+27, r1	; 0x1b
    4b2a:	1c 8e       	std	Y+28, r1	; 0x1c
    4b2c:	1d 8e       	std	Y+29, r1	; 0x1d
    4b2e:	1e 8e       	std	Y+30, r1	; 0x1e
    4b30:	1f 8e       	std	Y+31, r1	; 0x1f
    4b32:	18 a2       	std	Y+32, r1	; 0x20
    4b34:	19 a2       	std	Y+33, r1	; 0x21
    4b36:	1a a2       	std	Y+34, r1	; 0x22
    4b38:	1b a2       	std	Y+35, r1	; 0x23
    4b3a:	1c a2       	std	Y+36, r1	; 0x24
    4b3c:	1d a2       	std	Y+37, r1	; 0x25
    4b3e:	1e a2       	std	Y+38, r1	; 0x26
    4b40:	1f a2       	std	Y+39, r1	; 0x27
    4b42:	18 a6       	std	Y+40, r1	; 0x28
    4b44:	19 a6       	std	Y+41, r1	; 0x29
    4b46:	1a a6       	std	Y+42, r1	; 0x2a
    4b48:	1b a6       	std	Y+43, r1	; 0x2b
    4b4a:	1c a6       	std	Y+44, r1	; 0x2c
    4b4c:	1d a6       	std	Y+45, r1	; 0x2d
    4b4e:	1e a6       	std	Y+46, r1	; 0x2e
    4b50:	1f a6       	std	Y+47, r1	; 0x2f
    4b52:	18 aa       	std	Y+48, r1	; 0x30
    4b54:	19 aa       	std	Y+49, r1	; 0x31
    4b56:	1a aa       	std	Y+50, r1	; 0x32
    4b58:	1b aa       	std	Y+51, r1	; 0x33
    4b5a:	1c aa       	std	Y+52, r1	; 0x34
    4b5c:	1d aa       	std	Y+53, r1	; 0x35
    4b5e:	1e aa       	std	Y+54, r1	; 0x36
    4b60:	1f aa       	std	Y+55, r1	; 0x37
    4b62:	18 ae       	std	Y+56, r1	; 0x38
    4b64:	19 ae       	std	Y+57, r1	; 0x39
    4b66:	1a ae       	std	Y+58, r1	; 0x3a
    4b68:	1b ae       	std	Y+59, r1	; 0x3b
    4b6a:	1c ae       	std	Y+60, r1	; 0x3c
    4b6c:	fe 01       	movw	r30, r28
    4b6e:	fd 96       	adiw	r30, 0x3d	; 61
    4b70:	10 82       	st	Z, r1
    4b72:	11 82       	std	Z+1, r1	; 0x01
    4b74:	12 82       	std	Z+2, r1	; 0x02
    4b76:	13 82       	std	Z+3, r1	; 0x03
    4b78:	34 96       	adiw	r30, 0x04	; 4
    4b7a:	10 82       	st	Z, r1
    4b7c:	11 82       	std	Z+1, r1	; 0x01
    4b7e:	12 82       	std	Z+2, r1	; 0x02
    4b80:	13 82       	std	Z+3, r1	; 0x03
    4b82:	34 96       	adiw	r30, 0x04	; 4
    4b84:	10 82       	st	Z, r1
    4b86:	11 82       	std	Z+1, r1	; 0x01
    4b88:	12 82       	std	Z+2, r1	; 0x02
    4b8a:	13 82       	std	Z+3, r1	; 0x03
    4b8c:	34 96       	adiw	r30, 0x04	; 4
    4b8e:	10 82       	st	Z, r1
    4b90:	11 82       	std	Z+1, r1	; 0x01
    4b92:	12 82       	std	Z+2, r1	; 0x02
    4b94:	13 82       	std	Z+3, r1	; 0x03
    4b96:	34 96       	adiw	r30, 0x04	; 4
    4b98:	10 82       	st	Z, r1
    4b9a:	11 82       	std	Z+1, r1	; 0x01
    4b9c:	12 82       	std	Z+2, r1	; 0x02
    4b9e:	13 82       	std	Z+3, r1	; 0x03
    4ba0:	34 96       	adiw	r30, 0x04	; 4
    4ba2:	10 82       	st	Z, r1
    4ba4:	11 82       	std	Z+1, r1	; 0x01
    4ba6:	12 82       	std	Z+2, r1	; 0x02
    4ba8:	13 82       	std	Z+3, r1	; 0x03
    4baa:	34 96       	adiw	r30, 0x04	; 4
    4bac:	10 82       	st	Z, r1
    4bae:	11 82       	std	Z+1, r1	; 0x01
    4bb0:	12 82       	std	Z+2, r1	; 0x02
    4bb2:	13 82       	std	Z+3, r1	; 0x03
    4bb4:	34 96       	adiw	r30, 0x04	; 4
    4bb6:	10 82       	st	Z, r1
    4bb8:	11 82       	std	Z+1, r1	; 0x01
    4bba:	12 82       	std	Z+2, r1	; 0x02
    4bbc:	13 82       	std	Z+3, r1	; 0x03
    4bbe:	34 96       	adiw	r30, 0x04	; 4
    4bc0:	10 82       	st	Z, r1
    4bc2:	11 82       	std	Z+1, r1	; 0x01
    4bc4:	12 82       	std	Z+2, r1	; 0x02
    4bc6:	13 82       	std	Z+3, r1	; 0x03
    4bc8:	34 96       	adiw	r30, 0x04	; 4
    4bca:	10 82       	st	Z, r1
    4bcc:	11 82       	std	Z+1, r1	; 0x01
    4bce:	12 82       	std	Z+2, r1	; 0x02
    4bd0:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    4bd2:	b8 01       	movw	r22, r16
    4bd4:	ce 01       	movw	r24, r28
    4bd6:	0e 94 50 24 	call	0x48a0	; 0x48a0 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
	
	return msg;
}
    4bda:	ce 01       	movw	r24, r28
    4bdc:	df 91       	pop	r29
    4bde:	cf 91       	pop	r28
    4be0:	1f 91       	pop	r17
    4be2:	0f 91       	pop	r16
    4be4:	08 95       	ret

00004be6 <_ZN10helicopter8messages7MessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4be6:	20 e5       	ldi	r18, 0x50	; 80
    4be8:	32 e0       	ldi	r19, 0x02	; 2
    4bea:	fc 01       	movw	r30, r24
    4bec:	31 83       	std	Z+1, r19	; 0x01
    4bee:	20 83       	st	Z, r18
    4bf0:	08 95       	ret

00004bf2 <_ZN10helicopter8messages7Message8getBytesEv>:
	* Returns the data in this message in raw byte format for transmission.
	*/
byte *Message::getBytes()
{
	return NULL;
}
    4bf2:	80 e0       	ldi	r24, 0x00	; 0
    4bf4:	90 e0       	ldi	r25, 0x00	; 0
    4bf6:	08 95       	ret

00004bf8 <_ZN10helicopter8messages7Message12buildMessageEPh>:
	* for creating a message object given a stream of bytes.
	* @param message The bytes in the payload of the message which should be used
	* to construct a message object.
	*/
void Message::buildMessage(byte *message)
{
    4bf8:	08 95       	ret

00004bfa <_ZN10helicopter8messages7MessageD0Ev>:
    4bfa:	20 e5       	ldi	r18, 0x50	; 80
    4bfc:	32 e0       	ldi	r19, 0x02	; 2
    4bfe:	fc 01       	movw	r30, r24
    4c00:	31 83       	std	Z+1, r19	; 0x01
    4c02:	20 83       	st	Z, r18
					
				}
    4c04:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    4c08:	08 95       	ret

00004c0a <_ZN10helicopter8messages7Message14getMessageSizeEv>:
	* information (sync bytes and checksum bytes)
	*/
int Message::getMessageSize()
{
	return msgSize;
}
    4c0a:	fc 01       	movw	r30, r24
    4c0c:	83 81       	ldd	r24, Z+3	; 0x03
    4c0e:	94 81       	ldd	r25, Z+4	; 0x04
    4c10:	08 95       	ret

00004c12 <_ZN10helicopter8messages17SensorDataMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4c12:	20 e5       	ldi	r18, 0x50	; 80
    4c14:	32 e0       	ldi	r19, 0x02	; 2
    4c16:	fc 01       	movw	r30, r24
    4c18:	31 83       	std	Z+1, r19	; 0x01
    4c1a:	20 83       	st	Z, r18
    4c1c:	08 95       	ret

00004c1e <_ZN10helicopter8messages17SensorDataMessageD0Ev>:
    4c1e:	20 e5       	ldi	r18, 0x50	; 80
    4c20:	32 e0       	ldi	r19, 0x02	; 2
    4c22:	fc 01       	movw	r30, r24
    4c24:	31 83       	std	Z+1, r19	; 0x01
    4c26:	20 83       	st	Z, r18
					PressureMillibars(0)
				{
					
				}
				
				~SensorDataMessage() {}
    4c28:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    4c2c:	08 95       	ret

00004c2e <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>:
#include "SensorDataMessage.h"

using namespace helicopter::messages;

byte *SensorDataMessage::getBytes()
{
    4c2e:	cf 93       	push	r28
    4c30:	df 93       	push	r29
    4c32:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4c34:	81 e4       	ldi	r24, 0x41	; 65
    4c36:	90 e0       	ldi	r25, 0x00	; 0
    4c38:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    4c3c:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4c3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c40:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4c42:	8d 81       	ldd	r24, Y+5	; 0x05
    4c44:	9e 81       	ldd	r25, Y+6	; 0x06
    4c46:	af 81       	ldd	r26, Y+7	; 0x07
    4c48:	b8 85       	ldd	r27, Y+8	; 0x08
    4c4a:	81 83       	std	Z+1, r24	; 0x01
    4c4c:	92 83       	std	Z+2, r25	; 0x02
    4c4e:	a3 83       	std	Z+3, r26	; 0x03
    4c50:	b4 83       	std	Z+4, r27	; 0x04
    4c52:	89 85       	ldd	r24, Y+9	; 0x09
    4c54:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c56:	ab 85       	ldd	r26, Y+11	; 0x0b
    4c58:	bc 85       	ldd	r27, Y+12	; 0x0c
    4c5a:	85 83       	std	Z+5, r24	; 0x05
    4c5c:	96 83       	std	Z+6, r25	; 0x06
    4c5e:	a7 83       	std	Z+7, r26	; 0x07
    4c60:	b0 87       	std	Z+8, r27	; 0x08
    4c62:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c64:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c66:	af 85       	ldd	r26, Y+15	; 0x0f
    4c68:	b8 89       	ldd	r27, Y+16	; 0x10
    4c6a:	81 87       	std	Z+9, r24	; 0x09
    4c6c:	92 87       	std	Z+10, r25	; 0x0a
    4c6e:	a3 87       	std	Z+11, r26	; 0x0b
    4c70:	b4 87       	std	Z+12, r27	; 0x0c
    4c72:	89 89       	ldd	r24, Y+17	; 0x11
    4c74:	9a 89       	ldd	r25, Y+18	; 0x12
    4c76:	ab 89       	ldd	r26, Y+19	; 0x13
    4c78:	bc 89       	ldd	r27, Y+20	; 0x14
    4c7a:	85 87       	std	Z+13, r24	; 0x0d
    4c7c:	96 87       	std	Z+14, r25	; 0x0e
    4c7e:	a7 87       	std	Z+15, r26	; 0x0f
    4c80:	b0 8b       	std	Z+16, r27	; 0x10
    4c82:	8d 89       	ldd	r24, Y+21	; 0x15
    4c84:	9e 89       	ldd	r25, Y+22	; 0x16
    4c86:	af 89       	ldd	r26, Y+23	; 0x17
    4c88:	b8 8d       	ldd	r27, Y+24	; 0x18
    4c8a:	81 8b       	std	Z+17, r24	; 0x11
    4c8c:	92 8b       	std	Z+18, r25	; 0x12
    4c8e:	a3 8b       	std	Z+19, r26	; 0x13
    4c90:	b4 8b       	std	Z+20, r27	; 0x14
    4c92:	89 8d       	ldd	r24, Y+25	; 0x19
    4c94:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4c96:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4c98:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4c9a:	85 8b       	std	Z+21, r24	; 0x15
    4c9c:	96 8b       	std	Z+22, r25	; 0x16
    4c9e:	a7 8b       	std	Z+23, r26	; 0x17
    4ca0:	b0 8f       	std	Z+24, r27	; 0x18
    4ca2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4ca4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4ca6:	af 8d       	ldd	r26, Y+31	; 0x1f
    4ca8:	b8 a1       	ldd	r27, Y+32	; 0x20
    4caa:	81 8f       	std	Z+25, r24	; 0x19
    4cac:	92 8f       	std	Z+26, r25	; 0x1a
    4cae:	a3 8f       	std	Z+27, r26	; 0x1b
    4cb0:	b4 8f       	std	Z+28, r27	; 0x1c
    4cb2:	89 a1       	ldd	r24, Y+33	; 0x21
    4cb4:	9a a1       	ldd	r25, Y+34	; 0x22
    4cb6:	ab a1       	ldd	r26, Y+35	; 0x23
    4cb8:	bc a1       	ldd	r27, Y+36	; 0x24
    4cba:	85 8f       	std	Z+29, r24	; 0x1d
    4cbc:	96 8f       	std	Z+30, r25	; 0x1e
    4cbe:	a7 8f       	std	Z+31, r26	; 0x1f
    4cc0:	b0 a3       	std	Z+32, r27	; 0x20
    4cc2:	8d a1       	ldd	r24, Y+37	; 0x25
    4cc4:	9e a1       	ldd	r25, Y+38	; 0x26
    4cc6:	af a1       	ldd	r26, Y+39	; 0x27
    4cc8:	b8 a5       	ldd	r27, Y+40	; 0x28
    4cca:	81 a3       	std	Z+33, r24	; 0x21
    4ccc:	92 a3       	std	Z+34, r25	; 0x22
    4cce:	a3 a3       	std	Z+35, r26	; 0x23
    4cd0:	b4 a3       	std	Z+36, r27	; 0x24
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4cd2:	89 a5       	ldd	r24, Y+41	; 0x29
    4cd4:	9a a5       	ldd	r25, Y+42	; 0x2a
    4cd6:	ab a5       	ldd	r26, Y+43	; 0x2b
    4cd8:	bc a5       	ldd	r27, Y+44	; 0x2c
    4cda:	85 a3       	std	Z+37, r24	; 0x25
    4cdc:	96 a3       	std	Z+38, r25	; 0x26
    4cde:	a7 a3       	std	Z+39, r26	; 0x27
    4ce0:	b0 a7       	std	Z+40, r27	; 0x28
    4ce2:	8d a5       	ldd	r24, Y+45	; 0x2d
    4ce4:	9e a5       	ldd	r25, Y+46	; 0x2e
    4ce6:	af a5       	ldd	r26, Y+47	; 0x2f
    4ce8:	b8 a9       	ldd	r27, Y+48	; 0x30
    4cea:	81 a7       	std	Z+41, r24	; 0x29
    4cec:	92 a7       	std	Z+42, r25	; 0x2a
    4cee:	a3 a7       	std	Z+43, r26	; 0x2b
    4cf0:	b4 a7       	std	Z+44, r27	; 0x2c
    4cf2:	89 a9       	ldd	r24, Y+49	; 0x31
    4cf4:	9a a9       	ldd	r25, Y+50	; 0x32
    4cf6:	ab a9       	ldd	r26, Y+51	; 0x33
    4cf8:	bc a9       	ldd	r27, Y+52	; 0x34
    4cfa:	85 a7       	std	Z+45, r24	; 0x2d
    4cfc:	96 a7       	std	Z+46, r25	; 0x2e
    4cfe:	a7 a7       	std	Z+47, r26	; 0x2f
    4d00:	b0 ab       	std	Z+48, r27	; 0x30
    4d02:	8d a9       	ldd	r24, Y+53	; 0x35
    4d04:	9e a9       	ldd	r25, Y+54	; 0x36
    4d06:	af a9       	ldd	r26, Y+55	; 0x37
    4d08:	b8 ad       	ldd	r27, Y+56	; 0x38
    4d0a:	81 ab       	std	Z+49, r24	; 0x31
    4d0c:	92 ab       	std	Z+50, r25	; 0x32
    4d0e:	a3 ab       	std	Z+51, r26	; 0x33
    4d10:	b4 ab       	std	Z+52, r27	; 0x34
    4d12:	49 ad       	ldd	r20, Y+57	; 0x39
    4d14:	5a ad       	ldd	r21, Y+58	; 0x3a
    4d16:	6b ad       	ldd	r22, Y+59	; 0x3b
    4d18:	7c ad       	ldd	r23, Y+60	; 0x3c
    4d1a:	45 ab       	std	Z+53, r20	; 0x35
    4d1c:	56 ab       	std	Z+54, r21	; 0x36
    4d1e:	67 ab       	std	Z+55, r22	; 0x37
    4d20:	70 af       	std	Z+56, r23	; 0x38
    4d22:	de 01       	movw	r26, r28
    4d24:	dd 96       	adiw	r26, 0x3d	; 61
    4d26:	4d 91       	ld	r20, X+
    4d28:	5d 91       	ld	r21, X+
    4d2a:	6d 91       	ld	r22, X+
    4d2c:	7c 91       	ld	r23, X
    4d2e:	41 af       	std	Z+57, r20	; 0x39
    4d30:	52 af       	std	Z+58, r21	; 0x3a
    4d32:	63 af       	std	Z+59, r22	; 0x3b
    4d34:	74 af       	std	Z+60, r23	; 0x3c
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4d36:	df 01       	movw	r26, r30
    4d38:	dd 96       	adiw	r26, 0x3d	; 61
    4d3a:	cf 5b       	subi	r28, 0xBF	; 191
    4d3c:	df 4f       	sbci	r29, 0xFF	; 255
    4d3e:	48 81       	ld	r20, Y
    4d40:	59 81       	ldd	r21, Y+1	; 0x01
    4d42:	6a 81       	ldd	r22, Y+2	; 0x02
    4d44:	7b 81       	ldd	r23, Y+3	; 0x03
    4d46:	4d 93       	st	X+, r20
    4d48:	5d 93       	st	X+, r21
    4d4a:	6d 93       	st	X+, r22
    4d4c:	7c 93       	st	X, r23
    4d4e:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ZVEcefCms);
	encode (msgPtr, PressureMillibars);
	
	
	return msg;
}
    4d50:	cf 01       	movw	r24, r30
    4d52:	df 91       	pop	r29
    4d54:	cf 91       	pop	r28
    4d56:	08 95       	ret

00004d58 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>:

void SensorDataMessage::buildMessage(byte *message)
{
    4d58:	cf 93       	push	r28
    4d5a:	df 93       	push	r29
    4d5c:	fc 01       	movw	r30, r24
    4d5e:	db 01       	movw	r26, r22
	if (message != NULL)
    4d60:	10 97       	sbiw	r26, 0x00	; 0
    4d62:	09 f4       	brne	.+2      	; 0x4d66 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0xe>
    4d64:	a5 c0       	rjmp	.+330    	; 0x4eb0 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0x158>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    4d66:	8c 91       	ld	r24, X
    4d68:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4d6a:	11 96       	adiw	r26, 0x01	; 1
    4d6c:	4d 91       	ld	r20, X+
    4d6e:	5d 91       	ld	r21, X+
    4d70:	6d 91       	ld	r22, X+
    4d72:	7c 91       	ld	r23, X
    4d74:	14 97       	sbiw	r26, 0x04	; 4
    4d76:	45 83       	std	Z+5, r20	; 0x05
    4d78:	56 83       	std	Z+6, r21	; 0x06
    4d7a:	67 83       	std	Z+7, r22	; 0x07
    4d7c:	70 87       	std	Z+8, r23	; 0x08
    4d7e:	15 96       	adiw	r26, 0x05	; 5
    4d80:	4d 91       	ld	r20, X+
    4d82:	5d 91       	ld	r21, X+
    4d84:	6d 91       	ld	r22, X+
    4d86:	7c 91       	ld	r23, X
    4d88:	18 97       	sbiw	r26, 0x08	; 8
    4d8a:	41 87       	std	Z+9, r20	; 0x09
    4d8c:	52 87       	std	Z+10, r21	; 0x0a
    4d8e:	63 87       	std	Z+11, r22	; 0x0b
    4d90:	74 87       	std	Z+12, r23	; 0x0c
    4d92:	19 96       	adiw	r26, 0x09	; 9
    4d94:	4d 91       	ld	r20, X+
    4d96:	5d 91       	ld	r21, X+
    4d98:	6d 91       	ld	r22, X+
    4d9a:	7c 91       	ld	r23, X
    4d9c:	1c 97       	sbiw	r26, 0x0c	; 12
    4d9e:	45 87       	std	Z+13, r20	; 0x0d
    4da0:	56 87       	std	Z+14, r21	; 0x0e
    4da2:	67 87       	std	Z+15, r22	; 0x0f
    4da4:	70 8b       	std	Z+16, r23	; 0x10
    4da6:	1d 96       	adiw	r26, 0x0d	; 13
    4da8:	4d 91       	ld	r20, X+
    4daa:	5d 91       	ld	r21, X+
    4dac:	6d 91       	ld	r22, X+
    4dae:	7c 91       	ld	r23, X
    4db0:	50 97       	sbiw	r26, 0x10	; 16
    4db2:	41 8b       	std	Z+17, r20	; 0x11
    4db4:	52 8b       	std	Z+18, r21	; 0x12
    4db6:	63 8b       	std	Z+19, r22	; 0x13
    4db8:	74 8b       	std	Z+20, r23	; 0x14
    4dba:	51 96       	adiw	r26, 0x11	; 17
    4dbc:	4d 91       	ld	r20, X+
    4dbe:	5d 91       	ld	r21, X+
    4dc0:	6d 91       	ld	r22, X+
    4dc2:	7c 91       	ld	r23, X
    4dc4:	54 97       	sbiw	r26, 0x14	; 20
    4dc6:	45 8b       	std	Z+21, r20	; 0x15
    4dc8:	56 8b       	std	Z+22, r21	; 0x16
    4dca:	67 8b       	std	Z+23, r22	; 0x17
    4dcc:	70 8f       	std	Z+24, r23	; 0x18
    4dce:	55 96       	adiw	r26, 0x15	; 21
    4dd0:	4d 91       	ld	r20, X+
    4dd2:	5d 91       	ld	r21, X+
    4dd4:	6d 91       	ld	r22, X+
    4dd6:	7c 91       	ld	r23, X
    4dd8:	58 97       	sbiw	r26, 0x18	; 24
    4dda:	41 8f       	std	Z+25, r20	; 0x19
    4ddc:	52 8f       	std	Z+26, r21	; 0x1a
    4dde:	63 8f       	std	Z+27, r22	; 0x1b
    4de0:	74 8f       	std	Z+28, r23	; 0x1c
    4de2:	59 96       	adiw	r26, 0x19	; 25
    4de4:	4d 91       	ld	r20, X+
    4de6:	5d 91       	ld	r21, X+
    4de8:	6d 91       	ld	r22, X+
    4dea:	7c 91       	ld	r23, X
    4dec:	5c 97       	sbiw	r26, 0x1c	; 28
    4dee:	45 8f       	std	Z+29, r20	; 0x1d
    4df0:	56 8f       	std	Z+30, r21	; 0x1e
    4df2:	67 8f       	std	Z+31, r22	; 0x1f
    4df4:	70 a3       	std	Z+32, r23	; 0x20
    4df6:	5d 96       	adiw	r26, 0x1d	; 29
    4df8:	4d 91       	ld	r20, X+
    4dfa:	5d 91       	ld	r21, X+
    4dfc:	6d 91       	ld	r22, X+
    4dfe:	7c 91       	ld	r23, X
    4e00:	90 97       	sbiw	r26, 0x20	; 32
    4e02:	41 a3       	std	Z+33, r20	; 0x21
    4e04:	52 a3       	std	Z+34, r21	; 0x22
    4e06:	63 a3       	std	Z+35, r22	; 0x23
    4e08:	74 a3       	std	Z+36, r23	; 0x24
    4e0a:	91 96       	adiw	r26, 0x21	; 33
    4e0c:	4d 91       	ld	r20, X+
    4e0e:	5d 91       	ld	r21, X+
    4e10:	6d 91       	ld	r22, X+
    4e12:	7c 91       	ld	r23, X
    4e14:	94 97       	sbiw	r26, 0x24	; 36
    4e16:	45 a3       	std	Z+37, r20	; 0x25
    4e18:	56 a3       	std	Z+38, r21	; 0x26
    4e1a:	67 a3       	std	Z+39, r22	; 0x27
    4e1c:	70 a7       	std	Z+40, r23	; 0x28
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4e1e:	95 96       	adiw	r26, 0x25	; 37
    4e20:	4d 91       	ld	r20, X+
    4e22:	5d 91       	ld	r21, X+
    4e24:	6d 91       	ld	r22, X+
    4e26:	7c 91       	ld	r23, X
    4e28:	98 97       	sbiw	r26, 0x28	; 40
    4e2a:	41 a7       	std	Z+41, r20	; 0x29
    4e2c:	52 a7       	std	Z+42, r21	; 0x2a
    4e2e:	63 a7       	std	Z+43, r22	; 0x2b
    4e30:	74 a7       	std	Z+44, r23	; 0x2c
    4e32:	99 96       	adiw	r26, 0x29	; 41
    4e34:	4d 91       	ld	r20, X+
    4e36:	5d 91       	ld	r21, X+
    4e38:	6d 91       	ld	r22, X+
    4e3a:	7c 91       	ld	r23, X
    4e3c:	9c 97       	sbiw	r26, 0x2c	; 44
    4e3e:	45 a7       	std	Z+45, r20	; 0x2d
    4e40:	56 a7       	std	Z+46, r21	; 0x2e
    4e42:	67 a7       	std	Z+47, r22	; 0x2f
    4e44:	70 ab       	std	Z+48, r23	; 0x30
    4e46:	9d 96       	adiw	r26, 0x2d	; 45
    4e48:	4d 91       	ld	r20, X+
    4e4a:	5d 91       	ld	r21, X+
    4e4c:	6d 91       	ld	r22, X+
    4e4e:	7c 91       	ld	r23, X
    4e50:	d0 97       	sbiw	r26, 0x30	; 48
    4e52:	41 ab       	std	Z+49, r20	; 0x31
    4e54:	52 ab       	std	Z+50, r21	; 0x32
    4e56:	63 ab       	std	Z+51, r22	; 0x33
    4e58:	74 ab       	std	Z+52, r23	; 0x34
    4e5a:	d1 96       	adiw	r26, 0x31	; 49
    4e5c:	4d 91       	ld	r20, X+
    4e5e:	5d 91       	ld	r21, X+
    4e60:	6d 91       	ld	r22, X+
    4e62:	7c 91       	ld	r23, X
    4e64:	d4 97       	sbiw	r26, 0x34	; 52
    4e66:	45 ab       	std	Z+53, r20	; 0x35
    4e68:	56 ab       	std	Z+54, r21	; 0x36
    4e6a:	67 ab       	std	Z+55, r22	; 0x37
    4e6c:	70 af       	std	Z+56, r23	; 0x38
    4e6e:	d5 96       	adiw	r26, 0x35	; 53
    4e70:	4d 91       	ld	r20, X+
    4e72:	5d 91       	ld	r21, X+
    4e74:	6d 91       	ld	r22, X+
    4e76:	7c 91       	ld	r23, X
    4e78:	d8 97       	sbiw	r26, 0x38	; 56
    4e7a:	41 af       	std	Z+57, r20	; 0x39
    4e7c:	52 af       	std	Z+58, r21	; 0x3a
    4e7e:	63 af       	std	Z+59, r22	; 0x3b
    4e80:	74 af       	std	Z+60, r23	; 0x3c
    4e82:	ef 01       	movw	r28, r30
    4e84:	ed 96       	adiw	r28, 0x3d	; 61
    4e86:	d9 96       	adiw	r26, 0x39	; 57
    4e88:	4d 91       	ld	r20, X+
    4e8a:	5d 91       	ld	r21, X+
    4e8c:	6d 91       	ld	r22, X+
    4e8e:	7c 91       	ld	r23, X
    4e90:	dc 97       	sbiw	r26, 0x3c	; 60
    4e92:	48 83       	st	Y, r20
    4e94:	59 83       	std	Y+1, r21	; 0x01
    4e96:	6a 83       	std	Y+2, r22	; 0x02
    4e98:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4e9a:	ef 5b       	subi	r30, 0xBF	; 191
    4e9c:	ff 4f       	sbci	r31, 0xFF	; 255
    4e9e:	dd 96       	adiw	r26, 0x3d	; 61
    4ea0:	4d 91       	ld	r20, X+
    4ea2:	5d 91       	ld	r21, X+
    4ea4:	6d 91       	ld	r22, X+
    4ea6:	7c 91       	ld	r23, X
    4ea8:	40 83       	st	Z, r20
    4eaa:	51 83       	std	Z+1, r21	; 0x01
    4eac:	62 83       	std	Z+2, r22	; 0x02
    4eae:	73 83       	std	Z+3, r23	; 0x03
		decode (message, XVEcefCms);
		decode (message, YVEcefCms);
		decode (message, ZVEcefCms);
		decode (message, PressureMillibars);
	}
}
    4eb0:	df 91       	pop	r29
    4eb2:	cf 91       	pop	r28
    4eb4:	08 95       	ret

00004eb6 <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>:

SensorDataMessage* SensorDataMessage::buildMessageSt(byte *message)
{
    4eb6:	0f 93       	push	r16
    4eb8:	1f 93       	push	r17
    4eba:	cf 93       	push	r28
    4ebc:	df 93       	push	r29
    4ebe:	8c 01       	movw	r16, r24
	SensorDataMessage *msg = new SensorDataMessage();
    4ec0:	85 e4       	ldi	r24, 0x45	; 69
    4ec2:	90 e0       	ldi	r25, 0x00	; 0
    4ec4:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    4ec8:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    4eca:	84 e0       	ldi	r24, 0x04	; 4
    4ecc:	8a 83       	std	Y+2, r24	; 0x02
    4ece:	81 e4       	ldi	r24, 0x41	; 65
    4ed0:	90 e0       	ldi	r25, 0x00	; 0
    4ed2:	9c 83       	std	Y+4, r25	; 0x04
    4ed4:	8b 83       	std	Y+3, r24	; 0x03
					YEcefCm(0),
					ZEcefCm(0),
					XVEcefCms(0),
					YVEcefCms(0),
					ZVEcefCms(0),
					PressureMillibars(0)
    4ed6:	8c e5       	ldi	r24, 0x5C	; 92
    4ed8:	92 e0       	ldi	r25, 0x02	; 2
    4eda:	99 83       	std	Y+1, r25	; 0x01
    4edc:	88 83       	st	Y, r24
    4ede:	1d 82       	std	Y+5, r1	; 0x05
    4ee0:	1e 82       	std	Y+6, r1	; 0x06
    4ee2:	1f 82       	std	Y+7, r1	; 0x07
    4ee4:	18 86       	std	Y+8, r1	; 0x08
    4ee6:	19 86       	std	Y+9, r1	; 0x09
    4ee8:	1a 86       	std	Y+10, r1	; 0x0a
    4eea:	1b 86       	std	Y+11, r1	; 0x0b
    4eec:	1c 86       	std	Y+12, r1	; 0x0c
    4eee:	1d 86       	std	Y+13, r1	; 0x0d
    4ef0:	1e 86       	std	Y+14, r1	; 0x0e
    4ef2:	1f 86       	std	Y+15, r1	; 0x0f
    4ef4:	18 8a       	std	Y+16, r1	; 0x10
    4ef6:	19 8a       	std	Y+17, r1	; 0x11
    4ef8:	1a 8a       	std	Y+18, r1	; 0x12
    4efa:	1b 8a       	std	Y+19, r1	; 0x13
    4efc:	1c 8a       	std	Y+20, r1	; 0x14
    4efe:	1d 8a       	std	Y+21, r1	; 0x15
    4f00:	1e 8a       	std	Y+22, r1	; 0x16
    4f02:	1f 8a       	std	Y+23, r1	; 0x17
    4f04:	18 8e       	std	Y+24, r1	; 0x18
    4f06:	19 8e       	std	Y+25, r1	; 0x19
    4f08:	1a 8e       	std	Y+26, r1	; 0x1a
    4f0a:	1b 8e       	std	Y+27, r1	; 0x1b
    4f0c:	1c 8e       	std	Y+28, r1	; 0x1c
    4f0e:	1d 8e       	std	Y+29, r1	; 0x1d
    4f10:	1e 8e       	std	Y+30, r1	; 0x1e
    4f12:	1f 8e       	std	Y+31, r1	; 0x1f
    4f14:	18 a2       	std	Y+32, r1	; 0x20
    4f16:	19 a2       	std	Y+33, r1	; 0x21
    4f18:	1a a2       	std	Y+34, r1	; 0x22
    4f1a:	1b a2       	std	Y+35, r1	; 0x23
    4f1c:	1c a2       	std	Y+36, r1	; 0x24
    4f1e:	1d a2       	std	Y+37, r1	; 0x25
    4f20:	1e a2       	std	Y+38, r1	; 0x26
    4f22:	1f a2       	std	Y+39, r1	; 0x27
    4f24:	18 a6       	std	Y+40, r1	; 0x28
    4f26:	19 a6       	std	Y+41, r1	; 0x29
    4f28:	1a a6       	std	Y+42, r1	; 0x2a
    4f2a:	1b a6       	std	Y+43, r1	; 0x2b
    4f2c:	1c a6       	std	Y+44, r1	; 0x2c
    4f2e:	1d a6       	std	Y+45, r1	; 0x2d
    4f30:	1e a6       	std	Y+46, r1	; 0x2e
    4f32:	1f a6       	std	Y+47, r1	; 0x2f
    4f34:	18 aa       	std	Y+48, r1	; 0x30
    4f36:	19 aa       	std	Y+49, r1	; 0x31
    4f38:	1a aa       	std	Y+50, r1	; 0x32
    4f3a:	1b aa       	std	Y+51, r1	; 0x33
    4f3c:	1c aa       	std	Y+52, r1	; 0x34
    4f3e:	1d aa       	std	Y+53, r1	; 0x35
    4f40:	1e aa       	std	Y+54, r1	; 0x36
    4f42:	1f aa       	std	Y+55, r1	; 0x37
    4f44:	18 ae       	std	Y+56, r1	; 0x38
    4f46:	19 ae       	std	Y+57, r1	; 0x39
    4f48:	1a ae       	std	Y+58, r1	; 0x3a
    4f4a:	1b ae       	std	Y+59, r1	; 0x3b
    4f4c:	1c ae       	std	Y+60, r1	; 0x3c
    4f4e:	fe 01       	movw	r30, r28
    4f50:	fd 96       	adiw	r30, 0x3d	; 61
    4f52:	10 82       	st	Z, r1
    4f54:	11 82       	std	Z+1, r1	; 0x01
    4f56:	12 82       	std	Z+2, r1	; 0x02
    4f58:	13 82       	std	Z+3, r1	; 0x03
    4f5a:	34 96       	adiw	r30, 0x04	; 4
    4f5c:	10 82       	st	Z, r1
    4f5e:	11 82       	std	Z+1, r1	; 0x01
    4f60:	12 82       	std	Z+2, r1	; 0x02
    4f62:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    4f64:	b8 01       	movw	r22, r16
    4f66:	ce 01       	movw	r24, r28
    4f68:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
	
	return msg;
    4f6c:	ce 01       	movw	r24, r28
    4f6e:	df 91       	pop	r29
    4f70:	cf 91       	pop	r28
    4f72:	1f 91       	pop	r17
    4f74:	0f 91       	pop	r16
    4f76:	08 95       	ret

00004f78 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4f78:	20 e5       	ldi	r18, 0x50	; 80
    4f7a:	32 e0       	ldi	r19, 0x02	; 2
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	31 83       	std	Z+1, r19	; 0x01
    4f80:	20 83       	st	Z, r18
    4f82:	08 95       	ret

00004f84 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>:
    4f84:	20 e5       	ldi	r18, 0x50	; 80
    4f86:	32 e0       	ldi	r19, 0x02	; 2
    4f88:	fc 01       	movw	r30, r24
    4f8a:	31 83       	std	Z+1, r19	; 0x01
    4f8c:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SimpleTelemetryMessage() {}
    4f8e:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    4f92:	08 95       	ret

00004f94 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SimpleTelemetryMessage::getBytes()
{
    4f94:	cf 93       	push	r28
    4f96:	df 93       	push	r29
    4f98:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4f9a:	89 e7       	ldi	r24, 0x79	; 121
    4f9c:	90 e0       	ldi	r25, 0x00	; 0
    4f9e:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    4fa2:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    4fa6:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4fa8:	8d 81       	ldd	r24, Y+5	; 0x05
    4faa:	9e 81       	ldd	r25, Y+6	; 0x06
    4fac:	af 81       	ldd	r26, Y+7	; 0x07
    4fae:	b8 85       	ldd	r27, Y+8	; 0x08
    4fb0:	81 83       	std	Z+1, r24	; 0x01
    4fb2:	92 83       	std	Z+2, r25	; 0x02
    4fb4:	a3 83       	std	Z+3, r26	; 0x03
    4fb6:	b4 83       	std	Z+4, r27	; 0x04
    4fb8:	89 85       	ldd	r24, Y+9	; 0x09
    4fba:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fbc:	ab 85       	ldd	r26, Y+11	; 0x0b
    4fbe:	bc 85       	ldd	r27, Y+12	; 0x0c
    4fc0:	85 83       	std	Z+5, r24	; 0x05
    4fc2:	96 83       	std	Z+6, r25	; 0x06
    4fc4:	a7 83       	std	Z+7, r26	; 0x07
    4fc6:	b0 87       	std	Z+8, r27	; 0x08
    4fc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fca:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fcc:	af 85       	ldd	r26, Y+15	; 0x0f
    4fce:	b8 89       	ldd	r27, Y+16	; 0x10
    4fd0:	81 87       	std	Z+9, r24	; 0x09
    4fd2:	92 87       	std	Z+10, r25	; 0x0a
    4fd4:	a3 87       	std	Z+11, r26	; 0x0b
    4fd6:	b4 87       	std	Z+12, r27	; 0x0c
    4fd8:	89 89       	ldd	r24, Y+17	; 0x11
    4fda:	9a 89       	ldd	r25, Y+18	; 0x12
    4fdc:	ab 89       	ldd	r26, Y+19	; 0x13
    4fde:	bc 89       	ldd	r27, Y+20	; 0x14
    4fe0:	85 87       	std	Z+13, r24	; 0x0d
    4fe2:	96 87       	std	Z+14, r25	; 0x0e
    4fe4:	a7 87       	std	Z+15, r26	; 0x0f
    4fe6:	b0 8b       	std	Z+16, r27	; 0x10
    4fe8:	8d 89       	ldd	r24, Y+21	; 0x15
    4fea:	9e 89       	ldd	r25, Y+22	; 0x16
    4fec:	af 89       	ldd	r26, Y+23	; 0x17
    4fee:	b8 8d       	ldd	r27, Y+24	; 0x18
    4ff0:	81 8b       	std	Z+17, r24	; 0x11
    4ff2:	92 8b       	std	Z+18, r25	; 0x12
    4ff4:	a3 8b       	std	Z+19, r26	; 0x13
    4ff6:	b4 8b       	std	Z+20, r27	; 0x14
    4ff8:	89 8d       	ldd	r24, Y+25	; 0x19
    4ffa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4ffc:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4ffe:	bc 8d       	ldd	r27, Y+28	; 0x1c
    5000:	85 8b       	std	Z+21, r24	; 0x15
    5002:	96 8b       	std	Z+22, r25	; 0x16
    5004:	a7 8b       	std	Z+23, r26	; 0x17
    5006:	b0 8f       	std	Z+24, r27	; 0x18
    5008:	8d 8d       	ldd	r24, Y+29	; 0x1d
    500a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    500c:	af 8d       	ldd	r26, Y+31	; 0x1f
    500e:	b8 a1       	ldd	r27, Y+32	; 0x20
    5010:	81 8f       	std	Z+25, r24	; 0x19
    5012:	92 8f       	std	Z+26, r25	; 0x1a
    5014:	a3 8f       	std	Z+27, r26	; 0x1b
    5016:	b4 8f       	std	Z+28, r27	; 0x1c
    5018:	89 a1       	ldd	r24, Y+33	; 0x21
    501a:	9a a1       	ldd	r25, Y+34	; 0x22
    501c:	ab a1       	ldd	r26, Y+35	; 0x23
    501e:	bc a1       	ldd	r27, Y+36	; 0x24
    5020:	85 8f       	std	Z+29, r24	; 0x1d
    5022:	96 8f       	std	Z+30, r25	; 0x1e
    5024:	a7 8f       	std	Z+31, r26	; 0x1f
    5026:	b0 a3       	std	Z+32, r27	; 0x20
    5028:	8d a1       	ldd	r24, Y+37	; 0x25
    502a:	9e a1       	ldd	r25, Y+38	; 0x26
    502c:	af a1       	ldd	r26, Y+39	; 0x27
    502e:	b8 a5       	ldd	r27, Y+40	; 0x28
    5030:	81 a3       	std	Z+33, r24	; 0x21
    5032:	92 a3       	std	Z+34, r25	; 0x22
    5034:	a3 a3       	std	Z+35, r26	; 0x23
    5036:	b4 a3       	std	Z+36, r27	; 0x24
    5038:	89 a5       	ldd	r24, Y+41	; 0x29
    503a:	9a a5       	ldd	r25, Y+42	; 0x2a
    503c:	ab a5       	ldd	r26, Y+43	; 0x2b
    503e:	bc a5       	ldd	r27, Y+44	; 0x2c
    5040:	85 a3       	std	Z+37, r24	; 0x25
    5042:	96 a3       	std	Z+38, r25	; 0x26
    5044:	a7 a3       	std	Z+39, r26	; 0x27
    5046:	b0 a7       	std	Z+40, r27	; 0x28
    5048:	8d a5       	ldd	r24, Y+45	; 0x2d
    504a:	9e a5       	ldd	r25, Y+46	; 0x2e
    504c:	af a5       	ldd	r26, Y+47	; 0x2f
    504e:	b8 a9       	ldd	r27, Y+48	; 0x30
    5050:	81 a7       	std	Z+41, r24	; 0x29
    5052:	92 a7       	std	Z+42, r25	; 0x2a
    5054:	a3 a7       	std	Z+43, r26	; 0x2b
    5056:	b4 a7       	std	Z+44, r27	; 0x2c
    5058:	89 a9       	ldd	r24, Y+49	; 0x31
    505a:	9a a9       	ldd	r25, Y+50	; 0x32
    505c:	ab a9       	ldd	r26, Y+51	; 0x33
    505e:	bc a9       	ldd	r27, Y+52	; 0x34
    5060:	85 a7       	std	Z+45, r24	; 0x2d
    5062:	96 a7       	std	Z+46, r25	; 0x2e
    5064:	a7 a7       	std	Z+47, r26	; 0x2f
    5066:	b0 ab       	std	Z+48, r27	; 0x30
    5068:	8d a9       	ldd	r24, Y+53	; 0x35
    506a:	9e a9       	ldd	r25, Y+54	; 0x36
    506c:	af a9       	ldd	r26, Y+55	; 0x37
    506e:	b8 ad       	ldd	r27, Y+56	; 0x38
    5070:	81 ab       	std	Z+49, r24	; 0x31
    5072:	92 ab       	std	Z+50, r25	; 0x32
    5074:	a3 ab       	std	Z+51, r26	; 0x33
    5076:	b4 ab       	std	Z+52, r27	; 0x34
    5078:	89 ad       	ldd	r24, Y+57	; 0x39
    507a:	9a ad       	ldd	r25, Y+58	; 0x3a
    507c:	ab ad       	ldd	r26, Y+59	; 0x3b
    507e:	bc ad       	ldd	r27, Y+60	; 0x3c
    5080:	85 ab       	std	Z+53, r24	; 0x35
    5082:	96 ab       	std	Z+54, r25	; 0x36
    5084:	a7 ab       	std	Z+55, r26	; 0x37
    5086:	b0 af       	std	Z+56, r27	; 0x38
    5088:	de 01       	movw	r26, r28
    508a:	dd 96       	adiw	r26, 0x3d	; 61
    508c:	8d 91       	ld	r24, X+
    508e:	9d 91       	ld	r25, X+
    5090:	0d 90       	ld	r0, X+
    5092:	bc 91       	ld	r27, X
    5094:	a0 2d       	mov	r26, r0
    5096:	81 af       	std	Z+57, r24	; 0x39
    5098:	92 af       	std	Z+58, r25	; 0x3a
    509a:	a3 af       	std	Z+59, r26	; 0x3b
    509c:	b4 af       	std	Z+60, r27	; 0x3c
    509e:	9f 01       	movw	r18, r30
    50a0:	23 5c       	subi	r18, 0xC3	; 195
    50a2:	3f 4f       	sbci	r19, 0xFF	; 255
    50a4:	de 01       	movw	r26, r28
    50a6:	af 5b       	subi	r26, 0xBF	; 191
    50a8:	bf 4f       	sbci	r27, 0xFF	; 255
    50aa:	4d 91       	ld	r20, X+
    50ac:	5d 91       	ld	r21, X+
    50ae:	6d 91       	ld	r22, X+
    50b0:	7c 91       	ld	r23, X
    50b2:	d9 01       	movw	r26, r18
    50b4:	4d 93       	st	X+, r20
    50b6:	5d 93       	st	X+, r21
    50b8:	6d 93       	st	X+, r22
    50ba:	7c 93       	st	X, r23
    50bc:	13 97       	sbiw	r26, 0x03	; 3
    50be:	2c 5f       	subi	r18, 0xFC	; 252
    50c0:	3f 4f       	sbci	r19, 0xFF	; 255
    50c2:	de 01       	movw	r26, r28
    50c4:	ab 5b       	subi	r26, 0xBB	; 187
    50c6:	bf 4f       	sbci	r27, 0xFF	; 255
    50c8:	4d 91       	ld	r20, X+
    50ca:	5d 91       	ld	r21, X+
    50cc:	6d 91       	ld	r22, X+
    50ce:	7c 91       	ld	r23, X
    50d0:	d9 01       	movw	r26, r18
    50d2:	4d 93       	st	X+, r20
    50d4:	5d 93       	st	X+, r21
    50d6:	6d 93       	st	X+, r22
    50d8:	7c 93       	st	X, r23
    50da:	13 97       	sbiw	r26, 0x03	; 3
    50dc:	2c 5f       	subi	r18, 0xFC	; 252
    50de:	3f 4f       	sbci	r19, 0xFF	; 255
    50e0:	de 01       	movw	r26, r28
    50e2:	a7 5b       	subi	r26, 0xB7	; 183
    50e4:	bf 4f       	sbci	r27, 0xFF	; 255
    50e6:	4d 91       	ld	r20, X+
    50e8:	5d 91       	ld	r21, X+
    50ea:	6d 91       	ld	r22, X+
    50ec:	7c 91       	ld	r23, X
    50ee:	d9 01       	movw	r26, r18
    50f0:	4d 93       	st	X+, r20
    50f2:	5d 93       	st	X+, r21
    50f4:	6d 93       	st	X+, r22
    50f6:	7c 93       	st	X, r23
    50f8:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    50fa:	2c 5f       	subi	r18, 0xFC	; 252
    50fc:	3f 4f       	sbci	r19, 0xFF	; 255
    50fe:	de 01       	movw	r26, r28
    5100:	a3 5b       	subi	r26, 0xB3	; 179
    5102:	bf 4f       	sbci	r27, 0xFF	; 255
    5104:	4d 91       	ld	r20, X+
    5106:	5d 91       	ld	r21, X+
    5108:	6d 91       	ld	r22, X+
    510a:	7c 91       	ld	r23, X
    510c:	d9 01       	movw	r26, r18
    510e:	4d 93       	st	X+, r20
    5110:	5d 93       	st	X+, r21
    5112:	6d 93       	st	X+, r22
    5114:	7c 93       	st	X, r23
    5116:	13 97       	sbiw	r26, 0x03	; 3
    5118:	2c 5f       	subi	r18, 0xFC	; 252
    511a:	3f 4f       	sbci	r19, 0xFF	; 255
    511c:	de 01       	movw	r26, r28
    511e:	af 5a       	subi	r26, 0xAF	; 175
    5120:	bf 4f       	sbci	r27, 0xFF	; 255
    5122:	4d 91       	ld	r20, X+
    5124:	5d 91       	ld	r21, X+
    5126:	6d 91       	ld	r22, X+
    5128:	7c 91       	ld	r23, X
    512a:	d9 01       	movw	r26, r18
    512c:	4d 93       	st	X+, r20
    512e:	5d 93       	st	X+, r21
    5130:	6d 93       	st	X+, r22
    5132:	7c 93       	st	X, r23
    5134:	13 97       	sbiw	r26, 0x03	; 3
    5136:	2c 5f       	subi	r18, 0xFC	; 252
    5138:	3f 4f       	sbci	r19, 0xFF	; 255
    513a:	de 01       	movw	r26, r28
    513c:	ab 5a       	subi	r26, 0xAB	; 171
    513e:	bf 4f       	sbci	r27, 0xFF	; 255
    5140:	4d 91       	ld	r20, X+
    5142:	5d 91       	ld	r21, X+
    5144:	6d 91       	ld	r22, X+
    5146:	7c 91       	ld	r23, X
    5148:	d9 01       	movw	r26, r18
    514a:	4d 93       	st	X+, r20
    514c:	5d 93       	st	X+, r21
    514e:	6d 93       	st	X+, r22
    5150:	7c 93       	st	X, r23
    5152:	13 97       	sbiw	r26, 0x03	; 3
    5154:	2c 5f       	subi	r18, 0xFC	; 252
    5156:	3f 4f       	sbci	r19, 0xFF	; 255
    5158:	de 01       	movw	r26, r28
    515a:	a7 5a       	subi	r26, 0xA7	; 167
    515c:	bf 4f       	sbci	r27, 0xFF	; 255
    515e:	4d 91       	ld	r20, X+
    5160:	5d 91       	ld	r21, X+
    5162:	6d 91       	ld	r22, X+
    5164:	7c 91       	ld	r23, X
    5166:	d9 01       	movw	r26, r18
    5168:	4d 93       	st	X+, r20
    516a:	5d 93       	st	X+, r21
    516c:	6d 93       	st	X+, r22
    516e:	7c 93       	st	X, r23
    5170:	13 97       	sbiw	r26, 0x03	; 3
    5172:	2c 5f       	subi	r18, 0xFC	; 252
    5174:	3f 4f       	sbci	r19, 0xFF	; 255
    5176:	de 01       	movw	r26, r28
    5178:	a3 5a       	subi	r26, 0xA3	; 163
    517a:	bf 4f       	sbci	r27, 0xFF	; 255
    517c:	4d 91       	ld	r20, X+
    517e:	5d 91       	ld	r21, X+
    5180:	6d 91       	ld	r22, X+
    5182:	7c 91       	ld	r23, X
    5184:	d9 01       	movw	r26, r18
    5186:	4d 93       	st	X+, r20
    5188:	5d 93       	st	X+, r21
    518a:	6d 93       	st	X+, r22
    518c:	7c 93       	st	X, r23
    518e:	13 97       	sbiw	r26, 0x03	; 3
    5190:	2c 5f       	subi	r18, 0xFC	; 252
    5192:	3f 4f       	sbci	r19, 0xFF	; 255
    5194:	de 01       	movw	r26, r28
    5196:	af 59       	subi	r26, 0x9F	; 159
    5198:	bf 4f       	sbci	r27, 0xFF	; 255
    519a:	4d 91       	ld	r20, X+
    519c:	5d 91       	ld	r21, X+
    519e:	6d 91       	ld	r22, X+
    51a0:	7c 91       	ld	r23, X
    51a2:	d9 01       	movw	r26, r18
    51a4:	4d 93       	st	X+, r20
    51a6:	5d 93       	st	X+, r21
    51a8:	6d 93       	st	X+, r22
    51aa:	7c 93       	st	X, r23
    51ac:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    51ae:	2c 5f       	subi	r18, 0xFC	; 252
    51b0:	3f 4f       	sbci	r19, 0xFF	; 255
    51b2:	de 01       	movw	r26, r28
    51b4:	ab 59       	subi	r26, 0x9B	; 155
    51b6:	bf 4f       	sbci	r27, 0xFF	; 255
    51b8:	4d 91       	ld	r20, X+
    51ba:	5d 91       	ld	r21, X+
    51bc:	6d 91       	ld	r22, X+
    51be:	7c 91       	ld	r23, X
    51c0:	d9 01       	movw	r26, r18
    51c2:	4d 93       	st	X+, r20
    51c4:	5d 93       	st	X+, r21
    51c6:	6d 93       	st	X+, r22
    51c8:	7c 93       	st	X, r23
    51ca:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    51cc:	2c 5f       	subi	r18, 0xFC	; 252
    51ce:	3f 4f       	sbci	r19, 0xFF	; 255
    51d0:	de 01       	movw	r26, r28
    51d2:	a7 59       	subi	r26, 0x97	; 151
    51d4:	bf 4f       	sbci	r27, 0xFF	; 255
    51d6:	4d 91       	ld	r20, X+
    51d8:	5d 91       	ld	r21, X+
    51da:	6d 91       	ld	r22, X+
    51dc:	7c 91       	ld	r23, X
    51de:	d9 01       	movw	r26, r18
    51e0:	4d 93       	st	X+, r20
    51e2:	5d 93       	st	X+, r21
    51e4:	6d 93       	st	X+, r22
    51e6:	7c 93       	st	X, r23
    51e8:	13 97       	sbiw	r26, 0x03	; 3
    51ea:	2c 5f       	subi	r18, 0xFC	; 252
    51ec:	3f 4f       	sbci	r19, 0xFF	; 255
    51ee:	de 01       	movw	r26, r28
    51f0:	a3 59       	subi	r26, 0x93	; 147
    51f2:	bf 4f       	sbci	r27, 0xFF	; 255
    51f4:	4d 91       	ld	r20, X+
    51f6:	5d 91       	ld	r21, X+
    51f8:	6d 91       	ld	r22, X+
    51fa:	7c 91       	ld	r23, X
    51fc:	d9 01       	movw	r26, r18
    51fe:	4d 93       	st	X+, r20
    5200:	5d 93       	st	X+, r21
    5202:	6d 93       	st	X+, r22
    5204:	7c 93       	st	X, r23
    5206:	13 97       	sbiw	r26, 0x03	; 3
    5208:	2c 5f       	subi	r18, 0xFC	; 252
    520a:	3f 4f       	sbci	r19, 0xFF	; 255
    520c:	ce 01       	movw	r24, r28
    520e:	8f 58       	subi	r24, 0x8F	; 143
    5210:	9f 4f       	sbci	r25, 0xFF	; 255
    5212:	dc 01       	movw	r26, r24
    5214:	4d 91       	ld	r20, X+
    5216:	5d 91       	ld	r21, X+
    5218:	6d 91       	ld	r22, X+
    521a:	7c 91       	ld	r23, X
    521c:	d9 01       	movw	r26, r18
    521e:	4d 93       	st	X+, r20
    5220:	5d 93       	st	X+, r21
    5222:	6d 93       	st	X+, r22
    5224:	7c 93       	st	X, r23
    5226:	13 97       	sbiw	r26, 0x03	; 3
    5228:	2c 5f       	subi	r18, 0xFC	; 252
    522a:	3f 4f       	sbci	r19, 0xFF	; 255
    522c:	04 96       	adiw	r24, 0x04	; 4
    522e:	dc 01       	movw	r26, r24
    5230:	4d 91       	ld	r20, X+
    5232:	5d 91       	ld	r21, X+
    5234:	6d 91       	ld	r22, X+
    5236:	7c 91       	ld	r23, X
    5238:	d9 01       	movw	r26, r18
    523a:	4d 93       	st	X+, r20
    523c:	5d 93       	st	X+, r21
    523e:	6d 93       	st	X+, r22
    5240:	7c 93       	st	X, r23
    5242:	13 97       	sbiw	r26, 0x03	; 3
    5244:	14 96       	adiw	r26, 0x04	; 4
    5246:	c7 58       	subi	r28, 0x87	; 135
    5248:	df 4f       	sbci	r29, 0xFF	; 255
    524a:	48 81       	ld	r20, Y
    524c:	59 81       	ldd	r21, Y+1	; 0x01
    524e:	6a 81       	ldd	r22, Y+2	; 0x02
    5250:	7b 81       	ldd	r23, Y+3	; 0x03
    5252:	4d 93       	st	X+, r20
    5254:	5d 93       	st	X+, r21
    5256:	6d 93       	st	X+, r22
    5258:	7c 93       	st	X, r23
    525a:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
	
	return msg;
}
    525c:	cf 01       	movw	r24, r30
    525e:	df 91       	pop	r29
    5260:	cf 91       	pop	r28
    5262:	08 95       	ret

00005264 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>:

void SimpleTelemetryMessage::buildMessage(byte *message)
{
    5264:	cf 93       	push	r28
    5266:	df 93       	push	r29
    5268:	fc 01       	movw	r30, r24
    526a:	db 01       	movw	r26, r22
	if (message != NULL)
    526c:	10 97       	sbiw	r26, 0x00	; 0
    526e:	09 f4       	brne	.+2      	; 0x5272 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0xe>
    5270:	5e c1       	rjmp	.+700    	; 0x552e <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0x2ca>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    5272:	8c 91       	ld	r24, X
    5274:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5276:	11 96       	adiw	r26, 0x01	; 1
    5278:	4d 91       	ld	r20, X+
    527a:	5d 91       	ld	r21, X+
    527c:	6d 91       	ld	r22, X+
    527e:	7c 91       	ld	r23, X
    5280:	14 97       	sbiw	r26, 0x04	; 4
    5282:	45 83       	std	Z+5, r20	; 0x05
    5284:	56 83       	std	Z+6, r21	; 0x06
    5286:	67 83       	std	Z+7, r22	; 0x07
    5288:	70 87       	std	Z+8, r23	; 0x08
    528a:	15 96       	adiw	r26, 0x05	; 5
    528c:	4d 91       	ld	r20, X+
    528e:	5d 91       	ld	r21, X+
    5290:	6d 91       	ld	r22, X+
    5292:	7c 91       	ld	r23, X
    5294:	18 97       	sbiw	r26, 0x08	; 8
    5296:	41 87       	std	Z+9, r20	; 0x09
    5298:	52 87       	std	Z+10, r21	; 0x0a
    529a:	63 87       	std	Z+11, r22	; 0x0b
    529c:	74 87       	std	Z+12, r23	; 0x0c
    529e:	19 96       	adiw	r26, 0x09	; 9
    52a0:	4d 91       	ld	r20, X+
    52a2:	5d 91       	ld	r21, X+
    52a4:	6d 91       	ld	r22, X+
    52a6:	7c 91       	ld	r23, X
    52a8:	1c 97       	sbiw	r26, 0x0c	; 12
    52aa:	45 87       	std	Z+13, r20	; 0x0d
    52ac:	56 87       	std	Z+14, r21	; 0x0e
    52ae:	67 87       	std	Z+15, r22	; 0x0f
    52b0:	70 8b       	std	Z+16, r23	; 0x10
    52b2:	1d 96       	adiw	r26, 0x0d	; 13
    52b4:	4d 91       	ld	r20, X+
    52b6:	5d 91       	ld	r21, X+
    52b8:	6d 91       	ld	r22, X+
    52ba:	7c 91       	ld	r23, X
    52bc:	50 97       	sbiw	r26, 0x10	; 16
    52be:	41 8b       	std	Z+17, r20	; 0x11
    52c0:	52 8b       	std	Z+18, r21	; 0x12
    52c2:	63 8b       	std	Z+19, r22	; 0x13
    52c4:	74 8b       	std	Z+20, r23	; 0x14
    52c6:	51 96       	adiw	r26, 0x11	; 17
    52c8:	4d 91       	ld	r20, X+
    52ca:	5d 91       	ld	r21, X+
    52cc:	6d 91       	ld	r22, X+
    52ce:	7c 91       	ld	r23, X
    52d0:	54 97       	sbiw	r26, 0x14	; 20
    52d2:	45 8b       	std	Z+21, r20	; 0x15
    52d4:	56 8b       	std	Z+22, r21	; 0x16
    52d6:	67 8b       	std	Z+23, r22	; 0x17
    52d8:	70 8f       	std	Z+24, r23	; 0x18
    52da:	55 96       	adiw	r26, 0x15	; 21
    52dc:	4d 91       	ld	r20, X+
    52de:	5d 91       	ld	r21, X+
    52e0:	6d 91       	ld	r22, X+
    52e2:	7c 91       	ld	r23, X
    52e4:	58 97       	sbiw	r26, 0x18	; 24
    52e6:	41 8f       	std	Z+25, r20	; 0x19
    52e8:	52 8f       	std	Z+26, r21	; 0x1a
    52ea:	63 8f       	std	Z+27, r22	; 0x1b
    52ec:	74 8f       	std	Z+28, r23	; 0x1c
    52ee:	59 96       	adiw	r26, 0x19	; 25
    52f0:	4d 91       	ld	r20, X+
    52f2:	5d 91       	ld	r21, X+
    52f4:	6d 91       	ld	r22, X+
    52f6:	7c 91       	ld	r23, X
    52f8:	5c 97       	sbiw	r26, 0x1c	; 28
    52fa:	45 8f       	std	Z+29, r20	; 0x1d
    52fc:	56 8f       	std	Z+30, r21	; 0x1e
    52fe:	67 8f       	std	Z+31, r22	; 0x1f
    5300:	70 a3       	std	Z+32, r23	; 0x20
    5302:	5d 96       	adiw	r26, 0x1d	; 29
    5304:	4d 91       	ld	r20, X+
    5306:	5d 91       	ld	r21, X+
    5308:	6d 91       	ld	r22, X+
    530a:	7c 91       	ld	r23, X
    530c:	90 97       	sbiw	r26, 0x20	; 32
    530e:	41 a3       	std	Z+33, r20	; 0x21
    5310:	52 a3       	std	Z+34, r21	; 0x22
    5312:	63 a3       	std	Z+35, r22	; 0x23
    5314:	74 a3       	std	Z+36, r23	; 0x24
    5316:	91 96       	adiw	r26, 0x21	; 33
    5318:	4d 91       	ld	r20, X+
    531a:	5d 91       	ld	r21, X+
    531c:	6d 91       	ld	r22, X+
    531e:	7c 91       	ld	r23, X
    5320:	94 97       	sbiw	r26, 0x24	; 36
    5322:	45 a3       	std	Z+37, r20	; 0x25
    5324:	56 a3       	std	Z+38, r21	; 0x26
    5326:	67 a3       	std	Z+39, r22	; 0x27
    5328:	70 a7       	std	Z+40, r23	; 0x28
    532a:	95 96       	adiw	r26, 0x25	; 37
    532c:	4d 91       	ld	r20, X+
    532e:	5d 91       	ld	r21, X+
    5330:	6d 91       	ld	r22, X+
    5332:	7c 91       	ld	r23, X
    5334:	98 97       	sbiw	r26, 0x28	; 40
    5336:	41 a7       	std	Z+41, r20	; 0x29
    5338:	52 a7       	std	Z+42, r21	; 0x2a
    533a:	63 a7       	std	Z+43, r22	; 0x2b
    533c:	74 a7       	std	Z+44, r23	; 0x2c
    533e:	99 96       	adiw	r26, 0x29	; 41
    5340:	4d 91       	ld	r20, X+
    5342:	5d 91       	ld	r21, X+
    5344:	6d 91       	ld	r22, X+
    5346:	7c 91       	ld	r23, X
    5348:	9c 97       	sbiw	r26, 0x2c	; 44
    534a:	45 a7       	std	Z+45, r20	; 0x2d
    534c:	56 a7       	std	Z+46, r21	; 0x2e
    534e:	67 a7       	std	Z+47, r22	; 0x2f
    5350:	70 ab       	std	Z+48, r23	; 0x30
    5352:	9d 96       	adiw	r26, 0x2d	; 45
    5354:	4d 91       	ld	r20, X+
    5356:	5d 91       	ld	r21, X+
    5358:	6d 91       	ld	r22, X+
    535a:	7c 91       	ld	r23, X
    535c:	d0 97       	sbiw	r26, 0x30	; 48
    535e:	41 ab       	std	Z+49, r20	; 0x31
    5360:	52 ab       	std	Z+50, r21	; 0x32
    5362:	63 ab       	std	Z+51, r22	; 0x33
    5364:	74 ab       	std	Z+52, r23	; 0x34
    5366:	d1 96       	adiw	r26, 0x31	; 49
    5368:	4d 91       	ld	r20, X+
    536a:	5d 91       	ld	r21, X+
    536c:	6d 91       	ld	r22, X+
    536e:	7c 91       	ld	r23, X
    5370:	d4 97       	sbiw	r26, 0x34	; 52
    5372:	45 ab       	std	Z+53, r20	; 0x35
    5374:	56 ab       	std	Z+54, r21	; 0x36
    5376:	67 ab       	std	Z+55, r22	; 0x37
    5378:	70 af       	std	Z+56, r23	; 0x38
    537a:	d5 96       	adiw	r26, 0x35	; 53
    537c:	4d 91       	ld	r20, X+
    537e:	5d 91       	ld	r21, X+
    5380:	6d 91       	ld	r22, X+
    5382:	7c 91       	ld	r23, X
    5384:	d8 97       	sbiw	r26, 0x38	; 56
    5386:	41 af       	std	Z+57, r20	; 0x39
    5388:	52 af       	std	Z+58, r21	; 0x3a
    538a:	63 af       	std	Z+59, r22	; 0x3b
    538c:	74 af       	std	Z+60, r23	; 0x3c
    538e:	ef 01       	movw	r28, r30
    5390:	ed 96       	adiw	r28, 0x3d	; 61
    5392:	d9 96       	adiw	r26, 0x39	; 57
    5394:	4d 91       	ld	r20, X+
    5396:	5d 91       	ld	r21, X+
    5398:	6d 91       	ld	r22, X+
    539a:	7c 91       	ld	r23, X
    539c:	dc 97       	sbiw	r26, 0x3c	; 60
    539e:	48 83       	st	Y, r20
    53a0:	59 83       	std	Y+1, r21	; 0x01
    53a2:	6a 83       	std	Y+2, r22	; 0x02
    53a4:	7b 83       	std	Y+3, r23	; 0x03
    53a6:	9f 01       	movw	r18, r30
    53a8:	2f 5b       	subi	r18, 0xBF	; 191
    53aa:	3f 4f       	sbci	r19, 0xFF	; 255
    53ac:	cd 01       	movw	r24, r26
    53ae:	cd 96       	adiw	r24, 0x3d	; 61
    53b0:	ec 01       	movw	r28, r24
    53b2:	48 81       	ld	r20, Y
    53b4:	59 81       	ldd	r21, Y+1	; 0x01
    53b6:	6a 81       	ldd	r22, Y+2	; 0x02
    53b8:	7b 81       	ldd	r23, Y+3	; 0x03
    53ba:	e9 01       	movw	r28, r18
    53bc:	48 83       	st	Y, r20
    53be:	59 83       	std	Y+1, r21	; 0x01
    53c0:	6a 83       	std	Y+2, r22	; 0x02
    53c2:	7b 83       	std	Y+3, r23	; 0x03
    53c4:	2c 5f       	subi	r18, 0xFC	; 252
    53c6:	3f 4f       	sbci	r19, 0xFF	; 255
    53c8:	04 96       	adiw	r24, 0x04	; 4
    53ca:	ec 01       	movw	r28, r24
    53cc:	48 81       	ld	r20, Y
    53ce:	59 81       	ldd	r21, Y+1	; 0x01
    53d0:	6a 81       	ldd	r22, Y+2	; 0x02
    53d2:	7b 81       	ldd	r23, Y+3	; 0x03
    53d4:	e9 01       	movw	r28, r18
    53d6:	48 83       	st	Y, r20
    53d8:	59 83       	std	Y+1, r21	; 0x01
    53da:	6a 83       	std	Y+2, r22	; 0x02
    53dc:	7b 83       	std	Y+3, r23	; 0x03
    53de:	2c 5f       	subi	r18, 0xFC	; 252
    53e0:	3f 4f       	sbci	r19, 0xFF	; 255
    53e2:	04 96       	adiw	r24, 0x04	; 4
    53e4:	ec 01       	movw	r28, r24
    53e6:	48 81       	ld	r20, Y
    53e8:	59 81       	ldd	r21, Y+1	; 0x01
    53ea:	6a 81       	ldd	r22, Y+2	; 0x02
    53ec:	7b 81       	ldd	r23, Y+3	; 0x03
    53ee:	e9 01       	movw	r28, r18
    53f0:	48 83       	st	Y, r20
    53f2:	59 83       	std	Y+1, r21	; 0x01
    53f4:	6a 83       	std	Y+2, r22	; 0x02
    53f6:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    53f8:	2c 5f       	subi	r18, 0xFC	; 252
    53fa:	3f 4f       	sbci	r19, 0xFF	; 255
    53fc:	04 96       	adiw	r24, 0x04	; 4
    53fe:	ec 01       	movw	r28, r24
    5400:	48 81       	ld	r20, Y
    5402:	59 81       	ldd	r21, Y+1	; 0x01
    5404:	6a 81       	ldd	r22, Y+2	; 0x02
    5406:	7b 81       	ldd	r23, Y+3	; 0x03
    5408:	e9 01       	movw	r28, r18
    540a:	48 83       	st	Y, r20
    540c:	59 83       	std	Y+1, r21	; 0x01
    540e:	6a 83       	std	Y+2, r22	; 0x02
    5410:	7b 83       	std	Y+3, r23	; 0x03
    5412:	2c 5f       	subi	r18, 0xFC	; 252
    5414:	3f 4f       	sbci	r19, 0xFF	; 255
    5416:	04 96       	adiw	r24, 0x04	; 4
    5418:	ec 01       	movw	r28, r24
    541a:	48 81       	ld	r20, Y
    541c:	59 81       	ldd	r21, Y+1	; 0x01
    541e:	6a 81       	ldd	r22, Y+2	; 0x02
    5420:	7b 81       	ldd	r23, Y+3	; 0x03
    5422:	e9 01       	movw	r28, r18
    5424:	48 83       	st	Y, r20
    5426:	59 83       	std	Y+1, r21	; 0x01
    5428:	6a 83       	std	Y+2, r22	; 0x02
    542a:	7b 83       	std	Y+3, r23	; 0x03
    542c:	2c 5f       	subi	r18, 0xFC	; 252
    542e:	3f 4f       	sbci	r19, 0xFF	; 255
    5430:	04 96       	adiw	r24, 0x04	; 4
    5432:	ec 01       	movw	r28, r24
    5434:	48 81       	ld	r20, Y
    5436:	59 81       	ldd	r21, Y+1	; 0x01
    5438:	6a 81       	ldd	r22, Y+2	; 0x02
    543a:	7b 81       	ldd	r23, Y+3	; 0x03
    543c:	e9 01       	movw	r28, r18
    543e:	48 83       	st	Y, r20
    5440:	59 83       	std	Y+1, r21	; 0x01
    5442:	6a 83       	std	Y+2, r22	; 0x02
    5444:	7b 83       	std	Y+3, r23	; 0x03
    5446:	2c 5f       	subi	r18, 0xFC	; 252
    5448:	3f 4f       	sbci	r19, 0xFF	; 255
    544a:	04 96       	adiw	r24, 0x04	; 4
    544c:	ec 01       	movw	r28, r24
    544e:	48 81       	ld	r20, Y
    5450:	59 81       	ldd	r21, Y+1	; 0x01
    5452:	6a 81       	ldd	r22, Y+2	; 0x02
    5454:	7b 81       	ldd	r23, Y+3	; 0x03
    5456:	e9 01       	movw	r28, r18
    5458:	48 83       	st	Y, r20
    545a:	59 83       	std	Y+1, r21	; 0x01
    545c:	6a 83       	std	Y+2, r22	; 0x02
    545e:	7b 83       	std	Y+3, r23	; 0x03
    5460:	2c 5f       	subi	r18, 0xFC	; 252
    5462:	3f 4f       	sbci	r19, 0xFF	; 255
    5464:	04 96       	adiw	r24, 0x04	; 4
    5466:	ec 01       	movw	r28, r24
    5468:	48 81       	ld	r20, Y
    546a:	59 81       	ldd	r21, Y+1	; 0x01
    546c:	6a 81       	ldd	r22, Y+2	; 0x02
    546e:	7b 81       	ldd	r23, Y+3	; 0x03
    5470:	e9 01       	movw	r28, r18
    5472:	48 83       	st	Y, r20
    5474:	59 83       	std	Y+1, r21	; 0x01
    5476:	6a 83       	std	Y+2, r22	; 0x02
    5478:	7b 83       	std	Y+3, r23	; 0x03
    547a:	2c 5f       	subi	r18, 0xFC	; 252
    547c:	3f 4f       	sbci	r19, 0xFF	; 255
    547e:	04 96       	adiw	r24, 0x04	; 4
    5480:	ec 01       	movw	r28, r24
    5482:	48 81       	ld	r20, Y
    5484:	59 81       	ldd	r21, Y+1	; 0x01
    5486:	6a 81       	ldd	r22, Y+2	; 0x02
    5488:	7b 81       	ldd	r23, Y+3	; 0x03
    548a:	e9 01       	movw	r28, r18
    548c:	48 83       	st	Y, r20
    548e:	59 83       	std	Y+1, r21	; 0x01
    5490:	6a 83       	std	Y+2, r22	; 0x02
    5492:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5494:	2c 5f       	subi	r18, 0xFC	; 252
    5496:	3f 4f       	sbci	r19, 0xFF	; 255
    5498:	04 96       	adiw	r24, 0x04	; 4
    549a:	ec 01       	movw	r28, r24
    549c:	48 81       	ld	r20, Y
    549e:	59 81       	ldd	r21, Y+1	; 0x01
    54a0:	6a 81       	ldd	r22, Y+2	; 0x02
    54a2:	7b 81       	ldd	r23, Y+3	; 0x03
    54a4:	e9 01       	movw	r28, r18
    54a6:	48 83       	st	Y, r20
    54a8:	59 83       	std	Y+1, r21	; 0x01
    54aa:	6a 83       	std	Y+2, r22	; 0x02
    54ac:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    54ae:	2c 5f       	subi	r18, 0xFC	; 252
    54b0:	3f 4f       	sbci	r19, 0xFF	; 255
    54b2:	04 96       	adiw	r24, 0x04	; 4
    54b4:	ec 01       	movw	r28, r24
    54b6:	48 81       	ld	r20, Y
    54b8:	59 81       	ldd	r21, Y+1	; 0x01
    54ba:	6a 81       	ldd	r22, Y+2	; 0x02
    54bc:	7b 81       	ldd	r23, Y+3	; 0x03
    54be:	e9 01       	movw	r28, r18
    54c0:	48 83       	st	Y, r20
    54c2:	59 83       	std	Y+1, r21	; 0x01
    54c4:	6a 83       	std	Y+2, r22	; 0x02
    54c6:	7b 83       	std	Y+3, r23	; 0x03
    54c8:	2c 5f       	subi	r18, 0xFC	; 252
    54ca:	3f 4f       	sbci	r19, 0xFF	; 255
    54cc:	04 96       	adiw	r24, 0x04	; 4
    54ce:	ec 01       	movw	r28, r24
    54d0:	48 81       	ld	r20, Y
    54d2:	59 81       	ldd	r21, Y+1	; 0x01
    54d4:	6a 81       	ldd	r22, Y+2	; 0x02
    54d6:	7b 81       	ldd	r23, Y+3	; 0x03
    54d8:	e9 01       	movw	r28, r18
    54da:	48 83       	st	Y, r20
    54dc:	59 83       	std	Y+1, r21	; 0x01
    54de:	6a 83       	std	Y+2, r22	; 0x02
    54e0:	7b 83       	std	Y+3, r23	; 0x03
    54e2:	2c 5f       	subi	r18, 0xFC	; 252
    54e4:	3f 4f       	sbci	r19, 0xFF	; 255
    54e6:	04 96       	adiw	r24, 0x04	; 4
    54e8:	ec 01       	movw	r28, r24
    54ea:	48 81       	ld	r20, Y
    54ec:	59 81       	ldd	r21, Y+1	; 0x01
    54ee:	6a 81       	ldd	r22, Y+2	; 0x02
    54f0:	7b 81       	ldd	r23, Y+3	; 0x03
    54f2:	e9 01       	movw	r28, r18
    54f4:	48 83       	st	Y, r20
    54f6:	59 83       	std	Y+1, r21	; 0x01
    54f8:	6a 83       	std	Y+2, r22	; 0x02
    54fa:	7b 83       	std	Y+3, r23	; 0x03
    54fc:	2c 5f       	subi	r18, 0xFC	; 252
    54fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5500:	04 96       	adiw	r24, 0x04	; 4
    5502:	ec 01       	movw	r28, r24
    5504:	48 81       	ld	r20, Y
    5506:	59 81       	ldd	r21, Y+1	; 0x01
    5508:	6a 81       	ldd	r22, Y+2	; 0x02
    550a:	7b 81       	ldd	r23, Y+3	; 0x03
    550c:	e9 01       	movw	r28, r18
    550e:	48 83       	st	Y, r20
    5510:	59 83       	std	Y+1, r21	; 0x01
    5512:	6a 83       	std	Y+2, r22	; 0x02
    5514:	7b 83       	std	Y+3, r23	; 0x03
    5516:	e7 58       	subi	r30, 0x87	; 135
    5518:	ff 4f       	sbci	r31, 0xFF	; 255
    551a:	ab 58       	subi	r26, 0x8B	; 139
    551c:	bf 4f       	sbci	r27, 0xFF	; 255
    551e:	4d 91       	ld	r20, X+
    5520:	5d 91       	ld	r21, X+
    5522:	6d 91       	ld	r22, X+
    5524:	7c 91       	ld	r23, X
    5526:	40 83       	st	Z, r20
    5528:	51 83       	std	Z+1, r21	; 0x01
    552a:	62 83       	std	Z+2, r22	; 0x02
    552c:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    552e:	df 91       	pop	r29
    5530:	cf 91       	pop	r28
    5532:	08 95       	ret

00005534 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>:

SimpleTelemetryMessage* SimpleTelemetryMessage::buildMessageSt(byte *message)
{
    5534:	0f 93       	push	r16
    5536:	1f 93       	push	r17
    5538:	cf 93       	push	r28
    553a:	df 93       	push	r29
    553c:	8c 01       	movw	r16, r24
	SimpleTelemetryMessage *msg = new SimpleTelemetryMessage();
    553e:	8d e7       	ldi	r24, 0x7D	; 125
    5540:	90 e0       	ldi	r25, 0x00	; 0
    5542:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    5546:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    5548:	86 e0       	ldi	r24, 0x06	; 6
    554a:	8a 83       	std	Y+2, r24	; 0x02
    554c:	89 e7       	ldi	r24, 0x79	; 121
    554e:	90 e0       	ldi	r25, 0x00	; 0
    5550:	9c 83       	std	Y+4, r25	; 0x04
    5552:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    5554:	88 e6       	ldi	r24, 0x68	; 104
    5556:	92 e0       	ldi	r25, 0x02	; 2
    5558:	99 83       	std	Y+1, r25	; 0x01
    555a:	88 83       	st	Y, r24
    555c:	1d 82       	std	Y+5, r1	; 0x05
    555e:	1e 82       	std	Y+6, r1	; 0x06
    5560:	1f 82       	std	Y+7, r1	; 0x07
    5562:	18 86       	std	Y+8, r1	; 0x08
    5564:	19 86       	std	Y+9, r1	; 0x09
    5566:	1a 86       	std	Y+10, r1	; 0x0a
    5568:	1b 86       	std	Y+11, r1	; 0x0b
    556a:	1c 86       	std	Y+12, r1	; 0x0c
    556c:	1d 86       	std	Y+13, r1	; 0x0d
    556e:	1e 86       	std	Y+14, r1	; 0x0e
    5570:	1f 86       	std	Y+15, r1	; 0x0f
    5572:	18 8a       	std	Y+16, r1	; 0x10
    5574:	19 8a       	std	Y+17, r1	; 0x11
    5576:	1a 8a       	std	Y+18, r1	; 0x12
    5578:	1b 8a       	std	Y+19, r1	; 0x13
    557a:	1c 8a       	std	Y+20, r1	; 0x14
    557c:	1d 8a       	std	Y+21, r1	; 0x15
    557e:	1e 8a       	std	Y+22, r1	; 0x16
    5580:	1f 8a       	std	Y+23, r1	; 0x17
    5582:	18 8e       	std	Y+24, r1	; 0x18
    5584:	19 8e       	std	Y+25, r1	; 0x19
    5586:	1a 8e       	std	Y+26, r1	; 0x1a
    5588:	1b 8e       	std	Y+27, r1	; 0x1b
    558a:	1c 8e       	std	Y+28, r1	; 0x1c
    558c:	1d 8e       	std	Y+29, r1	; 0x1d
    558e:	1e 8e       	std	Y+30, r1	; 0x1e
    5590:	1f 8e       	std	Y+31, r1	; 0x1f
    5592:	18 a2       	std	Y+32, r1	; 0x20
    5594:	19 a2       	std	Y+33, r1	; 0x21
    5596:	1a a2       	std	Y+34, r1	; 0x22
    5598:	1b a2       	std	Y+35, r1	; 0x23
    559a:	1c a2       	std	Y+36, r1	; 0x24
    559c:	1d a2       	std	Y+37, r1	; 0x25
    559e:	1e a2       	std	Y+38, r1	; 0x26
    55a0:	1f a2       	std	Y+39, r1	; 0x27
    55a2:	18 a6       	std	Y+40, r1	; 0x28
    55a4:	19 a6       	std	Y+41, r1	; 0x29
    55a6:	1a a6       	std	Y+42, r1	; 0x2a
    55a8:	1b a6       	std	Y+43, r1	; 0x2b
    55aa:	1c a6       	std	Y+44, r1	; 0x2c
    55ac:	1d a6       	std	Y+45, r1	; 0x2d
    55ae:	1e a6       	std	Y+46, r1	; 0x2e
    55b0:	1f a6       	std	Y+47, r1	; 0x2f
    55b2:	18 aa       	std	Y+48, r1	; 0x30
    55b4:	19 aa       	std	Y+49, r1	; 0x31
    55b6:	1a aa       	std	Y+50, r1	; 0x32
    55b8:	1b aa       	std	Y+51, r1	; 0x33
    55ba:	1c aa       	std	Y+52, r1	; 0x34
    55bc:	1d aa       	std	Y+53, r1	; 0x35
    55be:	1e aa       	std	Y+54, r1	; 0x36
    55c0:	1f aa       	std	Y+55, r1	; 0x37
    55c2:	18 ae       	std	Y+56, r1	; 0x38
    55c4:	19 ae       	std	Y+57, r1	; 0x39
    55c6:	1a ae       	std	Y+58, r1	; 0x3a
    55c8:	1b ae       	std	Y+59, r1	; 0x3b
    55ca:	1c ae       	std	Y+60, r1	; 0x3c
    55cc:	fe 01       	movw	r30, r28
    55ce:	fd 96       	adiw	r30, 0x3d	; 61
    55d0:	10 82       	st	Z, r1
    55d2:	11 82       	std	Z+1, r1	; 0x01
    55d4:	12 82       	std	Z+2, r1	; 0x02
    55d6:	13 82       	std	Z+3, r1	; 0x03
    55d8:	34 96       	adiw	r30, 0x04	; 4
    55da:	10 82       	st	Z, r1
    55dc:	11 82       	std	Z+1, r1	; 0x01
    55de:	12 82       	std	Z+2, r1	; 0x02
    55e0:	13 82       	std	Z+3, r1	; 0x03
    55e2:	34 96       	adiw	r30, 0x04	; 4
    55e4:	10 82       	st	Z, r1
    55e6:	11 82       	std	Z+1, r1	; 0x01
    55e8:	12 82       	std	Z+2, r1	; 0x02
    55ea:	13 82       	std	Z+3, r1	; 0x03
    55ec:	34 96       	adiw	r30, 0x04	; 4
    55ee:	10 82       	st	Z, r1
    55f0:	11 82       	std	Z+1, r1	; 0x01
    55f2:	12 82       	std	Z+2, r1	; 0x02
    55f4:	13 82       	std	Z+3, r1	; 0x03
    55f6:	34 96       	adiw	r30, 0x04	; 4
    55f8:	10 82       	st	Z, r1
    55fa:	11 82       	std	Z+1, r1	; 0x01
    55fc:	12 82       	std	Z+2, r1	; 0x02
    55fe:	13 82       	std	Z+3, r1	; 0x03
    5600:	34 96       	adiw	r30, 0x04	; 4
    5602:	10 82       	st	Z, r1
    5604:	11 82       	std	Z+1, r1	; 0x01
    5606:	12 82       	std	Z+2, r1	; 0x02
    5608:	13 82       	std	Z+3, r1	; 0x03
    560a:	34 96       	adiw	r30, 0x04	; 4
    560c:	10 82       	st	Z, r1
    560e:	11 82       	std	Z+1, r1	; 0x01
    5610:	12 82       	std	Z+2, r1	; 0x02
    5612:	13 82       	std	Z+3, r1	; 0x03
    5614:	34 96       	adiw	r30, 0x04	; 4
    5616:	10 82       	st	Z, r1
    5618:	11 82       	std	Z+1, r1	; 0x01
    561a:	12 82       	std	Z+2, r1	; 0x02
    561c:	13 82       	std	Z+3, r1	; 0x03
    561e:	34 96       	adiw	r30, 0x04	; 4
    5620:	10 82       	st	Z, r1
    5622:	11 82       	std	Z+1, r1	; 0x01
    5624:	12 82       	std	Z+2, r1	; 0x02
    5626:	13 82       	std	Z+3, r1	; 0x03
    5628:	34 96       	adiw	r30, 0x04	; 4
    562a:	10 82       	st	Z, r1
    562c:	11 82       	std	Z+1, r1	; 0x01
    562e:	12 82       	std	Z+2, r1	; 0x02
    5630:	13 82       	std	Z+3, r1	; 0x03
    5632:	34 96       	adiw	r30, 0x04	; 4
    5634:	10 82       	st	Z, r1
    5636:	11 82       	std	Z+1, r1	; 0x01
    5638:	12 82       	std	Z+2, r1	; 0x02
    563a:	13 82       	std	Z+3, r1	; 0x03
    563c:	34 96       	adiw	r30, 0x04	; 4
    563e:	10 82       	st	Z, r1
    5640:	11 82       	std	Z+1, r1	; 0x01
    5642:	12 82       	std	Z+2, r1	; 0x02
    5644:	13 82       	std	Z+3, r1	; 0x03
    5646:	34 96       	adiw	r30, 0x04	; 4
    5648:	10 82       	st	Z, r1
    564a:	11 82       	std	Z+1, r1	; 0x01
    564c:	12 82       	std	Z+2, r1	; 0x02
    564e:	13 82       	std	Z+3, r1	; 0x03
    5650:	34 96       	adiw	r30, 0x04	; 4
    5652:	10 82       	st	Z, r1
    5654:	11 82       	std	Z+1, r1	; 0x01
    5656:	12 82       	std	Z+2, r1	; 0x02
    5658:	13 82       	std	Z+3, r1	; 0x03
    565a:	34 96       	adiw	r30, 0x04	; 4
    565c:	10 82       	st	Z, r1
    565e:	11 82       	std	Z+1, r1	; 0x01
    5660:	12 82       	std	Z+2, r1	; 0x02
    5662:	13 82       	std	Z+3, r1	; 0x03
    5664:	34 96       	adiw	r30, 0x04	; 4
    5666:	10 82       	st	Z, r1
    5668:	11 82       	std	Z+1, r1	; 0x01
    566a:	12 82       	std	Z+2, r1	; 0x02
    566c:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    566e:	b8 01       	movw	r22, r16
    5670:	ce 01       	movw	r24, r28
    5672:	0e 94 32 29 	call	0x5264	; 0x5264 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    5676:	ce 01       	movw	r24, r28
    5678:	df 91       	pop	r29
    567a:	cf 91       	pop	r28
    567c:	1f 91       	pop	r17
    567e:	0f 91       	pop	r16
    5680:	08 95       	ret

00005682 <_ZN10helicopter8messages11SyncMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    5682:	20 e5       	ldi	r18, 0x50	; 80
    5684:	32 e0       	ldi	r19, 0x02	; 2
    5686:	fc 01       	movw	r30, r24
    5688:	31 83       	std	Z+1, r19	; 0x01
    568a:	20 83       	st	Z, r18
    568c:	08 95       	ret

0000568e <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>:
	return msg;
}

void SyncMessage::buildMessage(byte *message)
{
	if (message != NULL)
    568e:	61 15       	cp	r22, r1
    5690:	71 05       	cpc	r23, r1
    5692:	41 f0       	breq	.+16     	; 0x56a4 <_ZN10helicopter8messages11SyncMessage12buildMessageEPh+0x16>
	{
		msgType = message[0];
    5694:	fb 01       	movw	r30, r22
    5696:	20 81       	ld	r18, Z
    5698:	fc 01       	movw	r30, r24
    569a:	22 83       	std	Z+2, r18	; 0x02
		RequestedMessage = message[1];
    569c:	fb 01       	movw	r30, r22
    569e:	21 81       	ldd	r18, Z+1	; 0x01
    56a0:	fc 01       	movw	r30, r24
    56a2:	25 83       	std	Z+5, r18	; 0x05
    56a4:	08 95       	ret

000056a6 <_ZN10helicopter8messages11SyncMessageD0Ev>:
    56a6:	20 e5       	ldi	r18, 0x50	; 80
    56a8:	32 e0       	ldi	r19, 0x02	; 2
    56aa:	fc 01       	movw	r30, r24
    56ac:	31 83       	std	Z+1, r19	; 0x01
    56ae:	20 83       	st	Z, r18
				}
				
				~SyncMessage()
				{
					
				}
    56b0:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    56b4:	08 95       	ret

000056b6 <_ZN10helicopter8messages11SyncMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SyncMessage::getBytes()
{
    56b6:	cf 93       	push	r28
    56b8:	df 93       	push	r29
    56ba:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    56bc:	82 e0       	ldi	r24, 0x02	; 2
    56be:	90 e0       	ldi	r25, 0x00	; 0
    56c0:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
	byte *msgPtr = msg;
	msgPtr[0] = this->msgType;
    56c4:	2a 81       	ldd	r18, Y+2	; 0x02
    56c6:	fc 01       	movw	r30, r24
    56c8:	20 83       	st	Z, r18
	msgPtr[1] = this->RequestedMessage;
    56ca:	2d 81       	ldd	r18, Y+5	; 0x05
    56cc:	21 83       	std	Z+1, r18	; 0x01
	
	return msg;
}
    56ce:	df 91       	pop	r29
    56d0:	cf 91       	pop	r28
    56d2:	08 95       	ret

000056d4 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>:
    56d4:	20 e5       	ldi	r18, 0x50	; 80
    56d6:	32 e0       	ldi	r19, 0x02	; 2
    56d8:	fc 01       	movw	r30, r24
    56da:	31 83       	std	Z+1, r19	; 0x01
    56dc:	20 83       	st	Z, r18
    56de:	08 95       	ret

000056e0 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>:
    56e0:	20 e5       	ldi	r18, 0x50	; 80
    56e2:	32 e0       	ldi	r19, 0x02	; 2
    56e4:	fc 01       	movw	r30, r24
    56e6:	31 83       	std	Z+1, r19	; 0x01
    56e8:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SystemTelemetryMessage() {}
    56ea:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    56ee:	08 95       	ret

000056f0 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SystemTelemetryMessage::getBytes()
{
    56f0:	cf 93       	push	r28
    56f2:	df 93       	push	r29
    56f4:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    56f6:	8d e2       	ldi	r24, 0x2D	; 45
    56f8:	91 e0       	ldi	r25, 0x01	; 1
    56fa:	0e 94 0e 61 	call	0xc21c	; 0xc21c <_Znaj>
    56fe:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    5700:	8a 81       	ldd	r24, Y+2	; 0x02
    5702:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5704:	8d 81       	ldd	r24, Y+5	; 0x05
    5706:	9e 81       	ldd	r25, Y+6	; 0x06
    5708:	af 81       	ldd	r26, Y+7	; 0x07
    570a:	b8 85       	ldd	r27, Y+8	; 0x08
    570c:	81 83       	std	Z+1, r24	; 0x01
    570e:	92 83       	std	Z+2, r25	; 0x02
    5710:	a3 83       	std	Z+3, r26	; 0x03
    5712:	b4 83       	std	Z+4, r27	; 0x04
    5714:	89 85       	ldd	r24, Y+9	; 0x09
    5716:	9a 85       	ldd	r25, Y+10	; 0x0a
    5718:	ab 85       	ldd	r26, Y+11	; 0x0b
    571a:	bc 85       	ldd	r27, Y+12	; 0x0c
    571c:	85 83       	std	Z+5, r24	; 0x05
    571e:	96 83       	std	Z+6, r25	; 0x06
    5720:	a7 83       	std	Z+7, r26	; 0x07
    5722:	b0 87       	std	Z+8, r27	; 0x08
    5724:	8d 85       	ldd	r24, Y+13	; 0x0d
    5726:	9e 85       	ldd	r25, Y+14	; 0x0e
    5728:	af 85       	ldd	r26, Y+15	; 0x0f
    572a:	b8 89       	ldd	r27, Y+16	; 0x10
    572c:	81 87       	std	Z+9, r24	; 0x09
    572e:	92 87       	std	Z+10, r25	; 0x0a
    5730:	a3 87       	std	Z+11, r26	; 0x0b
    5732:	b4 87       	std	Z+12, r27	; 0x0c
    5734:	89 89       	ldd	r24, Y+17	; 0x11
    5736:	9a 89       	ldd	r25, Y+18	; 0x12
    5738:	ab 89       	ldd	r26, Y+19	; 0x13
    573a:	bc 89       	ldd	r27, Y+20	; 0x14
    573c:	85 87       	std	Z+13, r24	; 0x0d
    573e:	96 87       	std	Z+14, r25	; 0x0e
    5740:	a7 87       	std	Z+15, r26	; 0x0f
    5742:	b0 8b       	std	Z+16, r27	; 0x10
    5744:	8d 89       	ldd	r24, Y+21	; 0x15
    5746:	9e 89       	ldd	r25, Y+22	; 0x16
    5748:	af 89       	ldd	r26, Y+23	; 0x17
    574a:	b8 8d       	ldd	r27, Y+24	; 0x18
    574c:	81 8b       	std	Z+17, r24	; 0x11
    574e:	92 8b       	std	Z+18, r25	; 0x12
    5750:	a3 8b       	std	Z+19, r26	; 0x13
    5752:	b4 8b       	std	Z+20, r27	; 0x14
    5754:	89 8d       	ldd	r24, Y+25	; 0x19
    5756:	9a 8d       	ldd	r25, Y+26	; 0x1a
    5758:	ab 8d       	ldd	r26, Y+27	; 0x1b
    575a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    575c:	85 8b       	std	Z+21, r24	; 0x15
    575e:	96 8b       	std	Z+22, r25	; 0x16
    5760:	a7 8b       	std	Z+23, r26	; 0x17
    5762:	b0 8f       	std	Z+24, r27	; 0x18
    5764:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5766:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5768:	af 8d       	ldd	r26, Y+31	; 0x1f
    576a:	b8 a1       	ldd	r27, Y+32	; 0x20
    576c:	81 8f       	std	Z+25, r24	; 0x19
    576e:	92 8f       	std	Z+26, r25	; 0x1a
    5770:	a3 8f       	std	Z+27, r26	; 0x1b
    5772:	b4 8f       	std	Z+28, r27	; 0x1c
    5774:	89 a1       	ldd	r24, Y+33	; 0x21
    5776:	9a a1       	ldd	r25, Y+34	; 0x22
    5778:	ab a1       	ldd	r26, Y+35	; 0x23
    577a:	bc a1       	ldd	r27, Y+36	; 0x24
    577c:	85 8f       	std	Z+29, r24	; 0x1d
    577e:	96 8f       	std	Z+30, r25	; 0x1e
    5780:	a7 8f       	std	Z+31, r26	; 0x1f
    5782:	b0 a3       	std	Z+32, r27	; 0x20
    5784:	8d a1       	ldd	r24, Y+37	; 0x25
    5786:	9e a1       	ldd	r25, Y+38	; 0x26
    5788:	af a1       	ldd	r26, Y+39	; 0x27
    578a:	b8 a5       	ldd	r27, Y+40	; 0x28
    578c:	81 a3       	std	Z+33, r24	; 0x21
    578e:	92 a3       	std	Z+34, r25	; 0x22
    5790:	a3 a3       	std	Z+35, r26	; 0x23
    5792:	b4 a3       	std	Z+36, r27	; 0x24
    5794:	89 a5       	ldd	r24, Y+41	; 0x29
    5796:	9a a5       	ldd	r25, Y+42	; 0x2a
    5798:	ab a5       	ldd	r26, Y+43	; 0x2b
    579a:	bc a5       	ldd	r27, Y+44	; 0x2c
    579c:	85 a3       	std	Z+37, r24	; 0x25
    579e:	96 a3       	std	Z+38, r25	; 0x26
    57a0:	a7 a3       	std	Z+39, r26	; 0x27
    57a2:	b0 a7       	std	Z+40, r27	; 0x28
    57a4:	8d a5       	ldd	r24, Y+45	; 0x2d
    57a6:	9e a5       	ldd	r25, Y+46	; 0x2e
    57a8:	af a5       	ldd	r26, Y+47	; 0x2f
    57aa:	b8 a9       	ldd	r27, Y+48	; 0x30
    57ac:	81 a7       	std	Z+41, r24	; 0x29
    57ae:	92 a7       	std	Z+42, r25	; 0x2a
    57b0:	a3 a7       	std	Z+43, r26	; 0x2b
    57b2:	b4 a7       	std	Z+44, r27	; 0x2c
    57b4:	89 a9       	ldd	r24, Y+49	; 0x31
    57b6:	9a a9       	ldd	r25, Y+50	; 0x32
    57b8:	ab a9       	ldd	r26, Y+51	; 0x33
    57ba:	bc a9       	ldd	r27, Y+52	; 0x34
    57bc:	85 a7       	std	Z+45, r24	; 0x2d
    57be:	96 a7       	std	Z+46, r25	; 0x2e
    57c0:	a7 a7       	std	Z+47, r26	; 0x2f
    57c2:	b0 ab       	std	Z+48, r27	; 0x30
    57c4:	8d a9       	ldd	r24, Y+53	; 0x35
    57c6:	9e a9       	ldd	r25, Y+54	; 0x36
    57c8:	af a9       	ldd	r26, Y+55	; 0x37
    57ca:	b8 ad       	ldd	r27, Y+56	; 0x38
    57cc:	81 ab       	std	Z+49, r24	; 0x31
    57ce:	92 ab       	std	Z+50, r25	; 0x32
    57d0:	a3 ab       	std	Z+51, r26	; 0x33
    57d2:	b4 ab       	std	Z+52, r27	; 0x34
    57d4:	89 ad       	ldd	r24, Y+57	; 0x39
    57d6:	9a ad       	ldd	r25, Y+58	; 0x3a
    57d8:	ab ad       	ldd	r26, Y+59	; 0x3b
    57da:	bc ad       	ldd	r27, Y+60	; 0x3c
    57dc:	85 ab       	std	Z+53, r24	; 0x35
    57de:	96 ab       	std	Z+54, r25	; 0x36
    57e0:	a7 ab       	std	Z+55, r26	; 0x37
    57e2:	b0 af       	std	Z+56, r27	; 0x38
    57e4:	de 01       	movw	r26, r28
    57e6:	dd 96       	adiw	r26, 0x3d	; 61
    57e8:	8d 91       	ld	r24, X+
    57ea:	9d 91       	ld	r25, X+
    57ec:	0d 90       	ld	r0, X+
    57ee:	bc 91       	ld	r27, X
    57f0:	a0 2d       	mov	r26, r0
    57f2:	81 af       	std	Z+57, r24	; 0x39
    57f4:	92 af       	std	Z+58, r25	; 0x3a
    57f6:	a3 af       	std	Z+59, r26	; 0x3b
    57f8:	b4 af       	std	Z+60, r27	; 0x3c
    57fa:	9f 01       	movw	r18, r30
    57fc:	23 5c       	subi	r18, 0xC3	; 195
    57fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5800:	de 01       	movw	r26, r28
    5802:	af 5b       	subi	r26, 0xBF	; 191
    5804:	bf 4f       	sbci	r27, 0xFF	; 255
    5806:	4d 91       	ld	r20, X+
    5808:	5d 91       	ld	r21, X+
    580a:	6d 91       	ld	r22, X+
    580c:	7c 91       	ld	r23, X
    580e:	d9 01       	movw	r26, r18
    5810:	4d 93       	st	X+, r20
    5812:	5d 93       	st	X+, r21
    5814:	6d 93       	st	X+, r22
    5816:	7c 93       	st	X, r23
    5818:	13 97       	sbiw	r26, 0x03	; 3
    581a:	2c 5f       	subi	r18, 0xFC	; 252
    581c:	3f 4f       	sbci	r19, 0xFF	; 255
    581e:	de 01       	movw	r26, r28
    5820:	ab 5b       	subi	r26, 0xBB	; 187
    5822:	bf 4f       	sbci	r27, 0xFF	; 255
    5824:	4d 91       	ld	r20, X+
    5826:	5d 91       	ld	r21, X+
    5828:	6d 91       	ld	r22, X+
    582a:	7c 91       	ld	r23, X
    582c:	d9 01       	movw	r26, r18
    582e:	4d 93       	st	X+, r20
    5830:	5d 93       	st	X+, r21
    5832:	6d 93       	st	X+, r22
    5834:	7c 93       	st	X, r23
    5836:	13 97       	sbiw	r26, 0x03	; 3
    5838:	2c 5f       	subi	r18, 0xFC	; 252
    583a:	3f 4f       	sbci	r19, 0xFF	; 255
    583c:	de 01       	movw	r26, r28
    583e:	a7 5b       	subi	r26, 0xB7	; 183
    5840:	bf 4f       	sbci	r27, 0xFF	; 255
    5842:	4d 91       	ld	r20, X+
    5844:	5d 91       	ld	r21, X+
    5846:	6d 91       	ld	r22, X+
    5848:	7c 91       	ld	r23, X
    584a:	d9 01       	movw	r26, r18
    584c:	4d 93       	st	X+, r20
    584e:	5d 93       	st	X+, r21
    5850:	6d 93       	st	X+, r22
    5852:	7c 93       	st	X, r23
    5854:	13 97       	sbiw	r26, 0x03	; 3
    5856:	2c 5f       	subi	r18, 0xFC	; 252
    5858:	3f 4f       	sbci	r19, 0xFF	; 255
    585a:	de 01       	movw	r26, r28
    585c:	a3 5b       	subi	r26, 0xB3	; 179
    585e:	bf 4f       	sbci	r27, 0xFF	; 255
    5860:	4d 91       	ld	r20, X+
    5862:	5d 91       	ld	r21, X+
    5864:	6d 91       	ld	r22, X+
    5866:	7c 91       	ld	r23, X
    5868:	d9 01       	movw	r26, r18
    586a:	4d 93       	st	X+, r20
    586c:	5d 93       	st	X+, r21
    586e:	6d 93       	st	X+, r22
    5870:	7c 93       	st	X, r23
    5872:	13 97       	sbiw	r26, 0x03	; 3
    5874:	2c 5f       	subi	r18, 0xFC	; 252
    5876:	3f 4f       	sbci	r19, 0xFF	; 255
    5878:	de 01       	movw	r26, r28
    587a:	af 5a       	subi	r26, 0xAF	; 175
    587c:	bf 4f       	sbci	r27, 0xFF	; 255
    587e:	4d 91       	ld	r20, X+
    5880:	5d 91       	ld	r21, X+
    5882:	6d 91       	ld	r22, X+
    5884:	7c 91       	ld	r23, X
    5886:	d9 01       	movw	r26, r18
    5888:	4d 93       	st	X+, r20
    588a:	5d 93       	st	X+, r21
    588c:	6d 93       	st	X+, r22
    588e:	7c 93       	st	X, r23
    5890:	13 97       	sbiw	r26, 0x03	; 3
    5892:	2c 5f       	subi	r18, 0xFC	; 252
    5894:	3f 4f       	sbci	r19, 0xFF	; 255
    5896:	de 01       	movw	r26, r28
    5898:	ab 5a       	subi	r26, 0xAB	; 171
    589a:	bf 4f       	sbci	r27, 0xFF	; 255
    589c:	4d 91       	ld	r20, X+
    589e:	5d 91       	ld	r21, X+
    58a0:	6d 91       	ld	r22, X+
    58a2:	7c 91       	ld	r23, X
    58a4:	d9 01       	movw	r26, r18
    58a6:	4d 93       	st	X+, r20
    58a8:	5d 93       	st	X+, r21
    58aa:	6d 93       	st	X+, r22
    58ac:	7c 93       	st	X, r23
    58ae:	13 97       	sbiw	r26, 0x03	; 3
    58b0:	2c 5f       	subi	r18, 0xFC	; 252
    58b2:	3f 4f       	sbci	r19, 0xFF	; 255
    58b4:	de 01       	movw	r26, r28
    58b6:	a7 5a       	subi	r26, 0xA7	; 167
    58b8:	bf 4f       	sbci	r27, 0xFF	; 255
    58ba:	4d 91       	ld	r20, X+
    58bc:	5d 91       	ld	r21, X+
    58be:	6d 91       	ld	r22, X+
    58c0:	7c 91       	ld	r23, X
    58c2:	d9 01       	movw	r26, r18
    58c4:	4d 93       	st	X+, r20
    58c6:	5d 93       	st	X+, r21
    58c8:	6d 93       	st	X+, r22
    58ca:	7c 93       	st	X, r23
    58cc:	13 97       	sbiw	r26, 0x03	; 3
    58ce:	2c 5f       	subi	r18, 0xFC	; 252
    58d0:	3f 4f       	sbci	r19, 0xFF	; 255
    58d2:	de 01       	movw	r26, r28
    58d4:	a3 5a       	subi	r26, 0xA3	; 163
    58d6:	bf 4f       	sbci	r27, 0xFF	; 255
    58d8:	4d 91       	ld	r20, X+
    58da:	5d 91       	ld	r21, X+
    58dc:	6d 91       	ld	r22, X+
    58de:	7c 91       	ld	r23, X
    58e0:	d9 01       	movw	r26, r18
    58e2:	4d 93       	st	X+, r20
    58e4:	5d 93       	st	X+, r21
    58e6:	6d 93       	st	X+, r22
    58e8:	7c 93       	st	X, r23
    58ea:	13 97       	sbiw	r26, 0x03	; 3
    58ec:	2c 5f       	subi	r18, 0xFC	; 252
    58ee:	3f 4f       	sbci	r19, 0xFF	; 255
    58f0:	de 01       	movw	r26, r28
    58f2:	af 59       	subi	r26, 0x9F	; 159
    58f4:	bf 4f       	sbci	r27, 0xFF	; 255
    58f6:	4d 91       	ld	r20, X+
    58f8:	5d 91       	ld	r21, X+
    58fa:	6d 91       	ld	r22, X+
    58fc:	7c 91       	ld	r23, X
    58fe:	d9 01       	movw	r26, r18
    5900:	4d 93       	st	X+, r20
    5902:	5d 93       	st	X+, r21
    5904:	6d 93       	st	X+, r22
    5906:	7c 93       	st	X, r23
    5908:	13 97       	sbiw	r26, 0x03	; 3
    590a:	2c 5f       	subi	r18, 0xFC	; 252
    590c:	3f 4f       	sbci	r19, 0xFF	; 255
    590e:	de 01       	movw	r26, r28
    5910:	ab 59       	subi	r26, 0x9B	; 155
    5912:	bf 4f       	sbci	r27, 0xFF	; 255
    5914:	4d 91       	ld	r20, X+
    5916:	5d 91       	ld	r21, X+
    5918:	6d 91       	ld	r22, X+
    591a:	7c 91       	ld	r23, X
    591c:	d9 01       	movw	r26, r18
    591e:	4d 93       	st	X+, r20
    5920:	5d 93       	st	X+, r21
    5922:	6d 93       	st	X+, r22
    5924:	7c 93       	st	X, r23
    5926:	13 97       	sbiw	r26, 0x03	; 3
    5928:	2c 5f       	subi	r18, 0xFC	; 252
    592a:	3f 4f       	sbci	r19, 0xFF	; 255
    592c:	de 01       	movw	r26, r28
    592e:	a7 59       	subi	r26, 0x97	; 151
    5930:	bf 4f       	sbci	r27, 0xFF	; 255
    5932:	4d 91       	ld	r20, X+
    5934:	5d 91       	ld	r21, X+
    5936:	6d 91       	ld	r22, X+
    5938:	7c 91       	ld	r23, X
    593a:	d9 01       	movw	r26, r18
    593c:	4d 93       	st	X+, r20
    593e:	5d 93       	st	X+, r21
    5940:	6d 93       	st	X+, r22
    5942:	7c 93       	st	X, r23
    5944:	13 97       	sbiw	r26, 0x03	; 3
    5946:	2c 5f       	subi	r18, 0xFC	; 252
    5948:	3f 4f       	sbci	r19, 0xFF	; 255
    594a:	de 01       	movw	r26, r28
    594c:	a3 59       	subi	r26, 0x93	; 147
    594e:	bf 4f       	sbci	r27, 0xFF	; 255
    5950:	4d 91       	ld	r20, X+
    5952:	5d 91       	ld	r21, X+
    5954:	6d 91       	ld	r22, X+
    5956:	7c 91       	ld	r23, X
    5958:	d9 01       	movw	r26, r18
    595a:	4d 93       	st	X+, r20
    595c:	5d 93       	st	X+, r21
    595e:	6d 93       	st	X+, r22
    5960:	7c 93       	st	X, r23
    5962:	13 97       	sbiw	r26, 0x03	; 3
    5964:	2c 5f       	subi	r18, 0xFC	; 252
    5966:	3f 4f       	sbci	r19, 0xFF	; 255
    5968:	de 01       	movw	r26, r28
    596a:	af 58       	subi	r26, 0x8F	; 143
    596c:	bf 4f       	sbci	r27, 0xFF	; 255
    596e:	4d 91       	ld	r20, X+
    5970:	5d 91       	ld	r21, X+
    5972:	6d 91       	ld	r22, X+
    5974:	7c 91       	ld	r23, X
    5976:	d9 01       	movw	r26, r18
    5978:	4d 93       	st	X+, r20
    597a:	5d 93       	st	X+, r21
    597c:	6d 93       	st	X+, r22
    597e:	7c 93       	st	X, r23
    5980:	13 97       	sbiw	r26, 0x03	; 3
    5982:	2c 5f       	subi	r18, 0xFC	; 252
    5984:	3f 4f       	sbci	r19, 0xFF	; 255
    5986:	de 01       	movw	r26, r28
    5988:	ab 58       	subi	r26, 0x8B	; 139
    598a:	bf 4f       	sbci	r27, 0xFF	; 255
    598c:	4d 91       	ld	r20, X+
    598e:	5d 91       	ld	r21, X+
    5990:	6d 91       	ld	r22, X+
    5992:	7c 91       	ld	r23, X
    5994:	d9 01       	movw	r26, r18
    5996:	4d 93       	st	X+, r20
    5998:	5d 93       	st	X+, r21
    599a:	6d 93       	st	X+, r22
    599c:	7c 93       	st	X, r23
    599e:	13 97       	sbiw	r26, 0x03	; 3
    59a0:	2c 5f       	subi	r18, 0xFC	; 252
    59a2:	3f 4f       	sbci	r19, 0xFF	; 255
    59a4:	de 01       	movw	r26, r28
    59a6:	a7 58       	subi	r26, 0x87	; 135
    59a8:	bf 4f       	sbci	r27, 0xFF	; 255
    59aa:	4d 91       	ld	r20, X+
    59ac:	5d 91       	ld	r21, X+
    59ae:	6d 91       	ld	r22, X+
    59b0:	7c 91       	ld	r23, X
    59b2:	d9 01       	movw	r26, r18
    59b4:	4d 93       	st	X+, r20
    59b6:	5d 93       	st	X+, r21
    59b8:	6d 93       	st	X+, r22
    59ba:	7c 93       	st	X, r23
    59bc:	13 97       	sbiw	r26, 0x03	; 3
    59be:	2c 5f       	subi	r18, 0xFC	; 252
    59c0:	3f 4f       	sbci	r19, 0xFF	; 255
    59c2:	de 01       	movw	r26, r28
    59c4:	a3 58       	subi	r26, 0x83	; 131
    59c6:	bf 4f       	sbci	r27, 0xFF	; 255
    59c8:	4d 91       	ld	r20, X+
    59ca:	5d 91       	ld	r21, X+
    59cc:	6d 91       	ld	r22, X+
    59ce:	7c 91       	ld	r23, X
    59d0:	d9 01       	movw	r26, r18
    59d2:	4d 93       	st	X+, r20
    59d4:	5d 93       	st	X+, r21
    59d6:	6d 93       	st	X+, r22
    59d8:	7c 93       	st	X, r23
    59da:	13 97       	sbiw	r26, 0x03	; 3
    59dc:	2c 5f       	subi	r18, 0xFC	; 252
    59de:	3f 4f       	sbci	r19, 0xFF	; 255
    59e0:	de 01       	movw	r26, r28
    59e2:	af 57       	subi	r26, 0x7F	; 127
    59e4:	bf 4f       	sbci	r27, 0xFF	; 255
    59e6:	4d 91       	ld	r20, X+
    59e8:	5d 91       	ld	r21, X+
    59ea:	6d 91       	ld	r22, X+
    59ec:	7c 91       	ld	r23, X
    59ee:	d9 01       	movw	r26, r18
    59f0:	4d 93       	st	X+, r20
    59f2:	5d 93       	st	X+, r21
    59f4:	6d 93       	st	X+, r22
    59f6:	7c 93       	st	X, r23
    59f8:	13 97       	sbiw	r26, 0x03	; 3
    59fa:	2c 5f       	subi	r18, 0xFC	; 252
    59fc:	3f 4f       	sbci	r19, 0xFF	; 255
    59fe:	de 01       	movw	r26, r28
    5a00:	ab 57       	subi	r26, 0x7B	; 123
    5a02:	bf 4f       	sbci	r27, 0xFF	; 255
    5a04:	4d 91       	ld	r20, X+
    5a06:	5d 91       	ld	r21, X+
    5a08:	6d 91       	ld	r22, X+
    5a0a:	7c 91       	ld	r23, X
    5a0c:	d9 01       	movw	r26, r18
    5a0e:	4d 93       	st	X+, r20
    5a10:	5d 93       	st	X+, r21
    5a12:	6d 93       	st	X+, r22
    5a14:	7c 93       	st	X, r23
    5a16:	13 97       	sbiw	r26, 0x03	; 3
    5a18:	2c 5f       	subi	r18, 0xFC	; 252
    5a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a1c:	de 01       	movw	r26, r28
    5a1e:	a7 57       	subi	r26, 0x77	; 119
    5a20:	bf 4f       	sbci	r27, 0xFF	; 255
    5a22:	4d 91       	ld	r20, X+
    5a24:	5d 91       	ld	r21, X+
    5a26:	6d 91       	ld	r22, X+
    5a28:	7c 91       	ld	r23, X
    5a2a:	d9 01       	movw	r26, r18
    5a2c:	4d 93       	st	X+, r20
    5a2e:	5d 93       	st	X+, r21
    5a30:	6d 93       	st	X+, r22
    5a32:	7c 93       	st	X, r23
    5a34:	13 97       	sbiw	r26, 0x03	; 3
    5a36:	2c 5f       	subi	r18, 0xFC	; 252
    5a38:	3f 4f       	sbci	r19, 0xFF	; 255
    5a3a:	de 01       	movw	r26, r28
    5a3c:	a3 57       	subi	r26, 0x73	; 115
    5a3e:	bf 4f       	sbci	r27, 0xFF	; 255
    5a40:	4d 91       	ld	r20, X+
    5a42:	5d 91       	ld	r21, X+
    5a44:	6d 91       	ld	r22, X+
    5a46:	7c 91       	ld	r23, X
    5a48:	d9 01       	movw	r26, r18
    5a4a:	4d 93       	st	X+, r20
    5a4c:	5d 93       	st	X+, r21
    5a4e:	6d 93       	st	X+, r22
    5a50:	7c 93       	st	X, r23
    5a52:	13 97       	sbiw	r26, 0x03	; 3
    5a54:	2c 5f       	subi	r18, 0xFC	; 252
    5a56:	3f 4f       	sbci	r19, 0xFF	; 255
    5a58:	de 01       	movw	r26, r28
    5a5a:	af 56       	subi	r26, 0x6F	; 111
    5a5c:	bf 4f       	sbci	r27, 0xFF	; 255
    5a5e:	4d 91       	ld	r20, X+
    5a60:	5d 91       	ld	r21, X+
    5a62:	6d 91       	ld	r22, X+
    5a64:	7c 91       	ld	r23, X
    5a66:	d9 01       	movw	r26, r18
    5a68:	4d 93       	st	X+, r20
    5a6a:	5d 93       	st	X+, r21
    5a6c:	6d 93       	st	X+, r22
    5a6e:	7c 93       	st	X, r23
    5a70:	13 97       	sbiw	r26, 0x03	; 3
    5a72:	2c 5f       	subi	r18, 0xFC	; 252
    5a74:	3f 4f       	sbci	r19, 0xFF	; 255
    5a76:	de 01       	movw	r26, r28
    5a78:	ab 56       	subi	r26, 0x6B	; 107
    5a7a:	bf 4f       	sbci	r27, 0xFF	; 255
    5a7c:	4d 91       	ld	r20, X+
    5a7e:	5d 91       	ld	r21, X+
    5a80:	6d 91       	ld	r22, X+
    5a82:	7c 91       	ld	r23, X
    5a84:	d9 01       	movw	r26, r18
    5a86:	4d 93       	st	X+, r20
    5a88:	5d 93       	st	X+, r21
    5a8a:	6d 93       	st	X+, r22
    5a8c:	7c 93       	st	X, r23
    5a8e:	13 97       	sbiw	r26, 0x03	; 3
    5a90:	2c 5f       	subi	r18, 0xFC	; 252
    5a92:	3f 4f       	sbci	r19, 0xFF	; 255
    5a94:	de 01       	movw	r26, r28
    5a96:	a7 56       	subi	r26, 0x67	; 103
    5a98:	bf 4f       	sbci	r27, 0xFF	; 255
    5a9a:	4d 91       	ld	r20, X+
    5a9c:	5d 91       	ld	r21, X+
    5a9e:	6d 91       	ld	r22, X+
    5aa0:	7c 91       	ld	r23, X
    5aa2:	d9 01       	movw	r26, r18
    5aa4:	4d 93       	st	X+, r20
    5aa6:	5d 93       	st	X+, r21
    5aa8:	6d 93       	st	X+, r22
    5aaa:	7c 93       	st	X, r23
    5aac:	13 97       	sbiw	r26, 0x03	; 3
    5aae:	2c 5f       	subi	r18, 0xFC	; 252
    5ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ab2:	de 01       	movw	r26, r28
    5ab4:	a3 56       	subi	r26, 0x63	; 99
    5ab6:	bf 4f       	sbci	r27, 0xFF	; 255
    5ab8:	4d 91       	ld	r20, X+
    5aba:	5d 91       	ld	r21, X+
    5abc:	6d 91       	ld	r22, X+
    5abe:	7c 91       	ld	r23, X
    5ac0:	d9 01       	movw	r26, r18
    5ac2:	4d 93       	st	X+, r20
    5ac4:	5d 93       	st	X+, r21
    5ac6:	6d 93       	st	X+, r22
    5ac8:	7c 93       	st	X, r23
    5aca:	13 97       	sbiw	r26, 0x03	; 3
    5acc:	2c 5f       	subi	r18, 0xFC	; 252
    5ace:	3f 4f       	sbci	r19, 0xFF	; 255
    5ad0:	de 01       	movw	r26, r28
    5ad2:	af 55       	subi	r26, 0x5F	; 95
    5ad4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ad6:	4d 91       	ld	r20, X+
    5ad8:	5d 91       	ld	r21, X+
    5ada:	6d 91       	ld	r22, X+
    5adc:	7c 91       	ld	r23, X
    5ade:	d9 01       	movw	r26, r18
    5ae0:	4d 93       	st	X+, r20
    5ae2:	5d 93       	st	X+, r21
    5ae4:	6d 93       	st	X+, r22
    5ae6:	7c 93       	st	X, r23
    5ae8:	13 97       	sbiw	r26, 0x03	; 3
    5aea:	2c 5f       	subi	r18, 0xFC	; 252
    5aec:	3f 4f       	sbci	r19, 0xFF	; 255
    5aee:	de 01       	movw	r26, r28
    5af0:	ab 55       	subi	r26, 0x5B	; 91
    5af2:	bf 4f       	sbci	r27, 0xFF	; 255
    5af4:	4d 91       	ld	r20, X+
    5af6:	5d 91       	ld	r21, X+
    5af8:	6d 91       	ld	r22, X+
    5afa:	7c 91       	ld	r23, X
    5afc:	d9 01       	movw	r26, r18
    5afe:	4d 93       	st	X+, r20
    5b00:	5d 93       	st	X+, r21
    5b02:	6d 93       	st	X+, r22
    5b04:	7c 93       	st	X, r23
    5b06:	13 97       	sbiw	r26, 0x03	; 3
    5b08:	2c 5f       	subi	r18, 0xFC	; 252
    5b0a:	3f 4f       	sbci	r19, 0xFF	; 255
    5b0c:	de 01       	movw	r26, r28
    5b0e:	a7 55       	subi	r26, 0x57	; 87
    5b10:	bf 4f       	sbci	r27, 0xFF	; 255
    5b12:	4d 91       	ld	r20, X+
    5b14:	5d 91       	ld	r21, X+
    5b16:	6d 91       	ld	r22, X+
    5b18:	7c 91       	ld	r23, X
    5b1a:	d9 01       	movw	r26, r18
    5b1c:	4d 93       	st	X+, r20
    5b1e:	5d 93       	st	X+, r21
    5b20:	6d 93       	st	X+, r22
    5b22:	7c 93       	st	X, r23
    5b24:	13 97       	sbiw	r26, 0x03	; 3
    5b26:	2c 5f       	subi	r18, 0xFC	; 252
    5b28:	3f 4f       	sbci	r19, 0xFF	; 255
    5b2a:	de 01       	movw	r26, r28
    5b2c:	a3 55       	subi	r26, 0x53	; 83
    5b2e:	bf 4f       	sbci	r27, 0xFF	; 255
    5b30:	4d 91       	ld	r20, X+
    5b32:	5d 91       	ld	r21, X+
    5b34:	6d 91       	ld	r22, X+
    5b36:	7c 91       	ld	r23, X
    5b38:	d9 01       	movw	r26, r18
    5b3a:	4d 93       	st	X+, r20
    5b3c:	5d 93       	st	X+, r21
    5b3e:	6d 93       	st	X+, r22
    5b40:	7c 93       	st	X, r23
    5b42:	13 97       	sbiw	r26, 0x03	; 3
    5b44:	2c 5f       	subi	r18, 0xFC	; 252
    5b46:	3f 4f       	sbci	r19, 0xFF	; 255
    5b48:	de 01       	movw	r26, r28
    5b4a:	af 54       	subi	r26, 0x4F	; 79
    5b4c:	bf 4f       	sbci	r27, 0xFF	; 255
    5b4e:	4d 91       	ld	r20, X+
    5b50:	5d 91       	ld	r21, X+
    5b52:	6d 91       	ld	r22, X+
    5b54:	7c 91       	ld	r23, X
    5b56:	d9 01       	movw	r26, r18
    5b58:	4d 93       	st	X+, r20
    5b5a:	5d 93       	st	X+, r21
    5b5c:	6d 93       	st	X+, r22
    5b5e:	7c 93       	st	X, r23
    5b60:	13 97       	sbiw	r26, 0x03	; 3
    5b62:	2c 5f       	subi	r18, 0xFC	; 252
    5b64:	3f 4f       	sbci	r19, 0xFF	; 255
    5b66:	de 01       	movw	r26, r28
    5b68:	ab 54       	subi	r26, 0x4B	; 75
    5b6a:	bf 4f       	sbci	r27, 0xFF	; 255
    5b6c:	4d 91       	ld	r20, X+
    5b6e:	5d 91       	ld	r21, X+
    5b70:	6d 91       	ld	r22, X+
    5b72:	7c 91       	ld	r23, X
    5b74:	d9 01       	movw	r26, r18
    5b76:	4d 93       	st	X+, r20
    5b78:	5d 93       	st	X+, r21
    5b7a:	6d 93       	st	X+, r22
    5b7c:	7c 93       	st	X, r23
    5b7e:	13 97       	sbiw	r26, 0x03	; 3
    5b80:	2c 5f       	subi	r18, 0xFC	; 252
    5b82:	3f 4f       	sbci	r19, 0xFF	; 255
    5b84:	de 01       	movw	r26, r28
    5b86:	a7 54       	subi	r26, 0x47	; 71
    5b88:	bf 4f       	sbci	r27, 0xFF	; 255
    5b8a:	4d 91       	ld	r20, X+
    5b8c:	5d 91       	ld	r21, X+
    5b8e:	6d 91       	ld	r22, X+
    5b90:	7c 91       	ld	r23, X
    5b92:	d9 01       	movw	r26, r18
    5b94:	4d 93       	st	X+, r20
    5b96:	5d 93       	st	X+, r21
    5b98:	6d 93       	st	X+, r22
    5b9a:	7c 93       	st	X, r23
    5b9c:	13 97       	sbiw	r26, 0x03	; 3
    5b9e:	2c 5f       	subi	r18, 0xFC	; 252
    5ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ba2:	de 01       	movw	r26, r28
    5ba4:	a3 54       	subi	r26, 0x43	; 67
    5ba6:	bf 4f       	sbci	r27, 0xFF	; 255
    5ba8:	4d 91       	ld	r20, X+
    5baa:	5d 91       	ld	r21, X+
    5bac:	6d 91       	ld	r22, X+
    5bae:	7c 91       	ld	r23, X
    5bb0:	d9 01       	movw	r26, r18
    5bb2:	4d 93       	st	X+, r20
    5bb4:	5d 93       	st	X+, r21
    5bb6:	6d 93       	st	X+, r22
    5bb8:	7c 93       	st	X, r23
    5bba:	13 97       	sbiw	r26, 0x03	; 3
    5bbc:	2c 5f       	subi	r18, 0xFC	; 252
    5bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5bc0:	de 01       	movw	r26, r28
    5bc2:	af 53       	subi	r26, 0x3F	; 63
    5bc4:	bf 4f       	sbci	r27, 0xFF	; 255
    5bc6:	4d 91       	ld	r20, X+
    5bc8:	5d 91       	ld	r21, X+
    5bca:	6d 91       	ld	r22, X+
    5bcc:	7c 91       	ld	r23, X
    5bce:	d9 01       	movw	r26, r18
    5bd0:	4d 93       	st	X+, r20
    5bd2:	5d 93       	st	X+, r21
    5bd4:	6d 93       	st	X+, r22
    5bd6:	7c 93       	st	X, r23
    5bd8:	13 97       	sbiw	r26, 0x03	; 3
    5bda:	2c 5f       	subi	r18, 0xFC	; 252
    5bdc:	3f 4f       	sbci	r19, 0xFF	; 255
    5bde:	de 01       	movw	r26, r28
    5be0:	ab 53       	subi	r26, 0x3B	; 59
    5be2:	bf 4f       	sbci	r27, 0xFF	; 255
    5be4:	4d 91       	ld	r20, X+
    5be6:	5d 91       	ld	r21, X+
    5be8:	6d 91       	ld	r22, X+
    5bea:	7c 91       	ld	r23, X
    5bec:	d9 01       	movw	r26, r18
    5bee:	4d 93       	st	X+, r20
    5bf0:	5d 93       	st	X+, r21
    5bf2:	6d 93       	st	X+, r22
    5bf4:	7c 93       	st	X, r23
    5bf6:	13 97       	sbiw	r26, 0x03	; 3
    5bf8:	2c 5f       	subi	r18, 0xFC	; 252
    5bfa:	3f 4f       	sbci	r19, 0xFF	; 255
    5bfc:	de 01       	movw	r26, r28
    5bfe:	a7 53       	subi	r26, 0x37	; 55
    5c00:	bf 4f       	sbci	r27, 0xFF	; 255
    5c02:	4d 91       	ld	r20, X+
    5c04:	5d 91       	ld	r21, X+
    5c06:	6d 91       	ld	r22, X+
    5c08:	7c 91       	ld	r23, X
    5c0a:	d9 01       	movw	r26, r18
    5c0c:	4d 93       	st	X+, r20
    5c0e:	5d 93       	st	X+, r21
    5c10:	6d 93       	st	X+, r22
    5c12:	7c 93       	st	X, r23
    5c14:	13 97       	sbiw	r26, 0x03	; 3
    5c16:	2c 5f       	subi	r18, 0xFC	; 252
    5c18:	3f 4f       	sbci	r19, 0xFF	; 255
    5c1a:	de 01       	movw	r26, r28
    5c1c:	a3 53       	subi	r26, 0x33	; 51
    5c1e:	bf 4f       	sbci	r27, 0xFF	; 255
    5c20:	4d 91       	ld	r20, X+
    5c22:	5d 91       	ld	r21, X+
    5c24:	6d 91       	ld	r22, X+
    5c26:	7c 91       	ld	r23, X
    5c28:	d9 01       	movw	r26, r18
    5c2a:	4d 93       	st	X+, r20
    5c2c:	5d 93       	st	X+, r21
    5c2e:	6d 93       	st	X+, r22
    5c30:	7c 93       	st	X, r23
    5c32:	13 97       	sbiw	r26, 0x03	; 3
    5c34:	2c 5f       	subi	r18, 0xFC	; 252
    5c36:	3f 4f       	sbci	r19, 0xFF	; 255
    5c38:	de 01       	movw	r26, r28
    5c3a:	af 52       	subi	r26, 0x2F	; 47
    5c3c:	bf 4f       	sbci	r27, 0xFF	; 255
    5c3e:	4d 91       	ld	r20, X+
    5c40:	5d 91       	ld	r21, X+
    5c42:	6d 91       	ld	r22, X+
    5c44:	7c 91       	ld	r23, X
    5c46:	d9 01       	movw	r26, r18
    5c48:	4d 93       	st	X+, r20
    5c4a:	5d 93       	st	X+, r21
    5c4c:	6d 93       	st	X+, r22
    5c4e:	7c 93       	st	X, r23
    5c50:	13 97       	sbiw	r26, 0x03	; 3
    5c52:	2c 5f       	subi	r18, 0xFC	; 252
    5c54:	3f 4f       	sbci	r19, 0xFF	; 255
    5c56:	de 01       	movw	r26, r28
    5c58:	ab 52       	subi	r26, 0x2B	; 43
    5c5a:	bf 4f       	sbci	r27, 0xFF	; 255
    5c5c:	4d 91       	ld	r20, X+
    5c5e:	5d 91       	ld	r21, X+
    5c60:	6d 91       	ld	r22, X+
    5c62:	7c 91       	ld	r23, X
    5c64:	d9 01       	movw	r26, r18
    5c66:	4d 93       	st	X+, r20
    5c68:	5d 93       	st	X+, r21
    5c6a:	6d 93       	st	X+, r22
    5c6c:	7c 93       	st	X, r23
    5c6e:	13 97       	sbiw	r26, 0x03	; 3
    5c70:	2c 5f       	subi	r18, 0xFC	; 252
    5c72:	3f 4f       	sbci	r19, 0xFF	; 255
    5c74:	de 01       	movw	r26, r28
    5c76:	a7 52       	subi	r26, 0x27	; 39
    5c78:	bf 4f       	sbci	r27, 0xFF	; 255
    5c7a:	4d 91       	ld	r20, X+
    5c7c:	5d 91       	ld	r21, X+
    5c7e:	6d 91       	ld	r22, X+
    5c80:	7c 91       	ld	r23, X
    5c82:	d9 01       	movw	r26, r18
    5c84:	4d 93       	st	X+, r20
    5c86:	5d 93       	st	X+, r21
    5c88:	6d 93       	st	X+, r22
    5c8a:	7c 93       	st	X, r23
    5c8c:	13 97       	sbiw	r26, 0x03	; 3
    5c8e:	2c 5f       	subi	r18, 0xFC	; 252
    5c90:	3f 4f       	sbci	r19, 0xFF	; 255
    5c92:	de 01       	movw	r26, r28
    5c94:	a3 52       	subi	r26, 0x23	; 35
    5c96:	bf 4f       	sbci	r27, 0xFF	; 255
    5c98:	4d 91       	ld	r20, X+
    5c9a:	5d 91       	ld	r21, X+
    5c9c:	6d 91       	ld	r22, X+
    5c9e:	7c 91       	ld	r23, X
    5ca0:	d9 01       	movw	r26, r18
    5ca2:	4d 93       	st	X+, r20
    5ca4:	5d 93       	st	X+, r21
    5ca6:	6d 93       	st	X+, r22
    5ca8:	7c 93       	st	X, r23
    5caa:	13 97       	sbiw	r26, 0x03	; 3
    5cac:	2c 5f       	subi	r18, 0xFC	; 252
    5cae:	3f 4f       	sbci	r19, 0xFF	; 255
    5cb0:	de 01       	movw	r26, r28
    5cb2:	af 51       	subi	r26, 0x1F	; 31
    5cb4:	bf 4f       	sbci	r27, 0xFF	; 255
    5cb6:	4d 91       	ld	r20, X+
    5cb8:	5d 91       	ld	r21, X+
    5cba:	6d 91       	ld	r22, X+
    5cbc:	7c 91       	ld	r23, X
    5cbe:	d9 01       	movw	r26, r18
    5cc0:	4d 93       	st	X+, r20
    5cc2:	5d 93       	st	X+, r21
    5cc4:	6d 93       	st	X+, r22
    5cc6:	7c 93       	st	X, r23
    5cc8:	13 97       	sbiw	r26, 0x03	; 3
    5cca:	2c 5f       	subi	r18, 0xFC	; 252
    5ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    5cce:	de 01       	movw	r26, r28
    5cd0:	ab 51       	subi	r26, 0x1B	; 27
    5cd2:	bf 4f       	sbci	r27, 0xFF	; 255
    5cd4:	4d 91       	ld	r20, X+
    5cd6:	5d 91       	ld	r21, X+
    5cd8:	6d 91       	ld	r22, X+
    5cda:	7c 91       	ld	r23, X
    5cdc:	d9 01       	movw	r26, r18
    5cde:	4d 93       	st	X+, r20
    5ce0:	5d 93       	st	X+, r21
    5ce2:	6d 93       	st	X+, r22
    5ce4:	7c 93       	st	X, r23
    5ce6:	13 97       	sbiw	r26, 0x03	; 3
    5ce8:	2c 5f       	subi	r18, 0xFC	; 252
    5cea:	3f 4f       	sbci	r19, 0xFF	; 255
    5cec:	de 01       	movw	r26, r28
    5cee:	a7 51       	subi	r26, 0x17	; 23
    5cf0:	bf 4f       	sbci	r27, 0xFF	; 255
    5cf2:	4d 91       	ld	r20, X+
    5cf4:	5d 91       	ld	r21, X+
    5cf6:	6d 91       	ld	r22, X+
    5cf8:	7c 91       	ld	r23, X
    5cfa:	d9 01       	movw	r26, r18
    5cfc:	4d 93       	st	X+, r20
    5cfe:	5d 93       	st	X+, r21
    5d00:	6d 93       	st	X+, r22
    5d02:	7c 93       	st	X, r23
    5d04:	13 97       	sbiw	r26, 0x03	; 3
    5d06:	2c 5f       	subi	r18, 0xFC	; 252
    5d08:	3f 4f       	sbci	r19, 0xFF	; 255
    5d0a:	de 01       	movw	r26, r28
    5d0c:	a3 51       	subi	r26, 0x13	; 19
    5d0e:	bf 4f       	sbci	r27, 0xFF	; 255
    5d10:	4d 91       	ld	r20, X+
    5d12:	5d 91       	ld	r21, X+
    5d14:	6d 91       	ld	r22, X+
    5d16:	7c 91       	ld	r23, X
    5d18:	d9 01       	movw	r26, r18
    5d1a:	4d 93       	st	X+, r20
    5d1c:	5d 93       	st	X+, r21
    5d1e:	6d 93       	st	X+, r22
    5d20:	7c 93       	st	X, r23
    5d22:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5d24:	2c 5f       	subi	r18, 0xFC	; 252
    5d26:	3f 4f       	sbci	r19, 0xFF	; 255
    5d28:	de 01       	movw	r26, r28
    5d2a:	af 50       	subi	r26, 0x0F	; 15
    5d2c:	bf 4f       	sbci	r27, 0xFF	; 255
    5d2e:	4d 91       	ld	r20, X+
    5d30:	5d 91       	ld	r21, X+
    5d32:	6d 91       	ld	r22, X+
    5d34:	7c 91       	ld	r23, X
    5d36:	d9 01       	movw	r26, r18
    5d38:	4d 93       	st	X+, r20
    5d3a:	5d 93       	st	X+, r21
    5d3c:	6d 93       	st	X+, r22
    5d3e:	7c 93       	st	X, r23
    5d40:	13 97       	sbiw	r26, 0x03	; 3
    5d42:	2c 5f       	subi	r18, 0xFC	; 252
    5d44:	3f 4f       	sbci	r19, 0xFF	; 255
    5d46:	de 01       	movw	r26, r28
    5d48:	ab 50       	subi	r26, 0x0B	; 11
    5d4a:	bf 4f       	sbci	r27, 0xFF	; 255
    5d4c:	4d 91       	ld	r20, X+
    5d4e:	5d 91       	ld	r21, X+
    5d50:	6d 91       	ld	r22, X+
    5d52:	7c 91       	ld	r23, X
    5d54:	d9 01       	movw	r26, r18
    5d56:	4d 93       	st	X+, r20
    5d58:	5d 93       	st	X+, r21
    5d5a:	6d 93       	st	X+, r22
    5d5c:	7c 93       	st	X, r23
    5d5e:	13 97       	sbiw	r26, 0x03	; 3
    5d60:	2c 5f       	subi	r18, 0xFC	; 252
    5d62:	3f 4f       	sbci	r19, 0xFF	; 255
    5d64:	de 01       	movw	r26, r28
    5d66:	a7 50       	subi	r26, 0x07	; 7
    5d68:	bf 4f       	sbci	r27, 0xFF	; 255
    5d6a:	4d 91       	ld	r20, X+
    5d6c:	5d 91       	ld	r21, X+
    5d6e:	6d 91       	ld	r22, X+
    5d70:	7c 91       	ld	r23, X
    5d72:	d9 01       	movw	r26, r18
    5d74:	4d 93       	st	X+, r20
    5d76:	5d 93       	st	X+, r21
    5d78:	6d 93       	st	X+, r22
    5d7a:	7c 93       	st	X, r23
    5d7c:	13 97       	sbiw	r26, 0x03	; 3
    5d7e:	2c 5f       	subi	r18, 0xFC	; 252
    5d80:	3f 4f       	sbci	r19, 0xFF	; 255
    5d82:	de 01       	movw	r26, r28
    5d84:	a3 50       	subi	r26, 0x03	; 3
    5d86:	bf 4f       	sbci	r27, 0xFF	; 255
    5d88:	4d 91       	ld	r20, X+
    5d8a:	5d 91       	ld	r21, X+
    5d8c:	6d 91       	ld	r22, X+
    5d8e:	7c 91       	ld	r23, X
    5d90:	d9 01       	movw	r26, r18
    5d92:	4d 93       	st	X+, r20
    5d94:	5d 93       	st	X+, r21
    5d96:	6d 93       	st	X+, r22
    5d98:	7c 93       	st	X, r23
    5d9a:	13 97       	sbiw	r26, 0x03	; 3
    5d9c:	2c 5f       	subi	r18, 0xFC	; 252
    5d9e:	3f 4f       	sbci	r19, 0xFF	; 255
    5da0:	de 01       	movw	r26, r28
    5da2:	af 5f       	subi	r26, 0xFF	; 255
    5da4:	be 4f       	sbci	r27, 0xFE	; 254
    5da6:	4d 91       	ld	r20, X+
    5da8:	5d 91       	ld	r21, X+
    5daa:	6d 91       	ld	r22, X+
    5dac:	7c 91       	ld	r23, X
    5dae:	d9 01       	movw	r26, r18
    5db0:	4d 93       	st	X+, r20
    5db2:	5d 93       	st	X+, r21
    5db4:	6d 93       	st	X+, r22
    5db6:	7c 93       	st	X, r23
    5db8:	13 97       	sbiw	r26, 0x03	; 3
    5dba:	2c 5f       	subi	r18, 0xFC	; 252
    5dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    5dbe:	de 01       	movw	r26, r28
    5dc0:	ab 5f       	subi	r26, 0xFB	; 251
    5dc2:	be 4f       	sbci	r27, 0xFE	; 254
    5dc4:	4d 91       	ld	r20, X+
    5dc6:	5d 91       	ld	r21, X+
    5dc8:	6d 91       	ld	r22, X+
    5dca:	7c 91       	ld	r23, X
    5dcc:	d9 01       	movw	r26, r18
    5dce:	4d 93       	st	X+, r20
    5dd0:	5d 93       	st	X+, r21
    5dd2:	6d 93       	st	X+, r22
    5dd4:	7c 93       	st	X, r23
    5dd6:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5dd8:	2c 5f       	subi	r18, 0xFC	; 252
    5dda:	3f 4f       	sbci	r19, 0xFF	; 255
    5ddc:	de 01       	movw	r26, r28
    5dde:	a7 5f       	subi	r26, 0xF7	; 247
    5de0:	be 4f       	sbci	r27, 0xFE	; 254
    5de2:	4d 91       	ld	r20, X+
    5de4:	5d 91       	ld	r21, X+
    5de6:	6d 91       	ld	r22, X+
    5de8:	7c 91       	ld	r23, X
    5dea:	d9 01       	movw	r26, r18
    5dec:	4d 93       	st	X+, r20
    5dee:	5d 93       	st	X+, r21
    5df0:	6d 93       	st	X+, r22
    5df2:	7c 93       	st	X, r23
    5df4:	13 97       	sbiw	r26, 0x03	; 3
    5df6:	2c 5f       	subi	r18, 0xFC	; 252
    5df8:	3f 4f       	sbci	r19, 0xFF	; 255
    5dfa:	de 01       	movw	r26, r28
    5dfc:	a3 5f       	subi	r26, 0xF3	; 243
    5dfe:	be 4f       	sbci	r27, 0xFE	; 254
    5e00:	4d 91       	ld	r20, X+
    5e02:	5d 91       	ld	r21, X+
    5e04:	6d 91       	ld	r22, X+
    5e06:	7c 91       	ld	r23, X
    5e08:	d9 01       	movw	r26, r18
    5e0a:	4d 93       	st	X+, r20
    5e0c:	5d 93       	st	X+, r21
    5e0e:	6d 93       	st	X+, r22
    5e10:	7c 93       	st	X, r23
    5e12:	13 97       	sbiw	r26, 0x03	; 3
    5e14:	2c 5f       	subi	r18, 0xFC	; 252
    5e16:	3f 4f       	sbci	r19, 0xFF	; 255
    5e18:	de 01       	movw	r26, r28
    5e1a:	af 5e       	subi	r26, 0xEF	; 239
    5e1c:	be 4f       	sbci	r27, 0xFE	; 254
    5e1e:	4d 91       	ld	r20, X+
    5e20:	5d 91       	ld	r21, X+
    5e22:	6d 91       	ld	r22, X+
    5e24:	7c 91       	ld	r23, X
    5e26:	d9 01       	movw	r26, r18
    5e28:	4d 93       	st	X+, r20
    5e2a:	5d 93       	st	X+, r21
    5e2c:	6d 93       	st	X+, r22
    5e2e:	7c 93       	st	X, r23
    5e30:	13 97       	sbiw	r26, 0x03	; 3
    5e32:	2c 5f       	subi	r18, 0xFC	; 252
    5e34:	3f 4f       	sbci	r19, 0xFF	; 255
    5e36:	de 01       	movw	r26, r28
    5e38:	ab 5e       	subi	r26, 0xEB	; 235
    5e3a:	be 4f       	sbci	r27, 0xFE	; 254
    5e3c:	4d 91       	ld	r20, X+
    5e3e:	5d 91       	ld	r21, X+
    5e40:	6d 91       	ld	r22, X+
    5e42:	7c 91       	ld	r23, X
    5e44:	d9 01       	movw	r26, r18
    5e46:	4d 93       	st	X+, r20
    5e48:	5d 93       	st	X+, r21
    5e4a:	6d 93       	st	X+, r22
    5e4c:	7c 93       	st	X, r23
    5e4e:	13 97       	sbiw	r26, 0x03	; 3
    5e50:	2c 5f       	subi	r18, 0xFC	; 252
    5e52:	3f 4f       	sbci	r19, 0xFF	; 255
    5e54:	de 01       	movw	r26, r28
    5e56:	a7 5e       	subi	r26, 0xE7	; 231
    5e58:	be 4f       	sbci	r27, 0xFE	; 254
    5e5a:	4d 91       	ld	r20, X+
    5e5c:	5d 91       	ld	r21, X+
    5e5e:	6d 91       	ld	r22, X+
    5e60:	7c 91       	ld	r23, X
    5e62:	d9 01       	movw	r26, r18
    5e64:	4d 93       	st	X+, r20
    5e66:	5d 93       	st	X+, r21
    5e68:	6d 93       	st	X+, r22
    5e6a:	7c 93       	st	X, r23
    5e6c:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5e6e:	2c 5f       	subi	r18, 0xFC	; 252
    5e70:	3f 4f       	sbci	r19, 0xFF	; 255
    5e72:	de 01       	movw	r26, r28
    5e74:	a3 5e       	subi	r26, 0xE3	; 227
    5e76:	be 4f       	sbci	r27, 0xFE	; 254
    5e78:	4d 91       	ld	r20, X+
    5e7a:	5d 91       	ld	r21, X+
    5e7c:	6d 91       	ld	r22, X+
    5e7e:	7c 91       	ld	r23, X
    5e80:	d9 01       	movw	r26, r18
    5e82:	4d 93       	st	X+, r20
    5e84:	5d 93       	st	X+, r21
    5e86:	6d 93       	st	X+, r22
    5e88:	7c 93       	st	X, r23
    5e8a:	13 97       	sbiw	r26, 0x03	; 3
    5e8c:	2c 5f       	subi	r18, 0xFC	; 252
    5e8e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e90:	de 01       	movw	r26, r28
    5e92:	af 5d       	subi	r26, 0xDF	; 223
    5e94:	be 4f       	sbci	r27, 0xFE	; 254
    5e96:	4d 91       	ld	r20, X+
    5e98:	5d 91       	ld	r21, X+
    5e9a:	6d 91       	ld	r22, X+
    5e9c:	7c 91       	ld	r23, X
    5e9e:	d9 01       	movw	r26, r18
    5ea0:	4d 93       	st	X+, r20
    5ea2:	5d 93       	st	X+, r21
    5ea4:	6d 93       	st	X+, r22
    5ea6:	7c 93       	st	X, r23
    5ea8:	13 97       	sbiw	r26, 0x03	; 3
    5eaa:	2c 5f       	subi	r18, 0xFC	; 252
    5eac:	3f 4f       	sbci	r19, 0xFF	; 255
    5eae:	ce 01       	movw	r24, r28
    5eb0:	8b 5d       	subi	r24, 0xDB	; 219
    5eb2:	9e 4f       	sbci	r25, 0xFE	; 254
    5eb4:	dc 01       	movw	r26, r24
    5eb6:	4d 91       	ld	r20, X+
    5eb8:	5d 91       	ld	r21, X+
    5eba:	6d 91       	ld	r22, X+
    5ebc:	7c 91       	ld	r23, X
    5ebe:	d9 01       	movw	r26, r18
    5ec0:	4d 93       	st	X+, r20
    5ec2:	5d 93       	st	X+, r21
    5ec4:	6d 93       	st	X+, r22
    5ec6:	7c 93       	st	X, r23
    5ec8:	13 97       	sbiw	r26, 0x03	; 3
    5eca:	2c 5f       	subi	r18, 0xFC	; 252
    5ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    5ece:	04 96       	adiw	r24, 0x04	; 4
    5ed0:	dc 01       	movw	r26, r24
    5ed2:	4d 91       	ld	r20, X+
    5ed4:	5d 91       	ld	r21, X+
    5ed6:	6d 91       	ld	r22, X+
    5ed8:	7c 91       	ld	r23, X
    5eda:	d9 01       	movw	r26, r18
    5edc:	4d 93       	st	X+, r20
    5ede:	5d 93       	st	X+, r21
    5ee0:	6d 93       	st	X+, r22
    5ee2:	7c 93       	st	X, r23
    5ee4:	13 97       	sbiw	r26, 0x03	; 3
    5ee6:	14 96       	adiw	r26, 0x04	; 4
    5ee8:	c3 5d       	subi	r28, 0xD3	; 211
    5eea:	de 4f       	sbci	r29, 0xFE	; 254
    5eec:	48 81       	ld	r20, Y
    5eee:	59 81       	ldd	r21, Y+1	; 0x01
    5ef0:	6a 81       	ldd	r22, Y+2	; 0x02
    5ef2:	7b 81       	ldd	r23, Y+3	; 0x03
    5ef4:	4d 93       	st	X+, r20
    5ef6:	5d 93       	st	X+, r21
    5ef8:	6d 93       	st	X+, r22
    5efa:	7c 93       	st	X, r23
    5efc:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
				
	return msg;
}
    5efe:	cf 01       	movw	r24, r30
    5f00:	df 91       	pop	r29
    5f02:	cf 91       	pop	r28
    5f04:	08 95       	ret

00005f06 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>:

void SystemTelemetryMessage::buildMessage(byte *message)
{
    5f06:	cf 93       	push	r28
    5f08:	df 93       	push	r29
    5f0a:	fc 01       	movw	r30, r24
    5f0c:	db 01       	movw	r26, r22
	if (message != NULL)
    5f0e:	10 97       	sbiw	r26, 0x00	; 0
    5f10:	09 f4       	brne	.+2      	; 0x5f14 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0xe>
    5f12:	a7 c3       	rjmp	.+1870   	; 0x6662 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0x75c>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    5f14:	8c 91       	ld	r24, X
    5f16:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5f18:	11 96       	adiw	r26, 0x01	; 1
    5f1a:	4d 91       	ld	r20, X+
    5f1c:	5d 91       	ld	r21, X+
    5f1e:	6d 91       	ld	r22, X+
    5f20:	7c 91       	ld	r23, X
    5f22:	14 97       	sbiw	r26, 0x04	; 4
    5f24:	45 83       	std	Z+5, r20	; 0x05
    5f26:	56 83       	std	Z+6, r21	; 0x06
    5f28:	67 83       	std	Z+7, r22	; 0x07
    5f2a:	70 87       	std	Z+8, r23	; 0x08
    5f2c:	15 96       	adiw	r26, 0x05	; 5
    5f2e:	4d 91       	ld	r20, X+
    5f30:	5d 91       	ld	r21, X+
    5f32:	6d 91       	ld	r22, X+
    5f34:	7c 91       	ld	r23, X
    5f36:	18 97       	sbiw	r26, 0x08	; 8
    5f38:	41 87       	std	Z+9, r20	; 0x09
    5f3a:	52 87       	std	Z+10, r21	; 0x0a
    5f3c:	63 87       	std	Z+11, r22	; 0x0b
    5f3e:	74 87       	std	Z+12, r23	; 0x0c
    5f40:	19 96       	adiw	r26, 0x09	; 9
    5f42:	4d 91       	ld	r20, X+
    5f44:	5d 91       	ld	r21, X+
    5f46:	6d 91       	ld	r22, X+
    5f48:	7c 91       	ld	r23, X
    5f4a:	1c 97       	sbiw	r26, 0x0c	; 12
    5f4c:	45 87       	std	Z+13, r20	; 0x0d
    5f4e:	56 87       	std	Z+14, r21	; 0x0e
    5f50:	67 87       	std	Z+15, r22	; 0x0f
    5f52:	70 8b       	std	Z+16, r23	; 0x10
    5f54:	1d 96       	adiw	r26, 0x0d	; 13
    5f56:	4d 91       	ld	r20, X+
    5f58:	5d 91       	ld	r21, X+
    5f5a:	6d 91       	ld	r22, X+
    5f5c:	7c 91       	ld	r23, X
    5f5e:	50 97       	sbiw	r26, 0x10	; 16
    5f60:	41 8b       	std	Z+17, r20	; 0x11
    5f62:	52 8b       	std	Z+18, r21	; 0x12
    5f64:	63 8b       	std	Z+19, r22	; 0x13
    5f66:	74 8b       	std	Z+20, r23	; 0x14
    5f68:	51 96       	adiw	r26, 0x11	; 17
    5f6a:	4d 91       	ld	r20, X+
    5f6c:	5d 91       	ld	r21, X+
    5f6e:	6d 91       	ld	r22, X+
    5f70:	7c 91       	ld	r23, X
    5f72:	54 97       	sbiw	r26, 0x14	; 20
    5f74:	45 8b       	std	Z+21, r20	; 0x15
    5f76:	56 8b       	std	Z+22, r21	; 0x16
    5f78:	67 8b       	std	Z+23, r22	; 0x17
    5f7a:	70 8f       	std	Z+24, r23	; 0x18
    5f7c:	55 96       	adiw	r26, 0x15	; 21
    5f7e:	4d 91       	ld	r20, X+
    5f80:	5d 91       	ld	r21, X+
    5f82:	6d 91       	ld	r22, X+
    5f84:	7c 91       	ld	r23, X
    5f86:	58 97       	sbiw	r26, 0x18	; 24
    5f88:	41 8f       	std	Z+25, r20	; 0x19
    5f8a:	52 8f       	std	Z+26, r21	; 0x1a
    5f8c:	63 8f       	std	Z+27, r22	; 0x1b
    5f8e:	74 8f       	std	Z+28, r23	; 0x1c
    5f90:	59 96       	adiw	r26, 0x19	; 25
    5f92:	4d 91       	ld	r20, X+
    5f94:	5d 91       	ld	r21, X+
    5f96:	6d 91       	ld	r22, X+
    5f98:	7c 91       	ld	r23, X
    5f9a:	5c 97       	sbiw	r26, 0x1c	; 28
    5f9c:	45 8f       	std	Z+29, r20	; 0x1d
    5f9e:	56 8f       	std	Z+30, r21	; 0x1e
    5fa0:	67 8f       	std	Z+31, r22	; 0x1f
    5fa2:	70 a3       	std	Z+32, r23	; 0x20
    5fa4:	5d 96       	adiw	r26, 0x1d	; 29
    5fa6:	4d 91       	ld	r20, X+
    5fa8:	5d 91       	ld	r21, X+
    5faa:	6d 91       	ld	r22, X+
    5fac:	7c 91       	ld	r23, X
    5fae:	90 97       	sbiw	r26, 0x20	; 32
    5fb0:	41 a3       	std	Z+33, r20	; 0x21
    5fb2:	52 a3       	std	Z+34, r21	; 0x22
    5fb4:	63 a3       	std	Z+35, r22	; 0x23
    5fb6:	74 a3       	std	Z+36, r23	; 0x24
    5fb8:	91 96       	adiw	r26, 0x21	; 33
    5fba:	4d 91       	ld	r20, X+
    5fbc:	5d 91       	ld	r21, X+
    5fbe:	6d 91       	ld	r22, X+
    5fc0:	7c 91       	ld	r23, X
    5fc2:	94 97       	sbiw	r26, 0x24	; 36
    5fc4:	45 a3       	std	Z+37, r20	; 0x25
    5fc6:	56 a3       	std	Z+38, r21	; 0x26
    5fc8:	67 a3       	std	Z+39, r22	; 0x27
    5fca:	70 a7       	std	Z+40, r23	; 0x28
    5fcc:	95 96       	adiw	r26, 0x25	; 37
    5fce:	4d 91       	ld	r20, X+
    5fd0:	5d 91       	ld	r21, X+
    5fd2:	6d 91       	ld	r22, X+
    5fd4:	7c 91       	ld	r23, X
    5fd6:	98 97       	sbiw	r26, 0x28	; 40
    5fd8:	41 a7       	std	Z+41, r20	; 0x29
    5fda:	52 a7       	std	Z+42, r21	; 0x2a
    5fdc:	63 a7       	std	Z+43, r22	; 0x2b
    5fde:	74 a7       	std	Z+44, r23	; 0x2c
    5fe0:	99 96       	adiw	r26, 0x29	; 41
    5fe2:	4d 91       	ld	r20, X+
    5fe4:	5d 91       	ld	r21, X+
    5fe6:	6d 91       	ld	r22, X+
    5fe8:	7c 91       	ld	r23, X
    5fea:	9c 97       	sbiw	r26, 0x2c	; 44
    5fec:	45 a7       	std	Z+45, r20	; 0x2d
    5fee:	56 a7       	std	Z+46, r21	; 0x2e
    5ff0:	67 a7       	std	Z+47, r22	; 0x2f
    5ff2:	70 ab       	std	Z+48, r23	; 0x30
    5ff4:	9d 96       	adiw	r26, 0x2d	; 45
    5ff6:	4d 91       	ld	r20, X+
    5ff8:	5d 91       	ld	r21, X+
    5ffa:	6d 91       	ld	r22, X+
    5ffc:	7c 91       	ld	r23, X
    5ffe:	d0 97       	sbiw	r26, 0x30	; 48
    6000:	41 ab       	std	Z+49, r20	; 0x31
    6002:	52 ab       	std	Z+50, r21	; 0x32
    6004:	63 ab       	std	Z+51, r22	; 0x33
    6006:	74 ab       	std	Z+52, r23	; 0x34
    6008:	d1 96       	adiw	r26, 0x31	; 49
    600a:	4d 91       	ld	r20, X+
    600c:	5d 91       	ld	r21, X+
    600e:	6d 91       	ld	r22, X+
    6010:	7c 91       	ld	r23, X
    6012:	d4 97       	sbiw	r26, 0x34	; 52
    6014:	45 ab       	std	Z+53, r20	; 0x35
    6016:	56 ab       	std	Z+54, r21	; 0x36
    6018:	67 ab       	std	Z+55, r22	; 0x37
    601a:	70 af       	std	Z+56, r23	; 0x38
    601c:	d5 96       	adiw	r26, 0x35	; 53
    601e:	4d 91       	ld	r20, X+
    6020:	5d 91       	ld	r21, X+
    6022:	6d 91       	ld	r22, X+
    6024:	7c 91       	ld	r23, X
    6026:	d8 97       	sbiw	r26, 0x38	; 56
    6028:	41 af       	std	Z+57, r20	; 0x39
    602a:	52 af       	std	Z+58, r21	; 0x3a
    602c:	63 af       	std	Z+59, r22	; 0x3b
    602e:	74 af       	std	Z+60, r23	; 0x3c
    6030:	ef 01       	movw	r28, r30
    6032:	ed 96       	adiw	r28, 0x3d	; 61
    6034:	d9 96       	adiw	r26, 0x39	; 57
    6036:	4d 91       	ld	r20, X+
    6038:	5d 91       	ld	r21, X+
    603a:	6d 91       	ld	r22, X+
    603c:	7c 91       	ld	r23, X
    603e:	dc 97       	sbiw	r26, 0x3c	; 60
    6040:	48 83       	st	Y, r20
    6042:	59 83       	std	Y+1, r21	; 0x01
    6044:	6a 83       	std	Y+2, r22	; 0x02
    6046:	7b 83       	std	Y+3, r23	; 0x03
    6048:	9f 01       	movw	r18, r30
    604a:	2f 5b       	subi	r18, 0xBF	; 191
    604c:	3f 4f       	sbci	r19, 0xFF	; 255
    604e:	cd 01       	movw	r24, r26
    6050:	cd 96       	adiw	r24, 0x3d	; 61
    6052:	ec 01       	movw	r28, r24
    6054:	48 81       	ld	r20, Y
    6056:	59 81       	ldd	r21, Y+1	; 0x01
    6058:	6a 81       	ldd	r22, Y+2	; 0x02
    605a:	7b 81       	ldd	r23, Y+3	; 0x03
    605c:	e9 01       	movw	r28, r18
    605e:	48 83       	st	Y, r20
    6060:	59 83       	std	Y+1, r21	; 0x01
    6062:	6a 83       	std	Y+2, r22	; 0x02
    6064:	7b 83       	std	Y+3, r23	; 0x03
    6066:	2c 5f       	subi	r18, 0xFC	; 252
    6068:	3f 4f       	sbci	r19, 0xFF	; 255
    606a:	04 96       	adiw	r24, 0x04	; 4
    606c:	ec 01       	movw	r28, r24
    606e:	48 81       	ld	r20, Y
    6070:	59 81       	ldd	r21, Y+1	; 0x01
    6072:	6a 81       	ldd	r22, Y+2	; 0x02
    6074:	7b 81       	ldd	r23, Y+3	; 0x03
    6076:	e9 01       	movw	r28, r18
    6078:	48 83       	st	Y, r20
    607a:	59 83       	std	Y+1, r21	; 0x01
    607c:	6a 83       	std	Y+2, r22	; 0x02
    607e:	7b 83       	std	Y+3, r23	; 0x03
    6080:	2c 5f       	subi	r18, 0xFC	; 252
    6082:	3f 4f       	sbci	r19, 0xFF	; 255
    6084:	04 96       	adiw	r24, 0x04	; 4
    6086:	ec 01       	movw	r28, r24
    6088:	48 81       	ld	r20, Y
    608a:	59 81       	ldd	r21, Y+1	; 0x01
    608c:	6a 81       	ldd	r22, Y+2	; 0x02
    608e:	7b 81       	ldd	r23, Y+3	; 0x03
    6090:	e9 01       	movw	r28, r18
    6092:	48 83       	st	Y, r20
    6094:	59 83       	std	Y+1, r21	; 0x01
    6096:	6a 83       	std	Y+2, r22	; 0x02
    6098:	7b 83       	std	Y+3, r23	; 0x03
    609a:	2c 5f       	subi	r18, 0xFC	; 252
    609c:	3f 4f       	sbci	r19, 0xFF	; 255
    609e:	04 96       	adiw	r24, 0x04	; 4
    60a0:	ec 01       	movw	r28, r24
    60a2:	48 81       	ld	r20, Y
    60a4:	59 81       	ldd	r21, Y+1	; 0x01
    60a6:	6a 81       	ldd	r22, Y+2	; 0x02
    60a8:	7b 81       	ldd	r23, Y+3	; 0x03
    60aa:	e9 01       	movw	r28, r18
    60ac:	48 83       	st	Y, r20
    60ae:	59 83       	std	Y+1, r21	; 0x01
    60b0:	6a 83       	std	Y+2, r22	; 0x02
    60b2:	7b 83       	std	Y+3, r23	; 0x03
    60b4:	2c 5f       	subi	r18, 0xFC	; 252
    60b6:	3f 4f       	sbci	r19, 0xFF	; 255
    60b8:	04 96       	adiw	r24, 0x04	; 4
    60ba:	ec 01       	movw	r28, r24
    60bc:	48 81       	ld	r20, Y
    60be:	59 81       	ldd	r21, Y+1	; 0x01
    60c0:	6a 81       	ldd	r22, Y+2	; 0x02
    60c2:	7b 81       	ldd	r23, Y+3	; 0x03
    60c4:	e9 01       	movw	r28, r18
    60c6:	48 83       	st	Y, r20
    60c8:	59 83       	std	Y+1, r21	; 0x01
    60ca:	6a 83       	std	Y+2, r22	; 0x02
    60cc:	7b 83       	std	Y+3, r23	; 0x03
    60ce:	2c 5f       	subi	r18, 0xFC	; 252
    60d0:	3f 4f       	sbci	r19, 0xFF	; 255
    60d2:	04 96       	adiw	r24, 0x04	; 4
    60d4:	ec 01       	movw	r28, r24
    60d6:	48 81       	ld	r20, Y
    60d8:	59 81       	ldd	r21, Y+1	; 0x01
    60da:	6a 81       	ldd	r22, Y+2	; 0x02
    60dc:	7b 81       	ldd	r23, Y+3	; 0x03
    60de:	e9 01       	movw	r28, r18
    60e0:	48 83       	st	Y, r20
    60e2:	59 83       	std	Y+1, r21	; 0x01
    60e4:	6a 83       	std	Y+2, r22	; 0x02
    60e6:	7b 83       	std	Y+3, r23	; 0x03
    60e8:	2c 5f       	subi	r18, 0xFC	; 252
    60ea:	3f 4f       	sbci	r19, 0xFF	; 255
    60ec:	04 96       	adiw	r24, 0x04	; 4
    60ee:	ec 01       	movw	r28, r24
    60f0:	48 81       	ld	r20, Y
    60f2:	59 81       	ldd	r21, Y+1	; 0x01
    60f4:	6a 81       	ldd	r22, Y+2	; 0x02
    60f6:	7b 81       	ldd	r23, Y+3	; 0x03
    60f8:	e9 01       	movw	r28, r18
    60fa:	48 83       	st	Y, r20
    60fc:	59 83       	std	Y+1, r21	; 0x01
    60fe:	6a 83       	std	Y+2, r22	; 0x02
    6100:	7b 83       	std	Y+3, r23	; 0x03
    6102:	2c 5f       	subi	r18, 0xFC	; 252
    6104:	3f 4f       	sbci	r19, 0xFF	; 255
    6106:	04 96       	adiw	r24, 0x04	; 4
    6108:	ec 01       	movw	r28, r24
    610a:	48 81       	ld	r20, Y
    610c:	59 81       	ldd	r21, Y+1	; 0x01
    610e:	6a 81       	ldd	r22, Y+2	; 0x02
    6110:	7b 81       	ldd	r23, Y+3	; 0x03
    6112:	e9 01       	movw	r28, r18
    6114:	48 83       	st	Y, r20
    6116:	59 83       	std	Y+1, r21	; 0x01
    6118:	6a 83       	std	Y+2, r22	; 0x02
    611a:	7b 83       	std	Y+3, r23	; 0x03
    611c:	2c 5f       	subi	r18, 0xFC	; 252
    611e:	3f 4f       	sbci	r19, 0xFF	; 255
    6120:	04 96       	adiw	r24, 0x04	; 4
    6122:	ec 01       	movw	r28, r24
    6124:	48 81       	ld	r20, Y
    6126:	59 81       	ldd	r21, Y+1	; 0x01
    6128:	6a 81       	ldd	r22, Y+2	; 0x02
    612a:	7b 81       	ldd	r23, Y+3	; 0x03
    612c:	e9 01       	movw	r28, r18
    612e:	48 83       	st	Y, r20
    6130:	59 83       	std	Y+1, r21	; 0x01
    6132:	6a 83       	std	Y+2, r22	; 0x02
    6134:	7b 83       	std	Y+3, r23	; 0x03
    6136:	2c 5f       	subi	r18, 0xFC	; 252
    6138:	3f 4f       	sbci	r19, 0xFF	; 255
    613a:	04 96       	adiw	r24, 0x04	; 4
    613c:	ec 01       	movw	r28, r24
    613e:	48 81       	ld	r20, Y
    6140:	59 81       	ldd	r21, Y+1	; 0x01
    6142:	6a 81       	ldd	r22, Y+2	; 0x02
    6144:	7b 81       	ldd	r23, Y+3	; 0x03
    6146:	e9 01       	movw	r28, r18
    6148:	48 83       	st	Y, r20
    614a:	59 83       	std	Y+1, r21	; 0x01
    614c:	6a 83       	std	Y+2, r22	; 0x02
    614e:	7b 83       	std	Y+3, r23	; 0x03
    6150:	2c 5f       	subi	r18, 0xFC	; 252
    6152:	3f 4f       	sbci	r19, 0xFF	; 255
    6154:	04 96       	adiw	r24, 0x04	; 4
    6156:	ec 01       	movw	r28, r24
    6158:	48 81       	ld	r20, Y
    615a:	59 81       	ldd	r21, Y+1	; 0x01
    615c:	6a 81       	ldd	r22, Y+2	; 0x02
    615e:	7b 81       	ldd	r23, Y+3	; 0x03
    6160:	e9 01       	movw	r28, r18
    6162:	48 83       	st	Y, r20
    6164:	59 83       	std	Y+1, r21	; 0x01
    6166:	6a 83       	std	Y+2, r22	; 0x02
    6168:	7b 83       	std	Y+3, r23	; 0x03
    616a:	2c 5f       	subi	r18, 0xFC	; 252
    616c:	3f 4f       	sbci	r19, 0xFF	; 255
    616e:	04 96       	adiw	r24, 0x04	; 4
    6170:	ec 01       	movw	r28, r24
    6172:	48 81       	ld	r20, Y
    6174:	59 81       	ldd	r21, Y+1	; 0x01
    6176:	6a 81       	ldd	r22, Y+2	; 0x02
    6178:	7b 81       	ldd	r23, Y+3	; 0x03
    617a:	e9 01       	movw	r28, r18
    617c:	48 83       	st	Y, r20
    617e:	59 83       	std	Y+1, r21	; 0x01
    6180:	6a 83       	std	Y+2, r22	; 0x02
    6182:	7b 83       	std	Y+3, r23	; 0x03
    6184:	2c 5f       	subi	r18, 0xFC	; 252
    6186:	3f 4f       	sbci	r19, 0xFF	; 255
    6188:	04 96       	adiw	r24, 0x04	; 4
    618a:	ec 01       	movw	r28, r24
    618c:	48 81       	ld	r20, Y
    618e:	59 81       	ldd	r21, Y+1	; 0x01
    6190:	6a 81       	ldd	r22, Y+2	; 0x02
    6192:	7b 81       	ldd	r23, Y+3	; 0x03
    6194:	e9 01       	movw	r28, r18
    6196:	48 83       	st	Y, r20
    6198:	59 83       	std	Y+1, r21	; 0x01
    619a:	6a 83       	std	Y+2, r22	; 0x02
    619c:	7b 83       	std	Y+3, r23	; 0x03
    619e:	2c 5f       	subi	r18, 0xFC	; 252
    61a0:	3f 4f       	sbci	r19, 0xFF	; 255
    61a2:	04 96       	adiw	r24, 0x04	; 4
    61a4:	ec 01       	movw	r28, r24
    61a6:	48 81       	ld	r20, Y
    61a8:	59 81       	ldd	r21, Y+1	; 0x01
    61aa:	6a 81       	ldd	r22, Y+2	; 0x02
    61ac:	7b 81       	ldd	r23, Y+3	; 0x03
    61ae:	e9 01       	movw	r28, r18
    61b0:	48 83       	st	Y, r20
    61b2:	59 83       	std	Y+1, r21	; 0x01
    61b4:	6a 83       	std	Y+2, r22	; 0x02
    61b6:	7b 83       	std	Y+3, r23	; 0x03
    61b8:	2c 5f       	subi	r18, 0xFC	; 252
    61ba:	3f 4f       	sbci	r19, 0xFF	; 255
    61bc:	04 96       	adiw	r24, 0x04	; 4
    61be:	ec 01       	movw	r28, r24
    61c0:	48 81       	ld	r20, Y
    61c2:	59 81       	ldd	r21, Y+1	; 0x01
    61c4:	6a 81       	ldd	r22, Y+2	; 0x02
    61c6:	7b 81       	ldd	r23, Y+3	; 0x03
    61c8:	e9 01       	movw	r28, r18
    61ca:	48 83       	st	Y, r20
    61cc:	59 83       	std	Y+1, r21	; 0x01
    61ce:	6a 83       	std	Y+2, r22	; 0x02
    61d0:	7b 83       	std	Y+3, r23	; 0x03
    61d2:	2c 5f       	subi	r18, 0xFC	; 252
    61d4:	3f 4f       	sbci	r19, 0xFF	; 255
    61d6:	04 96       	adiw	r24, 0x04	; 4
    61d8:	ec 01       	movw	r28, r24
    61da:	48 81       	ld	r20, Y
    61dc:	59 81       	ldd	r21, Y+1	; 0x01
    61de:	6a 81       	ldd	r22, Y+2	; 0x02
    61e0:	7b 81       	ldd	r23, Y+3	; 0x03
    61e2:	e9 01       	movw	r28, r18
    61e4:	48 83       	st	Y, r20
    61e6:	59 83       	std	Y+1, r21	; 0x01
    61e8:	6a 83       	std	Y+2, r22	; 0x02
    61ea:	7b 83       	std	Y+3, r23	; 0x03
    61ec:	2c 5f       	subi	r18, 0xFC	; 252
    61ee:	3f 4f       	sbci	r19, 0xFF	; 255
    61f0:	04 96       	adiw	r24, 0x04	; 4
    61f2:	ec 01       	movw	r28, r24
    61f4:	48 81       	ld	r20, Y
    61f6:	59 81       	ldd	r21, Y+1	; 0x01
    61f8:	6a 81       	ldd	r22, Y+2	; 0x02
    61fa:	7b 81       	ldd	r23, Y+3	; 0x03
    61fc:	e9 01       	movw	r28, r18
    61fe:	48 83       	st	Y, r20
    6200:	59 83       	std	Y+1, r21	; 0x01
    6202:	6a 83       	std	Y+2, r22	; 0x02
    6204:	7b 83       	std	Y+3, r23	; 0x03
    6206:	2c 5f       	subi	r18, 0xFC	; 252
    6208:	3f 4f       	sbci	r19, 0xFF	; 255
    620a:	04 96       	adiw	r24, 0x04	; 4
    620c:	ec 01       	movw	r28, r24
    620e:	48 81       	ld	r20, Y
    6210:	59 81       	ldd	r21, Y+1	; 0x01
    6212:	6a 81       	ldd	r22, Y+2	; 0x02
    6214:	7b 81       	ldd	r23, Y+3	; 0x03
    6216:	e9 01       	movw	r28, r18
    6218:	48 83       	st	Y, r20
    621a:	59 83       	std	Y+1, r21	; 0x01
    621c:	6a 83       	std	Y+2, r22	; 0x02
    621e:	7b 83       	std	Y+3, r23	; 0x03
    6220:	2c 5f       	subi	r18, 0xFC	; 252
    6222:	3f 4f       	sbci	r19, 0xFF	; 255
    6224:	04 96       	adiw	r24, 0x04	; 4
    6226:	ec 01       	movw	r28, r24
    6228:	48 81       	ld	r20, Y
    622a:	59 81       	ldd	r21, Y+1	; 0x01
    622c:	6a 81       	ldd	r22, Y+2	; 0x02
    622e:	7b 81       	ldd	r23, Y+3	; 0x03
    6230:	e9 01       	movw	r28, r18
    6232:	48 83       	st	Y, r20
    6234:	59 83       	std	Y+1, r21	; 0x01
    6236:	6a 83       	std	Y+2, r22	; 0x02
    6238:	7b 83       	std	Y+3, r23	; 0x03
    623a:	2c 5f       	subi	r18, 0xFC	; 252
    623c:	3f 4f       	sbci	r19, 0xFF	; 255
    623e:	04 96       	adiw	r24, 0x04	; 4
    6240:	ec 01       	movw	r28, r24
    6242:	48 81       	ld	r20, Y
    6244:	59 81       	ldd	r21, Y+1	; 0x01
    6246:	6a 81       	ldd	r22, Y+2	; 0x02
    6248:	7b 81       	ldd	r23, Y+3	; 0x03
    624a:	e9 01       	movw	r28, r18
    624c:	48 83       	st	Y, r20
    624e:	59 83       	std	Y+1, r21	; 0x01
    6250:	6a 83       	std	Y+2, r22	; 0x02
    6252:	7b 83       	std	Y+3, r23	; 0x03
    6254:	2c 5f       	subi	r18, 0xFC	; 252
    6256:	3f 4f       	sbci	r19, 0xFF	; 255
    6258:	04 96       	adiw	r24, 0x04	; 4
    625a:	ec 01       	movw	r28, r24
    625c:	48 81       	ld	r20, Y
    625e:	59 81       	ldd	r21, Y+1	; 0x01
    6260:	6a 81       	ldd	r22, Y+2	; 0x02
    6262:	7b 81       	ldd	r23, Y+3	; 0x03
    6264:	e9 01       	movw	r28, r18
    6266:	48 83       	st	Y, r20
    6268:	59 83       	std	Y+1, r21	; 0x01
    626a:	6a 83       	std	Y+2, r22	; 0x02
    626c:	7b 83       	std	Y+3, r23	; 0x03
    626e:	2c 5f       	subi	r18, 0xFC	; 252
    6270:	3f 4f       	sbci	r19, 0xFF	; 255
    6272:	04 96       	adiw	r24, 0x04	; 4
    6274:	ec 01       	movw	r28, r24
    6276:	48 81       	ld	r20, Y
    6278:	59 81       	ldd	r21, Y+1	; 0x01
    627a:	6a 81       	ldd	r22, Y+2	; 0x02
    627c:	7b 81       	ldd	r23, Y+3	; 0x03
    627e:	e9 01       	movw	r28, r18
    6280:	48 83       	st	Y, r20
    6282:	59 83       	std	Y+1, r21	; 0x01
    6284:	6a 83       	std	Y+2, r22	; 0x02
    6286:	7b 83       	std	Y+3, r23	; 0x03
    6288:	2c 5f       	subi	r18, 0xFC	; 252
    628a:	3f 4f       	sbci	r19, 0xFF	; 255
    628c:	04 96       	adiw	r24, 0x04	; 4
    628e:	ec 01       	movw	r28, r24
    6290:	48 81       	ld	r20, Y
    6292:	59 81       	ldd	r21, Y+1	; 0x01
    6294:	6a 81       	ldd	r22, Y+2	; 0x02
    6296:	7b 81       	ldd	r23, Y+3	; 0x03
    6298:	e9 01       	movw	r28, r18
    629a:	48 83       	st	Y, r20
    629c:	59 83       	std	Y+1, r21	; 0x01
    629e:	6a 83       	std	Y+2, r22	; 0x02
    62a0:	7b 83       	std	Y+3, r23	; 0x03
    62a2:	2c 5f       	subi	r18, 0xFC	; 252
    62a4:	3f 4f       	sbci	r19, 0xFF	; 255
    62a6:	04 96       	adiw	r24, 0x04	; 4
    62a8:	ec 01       	movw	r28, r24
    62aa:	48 81       	ld	r20, Y
    62ac:	59 81       	ldd	r21, Y+1	; 0x01
    62ae:	6a 81       	ldd	r22, Y+2	; 0x02
    62b0:	7b 81       	ldd	r23, Y+3	; 0x03
    62b2:	e9 01       	movw	r28, r18
    62b4:	48 83       	st	Y, r20
    62b6:	59 83       	std	Y+1, r21	; 0x01
    62b8:	6a 83       	std	Y+2, r22	; 0x02
    62ba:	7b 83       	std	Y+3, r23	; 0x03
    62bc:	2c 5f       	subi	r18, 0xFC	; 252
    62be:	3f 4f       	sbci	r19, 0xFF	; 255
    62c0:	04 96       	adiw	r24, 0x04	; 4
    62c2:	ec 01       	movw	r28, r24
    62c4:	48 81       	ld	r20, Y
    62c6:	59 81       	ldd	r21, Y+1	; 0x01
    62c8:	6a 81       	ldd	r22, Y+2	; 0x02
    62ca:	7b 81       	ldd	r23, Y+3	; 0x03
    62cc:	e9 01       	movw	r28, r18
    62ce:	48 83       	st	Y, r20
    62d0:	59 83       	std	Y+1, r21	; 0x01
    62d2:	6a 83       	std	Y+2, r22	; 0x02
    62d4:	7b 83       	std	Y+3, r23	; 0x03
    62d6:	2c 5f       	subi	r18, 0xFC	; 252
    62d8:	3f 4f       	sbci	r19, 0xFF	; 255
    62da:	04 96       	adiw	r24, 0x04	; 4
    62dc:	ec 01       	movw	r28, r24
    62de:	48 81       	ld	r20, Y
    62e0:	59 81       	ldd	r21, Y+1	; 0x01
    62e2:	6a 81       	ldd	r22, Y+2	; 0x02
    62e4:	7b 81       	ldd	r23, Y+3	; 0x03
    62e6:	e9 01       	movw	r28, r18
    62e8:	48 83       	st	Y, r20
    62ea:	59 83       	std	Y+1, r21	; 0x01
    62ec:	6a 83       	std	Y+2, r22	; 0x02
    62ee:	7b 83       	std	Y+3, r23	; 0x03
    62f0:	2c 5f       	subi	r18, 0xFC	; 252
    62f2:	3f 4f       	sbci	r19, 0xFF	; 255
    62f4:	04 96       	adiw	r24, 0x04	; 4
    62f6:	ec 01       	movw	r28, r24
    62f8:	48 81       	ld	r20, Y
    62fa:	59 81       	ldd	r21, Y+1	; 0x01
    62fc:	6a 81       	ldd	r22, Y+2	; 0x02
    62fe:	7b 81       	ldd	r23, Y+3	; 0x03
    6300:	e9 01       	movw	r28, r18
    6302:	48 83       	st	Y, r20
    6304:	59 83       	std	Y+1, r21	; 0x01
    6306:	6a 83       	std	Y+2, r22	; 0x02
    6308:	7b 83       	std	Y+3, r23	; 0x03
    630a:	2c 5f       	subi	r18, 0xFC	; 252
    630c:	3f 4f       	sbci	r19, 0xFF	; 255
    630e:	04 96       	adiw	r24, 0x04	; 4
    6310:	ec 01       	movw	r28, r24
    6312:	48 81       	ld	r20, Y
    6314:	59 81       	ldd	r21, Y+1	; 0x01
    6316:	6a 81       	ldd	r22, Y+2	; 0x02
    6318:	7b 81       	ldd	r23, Y+3	; 0x03
    631a:	e9 01       	movw	r28, r18
    631c:	48 83       	st	Y, r20
    631e:	59 83       	std	Y+1, r21	; 0x01
    6320:	6a 83       	std	Y+2, r22	; 0x02
    6322:	7b 83       	std	Y+3, r23	; 0x03
    6324:	2c 5f       	subi	r18, 0xFC	; 252
    6326:	3f 4f       	sbci	r19, 0xFF	; 255
    6328:	04 96       	adiw	r24, 0x04	; 4
    632a:	ec 01       	movw	r28, r24
    632c:	48 81       	ld	r20, Y
    632e:	59 81       	ldd	r21, Y+1	; 0x01
    6330:	6a 81       	ldd	r22, Y+2	; 0x02
    6332:	7b 81       	ldd	r23, Y+3	; 0x03
    6334:	e9 01       	movw	r28, r18
    6336:	48 83       	st	Y, r20
    6338:	59 83       	std	Y+1, r21	; 0x01
    633a:	6a 83       	std	Y+2, r22	; 0x02
    633c:	7b 83       	std	Y+3, r23	; 0x03
    633e:	2c 5f       	subi	r18, 0xFC	; 252
    6340:	3f 4f       	sbci	r19, 0xFF	; 255
    6342:	04 96       	adiw	r24, 0x04	; 4
    6344:	ec 01       	movw	r28, r24
    6346:	48 81       	ld	r20, Y
    6348:	59 81       	ldd	r21, Y+1	; 0x01
    634a:	6a 81       	ldd	r22, Y+2	; 0x02
    634c:	7b 81       	ldd	r23, Y+3	; 0x03
    634e:	e9 01       	movw	r28, r18
    6350:	48 83       	st	Y, r20
    6352:	59 83       	std	Y+1, r21	; 0x01
    6354:	6a 83       	std	Y+2, r22	; 0x02
    6356:	7b 83       	std	Y+3, r23	; 0x03
    6358:	2c 5f       	subi	r18, 0xFC	; 252
    635a:	3f 4f       	sbci	r19, 0xFF	; 255
    635c:	04 96       	adiw	r24, 0x04	; 4
    635e:	ec 01       	movw	r28, r24
    6360:	48 81       	ld	r20, Y
    6362:	59 81       	ldd	r21, Y+1	; 0x01
    6364:	6a 81       	ldd	r22, Y+2	; 0x02
    6366:	7b 81       	ldd	r23, Y+3	; 0x03
    6368:	e9 01       	movw	r28, r18
    636a:	48 83       	st	Y, r20
    636c:	59 83       	std	Y+1, r21	; 0x01
    636e:	6a 83       	std	Y+2, r22	; 0x02
    6370:	7b 83       	std	Y+3, r23	; 0x03
    6372:	2c 5f       	subi	r18, 0xFC	; 252
    6374:	3f 4f       	sbci	r19, 0xFF	; 255
    6376:	04 96       	adiw	r24, 0x04	; 4
    6378:	ec 01       	movw	r28, r24
    637a:	48 81       	ld	r20, Y
    637c:	59 81       	ldd	r21, Y+1	; 0x01
    637e:	6a 81       	ldd	r22, Y+2	; 0x02
    6380:	7b 81       	ldd	r23, Y+3	; 0x03
    6382:	e9 01       	movw	r28, r18
    6384:	48 83       	st	Y, r20
    6386:	59 83       	std	Y+1, r21	; 0x01
    6388:	6a 83       	std	Y+2, r22	; 0x02
    638a:	7b 83       	std	Y+3, r23	; 0x03
    638c:	2c 5f       	subi	r18, 0xFC	; 252
    638e:	3f 4f       	sbci	r19, 0xFF	; 255
    6390:	04 96       	adiw	r24, 0x04	; 4
    6392:	ec 01       	movw	r28, r24
    6394:	48 81       	ld	r20, Y
    6396:	59 81       	ldd	r21, Y+1	; 0x01
    6398:	6a 81       	ldd	r22, Y+2	; 0x02
    639a:	7b 81       	ldd	r23, Y+3	; 0x03
    639c:	e9 01       	movw	r28, r18
    639e:	48 83       	st	Y, r20
    63a0:	59 83       	std	Y+1, r21	; 0x01
    63a2:	6a 83       	std	Y+2, r22	; 0x02
    63a4:	7b 83       	std	Y+3, r23	; 0x03
    63a6:	2c 5f       	subi	r18, 0xFC	; 252
    63a8:	3f 4f       	sbci	r19, 0xFF	; 255
    63aa:	04 96       	adiw	r24, 0x04	; 4
    63ac:	ec 01       	movw	r28, r24
    63ae:	48 81       	ld	r20, Y
    63b0:	59 81       	ldd	r21, Y+1	; 0x01
    63b2:	6a 81       	ldd	r22, Y+2	; 0x02
    63b4:	7b 81       	ldd	r23, Y+3	; 0x03
    63b6:	e9 01       	movw	r28, r18
    63b8:	48 83       	st	Y, r20
    63ba:	59 83       	std	Y+1, r21	; 0x01
    63bc:	6a 83       	std	Y+2, r22	; 0x02
    63be:	7b 83       	std	Y+3, r23	; 0x03
    63c0:	2c 5f       	subi	r18, 0xFC	; 252
    63c2:	3f 4f       	sbci	r19, 0xFF	; 255
    63c4:	04 96       	adiw	r24, 0x04	; 4
    63c6:	ec 01       	movw	r28, r24
    63c8:	48 81       	ld	r20, Y
    63ca:	59 81       	ldd	r21, Y+1	; 0x01
    63cc:	6a 81       	ldd	r22, Y+2	; 0x02
    63ce:	7b 81       	ldd	r23, Y+3	; 0x03
    63d0:	e9 01       	movw	r28, r18
    63d2:	48 83       	st	Y, r20
    63d4:	59 83       	std	Y+1, r21	; 0x01
    63d6:	6a 83       	std	Y+2, r22	; 0x02
    63d8:	7b 83       	std	Y+3, r23	; 0x03
    63da:	2c 5f       	subi	r18, 0xFC	; 252
    63dc:	3f 4f       	sbci	r19, 0xFF	; 255
    63de:	04 96       	adiw	r24, 0x04	; 4
    63e0:	ec 01       	movw	r28, r24
    63e2:	48 81       	ld	r20, Y
    63e4:	59 81       	ldd	r21, Y+1	; 0x01
    63e6:	6a 81       	ldd	r22, Y+2	; 0x02
    63e8:	7b 81       	ldd	r23, Y+3	; 0x03
    63ea:	e9 01       	movw	r28, r18
    63ec:	48 83       	st	Y, r20
    63ee:	59 83       	std	Y+1, r21	; 0x01
    63f0:	6a 83       	std	Y+2, r22	; 0x02
    63f2:	7b 83       	std	Y+3, r23	; 0x03
    63f4:	2c 5f       	subi	r18, 0xFC	; 252
    63f6:	3f 4f       	sbci	r19, 0xFF	; 255
    63f8:	04 96       	adiw	r24, 0x04	; 4
    63fa:	ec 01       	movw	r28, r24
    63fc:	48 81       	ld	r20, Y
    63fe:	59 81       	ldd	r21, Y+1	; 0x01
    6400:	6a 81       	ldd	r22, Y+2	; 0x02
    6402:	7b 81       	ldd	r23, Y+3	; 0x03
    6404:	e9 01       	movw	r28, r18
    6406:	48 83       	st	Y, r20
    6408:	59 83       	std	Y+1, r21	; 0x01
    640a:	6a 83       	std	Y+2, r22	; 0x02
    640c:	7b 83       	std	Y+3, r23	; 0x03
    640e:	2c 5f       	subi	r18, 0xFC	; 252
    6410:	3f 4f       	sbci	r19, 0xFF	; 255
    6412:	04 96       	adiw	r24, 0x04	; 4
    6414:	ec 01       	movw	r28, r24
    6416:	48 81       	ld	r20, Y
    6418:	59 81       	ldd	r21, Y+1	; 0x01
    641a:	6a 81       	ldd	r22, Y+2	; 0x02
    641c:	7b 81       	ldd	r23, Y+3	; 0x03
    641e:	e9 01       	movw	r28, r18
    6420:	48 83       	st	Y, r20
    6422:	59 83       	std	Y+1, r21	; 0x01
    6424:	6a 83       	std	Y+2, r22	; 0x02
    6426:	7b 83       	std	Y+3, r23	; 0x03
    6428:	2c 5f       	subi	r18, 0xFC	; 252
    642a:	3f 4f       	sbci	r19, 0xFF	; 255
    642c:	04 96       	adiw	r24, 0x04	; 4
    642e:	ec 01       	movw	r28, r24
    6430:	48 81       	ld	r20, Y
    6432:	59 81       	ldd	r21, Y+1	; 0x01
    6434:	6a 81       	ldd	r22, Y+2	; 0x02
    6436:	7b 81       	ldd	r23, Y+3	; 0x03
    6438:	e9 01       	movw	r28, r18
    643a:	48 83       	st	Y, r20
    643c:	59 83       	std	Y+1, r21	; 0x01
    643e:	6a 83       	std	Y+2, r22	; 0x02
    6440:	7b 83       	std	Y+3, r23	; 0x03
    6442:	2c 5f       	subi	r18, 0xFC	; 252
    6444:	3f 4f       	sbci	r19, 0xFF	; 255
    6446:	04 96       	adiw	r24, 0x04	; 4
    6448:	ec 01       	movw	r28, r24
    644a:	48 81       	ld	r20, Y
    644c:	59 81       	ldd	r21, Y+1	; 0x01
    644e:	6a 81       	ldd	r22, Y+2	; 0x02
    6450:	7b 81       	ldd	r23, Y+3	; 0x03
    6452:	e9 01       	movw	r28, r18
    6454:	48 83       	st	Y, r20
    6456:	59 83       	std	Y+1, r21	; 0x01
    6458:	6a 83       	std	Y+2, r22	; 0x02
    645a:	7b 83       	std	Y+3, r23	; 0x03
    645c:	2c 5f       	subi	r18, 0xFC	; 252
    645e:	3f 4f       	sbci	r19, 0xFF	; 255
    6460:	04 96       	adiw	r24, 0x04	; 4
    6462:	ec 01       	movw	r28, r24
    6464:	48 81       	ld	r20, Y
    6466:	59 81       	ldd	r21, Y+1	; 0x01
    6468:	6a 81       	ldd	r22, Y+2	; 0x02
    646a:	7b 81       	ldd	r23, Y+3	; 0x03
    646c:	e9 01       	movw	r28, r18
    646e:	48 83       	st	Y, r20
    6470:	59 83       	std	Y+1, r21	; 0x01
    6472:	6a 83       	std	Y+2, r22	; 0x02
    6474:	7b 83       	std	Y+3, r23	; 0x03
    6476:	2c 5f       	subi	r18, 0xFC	; 252
    6478:	3f 4f       	sbci	r19, 0xFF	; 255
    647a:	04 96       	adiw	r24, 0x04	; 4
    647c:	ec 01       	movw	r28, r24
    647e:	48 81       	ld	r20, Y
    6480:	59 81       	ldd	r21, Y+1	; 0x01
    6482:	6a 81       	ldd	r22, Y+2	; 0x02
    6484:	7b 81       	ldd	r23, Y+3	; 0x03
    6486:	e9 01       	movw	r28, r18
    6488:	48 83       	st	Y, r20
    648a:	59 83       	std	Y+1, r21	; 0x01
    648c:	6a 83       	std	Y+2, r22	; 0x02
    648e:	7b 83       	std	Y+3, r23	; 0x03
    6490:	2c 5f       	subi	r18, 0xFC	; 252
    6492:	3f 4f       	sbci	r19, 0xFF	; 255
    6494:	04 96       	adiw	r24, 0x04	; 4
    6496:	ec 01       	movw	r28, r24
    6498:	48 81       	ld	r20, Y
    649a:	59 81       	ldd	r21, Y+1	; 0x01
    649c:	6a 81       	ldd	r22, Y+2	; 0x02
    649e:	7b 81       	ldd	r23, Y+3	; 0x03
    64a0:	e9 01       	movw	r28, r18
    64a2:	48 83       	st	Y, r20
    64a4:	59 83       	std	Y+1, r21	; 0x01
    64a6:	6a 83       	std	Y+2, r22	; 0x02
    64a8:	7b 83       	std	Y+3, r23	; 0x03
    64aa:	2c 5f       	subi	r18, 0xFC	; 252
    64ac:	3f 4f       	sbci	r19, 0xFF	; 255
    64ae:	04 96       	adiw	r24, 0x04	; 4
    64b0:	ec 01       	movw	r28, r24
    64b2:	48 81       	ld	r20, Y
    64b4:	59 81       	ldd	r21, Y+1	; 0x01
    64b6:	6a 81       	ldd	r22, Y+2	; 0x02
    64b8:	7b 81       	ldd	r23, Y+3	; 0x03
    64ba:	e9 01       	movw	r28, r18
    64bc:	48 83       	st	Y, r20
    64be:	59 83       	std	Y+1, r21	; 0x01
    64c0:	6a 83       	std	Y+2, r22	; 0x02
    64c2:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    64c4:	2c 5f       	subi	r18, 0xFC	; 252
    64c6:	3f 4f       	sbci	r19, 0xFF	; 255
    64c8:	04 96       	adiw	r24, 0x04	; 4
    64ca:	ec 01       	movw	r28, r24
    64cc:	48 81       	ld	r20, Y
    64ce:	59 81       	ldd	r21, Y+1	; 0x01
    64d0:	6a 81       	ldd	r22, Y+2	; 0x02
    64d2:	7b 81       	ldd	r23, Y+3	; 0x03
    64d4:	e9 01       	movw	r28, r18
    64d6:	48 83       	st	Y, r20
    64d8:	59 83       	std	Y+1, r21	; 0x01
    64da:	6a 83       	std	Y+2, r22	; 0x02
    64dc:	7b 83       	std	Y+3, r23	; 0x03
    64de:	2c 5f       	subi	r18, 0xFC	; 252
    64e0:	3f 4f       	sbci	r19, 0xFF	; 255
    64e2:	04 96       	adiw	r24, 0x04	; 4
    64e4:	ec 01       	movw	r28, r24
    64e6:	48 81       	ld	r20, Y
    64e8:	59 81       	ldd	r21, Y+1	; 0x01
    64ea:	6a 81       	ldd	r22, Y+2	; 0x02
    64ec:	7b 81       	ldd	r23, Y+3	; 0x03
    64ee:	e9 01       	movw	r28, r18
    64f0:	48 83       	st	Y, r20
    64f2:	59 83       	std	Y+1, r21	; 0x01
    64f4:	6a 83       	std	Y+2, r22	; 0x02
    64f6:	7b 83       	std	Y+3, r23	; 0x03
    64f8:	2c 5f       	subi	r18, 0xFC	; 252
    64fa:	3f 4f       	sbci	r19, 0xFF	; 255
    64fc:	04 96       	adiw	r24, 0x04	; 4
    64fe:	ec 01       	movw	r28, r24
    6500:	48 81       	ld	r20, Y
    6502:	59 81       	ldd	r21, Y+1	; 0x01
    6504:	6a 81       	ldd	r22, Y+2	; 0x02
    6506:	7b 81       	ldd	r23, Y+3	; 0x03
    6508:	e9 01       	movw	r28, r18
    650a:	48 83       	st	Y, r20
    650c:	59 83       	std	Y+1, r21	; 0x01
    650e:	6a 83       	std	Y+2, r22	; 0x02
    6510:	7b 83       	std	Y+3, r23	; 0x03
    6512:	2c 5f       	subi	r18, 0xFC	; 252
    6514:	3f 4f       	sbci	r19, 0xFF	; 255
    6516:	04 96       	adiw	r24, 0x04	; 4
    6518:	ec 01       	movw	r28, r24
    651a:	48 81       	ld	r20, Y
    651c:	59 81       	ldd	r21, Y+1	; 0x01
    651e:	6a 81       	ldd	r22, Y+2	; 0x02
    6520:	7b 81       	ldd	r23, Y+3	; 0x03
    6522:	e9 01       	movw	r28, r18
    6524:	48 83       	st	Y, r20
    6526:	59 83       	std	Y+1, r21	; 0x01
    6528:	6a 83       	std	Y+2, r22	; 0x02
    652a:	7b 83       	std	Y+3, r23	; 0x03
    652c:	2c 5f       	subi	r18, 0xFC	; 252
    652e:	3f 4f       	sbci	r19, 0xFF	; 255
    6530:	04 96       	adiw	r24, 0x04	; 4
    6532:	ec 01       	movw	r28, r24
    6534:	48 81       	ld	r20, Y
    6536:	59 81       	ldd	r21, Y+1	; 0x01
    6538:	6a 81       	ldd	r22, Y+2	; 0x02
    653a:	7b 81       	ldd	r23, Y+3	; 0x03
    653c:	e9 01       	movw	r28, r18
    653e:	48 83       	st	Y, r20
    6540:	59 83       	std	Y+1, r21	; 0x01
    6542:	6a 83       	std	Y+2, r22	; 0x02
    6544:	7b 83       	std	Y+3, r23	; 0x03
    6546:	2c 5f       	subi	r18, 0xFC	; 252
    6548:	3f 4f       	sbci	r19, 0xFF	; 255
    654a:	04 96       	adiw	r24, 0x04	; 4
    654c:	ec 01       	movw	r28, r24
    654e:	48 81       	ld	r20, Y
    6550:	59 81       	ldd	r21, Y+1	; 0x01
    6552:	6a 81       	ldd	r22, Y+2	; 0x02
    6554:	7b 81       	ldd	r23, Y+3	; 0x03
    6556:	e9 01       	movw	r28, r18
    6558:	48 83       	st	Y, r20
    655a:	59 83       	std	Y+1, r21	; 0x01
    655c:	6a 83       	std	Y+2, r22	; 0x02
    655e:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6560:	2c 5f       	subi	r18, 0xFC	; 252
    6562:	3f 4f       	sbci	r19, 0xFF	; 255
    6564:	04 96       	adiw	r24, 0x04	; 4
    6566:	ec 01       	movw	r28, r24
    6568:	48 81       	ld	r20, Y
    656a:	59 81       	ldd	r21, Y+1	; 0x01
    656c:	6a 81       	ldd	r22, Y+2	; 0x02
    656e:	7b 81       	ldd	r23, Y+3	; 0x03
    6570:	e9 01       	movw	r28, r18
    6572:	48 83       	st	Y, r20
    6574:	59 83       	std	Y+1, r21	; 0x01
    6576:	6a 83       	std	Y+2, r22	; 0x02
    6578:	7b 83       	std	Y+3, r23	; 0x03
    657a:	2c 5f       	subi	r18, 0xFC	; 252
    657c:	3f 4f       	sbci	r19, 0xFF	; 255
    657e:	04 96       	adiw	r24, 0x04	; 4
    6580:	ec 01       	movw	r28, r24
    6582:	48 81       	ld	r20, Y
    6584:	59 81       	ldd	r21, Y+1	; 0x01
    6586:	6a 81       	ldd	r22, Y+2	; 0x02
    6588:	7b 81       	ldd	r23, Y+3	; 0x03
    658a:	e9 01       	movw	r28, r18
    658c:	48 83       	st	Y, r20
    658e:	59 83       	std	Y+1, r21	; 0x01
    6590:	6a 83       	std	Y+2, r22	; 0x02
    6592:	7b 83       	std	Y+3, r23	; 0x03
    6594:	2c 5f       	subi	r18, 0xFC	; 252
    6596:	3f 4f       	sbci	r19, 0xFF	; 255
    6598:	04 96       	adiw	r24, 0x04	; 4
    659a:	ec 01       	movw	r28, r24
    659c:	48 81       	ld	r20, Y
    659e:	59 81       	ldd	r21, Y+1	; 0x01
    65a0:	6a 81       	ldd	r22, Y+2	; 0x02
    65a2:	7b 81       	ldd	r23, Y+3	; 0x03
    65a4:	e9 01       	movw	r28, r18
    65a6:	48 83       	st	Y, r20
    65a8:	59 83       	std	Y+1, r21	; 0x01
    65aa:	6a 83       	std	Y+2, r22	; 0x02
    65ac:	7b 83       	std	Y+3, r23	; 0x03
    65ae:	2c 5f       	subi	r18, 0xFC	; 252
    65b0:	3f 4f       	sbci	r19, 0xFF	; 255
    65b2:	04 96       	adiw	r24, 0x04	; 4
    65b4:	ec 01       	movw	r28, r24
    65b6:	48 81       	ld	r20, Y
    65b8:	59 81       	ldd	r21, Y+1	; 0x01
    65ba:	6a 81       	ldd	r22, Y+2	; 0x02
    65bc:	7b 81       	ldd	r23, Y+3	; 0x03
    65be:	e9 01       	movw	r28, r18
    65c0:	48 83       	st	Y, r20
    65c2:	59 83       	std	Y+1, r21	; 0x01
    65c4:	6a 83       	std	Y+2, r22	; 0x02
    65c6:	7b 83       	std	Y+3, r23	; 0x03
    65c8:	2c 5f       	subi	r18, 0xFC	; 252
    65ca:	3f 4f       	sbci	r19, 0xFF	; 255
    65cc:	04 96       	adiw	r24, 0x04	; 4
    65ce:	ec 01       	movw	r28, r24
    65d0:	48 81       	ld	r20, Y
    65d2:	59 81       	ldd	r21, Y+1	; 0x01
    65d4:	6a 81       	ldd	r22, Y+2	; 0x02
    65d6:	7b 81       	ldd	r23, Y+3	; 0x03
    65d8:	e9 01       	movw	r28, r18
    65da:	48 83       	st	Y, r20
    65dc:	59 83       	std	Y+1, r21	; 0x01
    65de:	6a 83       	std	Y+2, r22	; 0x02
    65e0:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    65e2:	2c 5f       	subi	r18, 0xFC	; 252
    65e4:	3f 4f       	sbci	r19, 0xFF	; 255
    65e6:	04 96       	adiw	r24, 0x04	; 4
    65e8:	ec 01       	movw	r28, r24
    65ea:	48 81       	ld	r20, Y
    65ec:	59 81       	ldd	r21, Y+1	; 0x01
    65ee:	6a 81       	ldd	r22, Y+2	; 0x02
    65f0:	7b 81       	ldd	r23, Y+3	; 0x03
    65f2:	e9 01       	movw	r28, r18
    65f4:	48 83       	st	Y, r20
    65f6:	59 83       	std	Y+1, r21	; 0x01
    65f8:	6a 83       	std	Y+2, r22	; 0x02
    65fa:	7b 83       	std	Y+3, r23	; 0x03
    65fc:	2c 5f       	subi	r18, 0xFC	; 252
    65fe:	3f 4f       	sbci	r19, 0xFF	; 255
    6600:	04 96       	adiw	r24, 0x04	; 4
    6602:	ec 01       	movw	r28, r24
    6604:	48 81       	ld	r20, Y
    6606:	59 81       	ldd	r21, Y+1	; 0x01
    6608:	6a 81       	ldd	r22, Y+2	; 0x02
    660a:	7b 81       	ldd	r23, Y+3	; 0x03
    660c:	e9 01       	movw	r28, r18
    660e:	48 83       	st	Y, r20
    6610:	59 83       	std	Y+1, r21	; 0x01
    6612:	6a 83       	std	Y+2, r22	; 0x02
    6614:	7b 83       	std	Y+3, r23	; 0x03
    6616:	2c 5f       	subi	r18, 0xFC	; 252
    6618:	3f 4f       	sbci	r19, 0xFF	; 255
    661a:	04 96       	adiw	r24, 0x04	; 4
    661c:	ec 01       	movw	r28, r24
    661e:	48 81       	ld	r20, Y
    6620:	59 81       	ldd	r21, Y+1	; 0x01
    6622:	6a 81       	ldd	r22, Y+2	; 0x02
    6624:	7b 81       	ldd	r23, Y+3	; 0x03
    6626:	e9 01       	movw	r28, r18
    6628:	48 83       	st	Y, r20
    662a:	59 83       	std	Y+1, r21	; 0x01
    662c:	6a 83       	std	Y+2, r22	; 0x02
    662e:	7b 83       	std	Y+3, r23	; 0x03
    6630:	2c 5f       	subi	r18, 0xFC	; 252
    6632:	3f 4f       	sbci	r19, 0xFF	; 255
    6634:	04 96       	adiw	r24, 0x04	; 4
    6636:	ec 01       	movw	r28, r24
    6638:	48 81       	ld	r20, Y
    663a:	59 81       	ldd	r21, Y+1	; 0x01
    663c:	6a 81       	ldd	r22, Y+2	; 0x02
    663e:	7b 81       	ldd	r23, Y+3	; 0x03
    6640:	e9 01       	movw	r28, r18
    6642:	48 83       	st	Y, r20
    6644:	59 83       	std	Y+1, r21	; 0x01
    6646:	6a 83       	std	Y+2, r22	; 0x02
    6648:	7b 83       	std	Y+3, r23	; 0x03
    664a:	e3 5d       	subi	r30, 0xD3	; 211
    664c:	fe 4f       	sbci	r31, 0xFE	; 254
    664e:	a7 5d       	subi	r26, 0xD7	; 215
    6650:	be 4f       	sbci	r27, 0xFE	; 254
    6652:	4d 91       	ld	r20, X+
    6654:	5d 91       	ld	r21, X+
    6656:	6d 91       	ld	r22, X+
    6658:	7c 91       	ld	r23, X
    665a:	40 83       	st	Z, r20
    665c:	51 83       	std	Z+1, r21	; 0x01
    665e:	62 83       	std	Z+2, r22	; 0x02
    6660:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    6662:	df 91       	pop	r29
    6664:	cf 91       	pop	r28
    6666:	08 95       	ret

00006668 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>:

SystemTelemetryMessage* SystemTelemetryMessage::buildMessageSt(byte *message)
{
    6668:	0f 93       	push	r16
    666a:	1f 93       	push	r17
    666c:	cf 93       	push	r28
    666e:	df 93       	push	r29
    6670:	8c 01       	movw	r16, r24
	SystemTelemetryMessage *msg = new SystemTelemetryMessage();
    6672:	81 e3       	ldi	r24, 0x31	; 49
    6674:	91 e0       	ldi	r25, 0x01	; 1
    6676:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    667a:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    667c:	82 e0       	ldi	r24, 0x02	; 2
    667e:	8a 83       	std	Y+2, r24	; 0x02
    6680:	8d e2       	ldi	r24, 0x2D	; 45
    6682:	91 e0       	ldi	r25, 0x01	; 1
    6684:	9c 83       	std	Y+4, r25	; 0x04
    6686:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    6688:	80 e8       	ldi	r24, 0x80	; 128
    668a:	92 e0       	ldi	r25, 0x02	; 2
    668c:	99 83       	std	Y+1, r25	; 0x01
    668e:	88 83       	st	Y, r24
    6690:	1d 82       	std	Y+5, r1	; 0x05
    6692:	1e 82       	std	Y+6, r1	; 0x06
    6694:	1f 82       	std	Y+7, r1	; 0x07
    6696:	18 86       	std	Y+8, r1	; 0x08
    6698:	19 86       	std	Y+9, r1	; 0x09
    669a:	1a 86       	std	Y+10, r1	; 0x0a
    669c:	1b 86       	std	Y+11, r1	; 0x0b
    669e:	1c 86       	std	Y+12, r1	; 0x0c
    66a0:	1d 86       	std	Y+13, r1	; 0x0d
    66a2:	1e 86       	std	Y+14, r1	; 0x0e
    66a4:	1f 86       	std	Y+15, r1	; 0x0f
    66a6:	18 8a       	std	Y+16, r1	; 0x10
    66a8:	19 8a       	std	Y+17, r1	; 0x11
    66aa:	1a 8a       	std	Y+18, r1	; 0x12
    66ac:	1b 8a       	std	Y+19, r1	; 0x13
    66ae:	1c 8a       	std	Y+20, r1	; 0x14
    66b0:	1d 8a       	std	Y+21, r1	; 0x15
    66b2:	1e 8a       	std	Y+22, r1	; 0x16
    66b4:	1f 8a       	std	Y+23, r1	; 0x17
    66b6:	18 8e       	std	Y+24, r1	; 0x18
    66b8:	19 8e       	std	Y+25, r1	; 0x19
    66ba:	1a 8e       	std	Y+26, r1	; 0x1a
    66bc:	1b 8e       	std	Y+27, r1	; 0x1b
    66be:	1c 8e       	std	Y+28, r1	; 0x1c
    66c0:	1d 8e       	std	Y+29, r1	; 0x1d
    66c2:	1e 8e       	std	Y+30, r1	; 0x1e
    66c4:	1f 8e       	std	Y+31, r1	; 0x1f
    66c6:	18 a2       	std	Y+32, r1	; 0x20
    66c8:	19 a2       	std	Y+33, r1	; 0x21
    66ca:	1a a2       	std	Y+34, r1	; 0x22
    66cc:	1b a2       	std	Y+35, r1	; 0x23
    66ce:	1c a2       	std	Y+36, r1	; 0x24
    66d0:	1d a2       	std	Y+37, r1	; 0x25
    66d2:	1e a2       	std	Y+38, r1	; 0x26
    66d4:	1f a2       	std	Y+39, r1	; 0x27
    66d6:	18 a6       	std	Y+40, r1	; 0x28
    66d8:	19 a6       	std	Y+41, r1	; 0x29
    66da:	1a a6       	std	Y+42, r1	; 0x2a
    66dc:	1b a6       	std	Y+43, r1	; 0x2b
    66de:	1c a6       	std	Y+44, r1	; 0x2c
    66e0:	1d a6       	std	Y+45, r1	; 0x2d
    66e2:	1e a6       	std	Y+46, r1	; 0x2e
    66e4:	1f a6       	std	Y+47, r1	; 0x2f
    66e6:	18 aa       	std	Y+48, r1	; 0x30
    66e8:	19 aa       	std	Y+49, r1	; 0x31
    66ea:	1a aa       	std	Y+50, r1	; 0x32
    66ec:	1b aa       	std	Y+51, r1	; 0x33
    66ee:	1c aa       	std	Y+52, r1	; 0x34
    66f0:	1d aa       	std	Y+53, r1	; 0x35
    66f2:	1e aa       	std	Y+54, r1	; 0x36
    66f4:	1f aa       	std	Y+55, r1	; 0x37
    66f6:	18 ae       	std	Y+56, r1	; 0x38
    66f8:	19 ae       	std	Y+57, r1	; 0x39
    66fa:	1a ae       	std	Y+58, r1	; 0x3a
    66fc:	1b ae       	std	Y+59, r1	; 0x3b
    66fe:	1c ae       	std	Y+60, r1	; 0x3c
    6700:	fe 01       	movw	r30, r28
    6702:	fd 96       	adiw	r30, 0x3d	; 61
    6704:	10 82       	st	Z, r1
    6706:	11 82       	std	Z+1, r1	; 0x01
    6708:	12 82       	std	Z+2, r1	; 0x02
    670a:	13 82       	std	Z+3, r1	; 0x03
    670c:	34 96       	adiw	r30, 0x04	; 4
    670e:	10 82       	st	Z, r1
    6710:	11 82       	std	Z+1, r1	; 0x01
    6712:	12 82       	std	Z+2, r1	; 0x02
    6714:	13 82       	std	Z+3, r1	; 0x03
    6716:	34 96       	adiw	r30, 0x04	; 4
    6718:	10 82       	st	Z, r1
    671a:	11 82       	std	Z+1, r1	; 0x01
    671c:	12 82       	std	Z+2, r1	; 0x02
    671e:	13 82       	std	Z+3, r1	; 0x03
    6720:	34 96       	adiw	r30, 0x04	; 4
    6722:	10 82       	st	Z, r1
    6724:	11 82       	std	Z+1, r1	; 0x01
    6726:	12 82       	std	Z+2, r1	; 0x02
    6728:	13 82       	std	Z+3, r1	; 0x03
    672a:	34 96       	adiw	r30, 0x04	; 4
    672c:	10 82       	st	Z, r1
    672e:	11 82       	std	Z+1, r1	; 0x01
    6730:	12 82       	std	Z+2, r1	; 0x02
    6732:	13 82       	std	Z+3, r1	; 0x03
    6734:	34 96       	adiw	r30, 0x04	; 4
    6736:	10 82       	st	Z, r1
    6738:	11 82       	std	Z+1, r1	; 0x01
    673a:	12 82       	std	Z+2, r1	; 0x02
    673c:	13 82       	std	Z+3, r1	; 0x03
    673e:	34 96       	adiw	r30, 0x04	; 4
    6740:	10 82       	st	Z, r1
    6742:	11 82       	std	Z+1, r1	; 0x01
    6744:	12 82       	std	Z+2, r1	; 0x02
    6746:	13 82       	std	Z+3, r1	; 0x03
    6748:	34 96       	adiw	r30, 0x04	; 4
    674a:	10 82       	st	Z, r1
    674c:	11 82       	std	Z+1, r1	; 0x01
    674e:	12 82       	std	Z+2, r1	; 0x02
    6750:	13 82       	std	Z+3, r1	; 0x03
    6752:	34 96       	adiw	r30, 0x04	; 4
    6754:	10 82       	st	Z, r1
    6756:	11 82       	std	Z+1, r1	; 0x01
    6758:	12 82       	std	Z+2, r1	; 0x02
    675a:	13 82       	std	Z+3, r1	; 0x03
    675c:	34 96       	adiw	r30, 0x04	; 4
    675e:	10 82       	st	Z, r1
    6760:	11 82       	std	Z+1, r1	; 0x01
    6762:	12 82       	std	Z+2, r1	; 0x02
    6764:	13 82       	std	Z+3, r1	; 0x03
    6766:	34 96       	adiw	r30, 0x04	; 4
    6768:	10 82       	st	Z, r1
    676a:	11 82       	std	Z+1, r1	; 0x01
    676c:	12 82       	std	Z+2, r1	; 0x02
    676e:	13 82       	std	Z+3, r1	; 0x03
    6770:	34 96       	adiw	r30, 0x04	; 4
    6772:	10 82       	st	Z, r1
    6774:	11 82       	std	Z+1, r1	; 0x01
    6776:	12 82       	std	Z+2, r1	; 0x02
    6778:	13 82       	std	Z+3, r1	; 0x03
    677a:	34 96       	adiw	r30, 0x04	; 4
    677c:	10 82       	st	Z, r1
    677e:	11 82       	std	Z+1, r1	; 0x01
    6780:	12 82       	std	Z+2, r1	; 0x02
    6782:	13 82       	std	Z+3, r1	; 0x03
    6784:	34 96       	adiw	r30, 0x04	; 4
    6786:	10 82       	st	Z, r1
    6788:	11 82       	std	Z+1, r1	; 0x01
    678a:	12 82       	std	Z+2, r1	; 0x02
    678c:	13 82       	std	Z+3, r1	; 0x03
    678e:	34 96       	adiw	r30, 0x04	; 4
    6790:	10 82       	st	Z, r1
    6792:	11 82       	std	Z+1, r1	; 0x01
    6794:	12 82       	std	Z+2, r1	; 0x02
    6796:	13 82       	std	Z+3, r1	; 0x03
    6798:	34 96       	adiw	r30, 0x04	; 4
    679a:	10 82       	st	Z, r1
    679c:	11 82       	std	Z+1, r1	; 0x01
    679e:	12 82       	std	Z+2, r1	; 0x02
    67a0:	13 82       	std	Z+3, r1	; 0x03
    67a2:	34 96       	adiw	r30, 0x04	; 4
    67a4:	10 82       	st	Z, r1
    67a6:	11 82       	std	Z+1, r1	; 0x01
    67a8:	12 82       	std	Z+2, r1	; 0x02
    67aa:	13 82       	std	Z+3, r1	; 0x03
    67ac:	34 96       	adiw	r30, 0x04	; 4
    67ae:	10 82       	st	Z, r1
    67b0:	11 82       	std	Z+1, r1	; 0x01
    67b2:	12 82       	std	Z+2, r1	; 0x02
    67b4:	13 82       	std	Z+3, r1	; 0x03
    67b6:	34 96       	adiw	r30, 0x04	; 4
    67b8:	10 82       	st	Z, r1
    67ba:	11 82       	std	Z+1, r1	; 0x01
    67bc:	12 82       	std	Z+2, r1	; 0x02
    67be:	13 82       	std	Z+3, r1	; 0x03
    67c0:	34 96       	adiw	r30, 0x04	; 4
    67c2:	10 82       	st	Z, r1
    67c4:	11 82       	std	Z+1, r1	; 0x01
    67c6:	12 82       	std	Z+2, r1	; 0x02
    67c8:	13 82       	std	Z+3, r1	; 0x03
    67ca:	34 96       	adiw	r30, 0x04	; 4
    67cc:	10 82       	st	Z, r1
    67ce:	11 82       	std	Z+1, r1	; 0x01
    67d0:	12 82       	std	Z+2, r1	; 0x02
    67d2:	13 82       	std	Z+3, r1	; 0x03
    67d4:	34 96       	adiw	r30, 0x04	; 4
    67d6:	10 82       	st	Z, r1
    67d8:	11 82       	std	Z+1, r1	; 0x01
    67da:	12 82       	std	Z+2, r1	; 0x02
    67dc:	13 82       	std	Z+3, r1	; 0x03
    67de:	34 96       	adiw	r30, 0x04	; 4
    67e0:	10 82       	st	Z, r1
    67e2:	11 82       	std	Z+1, r1	; 0x01
    67e4:	12 82       	std	Z+2, r1	; 0x02
    67e6:	13 82       	std	Z+3, r1	; 0x03
    67e8:	34 96       	adiw	r30, 0x04	; 4
    67ea:	10 82       	st	Z, r1
    67ec:	11 82       	std	Z+1, r1	; 0x01
    67ee:	12 82       	std	Z+2, r1	; 0x02
    67f0:	13 82       	std	Z+3, r1	; 0x03
    67f2:	34 96       	adiw	r30, 0x04	; 4
    67f4:	10 82       	st	Z, r1
    67f6:	11 82       	std	Z+1, r1	; 0x01
    67f8:	12 82       	std	Z+2, r1	; 0x02
    67fa:	13 82       	std	Z+3, r1	; 0x03
    67fc:	34 96       	adiw	r30, 0x04	; 4
    67fe:	10 82       	st	Z, r1
    6800:	11 82       	std	Z+1, r1	; 0x01
    6802:	12 82       	std	Z+2, r1	; 0x02
    6804:	13 82       	std	Z+3, r1	; 0x03
    6806:	34 96       	adiw	r30, 0x04	; 4
    6808:	10 82       	st	Z, r1
    680a:	11 82       	std	Z+1, r1	; 0x01
    680c:	12 82       	std	Z+2, r1	; 0x02
    680e:	13 82       	std	Z+3, r1	; 0x03
    6810:	34 96       	adiw	r30, 0x04	; 4
    6812:	10 82       	st	Z, r1
    6814:	11 82       	std	Z+1, r1	; 0x01
    6816:	12 82       	std	Z+2, r1	; 0x02
    6818:	13 82       	std	Z+3, r1	; 0x03
    681a:	34 96       	adiw	r30, 0x04	; 4
    681c:	10 82       	st	Z, r1
    681e:	11 82       	std	Z+1, r1	; 0x01
    6820:	12 82       	std	Z+2, r1	; 0x02
    6822:	13 82       	std	Z+3, r1	; 0x03
    6824:	34 96       	adiw	r30, 0x04	; 4
    6826:	10 82       	st	Z, r1
    6828:	11 82       	std	Z+1, r1	; 0x01
    682a:	12 82       	std	Z+2, r1	; 0x02
    682c:	13 82       	std	Z+3, r1	; 0x03
    682e:	34 96       	adiw	r30, 0x04	; 4
    6830:	10 82       	st	Z, r1
    6832:	11 82       	std	Z+1, r1	; 0x01
    6834:	12 82       	std	Z+2, r1	; 0x02
    6836:	13 82       	std	Z+3, r1	; 0x03
    6838:	34 96       	adiw	r30, 0x04	; 4
    683a:	10 82       	st	Z, r1
    683c:	11 82       	std	Z+1, r1	; 0x01
    683e:	12 82       	std	Z+2, r1	; 0x02
    6840:	13 82       	std	Z+3, r1	; 0x03
    6842:	34 96       	adiw	r30, 0x04	; 4
    6844:	10 82       	st	Z, r1
    6846:	11 82       	std	Z+1, r1	; 0x01
    6848:	12 82       	std	Z+2, r1	; 0x02
    684a:	13 82       	std	Z+3, r1	; 0x03
    684c:	34 96       	adiw	r30, 0x04	; 4
    684e:	10 82       	st	Z, r1
    6850:	11 82       	std	Z+1, r1	; 0x01
    6852:	12 82       	std	Z+2, r1	; 0x02
    6854:	13 82       	std	Z+3, r1	; 0x03
    6856:	34 96       	adiw	r30, 0x04	; 4
    6858:	10 82       	st	Z, r1
    685a:	11 82       	std	Z+1, r1	; 0x01
    685c:	12 82       	std	Z+2, r1	; 0x02
    685e:	13 82       	std	Z+3, r1	; 0x03
    6860:	34 96       	adiw	r30, 0x04	; 4
    6862:	10 82       	st	Z, r1
    6864:	11 82       	std	Z+1, r1	; 0x01
    6866:	12 82       	std	Z+2, r1	; 0x02
    6868:	13 82       	std	Z+3, r1	; 0x03
    686a:	34 96       	adiw	r30, 0x04	; 4
    686c:	10 82       	st	Z, r1
    686e:	11 82       	std	Z+1, r1	; 0x01
    6870:	12 82       	std	Z+2, r1	; 0x02
    6872:	13 82       	std	Z+3, r1	; 0x03
    6874:	34 96       	adiw	r30, 0x04	; 4
    6876:	10 82       	st	Z, r1
    6878:	11 82       	std	Z+1, r1	; 0x01
    687a:	12 82       	std	Z+2, r1	; 0x02
    687c:	13 82       	std	Z+3, r1	; 0x03
    687e:	34 96       	adiw	r30, 0x04	; 4
    6880:	10 82       	st	Z, r1
    6882:	11 82       	std	Z+1, r1	; 0x01
    6884:	12 82       	std	Z+2, r1	; 0x02
    6886:	13 82       	std	Z+3, r1	; 0x03
    6888:	34 96       	adiw	r30, 0x04	; 4
    688a:	10 82       	st	Z, r1
    688c:	11 82       	std	Z+1, r1	; 0x01
    688e:	12 82       	std	Z+2, r1	; 0x02
    6890:	13 82       	std	Z+3, r1	; 0x03
    6892:	34 96       	adiw	r30, 0x04	; 4
    6894:	10 82       	st	Z, r1
    6896:	11 82       	std	Z+1, r1	; 0x01
    6898:	12 82       	std	Z+2, r1	; 0x02
    689a:	13 82       	std	Z+3, r1	; 0x03
    689c:	34 96       	adiw	r30, 0x04	; 4
    689e:	10 82       	st	Z, r1
    68a0:	11 82       	std	Z+1, r1	; 0x01
    68a2:	12 82       	std	Z+2, r1	; 0x02
    68a4:	13 82       	std	Z+3, r1	; 0x03
    68a6:	34 96       	adiw	r30, 0x04	; 4
    68a8:	10 82       	st	Z, r1
    68aa:	11 82       	std	Z+1, r1	; 0x01
    68ac:	12 82       	std	Z+2, r1	; 0x02
    68ae:	13 82       	std	Z+3, r1	; 0x03
    68b0:	34 96       	adiw	r30, 0x04	; 4
    68b2:	10 82       	st	Z, r1
    68b4:	11 82       	std	Z+1, r1	; 0x01
    68b6:	12 82       	std	Z+2, r1	; 0x02
    68b8:	13 82       	std	Z+3, r1	; 0x03
    68ba:	34 96       	adiw	r30, 0x04	; 4
    68bc:	10 82       	st	Z, r1
    68be:	11 82       	std	Z+1, r1	; 0x01
    68c0:	12 82       	std	Z+2, r1	; 0x02
    68c2:	13 82       	std	Z+3, r1	; 0x03
    68c4:	34 96       	adiw	r30, 0x04	; 4
    68c6:	10 82       	st	Z, r1
    68c8:	11 82       	std	Z+1, r1	; 0x01
    68ca:	12 82       	std	Z+2, r1	; 0x02
    68cc:	13 82       	std	Z+3, r1	; 0x03
    68ce:	34 96       	adiw	r30, 0x04	; 4
    68d0:	10 82       	st	Z, r1
    68d2:	11 82       	std	Z+1, r1	; 0x01
    68d4:	12 82       	std	Z+2, r1	; 0x02
    68d6:	13 82       	std	Z+3, r1	; 0x03
    68d8:	34 96       	adiw	r30, 0x04	; 4
    68da:	10 82       	st	Z, r1
    68dc:	11 82       	std	Z+1, r1	; 0x01
    68de:	12 82       	std	Z+2, r1	; 0x02
    68e0:	13 82       	std	Z+3, r1	; 0x03
    68e2:	34 96       	adiw	r30, 0x04	; 4
    68e4:	10 82       	st	Z, r1
    68e6:	11 82       	std	Z+1, r1	; 0x01
    68e8:	12 82       	std	Z+2, r1	; 0x02
    68ea:	13 82       	std	Z+3, r1	; 0x03
    68ec:	34 96       	adiw	r30, 0x04	; 4
    68ee:	10 82       	st	Z, r1
    68f0:	11 82       	std	Z+1, r1	; 0x01
    68f2:	12 82       	std	Z+2, r1	; 0x02
    68f4:	13 82       	std	Z+3, r1	; 0x03
    68f6:	34 96       	adiw	r30, 0x04	; 4
    68f8:	10 82       	st	Z, r1
    68fa:	11 82       	std	Z+1, r1	; 0x01
    68fc:	12 82       	std	Z+2, r1	; 0x02
    68fe:	13 82       	std	Z+3, r1	; 0x03
    6900:	34 96       	adiw	r30, 0x04	; 4
    6902:	10 82       	st	Z, r1
    6904:	11 82       	std	Z+1, r1	; 0x01
    6906:	12 82       	std	Z+2, r1	; 0x02
    6908:	13 82       	std	Z+3, r1	; 0x03
    690a:	34 96       	adiw	r30, 0x04	; 4
    690c:	10 82       	st	Z, r1
    690e:	11 82       	std	Z+1, r1	; 0x01
    6910:	12 82       	std	Z+2, r1	; 0x02
    6912:	13 82       	std	Z+3, r1	; 0x03
    6914:	34 96       	adiw	r30, 0x04	; 4
    6916:	10 82       	st	Z, r1
    6918:	11 82       	std	Z+1, r1	; 0x01
    691a:	12 82       	std	Z+2, r1	; 0x02
    691c:	13 82       	std	Z+3, r1	; 0x03
    691e:	34 96       	adiw	r30, 0x04	; 4
    6920:	10 82       	st	Z, r1
    6922:	11 82       	std	Z+1, r1	; 0x01
    6924:	12 82       	std	Z+2, r1	; 0x02
    6926:	13 82       	std	Z+3, r1	; 0x03
    6928:	34 96       	adiw	r30, 0x04	; 4
    692a:	10 82       	st	Z, r1
    692c:	11 82       	std	Z+1, r1	; 0x01
    692e:	12 82       	std	Z+2, r1	; 0x02
    6930:	13 82       	std	Z+3, r1	; 0x03
    6932:	34 96       	adiw	r30, 0x04	; 4
    6934:	10 82       	st	Z, r1
    6936:	11 82       	std	Z+1, r1	; 0x01
    6938:	12 82       	std	Z+2, r1	; 0x02
    693a:	13 82       	std	Z+3, r1	; 0x03
    693c:	34 96       	adiw	r30, 0x04	; 4
    693e:	10 82       	st	Z, r1
    6940:	11 82       	std	Z+1, r1	; 0x01
    6942:	12 82       	std	Z+2, r1	; 0x02
    6944:	13 82       	std	Z+3, r1	; 0x03
    6946:	34 96       	adiw	r30, 0x04	; 4
    6948:	10 82       	st	Z, r1
    694a:	11 82       	std	Z+1, r1	; 0x01
    694c:	12 82       	std	Z+2, r1	; 0x02
    694e:	13 82       	std	Z+3, r1	; 0x03
    6950:	34 96       	adiw	r30, 0x04	; 4
    6952:	10 82       	st	Z, r1
    6954:	11 82       	std	Z+1, r1	; 0x01
    6956:	12 82       	std	Z+2, r1	; 0x02
    6958:	13 82       	std	Z+3, r1	; 0x03
    695a:	34 96       	adiw	r30, 0x04	; 4
    695c:	10 82       	st	Z, r1
    695e:	11 82       	std	Z+1, r1	; 0x01
    6960:	12 82       	std	Z+2, r1	; 0x02
    6962:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    6964:	b8 01       	movw	r22, r16
    6966:	ce 01       	movw	r24, r28
    6968:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    696c:	ce 01       	movw	r24, r28
    696e:	df 91       	pop	r29
    6970:	cf 91       	pop	r28
    6972:	1f 91       	pop	r17
    6974:	0f 91       	pop	r16
    6976:	08 95       	ret

00006978 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>:

SystemTelemetryMessage * SystemTelemetryMessage::buildMessageFromModel(SystemModel *model)
{
    6978:	2f 92       	push	r2
    697a:	3f 92       	push	r3
    697c:	4f 92       	push	r4
    697e:	5f 92       	push	r5
    6980:	6f 92       	push	r6
    6982:	7f 92       	push	r7
    6984:	8f 92       	push	r8
    6986:	9f 92       	push	r9
    6988:	af 92       	push	r10
    698a:	bf 92       	push	r11
    698c:	cf 92       	push	r12
    698e:	df 92       	push	r13
    6990:	ef 92       	push	r14
    6992:	ff 92       	push	r15
    6994:	0f 93       	push	r16
    6996:	1f 93       	push	r17
    6998:	cf 93       	push	r28
    699a:	df 93       	push	r29
    699c:	cd b7       	in	r28, 0x3d	; 61
    699e:	de b7       	in	r29, 0x3e	; 62
    69a0:	ca 54       	subi	r28, 0x4A	; 74
    69a2:	d1 09       	sbc	r29, r1
    69a4:	0f b6       	in	r0, 0x3f	; 63
    69a6:	f8 94       	cli
    69a8:	de bf       	out	0x3e, r29	; 62
    69aa:	0f be       	out	0x3f, r0	; 63
    69ac:	cd bf       	out	0x3d, r28	; 61
    69ae:	27 96       	adiw	r28, 0x07	; 7
    69b0:	9f af       	std	Y+63, r25	; 0x3f
    69b2:	8e af       	std	Y+62, r24	; 0x3e
    69b4:	27 97       	sbiw	r28, 0x07	; 7
	SystemTelemetryMessage *message = new SystemTelemetryMessage();
    69b6:	81 e3       	ldi	r24, 0x31	; 49
    69b8:	91 e0       	ldi	r25, 0x01	; 1
    69ba:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    69be:	fc 01       	movw	r30, r24
    69c0:	82 e0       	ldi	r24, 0x02	; 2
    69c2:	82 83       	std	Z+2, r24	; 0x02
    69c4:	8d e2       	ldi	r24, 0x2D	; 45
    69c6:	91 e0       	ldi	r25, 0x01	; 1
    69c8:	94 83       	std	Z+4, r25	; 0x04
    69ca:	83 83       	std	Z+3, r24	; 0x03
    69cc:	80 e8       	ldi	r24, 0x80	; 128
    69ce:	92 e0       	ldi	r25, 0x02	; 2
    69d0:	91 83       	std	Z+1, r25	; 0x01
    69d2:	80 83       	st	Z, r24
    69d4:	15 82       	std	Z+5, r1	; 0x05
    69d6:	16 82       	std	Z+6, r1	; 0x06
    69d8:	17 82       	std	Z+7, r1	; 0x07
    69da:	10 86       	std	Z+8, r1	; 0x08
    69dc:	11 86       	std	Z+9, r1	; 0x09
    69de:	12 86       	std	Z+10, r1	; 0x0a
    69e0:	13 86       	std	Z+11, r1	; 0x0b
    69e2:	14 86       	std	Z+12, r1	; 0x0c
    69e4:	15 86       	std	Z+13, r1	; 0x0d
    69e6:	16 86       	std	Z+14, r1	; 0x0e
    69e8:	17 86       	std	Z+15, r1	; 0x0f
    69ea:	10 8a       	std	Z+16, r1	; 0x10
    69ec:	11 8a       	std	Z+17, r1	; 0x11
    69ee:	12 8a       	std	Z+18, r1	; 0x12
    69f0:	13 8a       	std	Z+19, r1	; 0x13
    69f2:	14 8a       	std	Z+20, r1	; 0x14
    69f4:	15 8a       	std	Z+21, r1	; 0x15
    69f6:	16 8a       	std	Z+22, r1	; 0x16
    69f8:	17 8a       	std	Z+23, r1	; 0x17
    69fa:	10 8e       	std	Z+24, r1	; 0x18
    69fc:	11 8e       	std	Z+25, r1	; 0x19
    69fe:	12 8e       	std	Z+26, r1	; 0x1a
    6a00:	13 8e       	std	Z+27, r1	; 0x1b
    6a02:	14 8e       	std	Z+28, r1	; 0x1c
    6a04:	15 8e       	std	Z+29, r1	; 0x1d
    6a06:	16 8e       	std	Z+30, r1	; 0x1e
    6a08:	17 8e       	std	Z+31, r1	; 0x1f
    6a0a:	10 a2       	std	Z+32, r1	; 0x20
    6a0c:	11 a2       	std	Z+33, r1	; 0x21
    6a0e:	12 a2       	std	Z+34, r1	; 0x22
    6a10:	13 a2       	std	Z+35, r1	; 0x23
    6a12:	14 a2       	std	Z+36, r1	; 0x24
    6a14:	15 a2       	std	Z+37, r1	; 0x25
    6a16:	16 a2       	std	Z+38, r1	; 0x26
    6a18:	17 a2       	std	Z+39, r1	; 0x27
    6a1a:	10 a6       	std	Z+40, r1	; 0x28
    6a1c:	11 a6       	std	Z+41, r1	; 0x29
    6a1e:	12 a6       	std	Z+42, r1	; 0x2a
    6a20:	13 a6       	std	Z+43, r1	; 0x2b
    6a22:	14 a6       	std	Z+44, r1	; 0x2c
    6a24:	15 a6       	std	Z+45, r1	; 0x2d
    6a26:	16 a6       	std	Z+46, r1	; 0x2e
    6a28:	17 a6       	std	Z+47, r1	; 0x2f
    6a2a:	10 aa       	std	Z+48, r1	; 0x30
    6a2c:	11 aa       	std	Z+49, r1	; 0x31
    6a2e:	12 aa       	std	Z+50, r1	; 0x32
    6a30:	13 aa       	std	Z+51, r1	; 0x33
    6a32:	14 aa       	std	Z+52, r1	; 0x34
    6a34:	15 aa       	std	Z+53, r1	; 0x35
    6a36:	16 aa       	std	Z+54, r1	; 0x36
    6a38:	17 aa       	std	Z+55, r1	; 0x37
    6a3a:	10 ae       	std	Z+56, r1	; 0x38
    6a3c:	11 ae       	std	Z+57, r1	; 0x39
    6a3e:	12 ae       	std	Z+58, r1	; 0x3a
    6a40:	13 ae       	std	Z+59, r1	; 0x3b
    6a42:	14 ae       	std	Z+60, r1	; 0x3c
    6a44:	7f 01       	movw	r14, r30
    6a46:	2d e3       	ldi	r18, 0x3D	; 61
    6a48:	e2 0e       	add	r14, r18
    6a4a:	f1 1c       	adc	r15, r1
    6a4c:	d7 01       	movw	r26, r14
    6a4e:	1d 92       	st	X+, r1
    6a50:	1d 92       	st	X+, r1
    6a52:	1d 92       	st	X+, r1
    6a54:	1c 92       	st	X, r1
    6a56:	13 97       	sbiw	r26, 0x03	; 3
    6a58:	14 96       	adiw	r26, 0x04	; 4
    6a5a:	1d 92       	st	X+, r1
    6a5c:	1d 92       	st	X+, r1
    6a5e:	1d 92       	st	X+, r1
    6a60:	1c 92       	st	X, r1
    6a62:	13 97       	sbiw	r26, 0x03	; 3
    6a64:	14 96       	adiw	r26, 0x04	; 4
    6a66:	1d 92       	st	X+, r1
    6a68:	1d 92       	st	X+, r1
    6a6a:	1d 92       	st	X+, r1
    6a6c:	1c 92       	st	X, r1
    6a6e:	13 97       	sbiw	r26, 0x03	; 3
    6a70:	14 96       	adiw	r26, 0x04	; 4
    6a72:	1d 92       	st	X+, r1
    6a74:	1d 92       	st	X+, r1
    6a76:	1d 92       	st	X+, r1
    6a78:	1c 92       	st	X, r1
    6a7a:	13 97       	sbiw	r26, 0x03	; 3
    6a7c:	14 96       	adiw	r26, 0x04	; 4
    6a7e:	1d 92       	st	X+, r1
    6a80:	1d 92       	st	X+, r1
    6a82:	1d 92       	st	X+, r1
    6a84:	1c 92       	st	X, r1
    6a86:	13 97       	sbiw	r26, 0x03	; 3
    6a88:	14 96       	adiw	r26, 0x04	; 4
    6a8a:	1d 92       	st	X+, r1
    6a8c:	1d 92       	st	X+, r1
    6a8e:	1d 92       	st	X+, r1
    6a90:	1c 92       	st	X, r1
    6a92:	13 97       	sbiw	r26, 0x03	; 3
    6a94:	8f 01       	movw	r16, r30
    6a96:	0b 5a       	subi	r16, 0xAB	; 171
    6a98:	1f 4f       	sbci	r17, 0xFF	; 255
    6a9a:	d8 01       	movw	r26, r16
    6a9c:	1d 92       	st	X+, r1
    6a9e:	1d 92       	st	X+, r1
    6aa0:	1d 92       	st	X+, r1
    6aa2:	1c 92       	st	X, r1
    6aa4:	13 97       	sbiw	r26, 0x03	; 3
    6aa6:	14 96       	adiw	r26, 0x04	; 4
    6aa8:	1d 92       	st	X+, r1
    6aaa:	1d 92       	st	X+, r1
    6aac:	1d 92       	st	X+, r1
    6aae:	1c 92       	st	X, r1
    6ab0:	13 97       	sbiw	r26, 0x03	; 3
    6ab2:	af 01       	movw	r20, r30
    6ab4:	43 5a       	subi	r20, 0xA3	; 163
    6ab6:	5f 4f       	sbci	r21, 0xFF	; 255
    6ab8:	da 01       	movw	r26, r20
    6aba:	1d 92       	st	X+, r1
    6abc:	1d 92       	st	X+, r1
    6abe:	1d 92       	st	X+, r1
    6ac0:	1c 92       	st	X, r1
    6ac2:	13 97       	sbiw	r26, 0x03	; 3
    6ac4:	1f 01       	movw	r2, r30
    6ac6:	b1 e6       	ldi	r27, 0x61	; 97
    6ac8:	2b 0e       	add	r2, r27
    6aca:	31 1c       	adc	r3, r1
    6acc:	d1 01       	movw	r26, r2
    6ace:	1d 92       	st	X+, r1
    6ad0:	1d 92       	st	X+, r1
    6ad2:	1d 92       	st	X+, r1
    6ad4:	1c 92       	st	X, r1
    6ad6:	13 97       	sbiw	r26, 0x03	; 3
    6ad8:	bf 01       	movw	r22, r30
    6ada:	6b 59       	subi	r22, 0x9B	; 155
    6adc:	7f 4f       	sbci	r23, 0xFF	; 255
    6ade:	db 01       	movw	r26, r22
    6ae0:	1d 92       	st	X+, r1
    6ae2:	1d 92       	st	X+, r1
    6ae4:	1d 92       	st	X+, r1
    6ae6:	1c 92       	st	X, r1
    6ae8:	13 97       	sbiw	r26, 0x03	; 3
    6aea:	5f 01       	movw	r10, r30
    6aec:	b9 e6       	ldi	r27, 0x69	; 105
    6aee:	ab 0e       	add	r10, r27
    6af0:	b1 1c       	adc	r11, r1
    6af2:	d5 01       	movw	r26, r10
    6af4:	1d 92       	st	X+, r1
    6af6:	1d 92       	st	X+, r1
    6af8:	1d 92       	st	X+, r1
    6afa:	1c 92       	st	X, r1
    6afc:	13 97       	sbiw	r26, 0x03	; 3
    6afe:	4f 01       	movw	r8, r30
    6b00:	bd e6       	ldi	r27, 0x6D	; 109
    6b02:	8b 0e       	add	r8, r27
    6b04:	91 1c       	adc	r9, r1
    6b06:	d4 01       	movw	r26, r8
    6b08:	1d 92       	st	X+, r1
    6b0a:	1d 92       	st	X+, r1
    6b0c:	1d 92       	st	X+, r1
    6b0e:	1c 92       	st	X, r1
    6b10:	13 97       	sbiw	r26, 0x03	; 3
    6b12:	9f 01       	movw	r18, r30
    6b14:	2f 58       	subi	r18, 0x8F	; 143
    6b16:	3f 4f       	sbci	r19, 0xFF	; 255
    6b18:	29 96       	adiw	r28, 0x09	; 9
    6b1a:	3f af       	std	Y+63, r19	; 0x3f
    6b1c:	2e af       	std	Y+62, r18	; 0x3e
    6b1e:	29 97       	sbiw	r28, 0x09	; 9
    6b20:	d9 01       	movw	r26, r18
    6b22:	1d 92       	st	X+, r1
    6b24:	1d 92       	st	X+, r1
    6b26:	1d 92       	st	X+, r1
    6b28:	1c 92       	st	X, r1
    6b2a:	13 97       	sbiw	r26, 0x03	; 3
    6b2c:	2c 5f       	subi	r18, 0xFC	; 252
    6b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    6b30:	3a 83       	std	Y+2, r19	; 0x02
    6b32:	29 83       	std	Y+1, r18	; 0x01
    6b34:	d9 01       	movw	r26, r18
    6b36:	1d 92       	st	X+, r1
    6b38:	1d 92       	st	X+, r1
    6b3a:	1d 92       	st	X+, r1
    6b3c:	1c 92       	st	X, r1
    6b3e:	13 97       	sbiw	r26, 0x03	; 3
    6b40:	14 96       	adiw	r26, 0x04	; 4
    6b42:	1d 92       	st	X+, r1
    6b44:	1d 92       	st	X+, r1
    6b46:	1d 92       	st	X+, r1
    6b48:	1c 92       	st	X, r1
    6b4a:	13 97       	sbiw	r26, 0x03	; 3
    6b4c:	14 96       	adiw	r26, 0x04	; 4
    6b4e:	1d 92       	st	X+, r1
    6b50:	1d 92       	st	X+, r1
    6b52:	1d 92       	st	X+, r1
    6b54:	1c 92       	st	X, r1
    6b56:	13 97       	sbiw	r26, 0x03	; 3
    6b58:	14 96       	adiw	r26, 0x04	; 4
    6b5a:	1d 92       	st	X+, r1
    6b5c:	1d 92       	st	X+, r1
    6b5e:	1d 92       	st	X+, r1
    6b60:	1c 92       	st	X, r1
    6b62:	13 97       	sbiw	r26, 0x03	; 3
    6b64:	14 96       	adiw	r26, 0x04	; 4
    6b66:	1d 92       	st	X+, r1
    6b68:	1d 92       	st	X+, r1
    6b6a:	1d 92       	st	X+, r1
    6b6c:	1c 92       	st	X, r1
    6b6e:	13 97       	sbiw	r26, 0x03	; 3
    6b70:	14 96       	adiw	r26, 0x04	; 4
    6b72:	1d 92       	st	X+, r1
    6b74:	1d 92       	st	X+, r1
    6b76:	1d 92       	st	X+, r1
    6b78:	1c 92       	st	X, r1
    6b7a:	13 97       	sbiw	r26, 0x03	; 3
    6b7c:	28 5e       	subi	r18, 0xE8	; 232
    6b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    6b80:	3c 83       	std	Y+4, r19	; 0x04
    6b82:	2b 83       	std	Y+3, r18	; 0x03
    6b84:	d9 01       	movw	r26, r18
    6b86:	1d 92       	st	X+, r1
    6b88:	1d 92       	st	X+, r1
    6b8a:	1d 92       	st	X+, r1
    6b8c:	1c 92       	st	X, r1
    6b8e:	13 97       	sbiw	r26, 0x03	; 3
    6b90:	14 96       	adiw	r26, 0x04	; 4
    6b92:	1d 92       	st	X+, r1
    6b94:	1d 92       	st	X+, r1
    6b96:	1d 92       	st	X+, r1
    6b98:	1c 92       	st	X, r1
    6b9a:	13 97       	sbiw	r26, 0x03	; 3
    6b9c:	14 96       	adiw	r26, 0x04	; 4
    6b9e:	1d 92       	st	X+, r1
    6ba0:	1d 92       	st	X+, r1
    6ba2:	1d 92       	st	X+, r1
    6ba4:	1c 92       	st	X, r1
    6ba6:	13 97       	sbiw	r26, 0x03	; 3
    6ba8:	24 5f       	subi	r18, 0xF4	; 244
    6baa:	3f 4f       	sbci	r19, 0xFF	; 255
    6bac:	3e 83       	std	Y+6, r19	; 0x06
    6bae:	2d 83       	std	Y+5, r18	; 0x05
    6bb0:	d9 01       	movw	r26, r18
    6bb2:	1d 92       	st	X+, r1
    6bb4:	1d 92       	st	X+, r1
    6bb6:	1d 92       	st	X+, r1
    6bb8:	1c 92       	st	X, r1
    6bba:	13 97       	sbiw	r26, 0x03	; 3
    6bbc:	2c 5f       	subi	r18, 0xFC	; 252
    6bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    6bc0:	38 87       	std	Y+8, r19	; 0x08
    6bc2:	2f 83       	std	Y+7, r18	; 0x07
    6bc4:	d9 01       	movw	r26, r18
    6bc6:	1d 92       	st	X+, r1
    6bc8:	1d 92       	st	X+, r1
    6bca:	1d 92       	st	X+, r1
    6bcc:	1c 92       	st	X, r1
    6bce:	13 97       	sbiw	r26, 0x03	; 3
    6bd0:	2c 5f       	subi	r18, 0xFC	; 252
    6bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    6bd4:	3a 87       	std	Y+10, r19	; 0x0a
    6bd6:	29 87       	std	Y+9, r18	; 0x09
    6bd8:	d9 01       	movw	r26, r18
    6bda:	1d 92       	st	X+, r1
    6bdc:	1d 92       	st	X+, r1
    6bde:	1d 92       	st	X+, r1
    6be0:	1c 92       	st	X, r1
    6be2:	13 97       	sbiw	r26, 0x03	; 3
    6be4:	2c 5f       	subi	r18, 0xFC	; 252
    6be6:	3f 4f       	sbci	r19, 0xFF	; 255
    6be8:	3c 87       	std	Y+12, r19	; 0x0c
    6bea:	2b 87       	std	Y+11, r18	; 0x0b
    6bec:	d9 01       	movw	r26, r18
    6bee:	1d 92       	st	X+, r1
    6bf0:	1d 92       	st	X+, r1
    6bf2:	1d 92       	st	X+, r1
    6bf4:	1c 92       	st	X, r1
    6bf6:	13 97       	sbiw	r26, 0x03	; 3
    6bf8:	2c 5f       	subi	r18, 0xFC	; 252
    6bfa:	3f 4f       	sbci	r19, 0xFF	; 255
    6bfc:	3e 87       	std	Y+14, r19	; 0x0e
    6bfe:	2d 87       	std	Y+13, r18	; 0x0d
    6c00:	d9 01       	movw	r26, r18
    6c02:	1d 92       	st	X+, r1
    6c04:	1d 92       	st	X+, r1
    6c06:	1d 92       	st	X+, r1
    6c08:	1c 92       	st	X, r1
    6c0a:	13 97       	sbiw	r26, 0x03	; 3
    6c0c:	2c 5f       	subi	r18, 0xFC	; 252
    6c0e:	3f 4f       	sbci	r19, 0xFF	; 255
    6c10:	38 8b       	std	Y+16, r19	; 0x10
    6c12:	2f 87       	std	Y+15, r18	; 0x0f
    6c14:	d9 01       	movw	r26, r18
    6c16:	1d 92       	st	X+, r1
    6c18:	1d 92       	st	X+, r1
    6c1a:	1d 92       	st	X+, r1
    6c1c:	1c 92       	st	X, r1
    6c1e:	13 97       	sbiw	r26, 0x03	; 3
    6c20:	14 96       	adiw	r26, 0x04	; 4
    6c22:	1d 92       	st	X+, r1
    6c24:	1d 92       	st	X+, r1
    6c26:	1d 92       	st	X+, r1
    6c28:	1c 92       	st	X, r1
    6c2a:	13 97       	sbiw	r26, 0x03	; 3
    6c2c:	14 96       	adiw	r26, 0x04	; 4
    6c2e:	1d 92       	st	X+, r1
    6c30:	1d 92       	st	X+, r1
    6c32:	1d 92       	st	X+, r1
    6c34:	1c 92       	st	X, r1
    6c36:	13 97       	sbiw	r26, 0x03	; 3
    6c38:	14 96       	adiw	r26, 0x04	; 4
    6c3a:	1d 92       	st	X+, r1
    6c3c:	1d 92       	st	X+, r1
    6c3e:	1d 92       	st	X+, r1
    6c40:	1c 92       	st	X, r1
    6c42:	13 97       	sbiw	r26, 0x03	; 3
    6c44:	14 96       	adiw	r26, 0x04	; 4
    6c46:	1d 92       	st	X+, r1
    6c48:	1d 92       	st	X+, r1
    6c4a:	1d 92       	st	X+, r1
    6c4c:	1c 92       	st	X, r1
    6c4e:	13 97       	sbiw	r26, 0x03	; 3
    6c50:	2c 5e       	subi	r18, 0xEC	; 236
    6c52:	3f 4f       	sbci	r19, 0xFF	; 255
    6c54:	3a 8b       	std	Y+18, r19	; 0x12
    6c56:	29 8b       	std	Y+17, r18	; 0x11
    6c58:	d9 01       	movw	r26, r18
    6c5a:	1d 92       	st	X+, r1
    6c5c:	1d 92       	st	X+, r1
    6c5e:	1d 92       	st	X+, r1
    6c60:	1c 92       	st	X, r1
    6c62:	13 97       	sbiw	r26, 0x03	; 3
    6c64:	2c 5f       	subi	r18, 0xFC	; 252
    6c66:	3f 4f       	sbci	r19, 0xFF	; 255
    6c68:	3c 8b       	std	Y+20, r19	; 0x14
    6c6a:	2b 8b       	std	Y+19, r18	; 0x13
    6c6c:	d9 01       	movw	r26, r18
    6c6e:	1d 92       	st	X+, r1
    6c70:	1d 92       	st	X+, r1
    6c72:	1d 92       	st	X+, r1
    6c74:	1c 92       	st	X, r1
    6c76:	13 97       	sbiw	r26, 0x03	; 3
    6c78:	2c 5f       	subi	r18, 0xFC	; 252
    6c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    6c7c:	3e 8b       	std	Y+22, r19	; 0x16
    6c7e:	2d 8b       	std	Y+21, r18	; 0x15
    6c80:	d9 01       	movw	r26, r18
    6c82:	1d 92       	st	X+, r1
    6c84:	1d 92       	st	X+, r1
    6c86:	1d 92       	st	X+, r1
    6c88:	1c 92       	st	X, r1
    6c8a:	13 97       	sbiw	r26, 0x03	; 3
    6c8c:	2c 5f       	subi	r18, 0xFC	; 252
    6c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    6c90:	38 8f       	std	Y+24, r19	; 0x18
    6c92:	2f 8b       	std	Y+23, r18	; 0x17
    6c94:	d9 01       	movw	r26, r18
    6c96:	1d 92       	st	X+, r1
    6c98:	1d 92       	st	X+, r1
    6c9a:	1d 92       	st	X+, r1
    6c9c:	1c 92       	st	X, r1
    6c9e:	13 97       	sbiw	r26, 0x03	; 3
    6ca0:	2c 5f       	subi	r18, 0xFC	; 252
    6ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    6ca4:	3a 8f       	std	Y+26, r19	; 0x1a
    6ca6:	29 8f       	std	Y+25, r18	; 0x19
    6ca8:	d9 01       	movw	r26, r18
    6caa:	1d 92       	st	X+, r1
    6cac:	1d 92       	st	X+, r1
    6cae:	1d 92       	st	X+, r1
    6cb0:	1c 92       	st	X, r1
    6cb2:	13 97       	sbiw	r26, 0x03	; 3
    6cb4:	2c 5f       	subi	r18, 0xFC	; 252
    6cb6:	3f 4f       	sbci	r19, 0xFF	; 255
    6cb8:	3c 8f       	std	Y+28, r19	; 0x1c
    6cba:	2b 8f       	std	Y+27, r18	; 0x1b
    6cbc:	d9 01       	movw	r26, r18
    6cbe:	1d 92       	st	X+, r1
    6cc0:	1d 92       	st	X+, r1
    6cc2:	1d 92       	st	X+, r1
    6cc4:	1c 92       	st	X, r1
    6cc6:	13 97       	sbiw	r26, 0x03	; 3
    6cc8:	2c 5f       	subi	r18, 0xFC	; 252
    6cca:	3f 4f       	sbci	r19, 0xFF	; 255
    6ccc:	3e 8f       	std	Y+30, r19	; 0x1e
    6cce:	2d 8f       	std	Y+29, r18	; 0x1d
    6cd0:	d9 01       	movw	r26, r18
    6cd2:	1d 92       	st	X+, r1
    6cd4:	1d 92       	st	X+, r1
    6cd6:	1d 92       	st	X+, r1
    6cd8:	1c 92       	st	X, r1
    6cda:	13 97       	sbiw	r26, 0x03	; 3
    6cdc:	cf 01       	movw	r24, r30
    6cde:	83 52       	subi	r24, 0x23	; 35
    6ce0:	9f 4f       	sbci	r25, 0xFF	; 255
    6ce2:	dc 01       	movw	r26, r24
    6ce4:	1d 92       	st	X+, r1
    6ce6:	1d 92       	st	X+, r1
    6ce8:	1d 92       	st	X+, r1
    6cea:	1c 92       	st	X, r1
    6cec:	13 97       	sbiw	r26, 0x03	; 3
    6cee:	28 5f       	subi	r18, 0xF8	; 248
    6cf0:	3f 4f       	sbci	r19, 0xFF	; 255
    6cf2:	2b 96       	adiw	r28, 0x0b	; 11
    6cf4:	3f af       	std	Y+63, r19	; 0x3f
    6cf6:	2e af       	std	Y+62, r18	; 0x3e
    6cf8:	2b 97       	sbiw	r28, 0x0b	; 11
    6cfa:	d9 01       	movw	r26, r18
    6cfc:	1d 92       	st	X+, r1
    6cfe:	1d 92       	st	X+, r1
    6d00:	1d 92       	st	X+, r1
    6d02:	1c 92       	st	X, r1
    6d04:	13 97       	sbiw	r26, 0x03	; 3
    6d06:	2c 5f       	subi	r18, 0xFC	; 252
    6d08:	3f 4f       	sbci	r19, 0xFF	; 255
    6d0a:	38 a3       	std	Y+32, r19	; 0x20
    6d0c:	2f 8f       	std	Y+31, r18	; 0x1f
    6d0e:	d9 01       	movw	r26, r18
    6d10:	1d 92       	st	X+, r1
    6d12:	1d 92       	st	X+, r1
    6d14:	1d 92       	st	X+, r1
    6d16:	1c 92       	st	X, r1
    6d18:	13 97       	sbiw	r26, 0x03	; 3
    6d1a:	2c 5f       	subi	r18, 0xFC	; 252
    6d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    6d1e:	3a a3       	std	Y+34, r19	; 0x22
    6d20:	29 a3       	std	Y+33, r18	; 0x21
    6d22:	d9 01       	movw	r26, r18
    6d24:	1d 92       	st	X+, r1
    6d26:	1d 92       	st	X+, r1
    6d28:	1d 92       	st	X+, r1
    6d2a:	1c 92       	st	X, r1
    6d2c:	13 97       	sbiw	r26, 0x03	; 3
    6d2e:	2c 5f       	subi	r18, 0xFC	; 252
    6d30:	3f 4f       	sbci	r19, 0xFF	; 255
    6d32:	3c a3       	std	Y+36, r19	; 0x24
    6d34:	2b a3       	std	Y+35, r18	; 0x23
    6d36:	d9 01       	movw	r26, r18
    6d38:	1d 92       	st	X+, r1
    6d3a:	1d 92       	st	X+, r1
    6d3c:	1d 92       	st	X+, r1
    6d3e:	1c 92       	st	X, r1
    6d40:	13 97       	sbiw	r26, 0x03	; 3
    6d42:	2c 5f       	subi	r18, 0xFC	; 252
    6d44:	3f 4f       	sbci	r19, 0xFF	; 255
    6d46:	3e a3       	std	Y+38, r19	; 0x26
    6d48:	2d a3       	std	Y+37, r18	; 0x25
    6d4a:	d9 01       	movw	r26, r18
    6d4c:	1d 92       	st	X+, r1
    6d4e:	1d 92       	st	X+, r1
    6d50:	1d 92       	st	X+, r1
    6d52:	1c 92       	st	X, r1
    6d54:	13 97       	sbiw	r26, 0x03	; 3
    6d56:	2c 5f       	subi	r18, 0xFC	; 252
    6d58:	3f 4f       	sbci	r19, 0xFF	; 255
    6d5a:	38 a7       	std	Y+40, r19	; 0x28
    6d5c:	2f a3       	std	Y+39, r18	; 0x27
    6d5e:	d9 01       	movw	r26, r18
    6d60:	1d 92       	st	X+, r1
    6d62:	1d 92       	st	X+, r1
    6d64:	1d 92       	st	X+, r1
    6d66:	1c 92       	st	X, r1
    6d68:	13 97       	sbiw	r26, 0x03	; 3
    6d6a:	2c 5f       	subi	r18, 0xFC	; 252
    6d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    6d6e:	3a a7       	std	Y+42, r19	; 0x2a
    6d70:	29 a7       	std	Y+41, r18	; 0x29
    6d72:	d9 01       	movw	r26, r18
    6d74:	1d 92       	st	X+, r1
    6d76:	1d 92       	st	X+, r1
    6d78:	1d 92       	st	X+, r1
    6d7a:	1c 92       	st	X, r1
    6d7c:	13 97       	sbiw	r26, 0x03	; 3
    6d7e:	2c 5f       	subi	r18, 0xFC	; 252
    6d80:	3f 4f       	sbci	r19, 0xFF	; 255
    6d82:	3c a7       	std	Y+44, r19	; 0x2c
    6d84:	2b a7       	std	Y+43, r18	; 0x2b
    6d86:	d9 01       	movw	r26, r18
    6d88:	1d 92       	st	X+, r1
    6d8a:	1d 92       	st	X+, r1
    6d8c:	1d 92       	st	X+, r1
    6d8e:	1c 92       	st	X, r1
    6d90:	13 97       	sbiw	r26, 0x03	; 3
    6d92:	2c 5f       	subi	r18, 0xFC	; 252
    6d94:	3f 4f       	sbci	r19, 0xFF	; 255
    6d96:	3e a7       	std	Y+46, r19	; 0x2e
    6d98:	2d a7       	std	Y+45, r18	; 0x2d
    6d9a:	d9 01       	movw	r26, r18
    6d9c:	1d 92       	st	X+, r1
    6d9e:	1d 92       	st	X+, r1
    6da0:	1d 92       	st	X+, r1
    6da2:	1c 92       	st	X, r1
    6da4:	13 97       	sbiw	r26, 0x03	; 3
    6da6:	2c 5f       	subi	r18, 0xFC	; 252
    6da8:	3f 4f       	sbci	r19, 0xFF	; 255
    6daa:	38 ab       	std	Y+48, r19	; 0x30
    6dac:	2f a7       	std	Y+47, r18	; 0x2f
    6dae:	d9 01       	movw	r26, r18
    6db0:	1d 92       	st	X+, r1
    6db2:	1d 92       	st	X+, r1
    6db4:	1d 92       	st	X+, r1
    6db6:	1c 92       	st	X, r1
    6db8:	13 97       	sbiw	r26, 0x03	; 3
    6dba:	2c 5f       	subi	r18, 0xFC	; 252
    6dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    6dbe:	3a ab       	std	Y+50, r19	; 0x32
    6dc0:	29 ab       	std	Y+49, r18	; 0x31
    6dc2:	d9 01       	movw	r26, r18
    6dc4:	1d 92       	st	X+, r1
    6dc6:	1d 92       	st	X+, r1
    6dc8:	1d 92       	st	X+, r1
    6dca:	1c 92       	st	X, r1
    6dcc:	13 97       	sbiw	r26, 0x03	; 3
    6dce:	2c 5f       	subi	r18, 0xFC	; 252
    6dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    6dd2:	3c ab       	std	Y+52, r19	; 0x34
    6dd4:	2b ab       	std	Y+51, r18	; 0x33
    6dd6:	d9 01       	movw	r26, r18
    6dd8:	1d 92       	st	X+, r1
    6dda:	1d 92       	st	X+, r1
    6ddc:	1d 92       	st	X+, r1
    6dde:	1c 92       	st	X, r1
    6de0:	13 97       	sbiw	r26, 0x03	; 3
    6de2:	2c 5f       	subi	r18, 0xFC	; 252
    6de4:	3f 4f       	sbci	r19, 0xFF	; 255
    6de6:	3e ab       	std	Y+54, r19	; 0x36
    6de8:	2d ab       	std	Y+53, r18	; 0x35
    6dea:	d9 01       	movw	r26, r18
    6dec:	1d 92       	st	X+, r1
    6dee:	1d 92       	st	X+, r1
    6df0:	1d 92       	st	X+, r1
    6df2:	1c 92       	st	X, r1
    6df4:	13 97       	sbiw	r26, 0x03	; 3
    6df6:	2c 5f       	subi	r18, 0xFC	; 252
    6df8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dfa:	38 af       	std	Y+56, r19	; 0x38
    6dfc:	2f ab       	std	Y+55, r18	; 0x37
    6dfe:	d9 01       	movw	r26, r18
    6e00:	1d 92       	st	X+, r1
    6e02:	1d 92       	st	X+, r1
    6e04:	1d 92       	st	X+, r1
    6e06:	1c 92       	st	X, r1
    6e08:	13 97       	sbiw	r26, 0x03	; 3
    6e0a:	2c 5f       	subi	r18, 0xFC	; 252
    6e0c:	3f 4f       	sbci	r19, 0xFF	; 255
    6e0e:	3a af       	std	Y+58, r19	; 0x3a
    6e10:	29 af       	std	Y+57, r18	; 0x39
    6e12:	d9 01       	movw	r26, r18
    6e14:	1d 92       	st	X+, r1
    6e16:	1d 92       	st	X+, r1
    6e18:	1d 92       	st	X+, r1
    6e1a:	1c 92       	st	X, r1
    6e1c:	13 97       	sbiw	r26, 0x03	; 3
    6e1e:	2c 5f       	subi	r18, 0xFC	; 252
    6e20:	3f 4f       	sbci	r19, 0xFF	; 255
    6e22:	3c af       	std	Y+60, r19	; 0x3c
    6e24:	2b af       	std	Y+59, r18	; 0x3b
    6e26:	d9 01       	movw	r26, r18
    6e28:	1d 92       	st	X+, r1
    6e2a:	1d 92       	st	X+, r1
    6e2c:	1d 92       	st	X+, r1
    6e2e:	1c 92       	st	X, r1
    6e30:	13 97       	sbiw	r26, 0x03	; 3
    6e32:	2c 5f       	subi	r18, 0xFC	; 252
    6e34:	3f 4f       	sbci	r19, 0xFF	; 255
    6e36:	3e af       	std	Y+62, r19	; 0x3e
    6e38:	2d af       	std	Y+61, r18	; 0x3d
    6e3a:	d9 01       	movw	r26, r18
    6e3c:	1d 92       	st	X+, r1
    6e3e:	1d 92       	st	X+, r1
    6e40:	1d 92       	st	X+, r1
    6e42:	1c 92       	st	X, r1
    6e44:	13 97       	sbiw	r26, 0x03	; 3
    6e46:	2c 5f       	subi	r18, 0xFC	; 252
    6e48:	3f 4f       	sbci	r19, 0xFF	; 255
    6e4a:	21 96       	adiw	r28, 0x01	; 1
    6e4c:	3f af       	std	Y+63, r19	; 0x3f
    6e4e:	2e af       	std	Y+62, r18	; 0x3e
    6e50:	21 97       	sbiw	r28, 0x01	; 1
    6e52:	d9 01       	movw	r26, r18
    6e54:	1d 92       	st	X+, r1
    6e56:	1d 92       	st	X+, r1
    6e58:	1d 92       	st	X+, r1
    6e5a:	1c 92       	st	X, r1
    6e5c:	13 97       	sbiw	r26, 0x03	; 3
    6e5e:	2c 5f       	subi	r18, 0xFC	; 252
    6e60:	3f 4f       	sbci	r19, 0xFF	; 255
    6e62:	23 96       	adiw	r28, 0x03	; 3
    6e64:	3f af       	std	Y+63, r19	; 0x3f
    6e66:	2e af       	std	Y+62, r18	; 0x3e
    6e68:	23 97       	sbiw	r28, 0x03	; 3
    6e6a:	d9 01       	movw	r26, r18
    6e6c:	1d 92       	st	X+, r1
    6e6e:	1d 92       	st	X+, r1
    6e70:	1d 92       	st	X+, r1
    6e72:	1c 92       	st	X, r1
    6e74:	13 97       	sbiw	r26, 0x03	; 3
    6e76:	2c 5f       	subi	r18, 0xFC	; 252
    6e78:	3f 4f       	sbci	r19, 0xFF	; 255
    6e7a:	25 96       	adiw	r28, 0x05	; 5
    6e7c:	3f af       	std	Y+63, r19	; 0x3f
    6e7e:	2e af       	std	Y+62, r18	; 0x3e
    6e80:	25 97       	sbiw	r28, 0x05	; 5
    6e82:	d9 01       	movw	r26, r18
    6e84:	1d 92       	st	X+, r1
    6e86:	1d 92       	st	X+, r1
    6e88:	1d 92       	st	X+, r1
    6e8a:	1c 92       	st	X, r1
    6e8c:	13 97       	sbiw	r26, 0x03	; 3
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}

			float YawDerivativeError() const {return yawDerivativeError;}
    6e8e:	27 96       	adiw	r28, 0x07	; 7
    6e90:	ae ad       	ldd	r26, Y+62	; 0x3e
    6e92:	bf ad       	ldd	r27, Y+63	; 0x3f
    6e94:	27 97       	sbiw	r28, 0x07	; 7
    6e96:	5e 96       	adiw	r26, 0x1e	; 30
    6e98:	4d 90       	ld	r4, X+
    6e9a:	5d 90       	ld	r5, X+
    6e9c:	6d 90       	ld	r6, X+
    6e9e:	7c 90       	ld	r7, X
    6ea0:	91 97       	sbiw	r26, 0x21	; 33
	
	message->YawDerivativeError = model->YawDerivativeError();
    6ea2:	45 86       	std	Z+13, r4	; 0x0d
    6ea4:	56 86       	std	Z+14, r5	; 0x0e
    6ea6:	67 86       	std	Z+15, r6	; 0x0f
    6ea8:	70 8a       	std	Z+16, r7	; 0x10
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
    6eaa:	56 96       	adiw	r26, 0x16	; 22
    6eac:	4d 90       	ld	r4, X+
    6eae:	5d 90       	ld	r5, X+
    6eb0:	6d 90       	ld	r6, X+
    6eb2:	7c 90       	ld	r7, X
    6eb4:	59 97       	sbiw	r26, 0x19	; 25
	message->YawIntegral = model->YawIntegral();
    6eb6:	45 82       	std	Z+5, r4	; 0x05
    6eb8:	56 82       	std	Z+6, r5	; 0x06
    6eba:	67 82       	std	Z+7, r6	; 0x07
    6ebc:	70 86       	std	Z+8, r7	; 0x08
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
    6ebe:	5a 96       	adiw	r26, 0x1a	; 26
    6ec0:	4d 90       	ld	r4, X+
    6ec2:	5d 90       	ld	r5, X+
    6ec4:	6d 90       	ld	r6, X+
    6ec6:	7c 90       	ld	r7, X
    6ec8:	5d 97       	sbiw	r26, 0x1d	; 29
	message->YawProportional = model->YawProportional();
    6eca:	41 86       	std	Z+9, r4	; 0x09
    6ecc:	52 86       	std	Z+10, r5	; 0x0a
    6ece:	63 86       	std	Z+11, r6	; 0x0b
    6ed0:	74 86       	std	Z+12, r7	; 0x0c
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    6ed2:	1a 96       	adiw	r26, 0x0a	; 10
    6ed4:	4d 90       	ld	r4, X+
    6ed6:	5d 90       	ld	r5, X+
    6ed8:	6d 90       	ld	r6, X+
    6eda:	7c 90       	ld	r7, X
    6edc:	1d 97       	sbiw	r26, 0x0d	; 13
	message->YawControl = model->YawControl();
    6ede:	41 8a       	std	Z+17, r4	; 0x11
    6ee0:	52 8a       	std	Z+18, r5	; 0x12
    6ee2:	63 8a       	std	Z+19, r6	; 0x13
    6ee4:	74 8a       	std	Z+20, r7	; 0x14
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    6ee6:	6d 01       	movw	r12, r26
    6ee8:	b2 ed       	ldi	r27, 0xD2	; 210
    6eea:	cb 0e       	add	r12, r27
    6eec:	d1 1c       	adc	r13, r1
    6eee:	d6 01       	movw	r26, r12
    6ef0:	4d 90       	ld	r4, X+
    6ef2:	5d 90       	ld	r5, X+
    6ef4:	6d 90       	ld	r6, X+
    6ef6:	7c 90       	ld	r7, X
	

	message->PitchRads = model->PitchRads();
    6ef8:	45 a6       	std	Z+45, r4	; 0x2d
    6efa:	56 a6       	std	Z+46, r5	; 0x2e
    6efc:	67 a6       	std	Z+47, r6	; 0x2f
    6efe:	70 aa       	std	Z+48, r7	; 0x30
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    6f00:	27 96       	adiw	r28, 0x07	; 7
    6f02:	ae ad       	ldd	r26, Y+62	; 0x3e
    6f04:	bf ad       	ldd	r27, Y+63	; 0x3f
    6f06:	27 97       	sbiw	r28, 0x07	; 7
    6f08:	92 96       	adiw	r26, 0x22	; 34
    6f0a:	4d 90       	ld	r4, X+
    6f0c:	5d 90       	ld	r5, X+
    6f0e:	6d 90       	ld	r6, X+
    6f10:	7c 90       	ld	r7, X
    6f12:	95 97       	sbiw	r26, 0x25	; 37
	message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    6f14:	45 a2       	std	Z+37, r4	; 0x25
    6f16:	56 a2       	std	Z+38, r5	; 0x26
    6f18:	67 a2       	std	Z+39, r6	; 0x27
    6f1a:	70 a6       	std	Z+40, r7	; 0x28
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
    6f1c:	6d 01       	movw	r12, r26
    6f1e:	b6 e4       	ldi	r27, 0x46	; 70
    6f20:	cb 0e       	add	r12, r27
    6f22:	d1 1c       	adc	r13, r1
    6f24:	d6 01       	movw	r26, r12
    6f26:	4d 90       	ld	r4, X+
    6f28:	5d 90       	ld	r5, X+
    6f2a:	6d 90       	ld	r6, X+
    6f2c:	7c 90       	ld	r7, X
	message->XDerivativeError = model->XDerivativeError();
    6f2e:	41 ae       	std	Z+57, r4	; 0x39
    6f30:	52 ae       	std	Z+58, r5	; 0x3a
    6f32:	63 ae       	std	Z+59, r6	; 0x3b
    6f34:	74 ae       	std	Z+60, r7	; 0x3c
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
    6f36:	27 96       	adiw	r28, 0x07	; 7
    6f38:	ce ac       	ldd	r12, Y+62	; 0x3e
    6f3a:	df ac       	ldd	r13, Y+63	; 0x3f
    6f3c:	27 97       	sbiw	r28, 0x07	; 7
    6f3e:	b2 e4       	ldi	r27, 0x42	; 66
    6f40:	cb 0e       	add	r12, r27
    6f42:	d1 1c       	adc	r13, r1
    6f44:	d6 01       	movw	r26, r12
    6f46:	4d 90       	ld	r4, X+
    6f48:	5d 90       	ld	r5, X+
    6f4a:	6d 90       	ld	r6, X+
    6f4c:	7c 90       	ld	r7, X
	message->XIntegral = model->XIntegral();
    6f4e:	41 aa       	std	Z+49, r4	; 0x31
    6f50:	52 aa       	std	Z+50, r5	; 0x32
    6f52:	63 aa       	std	Z+51, r6	; 0x33
    6f54:	74 aa       	std	Z+52, r7	; 0x34
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
    6f56:	27 96       	adiw	r28, 0x07	; 7
    6f58:	ce ac       	ldd	r12, Y+62	; 0x3e
    6f5a:	df ac       	ldd	r13, Y+63	; 0x3f
    6f5c:	27 97       	sbiw	r28, 0x07	; 7
    6f5e:	be e3       	ldi	r27, 0x3E	; 62
    6f60:	cb 0e       	add	r12, r27
    6f62:	d1 1c       	adc	r13, r1
    6f64:	d6 01       	movw	r26, r12
    6f66:	4d 90       	ld	r4, X+
    6f68:	5d 90       	ld	r5, X+
    6f6a:	6d 90       	ld	r6, X+
    6f6c:	7c 90       	ld	r7, X
	message->XProportional = model->XProportional();
    6f6e:	45 aa       	std	Z+53, r4	; 0x35
    6f70:	56 aa       	std	Z+54, r5	; 0x36
    6f72:	67 aa       	std	Z+55, r6	; 0x37
    6f74:	70 ae       	std	Z+56, r7	; 0x38
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    6f76:	27 96       	adiw	r28, 0x07	; 7
    6f78:	ae ad       	ldd	r26, Y+62	; 0x3e
    6f7a:	bf ad       	ldd	r27, Y+63	; 0x3f
    6f7c:	27 97       	sbiw	r28, 0x07	; 7
    6f7e:	d2 96       	adiw	r26, 0x32	; 50
    6f80:	4d 90       	ld	r4, X+
    6f82:	5d 90       	ld	r5, X+
    6f84:	6d 90       	ld	r6, X+
    6f86:	7c 90       	ld	r7, X
    6f88:	d5 97       	sbiw	r26, 0x35	; 53
	message->XVelocityFRDCms = model->XVelocityFRDCms();
    6f8a:	41 a6       	std	Z+41, r4	; 0x29
    6f8c:	52 a6       	std	Z+42, r5	; 0x2a
    6f8e:	63 a6       	std	Z+43, r6	; 0x2b
    6f90:	74 a6       	std	Z+44, r7	; 0x2c
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    6f92:	9e 96       	adiw	r26, 0x2e	; 46
    6f94:	4d 90       	ld	r4, X+
    6f96:	5d 90       	ld	r5, X+
    6f98:	6d 90       	ld	r6, X+
    6f9a:	7c 90       	ld	r7, X
    6f9c:	d1 97       	sbiw	r26, 0x31	; 49
	message->LongitudeControl = model->LongitudeControl();
    6f9e:	d7 01       	movw	r26, r14
    6fa0:	4d 92       	st	X+, r4
    6fa2:	5d 92       	st	X+, r5
    6fa4:	6d 92       	st	X+, r6
    6fa6:	7c 92       	st	X, r7
    6fa8:	13 97       	sbiw	r26, 0x03	; 3
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
    6faa:	27 96       	adiw	r28, 0x07	; 7
    6fac:	ae ad       	ldd	r26, Y+62	; 0x3e
    6fae:	bf ad       	ldd	r27, Y+63	; 0x3f
    6fb0:	27 97       	sbiw	r28, 0x07	; 7
    6fb2:	da 96       	adiw	r26, 0x3a	; 58
    6fb4:	cd 90       	ld	r12, X+
    6fb6:	dd 90       	ld	r13, X+
    6fb8:	ed 90       	ld	r14, X+
    6fba:	fc 90       	ld	r15, X
    6fbc:	dd 97       	sbiw	r26, 0x3d	; 61
	message->XLongitudeOuterLoopSetpoint = model->XLongitudeOuterLoopSetpoint();
    6fbe:	d8 01       	movw	r26, r16
    6fc0:	cd 92       	st	X+, r12
    6fc2:	dd 92       	st	X+, r13
    6fc4:	ed 92       	st	X+, r14
    6fc6:	fc 92       	st	X, r15
    6fc8:	13 97       	sbiw	r26, 0x03	; 3
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    6fca:	27 96       	adiw	r28, 0x07	; 7
    6fcc:	0e ad       	ldd	r16, Y+62	; 0x3e
    6fce:	1f ad       	ldd	r17, Y+63	; 0x3f
    6fd0:	27 97       	sbiw	r28, 0x07	; 7
    6fd2:	06 52       	subi	r16, 0x26	; 38
    6fd4:	1f 4f       	sbci	r17, 0xFF	; 255
    6fd6:	d8 01       	movw	r26, r16
    6fd8:	cd 90       	ld	r12, X+
    6fda:	dd 90       	ld	r13, X+
    6fdc:	ed 90       	ld	r14, X+
    6fde:	fc 90       	ld	r15, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    6fe0:	dc 01       	movw	r26, r24
    6fe2:	cd 92       	st	X+, r12
    6fe4:	dd 92       	st	X+, r13
    6fe6:	ed 92       	st	X+, r14
    6fe8:	fc 92       	st	X, r15
    6fea:	13 97       	sbiw	r26, 0x03	; 3
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    6fec:	27 96       	adiw	r28, 0x07	; 7
    6fee:	ee ac       	ldd	r14, Y+62	; 0x3e
    6ff0:	ff ac       	ldd	r15, Y+63	; 0x3f
    6ff2:	27 97       	sbiw	r28, 0x07	; 7
    6ff4:	be ec       	ldi	r27, 0xCE	; 206
    6ff6:	eb 0e       	add	r14, r27
    6ff8:	f1 1c       	adc	r15, r1
    6ffa:	d7 01       	movw	r26, r14
    6ffc:	cd 90       	ld	r12, X+
    6ffe:	dd 90       	ld	r13, X+
    7000:	ed 90       	ld	r14, X+
    7002:	fc 90       	ld	r15, X

	
	message->RollRads = model->RollRads();
    7004:	db 01       	movw	r26, r22
    7006:	cd 92       	st	X+, r12
    7008:	dd 92       	st	X+, r13
    700a:	ed 92       	st	X+, r14
    700c:	fc 92       	st	X, r15
    700e:	13 97       	sbiw	r26, 0x03	; 3
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    7010:	27 96       	adiw	r28, 0x07	; 7
    7012:	6e ad       	ldd	r22, Y+62	; 0x3e
    7014:	7f ad       	ldd	r23, Y+63	; 0x3f
    7016:	27 97       	sbiw	r28, 0x07	; 7
    7018:	62 5b       	subi	r22, 0xB2	; 178
    701a:	7f 4f       	sbci	r23, 0xFF	; 255
    701c:	db 01       	movw	r26, r22
    701e:	cd 90       	ld	r12, X+
    7020:	dd 90       	ld	r13, X+
    7022:	ed 90       	ld	r14, X+
    7024:	fc 90       	ld	r15, X
	message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    7026:	da 01       	movw	r26, r20
    7028:	cd 92       	st	X+, r12
    702a:	dd 92       	st	X+, r13
    702c:	ed 92       	st	X+, r14
    702e:	fc 92       	st	X, r15
    7030:	13 97       	sbiw	r26, 0x03	; 3
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
    7032:	27 96       	adiw	r28, 0x07	; 7
    7034:	4e ad       	ldd	r20, Y+62	; 0x3e
    7036:	5f ad       	ldd	r21, Y+63	; 0x3f
    7038:	27 97       	sbiw	r28, 0x07	; 7
    703a:	4e 58       	subi	r20, 0x8E	; 142
    703c:	5f 4f       	sbci	r21, 0xFF	; 255
    703e:	da 01       	movw	r26, r20
    7040:	4d 91       	ld	r20, X+
    7042:	5d 91       	ld	r21, X+
    7044:	6d 91       	ld	r22, X+
    7046:	7c 91       	ld	r23, X
	message->YDerivativeError = model->YDerivativeError();
    7048:	29 96       	adiw	r28, 0x09	; 9
    704a:	ae ad       	ldd	r26, Y+62	; 0x3e
    704c:	bf ad       	ldd	r27, Y+63	; 0x3f
    704e:	29 97       	sbiw	r28, 0x09	; 9
    7050:	4d 93       	st	X+, r20
    7052:	5d 93       	st	X+, r21
    7054:	6d 93       	st	X+, r22
    7056:	7c 93       	st	X, r23
    7058:	13 97       	sbiw	r26, 0x03	; 3
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
    705a:	27 96       	adiw	r28, 0x07	; 7
    705c:	2e ad       	ldd	r18, Y+62	; 0x3e
    705e:	3f ad       	ldd	r19, Y+63	; 0x3f
    7060:	27 97       	sbiw	r28, 0x07	; 7
    7062:	22 59       	subi	r18, 0x92	; 146
    7064:	3f 4f       	sbci	r19, 0xFF	; 255
    7066:	d9 01       	movw	r26, r18
    7068:	4d 91       	ld	r20, X+
    706a:	5d 91       	ld	r21, X+
    706c:	6d 91       	ld	r22, X+
    706e:	7c 91       	ld	r23, X
	message->YIntegral = model->YIntegral();
    7070:	d5 01       	movw	r26, r10
    7072:	4d 93       	st	X+, r20
    7074:	5d 93       	st	X+, r21
    7076:	6d 93       	st	X+, r22
    7078:	7c 93       	st	X, r23
    707a:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
    707c:	27 96       	adiw	r28, 0x07	; 7
    707e:	2e ad       	ldd	r18, Y+62	; 0x3e
    7080:	3f ad       	ldd	r19, Y+63	; 0x3f
    7082:	27 97       	sbiw	r28, 0x07	; 7
    7084:	26 59       	subi	r18, 0x96	; 150
    7086:	3f 4f       	sbci	r19, 0xFF	; 255
    7088:	d9 01       	movw	r26, r18
    708a:	4d 91       	ld	r20, X+
    708c:	5d 91       	ld	r21, X+
    708e:	6d 91       	ld	r22, X+
    7090:	7c 91       	ld	r23, X
	message->YProportional = model->YProportional();
    7092:	d4 01       	movw	r26, r8
    7094:	4d 93       	st	X+, r20
    7096:	5d 93       	st	X+, r21
    7098:	6d 93       	st	X+, r22
    709a:	7c 93       	st	X, r23
    709c:	13 97       	sbiw	r26, 0x03	; 3
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    709e:	27 96       	adiw	r28, 0x07	; 7
    70a0:	2e ad       	ldd	r18, Y+62	; 0x3e
    70a2:	3f ad       	ldd	r19, Y+63	; 0x3f
    70a4:	27 97       	sbiw	r28, 0x07	; 7
    70a6:	22 5a       	subi	r18, 0xA2	; 162
    70a8:	3f 4f       	sbci	r19, 0xFF	; 255
    70aa:	d9 01       	movw	r26, r18
    70ac:	4d 91       	ld	r20, X+
    70ae:	5d 91       	ld	r21, X+
    70b0:	6d 91       	ld	r22, X+
    70b2:	7c 91       	ld	r23, X
	message->YVelocityFRDCms = model->YVelocityFRDCms();
    70b4:	d1 01       	movw	r26, r2
    70b6:	4d 93       	st	X+, r20
    70b8:	5d 93       	st	X+, r21
    70ba:	6d 93       	st	X+, r22
    70bc:	7c 93       	st	X, r23
    70be:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    70c0:	27 96       	adiw	r28, 0x07	; 7
    70c2:	2e ad       	ldd	r18, Y+62	; 0x3e
    70c4:	3f ad       	ldd	r19, Y+63	; 0x3f
    70c6:	27 97       	sbiw	r28, 0x07	; 7
    70c8:	26 5a       	subi	r18, 0xA6	; 166
    70ca:	3f 4f       	sbci	r19, 0xFF	; 255
    70cc:	d9 01       	movw	r26, r18
    70ce:	4d 91       	ld	r20, X+
    70d0:	5d 91       	ld	r21, X+
    70d2:	6d 91       	ld	r22, X+
    70d4:	7c 91       	ld	r23, X
	message->LateralControl = model->LateralControl();
    70d6:	a9 81       	ldd	r26, Y+1	; 0x01
    70d8:	ba 81       	ldd	r27, Y+2	; 0x02
    70da:	4d 93       	st	X+, r20
    70dc:	5d 93       	st	X+, r21
    70de:	6d 93       	st	X+, r22
    70e0:	7c 93       	st	X, r23
    70e2:	13 97       	sbiw	r26, 0x03	; 3
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
    70e4:	27 96       	adiw	r28, 0x07	; 7
    70e6:	2e ad       	ldd	r18, Y+62	; 0x3e
    70e8:	3f ad       	ldd	r19, Y+63	; 0x3f
    70ea:	27 97       	sbiw	r28, 0x07	; 7
    70ec:	2a 59       	subi	r18, 0x9A	; 154
    70ee:	3f 4f       	sbci	r19, 0xFF	; 255
    70f0:	d9 01       	movw	r26, r18
    70f2:	4d 91       	ld	r20, X+
    70f4:	5d 91       	ld	r21, X+
    70f6:	6d 91       	ld	r22, X+
    70f8:	7c 91       	ld	r23, X
	message->YLateralOuterLoopSetpoint = model->YLateralOuterLoopSetpoint();
    70fa:	ab 81       	ldd	r26, Y+3	; 0x03
    70fc:	bc 81       	ldd	r27, Y+4	; 0x04
    70fe:	4d 93       	st	X+, r20
    7100:	5d 93       	st	X+, r21
    7102:	6d 93       	st	X+, r22
    7104:	7c 93       	st	X, r23
    7106:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    7108:	27 96       	adiw	r28, 0x07	; 7
    710a:	2e ad       	ldd	r18, Y+62	; 0x3e
    710c:	3f ad       	ldd	r19, Y+63	; 0x3f
    710e:	27 97       	sbiw	r28, 0x07	; 7
    7110:	22 52       	subi	r18, 0x22	; 34
    7112:	3f 4f       	sbci	r19, 0xFF	; 255
    7114:	d9 01       	movw	r26, r18
    7116:	4d 91       	ld	r20, X+
    7118:	5d 91       	ld	r21, X+
    711a:	6d 91       	ld	r22, X+
    711c:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();	
    711e:	2b 96       	adiw	r28, 0x0b	; 11
    7120:	ae ad       	ldd	r26, Y+62	; 0x3e
    7122:	bf ad       	ldd	r27, Y+63	; 0x3f
    7124:	2b 97       	sbiw	r28, 0x0b	; 11
    7126:	4d 93       	st	X+, r20
    7128:	5d 93       	st	X+, r21
    712a:	6d 93       	st	X+, r22
    712c:	7c 93       	st	X, r23
    712e:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}

			float ZDerivativeError() const {return zDerivativeError;}
    7130:	27 96       	adiw	r28, 0x07	; 7
    7132:	4e ad       	ldd	r20, Y+62	; 0x3e
    7134:	5f ad       	ldd	r21, Y+63	; 0x3f
    7136:	27 97       	sbiw	r28, 0x07	; 7
    7138:	42 56       	subi	r20, 0x62	; 98
    713a:	5f 4f       	sbci	r21, 0xFF	; 255
    713c:	da 01       	movw	r26, r20
    713e:	4d 91       	ld	r20, X+
    7140:	5d 91       	ld	r21, X+
    7142:	6d 91       	ld	r22, X+
    7144:	7c 91       	ld	r23, X
	
	
	//message->AltitudeMetersAgl = model->AltitudeMetersAgl();
	message->ZDerivativeError = model->ZDerivativeError();
    7146:	ad 85       	ldd	r26, Y+13	; 0x0d
    7148:	be 85       	ldd	r27, Y+14	; 0x0e
    714a:	4d 93       	st	X+, r20
    714c:	5d 93       	st	X+, r21
    714e:	6d 93       	st	X+, r22
    7150:	7c 93       	st	X, r23
    7152:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    7154:	27 96       	adiw	r28, 0x07	; 7
    7156:	4e ad       	ldd	r20, Y+62	; 0x3e
    7158:	5f ad       	ldd	r21, Y+63	; 0x3f
    715a:	27 97       	sbiw	r28, 0x07	; 7
    715c:	4a 52       	subi	r20, 0x2A	; 42
    715e:	5f 4f       	sbci	r21, 0xFF	; 255
    7160:	da 01       	movw	r26, r20
    7162:	4d 91       	ld	r20, X+
    7164:	5d 91       	ld	r21, X+
    7166:	6d 91       	ld	r22, X+
    7168:	7c 91       	ld	r23, X
	message->YawRads = model->YawRads();
    716a:	af 81       	ldd	r26, Y+7	; 0x07
    716c:	b8 85       	ldd	r27, Y+8	; 0x08
    716e:	4d 93       	st	X+, r20
    7170:	5d 93       	st	X+, r21
    7172:	6d 93       	st	X+, r22
    7174:	7c 93       	st	X, r23
    7176:	13 97       	sbiw	r26, 0x03	; 3
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
    7178:	27 96       	adiw	r28, 0x07	; 7
    717a:	4e ad       	ldd	r20, Y+62	; 0x3e
    717c:	5f ad       	ldd	r21, Y+63	; 0x3f
    717e:	27 97       	sbiw	r28, 0x07	; 7
    7180:	4a 56       	subi	r20, 0x6A	; 106
    7182:	5f 4f       	sbci	r21, 0xFF	; 255
    7184:	da 01       	movw	r26, r20
    7186:	4d 91       	ld	r20, X+
    7188:	5d 91       	ld	r21, X+
    718a:	6d 91       	ld	r22, X+
    718c:	7c 91       	ld	r23, X
	message->ZIntegral = model->ZIntegral();
    718e:	a9 85       	ldd	r26, Y+9	; 0x09
    7190:	ba 85       	ldd	r27, Y+10	; 0x0a
    7192:	4d 93       	st	X+, r20
    7194:	5d 93       	st	X+, r21
    7196:	6d 93       	st	X+, r22
    7198:	7c 93       	st	X, r23
    719a:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
    719c:	27 96       	adiw	r28, 0x07	; 7
    719e:	4e ad       	ldd	r20, Y+62	; 0x3e
    71a0:	5f ad       	ldd	r21, Y+63	; 0x3f
    71a2:	27 97       	sbiw	r28, 0x07	; 7
    71a4:	46 56       	subi	r20, 0x66	; 102
    71a6:	5f 4f       	sbci	r21, 0xFF	; 255
    71a8:	da 01       	movw	r26, r20
    71aa:	4d 91       	ld	r20, X+
    71ac:	5d 91       	ld	r21, X+
    71ae:	6d 91       	ld	r22, X+
    71b0:	7c 91       	ld	r23, X
	message->ZProportional = model->ZProportional();
    71b2:	ab 85       	ldd	r26, Y+11	; 0x0b
    71b4:	bc 85       	ldd	r27, Y+12	; 0x0c
    71b6:	4d 93       	st	X+, r20
    71b8:	5d 93       	st	X+, r21
    71ba:	6d 93       	st	X+, r22
    71bc:	7c 93       	st	X, r23
    71be:	13 97       	sbiw	r26, 0x03	; 3
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    71c0:	27 96       	adiw	r28, 0x07	; 7
    71c2:	4e ad       	ldd	r20, Y+62	; 0x3e
    71c4:	5f ad       	ldd	r21, Y+63	; 0x3f
    71c6:	27 97       	sbiw	r28, 0x07	; 7
    71c8:	42 57       	subi	r20, 0x72	; 114
    71ca:	5f 4f       	sbci	r21, 0xFF	; 255
    71cc:	da 01       	movw	r26, r20
    71ce:	4d 91       	ld	r20, X+
    71d0:	5d 91       	ld	r21, X+
    71d2:	6d 91       	ld	r22, X+
    71d4:	7c 91       	ld	r23, X
	message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    71d6:	ad 81       	ldd	r26, Y+5	; 0x05
    71d8:	be 81       	ldd	r27, Y+6	; 0x06
    71da:	4d 93       	st	X+, r20
    71dc:	5d 93       	st	X+, r21
    71de:	6d 93       	st	X+, r22
    71e0:	7c 93       	st	X, r23
    71e2:	13 97       	sbiw	r26, 0x03	; 3

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    71e4:	27 96       	adiw	r28, 0x07	; 7
    71e6:	4e ad       	ldd	r20, Y+62	; 0x3e
    71e8:	5f ad       	ldd	r21, Y+63	; 0x3f
    71ea:	27 97       	sbiw	r28, 0x07	; 7
    71ec:	4a 57       	subi	r20, 0x7A	; 122
    71ee:	5f 4f       	sbci	r21, 0xFF	; 255
    71f0:	da 01       	movw	r26, r20
    71f2:	4d 91       	ld	r20, X+
    71f4:	5d 91       	ld	r21, X+
    71f6:	6d 91       	ld	r22, X+
    71f8:	7c 91       	ld	r23, X
	message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    71fa:	af 85       	ldd	r26, Y+15	; 0x0f
    71fc:	b8 89       	ldd	r27, Y+16	; 0x10
    71fe:	4d 93       	st	X+, r20
    7200:	5d 93       	st	X+, r21
    7202:	6d 93       	st	X+, r22
    7204:	7c 93       	st	X, r23
    7206:	13 97       	sbiw	r26, 0x03	; 3
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    7208:	27 96       	adiw	r28, 0x07	; 7
    720a:	4e ad       	ldd	r20, Y+62	; 0x3e
    720c:	5f ad       	ldd	r21, Y+63	; 0x3f
    720e:	27 97       	sbiw	r28, 0x07	; 7
    7210:	42 58       	subi	r20, 0x82	; 130
    7212:	5f 4f       	sbci	r21, 0xFF	; 255
    7214:	da 01       	movw	r26, r20
    7216:	4d 91       	ld	r20, X+
    7218:	5d 91       	ld	r21, X+
    721a:	6d 91       	ld	r22, X+
    721c:	7c 91       	ld	r23, X
	message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    721e:	a9 89       	ldd	r26, Y+17	; 0x11
    7220:	ba 89       	ldd	r27, Y+18	; 0x12
    7222:	4d 93       	st	X+, r20
    7224:	5d 93       	st	X+, r21
    7226:	6d 93       	st	X+, r22
    7228:	7c 93       	st	X, r23
    722a:	13 97       	sbiw	r26, 0x03	; 3

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    722c:	27 96       	adiw	r28, 0x07	; 7
    722e:	4e ad       	ldd	r20, Y+62	; 0x3e
    7230:	5f ad       	ldd	r21, Y+63	; 0x3f
    7232:	27 97       	sbiw	r28, 0x07	; 7
    7234:	4a 51       	subi	r20, 0x1A	; 26
    7236:	5f 4f       	sbci	r21, 0xFF	; 255
    7238:	da 01       	movw	r26, r20
    723a:	4d 91       	ld	r20, X+
    723c:	5d 91       	ld	r21, X+
    723e:	6d 91       	ld	r22, X+
    7240:	7c 91       	ld	r23, X
	
	
	
	message->XAccelFrdMss = model->XAccelFrdMss();
    7242:	af 89       	ldd	r26, Y+23	; 0x17
    7244:	b8 8d       	ldd	r27, Y+24	; 0x18
    7246:	4d 93       	st	X+, r20
    7248:	5d 93       	st	X+, r21
    724a:	6d 93       	st	X+, r22
    724c:	7c 93       	st	X, r23
    724e:	13 97       	sbiw	r26, 0x03	; 3
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    7250:	27 96       	adiw	r28, 0x07	; 7
    7252:	4e ad       	ldd	r20, Y+62	; 0x3e
    7254:	5f ad       	ldd	r21, Y+63	; 0x3f
    7256:	27 97       	sbiw	r28, 0x07	; 7
    7258:	46 51       	subi	r20, 0x16	; 22
    725a:	5f 4f       	sbci	r21, 0xFF	; 255
    725c:	da 01       	movw	r26, r20
    725e:	4d 91       	ld	r20, X+
    7260:	5d 91       	ld	r21, X+
    7262:	6d 91       	ld	r22, X+
    7264:	7c 91       	ld	r23, X
	message->YAccelFrdMss = model->YAccelFrdMss();
    7266:	a9 8d       	ldd	r26, Y+25	; 0x19
    7268:	ba 8d       	ldd	r27, Y+26	; 0x1a
    726a:	4d 93       	st	X+, r20
    726c:	5d 93       	st	X+, r21
    726e:	6d 93       	st	X+, r22
    7270:	7c 93       	st	X, r23
    7272:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    7274:	27 96       	adiw	r28, 0x07	; 7
    7276:	4e ad       	ldd	r20, Y+62	; 0x3e
    7278:	5f ad       	ldd	r21, Y+63	; 0x3f
    727a:	27 97       	sbiw	r28, 0x07	; 7
    727c:	42 51       	subi	r20, 0x12	; 18
    727e:	5f 4f       	sbci	r21, 0xFF	; 255
    7280:	da 01       	movw	r26, r20
    7282:	4d 91       	ld	r20, X+
    7284:	5d 91       	ld	r21, X+
    7286:	6d 91       	ld	r22, X+
    7288:	7c 91       	ld	r23, X
	message->ZAccelFrdMss = model->ZAccelFrdMss();
    728a:	ab 8d       	ldd	r26, Y+27	; 0x1b
    728c:	bc 8d       	ldd	r27, Y+28	; 0x1c
    728e:	4d 93       	st	X+, r20
    7290:	5d 93       	st	X+, r21
    7292:	6d 93       	st	X+, r22
    7294:	7c 93       	st	X, r23
    7296:	13 97       	sbiw	r26, 0x03	; 3
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    7298:	27 96       	adiw	r28, 0x07	; 7
    729a:	4e ad       	ldd	r20, Y+62	; 0x3e
    729c:	5f ad       	ldd	r21, Y+63	; 0x3f
    729e:	27 97       	sbiw	r28, 0x07	; 7
    72a0:	4e 51       	subi	r20, 0x1E	; 30
    72a2:	5f 4f       	sbci	r21, 0xFF	; 255
    72a4:	da 01       	movw	r26, r20
    72a6:	4d 91       	ld	r20, X+
    72a8:	5d 91       	ld	r21, X+
    72aa:	6d 91       	ld	r22, X+
    72ac:	7c 91       	ld	r23, X
	message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    72ae:	ad 8d       	ldd	r26, Y+29	; 0x1d
    72b0:	be 8d       	ldd	r27, Y+30	; 0x1e
    72b2:	4d 93       	st	X+, r20
    72b4:	5d 93       	st	X+, r21
    72b6:	6d 93       	st	X+, r22
    72b8:	7c 93       	st	X, r23
    72ba:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    72bc:	d8 01       	movw	r26, r16
    72be:	4d 91       	ld	r20, X+
    72c0:	5d 91       	ld	r21, X+
    72c2:	6d 91       	ld	r22, X+
    72c4:	7c 91       	ld	r23, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    72c6:	dc 01       	movw	r26, r24
    72c8:	4d 93       	st	X+, r20
    72ca:	5d 93       	st	X+, r21
    72cc:	6d 93       	st	X+, r22
    72ce:	7c 93       	st	X, r23
    72d0:	13 97       	sbiw	r26, 0x03	; 3
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    72d2:	d9 01       	movw	r26, r18
    72d4:	4d 91       	ld	r20, X+
    72d6:	5d 91       	ld	r21, X+
    72d8:	6d 91       	ld	r22, X+
    72da:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    72dc:	2b 96       	adiw	r28, 0x0b	; 11
    72de:	ae ad       	ldd	r26, Y+62	; 0x3e
    72e0:	bf ad       	ldd	r27, Y+63	; 0x3f
    72e2:	2b 97       	sbiw	r28, 0x0b	; 11
    72e4:	4d 93       	st	X+, r20
    72e6:	5d 93       	st	X+, r21
    72e8:	6d 93       	st	X+, r22
    72ea:	7c 93       	st	X, r23
    72ec:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    72ee:	27 96       	adiw	r28, 0x07	; 7
    72f0:	ae ad       	ldd	r26, Y+62	; 0x3e
    72f2:	bf ad       	ldd	r27, Y+63	; 0x3f
    72f4:	27 97       	sbiw	r28, 0x07	; 7
    72f6:	ae 50       	subi	r26, 0x0E	; 14
    72f8:	bf 4f       	sbci	r27, 0xFF	; 255
    72fa:	4d 91       	ld	r20, X+
    72fc:	5d 91       	ld	r21, X+
    72fe:	6d 91       	ld	r22, X+
    7300:	7c 91       	ld	r23, X
	message->XMagFrd = model->XMagFrd();
    7302:	af 8d       	ldd	r26, Y+31	; 0x1f
    7304:	b8 a1       	ldd	r27, Y+32	; 0x20
    7306:	4d 93       	st	X+, r20
    7308:	5d 93       	st	X+, r21
    730a:	6d 93       	st	X+, r22
    730c:	7c 93       	st	X, r23
    730e:	13 97       	sbiw	r26, 0x03	; 3
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    7310:	27 96       	adiw	r28, 0x07	; 7
    7312:	ae ad       	ldd	r26, Y+62	; 0x3e
    7314:	bf ad       	ldd	r27, Y+63	; 0x3f
    7316:	27 97       	sbiw	r28, 0x07	; 7
    7318:	aa 50       	subi	r26, 0x0A	; 10
    731a:	bf 4f       	sbci	r27, 0xFF	; 255
    731c:	4d 91       	ld	r20, X+
    731e:	5d 91       	ld	r21, X+
    7320:	6d 91       	ld	r22, X+
    7322:	7c 91       	ld	r23, X
	message->YMagFrd = model->YMagFrd();
    7324:	a9 a1       	ldd	r26, Y+33	; 0x21
    7326:	ba a1       	ldd	r27, Y+34	; 0x22
    7328:	4d 93       	st	X+, r20
    732a:	5d 93       	st	X+, r21
    732c:	6d 93       	st	X+, r22
    732e:	7c 93       	st	X, r23
    7330:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    7332:	27 96       	adiw	r28, 0x07	; 7
    7334:	ae ad       	ldd	r26, Y+62	; 0x3e
    7336:	bf ad       	ldd	r27, Y+63	; 0x3f
    7338:	27 97       	sbiw	r28, 0x07	; 7
    733a:	a6 50       	subi	r26, 0x06	; 6
    733c:	bf 4f       	sbci	r27, 0xFF	; 255
    733e:	4d 91       	ld	r20, X+
    7340:	5d 91       	ld	r21, X+
    7342:	6d 91       	ld	r22, X+
    7344:	7c 91       	ld	r23, X
	message->ZMagFrd = model->ZMagFrd();
    7346:	ab a1       	ldd	r26, Y+35	; 0x23
    7348:	bc a1       	ldd	r27, Y+36	; 0x24
    734a:	4d 93       	st	X+, r20
    734c:	5d 93       	st	X+, r21
    734e:	6d 93       	st	X+, r22
    7350:	7c 93       	st	X, r23
    7352:	13 97       	sbiw	r26, 0x03	; 3
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    7354:	27 96       	adiw	r28, 0x07	; 7
    7356:	ae ad       	ldd	r26, Y+62	; 0x3e
    7358:	bf ad       	ldd	r27, Y+63	; 0x3f
    735a:	27 97       	sbiw	r28, 0x07	; 7
    735c:	a2 50       	subi	r26, 0x02	; 2
    735e:	bf 4f       	sbci	r27, 0xFF	; 255
    7360:	4d 91       	ld	r20, X+
    7362:	5d 91       	ld	r21, X+
    7364:	6d 91       	ld	r22, X+
    7366:	7c 91       	ld	r23, X

	message->XEcefCm = model->XEcefCm();
    7368:	ad a1       	ldd	r26, Y+37	; 0x25
    736a:	be a1       	ldd	r27, Y+38	; 0x26
    736c:	4d 93       	st	X+, r20
    736e:	5d 93       	st	X+, r21
    7370:	6d 93       	st	X+, r22
    7372:	7c 93       	st	X, r23
    7374:	13 97       	sbiw	r26, 0x03	; 3
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    7376:	27 96       	adiw	r28, 0x07	; 7
    7378:	ae ad       	ldd	r26, Y+62	; 0x3e
    737a:	bf ad       	ldd	r27, Y+63	; 0x3f
    737c:	27 97       	sbiw	r28, 0x07	; 7
    737e:	ae 5f       	subi	r26, 0xFE	; 254
    7380:	be 4f       	sbci	r27, 0xFE	; 254
    7382:	4d 91       	ld	r20, X+
    7384:	5d 91       	ld	r21, X+
    7386:	6d 91       	ld	r22, X+
    7388:	7c 91       	ld	r23, X
	message->YEcefCm = model->YEcefCm();
    738a:	af a1       	ldd	r26, Y+39	; 0x27
    738c:	b8 a5       	ldd	r27, Y+40	; 0x28
    738e:	4d 93       	st	X+, r20
    7390:	5d 93       	st	X+, r21
    7392:	6d 93       	st	X+, r22
    7394:	7c 93       	st	X, r23
    7396:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    7398:	27 96       	adiw	r28, 0x07	; 7
    739a:	ae ad       	ldd	r26, Y+62	; 0x3e
    739c:	bf ad       	ldd	r27, Y+63	; 0x3f
    739e:	27 97       	sbiw	r28, 0x07	; 7
    73a0:	aa 5f       	subi	r26, 0xFA	; 250
    73a2:	be 4f       	sbci	r27, 0xFE	; 254
    73a4:	4d 91       	ld	r20, X+
    73a6:	5d 91       	ld	r21, X+
    73a8:	6d 91       	ld	r22, X+
    73aa:	7c 91       	ld	r23, X
	message->ZEcefCm = model->ZEcefCm();	
    73ac:	a9 a5       	ldd	r26, Y+41	; 0x29
    73ae:	ba a5       	ldd	r27, Y+42	; 0x2a
    73b0:	4d 93       	st	X+, r20
    73b2:	5d 93       	st	X+, r21
    73b4:	6d 93       	st	X+, r22
    73b6:	7c 93       	st	X, r23
    73b8:	13 97       	sbiw	r26, 0x03	; 3
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    73ba:	27 96       	adiw	r28, 0x07	; 7
    73bc:	ae ad       	ldd	r26, Y+62	; 0x3e
    73be:	bf ad       	ldd	r27, Y+63	; 0x3f
    73c0:	27 97       	sbiw	r28, 0x07	; 7
    73c2:	a6 5f       	subi	r26, 0xF6	; 246
    73c4:	be 4f       	sbci	r27, 0xFE	; 254
    73c6:	4d 91       	ld	r20, X+
    73c8:	5d 91       	ld	r21, X+
    73ca:	6d 91       	ld	r22, X+
    73cc:	7c 91       	ld	r23, X
	message->XVEcefCms = model->XVEcefCms();
    73ce:	ab a5       	ldd	r26, Y+43	; 0x2b
    73d0:	bc a5       	ldd	r27, Y+44	; 0x2c
    73d2:	4d 93       	st	X+, r20
    73d4:	5d 93       	st	X+, r21
    73d6:	6d 93       	st	X+, r22
    73d8:	7c 93       	st	X, r23
    73da:	13 97       	sbiw	r26, 0x03	; 3
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    73dc:	27 96       	adiw	r28, 0x07	; 7
    73de:	ae ad       	ldd	r26, Y+62	; 0x3e
    73e0:	bf ad       	ldd	r27, Y+63	; 0x3f
    73e2:	27 97       	sbiw	r28, 0x07	; 7
    73e4:	a2 5f       	subi	r26, 0xF2	; 242
    73e6:	be 4f       	sbci	r27, 0xFE	; 254
    73e8:	4d 91       	ld	r20, X+
    73ea:	5d 91       	ld	r21, X+
    73ec:	6d 91       	ld	r22, X+
    73ee:	7c 91       	ld	r23, X
	message->YVEcefCms = model->YVEcefCms();
    73f0:	ad a5       	ldd	r26, Y+45	; 0x2d
    73f2:	be a5       	ldd	r27, Y+46	; 0x2e
    73f4:	4d 93       	st	X+, r20
    73f6:	5d 93       	st	X+, r21
    73f8:	6d 93       	st	X+, r22
    73fa:	7c 93       	st	X, r23
    73fc:	13 97       	sbiw	r26, 0x03	; 3
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    73fe:	27 96       	adiw	r28, 0x07	; 7
    7400:	ae ad       	ldd	r26, Y+62	; 0x3e
    7402:	bf ad       	ldd	r27, Y+63	; 0x3f
    7404:	27 97       	sbiw	r28, 0x07	; 7
    7406:	ae 5e       	subi	r26, 0xEE	; 238
    7408:	be 4f       	sbci	r27, 0xFE	; 254
    740a:	4d 91       	ld	r20, X+
    740c:	5d 91       	ld	r21, X+
    740e:	6d 91       	ld	r22, X+
    7410:	7c 91       	ld	r23, X
	message->ZVEcefCms = model->ZVEcefCms();
    7412:	af a5       	ldd	r26, Y+47	; 0x2f
    7414:	b8 a9       	ldd	r27, Y+48	; 0x30
    7416:	4d 93       	st	X+, r20
    7418:	5d 93       	st	X+, r21
    741a:	6d 93       	st	X+, r22
    741c:	7c 93       	st	X, r23
    741e:	13 97       	sbiw	r26, 0x03	; 3
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    7420:	27 96       	adiw	r28, 0x07	; 7
    7422:	ae ad       	ldd	r26, Y+62	; 0x3e
    7424:	bf ad       	ldd	r27, Y+63	; 0x3f
    7426:	27 97       	sbiw	r28, 0x07	; 7
    7428:	aa 5e       	subi	r26, 0xEA	; 234
    742a:	be 4f       	sbci	r27, 0xFE	; 254
    742c:	4d 91       	ld	r20, X+
    742e:	5d 91       	ld	r21, X+
    7430:	6d 91       	ld	r22, X+
    7432:	7c 91       	ld	r23, X
	message->PressureMillibars = model->PressureMillibars();
    7434:	a9 a9       	ldd	r26, Y+49	; 0x31
    7436:	ba a9       	ldd	r27, Y+50	; 0x32
    7438:	4d 93       	st	X+, r20
    743a:	5d 93       	st	X+, r21
    743c:	6d 93       	st	X+, r22
    743e:	7c 93       	st	X, r23
    7440:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    7442:	27 96       	adiw	r28, 0x07	; 7
    7444:	ae ad       	ldd	r26, Y+62	; 0x3e
    7446:	bf ad       	ldd	r27, Y+63	; 0x3f
    7448:	27 97       	sbiw	r28, 0x07	; 7
    744a:	ae 54       	subi	r26, 0x4E	; 78
    744c:	bf 4f       	sbci	r27, 0xFF	; 255
    744e:	4d 91       	ld	r20, X+
    7450:	5d 91       	ld	r21, X+
    7452:	6d 91       	ld	r22, X+
    7454:	7c 91       	ld	r23, X
	
	
	
	message->ChecksumErrors = model->ChecksumErrors();
    7456:	21 96       	adiw	r28, 0x01	; 1
    7458:	ae ad       	ldd	r26, Y+62	; 0x3e
    745a:	bf ad       	ldd	r27, Y+63	; 0x3f
    745c:	21 97       	sbiw	r28, 0x01	; 1
    745e:	4d 93       	st	X+, r20
    7460:	5d 93       	st	X+, r21
    7462:	6d 93       	st	X+, r22
    7464:	7c 93       	st	X, r23
    7466:	13 97       	sbiw	r26, 0x03	; 3

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    7468:	27 96       	adiw	r28, 0x07	; 7
    746a:	ae ad       	ldd	r26, Y+62	; 0x3e
    746c:	bf ad       	ldd	r27, Y+63	; 0x3f
    746e:	27 97       	sbiw	r28, 0x07	; 7
    7470:	a6 55       	subi	r26, 0x56	; 86
    7472:	bf 4f       	sbci	r27, 0xFF	; 255
    7474:	4d 91       	ld	r20, X+
    7476:	5d 91       	ld	r21, X+
    7478:	6d 91       	ld	r22, X+
    747a:	7c 91       	ld	r23, X
	message->Timeouts = model->Timeouts();
    747c:	ab ad       	ldd	r26, Y+59	; 0x3b
    747e:	bc ad       	ldd	r27, Y+60	; 0x3c
    7480:	4d 93       	st	X+, r20
    7482:	5d 93       	st	X+, r21
    7484:	6d 93       	st	X+, r22
    7486:	7c 93       	st	X, r23
    7488:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    748a:	27 96       	adiw	r28, 0x07	; 7
    748c:	ae ad       	ldd	r26, Y+62	; 0x3e
    748e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7490:	27 97       	sbiw	r28, 0x07	; 7
    7492:	a2 55       	subi	r26, 0x52	; 82
    7494:	bf 4f       	sbci	r27, 0xFF	; 255
    7496:	4d 91       	ld	r20, X+
    7498:	5d 91       	ld	r21, X+
    749a:	6d 91       	ld	r22, X+
    749c:	7c 91       	ld	r23, X
	message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    749e:	ad ad       	ldd	r26, Y+61	; 0x3d
    74a0:	be ad       	ldd	r27, Y+62	; 0x3e
    74a2:	4d 93       	st	X+, r20
    74a4:	5d 93       	st	X+, r21
    74a6:	6d 93       	st	X+, r22
    74a8:	7c 93       	st	X, r23
    74aa:	13 97       	sbiw	r26, 0x03	; 3
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    74ac:	27 96       	adiw	r28, 0x07	; 7
    74ae:	ae ad       	ldd	r26, Y+62	; 0x3e
    74b0:	bf ad       	ldd	r27, Y+63	; 0x3f
    74b2:	27 97       	sbiw	r28, 0x07	; 7
    74b4:	aa 54       	subi	r26, 0x4A	; 74
    74b6:	bf 4f       	sbci	r27, 0xFF	; 255
    74b8:	4d 91       	ld	r20, X+
    74ba:	5d 91       	ld	r21, X+
    74bc:	6d 91       	ld	r22, X+
    74be:	7c 91       	ld	r23, X
	message->NumOfBlownFrames = model->BlownFrames();
    74c0:	23 96       	adiw	r28, 0x03	; 3
    74c2:	ae ad       	ldd	r26, Y+62	; 0x3e
    74c4:	bf ad       	ldd	r27, Y+63	; 0x3f
    74c6:	23 97       	sbiw	r28, 0x03	; 3
    74c8:	4d 93       	st	X+, r20
    74ca:	5d 93       	st	X+, r21
    74cc:	6d 93       	st	X+, r22
    74ce:	7c 93       	st	X, r23
    74d0:	13 97       	sbiw	r26, 0x03	; 3
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    74d2:	27 96       	adiw	r28, 0x07	; 7
    74d4:	ae ad       	ldd	r26, Y+62	; 0x3e
    74d6:	bf ad       	ldd	r27, Y+63	; 0x3f
    74d8:	27 97       	sbiw	r28, 0x07	; 7
    74da:	a6 54       	subi	r26, 0x46	; 70
    74dc:	bf 4f       	sbci	r27, 0xFF	; 255
    74de:	4d 91       	ld	r20, X+
    74e0:	5d 91       	ld	r21, X+
    74e2:	6d 91       	ld	r22, X+
    74e4:	7c 91       	ld	r23, X
	message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    74e6:	25 96       	adiw	r28, 0x05	; 5
    74e8:	ae ad       	ldd	r26, Y+62	; 0x3e
    74ea:	bf ad       	ldd	r27, Y+63	; 0x3f
    74ec:	25 97       	sbiw	r28, 0x05	; 5
    74ee:	4d 93       	st	X+, r20
    74f0:	5d 93       	st	X+, r21
    74f2:	6d 93       	st	X+, r22
    74f4:	7c 93       	st	X, r23
    74f6:	13 97       	sbiw	r26, 0x03	; 3
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
    74f8:	27 96       	adiw	r28, 0x07	; 7
    74fa:	ae ad       	ldd	r26, Y+62	; 0x3e
    74fc:	bf ad       	ldd	r27, Y+63	; 0x3f
    74fe:	27 97       	sbiw	r28, 0x07	; 7
    7500:	96 96       	adiw	r26, 0x26	; 38
    7502:	4d 91       	ld	r20, X+
    7504:	5d 91       	ld	r21, X+
    7506:	6d 91       	ld	r22, X+
    7508:	7c 91       	ld	r23, X
    750a:	99 97       	sbiw	r26, 0x29	; 41
	
	
	
	message->XRefSetpoint = model->ReferenceXNEDLocalFrameCm();
    750c:	ab a9       	ldd	r26, Y+51	; 0x33
    750e:	bc a9       	ldd	r27, Y+52	; 0x34
    7510:	4d 93       	st	X+, r20
    7512:	5d 93       	st	X+, r21
    7514:	6d 93       	st	X+, r22
    7516:	7c 93       	st	X, r23
    7518:	13 97       	sbiw	r26, 0x03	; 3


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    751a:	27 96       	adiw	r28, 0x07	; 7
    751c:	ae ad       	ldd	r26, Y+62	; 0x3e
    751e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7520:	27 97       	sbiw	r28, 0x07	; 7
    7522:	ae 5a       	subi	r26, 0xAE	; 174
    7524:	bf 4f       	sbci	r27, 0xFF	; 255
    7526:	4d 91       	ld	r20, X+
    7528:	5d 91       	ld	r21, X+
    752a:	6d 91       	ld	r22, X+
    752c:	7c 91       	ld	r23, X
	message->YRefSetpoint = model->ReferenceYNEDLocalFrameCm();
    752e:	ad a9       	ldd	r26, Y+53	; 0x35
    7530:	be a9       	ldd	r27, Y+54	; 0x36
    7532:	4d 93       	st	X+, r20
    7534:	5d 93       	st	X+, r21
    7536:	6d 93       	st	X+, r22
    7538:	7c 93       	st	X, r23
    753a:	13 97       	sbiw	r26, 0x03	; 3

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    753c:	27 96       	adiw	r28, 0x07	; 7
    753e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7540:	bf ad       	ldd	r27, Y+63	; 0x3f
    7542:	27 97       	sbiw	r28, 0x07	; 7
    7544:	ae 57       	subi	r26, 0x7E	; 126
    7546:	bf 4f       	sbci	r27, 0xFF	; 255
    7548:	4d 91       	ld	r20, X+
    754a:	5d 91       	ld	r21, X+
    754c:	6d 91       	ld	r22, X+
    754e:	7c 91       	ld	r23, X
	message->ZRefSetpoint = model->ReferenceZNEDLocalFrameCm();	
    7550:	af a9       	ldd	r26, Y+55	; 0x37
    7552:	b8 ad       	ldd	r27, Y+56	; 0x38
    7554:	4d 93       	st	X+, r20
    7556:	5d 93       	st	X+, r21
    7558:	6d 93       	st	X+, r22
    755a:	7c 93       	st	X, r23
    755c:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
    755e:	27 96       	adiw	r28, 0x07	; 7
    7560:	ae ad       	ldd	r26, Y+62	; 0x3e
    7562:	bf ad       	ldd	r27, Y+63	; 0x3f
    7564:	27 97       	sbiw	r28, 0x07	; 7
    7566:	16 96       	adiw	r26, 0x06	; 6
    7568:	4d 91       	ld	r20, X+
    756a:	5d 91       	ld	r21, X+
    756c:	6d 91       	ld	r22, X+
    756e:	7c 91       	ld	r23, X
    7570:	19 97       	sbiw	r26, 0x09	; 9
	message->YawRefSetpoint = model->ReferenceMagYawRads();
    7572:	a9 ad       	ldd	r26, Y+57	; 0x39
    7574:	ba ad       	ldd	r27, Y+58	; 0x3a
    7576:	4d 93       	st	X+, r20
    7578:	5d 93       	st	X+, r21
    757a:	6d 93       	st	X+, r22
    757c:	7c 93       	st	X, r23
    757e:	13 97       	sbiw	r26, 0x03	; 3

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    7580:	27 96       	adiw	r28, 0x07	; 7
    7582:	ae ad       	ldd	r26, Y+62	; 0x3e
    7584:	bf ad       	ldd	r27, Y+63	; 0x3f
    7586:	27 97       	sbiw	r28, 0x07	; 7
    7588:	ae 55       	subi	r26, 0x5E	; 94
    758a:	bf 4f       	sbci	r27, 0xFF	; 255
    758c:	4d 91       	ld	r20, X+
    758e:	5d 91       	ld	r21, X+
    7590:	6d 91       	ld	r22, X+
    7592:	7c 91       	ld	r23, X
	
	
	message->LatitudeDegrees = model->LatitudeDegrees();
    7594:	ab 89       	ldd	r26, Y+19	; 0x13
    7596:	bc 89       	ldd	r27, Y+20	; 0x14
    7598:	4d 93       	st	X+, r20
    759a:	5d 93       	st	X+, r21
    759c:	6d 93       	st	X+, r22
    759e:	7c 93       	st	X, r23
    75a0:	13 97       	sbiw	r26, 0x03	; 3
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    75a2:	27 96       	adiw	r28, 0x07	; 7
    75a4:	ae ad       	ldd	r26, Y+62	; 0x3e
    75a6:	bf ad       	ldd	r27, Y+63	; 0x3f
    75a8:	27 97       	sbiw	r28, 0x07	; 7
    75aa:	aa 55       	subi	r26, 0x5A	; 90
    75ac:	bf 4f       	sbci	r27, 0xFF	; 255
    75ae:	4d 91       	ld	r20, X+
    75b0:	5d 91       	ld	r21, X+
    75b2:	6d 91       	ld	r22, X+
    75b4:	7c 91       	ld	r23, X
	message->LongitudeDegrees = model->LongitudeDegrees();
    75b6:	ad 89       	ldd	r26, Y+21	; 0x15
    75b8:	be 89       	ldd	r27, Y+22	; 0x16
    75ba:	4d 93       	st	X+, r20
    75bc:	5d 93       	st	X+, r21
    75be:	6d 93       	st	X+, r22
    75c0:	7c 93       	st	X, r23
    75c2:	13 97       	sbiw	r26, 0x03	; 3
	
	return message;
}
    75c4:	cf 01       	movw	r24, r30
    75c6:	c6 5b       	subi	r28, 0xB6	; 182
    75c8:	df 4f       	sbci	r29, 0xFF	; 255
    75ca:	0f b6       	in	r0, 0x3f	; 63
    75cc:	f8 94       	cli
    75ce:	de bf       	out	0x3e, r29	; 62
    75d0:	0f be       	out	0x3f, r0	; 63
    75d2:	cd bf       	out	0x3d, r28	; 61
    75d4:	df 91       	pop	r29
    75d6:	cf 91       	pop	r28
    75d8:	1f 91       	pop	r17
    75da:	0f 91       	pop	r16
    75dc:	ff 90       	pop	r15
    75de:	ef 90       	pop	r14
    75e0:	df 90       	pop	r13
    75e2:	cf 90       	pop	r12
    75e4:	bf 90       	pop	r11
    75e6:	af 90       	pop	r10
    75e8:	9f 90       	pop	r9
    75ea:	8f 90       	pop	r8
    75ec:	7f 90       	pop	r7
    75ee:	6f 90       	pop	r6
    75f0:	5f 90       	pop	r5
    75f2:	4f 90       	pop	r4
    75f4:	3f 90       	pop	r3
    75f6:	2f 90       	pop	r2
    75f8:	08 95       	ret

000075fa <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>:
	model->YVEcefCms(this->YVEcefCms);
	model->ZVEcefCms(this->ZVEcefCms);
}

void SystemTelemetryMessage::updateModelFromMessageFromSimulator (SystemModel *model)
{
    75fa:	fb 01       	movw	r30, r22
	//Convert from meters per sec, to foot per sec.
	
	
	
	//Copy fake gyroscope data
	model->PitchAngularVelocityRadsPerSecond(this->PitchAngularVelocityRadsPerSecond);
    75fc:	dc 01       	movw	r26, r24
    75fe:	a3 52       	subi	r26, 0x23	; 35
    7600:	bf 4f       	sbci	r27, 0xFF	; 255
    7602:	4d 91       	ld	r20, X+
    7604:	5d 91       	ld	r21, X+
    7606:	6d 91       	ld	r22, X+
    7608:	7c 91       	ld	r23, X
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    760a:	df 01       	movw	r26, r30
    760c:	a6 52       	subi	r26, 0x26	; 38
    760e:	bf 4f       	sbci	r27, 0xFF	; 255
    7610:	4d 93       	st	X+, r20
    7612:	5d 93       	st	X+, r21
    7614:	6d 93       	st	X+, r22
    7616:	7c 93       	st	X, r23
    7618:	13 97       	sbiw	r26, 0x03	; 3
	model->YawAngularVelocityRadsPerSecond(this->YawAngularVelocityRadsPerSecond);
    761a:	dc 01       	movw	r26, r24
    761c:	a7 52       	subi	r26, 0x27	; 39
    761e:	bf 4f       	sbci	r27, 0xFF	; 255
    7620:	4d 91       	ld	r20, X+
    7622:	5d 91       	ld	r21, X+
    7624:	6d 91       	ld	r22, X+
    7626:	7c 91       	ld	r23, X
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    7628:	df 01       	movw	r26, r30
    762a:	ae 51       	subi	r26, 0x1E	; 30
    762c:	bf 4f       	sbci	r27, 0xFF	; 255
    762e:	4d 93       	st	X+, r20
    7630:	5d 93       	st	X+, r21
    7632:	6d 93       	st	X+, r22
    7634:	7c 93       	st	X, r23
    7636:	13 97       	sbiw	r26, 0x03	; 3
	model->RollAngularVelocityRadsPerSecond(this->RollAngularVelocityRadsPerSecond);
    7638:	dc 01       	movw	r26, r24
    763a:	af 51       	subi	r26, 0x1F	; 31
    763c:	bf 4f       	sbci	r27, 0xFF	; 255
    763e:	4d 91       	ld	r20, X+
    7640:	5d 91       	ld	r21, X+
    7642:	6d 91       	ld	r22, X+
    7644:	7c 91       	ld	r23, X
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    7646:	df 01       	movw	r26, r30
    7648:	a2 52       	subi	r26, 0x22	; 34
    764a:	bf 4f       	sbci	r27, 0xFF	; 255
    764c:	4d 93       	st	X+, r20
    764e:	5d 93       	st	X+, r21
    7650:	6d 93       	st	X+, r22
    7652:	7c 93       	st	X, r23
    7654:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake GPS data
//	model->XVelocityMetersPerSecond(this->XVelocityMetersPerSecond); //this is supposed to be 'output' data, not input.
//	model->YVelocityMetersPerSecond(this->YVelocityMetersPerSecond);
	//ZVelocity is derived from pressure changes. //model->ZVelocityMetersPerSecond(this->ZVelocityMetersPerSecond); 
	model->LatitudeDegrees(this->LatitudeDegrees);
    7656:	dc 01       	movw	r26, r24
    7658:	ab 53       	subi	r26, 0x3B	; 59
    765a:	bf 4f       	sbci	r27, 0xFF	; 255
    765c:	4d 91       	ld	r20, X+
    765e:	5d 91       	ld	r21, X+
    7660:	6d 91       	ld	r22, X+
    7662:	7c 91       	ld	r23, X
			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						
    7664:	df 01       	movw	r26, r30
    7666:	ae 55       	subi	r26, 0x5E	; 94
    7668:	bf 4f       	sbci	r27, 0xFF	; 255
    766a:	4d 93       	st	X+, r20
    766c:	5d 93       	st	X+, r21
    766e:	6d 93       	st	X+, r22
    7670:	7c 93       	st	X, r23
    7672:	13 97       	sbiw	r26, 0x03	; 3
	model->LongitudeDegrees(this->LongitudeDegrees);
    7674:	dc 01       	movw	r26, r24
    7676:	a7 53       	subi	r26, 0x37	; 55
    7678:	bf 4f       	sbci	r27, 0xFF	; 255
    767a:	4d 91       	ld	r20, X+
    767c:	5d 91       	ld	r21, X+
    767e:	6d 91       	ld	r22, X+
    7680:	7c 91       	ld	r23, X

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
    7682:	df 01       	movw	r26, r30
    7684:	aa 55       	subi	r26, 0x5A	; 90
    7686:	bf 4f       	sbci	r27, 0xFF	; 255
    7688:	4d 93       	st	X+, r20
    768a:	5d 93       	st	X+, r21
    768c:	6d 93       	st	X+, r22
    768e:	7c 93       	st	X, r23
    7690:	13 97       	sbiw	r26, 0x03	; 3
	model->XEcefCm(this->XEcefCm);
    7692:	dc 01       	movw	r26, r24
    7694:	af 50       	subi	r26, 0x0F	; 15
    7696:	bf 4f       	sbci	r27, 0xFF	; 255
    7698:	4d 91       	ld	r20, X+
    769a:	5d 91       	ld	r21, X+
    769c:	6d 91       	ld	r22, X+
    769e:	7c 91       	ld	r23, X
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    76a0:	df 01       	movw	r26, r30
    76a2:	a2 50       	subi	r26, 0x02	; 2
    76a4:	bf 4f       	sbci	r27, 0xFF	; 255
    76a6:	4d 93       	st	X+, r20
    76a8:	5d 93       	st	X+, r21
    76aa:	6d 93       	st	X+, r22
    76ac:	7c 93       	st	X, r23
    76ae:	13 97       	sbiw	r26, 0x03	; 3
	model->YEcefCm(this->YEcefCm);
    76b0:	dc 01       	movw	r26, r24
    76b2:	ab 50       	subi	r26, 0x0B	; 11
    76b4:	bf 4f       	sbci	r27, 0xFF	; 255
    76b6:	4d 91       	ld	r20, X+
    76b8:	5d 91       	ld	r21, X+
    76ba:	6d 91       	ld	r22, X+
    76bc:	7c 91       	ld	r23, X
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    76be:	df 01       	movw	r26, r30
    76c0:	ae 5f       	subi	r26, 0xFE	; 254
    76c2:	be 4f       	sbci	r27, 0xFE	; 254
    76c4:	4d 93       	st	X+, r20
    76c6:	5d 93       	st	X+, r21
    76c8:	6d 93       	st	X+, r22
    76ca:	7c 93       	st	X, r23
    76cc:	13 97       	sbiw	r26, 0x03	; 3
	model->ZEcefCm(this->ZEcefCm);
    76ce:	dc 01       	movw	r26, r24
    76d0:	a7 50       	subi	r26, 0x07	; 7
    76d2:	bf 4f       	sbci	r27, 0xFF	; 255
    76d4:	4d 91       	ld	r20, X+
    76d6:	5d 91       	ld	r21, X+
    76d8:	6d 91       	ld	r22, X+
    76da:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    76dc:	df 01       	movw	r26, r30
    76de:	aa 5f       	subi	r26, 0xFA	; 250
    76e0:	be 4f       	sbci	r27, 0xFE	; 254
    76e2:	4d 93       	st	X+, r20
    76e4:	5d 93       	st	X+, r21
    76e6:	6d 93       	st	X+, r22
    76e8:	7c 93       	st	X, r23
    76ea:	13 97       	sbiw	r26, 0x03	; 3
		
	//Copy fake accelerometer data
	model->XAccelFrdMss(this->XAccelFrdMss);
    76ec:	dc 01       	movw	r26, r24
    76ee:	a3 53       	subi	r26, 0x33	; 51
    76f0:	bf 4f       	sbci	r27, 0xFF	; 255
    76f2:	4d 91       	ld	r20, X+
    76f4:	5d 91       	ld	r21, X+
    76f6:	6d 91       	ld	r22, X+
    76f8:	7c 91       	ld	r23, X
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    76fa:	df 01       	movw	r26, r30
    76fc:	aa 51       	subi	r26, 0x1A	; 26
    76fe:	bf 4f       	sbci	r27, 0xFF	; 255
    7700:	4d 93       	st	X+, r20
    7702:	5d 93       	st	X+, r21
    7704:	6d 93       	st	X+, r22
    7706:	7c 93       	st	X, r23
    7708:	13 97       	sbiw	r26, 0x03	; 3
	model->YAccelFrdMss(this->YAccelFrdMss);
    770a:	dc 01       	movw	r26, r24
    770c:	af 52       	subi	r26, 0x2F	; 47
    770e:	bf 4f       	sbci	r27, 0xFF	; 255
    7710:	4d 91       	ld	r20, X+
    7712:	5d 91       	ld	r21, X+
    7714:	6d 91       	ld	r22, X+
    7716:	7c 91       	ld	r23, X

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    7718:	df 01       	movw	r26, r30
    771a:	a6 51       	subi	r26, 0x16	; 22
    771c:	bf 4f       	sbci	r27, 0xFF	; 255
    771e:	4d 93       	st	X+, r20
    7720:	5d 93       	st	X+, r21
    7722:	6d 93       	st	X+, r22
    7724:	7c 93       	st	X, r23
    7726:	13 97       	sbiw	r26, 0x03	; 3
	model->ZAccelFrdMss(this->ZAccelFrdMss);
    7728:	dc 01       	movw	r26, r24
    772a:	ab 52       	subi	r26, 0x2B	; 43
    772c:	bf 4f       	sbci	r27, 0xFF	; 255
    772e:	4d 91       	ld	r20, X+
    7730:	5d 91       	ld	r21, X+
    7732:	6d 91       	ld	r22, X+
    7734:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    7736:	df 01       	movw	r26, r30
    7738:	a2 51       	subi	r26, 0x12	; 18
    773a:	bf 4f       	sbci	r27, 0xFF	; 255
    773c:	4d 93       	st	X+, r20
    773e:	5d 93       	st	X+, r21
    7740:	6d 93       	st	X+, r22
    7742:	7c 93       	st	X, r23
    7744:	13 97       	sbiw	r26, 0x03	; 3
	model->XVEcefCms(this->XVEcefCms);
    7746:	dc 01       	movw	r26, r24
    7748:	a3 50       	subi	r26, 0x03	; 3
    774a:	bf 4f       	sbci	r27, 0xFF	; 255
    774c:	4d 91       	ld	r20, X+
    774e:	5d 91       	ld	r21, X+
    7750:	6d 91       	ld	r22, X+
    7752:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    7754:	df 01       	movw	r26, r30
    7756:	a6 5f       	subi	r26, 0xF6	; 246
    7758:	be 4f       	sbci	r27, 0xFE	; 254
    775a:	4d 93       	st	X+, r20
    775c:	5d 93       	st	X+, r21
    775e:	6d 93       	st	X+, r22
    7760:	7c 93       	st	X, r23
    7762:	13 97       	sbiw	r26, 0x03	; 3
	model->YVEcefCms(this->YVEcefCms);
    7764:	dc 01       	movw	r26, r24
    7766:	af 5f       	subi	r26, 0xFF	; 255
    7768:	be 4f       	sbci	r27, 0xFE	; 254
    776a:	4d 91       	ld	r20, X+
    776c:	5d 91       	ld	r21, X+
    776e:	6d 91       	ld	r22, X+
    7770:	7c 91       	ld	r23, X
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    7772:	df 01       	movw	r26, r30
    7774:	a2 5f       	subi	r26, 0xF2	; 242
    7776:	be 4f       	sbci	r27, 0xFE	; 254
    7778:	4d 93       	st	X+, r20
    777a:	5d 93       	st	X+, r21
    777c:	6d 93       	st	X+, r22
    777e:	7c 93       	st	X, r23
    7780:	13 97       	sbiw	r26, 0x03	; 3
	model->ZVEcefCms(this->ZVEcefCms);
    7782:	dc 01       	movw	r26, r24
    7784:	ab 5f       	subi	r26, 0xFB	; 251
    7786:	be 4f       	sbci	r27, 0xFE	; 254
    7788:	4d 91       	ld	r20, X+
    778a:	5d 91       	ld	r21, X+
    778c:	6d 91       	ld	r22, X+
    778e:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    7790:	df 01       	movw	r26, r30
    7792:	ae 5e       	subi	r26, 0xEE	; 238
    7794:	be 4f       	sbci	r27, 0xFE	; 254
    7796:	4d 93       	st	X+, r20
    7798:	5d 93       	st	X+, r21
    779a:	6d 93       	st	X+, r22
    779c:	7c 93       	st	X, r23
    779e:	13 97       	sbiw	r26, 0x03	; 3

	//copy fake mag data
	model->XMagFrd(this->XMagFrd);
    77a0:	dc 01       	movw	r26, r24
    77a2:	ab 51       	subi	r26, 0x1B	; 27
    77a4:	bf 4f       	sbci	r27, 0xFF	; 255
    77a6:	4d 91       	ld	r20, X+
    77a8:	5d 91       	ld	r21, X+
    77aa:	6d 91       	ld	r22, X+
    77ac:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    77ae:	df 01       	movw	r26, r30
    77b0:	ae 50       	subi	r26, 0x0E	; 14
    77b2:	bf 4f       	sbci	r27, 0xFF	; 255
    77b4:	4d 93       	st	X+, r20
    77b6:	5d 93       	st	X+, r21
    77b8:	6d 93       	st	X+, r22
    77ba:	7c 93       	st	X, r23
    77bc:	13 97       	sbiw	r26, 0x03	; 3
	model->YMagFrd(this->YMagFrd);
    77be:	dc 01       	movw	r26, r24
    77c0:	a7 51       	subi	r26, 0x17	; 23
    77c2:	bf 4f       	sbci	r27, 0xFF	; 255
    77c4:	4d 91       	ld	r20, X+
    77c6:	5d 91       	ld	r21, X+
    77c8:	6d 91       	ld	r22, X+
    77ca:	7c 91       	ld	r23, X

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    77cc:	df 01       	movw	r26, r30
    77ce:	aa 50       	subi	r26, 0x0A	; 10
    77d0:	bf 4f       	sbci	r27, 0xFF	; 255
    77d2:	4d 93       	st	X+, r20
    77d4:	5d 93       	st	X+, r21
    77d6:	6d 93       	st	X+, r22
    77d8:	7c 93       	st	X, r23
    77da:	13 97       	sbiw	r26, 0x03	; 3
	model->ZMagFrd(this->ZMagFrd);
    77dc:	dc 01       	movw	r26, r24
    77de:	a3 51       	subi	r26, 0x13	; 19
    77e0:	bf 4f       	sbci	r27, 0xFF	; 255
    77e2:	4d 91       	ld	r20, X+
    77e4:	5d 91       	ld	r21, X+
    77e6:	6d 91       	ld	r22, X+
    77e8:	7c 91       	ld	r23, X

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    77ea:	df 01       	movw	r26, r30
    77ec:	a6 50       	subi	r26, 0x06	; 6
    77ee:	bf 4f       	sbci	r27, 0xFF	; 255
    77f0:	4d 93       	st	X+, r20
    77f2:	5d 93       	st	X+, r21
    77f4:	6d 93       	st	X+, r22
    77f6:	7c 93       	st	X, r23
    77f8:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake barometer data.
	model->PressureMillibars(this->PressureMillibars);	
    77fa:	dc 01       	movw	r26, r24
    77fc:	a7 5f       	subi	r26, 0xF7	; 247
    77fe:	be 4f       	sbci	r27, 0xFE	; 254
    7800:	4d 91       	ld	r20, X+
    7802:	5d 91       	ld	r21, X+
    7804:	6d 91       	ld	r22, X+
    7806:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    7808:	df 01       	movw	r26, r30
    780a:	aa 5e       	subi	r26, 0xEA	; 234
    780c:	be 4f       	sbci	r27, 0xFE	; 254
    780e:	4d 93       	st	X+, r20
    7810:	5d 93       	st	X+, r21
    7812:	6d 93       	st	X+, r22
    7814:	7c 93       	st	X, r23
    7816:	13 97       	sbiw	r26, 0x03	; 3


	model->ReferenceXNEDLocalFrameCm(this->XRefSetpoint);
    7818:	dc 01       	movw	r26, r24
    781a:	a3 5f       	subi	r26, 0xF3	; 243
    781c:	be 4f       	sbci	r27, 0xFE	; 254
    781e:	4d 91       	ld	r20, X+
    7820:	5d 91       	ld	r21, X+
    7822:	6d 91       	ld	r22, X+
    7824:	7c 91       	ld	r23, X
    7826:	13 97       	sbiw	r26, 0x03	; 3
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    7828:	46 a3       	std	Z+38, r20	; 0x26
    782a:	57 a3       	std	Z+39, r21	; 0x27
    782c:	60 a7       	std	Z+40, r22	; 0x28
    782e:	71 a7       	std	Z+41, r23	; 0x29
	model->ReferenceYNEDLocalFrameCm(this->YRefSetpoint);
    7830:	14 96       	adiw	r26, 0x04	; 4
    7832:	4d 91       	ld	r20, X+
    7834:	5d 91       	ld	r21, X+
    7836:	6d 91       	ld	r22, X+
    7838:	7c 91       	ld	r23, X

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    783a:	df 01       	movw	r26, r30
    783c:	ae 5a       	subi	r26, 0xAE	; 174
    783e:	bf 4f       	sbci	r27, 0xFF	; 255
    7840:	4d 93       	st	X+, r20
    7842:	5d 93       	st	X+, r21
    7844:	6d 93       	st	X+, r22
    7846:	7c 93       	st	X, r23
    7848:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceZNEDLocalFrameCm(this->ZRefSetpoint);
    784a:	dc 01       	movw	r26, r24
    784c:	ab 5e       	subi	r26, 0xEB	; 235
    784e:	be 4f       	sbci	r27, 0xFE	; 254
    7850:	4d 91       	ld	r20, X+
    7852:	5d 91       	ld	r21, X+
    7854:	6d 91       	ld	r22, X+
    7856:	7c 91       	ld	r23, X
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    7858:	df 01       	movw	r26, r30
    785a:	ae 57       	subi	r26, 0x7E	; 126
    785c:	bf 4f       	sbci	r27, 0xFF	; 255
    785e:	4d 93       	st	X+, r20
    7860:	5d 93       	st	X+, r21
    7862:	6d 93       	st	X+, r22
    7864:	7c 93       	st	X, r23
    7866:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceMagYawRads(this->YawRefSetpoint);
    7868:	dc 01       	movw	r26, r24
    786a:	a7 5e       	subi	r26, 0xE7	; 231
    786c:	be 4f       	sbci	r27, 0xFE	; 254
    786e:	8d 91       	ld	r24, X+
    7870:	9d 91       	ld	r25, X+
    7872:	0d 90       	ld	r0, X+
    7874:	bc 91       	ld	r27, X
    7876:	a0 2d       	mov	r26, r0
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    7878:	86 83       	std	Z+6, r24	; 0x06
    787a:	97 83       	std	Z+7, r25	; 0x07
    787c:	a0 87       	std	Z+8, r26	; 0x08
    787e:	b1 87       	std	Z+9, r27	; 0x09
    7880:	08 95       	ret

00007882 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>:
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;//.08f;//.05f;//.15;//.14f;//.08;//.08;*/
float AHRS::ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .001f;
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;

void AHRS::scaleAndAdjust(float vectorToAdjust[3], float vectorToScale[3], float scalerValue, float (&outputVector)[3])
{
    7882:	8f 92       	push	r8
    7884:	9f 92       	push	r9
    7886:	af 92       	push	r10
    7888:	bf 92       	push	r11
    788a:	cf 92       	push	r12
    788c:	df 92       	push	r13
    788e:	ef 92       	push	r14
    7890:	ff 92       	push	r15
    7892:	0f 93       	push	r16
    7894:	1f 93       	push	r17
    7896:	cf 93       	push	r28
    7898:	df 93       	push	r29
    789a:	eb 01       	movw	r28, r22
    789c:	6a 01       	movw	r12, r20
    789e:	48 01       	movw	r8, r16
    78a0:	59 01       	movw	r10, r18
	outputVector[0] = vectorToAdjust[0] - scalerValue * vectorToScale[0];
    78a2:	fa 01       	movw	r30, r20
    78a4:	20 81       	ld	r18, Z
    78a6:	31 81       	ldd	r19, Z+1	; 0x01
    78a8:	42 81       	ldd	r20, Z+2	; 0x02
    78aa:	53 81       	ldd	r21, Z+3	; 0x03
    78ac:	c5 01       	movw	r24, r10
    78ae:	b4 01       	movw	r22, r8
    78b0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    78b4:	9b 01       	movw	r18, r22
    78b6:	ac 01       	movw	r20, r24
    78b8:	68 81       	ld	r22, Y
    78ba:	79 81       	ldd	r23, Y+1	; 0x01
    78bc:	8a 81       	ldd	r24, Y+2	; 0x02
    78be:	9b 81       	ldd	r25, Y+3	; 0x03
    78c0:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    78c4:	f7 01       	movw	r30, r14
    78c6:	60 83       	st	Z, r22
    78c8:	71 83       	std	Z+1, r23	; 0x01
    78ca:	82 83       	std	Z+2, r24	; 0x02
    78cc:	93 83       	std	Z+3, r25	; 0x03
	outputVector[1] = vectorToAdjust[1] - scalerValue * vectorToScale[1];
    78ce:	f6 01       	movw	r30, r12
    78d0:	24 81       	ldd	r18, Z+4	; 0x04
    78d2:	35 81       	ldd	r19, Z+5	; 0x05
    78d4:	46 81       	ldd	r20, Z+6	; 0x06
    78d6:	57 81       	ldd	r21, Z+7	; 0x07
    78d8:	c5 01       	movw	r24, r10
    78da:	b4 01       	movw	r22, r8
    78dc:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    78e0:	9b 01       	movw	r18, r22
    78e2:	ac 01       	movw	r20, r24
    78e4:	6c 81       	ldd	r22, Y+4	; 0x04
    78e6:	7d 81       	ldd	r23, Y+5	; 0x05
    78e8:	8e 81       	ldd	r24, Y+6	; 0x06
    78ea:	9f 81       	ldd	r25, Y+7	; 0x07
    78ec:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    78f0:	f7 01       	movw	r30, r14
    78f2:	64 83       	std	Z+4, r22	; 0x04
    78f4:	75 83       	std	Z+5, r23	; 0x05
    78f6:	86 83       	std	Z+6, r24	; 0x06
    78f8:	97 83       	std	Z+7, r25	; 0x07
	outputVector[2] = vectorToAdjust[2] - scalerValue * vectorToScale[2];	
    78fa:	f6 01       	movw	r30, r12
    78fc:	20 85       	ldd	r18, Z+8	; 0x08
    78fe:	31 85       	ldd	r19, Z+9	; 0x09
    7900:	42 85       	ldd	r20, Z+10	; 0x0a
    7902:	53 85       	ldd	r21, Z+11	; 0x0b
    7904:	c5 01       	movw	r24, r10
    7906:	b4 01       	movw	r22, r8
    7908:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    790c:	9b 01       	movw	r18, r22
    790e:	ac 01       	movw	r20, r24
    7910:	68 85       	ldd	r22, Y+8	; 0x08
    7912:	79 85       	ldd	r23, Y+9	; 0x09
    7914:	8a 85       	ldd	r24, Y+10	; 0x0a
    7916:	9b 85       	ldd	r25, Y+11	; 0x0b
    7918:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    791c:	f7 01       	movw	r30, r14
    791e:	60 87       	std	Z+8, r22	; 0x08
    7920:	71 87       	std	Z+9, r23	; 0x09
    7922:	82 87       	std	Z+10, r24	; 0x0a
    7924:	93 87       	std	Z+11, r25	; 0x0b
}
    7926:	df 91       	pop	r29
    7928:	cf 91       	pop	r28
    792a:	1f 91       	pop	r17
    792c:	0f 91       	pop	r16
    792e:	ff 90       	pop	r15
    7930:	ef 90       	pop	r14
    7932:	df 90       	pop	r13
    7934:	cf 90       	pop	r12
    7936:	bf 90       	pop	r11
    7938:	af 90       	pop	r10
    793a:	9f 90       	pop	r9
    793c:	8f 90       	pop	r8
    793e:	08 95       	ret

00007940 <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>:


void AHRS::orthonormalizeDcm() 
{
    7940:	4f 92       	push	r4
    7942:	5f 92       	push	r5
    7944:	6f 92       	push	r6
    7946:	7f 92       	push	r7
    7948:	af 92       	push	r10
    794a:	bf 92       	push	r11
    794c:	cf 92       	push	r12
    794e:	df 92       	push	r13
    7950:	ef 92       	push	r14
    7952:	ff 92       	push	r15
    7954:	0f 93       	push	r16
    7956:	1f 93       	push	r17
    7958:	cf 93       	push	r28
    795a:	df 93       	push	r29
    795c:	5c 01       	movw	r10, r24
	/**
	 * The dot product of two orthonormal vectors should be 0 (because cos(90) = 0). So this
	 * gives us an error of how far from orthonormal the vectors are. It's a measure
	 * of how much X and Y are rotated towards each other. 
	 */
	float error = MatrixUtil::DotProduct(dcm[0], dcm[1]);
    795e:	ec 01       	movw	r28, r24
    7960:	c4 5b       	subi	r28, 0xB4	; 180
    7962:	df 4f       	sbci	r29, 0xFF	; 255
    7964:	6c 01       	movw	r12, r24
    7966:	80 e4       	ldi	r24, 0x40	; 64
    7968:	c8 0e       	add	r12, r24
    796a:	d1 1c       	adc	r13, r1
    796c:	be 01       	movw	r22, r28
    796e:	c6 01       	movw	r24, r12
    7970:	0e 94 ef 65 	call	0xcbde	; 0xcbde <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>
	
	/**
	 * Scale and adjust the two vectors involved in calculating the error to bring them 
	 * 'closer' to each other (more orthonormal)
	 */
	scaleAndAdjust(dcm[0], dcm[1], (error/2), dcm[0]);
    7974:	20 e0       	ldi	r18, 0x00	; 0
    7976:	30 e0       	ldi	r19, 0x00	; 0
    7978:	40 e0       	ldi	r20, 0x00	; 0
    797a:	5f e3       	ldi	r21, 0x3F	; 63
    797c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    7980:	2b 01       	movw	r4, r22
    7982:	3c 01       	movw	r6, r24
    7984:	76 01       	movw	r14, r12
    7986:	8b 01       	movw	r16, r22
    7988:	9c 01       	movw	r18, r24
    798a:	ae 01       	movw	r20, r28
    798c:	b6 01       	movw	r22, r12
    798e:	c5 01       	movw	r24, r10
    7990:	0e 94 41 3c 	call	0x7882	; 0x7882 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	scaleAndAdjust(dcm[1], dcm[0], (error/2), dcm[1]);
    7994:	7e 01       	movw	r14, r28
    7996:	93 01       	movw	r18, r6
    7998:	82 01       	movw	r16, r4
    799a:	a6 01       	movw	r20, r12
    799c:	be 01       	movw	r22, r28
    799e:	c5 01       	movw	r24, r10
    79a0:	0e 94 41 3c 	call	0x7882	; 0x7882 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	
	//The remaining vector will become the cross product of the other two vectors
	MatrixUtil::CrossProduct(dcm[0], dcm[1], dcm[2]);
    79a4:	88 e5       	ldi	r24, 0x58	; 88
    79a6:	a8 0e       	add	r10, r24
    79a8:	b1 1c       	adc	r11, r1
    79aa:	a5 01       	movw	r20, r10
    79ac:	be 01       	movw	r22, r28
    79ae:	c6 01       	movw	r24, r12
    79b0:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	
	//Normalize the matrix to ensure that the vector's magnitudes = 1
	MatrixUtil::Normalize(dcm[0]);
    79b4:	c6 01       	movw	r24, r12
    79b6:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[1]);
    79ba:	ce 01       	movw	r24, r28
    79bc:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[2]);
    79c0:	c5 01       	movw	r24, r10
    79c2:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
}
    79c6:	df 91       	pop	r29
    79c8:	cf 91       	pop	r28
    79ca:	1f 91       	pop	r17
    79cc:	0f 91       	pop	r16
    79ce:	ff 90       	pop	r15
    79d0:	ef 90       	pop	r14
    79d2:	df 90       	pop	r13
    79d4:	cf 90       	pop	r12
    79d6:	bf 90       	pop	r11
    79d8:	af 90       	pop	r10
    79da:	7f 90       	pop	r7
    79dc:	6f 90       	pop	r6
    79de:	5f 90       	pop	r5
    79e0:	4f 90       	pop	r4
    79e2:	08 95       	ret

000079e4 <_ZN10helicopter10navigation4AHRS6updateEfffffffff>:


void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
	float frdGyroXRs, float frdGyroYRs, float frdGyroZRs,
	float frdMagX, float frdMagY, float frdMagZ)
{
    79e4:	2f 92       	push	r2
    79e6:	3f 92       	push	r3
    79e8:	4f 92       	push	r4
    79ea:	5f 92       	push	r5
    79ec:	6f 92       	push	r6
    79ee:	7f 92       	push	r7
    79f0:	8f 92       	push	r8
    79f2:	9f 92       	push	r9
    79f4:	af 92       	push	r10
    79f6:	bf 92       	push	r11
    79f8:	cf 92       	push	r12
    79fa:	df 92       	push	r13
    79fc:	ef 92       	push	r14
    79fe:	ff 92       	push	r15
    7a00:	0f 93       	push	r16
    7a02:	1f 93       	push	r17
    7a04:	cf 93       	push	r28
    7a06:	df 93       	push	r29
    7a08:	cd b7       	in	r28, 0x3d	; 61
    7a0a:	de b7       	in	r29, 0x3e	; 62
    7a0c:	cc 57       	subi	r28, 0x7C	; 124
    7a0e:	d1 09       	sbc	r29, r1
    7a10:	0f b6       	in	r0, 0x3f	; 63
    7a12:	f8 94       	cli
    7a14:	de bf       	out	0x3e, r29	; 62
    7a16:	0f be       	out	0x3f, r0	; 63
    7a18:	cd bf       	out	0x3d, r28	; 61
    7a1a:	2c 01       	movw	r4, r24
    7a1c:	e1 96       	adiw	r28, 0x31	; 49
    7a1e:	8c ae       	std	Y+60, r8	; 0x3c
    7a20:	9d ae       	std	Y+61, r9	; 0x3d
    7a22:	ae ae       	std	Y+62, r10	; 0x3e
    7a24:	bf ae       	std	Y+63, r11	; 0x3f
    7a26:	e1 97       	sbiw	r28, 0x31	; 49
	float accelerometerVector[3] = {frdAccXMss, frdAccYMss, frdAccZMss};
    7a28:	a5 96       	adiw	r28, 0x25	; 37
    7a2a:	4c af       	std	Y+60, r20	; 0x3c
    7a2c:	5d af       	std	Y+61, r21	; 0x3d
    7a2e:	6e af       	std	Y+62, r22	; 0x3e
    7a30:	7f af       	std	Y+63, r23	; 0x3f
    7a32:	a5 97       	sbiw	r28, 0x25	; 37
    7a34:	a9 96       	adiw	r28, 0x29	; 41
    7a36:	0c af       	std	Y+60, r16	; 0x3c
    7a38:	1d af       	std	Y+61, r17	; 0x3d
    7a3a:	2e af       	std	Y+62, r18	; 0x3e
    7a3c:	3f af       	std	Y+63, r19	; 0x3f
    7a3e:	a9 97       	sbiw	r28, 0x29	; 41
    7a40:	ad 96       	adiw	r28, 0x2d	; 45
    7a42:	cc ae       	std	Y+60, r12	; 0x3c
    7a44:	dd ae       	std	Y+61, r13	; 0x3d
    7a46:	ee ae       	std	Y+62, r14	; 0x3e
    7a48:	ff ae       	std	Y+63, r15	; 0x3f
    7a4a:	ad 97       	sbiw	r28, 0x2d	; 45
	float magnetometerVector[3] = {frdMagX, frdMagY, frdMagZ};
    7a4c:	c6 56       	subi	r28, 0x66	; 102
    7a4e:	df 4f       	sbci	r29, 0xFF	; 255
    7a50:	88 81       	ld	r24, Y
    7a52:	99 81       	ldd	r25, Y+1	; 0x01
    7a54:	aa 81       	ldd	r26, Y+2	; 0x02
    7a56:	bb 81       	ldd	r27, Y+3	; 0x03
    7a58:	ca 59       	subi	r28, 0x9A	; 154
    7a5a:	d0 40       	sbci	r29, 0x00	; 0
    7a5c:	69 96       	adiw	r28, 0x19	; 25
    7a5e:	8c af       	std	Y+60, r24	; 0x3c
    7a60:	9d af       	std	Y+61, r25	; 0x3d
    7a62:	ae af       	std	Y+62, r26	; 0x3e
    7a64:	bf af       	std	Y+63, r27	; 0x3f
    7a66:	69 97       	sbiw	r28, 0x19	; 25
    7a68:	c2 56       	subi	r28, 0x62	; 98
    7a6a:	df 4f       	sbci	r29, 0xFF	; 255
    7a6c:	88 81       	ld	r24, Y
    7a6e:	99 81       	ldd	r25, Y+1	; 0x01
    7a70:	aa 81       	ldd	r26, Y+2	; 0x02
    7a72:	bb 81       	ldd	r27, Y+3	; 0x03
    7a74:	ce 59       	subi	r28, 0x9E	; 158
    7a76:	d0 40       	sbci	r29, 0x00	; 0
    7a78:	6d 96       	adiw	r28, 0x1d	; 29
    7a7a:	8c af       	std	Y+60, r24	; 0x3c
    7a7c:	9d af       	std	Y+61, r25	; 0x3d
    7a7e:	ae af       	std	Y+62, r26	; 0x3e
    7a80:	bf af       	std	Y+63, r27	; 0x3f
    7a82:	6d 97       	sbiw	r28, 0x1d	; 29
    7a84:	ce 55       	subi	r28, 0x5E	; 94
    7a86:	df 4f       	sbci	r29, 0xFF	; 255
    7a88:	88 81       	ld	r24, Y
    7a8a:	99 81       	ldd	r25, Y+1	; 0x01
    7a8c:	aa 81       	ldd	r26, Y+2	; 0x02
    7a8e:	bb 81       	ldd	r27, Y+3	; 0x03
    7a90:	c2 5a       	subi	r28, 0xA2	; 162
    7a92:	d0 40       	sbci	r29, 0x00	; 0
    7a94:	a1 96       	adiw	r28, 0x21	; 33
    7a96:	8c af       	std	Y+60, r24	; 0x3c
    7a98:	9d af       	std	Y+61, r25	; 0x3d
    7a9a:	ae af       	std	Y+62, r26	; 0x3e
    7a9c:	bf af       	std	Y+63, r27	; 0x3f
    7a9e:	a1 97       	sbiw	r28, 0x21	; 33
		
	float accelerometerAngularDisplacement[3] = {0};
    7aa0:	7e 01       	movw	r14, r28
    7aa2:	89 e4       	ldi	r24, 0x49	; 73
    7aa4:	e8 0e       	add	r14, r24
    7aa6:	f1 1c       	adc	r15, r1
    7aa8:	0f 2e       	mov	r0, r31
    7aaa:	fc e0       	ldi	r31, 0x0C	; 12
    7aac:	df 2e       	mov	r13, r31
    7aae:	f0 2d       	mov	r31, r0
    7ab0:	d7 01       	movw	r26, r14
    7ab2:	ed 2d       	mov	r30, r13
    7ab4:	1d 92       	st	X+, r1
    7ab6:	ea 95       	dec	r30
    7ab8:	e9 f7       	brne	.-6      	; 0x7ab4 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xd0>
	float magnetometerAngularDisplacement[3] = {0};
    7aba:	5e 01       	movw	r10, r28
    7abc:	fd e3       	ldi	r31, 0x3D	; 61
    7abe:	af 0e       	add	r10, r31
    7ac0:	b1 1c       	adc	r11, r1
    7ac2:	d5 01       	movw	r26, r10
    7ac4:	ed 2d       	mov	r30, r13
    7ac6:	1d 92       	st	X+, r1
    7ac8:	ea 95       	dec	r30
    7aca:	e9 f7       	brne	.-6      	; 0x7ac6 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xe2>
		
	//Scale the gyro value by the time interval to get the angle in rads.
	float gyroscopeAngularDisplacement[3] = { frdGyroXRs * gyroTimeInterval, 
    7acc:	d2 01       	movw	r26, r4
    7ace:	6d 90       	ld	r6, X+
    7ad0:	7d 90       	ld	r7, X+
    7ad2:	8d 90       	ld	r8, X+
    7ad4:	9c 90       	ld	r9, X
    7ad6:	e1 96       	adiw	r28, 0x31	; 49
    7ad8:	2c ad       	ldd	r18, Y+60	; 0x3c
    7ada:	3d ad       	ldd	r19, Y+61	; 0x3d
    7adc:	4e ad       	ldd	r20, Y+62	; 0x3e
    7ade:	5f ad       	ldd	r21, Y+63	; 0x3f
    7ae0:	e1 97       	sbiw	r28, 0x31	; 49
    7ae2:	c4 01       	movw	r24, r8
    7ae4:	b3 01       	movw	r22, r6
    7ae6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
												frdGyroYRs * gyroTimeInterval, 
												frdGyroZRs * gyroTimeInterval};	
    7aea:	69 ab       	std	Y+49, r22	; 0x31
    7aec:	7a ab       	std	Y+50, r23	; 0x32
    7aee:	8b ab       	std	Y+51, r24	; 0x33
    7af0:	9c ab       	std	Y+52, r25	; 0x34
	float accelerometerAngularDisplacement[3] = {0};
	float magnetometerAngularDisplacement[3] = {0};
		
	//Scale the gyro value by the time interval to get the angle in rads.
	float gyroscopeAngularDisplacement[3] = { frdGyroXRs * gyroTimeInterval, 
												frdGyroYRs * gyroTimeInterval, 
    7af2:	ce 56       	subi	r28, 0x6E	; 110
    7af4:	df 4f       	sbci	r29, 0xFF	; 255
    7af6:	28 81       	ld	r18, Y
    7af8:	39 81       	ldd	r19, Y+1	; 0x01
    7afa:	4a 81       	ldd	r20, Y+2	; 0x02
    7afc:	5b 81       	ldd	r21, Y+3	; 0x03
    7afe:	c2 59       	subi	r28, 0x92	; 146
    7b00:	d0 40       	sbci	r29, 0x00	; 0
    7b02:	c4 01       	movw	r24, r8
    7b04:	b3 01       	movw	r22, r6
    7b06:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
												frdGyroZRs * gyroTimeInterval};	
    7b0a:	6d ab       	std	Y+53, r22	; 0x35
    7b0c:	7e ab       	std	Y+54, r23	; 0x36
    7b0e:	8f ab       	std	Y+55, r24	; 0x37
    7b10:	98 af       	std	Y+56, r25	; 0x38
    7b12:	ca 56       	subi	r28, 0x6A	; 106
    7b14:	df 4f       	sbci	r29, 0xFF	; 255
    7b16:	28 81       	ld	r18, Y
    7b18:	39 81       	ldd	r19, Y+1	; 0x01
    7b1a:	4a 81       	ldd	r20, Y+2	; 0x02
    7b1c:	5b 81       	ldd	r21, Y+3	; 0x03
    7b1e:	c6 59       	subi	r28, 0x96	; 150
    7b20:	d0 40       	sbci	r29, 0x00	; 0
    7b22:	c4 01       	movw	r24, r8
    7b24:	b3 01       	movw	r22, r6
    7b26:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    7b2a:	69 af       	std	Y+57, r22	; 0x39
    7b2c:	7a af       	std	Y+58, r23	; 0x3a
    7b2e:	8b af       	std	Y+59, r24	; 0x3b
    7b30:	9c af       	std	Y+60, r25	; 0x3c
												
	float angularDisplacementWeightedAverage [3] = {0};	
    7b32:	3e 01       	movw	r6, r28
    7b34:	b5 e2       	ldi	r27, 0x25	; 37
    7b36:	6b 0e       	add	r6, r27
    7b38:	71 1c       	adc	r7, r1
    7b3a:	f3 01       	movw	r30, r6
    7b3c:	8d 2d       	mov	r24, r13
    7b3e:	11 92       	st	Z+, r1
    7b40:	8a 95       	dec	r24
    7b42:	e9 f7       	brne	.-6      	; 0x7b3e <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x15a>
		
	float changeInVector [3] = {0};
    7b44:	fe 01       	movw	r30, r28
    7b46:	79 96       	adiw	r30, 0x19	; 25
    7b48:	df 01       	movw	r26, r30
    7b4a:	8d 2d       	mov	r24, r13
    7b4c:	1d 92       	st	X+, r1
    7b4e:	8a 95       	dec	r24
    7b50:	e9 f7       	brne	.-6      	; 0x7b4c <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x168>
		 
	//Normalize the accelerometer and magnetometer data so that their magnitudes = 1. The DCM matrix
	//is based on unit vectors (vectors with a magnitude of one)
	MatrixUtil::Normalize(accelerometerVector);
    7b52:	ce 01       	movw	r24, r28
    7b54:	8f 59       	subi	r24, 0x9F	; 159
    7b56:	9f 4f       	sbci	r25, 0xFF	; 255
    7b58:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(magnetometerVector);
    7b5c:	ce 01       	movw	r24, r28
    7b5e:	8b 5a       	subi	r24, 0xAB	; 171
    7b60:	9f 4f       	sbci	r25, 0xFF	; 255
    7b62:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	 * west vector, and the accelerometer vector to get a 'north facing' vector which is the corrected
	 * magnetometer vector.
	 *
	 * Taken from Starlino's January 20, 2012 post at http://www.starlino.com/dcm_tutorial.html 
	 */
	float westFacingVector[3] = {0};//since the acceleration vector is pointing down, this is actually an east facing vector in our case. it's actually facing out the right side of the ship. 
    7b66:	4e 01       	movw	r8, r28
    7b68:	9d e0       	ldi	r25, 0x0D	; 13
    7b6a:	89 0e       	add	r8, r25
    7b6c:	91 1c       	adc	r9, r1
    7b6e:	d4 01       	movw	r26, r8
    7b70:	ed 2d       	mov	r30, r13
    7b72:	1d 92       	st	X+, r1
    7b74:	ea 95       	dec	r30
    7b76:	e9 f7       	brne	.-6      	; 0x7b72 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x18e>
	float correctedMagnetometerVector[3] = {0};
    7b78:	8e 01       	movw	r16, r28
    7b7a:	0f 5f       	subi	r16, 0xFF	; 255
    7b7c:	1f 4f       	sbci	r17, 0xFF	; 255
    7b7e:	d8 01       	movw	r26, r16
    7b80:	1d 92       	st	X+, r1
    7b82:	da 94       	dec	r13
    7b84:	e9 f7       	brne	.-6      	; 0x7b80 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x19c>
	* I also ran into the issue where the accel was vibrating so heavily that the y and z values were maxed out
	* this caused a gravity vector that pointed 45* down and west, this caused the heading value to
	* slowly start rotating. But if I had used the mag and accel values, it would have immediately given
	* erroneous results and would have started to rotate immediately.
	*/
	MatrixUtil::CrossProduct(dcm[2], magnetometerVector, westFacingVector);	
    7b86:	62 01       	movw	r12, r4
    7b88:	b8 e5       	ldi	r27, 0x58	; 88
    7b8a:	cb 0e       	add	r12, r27
    7b8c:	d1 1c       	adc	r13, r1
    7b8e:	a4 01       	movw	r20, r8
    7b90:	be 01       	movw	r22, r28
    7b92:	6b 5a       	subi	r22, 0xAB	; 171
    7b94:	7f 4f       	sbci	r23, 0xFF	; 255
    7b96:	c6 01       	movw	r24, r12
    7b98:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(westFacingVector, dcm[2], correctedMagnetometerVector);
    7b9c:	a8 01       	movw	r20, r16
    7b9e:	b6 01       	movw	r22, r12
    7ba0:	c4 01       	movw	r24, r8
    7ba2:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	//Doing it this way prevents a 'gyro' effect where if you pitch up, it causes the gyro to affect the yaw, and then it 'stabilizes' back to normal value
	//This way prevents that. if you took the DCM value and cross proded that with the mag value, you would get the gyro affect. 
	/*MatrixUtil::CrossProduct(accelerometerVector, magnetometerVector, westFacingVector);
	MatrixUtil::CrossProduct(westFacingVector, accelerometerVector, correctedMagnetometerVector);	*/
	
	MatrixUtil::Normalize(correctedMagnetometerVector);
    7ba6:	c8 01       	movw	r24, r16
    7ba8:	0e 94 ff 62 	call	0xc5fe	; 0xc5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	//This gives the angular displacement that the helicopter has moved since the last
	//iteration.
	//d?a = dt wa = KB0 x (KB1A - KB0) - see http://www.starlino.com/dcm_tutorial.html for proof		
	/*MatrixUtil::CrossProduct(accelerometerVector, dcm[2], accelerometerAngularDisplacement);
	MatrixUtil::CrossProduct(correctedMagnetometerVector, dcm[0], magnetometerAngularDisplacement);*/
	MatrixUtil::CrossProduct(dcm[2], accelerometerVector, accelerometerAngularDisplacement);
    7bac:	a7 01       	movw	r20, r14
    7bae:	be 01       	movw	r22, r28
    7bb0:	6f 59       	subi	r22, 0x9F	; 159
    7bb2:	7f 4f       	sbci	r23, 0xFF	; 255
    7bb4:	c6 01       	movw	r24, r12
    7bb6:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(dcm[0], correctedMagnetometerVector, magnetometerAngularDisplacement);
    7bba:	a5 01       	movw	r20, r10
    7bbc:	b8 01       	movw	r22, r16
    7bbe:	c2 01       	movw	r24, r4
    7bc0:	80 5c       	subi	r24, 0xC0	; 192
    7bc2:	9f 4f       	sbci	r25, 0xFF	; 255
    7bc4:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    7bc8:	80 91 0a 02 	lds	r24, 0x020A
    7bcc:	90 91 0b 02 	lds	r25, 0x020B
    7bd0:	a0 91 0c 02 	lds	r26, 0x020C
    7bd4:	b0 91 0d 02 	lds	r27, 0x020D
    7bd8:	e1 96       	adiw	r28, 0x31	; 49
    7bda:	8c af       	std	Y+60, r24	; 0x3c
    7bdc:	9d af       	std	Y+61, r25	; 0x3d
    7bde:	ae af       	std	Y+62, r26	; 0x3e
    7be0:	bf af       	std	Y+63, r27	; 0x3f
    7be2:	e1 97       	sbiw	r28, 0x31	; 49
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    7be4:	80 91 06 02 	lds	r24, 0x0206
    7be8:	90 91 07 02 	lds	r25, 0x0207
    7bec:	a0 91 08 02 	lds	r26, 0x0208
    7bf0:	b0 91 09 02 	lds	r27, 0x0209
    7bf4:	e5 96       	adiw	r28, 0x35	; 53
    7bf6:	8c af       	std	Y+60, r24	; 0x3c
    7bf8:	9d af       	std	Y+61, r25	; 0x3d
    7bfa:	ae af       	std	Y+62, r26	; 0x3e
    7bfc:	bf af       	std	Y+63, r27	; 0x3f
    7bfe:	e5 97       	sbiw	r28, 0x35	; 53
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    7c00:	20 e0       	ldi	r18, 0x00	; 0
    7c02:	30 e0       	ldi	r19, 0x00	; 0
    7c04:	40 e8       	ldi	r20, 0x80	; 128
    7c06:	5f e3       	ldi	r21, 0x3F	; 63
    7c08:	e1 96       	adiw	r28, 0x31	; 49
    7c0a:	6c ad       	ldd	r22, Y+60	; 0x3c
    7c0c:	7d ad       	ldd	r23, Y+61	; 0x3d
    7c0e:	8e ad       	ldd	r24, Y+62	; 0x3e
    7c10:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c12:	e1 97       	sbiw	r28, 0x31	; 49
    7c14:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7c18:	9b 01       	movw	r18, r22
    7c1a:	ac 01       	movw	r20, r24
    7c1c:	e5 96       	adiw	r28, 0x35	; 53
    7c1e:	6c ad       	ldd	r22, Y+60	; 0x3c
    7c20:	7d ad       	ldd	r23, Y+61	; 0x3d
    7c22:	8e ad       	ldd	r24, Y+62	; 0x3e
    7c24:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c26:	e5 97       	sbiw	r28, 0x35	; 53
    7c28:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7c2c:	e9 96       	adiw	r28, 0x39	; 57
    7c2e:	6c af       	std	Y+60, r22	; 0x3c
    7c30:	7d af       	std	Y+61, r23	; 0x3d
    7c32:	8e af       	std	Y+62, r24	; 0x3e
    7c34:	9f af       	std	Y+63, r25	; 0x3f
    7c36:	e9 97       	sbiw	r28, 0x39	; 57
    7c38:	87 01       	movw	r16, r14
    7c3a:	1e 01       	movw	r2, r28
    7c3c:	91 e3       	ldi	r25, 0x31	; 49
    7c3e:	29 0e       	add	r2, r25
    7c40:	31 1c       	adc	r3, r1
    7c42:	d7 01       	movw	r26, r14
    7c44:	1c 96       	adiw	r26, 0x0c	; 12
    7c46:	eb 96       	adiw	r28, 0x3b	; 59
    7c48:	bf af       	std	Y+63, r27	; 0x3f
    7c4a:	ae af       	std	Y+62, r26	; 0x3e
    7c4c:	eb 97       	sbiw	r28, 0x3b	; 59
    7c4e:	ed 96       	adiw	r28, 0x3d	; 61
    7c50:	5f ae       	std	Y+63, r5	; 0x3f
    7c52:	4e ae       	std	Y+62, r4	; 0x3e
    7c54:	ed 97       	sbiw	r28, 0x3d	; 61
    7c56:	25 01       	movw	r4, r10
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    7c58:	f8 01       	movw	r30, r16
    7c5a:	61 91       	ld	r22, Z+
    7c5c:	71 91       	ld	r23, Z+
    7c5e:	81 91       	ld	r24, Z+
    7c60:	91 91       	ld	r25, Z+
    7c62:	8f 01       	movw	r16, r30
		/**
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
    7c64:	d1 01       	movw	r26, r2
    7c66:	cd 90       	ld	r12, X+
    7c68:	dd 90       	ld	r13, X+
    7c6a:	ed 90       	ld	r14, X+
    7c6c:	fd 90       	ld	r15, X+
    7c6e:	1d 01       	movw	r2, r26
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    7c70:	f2 01       	movw	r30, r4
    7c72:	81 90       	ld	r8, Z+
    7c74:	91 90       	ld	r9, Z+
    7c76:	a1 90       	ld	r10, Z+
    7c78:	b1 90       	ld	r11, Z+
    7c7a:	2f 01       	movw	r4, r30
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    7c7c:	e1 96       	adiw	r28, 0x31	; 49
    7c7e:	2c ad       	ldd	r18, Y+60	; 0x3c
    7c80:	3d ad       	ldd	r19, Y+61	; 0x3d
    7c82:	4e ad       	ldd	r20, Y+62	; 0x3e
    7c84:	5f ad       	ldd	r21, Y+63	; 0x3f
    7c86:	e1 97       	sbiw	r28, 0x31	; 49
    7c88:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
		/**
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
    7c8c:	a7 01       	movw	r20, r14
    7c8e:	96 01       	movw	r18, r12
    7c90:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    7c94:	6b 01       	movw	r12, r22
    7c96:	7c 01       	movw	r14, r24
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    7c98:	e5 96       	adiw	r28, 0x35	; 53
    7c9a:	2c ad       	ldd	r18, Y+60	; 0x3c
    7c9c:	3d ad       	ldd	r19, Y+61	; 0x3d
    7c9e:	4e ad       	ldd	r20, Y+62	; 0x3e
    7ca0:	5f ad       	ldd	r21, Y+63	; 0x3f
    7ca2:	e5 97       	sbiw	r28, 0x35	; 53
    7ca4:	c5 01       	movw	r24, r10
    7ca6:	b4 01       	movw	r22, r8
    7ca8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    7cac:	9b 01       	movw	r18, r22
    7cae:	ac 01       	movw	r20, r24
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    7cb0:	c7 01       	movw	r24, r14
    7cb2:	b6 01       	movw	r22, r12
    7cb4:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    7cb8:	e9 96       	adiw	r28, 0x39	; 57
    7cba:	2c ad       	ldd	r18, Y+60	; 0x3c
    7cbc:	3d ad       	ldd	r19, Y+61	; 0x3d
    7cbe:	4e ad       	ldd	r20, Y+62	; 0x3e
    7cc0:	5f ad       	ldd	r21, Y+63	; 0x3f
    7cc2:	e9 97       	sbiw	r28, 0x39	; 57
    7cc4:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    7cc8:	d3 01       	movw	r26, r6
    7cca:	6d 93       	st	X+, r22
    7ccc:	7d 93       	st	X+, r23
    7cce:	8d 93       	st	X+, r24
    7cd0:	9d 93       	st	X+, r25
    7cd2:	3d 01       	movw	r6, r26
	debug2 = accelerometerVector[1];
	debug3 = accelerometerVector[2];
	*/
	//Calculate the weighted average of the angular displacements to obtain the correction vector
	//to adjust the DCM.
	for (int i = 0; i < 3; i++)
    7cd4:	eb 96       	adiw	r28, 0x3b	; 59
    7cd6:	ee ad       	ldd	r30, Y+62	; 0x3e
    7cd8:	ff ad       	ldd	r31, Y+63	; 0x3f
    7cda:	eb 97       	sbiw	r28, 0x3b	; 59
    7cdc:	0e 17       	cp	r16, r30
    7cde:	1f 07       	cpc	r17, r31
    7ce0:	09 f0       	breq	.+2      	; 0x7ce4 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x300>
    7ce2:	ba cf       	rjmp	.-140    	; 0x7c58 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x274>
    7ce4:	ed 96       	adiw	r28, 0x3d	; 61
    7ce6:	4e ac       	ldd	r4, Y+62	; 0x3e
    7ce8:	5f ac       	ldd	r5, Y+63	; 0x3f
    7cea:	ed 97       	sbiw	r28, 0x3d	; 61
    7cec:	82 01       	movw	r16, r4
    7cee:	00 5c       	subi	r16, 0xC0	; 192
    7cf0:	1f 4f       	sbci	r17, 0xFF	; 255
    7cf2:	e1 2c       	mov	r14, r1
    7cf4:	f1 2c       	mov	r15, r1
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
	{
		MatrixUtil::CrossProduct(angularDisplacementWeightedAverage, dcm[i], changeInVector);
    7cf6:	ae 01       	movw	r20, r28
    7cf8:	47 5e       	subi	r20, 0xE7	; 231
    7cfa:	5f 4f       	sbci	r21, 0xFF	; 255
    7cfc:	b8 01       	movw	r22, r16
    7cfe:	ce 01       	movw	r24, r28
    7d00:	85 96       	adiw	r24, 0x25	; 37
    7d02:	0e 94 7e 62 	call	0xc4fc	; 0xc4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		
		dcm[i][0] += changeInVector[0];
    7d06:	29 8d       	ldd	r18, Y+25	; 0x19
    7d08:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7d0a:	4b 8d       	ldd	r20, Y+27	; 0x1b
    7d0c:	5c 8d       	ldd	r21, Y+28	; 0x1c
    7d0e:	d8 01       	movw	r26, r16
    7d10:	6d 91       	ld	r22, X+
    7d12:	7d 91       	ld	r23, X+
    7d14:	8d 91       	ld	r24, X+
    7d16:	9c 91       	ld	r25, X
    7d18:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7d1c:	f8 01       	movw	r30, r16
    7d1e:	60 83       	st	Z, r22
    7d20:	71 83       	std	Z+1, r23	; 0x01
    7d22:	82 83       	std	Z+2, r24	; 0x02
    7d24:	93 83       	std	Z+3, r25	; 0x03
		dcm[i][1] += changeInVector[1];
    7d26:	2d 8d       	ldd	r18, Y+29	; 0x1d
    7d28:	3e 8d       	ldd	r19, Y+30	; 0x1e
    7d2a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    7d2c:	58 a1       	ldd	r21, Y+32	; 0x20
    7d2e:	64 81       	ldd	r22, Z+4	; 0x04
    7d30:	75 81       	ldd	r23, Z+5	; 0x05
    7d32:	86 81       	ldd	r24, Z+6	; 0x06
    7d34:	97 81       	ldd	r25, Z+7	; 0x07
    7d36:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7d3a:	d8 01       	movw	r26, r16
    7d3c:	14 96       	adiw	r26, 0x04	; 4
    7d3e:	6d 93       	st	X+, r22
    7d40:	7d 93       	st	X+, r23
    7d42:	8d 93       	st	X+, r24
    7d44:	9c 93       	st	X, r25
    7d46:	17 97       	sbiw	r26, 0x07	; 7
		dcm[i][2] += changeInVector[2];
    7d48:	29 a1       	ldd	r18, Y+33	; 0x21
    7d4a:	3a a1       	ldd	r19, Y+34	; 0x22
    7d4c:	4b a1       	ldd	r20, Y+35	; 0x23
    7d4e:	5c a1       	ldd	r21, Y+36	; 0x24
    7d50:	18 96       	adiw	r26, 0x08	; 8
    7d52:	6d 91       	ld	r22, X+
    7d54:	7d 91       	ld	r23, X+
    7d56:	8d 91       	ld	r24, X+
    7d58:	9c 91       	ld	r25, X
    7d5a:	1b 97       	sbiw	r26, 0x0b	; 11
    7d5c:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7d60:	f8 01       	movw	r30, r16
    7d62:	60 87       	std	Z+8, r22	; 0x08
    7d64:	71 87       	std	Z+9, r23	; 0x09
    7d66:	82 87       	std	Z+10, r24	; 0x0a
    7d68:	93 87       	std	Z+11, r25	; 0x0b
	/**
	 * Adjust the dcm matrix by the calculated angular displacement. We adjust the DCM matrix by the averaged
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
    7d6a:	ff ef       	ldi	r31, 0xFF	; 255
    7d6c:	ef 1a       	sub	r14, r31
    7d6e:	ff 0a       	sbc	r15, r31
    7d70:	04 5f       	subi	r16, 0xF4	; 244
    7d72:	1f 4f       	sbci	r17, 0xFF	; 255
    7d74:	83 e0       	ldi	r24, 0x03	; 3
    7d76:	e8 16       	cp	r14, r24
    7d78:	f1 04       	cpc	r15, r1
    7d7a:	09 f0       	breq	.+2      	; 0x7d7e <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x39a>
    7d7c:	bc cf       	rjmp	.-136    	; 0x7cf6 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x312>
	}
	
	
	
	//Adjust the matrix to make it closer to orthonormal.
	orthonormalizeDcm();
    7d7e:	c2 01       	movw	r24, r4
    7d80:	0e 94 a0 3c 	call	0x7940	; 0x7940 <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    7d84:	f2 01       	movw	r30, r4
    7d86:	e0 5c       	subi	r30, 0xC0	; 192
    7d88:	ff 4f       	sbci	r31, 0xFF	; 255
    7d8a:	20 81       	ld	r18, Z
    7d8c:	31 81       	ldd	r19, Z+1	; 0x01
    7d8e:	42 81       	ldd	r20, Z+2	; 0x02
    7d90:	53 81       	ldd	r21, Z+3	; 0x03
    7d92:	3c 96       	adiw	r30, 0x0c	; 12
    7d94:	60 81       	ld	r22, Z
    7d96:	71 81       	ldd	r23, Z+1	; 0x01
    7d98:	82 81       	ldd	r24, Z+2	; 0x02
    7d9a:	93 81       	ldd	r25, Z+3	; 0x03
    7d9c:	0e 94 45 67 	call	0xce8a	; 0xce8a <atan2>
    7da0:	6b 01       	movw	r12, r22
    7da2:	7c 01       	movw	r14, r24
	if (yawRads < 0)
    7da4:	20 e0       	ldi	r18, 0x00	; 0
    7da6:	30 e0       	ldi	r19, 0x00	; 0
    7da8:	a9 01       	movw	r20, r18
    7daa:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    7dae:	88 23       	and	r24, r24
    7db0:	44 f0       	brlt	.+16     	; 0x7dc2 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x3de>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    7db2:	d2 01       	movw	r26, r4
    7db4:	98 96       	adiw	r26, 0x28	; 40
    7db6:	cd 92       	st	X+, r12
    7db8:	dd 92       	st	X+, r13
    7dba:	ed 92       	st	X+, r14
    7dbc:	fc 92       	st	X, r15
    7dbe:	9b 97       	sbiw	r26, 0x2b	; 43
    7dc0:	0d c0       	rjmp	.+26     	; 0x7ddc <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x3f8>
	if (yawRads < 0)
	{
		yawRads = 2.0f * M_PI + yawRads;
    7dc2:	2b ed       	ldi	r18, 0xDB	; 219
    7dc4:	3f e0       	ldi	r19, 0x0F	; 15
    7dc6:	49 ec       	ldi	r20, 0xC9	; 201
    7dc8:	50 e4       	ldi	r21, 0x40	; 64
    7dca:	c7 01       	movw	r24, r14
    7dcc:	b6 01       	movw	r22, r12
    7dce:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    7dd2:	f2 01       	movw	r30, r4
    7dd4:	60 a7       	std	Z+40, r22	; 0x28
    7dd6:	71 a7       	std	Z+41, r23	; 0x29
    7dd8:	82 a7       	std	Z+42, r24	; 0x2a
    7dda:	93 a7       	std	Z+43, r25	; 0x2b
	}
	
	pitchRads = -asin(dcm[2][0]);
    7ddc:	f2 01       	movw	r30, r4
    7dde:	e8 5a       	subi	r30, 0xA8	; 168
    7de0:	ff 4f       	sbci	r31, 0xFF	; 255
    7de2:	60 81       	ld	r22, Z
    7de4:	71 81       	ldd	r23, Z+1	; 0x01
    7de6:	82 81       	ldd	r24, Z+2	; 0x02
    7de8:	93 81       	ldd	r25, Z+3	; 0x03
    7dea:	0e 94 1f 67 	call	0xce3e	; 0xce3e <asin>
    7dee:	dc 01       	movw	r26, r24
    7df0:	cb 01       	movw	r24, r22
    7df2:	b0 58       	subi	r27, 0x80	; 128
    7df4:	f2 01       	movw	r30, r4
    7df6:	84 a7       	std	Z+44, r24	; 0x2c
    7df8:	95 a7       	std	Z+45, r25	; 0x2d
    7dfa:	a6 a7       	std	Z+46, r26	; 0x2e
    7dfc:	b7 a7       	std	Z+47, r27	; 0x2f
	rollRads = atan2(dcm[2][1], dcm[2][2]);
    7dfe:	e0 5a       	subi	r30, 0xA0	; 160
    7e00:	ff 4f       	sbci	r31, 0xFF	; 255
    7e02:	20 81       	ld	r18, Z
    7e04:	31 81       	ldd	r19, Z+1	; 0x01
    7e06:	42 81       	ldd	r20, Z+2	; 0x02
    7e08:	53 81       	ldd	r21, Z+3	; 0x03
    7e0a:	34 97       	sbiw	r30, 0x04	; 4
    7e0c:	60 81       	ld	r22, Z
    7e0e:	71 81       	ldd	r23, Z+1	; 0x01
    7e10:	82 81       	ldd	r24, Z+2	; 0x02
    7e12:	93 81       	ldd	r25, Z+3	; 0x03
    7e14:	0e 94 45 67 	call	0xce8a	; 0xce8a <atan2>
    7e18:	d2 01       	movw	r26, r4
    7e1a:	d0 96       	adiw	r26, 0x30	; 48
    7e1c:	6d 93       	st	X+, r22
    7e1e:	7d 93       	st	X+, r23
    7e20:	8d 93       	st	X+, r24
    7e22:	9c 93       	st	X, r25
    7e24:	d3 97       	sbiw	r26, 0x33	; 51
yawRads = heading;	*/
	
	
	

}
    7e26:	c4 58       	subi	r28, 0x84	; 132
    7e28:	df 4f       	sbci	r29, 0xFF	; 255
    7e2a:	0f b6       	in	r0, 0x3f	; 63
    7e2c:	f8 94       	cli
    7e2e:	de bf       	out	0x3e, r29	; 62
    7e30:	0f be       	out	0x3f, r0	; 63
    7e32:	cd bf       	out	0x3d, r28	; 61
    7e34:	df 91       	pop	r29
    7e36:	cf 91       	pop	r28
    7e38:	1f 91       	pop	r17
    7e3a:	0f 91       	pop	r16
    7e3c:	ff 90       	pop	r15
    7e3e:	ef 90       	pop	r14
    7e40:	df 90       	pop	r13
    7e42:	cf 90       	pop	r12
    7e44:	bf 90       	pop	r11
    7e46:	af 90       	pop	r10
    7e48:	9f 90       	pop	r9
    7e4a:	8f 90       	pop	r8
    7e4c:	7f 90       	pop	r7
    7e4e:	6f 90       	pop	r6
    7e50:	5f 90       	pop	r5
    7e52:	4f 90       	pop	r4
    7e54:	3f 90       	pop	r3
    7e56:	2f 90       	pop	r2
    7e58:	08 95       	ret

00007e5a <_ZN10helicopter10navigation4AHRS10getYawRadsEv>:

float AHRS::getYawRads()
{
	return yawRads;
    7e5a:	fc 01       	movw	r30, r24
    7e5c:	60 a5       	ldd	r22, Z+40	; 0x28
    7e5e:	71 a5       	ldd	r23, Z+41	; 0x29
    7e60:	82 a5       	ldd	r24, Z+42	; 0x2a
    7e62:	93 a5       	ldd	r25, Z+43	; 0x2b
}
    7e64:	08 95       	ret

00007e66 <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>:

float AHRS::getPitchRads()
{
	return pitchRads;
    7e66:	fc 01       	movw	r30, r24
    7e68:	64 a5       	ldd	r22, Z+44	; 0x2c
    7e6a:	75 a5       	ldd	r23, Z+45	; 0x2d
    7e6c:	86 a5       	ldd	r24, Z+46	; 0x2e
    7e6e:	97 a5       	ldd	r25, Z+47	; 0x2f
}
    7e70:	08 95       	ret

00007e72 <_ZN10helicopter10navigation4AHRS11getRollRadsEv>:

float AHRS::getRollRads()
{
	return rollRads;
    7e72:	fc 01       	movw	r30, r24
    7e74:	60 a9       	ldd	r22, Z+48	; 0x30
    7e76:	71 a9       	ldd	r23, Z+49	; 0x31
    7e78:	82 a9       	ldd	r24, Z+50	; 0x32
    7e7a:	93 a9       	ldd	r25, Z+51	; 0x33
}
    7e7c:	08 95       	ret

00007e7e <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>:
	}

	return scheduler;
}

Scheduler::Scheduler(unsigned long cpuSpeed, PRESCALER prescaler, int schedulerTickFrequencyHz)
    7e7e:	ef 92       	push	r14
    7e80:	ff 92       	push	r15
    7e82:	0f 93       	push	r16
    7e84:	1f 93       	push	r17
    7e86:	cf 93       	push	r28
    7e88:	df 93       	push	r29
    7e8a:	ec 01       	movw	r28, r24
    7e8c:	cb 01       	movw	r24, r22
    7e8e:	ba 01       	movw	r22, r20
    7e90:	79 01       	movw	r14, r18
{
	//Calculate the timer value to achieve the desired frequency.
	targetTimerCount =  ((cpuSpeed / prescaler) / schedulerTickFrequencyHz);
    7e92:	44 27       	eor	r20, r20
    7e94:	37 fd       	sbrc	r19, 7
    7e96:	40 95       	com	r20
    7e98:	54 2f       	mov	r21, r20
    7e9a:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    7e9e:	ca 01       	movw	r24, r20
    7ea0:	b9 01       	movw	r22, r18
    7ea2:	98 01       	movw	r18, r16
    7ea4:	44 27       	eor	r20, r20
    7ea6:	37 fd       	sbrc	r19, 7
    7ea8:	40 95       	com	r20
    7eaa:	54 2f       	mov	r21, r20
    7eac:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    7eb0:	3d ab       	std	Y+53, r19	; 0x35
    7eb2:	2c ab       	std	Y+52, r18	; 0x34

	this->targetTimerCount = targetTimerCount;

	this->prescaler = prescaler;
    7eb4:	ff aa       	std	Y+55, r15	; 0x37
    7eb6:	ee aa       	std	Y+54, r14	; 0x36
	
	numOfTasks = 0;
    7eb8:	1b aa       	std	Y+51, r1	; 0x33
    7eba:	1a aa       	std	Y+50, r1	; 0x32
	
	blowFrameDetected = false;
    7ebc:	18 ae       	std	Y+56, r1	; 0x38
	
	completedDispatch = true;
    7ebe:	81 e0       	ldi	r24, 0x01	; 1
    7ec0:	89 af       	std	Y+57, r24	; 0x39
}
    7ec2:	df 91       	pop	r29
    7ec4:	cf 91       	pop	r28
    7ec6:	1f 91       	pop	r17
    7ec8:	0f 91       	pop	r16
    7eca:	ff 90       	pop	r15
    7ecc:	ef 90       	pop	r14
    7ece:	08 95       	ret

00007ed0 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>:
using namespace helicopter::model;

Scheduler* Scheduler::scheduler = NULL;

Scheduler* Scheduler::getScheduler()
{
    7ed0:	0f 93       	push	r16
    7ed2:	1f 93       	push	r17
    7ed4:	cf 93       	push	r28
    7ed6:	df 93       	push	r29
	if (scheduler == NULL)
    7ed8:	80 91 a6 03 	lds	r24, 0x03A6
    7edc:	90 91 a7 03 	lds	r25, 0x03A7
    7ee0:	89 2b       	or	r24, r25
    7ee2:	99 f4       	brne	.+38     	; 0x7f0a <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv+0x3a>
	{
		scheduler = new Scheduler(F_CPU, PRESCALE_BY_TENTWENTYFOUR, SCHEDULER_TICK_FREQUENCY_HZ);
    7ee4:	8a e3       	ldi	r24, 0x3A	; 58
    7ee6:	90 e0       	ldi	r25, 0x00	; 0
    7ee8:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    7eec:	ec 01       	movw	r28, r24
    7eee:	08 ec       	ldi	r16, 0xC8	; 200
    7ef0:	10 e0       	ldi	r17, 0x00	; 0
    7ef2:	20 e0       	ldi	r18, 0x00	; 0
    7ef4:	34 e0       	ldi	r19, 0x04	; 4
    7ef6:	40 e0       	ldi	r20, 0x00	; 0
    7ef8:	54 e2       	ldi	r21, 0x24	; 36
    7efa:	64 ef       	ldi	r22, 0xF4	; 244
    7efc:	70 e0       	ldi	r23, 0x00	; 0
    7efe:	0e 94 3f 3f 	call	0x7e7e	; 0x7e7e <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>
    7f02:	d0 93 a7 03 	sts	0x03A7, r29
    7f06:	c0 93 a6 03 	sts	0x03A6, r28
	}

	return scheduler;
}
    7f0a:	80 91 a6 03 	lds	r24, 0x03A6
    7f0e:	90 91 a7 03 	lds	r25, 0x03A7
    7f12:	df 91       	pop	r29
    7f14:	cf 91       	pop	r28
    7f16:	1f 91       	pop	r17
    7f18:	0f 91       	pop	r16
    7f1a:	08 95       	ret

00007f1c <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>:
	}
}

int Scheduler::addTask(Task *task)
{
	if (numOfTasks < MAXNUMOFTASKS)
    7f1c:	fc 01       	movw	r30, r24
    7f1e:	22 a9       	ldd	r18, Z+50	; 0x32
    7f20:	33 a9       	ldd	r19, Z+51	; 0x33
    7f22:	29 31       	cpi	r18, 0x19	; 25
    7f24:	31 05       	cpc	r19, r1
    7f26:	7c f4       	brge	.+30     	; 0x7f46 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE+0x2a>
	{
		tasks[numOfTasks] = task;
    7f28:	f9 01       	movw	r30, r18
    7f2a:	ee 0f       	add	r30, r30
    7f2c:	ff 1f       	adc	r31, r31
    7f2e:	e8 0f       	add	r30, r24
    7f30:	f9 1f       	adc	r31, r25
    7f32:	71 83       	std	Z+1, r23	; 0x01
    7f34:	60 83       	st	Z, r22
		numOfTasks++;
    7f36:	2f 5f       	subi	r18, 0xFF	; 255
    7f38:	3f 4f       	sbci	r19, 0xFF	; 255
    7f3a:	fc 01       	movw	r30, r24
    7f3c:	33 ab       	std	Z+51, r19	; 0x33
    7f3e:	22 ab       	std	Z+50, r18	; 0x32
		
		return 0;
    7f40:	80 e0       	ldi	r24, 0x00	; 0
    7f42:	90 e0       	ldi	r25, 0x00	; 0
    7f44:	08 95       	ret
	}

	return -1;
    7f46:	8f ef       	ldi	r24, 0xFF	; 255
    7f48:	9f ef       	ldi	r25, 0xFF	; 255
}
    7f4a:	08 95       	ret

00007f4c <_ZN10helicopter9scheduler9Scheduler4initEv>:

void Scheduler::init()
{
    7f4c:	ef 92       	push	r14
    7f4e:	ff 92       	push	r15
    7f50:	0f 93       	push	r16
    7f52:	1f 93       	push	r17
    7f54:	cf 93       	push	r28
    7f56:	df 93       	push	r29
    7f58:	7c 01       	movw	r14, r24
	cli();
    7f5a:	f8 94       	cli
	
	for (int i = 0; i < numOfTasks; i++)
    7f5c:	dc 01       	movw	r26, r24
    7f5e:	d2 96       	adiw	r26, 0x32	; 50
    7f60:	8d 91       	ld	r24, X+
    7f62:	9c 91       	ld	r25, X
    7f64:	d3 97       	sbiw	r26, 0x33	; 51
    7f66:	18 16       	cp	r1, r24
    7f68:	19 06       	cpc	r1, r25
    7f6a:	ac f4       	brge	.+42     	; 0x7f96 <_ZN10helicopter9scheduler9Scheduler4initEv+0x4a>
    7f6c:	87 01       	movw	r16, r14
    7f6e:	c0 e0       	ldi	r28, 0x00	; 0
    7f70:	d0 e0       	ldi	r29, 0x00	; 0
	{
		tasks[i]->init();
    7f72:	f8 01       	movw	r30, r16
    7f74:	81 91       	ld	r24, Z+
    7f76:	91 91       	ld	r25, Z+
    7f78:	8f 01       	movw	r16, r30
    7f7a:	dc 01       	movw	r26, r24
    7f7c:	ed 91       	ld	r30, X+
    7f7e:	fc 91       	ld	r31, X
    7f80:	06 80       	ldd	r0, Z+6	; 0x06
    7f82:	f7 81       	ldd	r31, Z+7	; 0x07
    7f84:	e0 2d       	mov	r30, r0
    7f86:	19 95       	eicall

void Scheduler::init()
{
	cli();
	
	for (int i = 0; i < numOfTasks; i++)
    7f88:	21 96       	adiw	r28, 0x01	; 1
    7f8a:	f7 01       	movw	r30, r14
    7f8c:	22 a9       	ldd	r18, Z+50	; 0x32
    7f8e:	33 a9       	ldd	r19, Z+51	; 0x33
    7f90:	c2 17       	cp	r28, r18
    7f92:	d3 07       	cpc	r29, r19
    7f94:	74 f3       	brlt	.-36     	; 0x7f72 <_ZN10helicopter9scheduler9Scheduler4initEv+0x26>
	{
		tasks[i]->init();
	}
	
	//setup timer
	OCR2A = targetTimerCount; //Set Clear Timer on Compare (auto reset) (CTC)
    7f96:	d7 01       	movw	r26, r14
    7f98:	d4 96       	adiw	r26, 0x34	; 52
    7f9a:	8c 91       	ld	r24, X
    7f9c:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2A |= (1 << WGM21); //Configure timer 2 for ctc mode
    7fa0:	e0 eb       	ldi	r30, 0xB0	; 176
    7fa2:	f0 e0       	ldi	r31, 0x00	; 0
    7fa4:	80 81       	ld	r24, Z
    7fa6:	82 60       	ori	r24, 0x02	; 2
    7fa8:	80 83       	st	Z, r24
	TIMSK2 |= (1 << OCIE2A); //enable ctc interrupt for OCR0A
    7faa:	e0 e7       	ldi	r30, 0x70	; 112
    7fac:	f0 e0       	ldi	r31, 0x00	; 0
    7fae:	80 81       	ld	r24, Z
    7fb0:	82 60       	ori	r24, 0x02	; 2
    7fb2:	80 83       	st	Z, r24
		
	sei(); //Enable global interrupts
    7fb4:	78 94       	sei
}
    7fb6:	df 91       	pop	r29
    7fb8:	cf 91       	pop	r28
    7fba:	1f 91       	pop	r17
    7fbc:	0f 91       	pop	r16
    7fbe:	ff 90       	pop	r15
    7fc0:	ef 90       	pop	r14
    7fc2:	08 95       	ret

00007fc4 <_ZN10helicopter9scheduler9Scheduler8dispatchEv>:

void Scheduler::dispatch()
{
    7fc4:	ef 92       	push	r14
    7fc6:	ff 92       	push	r15
    7fc8:	0f 93       	push	r16
    7fca:	1f 93       	push	r17
    7fcc:	cf 93       	push	r28
    7fce:	df 93       	push	r29
    7fd0:	7c 01       	movw	r14, r24
	completedDispatch = false;
    7fd2:	fc 01       	movw	r30, r24
    7fd4:	11 ae       	std	Z+57, r1	; 0x39
	blowFrameDetected = false;
    7fd6:	10 ae       	std	Z+56, r1	; 0x38
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    7fd8:	82 a9       	ldd	r24, Z+50	; 0x32
    7fda:	93 a9       	ldd	r25, Z+51	; 0x33
    7fdc:	18 16       	cp	r1, r24
    7fde:	19 06       	cpc	r1, r25
    7fe0:	f4 f4       	brge	.+60     	; 0x801e <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x5a>
    7fe2:	87 01       	movw	r16, r14
    7fe4:	c0 e0       	ldi	r28, 0x00	; 0
    7fe6:	d0 e0       	ldi	r29, 0x00	; 0
	{
		task = tasks[i];
    7fe8:	f8 01       	movw	r30, r16
    7fea:	a1 91       	ld	r26, Z+
    7fec:	b1 91       	ld	r27, Z+
    7fee:	8f 01       	movw	r16, r30
		
		if (task->getIsReadyToRun())
    7ff0:	16 96       	adiw	r26, 0x06	; 6
    7ff2:	8c 91       	ld	r24, X
    7ff4:	16 97       	sbiw	r26, 0x06	; 6
    7ff6:	88 23       	and	r24, r24
    7ff8:	59 f0       	breq	.+22     	; 0x8010 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x4c>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    7ffa:	16 96       	adiw	r26, 0x06	; 6
    7ffc:	1c 92       	st	X, r1
    7ffe:	16 97       	sbiw	r26, 0x06	; 6
		{
			task->setIsReadyToRun(false);
			task->runTask();
    8000:	ed 91       	ld	r30, X+
    8002:	fc 91       	ld	r31, X
    8004:	11 97       	sbiw	r26, 0x01	; 1
    8006:	00 84       	ldd	r0, Z+8	; 0x08
    8008:	f1 85       	ldd	r31, Z+9	; 0x09
    800a:	e0 2d       	mov	r30, r0
    800c:	cd 01       	movw	r24, r26
    800e:	19 95       	eicall
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    8010:	21 96       	adiw	r28, 0x01	; 1
    8012:	f7 01       	movw	r30, r14
    8014:	22 a9       	ldd	r18, Z+50	; 0x32
    8016:	33 a9       	ldd	r19, Z+51	; 0x33
    8018:	c2 17       	cp	r28, r18
    801a:	d3 07       	cpc	r29, r19
    801c:	2c f3       	brlt	.-54     	; 0x7fe8 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x24>
			task->setIsReadyToRun(false);
			task->runTask();
		}
	}

	completedDispatch = true;
    801e:	81 e0       	ldi	r24, 0x01	; 1
    8020:	f7 01       	movw	r30, r14
    8022:	81 af       	std	Z+57, r24	; 0x39
	
	//tells the processor to goto sleep to conserve power since no more
	//tasks are scheduled to be run until after the next scheduler interrupt(tick)
	//which will then wake the processor back up.
	set_sleep_mode(SLEEP_MODE_IDLE);
    8024:	83 b7       	in	r24, 0x33	; 51
    8026:	81 7f       	andi	r24, 0xF1	; 241
    8028:	83 bf       	out	0x33, r24	; 51
	sleep_mode();
    802a:	83 b7       	in	r24, 0x33	; 51
    802c:	81 60       	ori	r24, 0x01	; 1
    802e:	83 bf       	out	0x33, r24	; 51
    8030:	88 95       	sleep
    8032:	83 b7       	in	r24, 0x33	; 51
    8034:	8e 7f       	andi	r24, 0xFE	; 254
    8036:	83 bf       	out	0x33, r24	; 51
}
    8038:	df 91       	pop	r29
    803a:	cf 91       	pop	r28
    803c:	1f 91       	pop	r17
    803e:	0f 91       	pop	r16
    8040:	ff 90       	pop	r15
    8042:	ef 90       	pop	r14
    8044:	08 95       	ret

00008046 <_ZN10helicopter9scheduler9Scheduler5startEv>:

void Scheduler::start()
{
	//Setting TCCR to a prescaler will start the timer.
	switch(this->prescaler)
    8046:	fc 01       	movw	r30, r24
    8048:	86 a9       	ldd	r24, Z+54	; 0x36
    804a:	97 a9       	ldd	r25, Z+55	; 0x37
    804c:	80 34       	cpi	r24, 0x40	; 64
    804e:	91 05       	cpc	r25, r1
    8050:	d9 f0       	breq	.+54     	; 0x8088 <_ZN10helicopter9scheduler9Scheduler5startEv+0x42>
    8052:	34 f4       	brge	.+12     	; 0x8060 <_ZN10helicopter9scheduler9Scheduler5startEv+0x1a>
    8054:	81 30       	cpi	r24, 0x01	; 1
    8056:	91 05       	cpc	r25, r1
    8058:	59 f0       	breq	.+22     	; 0x8070 <_ZN10helicopter9scheduler9Scheduler5startEv+0x2a>
    805a:	08 97       	sbiw	r24, 0x08	; 8
    805c:	79 f0       	breq	.+30     	; 0x807c <_ZN10helicopter9scheduler9Scheduler5startEv+0x36>
    805e:	26 c0       	rjmp	.+76     	; 0x80ac <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
    8060:	81 15       	cp	r24, r1
    8062:	f1 e0       	ldi	r31, 0x01	; 1
    8064:	9f 07       	cpc	r25, r31
    8066:	b1 f0       	breq	.+44     	; 0x8094 <_ZN10helicopter9scheduler9Scheduler5startEv+0x4e>
    8068:	81 15       	cp	r24, r1
    806a:	94 40       	sbci	r25, 0x04	; 4
    806c:	c9 f0       	breq	.+50     	; 0x80a0 <_ZN10helicopter9scheduler9Scheduler5startEv+0x5a>
    806e:	1e c0       	rjmp	.+60     	; 0x80ac <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
	{
		case 1:
			TCCR2B |= NoPrescaling;
    8070:	e1 eb       	ldi	r30, 0xB1	; 177
    8072:	f0 e0       	ldi	r31, 0x00	; 0
    8074:	80 81       	ld	r24, Z
    8076:	81 60       	ori	r24, 0x01	; 1
    8078:	80 83       	st	Z, r24
			break;
    807a:	08 95       	ret
		case 8:
			TCCR2B |= PrescaleByEight;
    807c:	e1 eb       	ldi	r30, 0xB1	; 177
    807e:	f0 e0       	ldi	r31, 0x00	; 0
    8080:	80 81       	ld	r24, Z
    8082:	82 60       	ori	r24, 0x02	; 2
    8084:	80 83       	st	Z, r24
			break;
    8086:	08 95       	ret
		case 64:
			TCCR2B |= PrescaleBySixtyFour;
    8088:	e1 eb       	ldi	r30, 0xB1	; 177
    808a:	f0 e0       	ldi	r31, 0x00	; 0
    808c:	80 81       	ld	r24, Z
    808e:	84 60       	ori	r24, 0x04	; 4
    8090:	80 83       	st	Z, r24
			break;
    8092:	08 95       	ret
		case 256:
			TCCR2B |= PrescaleByTwofiftysix;
    8094:	e1 eb       	ldi	r30, 0xB1	; 177
    8096:	f0 e0       	ldi	r31, 0x00	; 0
    8098:	80 81       	ld	r24, Z
    809a:	86 60       	ori	r24, 0x06	; 6
    809c:	80 83       	st	Z, r24
			break;
    809e:	08 95       	ret
		case 1024:
			TCCR2B |= PrescaleByTentwentyfour;
    80a0:	e1 eb       	ldi	r30, 0xB1	; 177
    80a2:	f0 e0       	ldi	r31, 0x00	; 0
    80a4:	80 81       	ld	r24, Z
    80a6:	87 60       	ori	r24, 0x07	; 7
    80a8:	80 83       	st	Z, r24
			break;
    80aa:	08 95       	ret
		default:
			TCCR2B |= NoPrescaling;	
    80ac:	e1 eb       	ldi	r30, 0xB1	; 177
    80ae:	f0 e0       	ldi	r31, 0x00	; 0
    80b0:	80 81       	ld	r24, Z
    80b2:	81 60       	ori	r24, 0x01	; 1
    80b4:	80 83       	st	Z, r24
    80b6:	08 95       	ret

000080b8 <__vector_13>:

/**
 * Interrupt service routine for determining when tasks are ready to execute.
 */
ISR(TIMER2_COMPA_vect)
{
    80b8:	1f 92       	push	r1
    80ba:	0f 92       	push	r0
    80bc:	0f b6       	in	r0, 0x3f	; 63
    80be:	0f 92       	push	r0
    80c0:	11 24       	eor	r1, r1
    80c2:	0b b6       	in	r0, 0x3b	; 59
    80c4:	0f 92       	push	r0
    80c6:	2f 93       	push	r18
    80c8:	3f 93       	push	r19
    80ca:	4f 93       	push	r20
    80cc:	5f 93       	push	r21
    80ce:	6f 93       	push	r22
    80d0:	7f 93       	push	r23
    80d2:	8f 93       	push	r24
    80d4:	9f 93       	push	r25
    80d6:	af 93       	push	r26
    80d8:	bf 93       	push	r27
    80da:	cf 93       	push	r28
    80dc:	df 93       	push	r29
    80de:	ef 93       	push	r30
    80e0:	ff 93       	push	r31
publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);	
}
	*/
	
	
	Scheduler *scheduler = Scheduler::getScheduler();
    80e2:	0e 94 68 3f 	call	0x7ed0	; 0x7ed0 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    80e6:	ec 01       	movw	r28, r24
	
	//Detect if the scheduler blew a frame
	if (!scheduler->hasCompletedDispatch())
    80e8:	89 ad       	ldd	r24, Y+57	; 0x39
    80ea:	81 11       	cpse	r24, r1
    80ec:	12 c0       	rjmp	.+36     	; 0x8112 <__vector_13+0x5a>
	{
//		scheduler->hasBlownFrame(true);
//publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);		
//SystemModel::publicModel->SerialCommunicationBufferOverruns(SystemModel::publicModel->SerialCommunicationBufferOverruns() + 1);		
SystemModel::publicModel->BlownFrames(SystemModel::publicModel->BlownFrames() + 1);		
    80ee:	e0 91 a4 03 	lds	r30, 0x03A4
    80f2:	f0 91 a5 03 	lds	r31, 0x03A5
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
    80f6:	ea 54       	subi	r30, 0x4A	; 74
    80f8:	ff 4f       	sbci	r31, 0xFF	; 255
    80fa:	40 81       	ld	r20, Z
    80fc:	51 81       	ldd	r21, Z+1	; 0x01
    80fe:	62 81       	ldd	r22, Z+2	; 0x02
    8100:	73 81       	ldd	r23, Z+3	; 0x03
    8102:	4f 5f       	subi	r20, 0xFF	; 255
    8104:	5f 4f       	sbci	r21, 0xFF	; 255
    8106:	6f 4f       	sbci	r22, 0xFF	; 255
    8108:	7f 4f       	sbci	r23, 0xFF	; 255
    810a:	40 83       	st	Z, r20
    810c:	51 83       	std	Z+1, r21	; 0x01
    810e:	62 83       	std	Z+2, r22	; 0x02
    8110:	73 83       	std	Z+3, r23	; 0x03
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    8112:	8a a9       	ldd	r24, Y+50	; 0x32
    8114:	9b a9       	ldd	r25, Y+51	; 0x33
    8116:	18 16       	cp	r1, r24
    8118:	19 06       	cpc	r1, r25
    811a:	e4 f4       	brge	.+56     	; 0x8154 <__vector_13+0x9c>
    811c:	de 01       	movw	r26, r28
    811e:	20 e0       	ldi	r18, 0x00	; 0
    8120:	30 e0       	ldi	r19, 0x00	; 0
    8122:	61 e0       	ldi	r22, 0x01	; 1
	{
		task = scheduler->getTasks()[i];
    8124:	ed 91       	ld	r30, X+
    8126:	fd 91       	ld	r31, X+
				virtual void runTask();
				
					
				int getDelay()
				{
					return delay;
    8128:	42 81       	ldd	r20, Z+2	; 0x02
    812a:	53 81       	ldd	r21, Z+3	; 0x03
		
		if (task->getDelay() <= 1)
    812c:	42 30       	cpi	r20, 0x02	; 2
    812e:	51 05       	cpc	r21, r1
    8130:	34 f4       	brge	.+12     	; 0x813e <__vector_13+0x86>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    8132:	66 83       	std	Z+6, r22	; 0x06
					return period;
				}
				
				void setDelay(int delay)
				{
					this->delay = delay;
    8134:	84 81       	ldd	r24, Z+4	; 0x04
    8136:	95 81       	ldd	r25, Z+5	; 0x05
    8138:	93 83       	std	Z+3, r25	; 0x03
    813a:	82 83       	std	Z+2, r24	; 0x02
    813c:	04 c0       	rjmp	.+8      	; 0x8146 <__vector_13+0x8e>
				/**
				 * Reduces the delay by one tick.
				 */
				void reduceDelay()
				{
					delay--;
    813e:	41 50       	subi	r20, 0x01	; 1
    8140:	51 09       	sbc	r21, r1
    8142:	53 83       	std	Z+3, r21	; 0x03
    8144:	42 83       	std	Z+2, r20	; 0x02
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    8146:	2f 5f       	subi	r18, 0xFF	; 255
    8148:	3f 4f       	sbci	r19, 0xFF	; 255
    814a:	8a a9       	ldd	r24, Y+50	; 0x32
    814c:	9b a9       	ldd	r25, Y+51	; 0x33
    814e:	28 17       	cp	r18, r24
    8150:	39 07       	cpc	r19, r25
    8152:	44 f3       	brlt	.-48     	; 0x8124 <__vector_13+0x6c>
		}else
		{
			task->reduceDelay();
		}
	}
}
    8154:	ff 91       	pop	r31
    8156:	ef 91       	pop	r30
    8158:	df 91       	pop	r29
    815a:	cf 91       	pop	r28
    815c:	bf 91       	pop	r27
    815e:	af 91       	pop	r26
    8160:	9f 91       	pop	r25
    8162:	8f 91       	pop	r24
    8164:	7f 91       	pop	r23
    8166:	6f 91       	pop	r22
    8168:	5f 91       	pop	r21
    816a:	4f 91       	pop	r20
    816c:	3f 91       	pop	r19
    816e:	2f 91       	pop	r18
    8170:	0f 90       	pop	r0
    8172:	0b be       	out	0x3b, r0	; 59
    8174:	0f 90       	pop	r0
    8176:	0f be       	out	0x3f, r0	; 63
    8178:	0f 90       	pop	r0
    817a:	1f 90       	pop	r1
    817c:	18 95       	reti

0000817e <_ZN10helicopter7sensors15BarometerSensor4initEv>:


using namespace helicopter::sensors;

void BarometerSensor::init()
{
    817e:	8f 92       	push	r8
    8180:	9f 92       	push	r9
    8182:	af 92       	push	r10
    8184:	bf 92       	push	r11
    8186:	cf 92       	push	r12
    8188:	df 92       	push	r13
    818a:	ef 92       	push	r14
    818c:	ff 92       	push	r15
    818e:	0f 93       	push	r16
    8190:	1f 93       	push	r17
    8192:	cf 93       	push	r28
    8194:	df 93       	push	r29
    8196:	8c 01       	movw	r16, r24
	//Per page 9 of MS5611-01Ba03.PDF Reset the barometer to ensure calibration PROM gets loaded.
	spiDriver->transactionWrite(RESET_COMMAND);
    8198:	6e e1       	ldi	r22, 0x1E	; 30
    819a:	fc 01       	movw	r30, r24
    819c:	80 81       	ld	r24, Z
    819e:	91 81       	ldd	r25, Z+1	; 0x01
    81a0:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    81a4:	8f e1       	ldi	r24, 0x1F	; 31
    81a6:	9e e4       	ldi	r25, 0x4E	; 78
    81a8:	01 97       	sbiw	r24, 0x01	; 1
    81aa:	f1 f7       	brne	.-4      	; 0x81a8 <_ZN10helicopter7sensors15BarometerSensor4initEv+0x2a>
    81ac:	00 c0       	rjmp	.+0      	; 0x81ae <_ZN10helicopter7sensors15BarometerSensor4initEv+0x30>
    81ae:	00 00       	nop
	/**
	 * Each barometer is individually calibrated at the factory. This reads those calibration
	 * values for our calculations to compensate temperature and pressure values. 
	 * Those values are stored in the programmable read only memory (PROM) of the barometer
	 */
	spiDriver->beginTransaction();
    81b0:	f8 01       	movw	r30, r16
    81b2:	80 81       	ld	r24, Z
    81b4:	91 81       	ldd	r25, Z+1	; 0x01
    81b6:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C1_COMMAND);
    81ba:	62 ea       	ldi	r22, 0xA2	; 162
    81bc:	f8 01       	movw	r30, r16
    81be:	80 81       	ld	r24, Z
    81c0:	91 81       	ldd	r25, Z+1	; 0x01
    81c2:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivity_SENSt1_C1 = spiDriver->readUInt();
    81c6:	f8 01       	movw	r30, r16
    81c8:	80 81       	ld	r24, Z
    81ca:	91 81       	ldd	r25, Z+1	; 0x01
    81cc:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    81d0:	4c 01       	movw	r8, r24
    81d2:	f8 01       	movw	r30, r16
    81d4:	82 8b       	std	Z+18, r24	; 0x12
    81d6:	93 8a       	std	Z+19, r9	; 0x13
    81d8:	14 8a       	std	Z+20, r1	; 0x14
    81da:	15 8a       	std	Z+21, r1	; 0x15
    81dc:	16 8a       	std	Z+22, r1	; 0x16
    81de:	17 8a       	std	Z+23, r1	; 0x17
    81e0:	10 8e       	std	Z+24, r1	; 0x18
    81e2:	11 8e       	std	Z+25, r1	; 0x19
	spiDriver->endTransaction();
    81e4:	80 81       	ld	r24, Z
    81e6:	91 81       	ldd	r25, Z+1	; 0x01
    81e8:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    81ec:	f8 01       	movw	r30, r16
    81ee:	80 81       	ld	r24, Z
    81f0:	91 81       	ldd	r25, Z+1	; 0x01
    81f2:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C2_COMMAND);
    81f6:	64 ea       	ldi	r22, 0xA4	; 164
    81f8:	f8 01       	movw	r30, r16
    81fa:	80 81       	ld	r24, Z
    81fc:	91 81       	ldd	r25, Z+1	; 0x01
    81fe:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivityOffset_OFFt1_C2 = spiDriver->readUInt();
    8202:	f8 01       	movw	r30, r16
    8204:	80 81       	ld	r24, Z
    8206:	91 81       	ldd	r25, Z+1	; 0x01
    8208:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    820c:	4c 01       	movw	r8, r24
    820e:	f8 01       	movw	r30, r16
    8210:	82 8f       	std	Z+26, r24	; 0x1a
    8212:	93 8e       	std	Z+27, r9	; 0x1b
    8214:	14 8e       	std	Z+28, r1	; 0x1c
    8216:	15 8e       	std	Z+29, r1	; 0x1d
    8218:	16 8e       	std	Z+30, r1	; 0x1e
    821a:	17 8e       	std	Z+31, r1	; 0x1f
    821c:	10 a2       	std	Z+32, r1	; 0x20
    821e:	11 a2       	std	Z+33, r1	; 0x21
	spiDriver->endTransaction();
    8220:	80 81       	ld	r24, Z
    8222:	91 81       	ldd	r25, Z+1	; 0x01
    8224:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>

	spiDriver->beginTransaction();
    8228:	f8 01       	movw	r30, r16
    822a:	80 81       	ld	r24, Z
    822c:	91 81       	ldd	r25, Z+1	; 0x01
    822e:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C3_COMMAND);
    8232:	66 ea       	ldi	r22, 0xA6	; 166
    8234:	f8 01       	movw	r30, r16
    8236:	80 81       	ld	r24, Z
    8238:	91 81       	ldd	r25, Z+1	; 0x01
    823a:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureSensitivity_TCS_C3 = spiDriver->readUInt();
    823e:	f8 01       	movw	r30, r16
    8240:	80 81       	ld	r24, Z
    8242:	91 81       	ldd	r25, Z+1	; 0x01
    8244:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8248:	4c 01       	movw	r8, r24
    824a:	f8 01       	movw	r30, r16
    824c:	82 a3       	std	Z+34, r24	; 0x22
    824e:	93 a2       	std	Z+35, r9	; 0x23
    8250:	14 a2       	std	Z+36, r1	; 0x24
    8252:	15 a2       	std	Z+37, r1	; 0x25
    8254:	16 a2       	std	Z+38, r1	; 0x26
    8256:	17 a2       	std	Z+39, r1	; 0x27
    8258:	10 a6       	std	Z+40, r1	; 0x28
    825a:	11 a6       	std	Z+41, r1	; 0x29
	spiDriver->endTransaction();
    825c:	80 81       	ld	r24, Z
    825e:	91 81       	ldd	r25, Z+1	; 0x01
    8260:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    8264:	f8 01       	movw	r30, r16
    8266:	80 81       	ld	r24, Z
    8268:	91 81       	ldd	r25, Z+1	; 0x01
    826a:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C4_COMMAND);
    826e:	68 ea       	ldi	r22, 0xA8	; 168
    8270:	f8 01       	movw	r30, r16
    8272:	80 81       	ld	r24, Z
    8274:	91 81       	ldd	r25, Z+1	; 0x01
    8276:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureOffset_TCO_C4 = spiDriver->readUInt();
    827a:	f8 01       	movw	r30, r16
    827c:	80 81       	ld	r24, Z
    827e:	91 81       	ldd	r25, Z+1	; 0x01
    8280:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8284:	4c 01       	movw	r8, r24
    8286:	f8 01       	movw	r30, r16
    8288:	82 a7       	std	Z+42, r24	; 0x2a
    828a:	93 a6       	std	Z+43, r9	; 0x2b
    828c:	14 a6       	std	Z+44, r1	; 0x2c
    828e:	15 a6       	std	Z+45, r1	; 0x2d
    8290:	16 a6       	std	Z+46, r1	; 0x2e
    8292:	17 a6       	std	Z+47, r1	; 0x2f
    8294:	10 aa       	std	Z+48, r1	; 0x30
    8296:	11 aa       	std	Z+49, r1	; 0x31
	spiDriver->endTransaction();
    8298:	80 81       	ld	r24, Z
    829a:	91 81       	ldd	r25, Z+1	; 0x01
    829c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    82a0:	f8 01       	movw	r30, r16
    82a2:	80 81       	ld	r24, Z
    82a4:	91 81       	ldd	r25, Z+1	; 0x01
    82a6:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C5_COMMAND);
    82aa:	6a ea       	ldi	r22, 0xAA	; 170
    82ac:	f8 01       	movw	r30, r16
    82ae:	80 81       	ld	r24, Z
    82b0:	91 81       	ldd	r25, Z+1	; 0x01
    82b2:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	referenceTemperature_Tref_C5 = spiDriver->readUInt();
    82b6:	f8 01       	movw	r30, r16
    82b8:	80 81       	ld	r24, Z
    82ba:	91 81       	ldd	r25, Z+1	; 0x01
    82bc:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    82c0:	4c 01       	movw	r8, r24
    82c2:	f8 01       	movw	r30, r16
    82c4:	82 ab       	std	Z+50, r24	; 0x32
    82c6:	93 aa       	std	Z+51, r9	; 0x33
    82c8:	14 aa       	std	Z+52, r1	; 0x34
    82ca:	15 aa       	std	Z+53, r1	; 0x35
    82cc:	16 aa       	std	Z+54, r1	; 0x36
    82ce:	17 aa       	std	Z+55, r1	; 0x37
    82d0:	10 ae       	std	Z+56, r1	; 0x38
    82d2:	11 ae       	std	Z+57, r1	; 0x39
	spiDriver->endTransaction();
    82d4:	80 81       	ld	r24, Z
    82d6:	91 81       	ldd	r25, Z+1	; 0x01
    82d8:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    82dc:	f8 01       	movw	r30, r16
    82de:	80 81       	ld	r24, Z
    82e0:	91 81       	ldd	r25, Z+1	; 0x01
    82e2:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C6_COMMAND);
    82e6:	6c ea       	ldi	r22, 0xAC	; 172
    82e8:	f8 01       	movw	r30, r16
    82ea:	80 81       	ld	r24, Z
    82ec:	91 81       	ldd	r25, Z+1	; 0x01
    82ee:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfTheTemperature_TEMPSENS_C6 = spiDriver->readUInt();
    82f2:	f8 01       	movw	r30, r16
    82f4:	80 81       	ld	r24, Z
    82f6:	91 81       	ldd	r25, Z+1	; 0x01
    82f8:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    82fc:	4c 01       	movw	r8, r24
    82fe:	98 01       	movw	r18, r16
    8300:	26 5c       	subi	r18, 0xC6	; 198
    8302:	3f 4f       	sbci	r19, 0xFF	; 255
    8304:	f8 01       	movw	r30, r16
    8306:	82 af       	std	Z+58, r24	; 0x3a
    8308:	f9 01       	movw	r30, r18
    830a:	91 82       	std	Z+1, r9	; 0x01
    830c:	12 82       	std	Z+2, r1	; 0x02
    830e:	13 82       	std	Z+3, r1	; 0x03
    8310:	14 82       	std	Z+4, r1	; 0x04
    8312:	15 82       	std	Z+5, r1	; 0x05
    8314:	16 82       	std	Z+6, r1	; 0x06
    8316:	17 82       	std	Z+7, r1	; 0x07
	spiDriver->endTransaction();
    8318:	f8 01       	movw	r30, r16
    831a:	80 81       	ld	r24, Z
    831c:	91 81       	ldd	r25, Z+1	; 0x01
    831e:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    8322:	df 91       	pop	r29
    8324:	cf 91       	pop	r28
    8326:	1f 91       	pop	r17
    8328:	0f 91       	pop	r16
    832a:	ff 90       	pop	r15
    832c:	ef 90       	pop	r14
    832e:	df 90       	pop	r13
    8330:	cf 90       	pop	r12
    8332:	bf 90       	pop	r11
    8334:	af 90       	pop	r10
    8336:	9f 90       	pop	r9
    8338:	8f 90       	pop	r8
    833a:	08 95       	ret

0000833c <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>:
	 * Initiate conversion for pressure.
	 * According to page 5 in MS5611-01Ba03.PDF, the best noise performance is obtained
	 * when the SPI bus is idle during ADC conversion. So we keep the ADC initiation command
	 * in it's own transaction to reduce noise. 
	 */
	spiDriver->transactionWrite(CONVERT_D1_PRESSURE_OSR_4096);
    833c:	68 e4       	ldi	r22, 0x48	; 72
    833e:	fc 01       	movw	r30, r24
    8340:	80 81       	ld	r24, Z
    8342:	91 81       	ldd	r25, Z+1	; 0x01
    8344:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    8348:	08 95       	ret

0000834a <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>:
}

void BarometerSensor::readD1Data()
{	
    834a:	cf 92       	push	r12
    834c:	df 92       	push	r13
    834e:	ef 92       	push	r14
    8350:	ff 92       	push	r15
    8352:	cf 93       	push	r28
    8354:	df 93       	push	r29
    8356:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    8358:	88 81       	ld	r24, Y
    835a:	99 81       	ldd	r25, Y+1	; 0x01
    835c:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    8360:	60 e0       	ldi	r22, 0x00	; 0
    8362:	88 81       	ld	r24, Y
    8364:	99 81       	ldd	r25, Y+1	; 0x01
    8366:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	
	/**
	 * The pressure is 3 bytes. So read the hight byte, shift it by eight, read the mid byte, shift by 8, then read the low byte
	 * to form a 3 byte 'long'
	 */
	rawPressure = spiDriver->readByte();
    836a:	88 81       	ld	r24, Y
    836c:	99 81       	ldd	r25, Y+1	; 0x01
    836e:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8372:	c8 2e       	mov	r12, r24
    8374:	d1 2c       	mov	r13, r1
    8376:	e1 2c       	mov	r14, r1
    8378:	f1 2c       	mov	r15, r1
    837a:	ce 82       	std	Y+6, r12	; 0x06
    837c:	df 82       	std	Y+7, r13	; 0x07
    837e:	e8 86       	std	Y+8, r14	; 0x08
    8380:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    8382:	88 81       	ld	r24, Y
    8384:	99 81       	ldd	r25, Y+1	; 0x01
    8386:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    838a:	fe 2c       	mov	r15, r14
    838c:	ed 2c       	mov	r14, r13
    838e:	dc 2c       	mov	r13, r12
    8390:	cc 24       	eor	r12, r12
    8392:	c8 2a       	or	r12, r24
    8394:	ce 82       	std	Y+6, r12	; 0x06
    8396:	df 82       	std	Y+7, r13	; 0x07
    8398:	e8 86       	std	Y+8, r14	; 0x08
    839a:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    839c:	88 81       	ld	r24, Y
    839e:	99 81       	ldd	r25, Y+1	; 0x01
    83a0:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    83a4:	fe 2c       	mov	r15, r14
    83a6:	ed 2c       	mov	r14, r13
    83a8:	dc 2c       	mov	r13, r12
    83aa:	cc 24       	eor	r12, r12
    83ac:	c8 2a       	or	r12, r24
    83ae:	ce 82       	std	Y+6, r12	; 0x06
    83b0:	df 82       	std	Y+7, r13	; 0x07
    83b2:	e8 86       	std	Y+8, r14	; 0x08
    83b4:	f9 86       	std	Y+9, r15	; 0x09
	
	spiDriver->endTransaction();	
    83b6:	88 81       	ld	r24, Y
    83b8:	99 81       	ldd	r25, Y+1	; 0x01
    83ba:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    83be:	df 91       	pop	r29
    83c0:	cf 91       	pop	r28
    83c2:	ff 90       	pop	r15
    83c4:	ef 90       	pop	r14
    83c6:	df 90       	pop	r13
    83c8:	cf 90       	pop	r12
    83ca:	08 95       	ret

000083cc <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>:

void BarometerSensor::sendD2Command()
{
	//Initiate conversion for temperature.
	spiDriver->transactionWrite(CONVERT_D2_TEMPERATURE_OSR_4096);	
    83cc:	68 e5       	ldi	r22, 0x58	; 88
    83ce:	fc 01       	movw	r30, r24
    83d0:	80 81       	ld	r24, Z
    83d2:	91 81       	ldd	r25, Z+1	; 0x01
    83d4:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    83d8:	08 95       	ret

000083da <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>:
}

void BarometerSensor::readD2Data()
{
    83da:	cf 92       	push	r12
    83dc:	df 92       	push	r13
    83de:	ef 92       	push	r14
    83e0:	ff 92       	push	r15
    83e2:	cf 93       	push	r28
    83e4:	df 93       	push	r29
    83e6:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    83e8:	88 81       	ld	r24, Y
    83ea:	99 81       	ldd	r25, Y+1	; 0x01
    83ec:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    83f0:	60 e0       	ldi	r22, 0x00	; 0
    83f2:	88 81       	ld	r24, Y
    83f4:	99 81       	ldd	r25, Y+1	; 0x01
    83f6:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	rawTemperature = spiDriver->readByte();
    83fa:	88 81       	ld	r24, Y
    83fc:	99 81       	ldd	r25, Y+1	; 0x01
    83fe:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8402:	c8 2e       	mov	r12, r24
    8404:	d1 2c       	mov	r13, r1
    8406:	e1 2c       	mov	r14, r1
    8408:	f1 2c       	mov	r15, r1
    840a:	ca 82       	std	Y+2, r12	; 0x02
    840c:	db 82       	std	Y+3, r13	; 0x03
    840e:	ec 82       	std	Y+4, r14	; 0x04
    8410:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();
    8412:	88 81       	ld	r24, Y
    8414:	99 81       	ldd	r25, Y+1	; 0x01
    8416:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    841a:	fe 2c       	mov	r15, r14
    841c:	ed 2c       	mov	r14, r13
    841e:	dc 2c       	mov	r13, r12
    8420:	cc 24       	eor	r12, r12
    8422:	c8 2a       	or	r12, r24
    8424:	ca 82       	std	Y+2, r12	; 0x02
    8426:	db 82       	std	Y+3, r13	; 0x03
    8428:	ec 82       	std	Y+4, r14	; 0x04
    842a:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();	
    842c:	88 81       	ld	r24, Y
    842e:	99 81       	ldd	r25, Y+1	; 0x01
    8430:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8434:	fe 2c       	mov	r15, r14
    8436:	ed 2c       	mov	r14, r13
    8438:	dc 2c       	mov	r13, r12
    843a:	cc 24       	eor	r12, r12
    843c:	c8 2a       	or	r12, r24
    843e:	ca 82       	std	Y+2, r12	; 0x02
    8440:	db 82       	std	Y+3, r13	; 0x03
    8442:	ec 82       	std	Y+4, r14	; 0x04
    8444:	fd 82       	std	Y+5, r15	; 0x05

	spiDriver->endTransaction();	
    8446:	88 81       	ld	r24, Y
    8448:	99 81       	ldd	r25, Y+1	; 0x01
    844a:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    844e:	df 91       	pop	r29
    8450:	cf 91       	pop	r28
    8452:	ff 90       	pop	r15
    8454:	ef 90       	pop	r14
    8456:	df 90       	pop	r13
    8458:	cf 90       	pop	r12
    845a:	08 95       	ret

0000845c <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>:


void BarometerSensor::processBaroData()
{
    845c:	2f 92       	push	r2
    845e:	3f 92       	push	r3
    8460:	4f 92       	push	r4
    8462:	5f 92       	push	r5
    8464:	6f 92       	push	r6
    8466:	7f 92       	push	r7
    8468:	8f 92       	push	r8
    846a:	9f 92       	push	r9
    846c:	af 92       	push	r10
    846e:	bf 92       	push	r11
    8470:	cf 92       	push	r12
    8472:	df 92       	push	r13
    8474:	ef 92       	push	r14
    8476:	ff 92       	push	r15
    8478:	0f 93       	push	r16
    847a:	1f 93       	push	r17
    847c:	cf 93       	push	r28
    847e:	df 93       	push	r29
    8480:	cd b7       	in	r28, 0x3d	; 61
    8482:	de b7       	in	r29, 0x3e	; 62
    8484:	c8 54       	subi	r28, 0x48	; 72
    8486:	d1 09       	sbc	r29, r1
    8488:	0f b6       	in	r0, 0x3f	; 63
    848a:	f8 94       	cli
    848c:	de bf       	out	0x3e, r29	; 62
    848e:	0f be       	out	0x3f, r0	; 63
    8490:	cd bf       	out	0x3d, r28	; 61
    8492:	27 96       	adiw	r28, 0x07	; 7
    8494:	9f af       	std	Y+63, r25	; 0x3f
    8496:	8e af       	std	Y+62, r24	; 0x3e
    8498:	27 97       	sbiw	r28, 0x07	; 7
	
	/**
	* Formulas from page 7 on MS5611-01BA03.pdf
	*/
	int64_t rawPress = rawPressure;
    849a:	fc 01       	movw	r30, r24
    849c:	86 81       	ldd	r24, Z+6	; 0x06
    849e:	97 81       	ldd	r25, Z+7	; 0x07
    84a0:	a0 85       	ldd	r26, Z+8	; 0x08
    84a2:	b1 85       	ldd	r27, Z+9	; 0x09
    84a4:	8c 01       	movw	r16, r24
    84a6:	9d 01       	movw	r18, r26
    84a8:	40 e0       	ldi	r20, 0x00	; 0
    84aa:	50 e0       	ldi	r21, 0x00	; 0
    84ac:	ba 01       	movw	r22, r20
    84ae:	8e 87       	std	Y+14, r24	; 0x0e
    84b0:	1f 87       	std	Y+15, r17	; 0x0f
    84b2:	28 8b       	std	Y+16, r18	; 0x10
    84b4:	39 8b       	std	Y+17, r19	; 0x11
    84b6:	4a 8b       	std	Y+18, r20	; 0x12
    84b8:	5b 8b       	std	Y+19, r21	; 0x13
    84ba:	6c 8b       	std	Y+20, r22	; 0x14
    84bc:	7d 8b       	std	Y+21, r23	; 0x15
	int64_t rawTemp = rawTemperature;
    84be:	82 80       	ldd	r8, Z+2	; 0x02
    84c0:	93 80       	ldd	r9, Z+3	; 0x03
    84c2:	a4 80       	ldd	r10, Z+4	; 0x04
    84c4:	b5 80       	ldd	r11, Z+5	; 0x05

	//I use the shift operators instead of division. (I.e. << 8 = dividing by 2^8).
	int64_t tempDifference = rawTemp - (referenceTemperature_Tref_C5 << 8);
    84c6:	22 a9       	ldd	r18, Z+50	; 0x32
    84c8:	33 a9       	ldd	r19, Z+51	; 0x33
    84ca:	44 a9       	ldd	r20, Z+52	; 0x34
    84cc:	55 a9       	ldd	r21, Z+53	; 0x35
    84ce:	66 a9       	ldd	r22, Z+54	; 0x36
    84d0:	77 a9       	ldd	r23, Z+55	; 0x37
    84d2:	80 ad       	ldd	r24, Z+56	; 0x38
    84d4:	91 ad       	ldd	r25, Z+57	; 0x39
    84d6:	08 e0       	ldi	r16, 0x08	; 8
    84d8:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    84dc:	62 2e       	mov	r6, r18
    84de:	73 2e       	mov	r7, r19
    84e0:	b4 2f       	mov	r27, r20
    84e2:	a5 2f       	mov	r26, r21
    84e4:	f6 2f       	mov	r31, r22
    84e6:	e7 2f       	mov	r30, r23
    84e8:	08 2f       	mov	r16, r24
    84ea:	19 2f       	mov	r17, r25
    84ec:	28 2d       	mov	r18, r8
    84ee:	39 2d       	mov	r19, r9
    84f0:	4a 2d       	mov	r20, r10
    84f2:	5b 2d       	mov	r21, r11
    84f4:	60 e0       	ldi	r22, 0x00	; 0
    84f6:	70 e0       	ldi	r23, 0x00	; 0
    84f8:	80 e0       	ldi	r24, 0x00	; 0
    84fa:	90 e0       	ldi	r25, 0x00	; 0
    84fc:	a6 2c       	mov	r10, r6
    84fe:	b7 2c       	mov	r11, r7
    8500:	cb 2e       	mov	r12, r27
    8502:	da 2e       	mov	r13, r26
    8504:	ef 2e       	mov	r14, r31
    8506:	fe 2e       	mov	r15, r30
    8508:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    850c:	32 2e       	mov	r3, r18
    850e:	23 2e       	mov	r2, r19
    8510:	49 83       	std	Y+1, r20	; 0x01
    8512:	5a 83       	std	Y+2, r21	; 0x02
    8514:	6b 83       	std	Y+3, r22	; 0x03
    8516:	77 2e       	mov	r7, r23
    8518:	88 2e       	mov	r8, r24
    851a:	99 2e       	mov	r9, r25
	int64_t temp = 2000 + ((tempDifference * temperatureCoefficientOfTheTemperature_TEMPSENS_C6) >> 23);
    851c:	27 96       	adiw	r28, 0x07	; 7
    851e:	ee ad       	ldd	r30, Y+62	; 0x3e
    8520:	ff ad       	ldd	r31, Y+63	; 0x3f
    8522:	27 97       	sbiw	r28, 0x07	; 7
    8524:	fa 96       	adiw	r30, 0x3a	; 58
    8526:	27 96       	adiw	r28, 0x07	; 7
    8528:	ae ad       	ldd	r26, Y+62	; 0x3e
    852a:	bf ad       	ldd	r27, Y+63	; 0x3f
    852c:	27 97       	sbiw	r28, 0x07	; 7
    852e:	da 96       	adiw	r26, 0x3a	; 58
    8530:	ac 90       	ld	r10, X
    8532:	b1 80       	ldd	r11, Z+1	; 0x01
    8534:	c2 80       	ldd	r12, Z+2	; 0x02
    8536:	d3 80       	ldd	r13, Z+3	; 0x03
    8538:	e4 80       	ldd	r14, Z+4	; 0x04
    853a:	f5 80       	ldd	r15, Z+5	; 0x05
    853c:	06 81       	ldd	r16, Z+6	; 0x06
    853e:	17 81       	ldd	r17, Z+7	; 0x07
    8540:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    8544:	07 e1       	ldi	r16, 0x17	; 23
    8546:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    854a:	2a 8f       	std	Y+26, r18	; 0x1a
    854c:	3b 8f       	std	Y+27, r19	; 0x1b
    854e:	4c 8f       	std	Y+28, r20	; 0x1c
    8550:	5d 8f       	std	Y+29, r21	; 0x1d
    8552:	6e 8f       	std	Y+30, r22	; 0x1e
    8554:	7f 8f       	std	Y+31, r23	; 0x1f
    8556:	88 a3       	std	Y+32, r24	; 0x20
    8558:	99 a3       	std	Y+33, r25	; 0x21
    855a:	20 53       	subi	r18, 0x30	; 48
    855c:	38 4f       	sbci	r19, 0xF8	; 248
    855e:	4f 4f       	sbci	r20, 0xFF	; 255
    8560:	5f 4f       	sbci	r21, 0xFF	; 255
    8562:	6f 4f       	sbci	r22, 0xFF	; 255
    8564:	7f 4f       	sbci	r23, 0xFF	; 255
    8566:	8f 4f       	sbci	r24, 0xFF	; 255
    8568:	9f 4f       	sbci	r25, 0xFF	; 255
    856a:	2e 8b       	std	Y+22, r18	; 0x16
    856c:	3f 8b       	std	Y+23, r19	; 0x17
    856e:	48 8f       	std	Y+24, r20	; 0x18
    8570:	59 8f       	std	Y+25, r21	; 0x19
    8572:	6a a3       	std	Y+34, r22	; 0x22
    8574:	7b a3       	std	Y+35, r23	; 0x23
    8576:	8c a3       	std	Y+36, r24	; 0x24
    8578:	9d a3       	std	Y+37, r25	; 0x25
	int64_t tempOffset = (pressureSensitivityOffset_OFFt1_C2 << 16) + ((temperatureCoefficientOfPressureOffset_TCO_C4 * tempDifference) >> 7);
    857a:	27 96       	adiw	r28, 0x07	; 7
    857c:	ee ad       	ldd	r30, Y+62	; 0x3e
    857e:	ff ad       	ldd	r31, Y+63	; 0x3f
    8580:	27 97       	sbiw	r28, 0x07	; 7
    8582:	22 8d       	ldd	r18, Z+26	; 0x1a
    8584:	33 8d       	ldd	r19, Z+27	; 0x1b
    8586:	44 8d       	ldd	r20, Z+28	; 0x1c
    8588:	55 8d       	ldd	r21, Z+29	; 0x1d
    858a:	66 8d       	ldd	r22, Z+30	; 0x1e
    858c:	77 8d       	ldd	r23, Z+31	; 0x1f
    858e:	80 a1       	ldd	r24, Z+32	; 0x20
    8590:	91 a1       	ldd	r25, Z+33	; 0x21
    8592:	00 e1       	ldi	r16, 0x10	; 16
    8594:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    8598:	2c 83       	std	Y+4, r18	; 0x04
    859a:	3d 83       	std	Y+5, r19	; 0x05
    859c:	4e 83       	std	Y+6, r20	; 0x06
    859e:	5f 83       	std	Y+7, r21	; 0x07
    85a0:	68 87       	std	Y+8, r22	; 0x08
    85a2:	67 2e       	mov	r6, r23
    85a4:	58 2e       	mov	r5, r24
    85a6:	49 2e       	mov	r4, r25
    85a8:	a2 a4       	ldd	r10, Z+42	; 0x2a
    85aa:	b3 a4       	ldd	r11, Z+43	; 0x2b
    85ac:	c4 a4       	ldd	r12, Z+44	; 0x2c
    85ae:	d5 a4       	ldd	r13, Z+45	; 0x2d
    85b0:	e6 a4       	ldd	r14, Z+46	; 0x2e
    85b2:	f7 a4       	ldd	r15, Z+47	; 0x2f
    85b4:	00 a9       	ldd	r16, Z+48	; 0x30
    85b6:	11 a9       	ldd	r17, Z+49	; 0x31
    85b8:	23 2d       	mov	r18, r3
    85ba:	32 2d       	mov	r19, r2
    85bc:	49 81       	ldd	r20, Y+1	; 0x01
    85be:	5a 81       	ldd	r21, Y+2	; 0x02
    85c0:	6b 81       	ldd	r22, Y+3	; 0x03
    85c2:	77 2d       	mov	r23, r7
    85c4:	88 2d       	mov	r24, r8
    85c6:	99 2d       	mov	r25, r9
    85c8:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    85cc:	07 e0       	ldi	r16, 0x07	; 7
    85ce:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    85d2:	a2 2e       	mov	r10, r18
    85d4:	b3 2e       	mov	r11, r19
    85d6:	c4 2e       	mov	r12, r20
    85d8:	d5 2e       	mov	r13, r21
    85da:	e6 2e       	mov	r14, r22
    85dc:	f7 2e       	mov	r15, r23
    85de:	08 2f       	mov	r16, r24
    85e0:	19 2f       	mov	r17, r25
    85e2:	2c 81       	ldd	r18, Y+4	; 0x04
    85e4:	3d 81       	ldd	r19, Y+5	; 0x05
    85e6:	4e 81       	ldd	r20, Y+6	; 0x06
    85e8:	5f 81       	ldd	r21, Y+7	; 0x07
    85ea:	68 85       	ldd	r22, Y+8	; 0x08
    85ec:	76 2d       	mov	r23, r6
    85ee:	85 2d       	mov	r24, r5
    85f0:	94 2d       	mov	r25, r4
    85f2:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    85f6:	2c 83       	std	Y+4, r18	; 0x04
    85f8:	3d 83       	std	Y+5, r19	; 0x05
    85fa:	4e 83       	std	Y+6, r20	; 0x06
    85fc:	5f 83       	std	Y+7, r21	; 0x07
    85fe:	68 87       	std	Y+8, r22	; 0x08
    8600:	7e a3       	std	Y+38, r23	; 0x26
    8602:	8f a3       	std	Y+39, r24	; 0x27
    8604:	98 a7       	std	Y+40, r25	; 0x28
	int64_t sensitivityAtTemp = (pressureSensitivity_SENSt1_C1 << 15) + ((temperatureCoefficientOfPressureSensitivity_TCS_C3 * tempDifference) >> 8);
    8606:	27 96       	adiw	r28, 0x07	; 7
    8608:	ae ad       	ldd	r26, Y+62	; 0x3e
    860a:	bf ad       	ldd	r27, Y+63	; 0x3f
    860c:	27 97       	sbiw	r28, 0x07	; 7
    860e:	52 96       	adiw	r26, 0x12	; 18
    8610:	2c 91       	ld	r18, X
    8612:	52 97       	sbiw	r26, 0x12	; 18
    8614:	53 96       	adiw	r26, 0x13	; 19
    8616:	3c 91       	ld	r19, X
    8618:	53 97       	sbiw	r26, 0x13	; 19
    861a:	54 96       	adiw	r26, 0x14	; 20
    861c:	4c 91       	ld	r20, X
    861e:	54 97       	sbiw	r26, 0x14	; 20
    8620:	55 96       	adiw	r26, 0x15	; 21
    8622:	5c 91       	ld	r21, X
    8624:	55 97       	sbiw	r26, 0x15	; 21
    8626:	56 96       	adiw	r26, 0x16	; 22
    8628:	6c 91       	ld	r22, X
    862a:	56 97       	sbiw	r26, 0x16	; 22
    862c:	57 96       	adiw	r26, 0x17	; 23
    862e:	7c 91       	ld	r23, X
    8630:	57 97       	sbiw	r26, 0x17	; 23
    8632:	58 96       	adiw	r26, 0x18	; 24
    8634:	8c 91       	ld	r24, X
    8636:	58 97       	sbiw	r26, 0x18	; 24
    8638:	59 96       	adiw	r26, 0x19	; 25
    863a:	9c 91       	ld	r25, X
    863c:	59 97       	sbiw	r26, 0x19	; 25
    863e:	0f e0       	ldi	r16, 0x0F	; 15
    8640:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    8644:	29 87       	std	Y+9, r18	; 0x09
    8646:	3a 87       	std	Y+10, r19	; 0x0a
    8648:	4b 87       	std	Y+11, r20	; 0x0b
    864a:	5c 87       	std	Y+12, r21	; 0x0c
    864c:	6d 87       	std	Y+13, r22	; 0x0d
    864e:	67 2e       	mov	r6, r23
    8650:	58 2e       	mov	r5, r24
    8652:	49 2e       	mov	r4, r25
    8654:	92 96       	adiw	r26, 0x22	; 34
    8656:	ac 90       	ld	r10, X
    8658:	92 97       	sbiw	r26, 0x22	; 34
    865a:	93 96       	adiw	r26, 0x23	; 35
    865c:	bc 90       	ld	r11, X
    865e:	93 97       	sbiw	r26, 0x23	; 35
    8660:	94 96       	adiw	r26, 0x24	; 36
    8662:	cc 90       	ld	r12, X
    8664:	94 97       	sbiw	r26, 0x24	; 36
    8666:	95 96       	adiw	r26, 0x25	; 37
    8668:	dc 90       	ld	r13, X
    866a:	95 97       	sbiw	r26, 0x25	; 37
    866c:	96 96       	adiw	r26, 0x26	; 38
    866e:	ec 90       	ld	r14, X
    8670:	96 97       	sbiw	r26, 0x26	; 38
    8672:	97 96       	adiw	r26, 0x27	; 39
    8674:	fc 90       	ld	r15, X
    8676:	97 97       	sbiw	r26, 0x27	; 39
    8678:	98 96       	adiw	r26, 0x28	; 40
    867a:	0c 91       	ld	r16, X
    867c:	98 97       	sbiw	r26, 0x28	; 40
    867e:	99 96       	adiw	r26, 0x29	; 41
    8680:	1c 91       	ld	r17, X
    8682:	23 2d       	mov	r18, r3
    8684:	32 2d       	mov	r19, r2
    8686:	49 81       	ldd	r20, Y+1	; 0x01
    8688:	5a 81       	ldd	r21, Y+2	; 0x02
    868a:	6b 81       	ldd	r22, Y+3	; 0x03
    868c:	77 2d       	mov	r23, r7
    868e:	88 2d       	mov	r24, r8
    8690:	99 2d       	mov	r25, r9
    8692:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    8696:	08 e0       	ldi	r16, 0x08	; 8
    8698:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    869c:	a2 2e       	mov	r10, r18
    869e:	b3 2e       	mov	r11, r19
    86a0:	c4 2e       	mov	r12, r20
    86a2:	d5 2e       	mov	r13, r21
    86a4:	e6 2e       	mov	r14, r22
    86a6:	f7 2e       	mov	r15, r23
    86a8:	08 2f       	mov	r16, r24
    86aa:	19 2f       	mov	r17, r25
    86ac:	29 85       	ldd	r18, Y+9	; 0x09
    86ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    86b0:	4b 85       	ldd	r20, Y+11	; 0x0b
    86b2:	5c 85       	ldd	r21, Y+12	; 0x0c
    86b4:	6d 85       	ldd	r22, Y+13	; 0x0d
    86b6:	76 2d       	mov	r23, r6
    86b8:	85 2d       	mov	r24, r5
    86ba:	94 2d       	mov	r25, r4
    86bc:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    86c0:	29 87       	std	Y+9, r18	; 0x09
    86c2:	3a 87       	std	Y+10, r19	; 0x0a
    86c4:	4b 87       	std	Y+11, r20	; 0x0b
    86c6:	5c 87       	std	Y+12, r21	; 0x0c
    86c8:	6d 87       	std	Y+13, r22	; 0x0d
    86ca:	47 2e       	mov	r4, r23
    86cc:	68 2e       	mov	r6, r24
    86ce:	59 2e       	mov	r5, r25
		
	/**
	 * The sensor's accuracy drops off when the temp is below 20*C. So the following is
	 * code to compensate for temperature below 20*C. 
	 */
	if (temp < 2000)
    86d0:	2e 89       	ldd	r18, Y+22	; 0x16
    86d2:	3f 89       	ldd	r19, Y+23	; 0x17
    86d4:	48 8d       	ldd	r20, Y+24	; 0x18
    86d6:	59 8d       	ldd	r21, Y+25	; 0x19
    86d8:	6a a1       	ldd	r22, Y+34	; 0x22
    86da:	7b a1       	ldd	r23, Y+35	; 0x23
    86dc:	8c a1       	ldd	r24, Y+36	; 0x24
    86de:	9d a1       	ldd	r25, Y+37	; 0x25
    86e0:	2f 3c       	cpi	r18, 0xCF	; 207
    86e2:	37 40       	sbci	r19, 0x07	; 7
    86e4:	41 05       	cpc	r20, r1
    86e6:	51 05       	cpc	r21, r1
    86e8:	61 05       	cpc	r22, r1
    86ea:	71 05       	cpc	r23, r1
    86ec:	81 05       	cpc	r24, r1
    86ee:	91 05       	cpc	r25, r1
    86f0:	11 f0       	breq	.+4      	; 0x86f6 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    86f2:	0c f0       	brlt	.+2      	; 0x86f6 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    86f4:	75 c1       	rjmp	.+746    	; 0x89e0 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x584>
	{
		int64_t temp2 = (tempDifference * tempDifference) >> 31;
    86f6:	a3 2c       	mov	r10, r3
    86f8:	b2 2c       	mov	r11, r2
    86fa:	c9 80       	ldd	r12, Y+1	; 0x01
    86fc:	da 80       	ldd	r13, Y+2	; 0x02
    86fe:	eb 80       	ldd	r14, Y+3	; 0x03
    8700:	f7 2c       	mov	r15, r7
    8702:	08 2d       	mov	r16, r8
    8704:	19 2d       	mov	r17, r9
    8706:	23 2d       	mov	r18, r3
    8708:	32 2d       	mov	r19, r2
    870a:	4c 2d       	mov	r20, r12
    870c:	5d 2d       	mov	r21, r13
    870e:	6e 2d       	mov	r22, r14
    8710:	77 2d       	mov	r23, r7
    8712:	88 2d       	mov	r24, r8
    8714:	99 2d       	mov	r25, r9
    8716:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    871a:	0f e1       	ldi	r16, 0x1F	; 31
    871c:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    8720:	2d af       	std	Y+61, r18	; 0x3d
    8722:	3e af       	std	Y+62, r19	; 0x3e
    8724:	4f af       	std	Y+63, r20	; 0x3f
    8726:	21 96       	adiw	r28, 0x01	; 1
    8728:	5f af       	std	Y+63, r21	; 0x3f
    872a:	21 97       	sbiw	r28, 0x01	; 1
    872c:	22 96       	adiw	r28, 0x02	; 2
    872e:	6f af       	std	Y+63, r22	; 0x3f
    8730:	22 97       	sbiw	r28, 0x02	; 2
    8732:	23 96       	adiw	r28, 0x03	; 3
    8734:	7f af       	std	Y+63, r23	; 0x3f
    8736:	23 97       	sbiw	r28, 0x03	; 3
    8738:	24 96       	adiw	r28, 0x04	; 4
    873a:	8f af       	std	Y+63, r24	; 0x3f
    873c:	24 97       	sbiw	r28, 0x04	; 4
    873e:	25 96       	adiw	r28, 0x05	; 5
    8740:	9f af       	std	Y+63, r25	; 0x3f
    8742:	25 97       	sbiw	r28, 0x05	; 5
		
		int64_t temporaryValue = (temp - 2000);
		temporaryValue *= temporaryValue;
    8744:	aa 8c       	ldd	r10, Y+26	; 0x1a
    8746:	bb 8c       	ldd	r11, Y+27	; 0x1b
    8748:	cc 8c       	ldd	r12, Y+28	; 0x1c
    874a:	dd 8c       	ldd	r13, Y+29	; 0x1d
    874c:	ee 8c       	ldd	r14, Y+30	; 0x1e
    874e:	ff 8c       	ldd	r15, Y+31	; 0x1f
    8750:	08 a1       	ldd	r16, Y+32	; 0x20
    8752:	19 a1       	ldd	r17, Y+33	; 0x21
    8754:	2a 2d       	mov	r18, r10
    8756:	3b 2d       	mov	r19, r11
    8758:	4c 2d       	mov	r20, r12
    875a:	5d 2d       	mov	r21, r13
    875c:	6e 2d       	mov	r22, r14
    875e:	7f 2d       	mov	r23, r15
    8760:	80 2f       	mov	r24, r16
    8762:	91 2f       	mov	r25, r17
    8764:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    8768:	2e ab       	std	Y+54, r18	; 0x36
    876a:	a3 2f       	mov	r26, r19
    876c:	b4 2f       	mov	r27, r20
    876e:	25 2e       	mov	r2, r21
    8770:	36 2e       	mov	r3, r22
    8772:	97 2e       	mov	r9, r23
    8774:	88 2e       	mov	r8, r24
    8776:	79 2e       	mov	r7, r25
		
		int64_t tempOffset2 = 5 * (temporaryValue >> 1);
    8778:	4b 2f       	mov	r20, r27
    877a:	52 2d       	mov	r21, r2
    877c:	63 2d       	mov	r22, r3
    877e:	79 2d       	mov	r23, r9
    8780:	88 2d       	mov	r24, r8
    8782:	97 2d       	mov	r25, r7
    8784:	01 e0       	ldi	r16, 0x01	; 1
    8786:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    878a:	a2 2e       	mov	r10, r18
    878c:	b3 2e       	mov	r11, r19
    878e:	c4 2e       	mov	r12, r20
    8790:	d5 2e       	mov	r13, r21
    8792:	e6 2e       	mov	r14, r22
    8794:	f7 2e       	mov	r15, r23
    8796:	f8 2f       	mov	r31, r24
    8798:	19 2f       	mov	r17, r25
    879a:	02 e0       	ldi	r16, 0x02	; 2
    879c:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    87a0:	0f 2f       	mov	r16, r31
    87a2:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    87a6:	2e a7       	std	Y+46, r18	; 0x2e
    87a8:	3f a7       	std	Y+47, r19	; 0x2f
    87aa:	48 ab       	std	Y+48, r20	; 0x30
    87ac:	59 ab       	std	Y+49, r21	; 0x31
    87ae:	6a ab       	std	Y+50, r22	; 0x32
    87b0:	7b ab       	std	Y+51, r23	; 0x33
    87b2:	8c ab       	std	Y+52, r24	; 0x34
    87b4:	9d ab       	std	Y+53, r25	; 0x35
    87b6:	29 83       	std	Y+1, r18	; 0x01
    87b8:	3a 83       	std	Y+2, r19	; 0x02
    87ba:	4b 83       	std	Y+3, r20	; 0x03
    87bc:	59 a7       	std	Y+41, r21	; 0x29
    87be:	6a a7       	std	Y+42, r22	; 0x2a
    87c0:	7b a7       	std	Y+43, r23	; 0x2b
    87c2:	8c a7       	std	Y+44, r24	; 0x2c
    87c4:	9d a7       	std	Y+45, r25	; 0x2d
		int64_t sensitivity2 = 5 * (temporaryValue >> 2);	
    87c6:	2e a9       	ldd	r18, Y+54	; 0x36
    87c8:	3a 2f       	mov	r19, r26
    87ca:	4b 2f       	mov	r20, r27
    87cc:	52 2d       	mov	r21, r2
    87ce:	63 2d       	mov	r22, r3
    87d0:	79 2d       	mov	r23, r9
    87d2:	88 2d       	mov	r24, r8
    87d4:	97 2d       	mov	r25, r7
    87d6:	02 e0       	ldi	r16, 0x02	; 2
    87d8:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    87dc:	a2 2e       	mov	r10, r18
    87de:	b3 2e       	mov	r11, r19
    87e0:	c4 2e       	mov	r12, r20
    87e2:	d5 2e       	mov	r13, r21
    87e4:	e6 2e       	mov	r14, r22
    87e6:	f7 2e       	mov	r15, r23
    87e8:	e8 2f       	mov	r30, r24
    87ea:	19 2f       	mov	r17, r25
    87ec:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    87f0:	0e 2f       	mov	r16, r30
    87f2:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    87f6:	72 2e       	mov	r7, r18
    87f8:	3e ab       	std	Y+54, r19	; 0x36
    87fa:	4f ab       	std	Y+55, r20	; 0x37
    87fc:	58 af       	std	Y+56, r21	; 0x38
    87fe:	69 af       	std	Y+57, r22	; 0x39
    8800:	7a af       	std	Y+58, r23	; 0x3a
    8802:	8b af       	std	Y+59, r24	; 0x3b
    8804:	9c af       	std	Y+60, r25	; 0x3c
    8806:	92 2e       	mov	r9, r18
    8808:	83 2e       	mov	r8, r19
    880a:	b4 2f       	mov	r27, r20
    880c:	25 2e       	mov	r2, r21
    880e:	36 2e       	mov	r3, r22
    8810:	a7 2f       	mov	r26, r23
    8812:	28 96       	adiw	r28, 0x08	; 8
    8814:	8f af       	std	Y+63, r24	; 0x3f
    8816:	28 97       	sbiw	r28, 0x08	; 8
    8818:	f9 2f       	mov	r31, r25
							
		//Temperature correction code for below 15*c
		if (temp < -1500)
    881a:	2e 89       	ldd	r18, Y+22	; 0x16
    881c:	3f 89       	ldd	r19, Y+23	; 0x17
    881e:	48 8d       	ldd	r20, Y+24	; 0x18
    8820:	59 8d       	ldd	r21, Y+25	; 0x19
    8822:	6a a1       	ldd	r22, Y+34	; 0x22
    8824:	7b a1       	ldd	r23, Y+35	; 0x23
    8826:	8c a1       	ldd	r24, Y+36	; 0x24
    8828:	9d a1       	ldd	r25, Y+37	; 0x25
    882a:	24 32       	cpi	r18, 0x24	; 36
    882c:	3a 4f       	sbci	r19, 0xFA	; 250
    882e:	4f 4f       	sbci	r20, 0xFF	; 255
    8830:	5f 4f       	sbci	r21, 0xFF	; 255
    8832:	6f 4f       	sbci	r22, 0xFF	; 255
    8834:	7f 4f       	sbci	r23, 0xFF	; 255
    8836:	8f 4f       	sbci	r24, 0xFF	; 255
    8838:	9f 4f       	sbci	r25, 0xFF	; 255
    883a:	0c f0       	brlt	.+2      	; 0x883e <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x3e2>
    883c:	7b c0       	rjmp	.+246    	; 0x8934 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x4d8>
		{
			int64_t temporaryValue2 = temp + 1500;
    883e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    8840:	3b 8d       	ldd	r19, Y+27	; 0x1b
    8842:	4c 8d       	ldd	r20, Y+28	; 0x1c
    8844:	5d 8d       	ldd	r21, Y+29	; 0x1d
    8846:	6e 8d       	ldd	r22, Y+30	; 0x1e
    8848:	7f 8d       	ldd	r23, Y+31	; 0x1f
    884a:	88 a1       	ldd	r24, Y+32	; 0x20
    884c:	99 a1       	ldd	r25, Y+33	; 0x21
    884e:	24 55       	subi	r18, 0x54	; 84
    8850:	32 4f       	sbci	r19, 0xF2	; 242
    8852:	4f 4f       	sbci	r20, 0xFF	; 255
    8854:	5f 4f       	sbci	r21, 0xFF	; 255
    8856:	6f 4f       	sbci	r22, 0xFF	; 255
    8858:	7f 4f       	sbci	r23, 0xFF	; 255
    885a:	8f 4f       	sbci	r24, 0xFF	; 255
    885c:	9f 4f       	sbci	r25, 0xFF	; 255
			temporaryValue2 *= temporaryValue2;
    885e:	a2 2e       	mov	r10, r18
    8860:	b3 2e       	mov	r11, r19
    8862:	c4 2e       	mov	r12, r20
    8864:	d5 2e       	mov	r13, r21
    8866:	e6 2e       	mov	r14, r22
    8868:	f7 2e       	mov	r15, r23
    886a:	08 2f       	mov	r16, r24
    886c:	19 2f       	mov	r17, r25
    886e:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    8872:	b2 2f       	mov	r27, r18
    8874:	a3 2f       	mov	r26, r19
    8876:	e4 2f       	mov	r30, r20
    8878:	f5 2f       	mov	r31, r21
    887a:	26 2e       	mov	r2, r22
    887c:	37 2e       	mov	r3, r23
    887e:	98 2e       	mov	r9, r24
    8880:	89 2e       	mov	r8, r25
			
			tempOffset2 = tempOffset2 + 7 * temporaryValue2;
    8882:	03 e0       	ldi	r16, 0x03	; 3
    8884:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    8888:	ab 2e       	mov	r10, r27
    888a:	ba 2e       	mov	r11, r26
    888c:	ce 2e       	mov	r12, r30
    888e:	df 2e       	mov	r13, r31
    8890:	e2 2c       	mov	r14, r2
    8892:	f3 2c       	mov	r15, r3
    8894:	09 2d       	mov	r16, r9
    8896:	18 2d       	mov	r17, r8
    8898:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    889c:	ae a4       	ldd	r10, Y+46	; 0x2e
    889e:	bf a4       	ldd	r11, Y+47	; 0x2f
    88a0:	c8 a8       	ldd	r12, Y+48	; 0x30
    88a2:	d9 a8       	ldd	r13, Y+49	; 0x31
    88a4:	ea a8       	ldd	r14, Y+50	; 0x32
    88a6:	fb a8       	ldd	r15, Y+51	; 0x33
    88a8:	0c a9       	ldd	r16, Y+52	; 0x34
    88aa:	1d a9       	ldd	r17, Y+53	; 0x35
    88ac:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    88b0:	29 83       	std	Y+1, r18	; 0x01
    88b2:	3a 83       	std	Y+2, r19	; 0x02
    88b4:	4b 83       	std	Y+3, r20	; 0x03
    88b6:	59 a7       	std	Y+41, r21	; 0x29
    88b8:	6a a7       	std	Y+42, r22	; 0x2a
    88ba:	7b a7       	std	Y+43, r23	; 0x2b
    88bc:	8c a7       	std	Y+44, r24	; 0x2c
    88be:	9d a7       	std	Y+45, r25	; 0x2d
			sensitivity2 = sensitivity2 + 11 * (temporaryValue2 >> 1);
    88c0:	2b 2f       	mov	r18, r27
    88c2:	3a 2f       	mov	r19, r26
    88c4:	4e 2f       	mov	r20, r30
    88c6:	5f 2f       	mov	r21, r31
    88c8:	62 2d       	mov	r22, r2
    88ca:	73 2d       	mov	r23, r3
    88cc:	89 2d       	mov	r24, r9
    88ce:	98 2d       	mov	r25, r8
    88d0:	01 e0       	ldi	r16, 0x01	; 1
    88d2:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    88d6:	b2 2f       	mov	r27, r18
    88d8:	a3 2f       	mov	r26, r19
    88da:	f4 2f       	mov	r31, r20
    88dc:	e5 2f       	mov	r30, r21
    88de:	26 2e       	mov	r2, r22
    88e0:	37 2e       	mov	r3, r23
    88e2:	98 2e       	mov	r9, r24
    88e4:	89 2e       	mov	r8, r25
    88e6:	02 e0       	ldi	r16, 0x02	; 2
    88e8:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    88ec:	ab 2e       	mov	r10, r27
    88ee:	ba 2e       	mov	r11, r26
    88f0:	cf 2e       	mov	r12, r31
    88f2:	de 2e       	mov	r13, r30
    88f4:	e2 2c       	mov	r14, r2
    88f6:	f3 2c       	mov	r15, r3
    88f8:	09 2d       	mov	r16, r9
    88fa:	18 2d       	mov	r17, r8
    88fc:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    8900:	02 e0       	ldi	r16, 0x02	; 2
    8902:	0e 94 3b 6c 	call	0xd876	; 0xd876 <__ashldi3>
    8906:	09 2d       	mov	r16, r9
    8908:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    890c:	a7 2c       	mov	r10, r7
    890e:	be a8       	ldd	r11, Y+54	; 0x36
    8910:	cf a8       	ldd	r12, Y+55	; 0x37
    8912:	d8 ac       	ldd	r13, Y+56	; 0x38
    8914:	e9 ac       	ldd	r14, Y+57	; 0x39
    8916:	fa ac       	ldd	r15, Y+58	; 0x3a
    8918:	0b ad       	ldd	r16, Y+59	; 0x3b
    891a:	1c ad       	ldd	r17, Y+60	; 0x3c
    891c:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__adddi3>
    8920:	92 2e       	mov	r9, r18
    8922:	83 2e       	mov	r8, r19
    8924:	b4 2f       	mov	r27, r20
    8926:	25 2e       	mov	r2, r21
    8928:	36 2e       	mov	r3, r22
    892a:	a7 2f       	mov	r26, r23
    892c:	28 96       	adiw	r28, 0x08	; 8
    892e:	8f af       	std	Y+63, r24	; 0x3f
    8930:	28 97       	sbiw	r28, 0x08	; 8
    8932:	f9 2f       	mov	r31, r25
		}
		
				
		temp = temp - temp2;
    8934:	2e 89       	ldd	r18, Y+22	; 0x16
    8936:	3f 89       	ldd	r19, Y+23	; 0x17
    8938:	48 8d       	ldd	r20, Y+24	; 0x18
    893a:	59 8d       	ldd	r21, Y+25	; 0x19
    893c:	6a a1       	ldd	r22, Y+34	; 0x22
    893e:	7b a1       	ldd	r23, Y+35	; 0x23
    8940:	8c a1       	ldd	r24, Y+36	; 0x24
    8942:	9d a1       	ldd	r25, Y+37	; 0x25
    8944:	ad ac       	ldd	r10, Y+61	; 0x3d
    8946:	be ac       	ldd	r11, Y+62	; 0x3e
    8948:	cf ac       	ldd	r12, Y+63	; 0x3f
    894a:	21 96       	adiw	r28, 0x01	; 1
    894c:	df ac       	ldd	r13, Y+63	; 0x3f
    894e:	21 97       	sbiw	r28, 0x01	; 1
    8950:	22 96       	adiw	r28, 0x02	; 2
    8952:	ef ac       	ldd	r14, Y+63	; 0x3f
    8954:	22 97       	sbiw	r28, 0x02	; 2
    8956:	23 96       	adiw	r28, 0x03	; 3
    8958:	ff ac       	ldd	r15, Y+63	; 0x3f
    895a:	23 97       	sbiw	r28, 0x03	; 3
    895c:	24 96       	adiw	r28, 0x04	; 4
    895e:	0f ad       	ldd	r16, Y+63	; 0x3f
    8960:	24 97       	sbiw	r28, 0x04	; 4
    8962:	25 96       	adiw	r28, 0x05	; 5
    8964:	1f ad       	ldd	r17, Y+63	; 0x3f
    8966:	25 97       	sbiw	r28, 0x05	; 5
    8968:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    896c:	2e 8b       	std	Y+22, r18	; 0x16
    896e:	3f 8b       	std	Y+23, r19	; 0x17
    8970:	48 8f       	std	Y+24, r20	; 0x18
    8972:	59 8f       	std	Y+25, r21	; 0x19
		tempOffset = tempOffset - tempOffset2;
    8974:	2c 81       	ldd	r18, Y+4	; 0x04
    8976:	3d 81       	ldd	r19, Y+5	; 0x05
    8978:	4e 81       	ldd	r20, Y+6	; 0x06
    897a:	5f 81       	ldd	r21, Y+7	; 0x07
    897c:	68 85       	ldd	r22, Y+8	; 0x08
    897e:	7e a1       	ldd	r23, Y+38	; 0x26
    8980:	8f a1       	ldd	r24, Y+39	; 0x27
    8982:	98 a5       	ldd	r25, Y+40	; 0x28
    8984:	a9 80       	ldd	r10, Y+1	; 0x01
    8986:	ba 80       	ldd	r11, Y+2	; 0x02
    8988:	cb 80       	ldd	r12, Y+3	; 0x03
    898a:	d9 a4       	ldd	r13, Y+41	; 0x29
    898c:	ea a4       	ldd	r14, Y+42	; 0x2a
    898e:	fb a4       	ldd	r15, Y+43	; 0x2b
    8990:	0c a5       	ldd	r16, Y+44	; 0x2c
    8992:	1d a5       	ldd	r17, Y+45	; 0x2d
    8994:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    8998:	2c 83       	std	Y+4, r18	; 0x04
    899a:	3d 83       	std	Y+5, r19	; 0x05
    899c:	4e 83       	std	Y+6, r20	; 0x06
    899e:	5f 83       	std	Y+7, r21	; 0x07
    89a0:	68 87       	std	Y+8, r22	; 0x08
    89a2:	7e a3       	std	Y+38, r23	; 0x26
    89a4:	8f a3       	std	Y+39, r24	; 0x27
    89a6:	98 a7       	std	Y+40, r25	; 0x28
		sensitivityAtTemp = sensitivityAtTemp - sensitivity2;
    89a8:	29 85       	ldd	r18, Y+9	; 0x09
    89aa:	3a 85       	ldd	r19, Y+10	; 0x0a
    89ac:	4b 85       	ldd	r20, Y+11	; 0x0b
    89ae:	5c 85       	ldd	r21, Y+12	; 0x0c
    89b0:	6d 85       	ldd	r22, Y+13	; 0x0d
    89b2:	74 2d       	mov	r23, r4
    89b4:	86 2d       	mov	r24, r6
    89b6:	95 2d       	mov	r25, r5
    89b8:	a9 2c       	mov	r10, r9
    89ba:	b8 2c       	mov	r11, r8
    89bc:	cb 2e       	mov	r12, r27
    89be:	d2 2c       	mov	r13, r2
    89c0:	e3 2c       	mov	r14, r3
    89c2:	fa 2e       	mov	r15, r26
    89c4:	28 96       	adiw	r28, 0x08	; 8
    89c6:	0f ad       	ldd	r16, Y+63	; 0x3f
    89c8:	28 97       	sbiw	r28, 0x08	; 8
    89ca:	1f 2f       	mov	r17, r31
    89cc:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    89d0:	29 87       	std	Y+9, r18	; 0x09
    89d2:	3a 87       	std	Y+10, r19	; 0x0a
    89d4:	4b 87       	std	Y+11, r20	; 0x0b
    89d6:	5c 87       	std	Y+12, r21	; 0x0c
    89d8:	6d 87       	std	Y+13, r22	; 0x0d
    89da:	47 2e       	mov	r4, r23
    89dc:	68 2e       	mov	r6, r24
    89de:	59 2e       	mov	r5, r25
	}
	
	pressureMillibars = (((((rawPress * sensitivityAtTemp) >> 21) - tempOffset)) >> 15);
    89e0:	a9 84       	ldd	r10, Y+9	; 0x09
    89e2:	ba 84       	ldd	r11, Y+10	; 0x0a
    89e4:	cb 84       	ldd	r12, Y+11	; 0x0b
    89e6:	dc 84       	ldd	r13, Y+12	; 0x0c
    89e8:	ed 84       	ldd	r14, Y+13	; 0x0d
    89ea:	f4 2c       	mov	r15, r4
    89ec:	06 2d       	mov	r16, r6
    89ee:	15 2d       	mov	r17, r5
    89f0:	2e 85       	ldd	r18, Y+14	; 0x0e
    89f2:	3f 85       	ldd	r19, Y+15	; 0x0f
    89f4:	48 89       	ldd	r20, Y+16	; 0x10
    89f6:	59 89       	ldd	r21, Y+17	; 0x11
    89f8:	60 e0       	ldi	r22, 0x00	; 0
    89fa:	70 e0       	ldi	r23, 0x00	; 0
    89fc:	80 e0       	ldi	r24, 0x00	; 0
    89fe:	90 e0       	ldi	r25, 0x00	; 0
    8a00:	0e 94 de 6b 	call	0xd7bc	; 0xd7bc <__muldi3>
    8a04:	05 e1       	ldi	r16, 0x15	; 21
    8a06:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    8a0a:	ac 80       	ldd	r10, Y+4	; 0x04
    8a0c:	bd 80       	ldd	r11, Y+5	; 0x05
    8a0e:	ce 80       	ldd	r12, Y+6	; 0x06
    8a10:	df 80       	ldd	r13, Y+7	; 0x07
    8a12:	e8 84       	ldd	r14, Y+8	; 0x08
    8a14:	fe a0       	ldd	r15, Y+38	; 0x26
    8a16:	0f a1       	ldd	r16, Y+39	; 0x27
    8a18:	18 a5       	ldd	r17, Y+40	; 0x28
    8a1a:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <__subdi3>
    8a1e:	0f e0       	ldi	r16, 0x0F	; 15
    8a20:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <__ashrdi3>
    8a24:	27 96       	adiw	r28, 0x07	; 7
    8a26:	ae ad       	ldd	r26, Y+62	; 0x3e
    8a28:	bf ad       	ldd	r27, Y+63	; 0x3f
    8a2a:	27 97       	sbiw	r28, 0x07	; 7
    8a2c:	1e 96       	adiw	r26, 0x0e	; 14
    8a2e:	2c 93       	st	X, r18
    8a30:	1e 97       	sbiw	r26, 0x0e	; 14
    8a32:	1f 96       	adiw	r26, 0x0f	; 15
    8a34:	3c 93       	st	X, r19
    8a36:	1f 97       	sbiw	r26, 0x0f	; 15
    8a38:	50 96       	adiw	r26, 0x10	; 16
    8a3a:	4c 93       	st	X, r20
    8a3c:	50 97       	sbiw	r26, 0x10	; 16
    8a3e:	51 96       	adiw	r26, 0x11	; 17
    8a40:	5c 93       	st	X, r21
    8a42:	51 97       	sbiw	r26, 0x11	; 17
	temperatureCelcius = temp;
    8a44:	3e 89       	ldd	r19, Y+22	; 0x16
    8a46:	2f 89       	ldd	r18, Y+23	; 0x17
    8a48:	98 8d       	ldd	r25, Y+24	; 0x18
    8a4a:	89 8d       	ldd	r24, Y+25	; 0x19
    8a4c:	1a 96       	adiw	r26, 0x0a	; 10
    8a4e:	3c 93       	st	X, r19
    8a50:	1a 97       	sbiw	r26, 0x0a	; 10
    8a52:	1b 96       	adiw	r26, 0x0b	; 11
    8a54:	2c 93       	st	X, r18
    8a56:	1b 97       	sbiw	r26, 0x0b	; 11
    8a58:	1c 96       	adiw	r26, 0x0c	; 12
    8a5a:	9c 93       	st	X, r25
    8a5c:	1c 97       	sbiw	r26, 0x0c	; 12
    8a5e:	1d 96       	adiw	r26, 0x0d	; 13
    8a60:	8c 93       	st	X, r24
}
    8a62:	c8 5b       	subi	r28, 0xB8	; 184
    8a64:	df 4f       	sbci	r29, 0xFF	; 255
    8a66:	0f b6       	in	r0, 0x3f	; 63
    8a68:	f8 94       	cli
    8a6a:	de bf       	out	0x3e, r29	; 62
    8a6c:	0f be       	out	0x3f, r0	; 63
    8a6e:	cd bf       	out	0x3d, r28	; 61
    8a70:	df 91       	pop	r29
    8a72:	cf 91       	pop	r28
    8a74:	1f 91       	pop	r17
    8a76:	0f 91       	pop	r16
    8a78:	ff 90       	pop	r15
    8a7a:	ef 90       	pop	r14
    8a7c:	df 90       	pop	r13
    8a7e:	cf 90       	pop	r12
    8a80:	bf 90       	pop	r11
    8a82:	af 90       	pop	r10
    8a84:	9f 90       	pop	r9
    8a86:	8f 90       	pop	r8
    8a88:	7f 90       	pop	r7
    8a8a:	6f 90       	pop	r6
    8a8c:	5f 90       	pop	r5
    8a8e:	4f 90       	pop	r4
    8a90:	3f 90       	pop	r3
    8a92:	2f 90       	pop	r2
    8a94:	08 95       	ret

00008a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>:
	
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
    8a96:	af 92       	push	r10
    8a98:	bf 92       	push	r11
    8a9a:	cf 92       	push	r12
    8a9c:	df 92       	push	r13
    8a9e:	ef 92       	push	r14
    8aa0:	ff 92       	push	r15
    8aa2:	0f 93       	push	r16
    8aa4:	1f 93       	push	r17
    8aa6:	cf 93       	push	r28
    8aa8:	df 93       	push	r29
    8aaa:	1f 92       	push	r1
    8aac:	cd b7       	in	r28, 0x3d	; 61
    8aae:	de b7       	in	r29, 0x3e	; 62
    8ab0:	8c 01       	movw	r16, r24
	int status = 0;
	byte b = 0;
    8ab2:	19 82       	std	Y+1, r1	; 0x01
	
	unsigned long currentFourBytes = 0;
    8ab4:	c1 2c       	mov	r12, r1
    8ab6:	d1 2c       	mov	r13, r1
    8ab8:	76 01       	movw	r14, r12
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
	{
		status = serialDriver->receive(b);
    8aba:	d8 01       	movw	r26, r16
    8abc:	8d 91       	ld	r24, X+
    8abe:	9c 91       	ld	r25, X
    8ac0:	dc 01       	movw	r26, r24
    8ac2:	ed 91       	ld	r30, X+
    8ac4:	fc 91       	ld	r31, X
    8ac6:	02 88       	ldd	r0, Z+18	; 0x12
    8ac8:	f3 89       	ldd	r31, Z+19	; 0x13
    8aca:	e0 2d       	mov	r30, r0
    8acc:	be 01       	movw	r22, r28
    8ace:	6f 5f       	subi	r22, 0xFF	; 255
    8ad0:	7f 4f       	sbci	r23, 0xFF	; 255
    8ad2:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    8ad4:	fe 2c       	mov	r15, r14
    8ad6:	ed 2c       	mov	r14, r13
    8ad8:	dc 2c       	mov	r13, r12
    8ada:	cc 24       	eor	r12, r12
    8adc:	29 81       	ldd	r18, Y+1	; 0x01
    8ade:	c2 2a       	or	r12, r18
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
    8ae0:	00 97       	sbiw	r24, 0x00	; 0
    8ae2:	09 f0       	breq	.+2      	; 0x8ae6 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x50>
    8ae4:	54 c0       	rjmp	.+168    	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
    8ae6:	d7 01       	movw	r26, r14
    8ae8:	c6 01       	movw	r24, r12
    8aea:	95 50       	subi	r25, 0x05	; 5
    8aec:	a2 46       	sbci	r26, 0x62	; 98
    8aee:	b5 4b       	sbci	r27, 0xB5	; 181
    8af0:	02 97       	sbiw	r24, 0x02	; 2
    8af2:	a1 05       	cpc	r26, r1
    8af4:	b1 05       	cpc	r27, r1
    8af6:	08 f7       	brcc	.-62     	; 0x8aba <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x24>
    8af8:	36 c0       	rjmp	.+108    	; 0x8b66 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xd0>
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
		{
			status = serialDriver->receive(b);
    8afa:	f8 01       	movw	r30, r16
    8afc:	80 81       	ld	r24, Z
    8afe:	91 81       	ldd	r25, Z+1	; 0x01
    8b00:	dc 01       	movw	r26, r24
    8b02:	ed 91       	ld	r30, X+
    8b04:	fc 91       	ld	r31, X
    8b06:	02 88       	ldd	r0, Z+18	; 0x12
    8b08:	f3 89       	ldd	r31, Z+19	; 0x13
    8b0a:	e0 2d       	mov	r30, r0
    8b0c:	be 01       	movw	r22, r28
    8b0e:	6f 5f       	subi	r22, 0xFF	; 255
    8b10:	7f 4f       	sbci	r23, 0xFF	; 255
    8b12:	19 95       	eicall
    8b14:	9c 01       	movw	r18, r24
    8b16:	b1 e0       	ldi	r27, 0x01	; 1
    8b18:	ab 1a       	sub	r10, r27
    8b1a:	b1 08       	sbc	r11, r1
		ackNackData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
    8b1c:	a1 14       	cp	r10, r1
    8b1e:	b1 04       	cpc	r11, r1
    8b20:	29 f0       	breq	.+10     	; 0x8b2c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x96>
    8b22:	21 15       	cp	r18, r1
    8b24:	31 05       	cpc	r19, r1
    8b26:	49 f3       	breq	.-46     	; 0x8afa <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x64>
    8b28:	c9 01       	movw	r24, r18
    8b2a:	31 c0       	rjmp	.+98     	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
		
			ackNackData[i] = b;
		}
	}	
	
	if (status == 0 && currentFourBytes == ackHeaderID)
    8b2c:	21 15       	cp	r18, r1
    8b2e:	31 05       	cpc	r19, r1
    8b30:	91 f4       	brne	.+36     	; 0x8b56 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xc0>
    8b32:	e1 e0       	ldi	r30, 0x01	; 1
    8b34:	ce 16       	cp	r12, r30
    8b36:	e5 e0       	ldi	r30, 0x05	; 5
    8b38:	de 06       	cpc	r13, r30
    8b3a:	e2 e6       	ldi	r30, 0x62	; 98
    8b3c:	ee 06       	cpc	r14, r30
    8b3e:	e5 eb       	ldi	r30, 0xB5	; 181
    8b40:	fe 06       	cpc	r15, r30
    8b42:	59 f0       	breq	.+22     	; 0x8b5a <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xc4>
	{
		return 0;
	}else if (status == 0 && currentFourBytes == nackHeaderID)
    8b44:	c1 14       	cp	r12, r1
    8b46:	f5 e0       	ldi	r31, 0x05	; 5
    8b48:	df 06       	cpc	r13, r31
    8b4a:	f2 e6       	ldi	r31, 0x62	; 98
    8b4c:	ef 06       	cpc	r14, r31
    8b4e:	f5 eb       	ldi	r31, 0xB5	; 181
    8b50:	ff 06       	cpc	r15, r31
    8b52:	e9 f4       	brne	.+58     	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
    8b54:	05 c0       	rjmp	.+10     	; 0x8b60 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xca>
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
		{
			status = serialDriver->receive(b);
    8b56:	c9 01       	movw	r24, r18
	}else if (status == 0 && currentFourBytes == nackHeaderID)
	{
		return 1;
	}
		
	return status;
    8b58:	1a c0       	rjmp	.+52     	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
		}
	}	
	
	if (status == 0 && currentFourBytes == ackHeaderID)
	{
		return 0;
    8b5a:	80 e0       	ldi	r24, 0x00	; 0
    8b5c:	90 e0       	ldi	r25, 0x00	; 0
    8b5e:	17 c0       	rjmp	.+46     	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
	}else if (status == 0 && currentFourBytes == nackHeaderID)
	{
		return 1;
    8b60:	81 e0       	ldi	r24, 0x01	; 1
    8b62:	90 e0       	ldi	r25, 0x00	; 0
    8b64:	14 c0       	rjmp	.+40     	; 0x8b8e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xf8>
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
		{
			status = serialDriver->receive(b);
    8b66:	d8 01       	movw	r26, r16
    8b68:	8d 91       	ld	r24, X+
    8b6a:	9c 91       	ld	r25, X
    8b6c:	dc 01       	movw	r26, r24
    8b6e:	ed 91       	ld	r30, X+
    8b70:	fc 91       	ld	r31, X
    8b72:	02 88       	ldd	r0, Z+18	; 0x12
    8b74:	f3 89       	ldd	r31, Z+19	; 0x13
    8b76:	e0 2d       	mov	r30, r0
    8b78:	be 01       	movw	r22, r28
    8b7a:	6f 5f       	subi	r22, 0xFF	; 255
    8b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    8b7e:	19 95       	eicall
    8b80:	9c 01       	movw	r18, r24
    8b82:	0f 2e       	mov	r0, r31
    8b84:	f5 e0       	ldi	r31, 0x05	; 5
    8b86:	af 2e       	mov	r10, r31
    8b88:	b1 2c       	mov	r11, r1
    8b8a:	f0 2d       	mov	r31, r0
    8b8c:	ca cf       	rjmp	.-108    	; 0x8b22 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x8c>
	{
		return 1;
	}
		
	return status;
}
    8b8e:	0f 90       	pop	r0
    8b90:	df 91       	pop	r29
    8b92:	cf 91       	pop	r28
    8b94:	1f 91       	pop	r17
    8b96:	0f 91       	pop	r16
    8b98:	ff 90       	pop	r15
    8b9a:	ef 90       	pop	r14
    8b9c:	df 90       	pop	r13
    8b9e:	cf 90       	pop	r12
    8ba0:	bf 90       	pop	r11
    8ba2:	af 90       	pop	r10
    8ba4:	08 95       	ret

00008ba6 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>:


int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
{
    8ba6:	4f 92       	push	r4
    8ba8:	5f 92       	push	r5
    8baa:	6f 92       	push	r6
    8bac:	7f 92       	push	r7
    8bae:	8f 92       	push	r8
    8bb0:	9f 92       	push	r9
    8bb2:	af 92       	push	r10
    8bb4:	bf 92       	push	r11
    8bb6:	cf 92       	push	r12
    8bb8:	df 92       	push	r13
    8bba:	ef 92       	push	r14
    8bbc:	ff 92       	push	r15
    8bbe:	0f 93       	push	r16
    8bc0:	1f 93       	push	r17
    8bc2:	cf 93       	push	r28
    8bc4:	df 93       	push	r29
    8bc6:	1f 92       	push	r1
    8bc8:	cd b7       	in	r28, 0x3d	; 61
    8bca:	de b7       	in	r29, 0x3e	; 62
    8bcc:	7c 01       	movw	r14, r24
    8bce:	2a 01       	movw	r4, r20
    8bd0:	3b 01       	movw	r6, r22
    8bd2:	69 01       	movw	r12, r18
	int status = 0;
	byte b = 0;
    8bd4:	19 82       	std	Y+1, r1	; 0x01
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    8bd6:	41 15       	cp	r20, r1
    8bd8:	51 05       	cpc	r21, r1
    8bda:	61 05       	cpc	r22, r1
    8bdc:	71 05       	cpc	r23, r1
    8bde:	c1 f1       	breq	.+112    	; 0x8c50 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xaa>
int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
{
	int status = 0;
	byte b = 0;
	
	unsigned long currentFourBytes = 0;
    8be0:	81 2c       	mov	r8, r1
    8be2:	91 2c       	mov	r9, r1
    8be4:	54 01       	movw	r10, r8
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
	{
		status = serialDriver->receive(b);
    8be6:	d7 01       	movw	r26, r14
    8be8:	8d 91       	ld	r24, X+
    8bea:	9c 91       	ld	r25, X
    8bec:	dc 01       	movw	r26, r24
    8bee:	ed 91       	ld	r30, X+
    8bf0:	fc 91       	ld	r31, X
    8bf2:	02 88       	ldd	r0, Z+18	; 0x12
    8bf4:	f3 89       	ldd	r31, Z+19	; 0x13
    8bf6:	e0 2d       	mov	r30, r0
    8bf8:	be 01       	movw	r22, r28
    8bfa:	6f 5f       	subi	r22, 0xFF	; 255
    8bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    8bfe:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    8c00:	ba 2c       	mov	r11, r10
    8c02:	a9 2c       	mov	r10, r9
    8c04:	98 2c       	mov	r9, r8
    8c06:	88 24       	eor	r8, r8
    8c08:	29 81       	ldd	r18, Y+1	; 0x01
    8c0a:	82 2a       	or	r8, r18
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    8c0c:	00 97       	sbiw	r24, 0x00	; 0
    8c0e:	b9 f5       	brne	.+110    	; 0x8c7e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xd8>
    8c10:	48 14       	cp	r4, r8
    8c12:	59 04       	cpc	r5, r9
    8c14:	6a 04       	cpc	r6, r10
    8c16:	7b 04       	cpc	r7, r11
    8c18:	31 f7       	brne	.-52     	; 0x8be6 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x40>
    8c1a:	1d c0       	rjmp	.+58     	; 0x8c56 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xb0>
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
		{
			status = serialDriver->receive(b);
    8c1c:	f7 01       	movw	r30, r14
    8c1e:	80 81       	ld	r24, Z
    8c20:	91 81       	ldd	r25, Z+1	; 0x01
    8c22:	dc 01       	movw	r26, r24
    8c24:	ed 91       	ld	r30, X+
    8c26:	fc 91       	ld	r31, X
    8c28:	02 88       	ldd	r0, Z+18	; 0x12
    8c2a:	f3 89       	ldd	r31, Z+19	; 0x13
    8c2c:	e0 2d       	mov	r30, r0
    8c2e:	be 01       	movw	r22, r28
    8c30:	6f 5f       	subi	r22, 0xFF	; 255
    8c32:	7f 4f       	sbci	r23, 0xFF	; 255
    8c34:	19 95       	eicall
		
			msgData[i] = b;
    8c36:	29 81       	ldd	r18, Y+1	; 0x01
    8c38:	f5 01       	movw	r30, r10
    8c3a:	21 93       	st	Z+, r18
    8c3c:	5f 01       	movw	r10, r30
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    8c3e:	ec 15       	cp	r30, r12
    8c40:	fd 05       	cpc	r31, r13
    8c42:	e9 f0       	breq	.+58     	; 0x8c7e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xd8>
    8c44:	00 97       	sbiw	r24, 0x00	; 0
    8c46:	51 f3       	breq	.-44     	; 0x8c1c <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x76>
    8c48:	1a c0       	rjmp	.+52     	; 0x8c7e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xd8>
    8c4a:	80 e0       	ldi	r24, 0x00	; 0
    8c4c:	90 e0       	ldi	r25, 0x00	; 0
    8c4e:	17 c0       	rjmp	.+46     	; 0x8c7e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xd8>
int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
{
	int status = 0;
	byte b = 0;
	
	unsigned long currentFourBytes = 0;
    8c50:	81 2c       	mov	r8, r1
    8c52:	91 2c       	mov	r9, r1
    8c54:	54 01       	movw	r10, r8
	if (status == 0)
	{
		/**
		* Populate the message array with the first four bytes.
		*/
		msgData[0] = 0xFF & (currentFourBytes >> 24);
    8c56:	d6 01       	movw	r26, r12
    8c58:	bc 92       	st	X, r11
		msgData[1] = 0xFF & (currentFourBytes >> 16);
    8c5a:	11 96       	adiw	r26, 0x01	; 1
    8c5c:	ac 92       	st	X, r10
    8c5e:	11 97       	sbiw	r26, 0x01	; 1
		msgData[2] = 0xFF & (currentFourBytes >> 8);
    8c60:	12 96       	adiw	r26, 0x02	; 2
    8c62:	9c 92       	st	X, r9
    8c64:	12 97       	sbiw	r26, 0x02	; 2
		msgData[3] = 0xFF & currentFourBytes;
    8c66:	13 96       	adiw	r26, 0x03	; 3
    8c68:	8c 92       	st	X, r8
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    8c6a:	05 30       	cpi	r16, 0x05	; 5
    8c6c:	11 05       	cpc	r17, r1
    8c6e:	6c f3       	brlt	.-38     	; 0x8c4a <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xa4>
    8c70:	56 01       	movw	r10, r12
    8c72:	b4 e0       	ldi	r27, 0x04	; 4
    8c74:	ab 0e       	add	r10, r27
    8c76:	b1 1c       	adc	r11, r1
    8c78:	c0 0e       	add	r12, r16
    8c7a:	d1 1e       	adc	r13, r17
    8c7c:	cf cf       	rjmp	.-98     	; 0x8c1c <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x76>
			msgData[i] = b;
		}
	}	
		
	return status;
}
    8c7e:	0f 90       	pop	r0
    8c80:	df 91       	pop	r29
    8c82:	cf 91       	pop	r28
    8c84:	1f 91       	pop	r17
    8c86:	0f 91       	pop	r16
    8c88:	ff 90       	pop	r15
    8c8a:	ef 90       	pop	r14
    8c8c:	df 90       	pop	r13
    8c8e:	cf 90       	pop	r12
    8c90:	bf 90       	pop	r11
    8c92:	af 90       	pop	r10
    8c94:	9f 90       	pop	r9
    8c96:	8f 90       	pop	r8
    8c98:	7f 90       	pop	r7
    8c9a:	6f 90       	pop	r6
    8c9c:	5f 90       	pop	r5
    8c9e:	4f 90       	pop	r4
    8ca0:	08 95       	ret

00008ca2 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>:

int GPSSensor::readSensor(byte *pollMsg, int pollMsgSize, byte *msgData, int msgDataSize )
{
    8ca2:	af 92       	push	r10
    8ca4:	bf 92       	push	r11
    8ca6:	cf 92       	push	r12
    8ca8:	df 92       	push	r13
    8caa:	ef 92       	push	r14
    8cac:	ff 92       	push	r15
    8cae:	0f 93       	push	r16
    8cb0:	1f 93       	push	r17
    8cb2:	cf 93       	push	r28
    8cb4:	df 93       	push	r29
    8cb6:	ec 01       	movw	r28, r24
    8cb8:	6b 01       	movw	r12, r22
    8cba:	5a 01       	movw	r10, r20
    8cbc:	79 01       	movw	r14, r18
	
	//Clear the serial driver's buffer of any existing data.
	//serialDriver->clearBuffer();
	
	//Start timer
	serialDriver->startTimer();
    8cbe:	88 81       	ld	r24, Y
    8cc0:	99 81       	ldd	r25, Y+1	; 0x01
    8cc2:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
	
	
	//Send poll command
	status = serialDriver->transmit((const char*)pollMsg, pollMsgSize);
    8cc6:	a5 01       	movw	r20, r10
    8cc8:	b6 01       	movw	r22, r12
    8cca:	88 81       	ld	r24, Y
    8ccc:	99 81       	ldd	r25, Y+1	; 0x01
    8cce:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
    8cd2:	5c 01       	movw	r10, r24
	
	if (status == 0)
    8cd4:	00 97       	sbiw	r24, 0x00	; 0
    8cd6:	99 f4       	brne	.+38     	; 0x8cfe <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i+0x5c>
		/**
		 * The message that is being sent will have the same header and ID fields of the message
		 * that should be received. So convert the header and ID field into a long to be compared
		 * against the incoming header and ID field.
		 */
		unsigned long desiredHeaderID = (unsigned long) pollMsg[0] << 24 | 
    8cd8:	f6 01       	movw	r30, r12
    8cda:	80 81       	ld	r24, Z
										(unsigned long) pollMsg[1] << 16 | 
    8cdc:	41 81       	ldd	r20, Z+1	; 0x01
    8cde:	50 e0       	ldi	r21, 0x00	; 0
    8ce0:	60 e0       	ldi	r22, 0x00	; 0
    8ce2:	70 e0       	ldi	r23, 0x00	; 0
    8ce4:	ba 01       	movw	r22, r20
    8ce6:	55 27       	eor	r21, r21
    8ce8:	44 27       	eor	r20, r20
		/**
		 * The message that is being sent will have the same header and ID fields of the message
		 * that should be received. So convert the header and ID field into a long to be compared
		 * against the incoming header and ID field.
		 */
		unsigned long desiredHeaderID = (unsigned long) pollMsg[0] << 24 | 
    8cea:	78 2b       	or	r23, r24
										(unsigned long) pollMsg[1] << 16 | 
										(unsigned long) pollMsg[2] << 8 | 
    8cec:	83 81       	ldd	r24, Z+3	; 0x03
		 * The message that is being sent will have the same header and ID fields of the message
		 * that should be received. So convert the header and ID field into a long to be compared
		 * against the incoming header and ID field.
		 */
		unsigned long desiredHeaderID = (unsigned long) pollMsg[0] << 24 | 
										(unsigned long) pollMsg[1] << 16 | 
    8cee:	48 2b       	or	r20, r24
										(unsigned long) pollMsg[2] << 8 | 
    8cf0:	82 81       	ldd	r24, Z+2	; 0x02
										(unsigned long) pollMsg[3];
    8cf2:	58 2b       	or	r21, r24
										
		status = receiveGpsData(desiredHeaderID, msgData, msgDataSize);
    8cf4:	97 01       	movw	r18, r14
    8cf6:	ce 01       	movw	r24, r28
    8cf8:	0e 94 d3 45 	call	0x8ba6	; 0x8ba6 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>
    8cfc:	5c 01       	movw	r10, r24

	}
	

	//Stop timer
	serialDriver->stopTimer();
    8cfe:	88 81       	ld	r24, Y
    8d00:	99 81       	ldd	r25, Y+1	; 0x01
    8d02:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
}
    8d06:	c5 01       	movw	r24, r10
    8d08:	df 91       	pop	r29
    8d0a:	cf 91       	pop	r28
    8d0c:	1f 91       	pop	r17
    8d0e:	0f 91       	pop	r16
    8d10:	ff 90       	pop	r15
    8d12:	ef 90       	pop	r14
    8d14:	df 90       	pop	r13
    8d16:	cf 90       	pop	r12
    8d18:	bf 90       	pop	r11
    8d1a:	af 90       	pop	r10
    8d1c:	08 95       	ret

00008d1e <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>:
	return status;
}


int GPSSensor::processSensorSolution()
{
    8d1e:	fc 01       	movw	r30, r24
	int status = 0;
	
	if (navSolMsgReceived)
    8d20:	80 91 aa 03 	lds	r24, 0x03AA
    8d24:	88 23       	and	r24, r24
    8d26:	09 f4       	brne	.+2      	; 0x8d2a <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0xc>
    8d28:	bd c0       	rjmp	.+378    	; 0x8ea4 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x186>
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];		
		*/
		

		positionFixStatus =  navSolMsgBuffer2[16] >= 3 ? VALID : INVALID;
    8d2a:	80 91 bd 03 	lds	r24, 0x03BD
    8d2e:	83 30       	cpi	r24, 0x03	; 3
    8d30:	10 f0       	brcs	.+4      	; 0x8d36 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18>
    8d32:	82 e0       	ldi	r24, 0x02	; 2
    8d34:	01 c0       	rjmp	.+2      	; 0x8d38 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x1a>
    8d36:	81 e0       	ldi	r24, 0x01	; 1
    8d38:	82 a7       	std	Z+42, r24	; 0x2a

		//Parse position info
		xEcefCm =  ((long)navSolMsgBuffer2[21] << 24) | ((long)navSolMsgBuffer2[20] << 16) | ((long)navSolMsgBuffer2[19] << 8) | (long) navSolMsgBuffer2[18];
    8d3a:	80 91 c2 03 	lds	r24, 0x03C2
    8d3e:	40 91 c1 03 	lds	r20, 0x03C1
    8d42:	50 e0       	ldi	r21, 0x00	; 0
    8d44:	60 e0       	ldi	r22, 0x00	; 0
    8d46:	70 e0       	ldi	r23, 0x00	; 0
    8d48:	ba 01       	movw	r22, r20
    8d4a:	55 27       	eor	r21, r21
    8d4c:	44 27       	eor	r20, r20
    8d4e:	78 2b       	or	r23, r24
    8d50:	80 91 bf 03 	lds	r24, 0x03BF
    8d54:	48 2b       	or	r20, r24
    8d56:	80 91 c0 03 	lds	r24, 0x03C0
    8d5a:	58 2b       	or	r21, r24
    8d5c:	42 87       	std	Z+10, r20	; 0x0a
    8d5e:	53 87       	std	Z+11, r21	; 0x0b
    8d60:	64 87       	std	Z+12, r22	; 0x0c
    8d62:	75 87       	std	Z+13, r23	; 0x0d
		yEcefCm =  ((long)navSolMsgBuffer2[25] << 24) | ((long)navSolMsgBuffer2[24] << 16) | ((long)navSolMsgBuffer2[23] << 8) | (long) navSolMsgBuffer2[22];
    8d64:	80 91 c6 03 	lds	r24, 0x03C6
    8d68:	40 91 c5 03 	lds	r20, 0x03C5
    8d6c:	50 e0       	ldi	r21, 0x00	; 0
    8d6e:	60 e0       	ldi	r22, 0x00	; 0
    8d70:	70 e0       	ldi	r23, 0x00	; 0
    8d72:	ba 01       	movw	r22, r20
    8d74:	55 27       	eor	r21, r21
    8d76:	44 27       	eor	r20, r20
    8d78:	78 2b       	or	r23, r24
    8d7a:	80 91 c3 03 	lds	r24, 0x03C3
    8d7e:	48 2b       	or	r20, r24
    8d80:	80 91 c4 03 	lds	r24, 0x03C4
    8d84:	58 2b       	or	r21, r24
    8d86:	46 87       	std	Z+14, r20	; 0x0e
    8d88:	57 87       	std	Z+15, r21	; 0x0f
    8d8a:	60 8b       	std	Z+16, r22	; 0x10
    8d8c:	71 8b       	std	Z+17, r23	; 0x11
		zEcefCm =  ((long)navSolMsgBuffer2[29] << 24) | ((long)navSolMsgBuffer2[28] << 16) | ((long)navSolMsgBuffer2[27] << 8) | (long) navSolMsgBuffer2[26];
    8d8e:	80 91 ca 03 	lds	r24, 0x03CA
    8d92:	40 91 c9 03 	lds	r20, 0x03C9
    8d96:	50 e0       	ldi	r21, 0x00	; 0
    8d98:	60 e0       	ldi	r22, 0x00	; 0
    8d9a:	70 e0       	ldi	r23, 0x00	; 0
    8d9c:	ba 01       	movw	r22, r20
    8d9e:	55 27       	eor	r21, r21
    8da0:	44 27       	eor	r20, r20
    8da2:	78 2b       	or	r23, r24
    8da4:	80 91 c7 03 	lds	r24, 0x03C7
    8da8:	48 2b       	or	r20, r24
    8daa:	80 91 c8 03 	lds	r24, 0x03C8
    8dae:	58 2b       	or	r21, r24
    8db0:	42 8b       	std	Z+18, r20	; 0x12
    8db2:	53 8b       	std	Z+19, r21	; 0x13
    8db4:	64 8b       	std	Z+20, r22	; 0x14
    8db6:	75 8b       	std	Z+21, r23	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsgBuffer2[33] << 24) | ((long)navSolMsgBuffer2[32] << 16) | ((long)navSolMsgBuffer2[31] << 8) | (long) navSolMsgBuffer2[30];
    8db8:	80 91 ce 03 	lds	r24, 0x03CE
    8dbc:	40 91 cd 03 	lds	r20, 0x03CD
    8dc0:	50 e0       	ldi	r21, 0x00	; 0
    8dc2:	60 e0       	ldi	r22, 0x00	; 0
    8dc4:	70 e0       	ldi	r23, 0x00	; 0
    8dc6:	ba 01       	movw	r22, r20
    8dc8:	55 27       	eor	r21, r21
    8dca:	44 27       	eor	r20, r20
    8dcc:	78 2b       	or	r23, r24
    8dce:	80 91 cb 03 	lds	r24, 0x03CB
    8dd2:	48 2b       	or	r20, r24
    8dd4:	80 91 cc 03 	lds	r24, 0x03CC
    8dd8:	58 2b       	or	r21, r24
    8dda:	46 8b       	std	Z+22, r20	; 0x16
    8ddc:	57 8b       	std	Z+23, r21	; 0x17
    8dde:	60 8f       	std	Z+24, r22	; 0x18
    8de0:	71 8f       	std	Z+25, r23	; 0x19

		//Parse velocity info
		xVEcefCms =  ((long)navSolMsgBuffer2[37] << 24) | ((long)navSolMsgBuffer2[36] << 16) | ((long)navSolMsgBuffer2[35] << 8) | (long) navSolMsgBuffer2[34];
    8de2:	80 91 d2 03 	lds	r24, 0x03D2
    8de6:	40 91 d1 03 	lds	r20, 0x03D1
    8dea:	50 e0       	ldi	r21, 0x00	; 0
    8dec:	60 e0       	ldi	r22, 0x00	; 0
    8dee:	70 e0       	ldi	r23, 0x00	; 0
    8df0:	ba 01       	movw	r22, r20
    8df2:	55 27       	eor	r21, r21
    8df4:	44 27       	eor	r20, r20
    8df6:	78 2b       	or	r23, r24
    8df8:	80 91 cf 03 	lds	r24, 0x03CF
    8dfc:	48 2b       	or	r20, r24
    8dfe:	80 91 d0 03 	lds	r24, 0x03D0
    8e02:	58 2b       	or	r21, r24
    8e04:	42 8f       	std	Z+26, r20	; 0x1a
    8e06:	53 8f       	std	Z+27, r21	; 0x1b
    8e08:	64 8f       	std	Z+28, r22	; 0x1c
    8e0a:	75 8f       	std	Z+29, r23	; 0x1d
		yVEcefCms =  ((long)navSolMsgBuffer2[41] << 24) | ((long)navSolMsgBuffer2[40] << 16) | ((long)navSolMsgBuffer2[39] << 8) | (long) navSolMsgBuffer2[38];
    8e0c:	80 91 d6 03 	lds	r24, 0x03D6
    8e10:	40 91 d5 03 	lds	r20, 0x03D5
    8e14:	50 e0       	ldi	r21, 0x00	; 0
    8e16:	60 e0       	ldi	r22, 0x00	; 0
    8e18:	70 e0       	ldi	r23, 0x00	; 0
    8e1a:	ba 01       	movw	r22, r20
    8e1c:	55 27       	eor	r21, r21
    8e1e:	44 27       	eor	r20, r20
    8e20:	78 2b       	or	r23, r24
    8e22:	80 91 d3 03 	lds	r24, 0x03D3
    8e26:	48 2b       	or	r20, r24
    8e28:	80 91 d4 03 	lds	r24, 0x03D4
    8e2c:	58 2b       	or	r21, r24
    8e2e:	46 8f       	std	Z+30, r20	; 0x1e
    8e30:	57 8f       	std	Z+31, r21	; 0x1f
    8e32:	60 a3       	std	Z+32, r22	; 0x20
    8e34:	71 a3       	std	Z+33, r23	; 0x21
		zVEcefCms =  ((long)navSolMsgBuffer2[45] << 24) | ((long)navSolMsgBuffer2[44] << 16) | ((long)navSolMsgBuffer2[43] << 8) | (long) navSolMsgBuffer2[42];
    8e36:	80 91 da 03 	lds	r24, 0x03DA
    8e3a:	40 91 d9 03 	lds	r20, 0x03D9
    8e3e:	50 e0       	ldi	r21, 0x00	; 0
    8e40:	60 e0       	ldi	r22, 0x00	; 0
    8e42:	70 e0       	ldi	r23, 0x00	; 0
    8e44:	ba 01       	movw	r22, r20
    8e46:	55 27       	eor	r21, r21
    8e48:	44 27       	eor	r20, r20
    8e4a:	78 2b       	or	r23, r24
    8e4c:	80 91 d7 03 	lds	r24, 0x03D7
    8e50:	48 2b       	or	r20, r24
    8e52:	80 91 d8 03 	lds	r24, 0x03D8
    8e56:	58 2b       	or	r21, r24
    8e58:	42 a3       	std	Z+34, r20	; 0x22
    8e5a:	53 a3       	std	Z+35, r21	; 0x23
    8e5c:	64 a3       	std	Z+36, r22	; 0x24
    8e5e:	75 a3       	std	Z+37, r23	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsgBuffer2[49] << 24) | ((long)navSolMsgBuffer2[48] << 16) | ((long)navSolMsgBuffer2[47] << 8) | (long) navSolMsgBuffer2[46];
    8e60:	80 91 de 03 	lds	r24, 0x03DE
    8e64:	40 91 dd 03 	lds	r20, 0x03DD
    8e68:	50 e0       	ldi	r21, 0x00	; 0
    8e6a:	60 e0       	ldi	r22, 0x00	; 0
    8e6c:	70 e0       	ldi	r23, 0x00	; 0
    8e6e:	ba 01       	movw	r22, r20
    8e70:	55 27       	eor	r21, r21
    8e72:	44 27       	eor	r20, r20
    8e74:	78 2b       	or	r23, r24
    8e76:	80 91 db 03 	lds	r24, 0x03DB
    8e7a:	48 2b       	or	r20, r24
    8e7c:	80 91 dc 03 	lds	r24, 0x03DC
    8e80:	58 2b       	or	r21, r24
    8e82:	46 a3       	std	Z+38, r20	; 0x26
    8e84:	57 a3       	std	Z+39, r21	; 0x27
    8e86:	60 a7       	std	Z+40, r22	; 0x28
    8e88:	71 a7       	std	Z+41, r23	; 0x29

		
		navSolMsgReceived = false;
    8e8a:	10 92 aa 03 	sts	0x03AA, r1
		processing = false;
    8e8e:	10 92 a8 03 	sts	0x03A8, r1
		
		
		if (crcError)
    8e92:	80 91 a9 03 	lds	r24, 0x03A9
    8e96:	88 23       	and	r24, r24
    8e98:	41 f0       	breq	.+16     	; 0x8eaa <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18c>
		{
			status = -1;
			crcError = false;
    8e9a:	10 92 a9 03 	sts	0x03A9, r1
		processing = false;
		
		
		if (crcError)
		{
			status = -1;
    8e9e:	8f ef       	ldi	r24, 0xFF	; 255
    8ea0:	9f ef       	ldi	r25, 0xFF	; 255
    8ea2:	08 95       	ret
}


int GPSSensor::processSensorSolution()
{
	int status = 0;
    8ea4:	80 e0       	ldi	r24, 0x00	; 0
    8ea6:	90 e0       	ldi	r25, 0x00	; 0
    8ea8:	08 95       	ret
    8eaa:	80 e0       	ldi	r24, 0x00	; 0
    8eac:	90 e0       	ldi	r25, 0x00	; 0
		
		
	}
	
	return status;
}
    8eae:	08 95       	ret

00008eb0 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>:

int GPSSensor::readSensorSolution()
{
    8eb0:	ef 92       	push	r14
    8eb2:	ff 92       	push	r15
    8eb4:	0f 93       	push	r16
    8eb6:	1f 93       	push	r17
    8eb8:	cf 93       	push	r28
    8eba:	df 93       	push	r29
    8ebc:	cd b7       	in	r28, 0x3d	; 61
    8ebe:	de b7       	in	r29, 0x3e	; 62
    8ec0:	ec 97       	sbiw	r28, 0x3c	; 60
    8ec2:	0f b6       	in	r0, 0x3f	; 63
    8ec4:	f8 94       	cli
    8ec6:	de bf       	out	0x3e, r29	; 62
    8ec8:	0f be       	out	0x3f, r0	; 63
    8eca:	cd bf       	out	0x3d, r28	; 61
    8ecc:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte navSolMsg[60] = {0};
    8ece:	9e 01       	movw	r18, r28
    8ed0:	2f 5f       	subi	r18, 0xFF	; 255
    8ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    8ed4:	8c e3       	ldi	r24, 0x3C	; 60
    8ed6:	f9 01       	movw	r30, r18
    8ed8:	11 92       	st	Z+, r1
    8eda:	8a 95       	dec	r24
    8edc:	e9 f7       	brne	.-6      	; 0x8ed8 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x28>
	
	status = readSensor((byte *)NAV_SOL_POLLMSG, sizeof(NAV_SOL_POLLMSG), navSolMsg, sizeof(navSolMsg));
    8ede:	0c e3       	ldi	r16, 0x3C	; 60
    8ee0:	10 e0       	ldi	r17, 0x00	; 0
    8ee2:	48 e0       	ldi	r20, 0x08	; 8
    8ee4:	50 e0       	ldi	r21, 0x00	; 0
    8ee6:	66 ed       	ldi	r22, 0xD6	; 214
    8ee8:	72 e0       	ldi	r23, 0x02	; 2
    8eea:	c7 01       	movw	r24, r14
    8eec:	0e 94 51 46 	call	0x8ca2	; 0x8ca2 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
	
	if (status == 0)
    8ef0:	00 97       	sbiw	r24, 0x00	; 0
    8ef2:	09 f0       	breq	.+2      	; 0x8ef6 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x46>
    8ef4:	90 c0       	rjmp	.+288    	; 0x9016 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x166>
	{
		//Parse status info 
		positionFixStatus =  navSolMsg[16] >= 3 ? VALID : INVALID;
    8ef6:	29 89       	ldd	r18, Y+17	; 0x11
    8ef8:	23 30       	cpi	r18, 0x03	; 3
    8efa:	10 f0       	brcs	.+4      	; 0x8f00 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x50>
    8efc:	22 e0       	ldi	r18, 0x02	; 2
    8efe:	01 c0       	rjmp	.+2      	; 0x8f02 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x52>
    8f00:	21 e0       	ldi	r18, 0x01	; 1
    8f02:	f7 01       	movw	r30, r14
    8f04:	22 a7       	std	Z+42, r18	; 0x2a
		
		//Parse position info
		xEcefCm =  ((long)navSolMsg[21] << 24) | ((long)navSolMsg[20] << 16) | ((long)navSolMsg[19] << 8) | (long) navSolMsg[18];
    8f06:	2e 89       	ldd	r18, Y+22	; 0x16
    8f08:	4d 89       	ldd	r20, Y+21	; 0x15
    8f0a:	50 e0       	ldi	r21, 0x00	; 0
    8f0c:	60 e0       	ldi	r22, 0x00	; 0
    8f0e:	70 e0       	ldi	r23, 0x00	; 0
    8f10:	ba 01       	movw	r22, r20
    8f12:	55 27       	eor	r21, r21
    8f14:	44 27       	eor	r20, r20
    8f16:	72 2b       	or	r23, r18
    8f18:	2b 89       	ldd	r18, Y+19	; 0x13
    8f1a:	42 2b       	or	r20, r18
    8f1c:	2c 89       	ldd	r18, Y+20	; 0x14
    8f1e:	52 2b       	or	r21, r18
    8f20:	42 87       	std	Z+10, r20	; 0x0a
    8f22:	53 87       	std	Z+11, r21	; 0x0b
    8f24:	64 87       	std	Z+12, r22	; 0x0c
    8f26:	75 87       	std	Z+13, r23	; 0x0d
		yEcefCm =  ((long)navSolMsg[25] << 24) | ((long)navSolMsg[24] << 16) | ((long)navSolMsg[23] << 8) | (long) navSolMsg[22];
    8f28:	2a 8d       	ldd	r18, Y+26	; 0x1a
    8f2a:	49 8d       	ldd	r20, Y+25	; 0x19
    8f2c:	50 e0       	ldi	r21, 0x00	; 0
    8f2e:	60 e0       	ldi	r22, 0x00	; 0
    8f30:	70 e0       	ldi	r23, 0x00	; 0
    8f32:	ba 01       	movw	r22, r20
    8f34:	55 27       	eor	r21, r21
    8f36:	44 27       	eor	r20, r20
    8f38:	72 2b       	or	r23, r18
    8f3a:	2f 89       	ldd	r18, Y+23	; 0x17
    8f3c:	42 2b       	or	r20, r18
    8f3e:	28 8d       	ldd	r18, Y+24	; 0x18
    8f40:	52 2b       	or	r21, r18
    8f42:	46 87       	std	Z+14, r20	; 0x0e
    8f44:	57 87       	std	Z+15, r21	; 0x0f
    8f46:	60 8b       	std	Z+16, r22	; 0x10
    8f48:	71 8b       	std	Z+17, r23	; 0x11
		zEcefCm =  ((long)navSolMsg[29] << 24) | ((long)navSolMsg[28] << 16) | ((long)navSolMsg[27] << 8) | (long) navSolMsg[26];
    8f4a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    8f4c:	4d 8d       	ldd	r20, Y+29	; 0x1d
    8f4e:	50 e0       	ldi	r21, 0x00	; 0
    8f50:	60 e0       	ldi	r22, 0x00	; 0
    8f52:	70 e0       	ldi	r23, 0x00	; 0
    8f54:	ba 01       	movw	r22, r20
    8f56:	55 27       	eor	r21, r21
    8f58:	44 27       	eor	r20, r20
    8f5a:	72 2b       	or	r23, r18
    8f5c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8f5e:	42 2b       	or	r20, r18
    8f60:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8f62:	52 2b       	or	r21, r18
    8f64:	42 8b       	std	Z+18, r20	; 0x12
    8f66:	53 8b       	std	Z+19, r21	; 0x13
    8f68:	64 8b       	std	Z+20, r22	; 0x14
    8f6a:	75 8b       	std	Z+21, r23	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsg[33] << 24) | ((long)navSolMsg[32] << 16) | ((long)navSolMsg[31] << 8) | (long) navSolMsg[30];
    8f6c:	2a a1       	ldd	r18, Y+34	; 0x22
    8f6e:	49 a1       	ldd	r20, Y+33	; 0x21
    8f70:	50 e0       	ldi	r21, 0x00	; 0
    8f72:	60 e0       	ldi	r22, 0x00	; 0
    8f74:	70 e0       	ldi	r23, 0x00	; 0
    8f76:	ba 01       	movw	r22, r20
    8f78:	55 27       	eor	r21, r21
    8f7a:	44 27       	eor	r20, r20
    8f7c:	72 2b       	or	r23, r18
    8f7e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    8f80:	42 2b       	or	r20, r18
    8f82:	28 a1       	ldd	r18, Y+32	; 0x20
    8f84:	52 2b       	or	r21, r18
    8f86:	46 8b       	std	Z+22, r20	; 0x16
    8f88:	57 8b       	std	Z+23, r21	; 0x17
    8f8a:	60 8f       	std	Z+24, r22	; 0x18
    8f8c:	71 8f       	std	Z+25, r23	; 0x19
		
		//Parse velocity info
		xVEcefCms =  ((long)navSolMsg[37] << 24) | ((long)navSolMsg[36] << 16) | ((long)navSolMsg[35] << 8) | (long) navSolMsg[34];
    8f8e:	2e a1       	ldd	r18, Y+38	; 0x26
    8f90:	4d a1       	ldd	r20, Y+37	; 0x25
    8f92:	50 e0       	ldi	r21, 0x00	; 0
    8f94:	60 e0       	ldi	r22, 0x00	; 0
    8f96:	70 e0       	ldi	r23, 0x00	; 0
    8f98:	ba 01       	movw	r22, r20
    8f9a:	55 27       	eor	r21, r21
    8f9c:	44 27       	eor	r20, r20
    8f9e:	72 2b       	or	r23, r18
    8fa0:	2b a1       	ldd	r18, Y+35	; 0x23
    8fa2:	42 2b       	or	r20, r18
    8fa4:	2c a1       	ldd	r18, Y+36	; 0x24
    8fa6:	52 2b       	or	r21, r18
    8fa8:	42 8f       	std	Z+26, r20	; 0x1a
    8faa:	53 8f       	std	Z+27, r21	; 0x1b
    8fac:	64 8f       	std	Z+28, r22	; 0x1c
    8fae:	75 8f       	std	Z+29, r23	; 0x1d
		yVEcefCms =  ((long)navSolMsg[41] << 24) | ((long)navSolMsg[40] << 16) | ((long)navSolMsg[39] << 8) | (long) navSolMsg[38];
    8fb0:	2a a5       	ldd	r18, Y+42	; 0x2a
    8fb2:	49 a5       	ldd	r20, Y+41	; 0x29
    8fb4:	50 e0       	ldi	r21, 0x00	; 0
    8fb6:	60 e0       	ldi	r22, 0x00	; 0
    8fb8:	70 e0       	ldi	r23, 0x00	; 0
    8fba:	ba 01       	movw	r22, r20
    8fbc:	55 27       	eor	r21, r21
    8fbe:	44 27       	eor	r20, r20
    8fc0:	72 2b       	or	r23, r18
    8fc2:	2f a1       	ldd	r18, Y+39	; 0x27
    8fc4:	42 2b       	or	r20, r18
    8fc6:	28 a5       	ldd	r18, Y+40	; 0x28
    8fc8:	52 2b       	or	r21, r18
    8fca:	46 8f       	std	Z+30, r20	; 0x1e
    8fcc:	57 8f       	std	Z+31, r21	; 0x1f
    8fce:	60 a3       	std	Z+32, r22	; 0x20
    8fd0:	71 a3       	std	Z+33, r23	; 0x21
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
    8fd2:	2e a5       	ldd	r18, Y+46	; 0x2e
    8fd4:	4d a5       	ldd	r20, Y+45	; 0x2d
    8fd6:	50 e0       	ldi	r21, 0x00	; 0
    8fd8:	60 e0       	ldi	r22, 0x00	; 0
    8fda:	70 e0       	ldi	r23, 0x00	; 0
    8fdc:	ba 01       	movw	r22, r20
    8fde:	55 27       	eor	r21, r21
    8fe0:	44 27       	eor	r20, r20
    8fe2:	72 2b       	or	r23, r18
    8fe4:	2b a5       	ldd	r18, Y+43	; 0x2b
    8fe6:	42 2b       	or	r20, r18
    8fe8:	2c a5       	ldd	r18, Y+44	; 0x2c
    8fea:	52 2b       	or	r21, r18
    8fec:	42 a3       	std	Z+34, r20	; 0x22
    8fee:	53 a3       	std	Z+35, r21	; 0x23
    8ff0:	64 a3       	std	Z+36, r22	; 0x24
    8ff2:	75 a3       	std	Z+37, r23	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];
    8ff4:	2a a9       	ldd	r18, Y+50	; 0x32
    8ff6:	49 a9       	ldd	r20, Y+49	; 0x31
    8ff8:	50 e0       	ldi	r21, 0x00	; 0
    8ffa:	60 e0       	ldi	r22, 0x00	; 0
    8ffc:	70 e0       	ldi	r23, 0x00	; 0
    8ffe:	ba 01       	movw	r22, r20
    9000:	55 27       	eor	r21, r21
    9002:	44 27       	eor	r20, r20
    9004:	72 2b       	or	r23, r18
    9006:	2f a5       	ldd	r18, Y+47	; 0x2f
    9008:	42 2b       	or	r20, r18
    900a:	28 a9       	ldd	r18, Y+48	; 0x30
    900c:	52 2b       	or	r21, r18
    900e:	46 a3       	std	Z+38, r20	; 0x26
    9010:	57 a3       	std	Z+39, r21	; 0x27
    9012:	60 a7       	std	Z+40, r22	; 0x28
    9014:	71 a7       	std	Z+41, r23	; 0x29
		
	}

	return status;
}
    9016:	ec 96       	adiw	r28, 0x3c	; 60
    9018:	0f b6       	in	r0, 0x3f	; 63
    901a:	f8 94       	cli
    901c:	de bf       	out	0x3e, r29	; 62
    901e:	0f be       	out	0x3f, r0	; 63
    9020:	cd bf       	out	0x3d, r28	; 61
    9022:	df 91       	pop	r29
    9024:	cf 91       	pop	r28
    9026:	1f 91       	pop	r17
    9028:	0f 91       	pop	r16
    902a:	ff 90       	pop	r15
    902c:	ef 90       	pop	r14
    902e:	08 95       	ret

00009030 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>:


int GPSSensor::readSensorNavStatus()
{
    9030:	ef 92       	push	r14
    9032:	ff 92       	push	r15
    9034:	0f 93       	push	r16
    9036:	1f 93       	push	r17
    9038:	cf 93       	push	r28
    903a:	df 93       	push	r29
    903c:	cd b7       	in	r28, 0x3d	; 61
    903e:	de b7       	in	r29, 0x3e	; 62
    9040:	66 97       	sbiw	r28, 0x16	; 22
    9042:	0f b6       	in	r0, 0x3f	; 63
    9044:	f8 94       	cli
    9046:	de bf       	out	0x3e, r29	; 62
    9048:	0f be       	out	0x3f, r0	; 63
    904a:	cd bf       	out	0x3d, r28	; 61
    904c:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte statusMsg[22] = {0};
    904e:	9e 01       	movw	r18, r28
    9050:	2f 5f       	subi	r18, 0xFF	; 255
    9052:	3f 4f       	sbci	r19, 0xFF	; 255
    9054:	86 e1       	ldi	r24, 0x16	; 22
    9056:	f9 01       	movw	r30, r18
    9058:	11 92       	st	Z+, r1
    905a:	8a 95       	dec	r24
    905c:	e9 f7       	brne	.-6      	; 0x9058 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x28>
	
	status = readSensor((byte *)NAV_STATUS_POLLMSG, sizeof(NAV_STATUS_POLLMSG), statusMsg, sizeof(statusMsg));
    905e:	06 e1       	ldi	r16, 0x16	; 22
    9060:	10 e0       	ldi	r17, 0x00	; 0
    9062:	48 e0       	ldi	r20, 0x08	; 8
    9064:	50 e0       	ldi	r21, 0x00	; 0
    9066:	6e ec       	ldi	r22, 0xCE	; 206
    9068:	72 e0       	ldi	r23, 0x02	; 2
    906a:	c7 01       	movw	r24, r14
    906c:	0e 94 51 46 	call	0x8ca2	; 0x8ca2 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
	
	if (status == 0)
    9070:	00 97       	sbiw	r24, 0x00	; 0
    9072:	41 f4       	brne	.+16     	; 0x9084 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x54>
	{
		//parse results
		positionFixStatus =  statusMsg[10] >= 3 ? VALID : INVALID;
    9074:	2b 85       	ldd	r18, Y+11	; 0x0b
    9076:	23 30       	cpi	r18, 0x03	; 3
    9078:	10 f0       	brcs	.+4      	; 0x907e <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x4e>
    907a:	22 e0       	ldi	r18, 0x02	; 2
    907c:	01 c0       	rjmp	.+2      	; 0x9080 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x50>
    907e:	21 e0       	ldi	r18, 0x01	; 1
    9080:	f7 01       	movw	r30, r14
    9082:	22 a7       	std	Z+42, r18	; 0x2a
	}

	return status;
}
    9084:	66 96       	adiw	r28, 0x16	; 22
    9086:	0f b6       	in	r0, 0x3f	; 63
    9088:	f8 94       	cli
    908a:	de bf       	out	0x3e, r29	; 62
    908c:	0f be       	out	0x3f, r0	; 63
    908e:	cd bf       	out	0x3d, r28	; 61
    9090:	df 91       	pop	r29
    9092:	cf 91       	pop	r28
    9094:	1f 91       	pop	r17
    9096:	0f 91       	pop	r16
    9098:	ff 90       	pop	r15
    909a:	ef 90       	pop	r14
    909c:	08 95       	ret

0000909e <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>:

	return status;
}

int GPSSensor::readSensorLLH()
{
    909e:	ef 92       	push	r14
    90a0:	ff 92       	push	r15
    90a2:	0f 93       	push	r16
    90a4:	1f 93       	push	r17
    90a6:	cf 93       	push	r28
    90a8:	df 93       	push	r29
    90aa:	cd b7       	in	r28, 0x3d	; 61
    90ac:	de b7       	in	r29, 0x3e	; 62
    90ae:	a2 97       	sbiw	r28, 0x22	; 34
    90b0:	0f b6       	in	r0, 0x3f	; 63
    90b2:	f8 94       	cli
    90b4:	de bf       	out	0x3e, r29	; 62
    90b6:	0f be       	out	0x3f, r0	; 63
    90b8:	cd bf       	out	0x3d, r28	; 61
    90ba:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte llhMsg[34] = {0};
    90bc:	9e 01       	movw	r18, r28
    90be:	2f 5f       	subi	r18, 0xFF	; 255
    90c0:	3f 4f       	sbci	r19, 0xFF	; 255
    90c2:	82 e2       	ldi	r24, 0x22	; 34
    90c4:	f9 01       	movw	r30, r18
    90c6:	11 92       	st	Z+, r1
    90c8:	8a 95       	dec	r24
    90ca:	e9 f7       	brne	.-6      	; 0x90c6 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x28>
	
	status = readSensor((byte *)NAV_POSLLH_POLLMSG, sizeof(NAV_POSLLH_POLLMSG), llhMsg, sizeof(llhMsg));
    90cc:	02 e2       	ldi	r16, 0x22	; 34
    90ce:	10 e0       	ldi	r17, 0x00	; 0
    90d0:	48 e0       	ldi	r20, 0x08	; 8
    90d2:	50 e0       	ldi	r21, 0x00	; 0
    90d4:	6e ed       	ldi	r22, 0xDE	; 222
    90d6:	72 e0       	ldi	r23, 0x02	; 2
    90d8:	c7 01       	movw	r24, r14
    90da:	0e 94 51 46 	call	0x8ca2	; 0x8ca2 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>

	if (status == 0)
    90de:	00 97       	sbiw	r24, 0x00	; 0
    90e0:	19 f5       	brne	.+70     	; 0x9128 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x8a>
	{
		//parse results
		longitudeDegE7 =  ((long)llhMsg[13] << 24) | ((long)llhMsg[12] << 16) | ((long)llhMsg[11] << 8) | (long)llhMsg[10];
    90e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    90e4:	4d 85       	ldd	r20, Y+13	; 0x0d
    90e6:	50 e0       	ldi	r21, 0x00	; 0
    90e8:	60 e0       	ldi	r22, 0x00	; 0
    90ea:	70 e0       	ldi	r23, 0x00	; 0
    90ec:	ba 01       	movw	r22, r20
    90ee:	55 27       	eor	r21, r21
    90f0:	44 27       	eor	r20, r20
    90f2:	72 2b       	or	r23, r18
    90f4:	2b 85       	ldd	r18, Y+11	; 0x0b
    90f6:	42 2b       	or	r20, r18
    90f8:	2c 85       	ldd	r18, Y+12	; 0x0c
    90fa:	52 2b       	or	r21, r18
    90fc:	f7 01       	movw	r30, r14
    90fe:	46 83       	std	Z+6, r20	; 0x06
    9100:	57 83       	std	Z+7, r21	; 0x07
    9102:	60 87       	std	Z+8, r22	; 0x08
    9104:	71 87       	std	Z+9, r23	; 0x09
		latitudeDegE7 =  ((long)llhMsg[17] << 24) | ((long)llhMsg[16] << 16) | ((long)llhMsg[15] << 8) | (long) llhMsg[14];		
    9106:	2a 89       	ldd	r18, Y+18	; 0x12
    9108:	49 89       	ldd	r20, Y+17	; 0x11
    910a:	50 e0       	ldi	r21, 0x00	; 0
    910c:	60 e0       	ldi	r22, 0x00	; 0
    910e:	70 e0       	ldi	r23, 0x00	; 0
    9110:	ba 01       	movw	r22, r20
    9112:	55 27       	eor	r21, r21
    9114:	44 27       	eor	r20, r20
    9116:	72 2b       	or	r23, r18
    9118:	2f 85       	ldd	r18, Y+15	; 0x0f
    911a:	42 2b       	or	r20, r18
    911c:	28 89       	ldd	r18, Y+16	; 0x10
    911e:	52 2b       	or	r21, r18
    9120:	42 83       	std	Z+2, r20	; 0x02
    9122:	53 83       	std	Z+3, r21	; 0x03
    9124:	64 83       	std	Z+4, r22	; 0x04
    9126:	75 83       	std	Z+5, r23	; 0x05
	}

	return status;
}
    9128:	a2 96       	adiw	r28, 0x22	; 34
    912a:	0f b6       	in	r0, 0x3f	; 63
    912c:	f8 94       	cli
    912e:	de bf       	out	0x3e, r29	; 62
    9130:	0f be       	out	0x3f, r0	; 63
    9132:	cd bf       	out	0x3d, r28	; 61
    9134:	df 91       	pop	r29
    9136:	cf 91       	pop	r28
    9138:	1f 91       	pop	r17
    913a:	0f 91       	pop	r16
    913c:	ff 90       	pop	r15
    913e:	ef 90       	pop	r14
    9140:	08 95       	ret

00009142 <_ZN10helicopter7sensors9GPSSensor4initEv>:

int GPSSensor::init()
{
    9142:	cf 93       	push	r28
    9144:	df 93       	push	r29
    9146:	ec 01       	movw	r28, r24
	
	/**
	 * Transmit a hotstart reset and then clear the buffers so that if the gps is still periodically
	 * sending data, it doesn't cause an overflow of the serial drivers buffer. 
	 */
	serialDriver->clearBuffer();
    9148:	88 81       	ld	r24, Y
    914a:	99 81       	ldd	r25, Y+1	; 0x01
    914c:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>
	serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    9150:	4c e0       	ldi	r20, 0x0C	; 12
    9152:	50 e0       	ldi	r21, 0x00	; 0
    9154:	68 e8       	ldi	r22, 0x88	; 136
    9156:	72 e0       	ldi	r23, 0x02	; 2
    9158:	88 81       	ld	r24, Y
    915a:	99 81       	ldd	r25, Y+1	; 0x01
    915c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	/**
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
    9160:	ce 01       	movw	r24, r28
    9162:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    9166:	00 97       	sbiw	r24, 0x00	; 0
    9168:	79 f0       	breq	.+30     	; 0x9188 <_ZN10helicopter7sensors9GPSSensor4initEv+0x46>
	{
		//Nack received, so resend command
		if (status == 1)
    916a:	01 97       	sbiw	r24, 0x01	; 1
    916c:	41 f4       	brne	.+16     	; 0x917e <_ZN10helicopter7sensors9GPSSensor4initEv+0x3c>
		{
			serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    916e:	4c e0       	ldi	r20, 0x0C	; 12
    9170:	50 e0       	ldi	r21, 0x00	; 0
    9172:	68 e8       	ldi	r22, 0x88	; 136
    9174:	72 e0       	ldi	r23, 0x02	; 2
    9176:	88 81       	ld	r24, Y
    9178:	99 81       	ldd	r25, Y+1	; 0x01
    917a:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    917e:	ce 01       	movw	r24, r28
    9180:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
	while(status != 0)
    9184:	00 97       	sbiw	r24, 0x00	; 0
    9186:	89 f7       	brne	.-30     	; 0x916a <_ZN10helicopter7sensors9GPSSensor4initEv+0x28>
    9188:	2f ef       	ldi	r18, 0xFF	; 255
    918a:	8e e9       	ldi	r24, 0x9E	; 158
    918c:	94 e2       	ldi	r25, 0x24	; 36
    918e:	21 50       	subi	r18, 0x01	; 1
    9190:	80 40       	sbci	r24, 0x00	; 0
    9192:	90 40       	sbci	r25, 0x00	; 0
    9194:	e1 f7       	brne	.-8      	; 0x918e <_ZN10helicopter7sensors9GPSSensor4initEv+0x4c>
    9196:	00 c0       	rjmp	.+0      	; 0x9198 <_ZN10helicopter7sensors9GPSSensor4initEv+0x56>
    9198:	00 00       	nop
	
	
	/**
	* Configure the GPS's port to use, protocol, and speed.
	*/
	serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    919a:	4c e1       	ldi	r20, 0x1C	; 28
    919c:	50 e0       	ldi	r21, 0x00	; 0
    919e:	62 ea       	ldi	r22, 0xA2	; 162
    91a0:	72 e0       	ldi	r23, 0x02	; 2
    91a2:	88 81       	ld	r24, Y
    91a4:	99 81       	ldd	r25, Y+1	; 0x01
    91a6:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	 * byte and discard each byte of the ack message because if we don't read ALL the bytes
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
    91aa:	ce 01       	movw	r24, r28
    91ac:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    91b0:	00 97       	sbiw	r24, 0x00	; 0
    91b2:	79 f0       	breq	.+30     	; 0x91d2 <_ZN10helicopter7sensors9GPSSensor4initEv+0x90>
	{
		//Nack received, so resend command
		if (status == 1)
    91b4:	01 97       	sbiw	r24, 0x01	; 1
    91b6:	41 f4       	brne	.+16     	; 0x91c8 <_ZN10helicopter7sensors9GPSSensor4initEv+0x86>
		{
			serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    91b8:	4c e1       	ldi	r20, 0x1C	; 28
    91ba:	50 e0       	ldi	r21, 0x00	; 0
    91bc:	62 ea       	ldi	r22, 0xA2	; 162
    91be:	72 e0       	ldi	r23, 0x02	; 2
    91c0:	88 81       	ld	r24, Y
    91c2:	99 81       	ldd	r25, Y+1	; 0x01
    91c4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    91c8:	ce 01       	movw	r24, r28
    91ca:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
	while(status != 0)
    91ce:	00 97       	sbiw	r24, 0x00	; 0
    91d0:	89 f7       	brne	.-30     	; 0x91b4 <_ZN10helicopter7sensors9GPSSensor4initEv+0x72>
			
		}
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    91d2:	4e e0       	ldi	r20, 0x0E	; 14
    91d4:	50 e0       	ldi	r21, 0x00	; 0
    91d6:	64 e9       	ldi	r22, 0x94	; 148
    91d8:	72 e0       	ldi	r23, 0x02	; 2
    91da:	88 81       	ld	r24, Y
    91dc:	99 81       	ldd	r25, Y+1	; 0x01
    91de:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	status = receiveAckNack();
    91e2:	ce 01       	movw	r24, r28
    91e4:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    91e8:	00 97       	sbiw	r24, 0x00	; 0
    91ea:	79 f0       	breq	.+30     	; 0x920a <_ZN10helicopter7sensors9GPSSensor4initEv+0xc8>
	{
		//Nack received, so resend command
		if (status == 1)
    91ec:	01 97       	sbiw	r24, 0x01	; 1
    91ee:	41 f4       	brne	.+16     	; 0x9200 <_ZN10helicopter7sensors9GPSSensor4initEv+0xbe>
		{
			serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    91f0:	4e e0       	ldi	r20, 0x0E	; 14
    91f2:	50 e0       	ldi	r21, 0x00	; 0
    91f4:	64 e9       	ldi	r22, 0x94	; 148
    91f6:	72 e0       	ldi	r23, 0x02	; 2
    91f8:	88 81       	ld	r24, Y
    91fa:	99 81       	ldd	r25, Y+1	; 0x01
    91fc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    9200:	ce 01       	movw	r24, r28
    9202:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
	status = receiveAckNack();
	while(status != 0)
    9206:	00 97       	sbiw	r24, 0x00	; 0
    9208:	89 f7       	brne	.-30     	; 0x91ec <_ZN10helicopter7sensors9GPSSensor4initEv+0xaa>
		status = receiveAckNack();
	}


	return status;
}
    920a:	df 91       	pop	r29
    920c:	cf 91       	pop	r28
    920e:	08 95       	ret

00009210 <_ZN10helicopter7sensors9GPSSensor5startEv>:


int GPSSensor::start()
{
    9210:	cf 93       	push	r28
    9212:	df 93       	push	r29
    9214:	ec 01       	movw	r28, r24
	cli();
    9216:	f8 94       	cli
	/**
	* Hack to setup the serial driver to interrupt when data is received.
	*/
	UCSR1B |= (1<<RXCIE1);
    9218:	e9 ec       	ldi	r30, 0xC9	; 201
    921a:	f0 e0       	ldi	r31, 0x00	; 0
    921c:	80 81       	ld	r24, Z
    921e:	80 68       	ori	r24, 0x80	; 128
    9220:	80 83       	st	Z, r24
	

	/**
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    9222:	40 e1       	ldi	r20, 0x10	; 16
    9224:	50 e0       	ldi	r21, 0x00	; 0
    9226:	6e eb       	ldi	r22, 0xBE	; 190
    9228:	72 e0       	ldi	r23, 0x02	; 2
    922a:	88 81       	ld	r24, Y
    922c:	99 81       	ldd	r25, Y+1	; 0x01
    922e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
		
	int status = receiveAckNack();
    9232:	ce 01       	movw	r24, r28
    9234:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    9238:	00 97       	sbiw	r24, 0x00	; 0
    923a:	79 f0       	breq	.+30     	; 0x925a <_ZN10helicopter7sensors9GPSSensor5startEv+0x4a>
	{
		//Nack received, so resend command
		if (status == 1)
    923c:	01 97       	sbiw	r24, 0x01	; 1
    923e:	41 f4       	brne	.+16     	; 0x9250 <_ZN10helicopter7sensors9GPSSensor5startEv+0x40>
		{
			serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    9240:	40 e1       	ldi	r20, 0x10	; 16
    9242:	50 e0       	ldi	r21, 0x00	; 0
    9244:	6e eb       	ldi	r22, 0xBE	; 190
    9246:	72 e0       	ldi	r23, 0x02	; 2
    9248:	88 81       	ld	r24, Y
    924a:	99 81       	ldd	r25, Y+1	; 0x01
    924c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    9250:	ce 01       	movw	r24, r28
    9252:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
		
	int status = receiveAckNack();
	while(status != 0)
    9256:	00 97       	sbiw	r24, 0x00	; 0
    9258:	89 f7       	brne	.-30     	; 0x923c <_ZN10helicopter7sensors9GPSSensor5startEv+0x2c>
			
		}
		status = receiveAckNack();
	}

	sei();	
    925a:	78 94       	sei
	
	return status;
}
    925c:	df 91       	pop	r29
    925e:	cf 91       	pop	r28
    9260:	08 95       	ret

00009262 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>:
				
bool GPSSensor::isGpsReady()
{
	return positionFixStatus == VALID;;
    9262:	21 e0       	ldi	r18, 0x01	; 1
    9264:	fc 01       	movw	r30, r24
    9266:	82 a5       	ldd	r24, Z+42	; 0x2a
    9268:	82 30       	cpi	r24, 0x02	; 2
    926a:	09 f0       	breq	.+2      	; 0x926e <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv+0xc>
    926c:	20 e0       	ldi	r18, 0x00	; 0
}
    926e:	82 2f       	mov	r24, r18
    9270:	08 95       	ret

00009272 <__vector_36>:



//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART1_RX_vect)
{
    9272:	1f 92       	push	r1
    9274:	0f 92       	push	r0
    9276:	0f b6       	in	r0, 0x3f	; 63
    9278:	0f 92       	push	r0
    927a:	11 24       	eor	r1, r1
    927c:	0b b6       	in	r0, 0x3b	; 59
    927e:	0f 92       	push	r0
    9280:	2f 93       	push	r18
    9282:	3f 93       	push	r19
    9284:	4f 93       	push	r20
    9286:	8f 93       	push	r24
    9288:	9f 93       	push	r25
    928a:	af 93       	push	r26
    928c:	bf 93       	push	r27
    928e:	ef 93       	push	r30
    9290:	ff 93       	push	r31

	byte msgByte = UDR1;
    9292:	40 91 ce 00 	lds	r20, 0x00CE
	

	if (GPSSensor::navSolBufferCounter < GPSSensor::navSolBufferSize)
    9296:	80 91 ab 03 	lds	r24, 0x03AB
    929a:	90 91 ac 03 	lds	r25, 0x03AC
    929e:	8c 33       	cpi	r24, 0x3C	; 60
    92a0:	91 05       	cpc	r25, r1
    92a2:	0c f0       	brlt	.+2      	; 0x92a6 <__vector_36+0x34>
    92a4:	50 c0       	rjmp	.+160    	; 0x9346 <__vector_36+0xd4>
		/**
		* if the first data values don't match header values and id values, then the msg has been corrupted
		* so ignore the message. 0xB5 is the first header byte, 0x62 is the second header byte,
		* 0x01 is the first ID byte for the nav_sol msg and 0x06 is the second header byte.
		*/
		if ((GPSSensor::navSolBufferCounter == 0 && msgByte != 0xB5) ||
    92a6:	00 97       	sbiw	r24, 0x00	; 0
    92a8:	21 f4       	brne	.+8      	; 0x92b2 <__vector_36+0x40>
    92aa:	45 3b       	cpi	r20, 0xB5	; 181
    92ac:	09 f0       	breq	.+2      	; 0x92b0 <__vector_36+0x3e>
    92ae:	67 c0       	rjmp	.+206    	; 0x937e <__vector_36+0x10c>
    92b0:	0e c0       	rjmp	.+28     	; 0x92ce <__vector_36+0x5c>
    92b2:	81 30       	cpi	r24, 0x01	; 1
    92b4:	91 05       	cpc	r25, r1
    92b6:	21 f4       	brne	.+8      	; 0x92c0 <__vector_36+0x4e>
			(GPSSensor::navSolBufferCounter == 1 && msgByte != 0x62) ||
    92b8:	42 36       	cpi	r20, 0x62	; 98
    92ba:	09 f0       	breq	.+2      	; 0x92be <__vector_36+0x4c>
    92bc:	60 c0       	rjmp	.+192    	; 0x937e <__vector_36+0x10c>
    92be:	4a c0       	rjmp	.+148    	; 0x9354 <__vector_36+0xe2>
    92c0:	82 30       	cpi	r24, 0x02	; 2
    92c2:	91 05       	cpc	r25, r1
    92c4:	21 f4       	brne	.+8      	; 0x92ce <__vector_36+0x5c>
			(GPSSensor::navSolBufferCounter == 2 && msgByte != 0x01) || 
    92c6:	41 30       	cpi	r20, 0x01	; 1
    92c8:	09 f0       	breq	.+2      	; 0x92cc <__vector_36+0x5a>
    92ca:	59 c0       	rjmp	.+178    	; 0x937e <__vector_36+0x10c>
    92cc:	5f c0       	rjmp	.+190    	; 0x938c <__vector_36+0x11a>
    92ce:	83 30       	cpi	r24, 0x03	; 3
    92d0:	91 05       	cpc	r25, r1
    92d2:	09 f0       	breq	.+2      	; 0x92d6 <__vector_36+0x64>
    92d4:	3f c0       	rjmp	.+126    	; 0x9354 <__vector_36+0xe2>
			(GPSSensor::navSolBufferCounter == 3 && msgByte != 0x06))
    92d6:	46 30       	cpi	r20, 0x06	; 6
    92d8:	09 f0       	breq	.+2      	; 0x92dc <__vector_36+0x6a>
    92da:	51 c0       	rjmp	.+162    	; 0x937e <__vector_36+0x10c>
    92dc:	57 c0       	rjmp	.+174    	; 0x938c <__vector_36+0x11a>
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
    92de:	41 91       	ld	r20, Z+
    92e0:	24 0f       	add	r18, r20
					ckB = ckB + ckA;
    92e2:	32 0f       	add	r19, r18
			{
				//8-bit fletcher algorithm defined on page 86 of gps pdf.
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
    92e4:	e8 17       	cp	r30, r24
    92e6:	f9 07       	cpc	r31, r25
    92e8:	d1 f7       	brne	.-12     	; 0x92de <__vector_36+0x6c>
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
					ckB = ckB + ckA;
				}
				
				if (GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 2] == ckA && 
    92ea:	80 91 23 04 	lds	r24, 0x0423
    92ee:	28 13       	cpse	r18, r24
    92f0:	20 c0       	rjmp	.+64     	; 0x9332 <__vector_36+0xc0>
    92f2:	80 91 24 04 	lds	r24, 0x0424
    92f6:	38 13       	cpse	r19, r24
    92f8:	1c c0       	rjmp	.+56     	; 0x9332 <__vector_36+0xc0>
					GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 1] == ckB)
				{
					//Don't change the buffer data if the system is currently processing the buffer.
					if (GPSSensor::processing == false)
    92fa:	80 91 a8 03 	lds	r24, 0x03A8
    92fe:	81 11       	cpse	r24, r1
    9300:	11 c0       	rjmp	.+34     	; 0x9324 <__vector_36+0xb2>
					{
						memcpy(GPSSensor::navSolMsgBuffer2,GPSSensor::navSolMsgBuffer, GPSSensor::navSolBufferSize);
    9302:	8c e3       	ldi	r24, 0x3C	; 60
    9304:	e9 ee       	ldi	r30, 0xE9	; 233
    9306:	f3 e0       	ldi	r31, 0x03	; 3
    9308:	ad ea       	ldi	r26, 0xAD	; 173
    930a:	b3 e0       	ldi	r27, 0x03	; 3
    930c:	01 90       	ld	r0, Z+
    930e:	0d 92       	st	X+, r0
    9310:	8a 95       	dec	r24
    9312:	e1 f7       	brne	.-8      	; 0x930c <__vector_36+0x9a>
						GPSSensor::navSolMsgReceived = true;
    9314:	81 e0       	ldi	r24, 0x01	; 1
    9316:	80 93 aa 03 	sts	0x03AA, r24
						GPSSensor::navSolBufferCounter = 0;						
    931a:	10 92 ac 03 	sts	0x03AC, r1
    931e:	10 92 ab 03 	sts	0x03AB, r1
    9322:	3f c0       	rjmp	.+126    	; 0x93a2 <__vector_36+0x130>
					{
						//Reset for a new message and drop this message because the system was processing the current message
						//when the new message came in. 
						//This could be bad because if the timing planets aligned, and this kept happening and the gps messages
						//kept getting dropped, then that would be bad. 
						GPSSensor::navSolMsgReceived = false;
    9324:	10 92 aa 03 	sts	0x03AA, r1
						GPSSensor::navSolBufferCounter = 0;
    9328:	10 92 ac 03 	sts	0x03AC, r1
    932c:	10 92 ab 03 	sts	0x03AB, r1
    9330:	38 c0       	rjmp	.+112    	; 0x93a2 <__vector_36+0x130>
					}
			
				}else
				{
					//GPS checksum didn't match. 
					GPSSensor::navSolMsgReceived = false;
    9332:	10 92 aa 03 	sts	0x03AA, r1
					GPSSensor::navSolBufferCounter = 0;
    9336:	10 92 ac 03 	sts	0x03AC, r1
    933a:	10 92 ab 03 	sts	0x03AB, r1
					GPSSensor::crcError = true;
    933e:	81 e0       	ldi	r24, 0x01	; 1
    9340:	80 93 a9 03 	sts	0x03A9, r24
    9344:	2e c0       	rjmp	.+92     	; 0x93a2 <__vector_36+0x130>
			}			
		}
	}else
	{
		//Theres been some kind of error and the buffer overran, so reset.
		GPSSensor::navSolMsgReceived = false;
    9346:	10 92 aa 03 	sts	0x03AA, r1
		GPSSensor::navSolBufferCounter = 0;
    934a:	10 92 ac 03 	sts	0x03AC, r1
    934e:	10 92 ab 03 	sts	0x03AB, r1
    9352:	27 c0       	rjmp	.+78     	; 0x93a2 <__vector_36+0x130>
		{
			GPSSensor::navSolMsgReceived = false;
			GPSSensor::navSolBufferCounter = 0;
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    9354:	9c 01       	movw	r18, r24
    9356:	2f 5f       	subi	r18, 0xFF	; 255
    9358:	3f 4f       	sbci	r19, 0xFF	; 255
    935a:	30 93 ac 03 	sts	0x03AC, r19
    935e:	20 93 ab 03 	sts	0x03AB, r18
    9362:	fc 01       	movw	r30, r24
    9364:	e7 51       	subi	r30, 0x17	; 23
    9366:	fc 4f       	sbci	r31, 0xFC	; 252
    9368:	40 83       	st	Z, r20
			
			if (GPSSensor::navSolBufferCounter >= GPSSensor::navSolBufferSize)
    936a:	2c 33       	cpi	r18, 0x3C	; 60
    936c:	31 05       	cpc	r19, r1
    936e:	cc f0       	brlt	.+50     	; 0x93a2 <__vector_36+0x130>
    9370:	eb ee       	ldi	r30, 0xEB	; 235
    9372:	f3 e0       	ldi	r31, 0x03	; 3
    9374:	83 e2       	ldi	r24, 0x23	; 35
    9376:	94 e0       	ldi	r25, 0x04	; 4
    9378:	30 e0       	ldi	r19, 0x00	; 0
    937a:	20 e0       	ldi	r18, 0x00	; 0
    937c:	b0 cf       	rjmp	.-160    	; 0x92de <__vector_36+0x6c>
			isCorrupted = true;
		}
		
		if (isCorrupted)
		{
			GPSSensor::navSolMsgReceived = false;
    937e:	10 92 aa 03 	sts	0x03AA, r1
			GPSSensor::navSolBufferCounter = 0;
    9382:	10 92 ac 03 	sts	0x03AC, r1
    9386:	10 92 ab 03 	sts	0x03AB, r1
    938a:	0b c0       	rjmp	.+22     	; 0x93a2 <__vector_36+0x130>
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    938c:	9c 01       	movw	r18, r24
    938e:	2f 5f       	subi	r18, 0xFF	; 255
    9390:	3f 4f       	sbci	r19, 0xFF	; 255
    9392:	30 93 ac 03 	sts	0x03AC, r19
    9396:	20 93 ab 03 	sts	0x03AB, r18
    939a:	fc 01       	movw	r30, r24
    939c:	e7 51       	subi	r30, 0x17	; 23
    939e:	fc 4f       	sbci	r31, 0xFC	; 252
    93a0:	40 83       	st	Z, r20

	
	//I'll want to make sure I do a memcpy on the buffer when i start working on it
	//to ensure it's not adjusted while I'm working on it.
	//and I'll want to set variable to false first.
    93a2:	ff 91       	pop	r31
    93a4:	ef 91       	pop	r30
    93a6:	bf 91       	pop	r27
    93a8:	af 91       	pop	r26
    93aa:	9f 91       	pop	r25
    93ac:	8f 91       	pop	r24
    93ae:	4f 91       	pop	r20
    93b0:	3f 91       	pop	r19
    93b2:	2f 91       	pop	r18
    93b4:	0f 90       	pop	r0
    93b6:	0b be       	out	0x3b, r0	; 59
    93b8:	0f 90       	pop	r0
    93ba:	0f be       	out	0x3f, r0	; 63
    93bc:	0f 90       	pop	r0
    93be:	1f 90       	pop	r1
    93c0:	18 95       	reti

000093c2 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>:
	this->gyroOffsets[2] = offsetz;
	
}

void IMUSensor::readSensor()
{
    93c2:	8f 92       	push	r8
    93c4:	9f 92       	push	r9
    93c6:	af 92       	push	r10
    93c8:	bf 92       	push	r11
    93ca:	cf 92       	push	r12
    93cc:	df 92       	push	r13
    93ce:	ef 92       	push	r14
    93d0:	ff 92       	push	r15
    93d2:	cf 93       	push	r28
    93d4:	df 93       	push	r29
    93d6:	ec 01       	movw	r28, r24
	if (!hasBeenRead)
    93d8:	fc 01       	movw	r30, r24
    93da:	e6 5b       	subi	r30, 0xB6	; 182
    93dc:	ff 4f       	sbci	r31, 0xFF	; 255
    93de:	80 81       	ld	r24, Z
    93e0:	81 11       	cpse	r24, r1
    93e2:	03 c0       	rjmp	.+6      	; 0x93ea <_ZN10helicopter7sensors9IMUSensor10readSensorEv+0x28>
	{
		missedRead = true;
    93e4:	81 e0       	ldi	r24, 0x01	; 1
    93e6:	31 96       	adiw	r30, 0x01	; 1
    93e8:	80 83       	st	Z, r24
	}
	
	hasBeenRead = false;
    93ea:	fe 01       	movw	r30, r28
    93ec:	e6 5b       	subi	r30, 0xB6	; 182
    93ee:	ff 4f       	sbci	r31, 0xFF	; 255
    93f0:	10 82       	st	Z, r1
	
	//indicate that this device is about to begin communicating with the sensor.
	spiDriver->beginTransaction();
    93f2:	8c a1       	ldd	r24, Y+36	; 0x24
    93f4:	9d a1       	ldd	r25, Y+37	; 0x25
    93f6:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	 * is now pointing to.
	 * The address is 'or'ed by the 'readcommand' to indicate to the
	 * sensor that the subsequent commands should read data
	 * from the sensor.
	 */	
	spiDriver->write(REG_ACCEL_XOUT_H | readCommand);
    93fa:	6b eb       	ldi	r22, 0xBB	; 187
    93fc:	8c a1       	ldd	r24, Y+36	; 0x24
    93fe:	9d a1       	ldd	r25, Y+37	; 0x25
    9400:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <_ZN10helicopter7drivers9SPIDriver5writeEh>

	rawAccX = spiDriver->readInt();
    9404:	8c a1       	ldd	r24, Y+36	; 0x24
    9406:	9d a1       	ldd	r25, Y+37	; 0x25
    9408:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    940c:	9f a3       	std	Y+39, r25	; 0x27
    940e:	8e a3       	std	Y+38, r24	; 0x26
	rawAccY = spiDriver->readInt();
    9410:	8c a1       	ldd	r24, Y+36	; 0x24
    9412:	9d a1       	ldd	r25, Y+37	; 0x25
    9414:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9418:	99 a7       	std	Y+41, r25	; 0x29
    941a:	88 a7       	std	Y+40, r24	; 0x28
	rawAccZ = spiDriver->readInt();
    941c:	8c a1       	ldd	r24, Y+36	; 0x24
    941e:	9d a1       	ldd	r25, Y+37	; 0x25
    9420:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9424:	9b a7       	std	Y+43, r25	; 0x2b
    9426:	8a a7       	std	Y+42, r24	; 0x2a
	
	//read the temp data, and ignore it since it isn't used.
	spiDriver->readInt();
    9428:	8c a1       	ldd	r24, Y+36	; 0x24
    942a:	9d a1       	ldd	r25, Y+37	; 0x25
    942c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
	
	rawGyroX = spiDriver->readInt();
    9430:	8c a1       	ldd	r24, Y+36	; 0x24
    9432:	9d a1       	ldd	r25, Y+37	; 0x25
    9434:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9438:	9d a7       	std	Y+45, r25	; 0x2d
    943a:	8c a7       	std	Y+44, r24	; 0x2c
	rawGyroY = spiDriver->readInt();
    943c:	8c a1       	ldd	r24, Y+36	; 0x24
    943e:	9d a1       	ldd	r25, Y+37	; 0x25
    9440:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9444:	9f a7       	std	Y+47, r25	; 0x2f
    9446:	8e a7       	std	Y+46, r24	; 0x2e
	rawGyroZ = spiDriver->readInt();
    9448:	8c a1       	ldd	r24, Y+36	; 0x24
    944a:	9d a1       	ldd	r25, Y+37	; 0x25
    944c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    9450:	99 ab       	std	Y+49, r25	; 0x31
    9452:	88 ab       	std	Y+48, r24	; 0x30
	
	/**
	 * The master (this CPU) then pulls the slave select line low indicating
	 * that it is done communicating.
	 */
	spiDriver->endTransaction();
    9454:	8c a1       	ldd	r24, Y+36	; 0x24
    9456:	9d a1       	ldd	r25, Y+37	; 0x25
    9458:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    945c:	6e a1       	ldd	r22, Y+38	; 0x26
    945e:	7f a1       	ldd	r23, Y+39	; 0x27
    9460:	88 27       	eor	r24, r24
    9462:	77 fd       	sbrc	r23, 7
    9464:	80 95       	com	r24
    9466:	98 2f       	mov	r25, r24
    9468:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    946c:	2a e0       	ldi	r18, 0x0A	; 10
    946e:	38 ee       	ldi	r19, 0xE8	; 232
    9470:	4c e9       	ldi	r20, 0x9C	; 156
    9472:	5a e3       	ldi	r21, 0x3A	; 58
    9474:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    9478:	4b 01       	movw	r8, r22
    947a:	5c 01       	movw	r10, r24
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    947c:	6a a5       	ldd	r22, Y+42	; 0x2a
    947e:	7b a5       	ldd	r23, Y+43	; 0x2b
    9480:	71 95       	neg	r23
    9482:	61 95       	neg	r22
    9484:	71 09       	sbc	r23, r1
    9486:	88 27       	eor	r24, r24
    9488:	77 fd       	sbrc	r23, 7
    948a:	80 95       	com	r24
    948c:	98 2f       	mov	r25, r24
    948e:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9492:	2a e0       	ldi	r18, 0x0A	; 10
    9494:	38 ee       	ldi	r19, 0xE8	; 232
    9496:	4c e9       	ldi	r20, 0x9C	; 156
    9498:	5a e3       	ldi	r21, 0x3A	; 58
    949a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    949e:	6b 01       	movw	r12, r22
    94a0:	7c 01       	movw	r14, r24
	
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    94a2:	68 a5       	ldd	r22, Y+40	; 0x28
    94a4:	79 a5       	ldd	r23, Y+41	; 0x29
    94a6:	88 27       	eor	r24, r24
    94a8:	77 fd       	sbrc	r23, 7
    94aa:	80 95       	com	r24
    94ac:	98 2f       	mov	r25, r24
    94ae:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    94b2:	2a e0       	ldi	r18, 0x0A	; 10
    94b4:	38 ee       	ldi	r19, 0xE8	; 232
    94b6:	4c e9       	ldi	r20, 0x9C	; 156
    94b8:	5a e3       	ldi	r21, 0x3A	; 58
    94ba:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	//Multiplying by negative 1 because technically the gravity vector is what we want to be
	//FRD, not the acceleration vector. so since gravity is -9.8 we want to convert it to 9.8.
	frdAccXMss *= -1;
    94be:	dc 01       	movw	r26, r24
    94c0:	cb 01       	movw	r24, r22
    94c2:	b0 58       	subi	r27, 0x80	; 128
    94c4:	8a ab       	std	Y+50, r24	; 0x32
    94c6:	9b ab       	std	Y+51, r25	; 0x33
    94c8:	ac ab       	std	Y+52, r26	; 0x34
    94ca:	bd ab       	std	Y+53, r27	; 0x35
	frdAccYMss *= -1;
    94cc:	b7 fa       	bst	r11, 7
    94ce:	b0 94       	com	r11
    94d0:	b7 f8       	bld	r11, 7
    94d2:	b0 94       	com	r11
    94d4:	8e aa       	std	Y+54, r8	; 0x36
    94d6:	9f aa       	std	Y+55, r9	; 0x37
    94d8:	a8 ae       	std	Y+56, r10	; 0x38
    94da:	b9 ae       	std	Y+57, r11	; 0x39
	frdAccZMss *= -1;
    94dc:	f7 fa       	bst	r15, 7
    94de:	f0 94       	com	r15
    94e0:	f7 f8       	bld	r15, 7
    94e2:	f0 94       	com	r15
    94e4:	ca ae       	std	Y+58, r12	; 0x3a
    94e6:	db ae       	std	Y+59, r13	; 0x3b
    94e8:	ec ae       	std	Y+60, r14	; 0x3c
    94ea:	fd ae       	std	Y+61, r15	; 0x3d
	
	frdGyroXRs = (rawGyroY - gyroOffsets[1]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    94ec:	7e 01       	movw	r14, r28
    94ee:	8e e3       	ldi	r24, 0x3E	; 62
    94f0:	e8 0e       	add	r14, r24
    94f2:	f1 1c       	adc	r15, r1
    94f4:	6e a5       	ldd	r22, Y+46	; 0x2e
    94f6:	7f a5       	ldd	r23, Y+47	; 0x2f
    94f8:	88 27       	eor	r24, r24
    94fa:	77 fd       	sbrc	r23, 7
    94fc:	80 95       	com	r24
    94fe:	98 2f       	mov	r25, r24
    9500:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9504:	fe 01       	movw	r30, r28
    9506:	e0 5b       	subi	r30, 0xB0	; 176
    9508:	ff 4f       	sbci	r31, 0xFF	; 255
    950a:	20 81       	ld	r18, Z
    950c:	31 81       	ldd	r19, Z+1	; 0x01
    950e:	42 81       	ldd	r20, Z+2	; 0x02
    9510:	53 81       	ldd	r21, Z+3	; 0x03
    9512:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    9516:	25 ea       	ldi	r18, 0xA5	; 165
    9518:	39 ee       	ldi	r19, 0xE9	; 233
    951a:	4a e6       	ldi	r20, 0x6A	; 106
    951c:	54 e4       	ldi	r21, 0x44	; 68
    951e:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    9522:	f7 01       	movw	r30, r14
    9524:	60 83       	st	Z, r22
    9526:	71 83       	std	Z+1, r23	; 0x01
    9528:	82 83       	std	Z+2, r24	; 0x02
    952a:	93 83       	std	Z+3, r25	; 0x03
	frdGyroYRs = (rawGyroX - gyroOffsets[0]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    952c:	7e 01       	movw	r14, r28
    952e:	f2 e4       	ldi	r31, 0x42	; 66
    9530:	ef 0e       	add	r14, r31
    9532:	f1 1c       	adc	r15, r1
    9534:	6c a5       	ldd	r22, Y+44	; 0x2c
    9536:	7d a5       	ldd	r23, Y+45	; 0x2d
    9538:	88 27       	eor	r24, r24
    953a:	77 fd       	sbrc	r23, 7
    953c:	80 95       	com	r24
    953e:	98 2f       	mov	r25, r24
    9540:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9544:	fe 01       	movw	r30, r28
    9546:	e4 5b       	subi	r30, 0xB4	; 180
    9548:	ff 4f       	sbci	r31, 0xFF	; 255
    954a:	20 81       	ld	r18, Z
    954c:	31 81       	ldd	r19, Z+1	; 0x01
    954e:	42 81       	ldd	r20, Z+2	; 0x02
    9550:	53 81       	ldd	r21, Z+3	; 0x03
    9552:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    9556:	25 ea       	ldi	r18, 0xA5	; 165
    9558:	39 ee       	ldi	r19, 0xE9	; 233
    955a:	4a e6       	ldi	r20, 0x6A	; 106
    955c:	54 e4       	ldi	r21, 0x44	; 68
    955e:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    9562:	f7 01       	movw	r30, r14
    9564:	60 83       	st	Z, r22
    9566:	71 83       	std	Z+1, r23	; 0x01
    9568:	82 83       	std	Z+2, r24	; 0x02
    956a:	93 83       	std	Z+3, r25	; 0x03
	frdGyroZRs = -(rawGyroZ - gyroOffsets[2]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    956c:	7e 01       	movw	r14, r28
    956e:	f6 e4       	ldi	r31, 0x46	; 70
    9570:	ef 0e       	add	r14, r31
    9572:	f1 1c       	adc	r15, r1
    9574:	68 a9       	ldd	r22, Y+48	; 0x30
    9576:	79 a9       	ldd	r23, Y+49	; 0x31
    9578:	88 27       	eor	r24, r24
    957a:	77 fd       	sbrc	r23, 7
    957c:	80 95       	com	r24
    957e:	98 2f       	mov	r25, r24
    9580:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9584:	cc 5a       	subi	r28, 0xAC	; 172
    9586:	df 4f       	sbci	r29, 0xFF	; 255
    9588:	28 81       	ld	r18, Y
    958a:	39 81       	ldd	r19, Y+1	; 0x01
    958c:	4a 81       	ldd	r20, Y+2	; 0x02
    958e:	5b 81       	ldd	r21, Y+3	; 0x03
    9590:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    9594:	90 58       	subi	r25, 0x80	; 128
    9596:	25 ea       	ldi	r18, 0xA5	; 165
    9598:	39 ee       	ldi	r19, 0xE9	; 233
    959a:	4a e6       	ldi	r20, 0x6A	; 106
    959c:	54 e4       	ldi	r21, 0x44	; 68
    959e:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    95a2:	f7 01       	movw	r30, r14
    95a4:	60 83       	st	Z, r22
    95a6:	71 83       	std	Z+1, r23	; 0x01
    95a8:	82 83       	std	Z+2, r24	; 0x02
    95aa:	93 83       	std	Z+3, r25	; 0x03
	
	
}
    95ac:	df 91       	pop	r29
    95ae:	cf 91       	pop	r28
    95b0:	ff 90       	pop	r15
    95b2:	ef 90       	pop	r14
    95b4:	df 90       	pop	r13
    95b6:	cf 90       	pop	r12
    95b8:	bf 90       	pop	r11
    95ba:	af 90       	pop	r10
    95bc:	9f 90       	pop	r9
    95be:	8f 90       	pop	r8
    95c0:	08 95       	ret

000095c2 <_ZN10helicopter7sensors9IMUSensor4initEv>:
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 8192;



void IMUSensor::init()
{
    95c2:	2f 92       	push	r2
    95c4:	3f 92       	push	r3
    95c6:	4f 92       	push	r4
    95c8:	5f 92       	push	r5
    95ca:	6f 92       	push	r6
    95cc:	7f 92       	push	r7
    95ce:	8f 92       	push	r8
    95d0:	9f 92       	push	r9
    95d2:	af 92       	push	r10
    95d4:	bf 92       	push	r11
    95d6:	cf 92       	push	r12
    95d8:	df 92       	push	r13
    95da:	ef 92       	push	r14
    95dc:	ff 92       	push	r15
    95de:	0f 93       	push	r16
    95e0:	1f 93       	push	r17
    95e2:	cf 93       	push	r28
    95e4:	df 93       	push	r29
    95e6:	cd b7       	in	r28, 0x3d	; 61
    95e8:	de b7       	in	r29, 0x3e	; 62
    95ea:	af 97       	sbiw	r28, 0x2f	; 47
    95ec:	0f b6       	in	r0, 0x3f	; 63
    95ee:	f8 94       	cli
    95f0:	de bf       	out	0x3e, r29	; 62
    95f2:	0f be       	out	0x3f, r0	; 63
    95f4:	cd bf       	out	0x3d, r28	; 61
    95f6:	99 87       	std	Y+9, r25	; 0x09
    95f8:	88 87       	std	Y+8, r24	; 0x08
	
	//Reset the sensor in case of a soft reset the sensor
	//might still have had power and thus not reset.
	//End the transaction. If I don't close and restart a new
	//transaction, accelerometer data doesn't seem to be able to be read.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_DEVICE_RESET);
    95fa:	40 e8       	ldi	r20, 0x80	; 128
    95fc:	6b e6       	ldi	r22, 0x6B	; 107
    95fe:	dc 01       	movw	r26, r24
    9600:	94 96       	adiw	r26, 0x24	; 36
    9602:	8d 91       	ld	r24, X+
    9604:	9c 91       	ld	r25, X
    9606:	95 97       	sbiw	r26, 0x25	; 37
    9608:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    960c:	bf ef       	ldi	r27, 0xFF	; 255
    960e:	e1 ee       	ldi	r30, 0xE1	; 225
    9610:	f4 e0       	ldi	r31, 0x04	; 4
    9612:	b1 50       	subi	r27, 0x01	; 1
    9614:	e0 40       	sbci	r30, 0x00	; 0
    9616:	f0 40       	sbci	r31, 0x00	; 0
    9618:	e1 f7       	brne	.-8      	; 0x9612 <_ZN10helicopter7sensors9IMUSensor4initEv+0x50>
    961a:	00 c0       	rjmp	.+0      	; 0x961c <_ZN10helicopter7sensors9IMUSensor4initEv+0x5a>
    961c:	00 00       	nop
	//wait for device reset
	_delay_ms(100);

	//Select Gyro Z as the reference clock. Selecting a gyro clock
	//is recommended in pag 41 of RM-MPU-6000A.pdf for improved stability.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_CLKSEL_GYROZ);
    961e:	43 e0       	ldi	r20, 0x03	; 3
    9620:	6b e6       	ldi	r22, 0x6B	; 107
    9622:	a8 85       	ldd	r26, Y+8	; 0x08
    9624:	b9 85       	ldd	r27, Y+9	; 0x09
    9626:	94 96       	adiw	r26, 0x24	; 36
    9628:	8d 91       	ld	r24, X+
    962a:	9c 91       	ld	r25, X
    962c:	95 97       	sbiw	r26, 0x25	; 37
    962e:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9632:	bf ef       	ldi	r27, 0xFF	; 255
    9634:	e1 ee       	ldi	r30, 0xE1	; 225
    9636:	f4 e0       	ldi	r31, 0x04	; 4
    9638:	b1 50       	subi	r27, 0x01	; 1
    963a:	e0 40       	sbci	r30, 0x00	; 0
    963c:	f0 40       	sbci	r31, 0x00	; 0
    963e:	e1 f7       	brne	.-8      	; 0x9638 <_ZN10helicopter7sensors9IMUSensor4initEv+0x76>
    9640:	00 c0       	rjmp	.+0      	; 0x9642 <_ZN10helicopter7sensors9IMUSensor4initEv+0x80>
    9642:	00 00       	nop
	//takes a long time and reading accelerometer data
	//returns 0 unless this is done.
	_delay_ms(100);

	//Enable SPI Interface / disable i2c.
	spiDriver->transactionWrite(REG_USER_CTRL,BITS_I2C_IF_DIS);
    9644:	40 e1       	ldi	r20, 0x10	; 16
    9646:	6a e6       	ldi	r22, 0x6A	; 106
    9648:	a8 85       	ldd	r26, Y+8	; 0x08
    964a:	b9 85       	ldd	r27, Y+9	; 0x09
    964c:	94 96       	adiw	r26, 0x24	; 36
    964e:	8d 91       	ld	r24, X+
    9650:	9c 91       	ld	r25, X
    9652:	95 97       	sbiw	r26, 0x25	; 37
    9654:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Set the sampling rate to 1kHz.
	spiDriver->transactionWrite(REG_SMPLRT_DIV,BITS_SMPLRT_DIV);
    9658:	40 e0       	ldi	r20, 0x00	; 0
    965a:	69 e1       	ldi	r22, 0x19	; 25
    965c:	e8 85       	ldd	r30, Y+8	; 0x08
    965e:	f9 85       	ldd	r31, Y+9	; 0x09
    9660:	84 a1       	ldd	r24, Z+36	; 0x24
    9662:	95 a1       	ldd	r25, Z+37	; 0x25
    9664:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	
	//Configures the Digital Low Pass Filter. This is how frequently the sensor readings are updated
	//for accelerometers and gyroscopes.
	spiDriver->transactionWrite(REG_CONFIG,BITS_DLPF_CFG);
    9668:	42 e0       	ldi	r20, 0x02	; 2
    966a:	6a e1       	ldi	r22, 0x1A	; 26
    966c:	a8 85       	ldd	r26, Y+8	; 0x08
    966e:	b9 85       	ldd	r27, Y+9	; 0x09
    9670:	94 96       	adiw	r26, 0x24	; 36
    9672:	8d 91       	ld	r24, X+
    9674:	9c 91       	ld	r25, X
    9676:	95 97       	sbiw	r26, 0x25	; 37
    9678:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Configures the sensitivity / scale range of the gyroscope
	spiDriver->transactionWrite(REG_GYRO_CONFIG,BITS_FS_SEL);
    967c:	48 e1       	ldi	r20, 0x18	; 24
    967e:	6b e1       	ldi	r22, 0x1B	; 27
    9680:	e8 85       	ldd	r30, Y+8	; 0x08
    9682:	f9 85       	ldd	r31, Y+9	; 0x09
    9684:	84 a1       	ldd	r24, Z+36	; 0x24
    9686:	95 a1       	ldd	r25, Z+37	; 0x25
    9688:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//configure the sensitivity / scale range of the accelerometer
	spiDriver->transactionWrite(REG_ACCEL_CONFIG,BITS_AFS_SEL);
    968c:	48 e0       	ldi	r20, 0x08	; 8
    968e:	6c e1       	ldi	r22, 0x1C	; 28
    9690:	a8 85       	ldd	r26, Y+8	; 0x08
    9692:	b9 85       	ldd	r27, Y+9	; 0x09
    9694:	94 96       	adiw	r26, 0x24	; 36
    9696:	8d 91       	ld	r24, X+
    9698:	9c 91       	ld	r25, X
    969a:	95 97       	sbiw	r26, 0x25	; 37
    969c:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    96a0:	9d c1       	rjmp	.+826    	; 0x99dc <_ZN10helicopter7sensors9IMUSensor4initEv+0x41a>
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
		{
			this->readSensor();
    96a2:	c8 01       	movw	r24, r16
    96a4:	0e 94 e1 49 	call	0x93c2	; 0x93c2 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
    96a8:	b1 e0       	ldi	r27, 0x01	; 1
    96aa:	eb 1a       	sub	r14, r27
    96ac:	f1 08       	sbc	r15, r1
		offsety = 0.0f;
		offsetz = 0.0f;
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
    96ae:	e1 14       	cp	r14, r1
    96b0:	f1 04       	cpc	r15, r1
    96b2:	b9 f7       	brne	.-18     	; 0x96a2 <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			this->readSensor();
		}
		


		float minoffsetx = this->rawGyroX;
    96b4:	e8 85       	ldd	r30, Y+8	; 0x08
    96b6:	f9 85       	ldd	r31, Y+9	; 0x09
    96b8:	64 a5       	ldd	r22, Z+44	; 0x2c
    96ba:	75 a5       	ldd	r23, Z+45	; 0x2d
    96bc:	88 27       	eor	r24, r24
    96be:	77 fd       	sbrc	r23, 7
    96c0:	80 95       	com	r24
    96c2:	98 2f       	mov	r25, r24
    96c4:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    96c8:	6e 8b       	std	Y+22, r22	; 0x16
    96ca:	7f 8b       	std	Y+23, r23	; 0x17
    96cc:	88 8f       	std	Y+24, r24	; 0x18
    96ce:	99 8f       	std	Y+25, r25	; 0x19
		float minoffsety = this->rawGyroY;
    96d0:	a8 85       	ldd	r26, Y+8	; 0x08
    96d2:	b9 85       	ldd	r27, Y+9	; 0x09
    96d4:	9e 96       	adiw	r26, 0x2e	; 46
    96d6:	6d 91       	ld	r22, X+
    96d8:	7c 91       	ld	r23, X
    96da:	9f 97       	sbiw	r26, 0x2f	; 47
    96dc:	88 27       	eor	r24, r24
    96de:	77 fd       	sbrc	r23, 7
    96e0:	80 95       	com	r24
    96e2:	98 2f       	mov	r25, r24
    96e4:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    96e8:	6a 8f       	std	Y+26, r22	; 0x1a
    96ea:	7b 8f       	std	Y+27, r23	; 0x1b
    96ec:	8c 8f       	std	Y+28, r24	; 0x1c
    96ee:	9d 8f       	std	Y+29, r25	; 0x1d
		float minoffsetz = this->rawGyroZ;
    96f0:	e8 85       	ldd	r30, Y+8	; 0x08
    96f2:	f9 85       	ldd	r31, Y+9	; 0x09
    96f4:	60 a9       	ldd	r22, Z+48	; 0x30
    96f6:	71 a9       	ldd	r23, Z+49	; 0x31
    96f8:	88 27       	eor	r24, r24
    96fa:	77 fd       	sbrc	r23, 7
    96fc:	80 95       	com	r24
    96fe:	98 2f       	mov	r25, r24
    9700:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9704:	6e 8f       	std	Y+30, r22	; 0x1e
    9706:	7f 8f       	std	Y+31, r23	; 0x1f
    9708:	88 a3       	std	Y+32, r24	; 0x20
    970a:	99 a3       	std	Y+33, r25	; 0x21
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
    970c:	6a a7       	std	Y+42, r22	; 0x2a
    970e:	7b a7       	std	Y+43, r23	; 0x2b
    9710:	8c a7       	std	Y+44, r24	; 0x2c
    9712:	9d a7       	std	Y+45, r25	; 0x2d
		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
    9714:	fa 8d       	ldd	r31, Y+26	; 0x1a
    9716:	fe a3       	std	Y+38, r31	; 0x26
    9718:	2b 8d       	ldd	r18, Y+27	; 0x1b
    971a:	2f a3       	std	Y+39, r18	; 0x27
    971c:	3c 8d       	ldd	r19, Y+28	; 0x1c
    971e:	38 a7       	std	Y+40, r19	; 0x28
    9720:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9722:	89 a7       	std	Y+41, r24	; 0x29

		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
    9724:	9e 89       	ldd	r25, Y+22	; 0x16
    9726:	9a a3       	std	Y+34, r25	; 0x22
    9728:	af 89       	ldd	r26, Y+23	; 0x17
    972a:	ab a3       	std	Y+35, r26	; 0x23
    972c:	b8 8d       	ldd	r27, Y+24	; 0x18
    972e:	bc a3       	std	Y+36, r27	; 0x24
    9730:	e9 8d       	ldd	r30, Y+25	; 0x19
    9732:	ed a3       	std	Y+37, r30	; 0x25
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    9734:	00 e0       	ldi	r16, 0x00	; 0
    9736:	10 e0       	ldi	r17, 0x00	; 0
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
		offsetz = 0.0f;
    9738:	1a 8a       	std	Y+18, r1	; 0x12
    973a:	1b 8a       	std	Y+19, r1	; 0x13
    973c:	1c 8a       	std	Y+20, r1	; 0x14
    973e:	1d 8a       	std	Y+21, r1	; 0x15
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
    9740:	1e 86       	std	Y+14, r1	; 0x0e
    9742:	1f 86       	std	Y+15, r1	; 0x0f
    9744:	18 8a       	std	Y+16, r1	; 0x10
    9746:	19 8a       	std	Y+17, r1	; 0x11
	
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
    9748:	1a 86       	std	Y+10, r1	; 0x0a
    974a:	1b 86       	std	Y+11, r1	; 0x0b
    974c:	1c 86       	std	Y+12, r1	; 0x0c
    974e:	1d 86       	std	Y+13, r1	; 0x0d
    9750:	1f a7       	std	Y+47, r17	; 0x2f
    9752:	0e a7       	std	Y+46, r16	; 0x2e
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
		{
			this->readSensor();
    9754:	88 85       	ldd	r24, Y+8	; 0x08
    9756:	99 85       	ldd	r25, Y+9	; 0x09
    9758:	0e 94 e1 49 	call	0x93c2	; 0x93c2 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
		
			offsetx = (this->rawGyroX + i*offsetx) / (i+1);
    975c:	a8 85       	ldd	r26, Y+8	; 0x08
    975e:	b9 85       	ldd	r27, Y+9	; 0x09
    9760:	9c 96       	adiw	r26, 0x2c	; 44
    9762:	8d 91       	ld	r24, X+
    9764:	9c 91       	ld	r25, X
    9766:	9d 97       	sbiw	r26, 0x2d	; 45
    9768:	bc 01       	movw	r22, r24
    976a:	88 27       	eor	r24, r24
    976c:	77 fd       	sbrc	r23, 7
    976e:	80 95       	com	r24
    9770:	98 2f       	mov	r25, r24
    9772:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9776:	46 2e       	mov	r4, r22
    9778:	57 2e       	mov	r5, r23
    977a:	8d 83       	std	Y+5, r24	; 0x05
    977c:	9e 83       	std	Y+6, r25	; 0x06
    977e:	ee a5       	ldd	r30, Y+46	; 0x2e
    9780:	ff a5       	ldd	r31, Y+47	; 0x2f
    9782:	bf 01       	movw	r22, r30
    9784:	88 27       	eor	r24, r24
    9786:	77 fd       	sbrc	r23, 7
    9788:	80 95       	com	r24
    978a:	98 2f       	mov	r25, r24
    978c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9790:	4b 01       	movw	r8, r22
    9792:	5c 01       	movw	r10, r24
    9794:	2a 85       	ldd	r18, Y+10	; 0x0a
    9796:	3b 85       	ldd	r19, Y+11	; 0x0b
    9798:	4c 85       	ldd	r20, Y+12	; 0x0c
    979a:	5d 85       	ldd	r21, Y+13	; 0x0d
    979c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    97a0:	9b 01       	movw	r18, r22
    97a2:	ac 01       	movw	r20, r24
    97a4:	64 2d       	mov	r22, r4
    97a6:	75 2d       	mov	r23, r5
    97a8:	8d 81       	ldd	r24, Y+5	; 0x05
    97aa:	9e 81       	ldd	r25, Y+6	; 0x06
    97ac:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    97b0:	69 83       	std	Y+1, r22	; 0x01
    97b2:	7a 83       	std	Y+2, r23	; 0x02
    97b4:	8b 83       	std	Y+3, r24	; 0x03
    97b6:	9c 83       	std	Y+4, r25	; 0x04
    97b8:	2e a5       	ldd	r18, Y+46	; 0x2e
    97ba:	3f a5       	ldd	r19, Y+47	; 0x2f
    97bc:	2f 5f       	subi	r18, 0xFF	; 255
    97be:	3f 4f       	sbci	r19, 0xFF	; 255
    97c0:	3f a7       	std	Y+47, r19	; 0x2f
    97c2:	2e a7       	std	Y+46, r18	; 0x2e
    97c4:	b9 01       	movw	r22, r18
    97c6:	88 27       	eor	r24, r24
    97c8:	77 fd       	sbrc	r23, 7
    97ca:	80 95       	com	r24
    97cc:	98 2f       	mov	r25, r24
    97ce:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    97d2:	6b 01       	movw	r12, r22
    97d4:	7c 01       	movw	r14, r24
    97d6:	9b 01       	movw	r18, r22
    97d8:	ac 01       	movw	r20, r24
    97da:	69 81       	ldd	r22, Y+1	; 0x01
    97dc:	7a 81       	ldd	r23, Y+2	; 0x02
    97de:	8b 81       	ldd	r24, Y+3	; 0x03
    97e0:	9c 81       	ldd	r25, Y+4	; 0x04
    97e2:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    97e6:	6a 87       	std	Y+10, r22	; 0x0a
    97e8:	7b 87       	std	Y+11, r23	; 0x0b
    97ea:	8c 87       	std	Y+12, r24	; 0x0c
    97ec:	9d 87       	std	Y+13, r25	; 0x0d
			offsety = (this->rawGyroY + i*offsety) / (i+1);
    97ee:	a8 85       	ldd	r26, Y+8	; 0x08
    97f0:	b9 85       	ldd	r27, Y+9	; 0x09
    97f2:	9e 96       	adiw	r26, 0x2e	; 46
    97f4:	8d 91       	ld	r24, X+
    97f6:	9c 91       	ld	r25, X
    97f8:	9f 97       	sbiw	r26, 0x2f	; 47
    97fa:	bc 01       	movw	r22, r24
    97fc:	88 27       	eor	r24, r24
    97fe:	77 fd       	sbrc	r23, 7
    9800:	80 95       	com	r24
    9802:	98 2f       	mov	r25, r24
    9804:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9808:	66 2e       	mov	r6, r22
    980a:	77 2e       	mov	r7, r23
    980c:	08 2f       	mov	r16, r24
    980e:	19 2f       	mov	r17, r25
    9810:	a5 01       	movw	r20, r10
    9812:	94 01       	movw	r18, r8
    9814:	6e 85       	ldd	r22, Y+14	; 0x0e
    9816:	7f 85       	ldd	r23, Y+15	; 0x0f
    9818:	88 89       	ldd	r24, Y+16	; 0x10
    981a:	99 89       	ldd	r25, Y+17	; 0x11
    981c:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    9820:	9b 01       	movw	r18, r22
    9822:	ac 01       	movw	r20, r24
    9824:	66 2d       	mov	r22, r6
    9826:	77 2d       	mov	r23, r7
    9828:	80 2f       	mov	r24, r16
    982a:	91 2f       	mov	r25, r17
    982c:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    9830:	a7 01       	movw	r20, r14
    9832:	96 01       	movw	r18, r12
    9834:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    9838:	6e 87       	std	Y+14, r22	; 0x0e
    983a:	7f 87       	std	Y+15, r23	; 0x0f
    983c:	88 8b       	std	Y+16, r24	; 0x10
    983e:	99 8b       	std	Y+17, r25	; 0x11
			offsetz = (this->rawGyroZ + i*offsetz) / (i+1);
    9840:	e8 85       	ldd	r30, Y+8	; 0x08
    9842:	f9 85       	ldd	r31, Y+9	; 0x09
    9844:	20 a9       	ldd	r18, Z+48	; 0x30
    9846:	31 a9       	ldd	r19, Z+49	; 0x31
    9848:	b9 01       	movw	r22, r18
    984a:	88 27       	eor	r24, r24
    984c:	77 fd       	sbrc	r23, 7
    984e:	80 95       	com	r24
    9850:	98 2f       	mov	r25, r24
    9852:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9856:	26 2e       	mov	r2, r22
    9858:	37 2e       	mov	r3, r23
    985a:	89 83       	std	Y+1, r24	; 0x01
    985c:	9f 83       	std	Y+7, r25	; 0x07
    985e:	a5 01       	movw	r20, r10
    9860:	94 01       	movw	r18, r8
    9862:	6a 89       	ldd	r22, Y+18	; 0x12
    9864:	7b 89       	ldd	r23, Y+19	; 0x13
    9866:	8c 89       	ldd	r24, Y+20	; 0x14
    9868:	9d 89       	ldd	r25, Y+21	; 0x15
    986a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    986e:	9b 01       	movw	r18, r22
    9870:	ac 01       	movw	r20, r24
    9872:	62 2d       	mov	r22, r2
    9874:	73 2d       	mov	r23, r3
    9876:	89 81       	ldd	r24, Y+1	; 0x01
    9878:	9f 81       	ldd	r25, Y+7	; 0x07
    987a:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    987e:	a7 01       	movw	r20, r14
    9880:	96 01       	movw	r18, r12
    9882:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    9886:	6a 8b       	std	Y+18, r22	; 0x12
    9888:	7b 8b       	std	Y+19, r23	; 0x13
    988a:	8c 8b       	std	Y+20, r24	; 0x14
    988c:	9d 8b       	std	Y+21, r25	; 0x15
			
			minoffsetx = this->rawGyroX < minoffsetx ? this->rawGyroX : minoffsetx;
    988e:	2e 89       	ldd	r18, Y+22	; 0x16
    9890:	3f 89       	ldd	r19, Y+23	; 0x17
    9892:	48 8d       	ldd	r20, Y+24	; 0x18
    9894:	59 8d       	ldd	r21, Y+25	; 0x19
    9896:	64 2d       	mov	r22, r4
    9898:	75 2d       	mov	r23, r5
    989a:	8d 81       	ldd	r24, Y+5	; 0x05
    989c:	9e 81       	ldd	r25, Y+6	; 0x06
    989e:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    98a2:	88 23       	and	r24, r24
    98a4:	34 f4       	brge	.+12     	; 0x98b2 <_ZN10helicopter7sensors9IMUSensor4initEv+0x2f0>
    98a6:	4e 8a       	std	Y+22, r4	; 0x16
    98a8:	5f 8a       	std	Y+23, r5	; 0x17
    98aa:	fd 81       	ldd	r31, Y+5	; 0x05
    98ac:	f8 8f       	std	Y+24, r31	; 0x18
    98ae:	2e 81       	ldd	r18, Y+6	; 0x06
    98b0:	29 8f       	std	Y+25, r18	; 0x19
			minoffsety = this->rawGyroY < minoffsety ? this->rawGyroY : minoffsety;
    98b2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    98b4:	3b 8d       	ldd	r19, Y+27	; 0x1b
    98b6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    98b8:	5d 8d       	ldd	r21, Y+29	; 0x1d
    98ba:	66 2d       	mov	r22, r6
    98bc:	77 2d       	mov	r23, r7
    98be:	80 2f       	mov	r24, r16
    98c0:	91 2f       	mov	r25, r17
    98c2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    98c6:	88 23       	and	r24, r24
    98c8:	24 f4       	brge	.+8      	; 0x98d2 <_ZN10helicopter7sensors9IMUSensor4initEv+0x310>
    98ca:	6a 8e       	std	Y+26, r6	; 0x1a
    98cc:	7b 8e       	std	Y+27, r7	; 0x1b
    98ce:	0c 8f       	std	Y+28, r16	; 0x1c
    98d0:	1d 8f       	std	Y+29, r17	; 0x1d
			minoffsetz = this->rawGyroZ < minoffsetz ? this->rawGyroZ : minoffsetz;
    98d2:	2e 8d       	ldd	r18, Y+30	; 0x1e
    98d4:	3f 8d       	ldd	r19, Y+31	; 0x1f
    98d6:	48 a1       	ldd	r20, Y+32	; 0x20
    98d8:	59 a1       	ldd	r21, Y+33	; 0x21
    98da:	62 2d       	mov	r22, r2
    98dc:	73 2d       	mov	r23, r3
    98de:	89 81       	ldd	r24, Y+1	; 0x01
    98e0:	9f 81       	ldd	r25, Y+7	; 0x07
    98e2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    98e6:	88 23       	and	r24, r24
    98e8:	34 f4       	brge	.+12     	; 0x98f6 <_ZN10helicopter7sensors9IMUSensor4initEv+0x334>
    98ea:	2e 8e       	std	Y+30, r2	; 0x1e
    98ec:	3f 8e       	std	Y+31, r3	; 0x1f
    98ee:	39 81       	ldd	r19, Y+1	; 0x01
    98f0:	38 a3       	std	Y+32, r19	; 0x20
    98f2:	8f 81       	ldd	r24, Y+7	; 0x07
    98f4:	89 a3       	std	Y+33, r24	; 0x21
			
			maxoffsetx = this->rawGyroX > maxoffsetx ? this->rawGyroX : maxoffsetx;
    98f6:	2a a1       	ldd	r18, Y+34	; 0x22
    98f8:	3b a1       	ldd	r19, Y+35	; 0x23
    98fa:	4c a1       	ldd	r20, Y+36	; 0x24
    98fc:	5d a1       	ldd	r21, Y+37	; 0x25
    98fe:	64 2d       	mov	r22, r4
    9900:	75 2d       	mov	r23, r5
    9902:	8d 81       	ldd	r24, Y+5	; 0x05
    9904:	9e 81       	ldd	r25, Y+6	; 0x06
    9906:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    990a:	18 16       	cp	r1, r24
    990c:	34 f4       	brge	.+12     	; 0x991a <_ZN10helicopter7sensors9IMUSensor4initEv+0x358>
    990e:	4a a2       	std	Y+34, r4	; 0x22
    9910:	5b a2       	std	Y+35, r5	; 0x23
    9912:	9d 81       	ldd	r25, Y+5	; 0x05
    9914:	9c a3       	std	Y+36, r25	; 0x24
    9916:	ae 81       	ldd	r26, Y+6	; 0x06
    9918:	ad a3       	std	Y+37, r26	; 0x25
			maxoffsety = this->rawGyroY > maxoffsety ? this->rawGyroY : maxoffsety;
    991a:	2e a1       	ldd	r18, Y+38	; 0x26
    991c:	3f a1       	ldd	r19, Y+39	; 0x27
    991e:	48 a5       	ldd	r20, Y+40	; 0x28
    9920:	59 a5       	ldd	r21, Y+41	; 0x29
    9922:	66 2d       	mov	r22, r6
    9924:	77 2d       	mov	r23, r7
    9926:	80 2f       	mov	r24, r16
    9928:	91 2f       	mov	r25, r17
    992a:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    992e:	18 16       	cp	r1, r24
    9930:	24 f4       	brge	.+8      	; 0x993a <_ZN10helicopter7sensors9IMUSensor4initEv+0x378>
    9932:	6e a2       	std	Y+38, r6	; 0x26
    9934:	7f a2       	std	Y+39, r7	; 0x27
    9936:	08 a7       	std	Y+40, r16	; 0x28
    9938:	19 a7       	std	Y+41, r17	; 0x29
			maxoffsetz = this->rawGyroZ > maxoffsetz ? this->rawGyroZ : maxoffsetz;
    993a:	2a a5       	ldd	r18, Y+42	; 0x2a
    993c:	3b a5       	ldd	r19, Y+43	; 0x2b
    993e:	4c a5       	ldd	r20, Y+44	; 0x2c
    9940:	5d a5       	ldd	r21, Y+45	; 0x2d
    9942:	62 2d       	mov	r22, r2
    9944:	73 2d       	mov	r23, r3
    9946:	89 81       	ldd	r24, Y+1	; 0x01
    9948:	9f 81       	ldd	r25, Y+7	; 0x07
    994a:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    994e:	18 16       	cp	r1, r24
    9950:	34 f4       	brge	.+12     	; 0x995e <_ZN10helicopter7sensors9IMUSensor4initEv+0x39c>
    9952:	2a a6       	std	Y+42, r2	; 0x2a
    9954:	3b a6       	std	Y+43, r3	; 0x2b
    9956:	b9 81       	ldd	r27, Y+1	; 0x01
    9958:	bc a7       	std	Y+44, r27	; 0x2c
    995a:	ef 81       	ldd	r30, Y+7	; 0x07
    995c:	ed a7       	std	Y+45, r30	; 0x2d
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    995e:	2e a5       	ldd	r18, Y+46	; 0x2e
    9960:	3f a5       	ldd	r19, Y+47	; 0x2f
    9962:	28 3e       	cpi	r18, 0xE8	; 232
    9964:	33 40       	sbci	r19, 0x03	; 3
    9966:	09 f0       	breq	.+2      	; 0x996a <_ZN10helicopter7sensors9IMUSensor4initEv+0x3a8>
    9968:	f5 ce       	rjmp	.-534    	; 0x9754 <_ZN10helicopter7sensors9IMUSensor4initEv+0x192>
			
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
    996a:	2e 89       	ldd	r18, Y+22	; 0x16
    996c:	3f 89       	ldd	r19, Y+23	; 0x17
    996e:	48 8d       	ldd	r20, Y+24	; 0x18
    9970:	59 8d       	ldd	r21, Y+25	; 0x19
    9972:	6a a1       	ldd	r22, Y+34	; 0x22
    9974:	7b a1       	ldd	r23, Y+35	; 0x23
    9976:	8c a1       	ldd	r24, Y+36	; 0x24
    9978:	9d a1       	ldd	r25, Y+37	; 0x25
    997a:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    997e:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    9980:	20 e0       	ldi	r18, 0x00	; 0
    9982:	30 e0       	ldi	r19, 0x00	; 0
    9984:	40 e2       	ldi	r20, 0x20	; 32
    9986:	51 e4       	ldi	r21, 0x41	; 65
    9988:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    998c:	88 23       	and	r24, r24
    998e:	34 f5       	brge	.+76     	; 0x99dc <_ZN10helicopter7sensors9IMUSensor4initEv+0x41a>
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
    9990:	2a 8d       	ldd	r18, Y+26	; 0x1a
    9992:	3b 8d       	ldd	r19, Y+27	; 0x1b
    9994:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9996:	5d 8d       	ldd	r21, Y+29	; 0x1d
    9998:	6e a1       	ldd	r22, Y+38	; 0x26
    999a:	7f a1       	ldd	r23, Y+39	; 0x27
    999c:	88 a5       	ldd	r24, Y+40	; 0x28
    999e:	99 a5       	ldd	r25, Y+41	; 0x29
    99a0:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    99a4:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    99a6:	20 e0       	ldi	r18, 0x00	; 0
    99a8:	30 e0       	ldi	r19, 0x00	; 0
    99aa:	40 e2       	ldi	r20, 0x20	; 32
    99ac:	51 e4       	ldi	r21, 0x41	; 65
    99ae:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    99b2:	88 23       	and	r24, r24
    99b4:	9c f4       	brge	.+38     	; 0x99dc <_ZN10helicopter7sensors9IMUSensor4initEv+0x41a>
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
		float differenceZ = fabs(maxoffsetz - minoffsetz);
    99b6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    99b8:	3f 8d       	ldd	r19, Y+31	; 0x1f
    99ba:	48 a1       	ldd	r20, Y+32	; 0x20
    99bc:	59 a1       	ldd	r21, Y+33	; 0x21
    99be:	6a a5       	ldd	r22, Y+42	; 0x2a
    99c0:	7b a5       	ldd	r23, Y+43	; 0x2b
    99c2:	8c a5       	ldd	r24, Y+44	; 0x2c
    99c4:	9d a5       	ldd	r25, Y+45	; 0x2d
    99c6:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    99ca:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    99cc:	20 e0       	ldi	r18, 0x00	; 0
    99ce:	30 e0       	ldi	r19, 0x00	; 0
    99d0:	40 e2       	ldi	r20, 0x20	; 32
    99d2:	51 e4       	ldi	r21, 0x41	; 65
    99d4:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    99d8:	88 23       	and	r24, r24
    99da:	44 f0       	brlt	.+16     	; 0x99ec <_ZN10helicopter7sensors9IMUSensor4initEv+0x42a>
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 8192;



void IMUSensor::init()
{
    99dc:	0f 2e       	mov	r0, r31
    99de:	f4 e1       	ldi	r31, 0x14	; 20
    99e0:	ef 2e       	mov	r14, r31
    99e2:	f0 2d       	mov	r31, r0
    99e4:	f1 2c       	mov	r15, r1
    99e6:	08 85       	ldd	r16, Y+8	; 0x08
    99e8:	19 85       	ldd	r17, Y+9	; 0x09
    99ea:	5b ce       	rjmp	.-842    	; 0x96a2 <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			isStable = true;
		}
		
	}
	
	this->gyroOffsets[0] = offsetx;
    99ec:	28 85       	ldd	r18, Y+8	; 0x08
    99ee:	39 85       	ldd	r19, Y+9	; 0x09
    99f0:	24 5b       	subi	r18, 0xB4	; 180
    99f2:	3f 4f       	sbci	r19, 0xFF	; 255
    99f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    99f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    99f8:	ac 85       	ldd	r26, Y+12	; 0x0c
    99fa:	bd 85       	ldd	r27, Y+13	; 0x0d
    99fc:	f9 01       	movw	r30, r18
    99fe:	80 83       	st	Z, r24
    9a00:	91 83       	std	Z+1, r25	; 0x01
    9a02:	a2 83       	std	Z+2, r26	; 0x02
    9a04:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[1] = offsety;
    9a06:	28 85       	ldd	r18, Y+8	; 0x08
    9a08:	39 85       	ldd	r19, Y+9	; 0x09
    9a0a:	20 5b       	subi	r18, 0xB0	; 176
    9a0c:	3f 4f       	sbci	r19, 0xFF	; 255
    9a0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    9a10:	9f 85       	ldd	r25, Y+15	; 0x0f
    9a12:	a8 89       	ldd	r26, Y+16	; 0x10
    9a14:	b9 89       	ldd	r27, Y+17	; 0x11
    9a16:	f9 01       	movw	r30, r18
    9a18:	80 83       	st	Z, r24
    9a1a:	91 83       	std	Z+1, r25	; 0x01
    9a1c:	a2 83       	std	Z+2, r26	; 0x02
    9a1e:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[2] = offsetz;
    9a20:	28 85       	ldd	r18, Y+8	; 0x08
    9a22:	39 85       	ldd	r19, Y+9	; 0x09
    9a24:	2c 5a       	subi	r18, 0xAC	; 172
    9a26:	3f 4f       	sbci	r19, 0xFF	; 255
    9a28:	8a 89       	ldd	r24, Y+18	; 0x12
    9a2a:	9b 89       	ldd	r25, Y+19	; 0x13
    9a2c:	ac 89       	ldd	r26, Y+20	; 0x14
    9a2e:	bd 89       	ldd	r27, Y+21	; 0x15
    9a30:	f9 01       	movw	r30, r18
    9a32:	80 83       	st	Z, r24
    9a34:	91 83       	std	Z+1, r25	; 0x01
    9a36:	a2 83       	std	Z+2, r26	; 0x02
    9a38:	b3 83       	std	Z+3, r27	; 0x03
	
}
    9a3a:	af 96       	adiw	r28, 0x2f	; 47
    9a3c:	0f b6       	in	r0, 0x3f	; 63
    9a3e:	f8 94       	cli
    9a40:	de bf       	out	0x3e, r29	; 62
    9a42:	0f be       	out	0x3f, r0	; 63
    9a44:	cd bf       	out	0x3d, r28	; 61
    9a46:	df 91       	pop	r29
    9a48:	cf 91       	pop	r28
    9a4a:	1f 91       	pop	r17
    9a4c:	0f 91       	pop	r16
    9a4e:	ff 90       	pop	r15
    9a50:	ef 90       	pop	r14
    9a52:	df 90       	pop	r13
    9a54:	cf 90       	pop	r12
    9a56:	bf 90       	pop	r11
    9a58:	af 90       	pop	r10
    9a5a:	9f 90       	pop	r9
    9a5c:	8f 90       	pop	r8
    9a5e:	7f 90       	pop	r7
    9a60:	6f 90       	pop	r6
    9a62:	5f 90       	pop	r5
    9a64:	4f 90       	pop	r4
    9a66:	3f 90       	pop	r3
    9a68:	2f 90       	pop	r2
    9a6a:	08 95       	ret

00009a6c <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>:
		_offset[1] = new_offsets[1];
		_offset[2] = new_offsets[2];
	
}

MagnetometerSensor::MagnetometerSensor(TWIDriver *driver):
    9a6c:	cf 92       	push	r12
    9a6e:	df 92       	push	r13
    9a70:	ef 92       	push	r14
    9a72:	ff 92       	push	r15
    9a74:	0f 93       	push	r16
    9a76:	1f 93       	push	r17
    9a78:	fc 01       	movw	r30, r24
	rawMagY(0),
	rawMagZ(0),
	frdMagX(0),
	frdMagY(0),
	frdMagZ(0),
	driver(driver)
    9a7a:	11 82       	std	Z+1, r1	; 0x01
    9a7c:	10 82       	st	Z, r1
    9a7e:	13 82       	std	Z+3, r1	; 0x03
    9a80:	12 82       	std	Z+2, r1	; 0x02
    9a82:	15 82       	std	Z+5, r1	; 0x05
    9a84:	14 82       	std	Z+4, r1	; 0x04
    9a86:	16 82       	std	Z+6, r1	; 0x06
    9a88:	17 82       	std	Z+7, r1	; 0x07
    9a8a:	10 86       	std	Z+8, r1	; 0x08
    9a8c:	11 86       	std	Z+9, r1	; 0x09
    9a8e:	12 86       	std	Z+10, r1	; 0x0a
    9a90:	13 86       	std	Z+11, r1	; 0x0b
    9a92:	14 86       	std	Z+12, r1	; 0x0c
    9a94:	15 86       	std	Z+13, r1	; 0x0d
    9a96:	16 86       	std	Z+14, r1	; 0x0e
    9a98:	17 86       	std	Z+15, r1	; 0x0f
    9a9a:	10 8a       	std	Z+16, r1	; 0x10
    9a9c:	11 8a       	std	Z+17, r1	; 0x11
    9a9e:	77 ab       	std	Z+55, r23	; 0x37
    9aa0:	66 ab       	std	Z+54, r22	; 0x36
	/**
		* Create a rotation matrix to rotate the magnetometer sensor data by
		* 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
		* counterclockwise on the Z axis.
		*/
	memset(magLBUToFRDRotationMatrix,0,sizeof(magLBUToFRDRotationMatrix));
    9aa2:	6c 01       	movw	r12, r24
    9aa4:	82 e1       	ldi	r24, 0x12	; 18
    9aa6:	c8 0e       	add	r12, r24
    9aa8:	d1 1c       	adc	r13, r1
    9aaa:	84 e2       	ldi	r24, 0x24	; 36
    9aac:	f6 01       	movw	r30, r12
    9aae:	11 92       	st	Z+, r1
    9ab0:	8a 95       	dec	r24
    9ab2:	e9 f7       	brne	.-6      	; 0x9aae <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE+0x42>
					
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
	MatrixUtil::CreateRotationMatrix(0.0f, 0.0f, (M_PI/2.0f), magLBUToFRDRotationMatrix);
    9ab4:	1b ed       	ldi	r17, 0xDB	; 219
    9ab6:	e1 2e       	mov	r14, r17
    9ab8:	1f e0       	ldi	r17, 0x0F	; 15
    9aba:	f1 2e       	mov	r15, r17
    9abc:	09 ec       	ldi	r16, 0xC9	; 201
    9abe:	1f e3       	ldi	r17, 0x3F	; 63
    9ac0:	20 e0       	ldi	r18, 0x00	; 0
    9ac2:	30 e0       	ldi	r19, 0x00	; 0
    9ac4:	a9 01       	movw	r20, r18
    9ac6:	ca 01       	movw	r24, r20
    9ac8:	b9 01       	movw	r22, r18
    9aca:	0e 94 8c 63 	call	0xc718	; 0xc718 <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
}
    9ace:	1f 91       	pop	r17
    9ad0:	0f 91       	pop	r16
    9ad2:	ff 90       	pop	r15
    9ad4:	ef 90       	pop	r14
    9ad6:	df 90       	pop	r13
    9ad8:	cf 90       	pop	r12
    9ada:	08 95       	ret

00009adc <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>:


float _offsets2[3] = {0};
float previousMag[3] = {.001, .001, .001};
int MagnetometerSensor::readSensor()
{
    9adc:	0f 93       	push	r16
    9ade:	1f 93       	push	r17
    9ae0:	cf 93       	push	r28
    9ae2:	df 93       	push	r29
    9ae4:	cd b7       	in	r28, 0x3d	; 61
    9ae6:	de b7       	in	r29, 0x3e	; 62
    9ae8:	64 97       	sbiw	r28, 0x14	; 20
    9aea:	0f b6       	in	r0, 0x3f	; 63
    9aec:	f8 94       	cli
    9aee:	de bf       	out	0x3e, r29	; 62
    9af0:	0f be       	out	0x3f, r0	; 63
    9af2:	cd bf       	out	0x3d, r28	; 61
    9af4:	8c 01       	movw	r16, r24
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    9af6:	fc 01       	movw	r30, r24
    9af8:	86 a9       	ldd	r24, Z+54	; 0x36
    9afa:	97 a9       	ldd	r25, Z+55	; 0x37
    9afc:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9b00:	81 11       	cpse	r24, r1
    9b02:	08 c0       	rjmp	.+16     	; 0x9b14 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x38>
    9b04:	f8 01       	movw	r30, r16
    9b06:	86 a9       	ldd	r24, Z+54	; 0x36
    9b08:	97 a9       	ldd	r25, Z+55	; 0x37
    9b0a:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9b0e:	8f ef       	ldi	r24, 0xFF	; 255
    9b10:	9f ef       	ldi	r25, 0xFF	; 255
    9b12:	67 c1       	rjmp	.+718    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		driver->stop();
		return -1;
	}*/		
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK));
    9b14:	48 e1       	ldi	r20, 0x18	; 24
    9b16:	6c e3       	ldi	r22, 0x3C	; 60
    9b18:	f8 01       	movw	r30, r16
    9b1a:	86 a9       	ldd	r24, Z+54	; 0x36
    9b1c:	97 a9       	ldd	r25, Z+55	; 0x37
    9b1e:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9b22:	81 11       	cpse	r24, r1
    9b24:	08 c0       	rjmp	.+16     	; 0x9b36 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x5a>
    9b26:	f8 01       	movw	r30, r16
    9b28:	86 a9       	ldd	r24, Z+54	; 0x36
    9b2a:	97 a9       	ldd	r25, Z+55	; 0x37
    9b2c:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9b30:	8f ef       	ldi	r24, 0xFF	; 255
    9b32:	9f ef       	ldi	r25, 0xFF	; 255
    9b34:	56 c1       	rjmp	.+684    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	/*if (!driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK));
    9b36:	48 e2       	ldi	r20, 0x28	; 40
    9b38:	63 e0       	ldi	r22, 0x03	; 3
    9b3a:	f8 01       	movw	r30, r16
    9b3c:	86 a9       	ldd	r24, Z+54	; 0x36
    9b3e:	97 a9       	ldd	r25, Z+55	; 0x37
    9b40:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9b44:	81 11       	cpse	r24, r1
    9b46:	08 c0       	rjmp	.+16     	; 0x9b58 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x7c>
    9b48:	f8 01       	movw	r30, r16
    9b4a:	86 a9       	ldd	r24, Z+54	; 0x36
    9b4c:	97 a9       	ldd	r25, Z+55	; 0x37
    9b4e:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9b52:	8f ef       	ldi	r24, 0xFF	; 255
    9b54:	9f ef       	ldi	r25, 0xFF	; 255
    9b56:	45 c1       	rjmp	.+650    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    9b58:	f8 01       	movw	r30, r16
    9b5a:	86 a9       	ldd	r24, Z+54	; 0x36
    9b5c:	97 a9       	ldd	r25, Z+55	; 0x37
    9b5e:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9b62:	81 11       	cpse	r24, r1
    9b64:	08 c0       	rjmp	.+16     	; 0x9b76 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x9a>
    9b66:	f8 01       	movw	r30, r16
    9b68:	86 a9       	ldd	r24, Z+54	; 0x36
    9b6a:	97 a9       	ldd	r25, Z+55	; 0x37
    9b6c:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9b70:	8f ef       	ldi	r24, 0xFF	; 255
    9b72:	9f ef       	ldi	r25, 0xFF	; 255
    9b74:	36 c1       	rjmp	.+620    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK));
    9b76:	40 e4       	ldi	r20, 0x40	; 64
    9b78:	6d e3       	ldi	r22, 0x3D	; 61
    9b7a:	f8 01       	movw	r30, r16
    9b7c:	86 a9       	ldd	r24, Z+54	; 0x36
    9b7e:	97 a9       	ldd	r25, Z+55	; 0x37
    9b80:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9b84:	81 11       	cpse	r24, r1
    9b86:	08 c0       	rjmp	.+16     	; 0x9b98 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xbc>
    9b88:	f8 01       	movw	r30, r16
    9b8a:	86 a9       	ldd	r24, Z+54	; 0x36
    9b8c:	97 a9       	ldd	r25, Z+55	; 0x37
    9b8e:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9b92:	8f ef       	ldi	r24, 0xFF	; 255
    9b94:	9f ef       	ldi	r25, 0xFF	; 255
    9b96:	25 c1       	rjmp	.+586    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	
	
		
	byte highByte = 0;
    9b98:	1c 8a       	std	Y+20, r1	; 0x14
	byte lowByte = 0;
    9b9a:	1b 8a       	std	Y+19, r1	; 0x13
		
	CHECK(driver->readByte(true, highByte));
    9b9c:	ae 01       	movw	r20, r28
    9b9e:	4c 5e       	subi	r20, 0xEC	; 236
    9ba0:	5f 4f       	sbci	r21, 0xFF	; 255
    9ba2:	61 e0       	ldi	r22, 0x01	; 1
    9ba4:	f8 01       	movw	r30, r16
    9ba6:	86 a9       	ldd	r24, Z+54	; 0x36
    9ba8:	97 a9       	ldd	r25, Z+55	; 0x37
    9baa:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9bae:	81 11       	cpse	r24, r1
    9bb0:	08 c0       	rjmp	.+16     	; 0x9bc2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xe6>
    9bb2:	f8 01       	movw	r30, r16
    9bb4:	86 a9       	ldd	r24, Z+54	; 0x36
    9bb6:	97 a9       	ldd	r25, Z+55	; 0x37
    9bb8:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9bbc:	8f ef       	ldi	r24, 0xFF	; 255
    9bbe:	9f ef       	ldi	r25, 0xFF	; 255
    9bc0:	10 c1       	rjmp	.+544    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	CHECK(driver->readByte(true, lowByte));
    9bc2:	ae 01       	movw	r20, r28
    9bc4:	4d 5e       	subi	r20, 0xED	; 237
    9bc6:	5f 4f       	sbci	r21, 0xFF	; 255
    9bc8:	61 e0       	ldi	r22, 0x01	; 1
    9bca:	f8 01       	movw	r30, r16
    9bcc:	86 a9       	ldd	r24, Z+54	; 0x36
    9bce:	97 a9       	ldd	r25, Z+55	; 0x37
    9bd0:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9bd4:	81 11       	cpse	r24, r1
    9bd6:	08 c0       	rjmp	.+16     	; 0x9be8 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x10c>
    9bd8:	f8 01       	movw	r30, r16
    9bda:	86 a9       	ldd	r24, Z+54	; 0x36
    9bdc:	97 a9       	ldd	r25, Z+55	; 0x37
    9bde:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9be2:	8f ef       	ldi	r24, 0xFF	; 255
    9be4:	9f ef       	ldi	r25, 0xFF	; 255
    9be6:	fd c0       	rjmp	.+506    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	rawMagX = (highByte << 8) | (lowByte);
    9be8:	8c 89       	ldd	r24, Y+20	; 0x14
    9bea:	90 e0       	ldi	r25, 0x00	; 0
    9bec:	98 2f       	mov	r25, r24
    9bee:	88 27       	eor	r24, r24
    9bf0:	2b 89       	ldd	r18, Y+19	; 0x13
    9bf2:	82 2b       	or	r24, r18
    9bf4:	f8 01       	movw	r30, r16
    9bf6:	91 83       	std	Z+1, r25	; 0x01
    9bf8:	80 83       	st	Z, r24
		
	CHECK(driver->readByte(true, highByte));
    9bfa:	ae 01       	movw	r20, r28
    9bfc:	4c 5e       	subi	r20, 0xEC	; 236
    9bfe:	5f 4f       	sbci	r21, 0xFF	; 255
    9c00:	61 e0       	ldi	r22, 0x01	; 1
    9c02:	86 a9       	ldd	r24, Z+54	; 0x36
    9c04:	97 a9       	ldd	r25, Z+55	; 0x37
    9c06:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9c0a:	81 11       	cpse	r24, r1
    9c0c:	08 c0       	rjmp	.+16     	; 0x9c1e <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x142>
    9c0e:	f8 01       	movw	r30, r16
    9c10:	86 a9       	ldd	r24, Z+54	; 0x36
    9c12:	97 a9       	ldd	r25, Z+55	; 0x37
    9c14:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9c18:	8f ef       	ldi	r24, 0xFF	; 255
    9c1a:	9f ef       	ldi	r25, 0xFF	; 255
    9c1c:	e2 c0       	rjmp	.+452    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	CHECK(driver->readByte(true, lowByte));
    9c1e:	ae 01       	movw	r20, r28
    9c20:	4d 5e       	subi	r20, 0xED	; 237
    9c22:	5f 4f       	sbci	r21, 0xFF	; 255
    9c24:	61 e0       	ldi	r22, 0x01	; 1
    9c26:	f8 01       	movw	r30, r16
    9c28:	86 a9       	ldd	r24, Z+54	; 0x36
    9c2a:	97 a9       	ldd	r25, Z+55	; 0x37
    9c2c:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9c30:	81 11       	cpse	r24, r1
    9c32:	08 c0       	rjmp	.+16     	; 0x9c44 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x168>
    9c34:	f8 01       	movw	r30, r16
    9c36:	86 a9       	ldd	r24, Z+54	; 0x36
    9c38:	97 a9       	ldd	r25, Z+55	; 0x37
    9c3a:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9c3e:	8f ef       	ldi	r24, 0xFF	; 255
    9c40:	9f ef       	ldi	r25, 0xFF	; 255
    9c42:	cf c0       	rjmp	.+414    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	rawMagZ = (highByte << 8) | (lowByte);
    9c44:	8c 89       	ldd	r24, Y+20	; 0x14
    9c46:	90 e0       	ldi	r25, 0x00	; 0
    9c48:	98 2f       	mov	r25, r24
    9c4a:	88 27       	eor	r24, r24
    9c4c:	2b 89       	ldd	r18, Y+19	; 0x13
    9c4e:	82 2b       	or	r24, r18
    9c50:	f8 01       	movw	r30, r16
    9c52:	95 83       	std	Z+5, r25	; 0x05
    9c54:	84 83       	std	Z+4, r24	; 0x04
		
	CHECK(driver->readByte(true, highByte));
    9c56:	ae 01       	movw	r20, r28
    9c58:	4c 5e       	subi	r20, 0xEC	; 236
    9c5a:	5f 4f       	sbci	r21, 0xFF	; 255
    9c5c:	61 e0       	ldi	r22, 0x01	; 1
    9c5e:	86 a9       	ldd	r24, Z+54	; 0x36
    9c60:	97 a9       	ldd	r25, Z+55	; 0x37
    9c62:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9c66:	81 11       	cpse	r24, r1
    9c68:	08 c0       	rjmp	.+16     	; 0x9c7a <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x19e>
    9c6a:	f8 01       	movw	r30, r16
    9c6c:	86 a9       	ldd	r24, Z+54	; 0x36
    9c6e:	97 a9       	ldd	r25, Z+55	; 0x37
    9c70:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9c74:	8f ef       	ldi	r24, 0xFF	; 255
    9c76:	9f ef       	ldi	r25, 0xFF	; 255
    9c78:	b4 c0       	rjmp	.+360    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
		
	//We don't send an acknowledgment on the last byte to be read (the magnetic Y values low byte) because of an apparent undocumented requirement by the device
	//that the nack needs to be sent to have the internal pointer go back to the magnetic X variable.
	//According to wikipedia, when in masterreceive mode, the master sends an ack bit after every byte read except for the last one. 
	CHECK(driver->readByte(false, lowByte));
    9c7a:	ae 01       	movw	r20, r28
    9c7c:	4d 5e       	subi	r20, 0xED	; 237
    9c7e:	5f 4f       	sbci	r21, 0xFF	; 255
    9c80:	60 e0       	ldi	r22, 0x00	; 0
    9c82:	f8 01       	movw	r30, r16
    9c84:	86 a9       	ldd	r24, Z+54	; 0x36
    9c86:	97 a9       	ldd	r25, Z+55	; 0x37
    9c88:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    9c8c:	81 11       	cpse	r24, r1
    9c8e:	08 c0       	rjmp	.+16     	; 0x9ca0 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1c4>
    9c90:	f8 01       	movw	r30, r16
    9c92:	86 a9       	ldd	r24, Z+54	; 0x36
    9c94:	97 a9       	ldd	r25, Z+55	; 0x37
    9c96:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <_ZN10helicopter7drivers9TWIDriver5resetEv>
    9c9a:	8f ef       	ldi	r24, 0xFF	; 255
    9c9c:	9f ef       	ldi	r25, 0xFF	; 255
    9c9e:	a1 c0       	rjmp	.+322    	; 0x9de2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x306>
	rawMagY = (highByte << 8) | (lowByte);		
    9ca0:	8c 89       	ldd	r24, Y+20	; 0x14
    9ca2:	90 e0       	ldi	r25, 0x00	; 0
    9ca4:	98 2f       	mov	r25, r24
    9ca6:	88 27       	eor	r24, r24
    9ca8:	2b 89       	ldd	r18, Y+19	; 0x13
    9caa:	82 2b       	or	r24, r18
    9cac:	f8 01       	movw	r30, r16
    9cae:	93 83       	std	Z+3, r25	; 0x03
    9cb0:	82 83       	std	Z+2, r24	; 0x02
	
	//transmit stop condition
	driver->stop();
    9cb2:	86 a9       	ldd	r24, Z+54	; 0x36
    9cb4:	97 a9       	ldd	r25, Z+55	; 0x37
    9cb6:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
		
	/**
	 * correct for magnetic interference. Code from ardupilot file found here:
	 * https://github.com/diydrones/ardupilot/blob/6af705d4554defc27aa475dab99f918b26de3ce1/libraries/AP_Compass/Compass_learn.cpp
	 */
	if (readyForOffsets)
    9cba:	80 91 25 04 	lds	r24, 0x0425
    9cbe:	88 23       	and	r24, r24
    9cc0:	09 f4       	brne	.+2      	; 0x9cc4 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1e8>
    9cc2:	46 c0       	rjmp	.+140    	; 0x9d50 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x274>
	{
		rawMagX *= calibration[0];
    9cc4:	f8 01       	movw	r30, r16
    9cc6:	60 81       	ld	r22, Z
    9cc8:	71 81       	ldd	r23, Z+1	; 0x01
    9cca:	88 27       	eor	r24, r24
    9ccc:	77 fd       	sbrc	r23, 7
    9cce:	80 95       	com	r24
    9cd0:	98 2f       	mov	r25, r24
    9cd2:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9cd6:	20 91 26 04 	lds	r18, 0x0426
    9cda:	30 91 27 04 	lds	r19, 0x0427
    9cde:	40 91 28 04 	lds	r20, 0x0428
    9ce2:	50 91 29 04 	lds	r21, 0x0429
    9ce6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    9cea:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    9cee:	f8 01       	movw	r30, r16
    9cf0:	71 83       	std	Z+1, r23	; 0x01
    9cf2:	60 83       	st	Z, r22
		rawMagY *= calibration[1];
    9cf4:	62 81       	ldd	r22, Z+2	; 0x02
    9cf6:	73 81       	ldd	r23, Z+3	; 0x03
    9cf8:	88 27       	eor	r24, r24
    9cfa:	77 fd       	sbrc	r23, 7
    9cfc:	80 95       	com	r24
    9cfe:	98 2f       	mov	r25, r24
    9d00:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9d04:	20 91 2a 04 	lds	r18, 0x042A
    9d08:	30 91 2b 04 	lds	r19, 0x042B
    9d0c:	40 91 2c 04 	lds	r20, 0x042C
    9d10:	50 91 2d 04 	lds	r21, 0x042D
    9d14:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    9d18:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    9d1c:	f8 01       	movw	r30, r16
    9d1e:	73 83       	std	Z+3, r23	; 0x03
    9d20:	62 83       	std	Z+2, r22	; 0x02
		rawMagZ *= calibration[2];
    9d22:	64 81       	ldd	r22, Z+4	; 0x04
    9d24:	75 81       	ldd	r23, Z+5	; 0x05
    9d26:	88 27       	eor	r24, r24
    9d28:	77 fd       	sbrc	r23, 7
    9d2a:	80 95       	com	r24
    9d2c:	98 2f       	mov	r25, r24
    9d2e:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9d32:	20 91 2e 04 	lds	r18, 0x042E
    9d36:	30 91 2f 04 	lds	r19, 0x042F
    9d3a:	40 91 30 04 	lds	r20, 0x0430
    9d3e:	50 91 31 04 	lds	r21, 0x0431
    9d42:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    9d46:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    9d4a:	f8 01       	movw	r30, r16
    9d4c:	75 83       	std	Z+5, r23	; 0x05
    9d4e:	64 83       	std	Z+4, r22	; 0x04
		
		
		
	
	//Convert the raw values to FRD values.
	float rotatedValues[3] = {0};
    9d50:	ae 01       	movw	r20, r28
    9d52:	4f 5f       	subi	r20, 0xFF	; 255
    9d54:	5f 4f       	sbci	r21, 0xFF	; 255
    9d56:	8c e0       	ldi	r24, 0x0C	; 12
    9d58:	fa 01       	movw	r30, r20
    9d5a:	11 92       	st	Z+, r1
    9d5c:	8a 95       	dec	r24
    9d5e:	e9 f7       	brne	.-6      	; 0x9d5a <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x27e>
	int values[3] = {rawMagX, rawMagY, rawMagZ};
    9d60:	f8 01       	movw	r30, r16
    9d62:	80 81       	ld	r24, Z
    9d64:	91 81       	ldd	r25, Z+1	; 0x01
    9d66:	9e 87       	std	Y+14, r25	; 0x0e
    9d68:	8d 87       	std	Y+13, r24	; 0x0d
    9d6a:	82 81       	ldd	r24, Z+2	; 0x02
    9d6c:	93 81       	ldd	r25, Z+3	; 0x03
    9d6e:	98 8b       	std	Y+16, r25	; 0x10
    9d70:	8f 87       	std	Y+15, r24	; 0x0f
    9d72:	84 81       	ldd	r24, Z+4	; 0x04
    9d74:	95 81       	ldd	r25, Z+5	; 0x05
    9d76:	9a 8b       	std	Y+18, r25	; 0x12
    9d78:	89 8b       	std	Y+17, r24	; 0x11
	
	MatrixUtil::RotateMatrix(magLBUToFRDRotationMatrix, values, rotatedValues);
    9d7a:	be 01       	movw	r22, r28
    9d7c:	63 5f       	subi	r22, 0xF3	; 243
    9d7e:	7f 4f       	sbci	r23, 0xFF	; 255
    9d80:	c8 01       	movw	r24, r16
    9d82:	42 96       	adiw	r24, 0x12	; 18
    9d84:	0e 94 21 65 	call	0xca42	; 0xca42 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>

	//Manually rotate in order to reduce processing
	
	/*frdMagX = rawMagY;
	frdMagY = -rawMagX;*/
	frdMagX = -rawMagY;
    9d88:	f8 01       	movw	r30, r16
    9d8a:	62 81       	ldd	r22, Z+2	; 0x02
    9d8c:	73 81       	ldd	r23, Z+3	; 0x03
    9d8e:	71 95       	neg	r23
    9d90:	61 95       	neg	r22
    9d92:	71 09       	sbc	r23, r1
    9d94:	88 27       	eor	r24, r24
    9d96:	77 fd       	sbrc	r23, 7
    9d98:	80 95       	com	r24
    9d9a:	98 2f       	mov	r25, r24
    9d9c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9da0:	f8 01       	movw	r30, r16
    9da2:	66 83       	std	Z+6, r22	; 0x06
    9da4:	77 83       	std	Z+7, r23	; 0x07
    9da6:	80 87       	std	Z+8, r24	; 0x08
    9da8:	91 87       	std	Z+9, r25	; 0x09
	frdMagY = rawMagX;
    9daa:	60 81       	ld	r22, Z
    9dac:	71 81       	ldd	r23, Z+1	; 0x01
    9dae:	88 27       	eor	r24, r24
    9db0:	77 fd       	sbrc	r23, 7
    9db2:	80 95       	com	r24
    9db4:	98 2f       	mov	r25, r24
    9db6:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9dba:	f8 01       	movw	r30, r16
    9dbc:	62 87       	std	Z+10, r22	; 0x0a
    9dbe:	73 87       	std	Z+11, r23	; 0x0b
    9dc0:	84 87       	std	Z+12, r24	; 0x0c
    9dc2:	95 87       	std	Z+13, r25	; 0x0d
	frdMagZ = rawMagZ;
    9dc4:	64 81       	ldd	r22, Z+4	; 0x04
    9dc6:	75 81       	ldd	r23, Z+5	; 0x05
    9dc8:	88 27       	eor	r24, r24
    9dca:	77 fd       	sbrc	r23, 7
    9dcc:	80 95       	com	r24
    9dce:	98 2f       	mov	r25, r24
    9dd0:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    9dd4:	f8 01       	movw	r30, r16
    9dd6:	66 87       	std	Z+14, r22	; 0x0e
    9dd8:	77 87       	std	Z+15, r23	; 0x0f
    9dda:	80 8b       	std	Z+16, r24	; 0x10
    9ddc:	91 8b       	std	Z+17, r25	; 0x11
		
		
		
		
		
	return 0;
    9dde:	80 e0       	ldi	r24, 0x00	; 0
    9de0:	90 e0       	ldi	r25, 0x00	; 0
    9de2:	64 96       	adiw	r28, 0x14	; 20
    9de4:	0f b6       	in	r0, 0x3f	; 63
    9de6:	f8 94       	cli
    9de8:	de bf       	out	0x3e, r29	; 62
    9dea:	0f be       	out	0x3f, r0	; 63
    9dec:	cd bf       	out	0x3d, r28	; 61
    9dee:	df 91       	pop	r29
    9df0:	cf 91       	pop	r28
    9df2:	1f 91       	pop	r17
    9df4:	0f 91       	pop	r16
    9df6:	08 95       	ret

00009df8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv>:

float calibration[3] = {};
bool readyForOffsets = false;

bool MagnetometerSensor::init()
{
    9df8:	2f 92       	push	r2
    9dfa:	3f 92       	push	r3
    9dfc:	4f 92       	push	r4
    9dfe:	5f 92       	push	r5
    9e00:	6f 92       	push	r6
    9e02:	7f 92       	push	r7
    9e04:	8f 92       	push	r8
    9e06:	9f 92       	push	r9
    9e08:	af 92       	push	r10
    9e0a:	bf 92       	push	r11
    9e0c:	cf 92       	push	r12
    9e0e:	df 92       	push	r13
    9e10:	ef 92       	push	r14
    9e12:	ff 92       	push	r15
    9e14:	0f 93       	push	r16
    9e16:	1f 93       	push	r17
    9e18:	cf 93       	push	r28
    9e1a:	df 93       	push	r29
    9e1c:	ec 01       	movw	r28, r24
	* Configure the output rate of the sensor, and number of samples that are averaged
	* per measurement output
	*/
	
	//Start a two wire transaction
	if(!driver->start())
    9e1e:	8e a9       	ldd	r24, Y+54	; 0x36
    9e20:	9f a9       	ldd	r25, Y+55	; 0x37
    9e22:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9e26:	f8 2e       	mov	r15, r24
    9e28:	88 23       	and	r24, r24
    9e2a:	09 f4       	brne	.+2      	; 0x9e2e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x36>
    9e2c:	a0 c2       	rjmp	.+1344   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation 
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    9e2e:	48 e1       	ldi	r20, 0x18	; 24
    9e30:	6c e3       	ldi	r22, 0x3C	; 60
    9e32:	8e a9       	ldd	r24, Y+54	; 0x36
    9e34:	9f a9       	ldd	r25, Y+55	; 0x37
    9e36:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9e3a:	f8 2e       	mov	r15, r24
    9e3c:	88 23       	and	r24, r24
    9e3e:	09 f4       	brne	.+2      	; 0x9e42 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4a>
    9e40:	96 c2       	rjmp	.+1324   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
		
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9e42:	48 e2       	ldi	r20, 0x28	; 40
    9e44:	60 e0       	ldi	r22, 0x00	; 0
    9e46:	8e a9       	ldd	r24, Y+54	; 0x36
    9e48:	9f a9       	ldd	r25, Y+55	; 0x37
    9e4a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9e4e:	f8 2e       	mov	r15, r24
    9e50:	88 23       	and	r24, r24
    9e52:	09 f4       	brne	.+2      	; 0x9e56 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5e>
    9e54:	8c c2       	rjmp	.+1304   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
		
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9e56:	48 e2       	ldi	r20, 0x28	; 40
    9e58:	68 e7       	ldi	r22, 0x78	; 120
    9e5a:	8e a9       	ldd	r24, Y+54	; 0x36
    9e5c:	9f a9       	ldd	r25, Y+55	; 0x37
    9e5e:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9e62:	f8 2e       	mov	r15, r24
    9e64:	88 23       	and	r24, r24
    9e66:	09 f4       	brne	.+2      	; 0x9e6a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x72>
    9e68:	82 c2       	rjmp	.+1284   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}	

	//end the transaction
	driver->stop();
    9e6a:	8e a9       	ldd	r24, Y+54	; 0x36
    9e6c:	9f a9       	ldd	r25, Y+55	; 0x37
    9e6e:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    9e72:	8e a9       	ldd	r24, Y+54	; 0x36
    9e74:	9f a9       	ldd	r25, Y+55	; 0x37
    9e76:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9e7a:	f8 2e       	mov	r15, r24
    9e7c:	88 23       	and	r24, r24
    9e7e:	09 f4       	brne	.+2      	; 0x9e82 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x8a>
    9e80:	76 c2       	rjmp	.+1260   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    9e82:	48 e1       	ldi	r20, 0x18	; 24
    9e84:	6c e3       	ldi	r22, 0x3C	; 60
    9e86:	8e a9       	ldd	r24, Y+54	; 0x36
    9e88:	9f a9       	ldd	r25, Y+55	; 0x37
    9e8a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9e8e:	f8 2e       	mov	r15, r24
    9e90:	88 23       	and	r24, r24
    9e92:	09 f4       	brne	.+2      	; 0x9e96 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x9e>
    9e94:	6c c2       	rjmp	.+1240   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9e96:	48 e2       	ldi	r20, 0x28	; 40
    9e98:	61 e0       	ldi	r22, 0x01	; 1
    9e9a:	8e a9       	ldd	r24, Y+54	; 0x36
    9e9c:	9f a9       	ldd	r25, Y+55	; 0x37
    9e9e:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9ea2:	f8 2e       	mov	r15, r24
    9ea4:	88 23       	and	r24, r24
    9ea6:	09 f4       	brne	.+2      	; 0x9eaa <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xb2>
    9ea8:	62 c2       	rjmp	.+1220   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(REGISTER_B_CONFIGURATION_660_GAIN, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9eaa:	48 e2       	ldi	r20, 0x28	; 40
    9eac:	60 e6       	ldi	r22, 0x60	; 96
    9eae:	8e a9       	ldd	r24, Y+54	; 0x36
    9eb0:	9f a9       	ldd	r25, Y+55	; 0x37
    9eb2:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9eb6:	f8 2e       	mov	r15, r24
    9eb8:	88 23       	and	r24, r24
    9eba:	09 f4       	brne	.+2      	; 0x9ebe <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xc6>
    9ebc:	58 c2       	rjmp	.+1200   	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    9ebe:	8e a9       	ldd	r24, Y+54	; 0x36
    9ec0:	9f a9       	ldd	r25, Y+55	; 0x37
    9ec2:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	    int numAttempts = 0, good_count = 0;
	    bool success = false;
		byte PositiveBiasConfig = 0x11;
		byte calibration_gain = 0x60;
	
	calibration[0] = 0;
    9ec6:	10 92 26 04 	sts	0x0426, r1
    9eca:	10 92 27 04 	sts	0x0427, r1
    9ece:	10 92 28 04 	sts	0x0428, r1
    9ed2:	10 92 29 04 	sts	0x0429, r1
	calibration[1] = 0;
    9ed6:	10 92 2a 04 	sts	0x042A, r1
    9eda:	10 92 2b 04 	sts	0x042B, r1
    9ede:	10 92 2c 04 	sts	0x042C, r1
    9ee2:	10 92 2d 04 	sts	0x042D, r1
	calibration[2] = 0;
    9ee6:	10 92 2e 04 	sts	0x042E, r1
    9eea:	10 92 2f 04 	sts	0x042F, r1
    9eee:	10 92 30 04 	sts	0x0430, r1
    9ef2:	10 92 31 04 	sts	0x0431, r1
	//
	float expected_x = -713;//766;
	float expected_y = 766;//713;
	float expected_z = 713;
	
	    int numAttempts = 0, good_count = 0;
    9ef6:	00 e0       	ldi	r16, 0x00	; 0
    9ef8:	10 e0       	ldi	r17, 0x00	; 0
    9efa:	21 2c       	mov	r2, r1
    9efc:	31 2c       	mov	r3, r1
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    {
        // record number of attempts at initialisation
        numAttempts++;
    9efe:	2f ef       	ldi	r18, 0xFF	; 255
    9f00:	22 1a       	sub	r2, r18
    9f02:	32 0a       	sbc	r3, r18



// force positiveBias (compass should return 715 for all channels)
	//Start a two wire transaction
	if(!driver->start())
    9f04:	8e a9       	ldd	r24, Y+54	; 0x36
    9f06:	9f a9       	ldd	r25, Y+55	; 0x37
    9f08:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9f0c:	88 23       	and	r24, r24
    9f0e:	09 f4       	brne	.+2      	; 0x9f12 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x11a>
    9f10:	17 c2       	rjmp	.+1070   	; 0xa340 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x548>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    9f12:	48 e1       	ldi	r20, 0x18	; 24
    9f14:	6c e3       	ldi	r22, 0x3C	; 60
    9f16:	8e a9       	ldd	r24, Y+54	; 0x36
    9f18:	9f a9       	ldd	r25, Y+55	; 0x37
    9f1a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9f1e:	88 23       	and	r24, r24
    9f20:	09 f4       	brne	.+2      	; 0x9f24 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x12c>
    9f22:	10 c2       	rjmp	.+1056   	; 0xa344 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x54c>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9f24:	48 e2       	ldi	r20, 0x28	; 40
    9f26:	60 e0       	ldi	r22, 0x00	; 0
    9f28:	8e a9       	ldd	r24, Y+54	; 0x36
    9f2a:	9f a9       	ldd	r25, Y+55	; 0x37
    9f2c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9f30:	88 23       	and	r24, r24
    9f32:	09 f4       	brne	.+2      	; 0x9f36 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x13e>
    9f34:	09 c2       	rjmp	.+1042   	; 0xa348 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x550>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(PositiveBiasConfig, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9f36:	48 e2       	ldi	r20, 0x28	; 40
    9f38:	61 e1       	ldi	r22, 0x11	; 17
    9f3a:	8e a9       	ldd	r24, Y+54	; 0x36
    9f3c:	9f a9       	ldd	r25, Y+55	; 0x37
    9f3e:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9f42:	88 23       	and	r24, r24
    9f44:	09 f4       	brne	.+2      	; 0x9f48 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x150>
    9f46:	02 c2       	rjmp	.+1028   	; 0xa34c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x554>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    9f48:	8e a9       	ldd	r24, Y+54	; 0x36
    9f4a:	9f a9       	ldd	r25, Y+55	; 0x37
    9f4c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    9f50:	8f ef       	ldi	r24, 0xFF	; 255
    9f52:	90 e7       	ldi	r25, 0x70	; 112
    9f54:	e2 e0       	ldi	r30, 0x02	; 2
    9f56:	81 50       	subi	r24, 0x01	; 1
    9f58:	90 40       	sbci	r25, 0x00	; 0
    9f5a:	e0 40       	sbci	r30, 0x00	; 0
    9f5c:	e1 f7       	brne	.-8      	; 0x9f56 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x15e>
    9f5e:	00 c0       	rjmp	.+0      	; 0x9f60 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x168>
    9f60:	00 00       	nop

        
        _delay_ms(50);

        // set gains
	if(!driver->start())
    9f62:	8e a9       	ldd	r24, Y+54	; 0x36
    9f64:	9f a9       	ldd	r25, Y+55	; 0x37
    9f66:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9f6a:	88 23       	and	r24, r24
    9f6c:	09 f4       	brne	.+2      	; 0x9f70 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x178>
    9f6e:	f0 c1       	rjmp	.+992    	; 0xa350 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x558>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    9f70:	48 e1       	ldi	r20, 0x18	; 24
    9f72:	6c e3       	ldi	r22, 0x3C	; 60
    9f74:	8e a9       	ldd	r24, Y+54	; 0x36
    9f76:	9f a9       	ldd	r25, Y+55	; 0x37
    9f78:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9f7c:	88 23       	and	r24, r24
    9f7e:	09 f4       	brne	.+2      	; 0x9f82 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x18a>
    9f80:	e9 c1       	rjmp	.+978    	; 0xa354 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x55c>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9f82:	48 e2       	ldi	r20, 0x28	; 40
    9f84:	61 e0       	ldi	r22, 0x01	; 1
    9f86:	8e a9       	ldd	r24, Y+54	; 0x36
    9f88:	9f a9       	ldd	r25, Y+55	; 0x37
    9f8a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9f8e:	88 23       	and	r24, r24
    9f90:	09 f4       	brne	.+2      	; 0x9f94 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x19c>
    9f92:	e2 c1       	rjmp	.+964    	; 0xa358 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x560>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(calibration_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9f94:	48 e2       	ldi	r20, 0x28	; 40
    9f96:	60 e6       	ldi	r22, 0x60	; 96
    9f98:	8e a9       	ldd	r24, Y+54	; 0x36
    9f9a:	9f a9       	ldd	r25, Y+55	; 0x37
    9f9c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9fa0:	88 23       	and	r24, r24
    9fa2:	09 f4       	brne	.+2      	; 0x9fa6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1ae>
    9fa4:	db c1       	rjmp	.+950    	; 0xa35c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x564>
	{
		return false;
	}

	//end the transaction
	driver->stop();		
    9fa6:	8e a9       	ldd	r24, Y+54	; 0x36
    9fa8:	9f a9       	ldd	r25, Y+55	; 0x37
    9faa:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    9fae:	ff ef       	ldi	r31, 0xFF	; 255
    9fb0:	20 e7       	ldi	r18, 0x70	; 112
    9fb2:	82 e0       	ldi	r24, 0x02	; 2
    9fb4:	f1 50       	subi	r31, 0x01	; 1
    9fb6:	20 40       	sbci	r18, 0x00	; 0
    9fb8:	80 40       	sbci	r24, 0x00	; 0
    9fba:	e1 f7       	brne	.-8      	; 0x9fb4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1bc>
    9fbc:	00 c0       	rjmp	.+0      	; 0x9fbe <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1c6>
    9fbe:	00 00       	nop
	
	
	        _delay_ms(50);

	        // set gains
	        if(!driver->start())
    9fc0:	8e a9       	ldd	r24, Y+54	; 0x36
    9fc2:	9f a9       	ldd	r25, Y+55	; 0x37
    9fc4:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    9fc8:	88 23       	and	r24, r24
    9fca:	09 f4       	brne	.+2      	; 0x9fce <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1d6>
    9fcc:	c9 c1       	rjmp	.+914    	; 0xa360 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x568>
	        {
		        return false;
	        }
	        
	        //Indicate that the next value is a write operation
	        if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    9fce:	48 e1       	ldi	r20, 0x18	; 24
    9fd0:	6c e3       	ldi	r22, 0x3C	; 60
    9fd2:	8e a9       	ldd	r24, Y+54	; 0x36
    9fd4:	9f a9       	ldd	r25, Y+55	; 0x37
    9fd6:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9fda:	88 23       	and	r24, r24
    9fdc:	09 f4       	brne	.+2      	; 0x9fe0 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1e8>
    9fde:	c2 c1       	rjmp	.+900    	; 0xa364 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x56c>
		        return false;
	        }
	        
			
	        //Write to the device so that the 'pointer' moves to register B
	        if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9fe0:	48 e2       	ldi	r20, 0x28	; 40
    9fe2:	62 e0       	ldi	r22, 0x02	; 2
    9fe4:	8e a9       	ldd	r24, Y+54	; 0x36
    9fe6:	9f a9       	ldd	r25, Y+55	; 0x37
    9fe8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9fec:	88 23       	and	r24, r24
    9fee:	09 f4       	brne	.+2      	; 0x9ff2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1fa>
    9ff0:	bb c1       	rjmp	.+886    	; 0xa368 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x570>
	        {
		        return false;
	        }
	        byte singleConversion = 0x01;
	        //Write the configuration value to register B
	        if (!driver->write(singleConversion, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    9ff2:	48 e2       	ldi	r20, 0x28	; 40
    9ff4:	61 e0       	ldi	r22, 0x01	; 1
    9ff6:	8e a9       	ldd	r24, Y+54	; 0x36
    9ff8:	9f a9       	ldd	r25, Y+55	; 0x37
    9ffa:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    9ffe:	88 23       	and	r24, r24
    a000:	09 f4       	brne	.+2      	; 0xa004 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x20c>
    a002:	b4 c1       	rjmp	.+872    	; 0xa36c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x574>
	        {
		        return false;
	        }

	        //end the transaction
	        driver->stop();
    a004:	8e a9       	ldd	r24, Y+54	; 0x36
    a006:	9f a9       	ldd	r25, Y+55	; 0x37
    a008:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a00c:	9f ef       	ldi	r25, 0xFF	; 255
    a00e:	e0 e7       	ldi	r30, 0x70	; 112
    a010:	f2 e0       	ldi	r31, 0x02	; 2
    a012:	91 50       	subi	r25, 0x01	; 1
    a014:	e0 40       	sbci	r30, 0x00	; 0
    a016:	f0 40       	sbci	r31, 0x00	; 0
    a018:	e1 f7       	brne	.-8      	; 0xa012 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x21a>
    a01a:	00 c0       	rjmp	.+0      	; 0xa01c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x224>
    a01c:	00 00       	nop
	
		
		_delay_ms(50);
		
        // read values from the compass
       readSensor();
    a01e:	ce 01       	movw	r24, r28
    a020:	0e 94 6e 4d 	call	0x9adc	; 0x9adc <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    a024:	2f ef       	ldi	r18, 0xFF	; 255
    a026:	80 e7       	ldi	r24, 0x70	; 112
    a028:	92 e0       	ldi	r25, 0x02	; 2
    a02a:	21 50       	subi	r18, 0x01	; 1
    a02c:	80 40       	sbci	r24, 0x00	; 0
    a02e:	90 40       	sbci	r25, 0x00	; 0
    a030:	e1 f7       	brne	.-8      	; 0xa02a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x232>
    a032:	00 c0       	rjmp	.+0      	; 0xa034 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x23c>
    a034:	00 00       	nop
		_delay_ms(50);

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
    a036:	2e 81       	ldd	r18, Y+6	; 0x06
    a038:	3f 81       	ldd	r19, Y+7	; 0x07
    a03a:	48 85       	ldd	r20, Y+8	; 0x08
    a03c:	59 85       	ldd	r21, Y+9	; 0x09
    a03e:	60 e0       	ldi	r22, 0x00	; 0
    a040:	70 e4       	ldi	r23, 0x40	; 64
    a042:	82 e3       	ldi	r24, 0x32	; 50
    a044:	94 ec       	ldi	r25, 0xC4	; 196
    a046:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a04a:	2b 01       	movw	r4, r22
    a04c:	3c 01       	movw	r6, r24
    a04e:	e8 94       	clt
    a050:	77 f8       	bld	r7, 7
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a052:	8a 84       	ldd	r8, Y+10	; 0x0a
    a054:	9b 84       	ldd	r9, Y+11	; 0x0b
    a056:	ac 84       	ldd	r10, Y+12	; 0x0c
    a058:	bd 84       	ldd	r11, Y+13	; 0x0d
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a05a:	ce 84       	ldd	r12, Y+14	; 0x0e
    a05c:	df 84       	ldd	r13, Y+15	; 0x0f
    a05e:	e8 88       	ldd	r14, Y+16	; 0x10
    a060:	f9 88       	ldd	r15, Y+17	; 0x11

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a062:	e3 e0       	ldi	r30, 0x03	; 3
    a064:	2e 16       	cp	r2, r30
    a066:	31 04       	cpc	r3, r1
    a068:	0c f4       	brge	.+2      	; 0xa06c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x274>
    a06a:	8a c0       	rjmp	.+276    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
    a06c:	23 e3       	ldi	r18, 0x33	; 51
    a06e:	33 e3       	ldi	r19, 0x33	; 51
    a070:	43 e3       	ldi	r20, 0x33	; 51
    a072:	5f e3       	ldi	r21, 0x3F	; 63
    a074:	c3 01       	movw	r24, r6
    a076:	b2 01       	movw	r22, r4
    a078:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    a07c:	18 16       	cp	r1, r24
    a07e:	0c f0       	brlt	.+2      	; 0xa082 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x28a>
    a080:	7f c0       	rjmp	.+254    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
            cal[0] > 0.7f && cal[0] < 1.35f &&
    a082:	2d ec       	ldi	r18, 0xCD	; 205
    a084:	3c ec       	ldi	r19, 0xCC	; 204
    a086:	4c ea       	ldi	r20, 0xAC	; 172
    a088:	5f e3       	ldi	r21, 0x3F	; 63
    a08a:	c3 01       	movw	r24, r6
    a08c:	b2 01       	movw	r22, r4
    a08e:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a092:	88 23       	and	r24, r24
    a094:	0c f0       	brlt	.+2      	; 0xa098 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2a0>
    a096:	74 c0       	rjmp	.+232    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a098:	a5 01       	movw	r20, r10
    a09a:	94 01       	movw	r18, r8
    a09c:	60 e0       	ldi	r22, 0x00	; 0
    a09e:	70 e8       	ldi	r23, 0x80	; 128
    a0a0:	8f e3       	ldi	r24, 0x3F	; 63
    a0a2:	94 e4       	ldi	r25, 0x44	; 68
    a0a4:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a0a8:	4b 01       	movw	r8, r22
    a0aa:	5c 01       	movw	r10, r24
    a0ac:	e8 94       	clt
    a0ae:	b7 f8       	bld	r11, 7
        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
            cal[0] > 0.7f && cal[0] < 1.35f &&
    a0b0:	23 e3       	ldi	r18, 0x33	; 51
    a0b2:	33 e3       	ldi	r19, 0x33	; 51
    a0b4:	43 e3       	ldi	r20, 0x33	; 51
    a0b6:	5f e3       	ldi	r21, 0x3F	; 63
    a0b8:	c5 01       	movw	r24, r10
    a0ba:	b4 01       	movw	r22, r8
    a0bc:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    a0c0:	18 16       	cp	r1, r24
    a0c2:	0c f0       	brlt	.+2      	; 0xa0c6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2ce>
    a0c4:	5d c0       	rjmp	.+186    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
            cal[1] > 0.7f && cal[1] < 1.35f &&
    a0c6:	2d ec       	ldi	r18, 0xCD	; 205
    a0c8:	3c ec       	ldi	r19, 0xCC	; 204
    a0ca:	4c ea       	ldi	r20, 0xAC	; 172
    a0cc:	5f e3       	ldi	r21, 0x3F	; 63
    a0ce:	c5 01       	movw	r24, r10
    a0d0:	b4 01       	movw	r22, r8
    a0d2:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a0d6:	88 23       	and	r24, r24
    a0d8:	0c f0       	brlt	.+2      	; 0xa0dc <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2e4>
    a0da:	52 c0       	rjmp	.+164    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a0dc:	a7 01       	movw	r20, r14
    a0de:	96 01       	movw	r18, r12
    a0e0:	60 e0       	ldi	r22, 0x00	; 0
    a0e2:	70 e4       	ldi	r23, 0x40	; 64
    a0e4:	82 e3       	ldi	r24, 0x32	; 50
    a0e6:	94 e4       	ldi	r25, 0x44	; 68
    a0e8:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a0ec:	6b 01       	movw	r12, r22
    a0ee:	7c 01       	movw	r14, r24
    a0f0:	e8 94       	clt
    a0f2:	f7 f8       	bld	r15, 7
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
            cal[0] > 0.7f && cal[0] < 1.35f &&
            cal[1] > 0.7f && cal[1] < 1.35f &&
    a0f4:	23 e3       	ldi	r18, 0x33	; 51
    a0f6:	33 e3       	ldi	r19, 0x33	; 51
    a0f8:	43 e3       	ldi	r20, 0x33	; 51
    a0fa:	5f e3       	ldi	r21, 0x3F	; 63
    a0fc:	c7 01       	movw	r24, r14
    a0fe:	b6 01       	movw	r22, r12
    a100:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    a104:	18 16       	cp	r1, r24
    a106:	e4 f5       	brge	.+120    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
            cal[2] > 0.7f && cal[2] < 1.35f) {
    a108:	2d ec       	ldi	r18, 0xCD	; 205
    a10a:	3c ec       	ldi	r19, 0xCC	; 204
    a10c:	4c ea       	ldi	r20, 0xAC	; 172
    a10e:	5f e3       	ldi	r21, 0x3F	; 63
    a110:	c7 01       	movw	r24, r14
    a112:	b6 01       	movw	r22, r12
    a114:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a118:	88 23       	and	r24, r24
    a11a:	94 f5       	brge	.+100    	; 0xa180 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x388>
//        if (numAttempts > 2 ) {				
            // hal.console->printf_P(PSTR("cal=%.2f %.2f %.2f good\n"), cal[0], cal[1], cal[2]);
            good_count++;
    a11c:	0f 5f       	subi	r16, 0xFF	; 255
    a11e:	1f 4f       	sbci	r17, 0xFF	; 255
            calibration[0] += cal[0];
    a120:	e6 e2       	ldi	r30, 0x26	; 38
    a122:	f4 e0       	ldi	r31, 0x04	; 4
    a124:	20 81       	ld	r18, Z
    a126:	31 81       	ldd	r19, Z+1	; 0x01
    a128:	42 81       	ldd	r20, Z+2	; 0x02
    a12a:	53 81       	ldd	r21, Z+3	; 0x03
    a12c:	c3 01       	movw	r24, r6
    a12e:	b2 01       	movw	r22, r4
    a130:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    a134:	e6 e2       	ldi	r30, 0x26	; 38
    a136:	f4 e0       	ldi	r31, 0x04	; 4
    a138:	60 83       	st	Z, r22
    a13a:	71 83       	std	Z+1, r23	; 0x01
    a13c:	82 83       	std	Z+2, r24	; 0x02
    a13e:	93 83       	std	Z+3, r25	; 0x03
            calibration[1] += cal[1];
    a140:	ea e2       	ldi	r30, 0x2A	; 42
    a142:	f4 e0       	ldi	r31, 0x04	; 4
    a144:	20 81       	ld	r18, Z
    a146:	31 81       	ldd	r19, Z+1	; 0x01
    a148:	42 81       	ldd	r20, Z+2	; 0x02
    a14a:	53 81       	ldd	r21, Z+3	; 0x03
    a14c:	c5 01       	movw	r24, r10
    a14e:	b4 01       	movw	r22, r8
    a150:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    a154:	ea e2       	ldi	r30, 0x2A	; 42
    a156:	f4 e0       	ldi	r31, 0x04	; 4
    a158:	60 83       	st	Z, r22
    a15a:	71 83       	std	Z+1, r23	; 0x01
    a15c:	82 83       	std	Z+2, r24	; 0x02
    a15e:	93 83       	std	Z+3, r25	; 0x03
            calibration[2] += cal[2];
    a160:	ee e2       	ldi	r30, 0x2E	; 46
    a162:	f4 e0       	ldi	r31, 0x04	; 4
    a164:	20 81       	ld	r18, Z
    a166:	31 81       	ldd	r19, Z+1	; 0x01
    a168:	42 81       	ldd	r20, Z+2	; 0x02
    a16a:	53 81       	ldd	r21, Z+3	; 0x03
    a16c:	c7 01       	movw	r24, r14
    a16e:	b6 01       	movw	r22, r12
    a170:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    a174:	ee e2       	ldi	r30, 0x2E	; 46
    a176:	f4 e0       	ldi	r31, 0x04	; 4
    a178:	60 83       	st	Z, r22
    a17a:	71 83       	std	Z+1, r23	; 0x01
    a17c:	82 83       	std	Z+2, r24	; 0x02
    a17e:	93 83       	std	Z+3, r25	; 0x03
	
	calibration[0] = 0;
	calibration[1] = 0;
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    a180:	f9 e1       	ldi	r31, 0x19	; 25
    a182:	2f 16       	cp	r2, r31
    a184:	31 04       	cpc	r3, r1
    a186:	29 f0       	breq	.+10     	; 0xa192 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x39a>
    a188:	05 30       	cpi	r16, 0x05	; 5
    a18a:	11 05       	cpc	r17, r1
    a18c:	0c f4       	brge	.+2      	; 0xa190 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x398>
    a18e:	b7 ce       	rjmp	.-658    	; 0x9efe <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x106>
    a190:	03 c0       	rjmp	.+6      	; 0xa198 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x3a0>
        }


    }

    if (good_count >= 5) {
    a192:	05 30       	cpi	r16, 0x05	; 5
    a194:	11 05       	cpc	r17, r1
    a196:	d4 f1       	brlt	.+116    	; 0xa20c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x414>
          impact is that the values we report on APM1/APM2 are lower
          than they should be (by a multiple of about 0.6). This
          doesn't have any impact other than the learned compass
          offsets
         */
        calibration[0] = calibration[0]  / good_count;
    a198:	b8 01       	movw	r22, r16
    a19a:	88 27       	eor	r24, r24
    a19c:	77 fd       	sbrc	r23, 7
    a19e:	80 95       	com	r24
    a1a0:	98 2f       	mov	r25, r24
    a1a2:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    a1a6:	6b 01       	movw	r12, r22
    a1a8:	7c 01       	movw	r14, r24
    a1aa:	06 e2       	ldi	r16, 0x26	; 38
    a1ac:	14 e0       	ldi	r17, 0x04	; 4
    a1ae:	9b 01       	movw	r18, r22
    a1b0:	ac 01       	movw	r20, r24
    a1b2:	f8 01       	movw	r30, r16
    a1b4:	60 81       	ld	r22, Z
    a1b6:	71 81       	ldd	r23, Z+1	; 0x01
    a1b8:	82 81       	ldd	r24, Z+2	; 0x02
    a1ba:	93 81       	ldd	r25, Z+3	; 0x03
    a1bc:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a1c0:	f8 01       	movw	r30, r16
    a1c2:	60 83       	st	Z, r22
    a1c4:	71 83       	std	Z+1, r23	; 0x01
    a1c6:	82 83       	std	Z+2, r24	; 0x02
    a1c8:	93 83       	std	Z+3, r25	; 0x03
        calibration[1] = calibration[1]  / good_count;
    a1ca:	0a e2       	ldi	r16, 0x2A	; 42
    a1cc:	14 e0       	ldi	r17, 0x04	; 4
    a1ce:	a7 01       	movw	r20, r14
    a1d0:	96 01       	movw	r18, r12
    a1d2:	f8 01       	movw	r30, r16
    a1d4:	60 81       	ld	r22, Z
    a1d6:	71 81       	ldd	r23, Z+1	; 0x01
    a1d8:	82 81       	ldd	r24, Z+2	; 0x02
    a1da:	93 81       	ldd	r25, Z+3	; 0x03
    a1dc:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a1e0:	f8 01       	movw	r30, r16
    a1e2:	60 83       	st	Z, r22
    a1e4:	71 83       	std	Z+1, r23	; 0x01
    a1e6:	82 83       	std	Z+2, r24	; 0x02
    a1e8:	93 83       	std	Z+3, r25	; 0x03
        calibration[2] = calibration[2]  / good_count;
    a1ea:	0e e2       	ldi	r16, 0x2E	; 46
    a1ec:	14 e0       	ldi	r17, 0x04	; 4
    a1ee:	a7 01       	movw	r20, r14
    a1f0:	96 01       	movw	r18, r12
    a1f2:	f8 01       	movw	r30, r16
    a1f4:	60 81       	ld	r22, Z
    a1f6:	71 81       	ldd	r23, Z+1	; 0x01
    a1f8:	82 81       	ldd	r24, Z+2	; 0x02
    a1fa:	93 81       	ldd	r25, Z+3	; 0x03
    a1fc:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a200:	f8 01       	movw	r30, r16
    a202:	60 83       	st	Z, r22
    a204:	71 83       	std	Z+1, r23	; 0x01
    a206:	82 83       	std	Z+2, r24	; 0x02
    a208:	93 83       	std	Z+3, r25	; 0x03
    a20a:	1c c0       	rjmp	.+56     	; 0xa244 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x44c>
        success = true;
    } else {
        /* best guess */
        calibration[0] = 1.0;
    a20c:	80 e0       	ldi	r24, 0x00	; 0
    a20e:	90 e0       	ldi	r25, 0x00	; 0
    a210:	a0 e8       	ldi	r26, 0x80	; 128
    a212:	bf e3       	ldi	r27, 0x3F	; 63
    a214:	80 93 26 04 	sts	0x0426, r24
    a218:	90 93 27 04 	sts	0x0427, r25
    a21c:	a0 93 28 04 	sts	0x0428, r26
    a220:	b0 93 29 04 	sts	0x0429, r27
        calibration[1] = 1.0;
    a224:	80 93 2a 04 	sts	0x042A, r24
    a228:	90 93 2b 04 	sts	0x042B, r25
    a22c:	a0 93 2c 04 	sts	0x042C, r26
    a230:	b0 93 2d 04 	sts	0x042D, r27
        calibration[2] = 1.0;
    a234:	80 93 2e 04 	sts	0x042E, r24
    a238:	90 93 2f 04 	sts	0x042F, r25
    a23c:	a0 93 30 04 	sts	0x0430, r26
    a240:	b0 93 31 04 	sts	0x0431, r27
	
	
	
	
	
	readyForOffsets = true;
    a244:	81 e0       	ldi	r24, 0x01	; 1
    a246:	80 93 25 04 	sts	0x0425, r24
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    a24a:	8e a9       	ldd	r24, Y+54	; 0x36
    a24c:	9f a9       	ldd	r25, Y+55	; 0x37
    a24e:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a252:	f8 2e       	mov	r15, r24
    a254:	88 23       	and	r24, r24
    a256:	09 f4       	brne	.+2      	; 0xa25a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x462>
    a258:	8a c0       	rjmp	.+276    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a25a:	48 e1       	ldi	r20, 0x18	; 24
    a25c:	6c e3       	ldi	r22, 0x3C	; 60
    a25e:	8e a9       	ldd	r24, Y+54	; 0x36
    a260:	9f a9       	ldd	r25, Y+55	; 0x37
    a262:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a266:	f8 2e       	mov	r15, r24
    a268:	88 23       	and	r24, r24
    a26a:	09 f4       	brne	.+2      	; 0xa26e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x476>
    a26c:	80 c0       	rjmp	.+256    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a26e:	48 e2       	ldi	r20, 0x28	; 40
    a270:	60 e0       	ldi	r22, 0x00	; 0
    a272:	8e a9       	ldd	r24, Y+54	; 0x36
    a274:	9f a9       	ldd	r25, Y+55	; 0x37
    a276:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a27a:	f8 2e       	mov	r15, r24
    a27c:	88 23       	and	r24, r24
    a27e:	09 f4       	brne	.+2      	; 0xa282 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x48a>
    a280:	76 c0       	rjmp	.+236    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
	
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a282:	48 e2       	ldi	r20, 0x28	; 40
    a284:	68 e7       	ldi	r22, 0x78	; 120
    a286:	8e a9       	ldd	r24, Y+54	; 0x36
    a288:	9f a9       	ldd	r25, Y+55	; 0x37
    a28a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a28e:	f8 2e       	mov	r15, r24
    a290:	88 23       	and	r24, r24
    a292:	09 f4       	brne	.+2      	; 0xa296 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x49e>
    a294:	6c c0       	rjmp	.+216    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    a296:	8e a9       	ldd	r24, Y+54	; 0x36
    a298:	9f a9       	ldd	r25, Y+55	; 0x37
    a29a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	byte primary_gain = 0x20;
	       // set gains
	       if(!driver->start())
    a29e:	8e a9       	ldd	r24, Y+54	; 0x36
    a2a0:	9f a9       	ldd	r25, Y+55	; 0x37
    a2a2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a2a6:	f8 2e       	mov	r15, r24
    a2a8:	88 23       	and	r24, r24
    a2aa:	09 f4       	brne	.+2      	; 0xa2ae <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4b6>
    a2ac:	60 c0       	rjmp	.+192    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }
	       
	       //Indicate that the next value is a write operation
	       if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a2ae:	48 e1       	ldi	r20, 0x18	; 24
    a2b0:	6c e3       	ldi	r22, 0x3C	; 60
    a2b2:	8e a9       	ldd	r24, Y+54	; 0x36
    a2b4:	9f a9       	ldd	r25, Y+55	; 0x37
    a2b6:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a2ba:	f8 2e       	mov	r15, r24
    a2bc:	88 23       	and	r24, r24
    a2be:	09 f4       	brne	.+2      	; 0xa2c2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4ca>
    a2c0:	56 c0       	rjmp	.+172    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }
	       
	       //Write to the device so that the 'pointer' moves to register B
	       if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a2c2:	48 e2       	ldi	r20, 0x28	; 40
    a2c4:	61 e0       	ldi	r22, 0x01	; 1
    a2c6:	8e a9       	ldd	r24, Y+54	; 0x36
    a2c8:	9f a9       	ldd	r25, Y+55	; 0x37
    a2ca:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a2ce:	f8 2e       	mov	r15, r24
    a2d0:	88 23       	and	r24, r24
    a2d2:	09 f4       	brne	.+2      	; 0xa2d6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4de>
    a2d4:	4c c0       	rjmp	.+152    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }
	       
	       //Write the configuration value to register B
	       if (!driver->write(primary_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a2d6:	48 e2       	ldi	r20, 0x28	; 40
    a2d8:	60 e2       	ldi	r22, 0x20	; 32
    a2da:	8e a9       	ldd	r24, Y+54	; 0x36
    a2dc:	9f a9       	ldd	r25, Y+55	; 0x37
    a2de:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a2e2:	f8 2e       	mov	r15, r24
    a2e4:	88 23       	and	r24, r24
    a2e6:	09 f4       	brne	.+2      	; 0xa2ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4f2>
    a2e8:	42 c0       	rjmp	.+132    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }

	       //end the transaction
	       driver->stop();
    a2ea:	8e a9       	ldd	r24, Y+54	; 0x36
    a2ec:	9f a9       	ldd	r25, Y+55	; 0x37
    a2ee:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>

	/**
	* Set the compass mode for continuous measurement
	*/
	//start a transaction
	if(!driver->start())
    a2f2:	8e a9       	ldd	r24, Y+54	; 0x36
    a2f4:	9f a9       	ldd	r25, Y+55	; 0x37
    a2f6:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a2fa:	f8 2e       	mov	r15, r24
    a2fc:	88 23       	and	r24, r24
    a2fe:	b9 f1       	breq	.+110    	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}
		
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a300:	48 e1       	ldi	r20, 0x18	; 24
    a302:	6c e3       	ldi	r22, 0x3C	; 60
    a304:	8e a9       	ldd	r24, Y+54	; 0x36
    a306:	9f a9       	ldd	r25, Y+55	; 0x37
    a308:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a30c:	f8 2e       	mov	r15, r24
    a30e:	88 23       	and	r24, r24
    a310:	71 f1       	breq	.+92     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}		
		
	//Write to the device so that the 'pointer' moves to the mode register
	if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a312:	48 e2       	ldi	r20, 0x28	; 40
    a314:	62 e0       	ldi	r22, 0x02	; 2
    a316:	8e a9       	ldd	r24, Y+54	; 0x36
    a318:	9f a9       	ldd	r25, Y+55	; 0x37
    a31a:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a31e:	f8 2e       	mov	r15, r24
    a320:	88 23       	and	r24, r24
    a322:	29 f1       	breq	.+74     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}

	//Write the configuration value to the mode register
	if (!driver->write(COMPASS_MODE_CONTINUOUS_MEASUREMENT_MODE, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a324:	48 e2       	ldi	r20, 0x28	; 40
    a326:	60 e0       	ldi	r22, 0x00	; 0
    a328:	8e a9       	ldd	r24, Y+54	; 0x36
    a32a:	9f a9       	ldd	r25, Y+55	; 0x37
    a32c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a330:	f8 2e       	mov	r15, r24
    a332:	88 23       	and	r24, r24
    a334:	e1 f0       	breq	.+56     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    a336:	8e a9       	ldd	r24, Y+54	; 0x36
    a338:	9f a9       	ldd	r25, Y+55	; 0x37
    a33a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	return true;
    a33e:	17 c0       	rjmp	.+46     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a340:	f8 2e       	mov	r15, r24
    a342:	15 c0       	rjmp	.+42     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a344:	f8 2e       	mov	r15, r24
    a346:	13 c0       	rjmp	.+38     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a348:	f8 2e       	mov	r15, r24
    a34a:	11 c0       	rjmp	.+34     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a34c:	f8 2e       	mov	r15, r24
    a34e:	0f c0       	rjmp	.+30     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a350:	f8 2e       	mov	r15, r24
    a352:	0d c0       	rjmp	.+26     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a354:	f8 2e       	mov	r15, r24
    a356:	0b c0       	rjmp	.+22     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a358:	f8 2e       	mov	r15, r24
    a35a:	09 c0       	rjmp	.+18     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a35c:	f8 2e       	mov	r15, r24
    a35e:	07 c0       	rjmp	.+14     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a360:	f8 2e       	mov	r15, r24
    a362:	05 c0       	rjmp	.+10     	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a364:	f8 2e       	mov	r15, r24
    a366:	03 c0       	rjmp	.+6      	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a368:	f8 2e       	mov	r15, r24
    a36a:	01 c0       	rjmp	.+2      	; 0xa36e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
    a36c:	f8 2e       	mov	r15, r24
}
    a36e:	8f 2d       	mov	r24, r15
    a370:	df 91       	pop	r29
    a372:	cf 91       	pop	r28
    a374:	1f 91       	pop	r17
    a376:	0f 91       	pop	r16
    a378:	ff 90       	pop	r15
    a37a:	ef 90       	pop	r14
    a37c:	df 90       	pop	r13
    a37e:	cf 90       	pop	r12
    a380:	bf 90       	pop	r11
    a382:	af 90       	pop	r10
    a384:	9f 90       	pop	r9
    a386:	8f 90       	pop	r8
    a388:	7f 90       	pop	r7
    a38a:	6f 90       	pop	r6
    a38c:	5f 90       	pop	r5
    a38e:	4f 90       	pop	r4
    a390:	3f 90       	pop	r3
    a392:	2f 90       	pop	r2
    a394:	08 95       	ret

0000a396 <_ZN10helicopter5tasks4Task4initEv>:
				virtual ~Task(){}
				
				/**
				 * Function to initialize the task before execution.
				 */
				virtual void init(){;}
    a396:	08 95       	ret

0000a398 <_ZN10helicopter5tasks14NavigationTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    a398:	26 e7       	ldi	r18, 0x76	; 118
    a39a:	33 e0       	ldi	r19, 0x03	; 3
    a39c:	fc 01       	movw	r30, r24
    a39e:	31 83       	std	Z+1, r19	; 0x01
    a3a0:	20 83       	st	Z, r18
    a3a2:	08 95       	ret

0000a3a4 <_ZN10helicopter5tasks14NavigationTaskD0Ev>:
    a3a4:	26 e7       	ldi	r18, 0x76	; 118
    a3a6:	33 e0       	ldi	r19, 0x03	; 3
    a3a8:	fc 01       	movw	r30, r24
    a3aa:	31 83       	std	Z+1, r19	; 0x01
    a3ac:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class NavigationTask : public Task
    a3ae:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    a3b2:	08 95       	ret

0000a3b4 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>:
{
	
}

void NavigationTask::runTaskImpl()
{
    a3b4:	6f 92       	push	r6
    a3b6:	7f 92       	push	r7
    a3b8:	8f 92       	push	r8
    a3ba:	9f 92       	push	r9
    a3bc:	af 92       	push	r10
    a3be:	bf 92       	push	r11
    a3c0:	cf 92       	push	r12
    a3c2:	df 92       	push	r13
    a3c4:	ef 92       	push	r14
    a3c6:	ff 92       	push	r15
    a3c8:	0f 93       	push	r16
    a3ca:	1f 93       	push	r17
    a3cc:	cf 93       	push	r28
    a3ce:	df 93       	push	r29
    a3d0:	ec 01       	movw	r28, r24
	//avoid oversampling by only calculating a new ahrs value if we have new gyro data (since our AHRS is most sensitive to gyro data).
	if (model->RollAngularVelocityRadsPerSecond() != oldrollAngularVelocityRs || 
    a3d2:	6d 84       	ldd	r6, Y+13	; 0x0d
    a3d4:	7e 84       	ldd	r7, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    a3d6:	f3 01       	movw	r30, r6
    a3d8:	e2 52       	subi	r30, 0x22	; 34
    a3da:	ff 4f       	sbci	r31, 0xFF	; 255
    a3dc:	80 80       	ld	r8, Z
    a3de:	91 80       	ldd	r9, Z+1	; 0x01
    a3e0:	a2 80       	ldd	r10, Z+2	; 0x02
    a3e2:	b3 80       	ldd	r11, Z+3	; 0x03
		model->PitchAngularVelocityRadsPerSecond() != oldpitchAngularVelocityRs ||
    a3e4:	a5 01       	movw	r20, r10
    a3e6:	94 01       	movw	r18, r8
    a3e8:	6b 89       	ldd	r22, Y+19	; 0x13
    a3ea:	7c 89       	ldd	r23, Y+20	; 0x14
    a3ec:	8d 89       	ldd	r24, Y+21	; 0x15
    a3ee:	9e 89       	ldd	r25, Y+22	; 0x16
    a3f0:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a3f4:	81 11       	cpse	r24, r1
    a3f6:	1f c0       	rjmp	.+62     	; 0xa436 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    a3f8:	f3 01       	movw	r30, r6
    a3fa:	e6 52       	subi	r30, 0x26	; 38
    a3fc:	ff 4f       	sbci	r31, 0xFF	; 255
}

void NavigationTask::runTaskImpl()
{
	//avoid oversampling by only calculating a new ahrs value if we have new gyro data (since our AHRS is most sensitive to gyro data).
	if (model->RollAngularVelocityRadsPerSecond() != oldrollAngularVelocityRs || 
    a3fe:	20 81       	ld	r18, Z
    a400:	31 81       	ldd	r19, Z+1	; 0x01
    a402:	42 81       	ldd	r20, Z+2	; 0x02
    a404:	53 81       	ldd	r21, Z+3	; 0x03
    a406:	6f 85       	ldd	r22, Y+15	; 0x0f
    a408:	78 89       	ldd	r23, Y+16	; 0x10
    a40a:	89 89       	ldd	r24, Y+17	; 0x11
    a40c:	9a 89       	ldd	r25, Y+18	; 0x12
    a40e:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a412:	81 11       	cpse	r24, r1
    a414:	10 c0       	rjmp	.+32     	; 0xa436 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    a416:	f3 01       	movw	r30, r6
    a418:	ee 51       	subi	r30, 0x1E	; 30
    a41a:	ff 4f       	sbci	r31, 0xFF	; 255
    a41c:	20 81       	ld	r18, Z
    a41e:	31 81       	ldd	r19, Z+1	; 0x01
    a420:	42 81       	ldd	r20, Z+2	; 0x02
    a422:	53 81       	ldd	r21, Z+3	; 0x03
    a424:	6f 89       	ldd	r22, Y+23	; 0x17
    a426:	78 8d       	ldd	r23, Y+24	; 0x18
    a428:	89 8d       	ldd	r24, Y+25	; 0x19
    a42a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a42c:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a430:	88 23       	and	r24, r24
    a432:	09 f4       	brne	.+2      	; 0xa436 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
    a434:	95 c0       	rjmp	.+298    	; 0xa560 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x1ac>
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    a436:	f3 01       	movw	r30, r6
    a438:	e2 51       	subi	r30, 0x12	; 18
    a43a:	ff 4f       	sbci	r31, 0xFF	; 255
		/**
		 * Update the AHRS
		 */
		ahrs->update(model->XAccelFrdMss(), model->YAccelFrdMss(), model->ZAccelFrdMss(),
					model->RollAngularVelocityRadsPerSecond(), model->PitchAngularVelocityRadsPerSecond(), model->YawAngularVelocityRadsPerSecond(),
					model->XMagFrd(), model->YMagFrd(), model->ZMagFrd());
    a43c:	c0 80       	ld	r12, Z
    a43e:	d1 80       	ldd	r13, Z+1	; 0x01
    a440:	e2 80       	ldd	r14, Z+2	; 0x02
    a442:	f3 80       	ldd	r15, Z+3	; 0x03
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    a444:	34 97       	sbiw	r30, 0x04	; 4
    a446:	00 81       	ld	r16, Z
    a448:	11 81       	ldd	r17, Z+1	; 0x01
    a44a:	22 81       	ldd	r18, Z+2	; 0x02
    a44c:	33 81       	ldd	r19, Z+3	; 0x03

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    a44e:	34 97       	sbiw	r30, 0x04	; 4
    a450:	40 81       	ld	r20, Z
    a452:	51 81       	ldd	r21, Z+1	; 0x01
    a454:	62 81       	ldd	r22, Z+2	; 0x02
    a456:	73 81       	ldd	r23, Z+3	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    a458:	74 96       	adiw	r30, 0x14	; 20
    a45a:	83 81       	ldd	r24, Z+3	; 0x03
    a45c:	8f 93       	push	r24
    a45e:	82 81       	ldd	r24, Z+2	; 0x02
    a460:	8f 93       	push	r24
    a462:	81 81       	ldd	r24, Z+1	; 0x01
    a464:	8f 93       	push	r24
    a466:	e0 81       	ld	r30, Z
    a468:	ef 93       	push	r30
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    a46a:	f3 01       	movw	r30, r6
    a46c:	ea 50       	subi	r30, 0x0A	; 10
    a46e:	ff 4f       	sbci	r31, 0xFF	; 255
    a470:	83 81       	ldd	r24, Z+3	; 0x03
    a472:	8f 93       	push	r24
    a474:	82 81       	ldd	r24, Z+2	; 0x02
    a476:	8f 93       	push	r24
    a478:	81 81       	ldd	r24, Z+1	; 0x01
    a47a:	8f 93       	push	r24
    a47c:	e0 81       	ld	r30, Z
    a47e:	ef 93       	push	r30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    a480:	f3 01       	movw	r30, r6
    a482:	ee 50       	subi	r30, 0x0E	; 14
    a484:	ff 4f       	sbci	r31, 0xFF	; 255
    a486:	83 81       	ldd	r24, Z+3	; 0x03
    a488:	8f 93       	push	r24
    a48a:	82 81       	ldd	r24, Z+2	; 0x02
    a48c:	8f 93       	push	r24
    a48e:	81 81       	ldd	r24, Z+1	; 0x01
    a490:	8f 93       	push	r24
    a492:	e0 81       	ld	r30, Z
    a494:	ef 93       	push	r30
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    a496:	f3 01       	movw	r30, r6
    a498:	ee 51       	subi	r30, 0x1E	; 30
    a49a:	ff 4f       	sbci	r31, 0xFF	; 255
    a49c:	83 81       	ldd	r24, Z+3	; 0x03
    a49e:	8f 93       	push	r24
    a4a0:	82 81       	ldd	r24, Z+2	; 0x02
    a4a2:	8f 93       	push	r24
    a4a4:	81 81       	ldd	r24, Z+1	; 0x01
    a4a6:	8f 93       	push	r24
    a4a8:	e0 81       	ld	r30, Z
    a4aa:	ef 93       	push	r30
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    a4ac:	f3 01       	movw	r30, r6
    a4ae:	e6 52       	subi	r30, 0x26	; 38
    a4b0:	ff 4f       	sbci	r31, 0xFF	; 255
    a4b2:	83 81       	ldd	r24, Z+3	; 0x03
    a4b4:	8f 93       	push	r24
    a4b6:	82 81       	ldd	r24, Z+2	; 0x02
    a4b8:	8f 93       	push	r24
    a4ba:	81 81       	ldd	r24, Z+1	; 0x01
    a4bc:	8f 93       	push	r24
    a4be:	e0 81       	ld	r30, Z
    a4c0:	ef 93       	push	r30
    a4c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4c4:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4c6:	0e 94 f2 3c 	call	0x79e4	; 0x79e4 <_ZN10helicopter10navigation4AHRS6updateEfffffffff>
				
		model->YawRads(ahrs->getYawRads());
    a4ca:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4cc:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4ce:	0e 94 2d 3f 	call	0x7e5a	; 0x7e5a <_ZN10helicopter10navigation4AHRS10getYawRadsEv>
    a4d2:	ed 85       	ldd	r30, Y+13	; 0x0d
    a4d4:	fe 85       	ldd	r31, Y+14	; 0x0e

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
    a4d6:	ea 52       	subi	r30, 0x2A	; 42
    a4d8:	ff 4f       	sbci	r31, 0xFF	; 255
    a4da:	60 83       	st	Z, r22
    a4dc:	71 83       	std	Z+1, r23	; 0x01
    a4de:	82 83       	std	Z+2, r24	; 0x02
    a4e0:	93 83       	std	Z+3, r25	; 0x03
		model->PitchRads(ahrs->getPitchRads());
    a4e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4e4:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4e6:	0e 94 33 3f 	call	0x7e66	; 0x7e66 <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>
    a4ea:	ed 85       	ldd	r30, Y+13	; 0x0d
    a4ec:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
    a4ee:	ee 52       	subi	r30, 0x2E	; 46
    a4f0:	ff 4f       	sbci	r31, 0xFF	; 255
    a4f2:	60 83       	st	Z, r22
    a4f4:	71 83       	std	Z+1, r23	; 0x01
    a4f6:	82 83       	std	Z+2, r24	; 0x02
    a4f8:	93 83       	std	Z+3, r25	; 0x03
		model->RollRads(ahrs->getRollRads());
    a4fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4fe:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <_ZN10helicopter10navigation4AHRS11getRollRadsEv>
    a502:	ed 85       	ldd	r30, Y+13	; 0x0d
    a504:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	
    a506:	e2 53       	subi	r30, 0x32	; 50
    a508:	ff 4f       	sbci	r31, 0xFF	; 255
    a50a:	60 83       	st	Z, r22
    a50c:	71 83       	std	Z+1, r23	; 0x01
    a50e:	82 83       	std	Z+2, r24	; 0x02
    a510:	93 83       	std	Z+3, r25	; 0x03
		
		oldrollAngularVelocityRs = model->RollAngularVelocityRadsPerSecond();
    a512:	2d 85       	ldd	r18, Y+13	; 0x0d
    a514:	3e 85       	ldd	r19, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    a516:	f9 01       	movw	r30, r18
    a518:	e2 52       	subi	r30, 0x22	; 34
    a51a:	ff 4f       	sbci	r31, 0xFF	; 255
    a51c:	80 81       	ld	r24, Z
    a51e:	91 81       	ldd	r25, Z+1	; 0x01
    a520:	a2 81       	ldd	r26, Z+2	; 0x02
    a522:	b3 81       	ldd	r27, Z+3	; 0x03
    a524:	8b 8b       	std	Y+19, r24	; 0x13
    a526:	9c 8b       	std	Y+20, r25	; 0x14
    a528:	ad 8b       	std	Y+21, r26	; 0x15
    a52a:	be 8b       	std	Y+22, r27	; 0x16
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    a52c:	34 97       	sbiw	r30, 0x04	; 4
    a52e:	80 81       	ld	r24, Z
    a530:	91 81       	ldd	r25, Z+1	; 0x01
    a532:	a2 81       	ldd	r26, Z+2	; 0x02
    a534:	b3 81       	ldd	r27, Z+3	; 0x03
		oldpitchAngularVelocityRs = model->PitchAngularVelocityRadsPerSecond();
    a536:	8f 87       	std	Y+15, r24	; 0x0f
    a538:	98 8b       	std	Y+16, r25	; 0x10
    a53a:	a9 8b       	std	Y+17, r26	; 0x11
    a53c:	ba 8b       	std	Y+18, r27	; 0x12
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    a53e:	38 96       	adiw	r30, 0x08	; 8
    a540:	80 81       	ld	r24, Z
    a542:	91 81       	ldd	r25, Z+1	; 0x01
    a544:	a2 81       	ldd	r26, Z+2	; 0x02
    a546:	b3 81       	ldd	r27, Z+3	; 0x03
		oldyawAngularVelocityRs = model->YawAngularVelocityRadsPerSecond();
    a548:	8f 8b       	std	Y+23, r24	; 0x17
    a54a:	98 8f       	std	Y+24, r25	; 0x18
    a54c:	a9 8f       	std	Y+25, r26	; 0x19
    a54e:	ba 8f       	std	Y+26, r27	; 0x1a
    a550:	8d b7       	in	r24, 0x3d	; 61
    a552:	9e b7       	in	r25, 0x3e	; 62
    a554:	44 96       	adiw	r24, 0x14	; 20
    a556:	0f b6       	in	r0, 0x3f	; 63
    a558:	f8 94       	cli
    a55a:	9e bf       	out	0x3e, r25	; 62
    a55c:	0f be       	out	0x3f, r0	; 63
    a55e:	8d bf       	out	0x3d, r24	; 61
	//model->YNEDLocalFrameCm(localNEDY);
	////model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	//
	//
	
}
    a560:	df 91       	pop	r29
    a562:	cf 91       	pop	r28
    a564:	1f 91       	pop	r17
    a566:	0f 91       	pop	r16
    a568:	ff 90       	pop	r15
    a56a:	ef 90       	pop	r14
    a56c:	df 90       	pop	r13
    a56e:	cf 90       	pop	r12
    a570:	bf 90       	pop	r11
    a572:	af 90       	pop	r10
    a574:	9f 90       	pop	r9
    a576:	8f 90       	pop	r8
    a578:	7f 90       	pop	r7
    a57a:	6f 90       	pop	r6
    a57c:	08 95       	ret

0000a57e <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float NavigationTask::WEIGHT = .15;


NavigationTask::NavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    a57e:	4f 92       	push	r4
    a580:	5f 92       	push	r5
    a582:	6f 92       	push	r6
    a584:	7f 92       	push	r7
    a586:	af 92       	push	r10
    a588:	bf 92       	push	r11
    a58a:	cf 92       	push	r12
    a58c:	df 92       	push	r13
    a58e:	ef 92       	push	r14
    a590:	ff 92       	push	r15
    a592:	0f 93       	push	r16
    a594:	1f 93       	push	r17
    a596:	cf 93       	push	r28
    a598:	df 93       	push	r29
    a59a:	ec 01       	movw	r28, r24
    a59c:	2a 01       	movw	r4, r20
    a59e:	3b 01       	movw	r6, r22
    a5a0:	59 01       	movw	r10, r18
    a5a2:	b7 01       	movw	r22, r14
    a5a4:	a6 01       	movw	r20, r12
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model),
oldpitchAngularVelocityRs(0),
oldrollAngularVelocityRs(0),
oldyawAngularVelocityRs(0)
    a5a6:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    a5aa:	8a ee       	ldi	r24, 0xEA	; 234
    a5ac:	92 e0       	ldi	r25, 0x02	; 2
    a5ae:	99 83       	std	Y+1, r25	; 0x01
    a5b0:	88 83       	st	Y, r24
    a5b2:	4f 82       	std	Y+7, r4	; 0x07
    a5b4:	58 86       	std	Y+8, r5	; 0x08
    a5b6:	69 86       	std	Y+9, r6	; 0x09
    a5b8:	7a 86       	std	Y+10, r7	; 0x0a
    a5ba:	bc 86       	std	Y+12, r11	; 0x0c
    a5bc:	ab 86       	std	Y+11, r10	; 0x0b
    a5be:	1e 87       	std	Y+14, r17	; 0x0e
    a5c0:	0d 87       	std	Y+13, r16	; 0x0d
    a5c2:	1f 86       	std	Y+15, r1	; 0x0f
    a5c4:	18 8a       	std	Y+16, r1	; 0x10
    a5c6:	19 8a       	std	Y+17, r1	; 0x11
    a5c8:	1a 8a       	std	Y+18, r1	; 0x12
    a5ca:	1b 8a       	std	Y+19, r1	; 0x13
    a5cc:	1c 8a       	std	Y+20, r1	; 0x14
    a5ce:	1d 8a       	std	Y+21, r1	; 0x15
    a5d0:	1e 8a       	std	Y+22, r1	; 0x16
    a5d2:	1f 8a       	std	Y+23, r1	; 0x17
    a5d4:	18 8e       	std	Y+24, r1	; 0x18
    a5d6:	19 8e       	std	Y+25, r1	; 0x19
    a5d8:	1a 8e       	std	Y+26, r1	; 0x1a
{
	
}
    a5da:	df 91       	pop	r29
    a5dc:	cf 91       	pop	r28
    a5de:	1f 91       	pop	r17
    a5e0:	0f 91       	pop	r16
    a5e2:	ff 90       	pop	r15
    a5e4:	ef 90       	pop	r14
    a5e6:	df 90       	pop	r13
    a5e8:	cf 90       	pop	r12
    a5ea:	bf 90       	pop	r11
    a5ec:	af 90       	pop	r10
    a5ee:	7f 90       	pop	r7
    a5f0:	6f 90       	pop	r6
    a5f2:	5f 90       	pop	r5
    a5f4:	4f 90       	pop	r4
    a5f6:	08 95       	ret

0000a5f8 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>:
    a5f8:	26 e7       	ldi	r18, 0x76	; 118
    a5fa:	33 e0       	ldi	r19, 0x03	; 3
    a5fc:	fc 01       	movw	r30, r24
    a5fe:	31 83       	std	Z+1, r19	; 0x01
    a600:	20 83       	st	Z, r18
    a602:	08 95       	ret

0000a604 <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>:
    a604:	26 e7       	ldi	r18, 0x76	; 118
    a606:	33 e0       	ldi	r19, 0x03	; 3
    a608:	fc 01       	movw	r30, r24
    a60a:	31 83       	std	Z+1, r19	; 0x01
    a60c:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDInnerLoopTask : public Task
    a60e:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    a612:	08 95       	ret

0000a614 <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>:
{
	
}

void PIDInnerLoopTask::runTaskImpl()
{
    a614:	cf 93       	push	r28
    a616:	df 93       	push	r29
    a618:	ec 01       	movw	r28, r24
	pidController->cyclicLateralInnerLoopUpdate();
    a61a:	8f 81       	ldd	r24, Y+7	; 0x07
    a61c:	98 85       	ldd	r25, Y+8	; 0x08
    a61e:	0e 94 0e 09 	call	0x121c	; 0x121c <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>
	pidController->cyclicLongitudeInnerLoopUpdate();
    a622:	8f 81       	ldd	r24, Y+7	; 0x07
    a624:	98 85       	ldd	r25, Y+8	; 0x08
    a626:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>
}
    a62a:	df 91       	pop	r29
    a62c:	cf 91       	pop	r28
    a62e:	08 95       	ret

0000a630 <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDInnerLoopTask.h"

using namespace helicopter::tasks;

PIDInnerLoopTask::PIDInnerLoopTask (PIDController *pidController, int delay, int period) :
    a630:	0f 93       	push	r16
    a632:	1f 93       	push	r17
    a634:	cf 93       	push	r28
    a636:	df 93       	push	r29
    a638:	ec 01       	movw	r28, r24
    a63a:	8b 01       	movw	r16, r22
    a63c:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    a63e:	a9 01       	movw	r20, r18
    a640:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    a644:	88 ef       	ldi	r24, 0xF8	; 248
    a646:	92 e0       	ldi	r25, 0x02	; 2
    a648:	99 83       	std	Y+1, r25	; 0x01
    a64a:	88 83       	st	Y, r24
    a64c:	18 87       	std	Y+8, r17	; 0x08
    a64e:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    a650:	df 91       	pop	r29
    a652:	cf 91       	pop	r28
    a654:	1f 91       	pop	r17
    a656:	0f 91       	pop	r16
    a658:	08 95       	ret

0000a65a <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>:
    a65a:	26 e7       	ldi	r18, 0x76	; 118
    a65c:	33 e0       	ldi	r19, 0x03	; 3
    a65e:	fc 01       	movw	r30, r24
    a660:	31 83       	std	Z+1, r19	; 0x01
    a662:	20 83       	st	Z, r18
    a664:	08 95       	ret

0000a666 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>:
    a666:	26 e7       	ldi	r18, 0x76	; 118
    a668:	33 e0       	ldi	r19, 0x03	; 3
    a66a:	fc 01       	movw	r30, r24
    a66c:	31 83       	std	Z+1, r19	; 0x01
    a66e:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDOuterLoopTask : public Task
    a670:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    a674:	08 95       	ret

0000a676 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>:
	
}

void PIDOuterLoopTask::runTaskImpl()
{
	pidController->outerLoopUpdate();
    a676:	fc 01       	movw	r30, r24
    a678:	87 81       	ldd	r24, Z+7	; 0x07
    a67a:	90 85       	ldd	r25, Z+8	; 0x08
    a67c:	0e 94 db 07 	call	0xfb6	; 0xfb6 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>
    a680:	08 95       	ret

0000a682 <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDOuterLoopTask.h"

using namespace helicopter::tasks;

PIDOuterLoopTask::PIDOuterLoopTask (PIDController *pidController, int delay, int period) :
    a682:	0f 93       	push	r16
    a684:	1f 93       	push	r17
    a686:	cf 93       	push	r28
    a688:	df 93       	push	r29
    a68a:	ec 01       	movw	r28, r24
    a68c:	8b 01       	movw	r16, r22
    a68e:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    a690:	a9 01       	movw	r20, r18
    a692:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    a696:	86 e0       	ldi	r24, 0x06	; 6
    a698:	93 e0       	ldi	r25, 0x03	; 3
    a69a:	99 83       	std	Y+1, r25	; 0x01
    a69c:	88 83       	st	Y, r24
    a69e:	18 87       	std	Y+8, r17	; 0x08
    a6a0:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    a6a2:	df 91       	pop	r29
    a6a4:	cf 91       	pop	r28
    a6a6:	1f 91       	pop	r17
    a6a8:	0f 91       	pop	r16
    a6aa:	08 95       	ret

0000a6ac <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>:
    a6ac:	26 e7       	ldi	r18, 0x76	; 118
    a6ae:	33 e0       	ldi	r19, 0x03	; 3
    a6b0:	fc 01       	movw	r30, r24
    a6b2:	31 83       	std	Z+1, r19	; 0x01
    a6b4:	20 83       	st	Z, r18
    a6b6:	08 95       	ret

0000a6b8 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>:
    a6b8:	26 e7       	ldi	r18, 0x76	; 118
    a6ba:	33 e0       	ldi	r19, 0x03	; 3
    a6bc:	fc 01       	movw	r30, r24
    a6be:	31 83       	std	Z+1, r19	; 0x01
    a6c0:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PVNavigationTask : public Task
    a6c2:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    a6c6:	08 95       	ret

0000a6c8 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>:
{
	
}

void PVNavigationTask::runTaskImpl()
{	
    a6c8:	4f 92       	push	r4
    a6ca:	5f 92       	push	r5
    a6cc:	6f 92       	push	r6
    a6ce:	7f 92       	push	r7
    a6d0:	8f 92       	push	r8
    a6d2:	9f 92       	push	r9
    a6d4:	af 92       	push	r10
    a6d6:	bf 92       	push	r11
    a6d8:	cf 92       	push	r12
    a6da:	df 92       	push	r13
    a6dc:	ef 92       	push	r14
    a6de:	ff 92       	push	r15
    a6e0:	0f 93       	push	r16
    a6e2:	1f 93       	push	r17
    a6e4:	cf 93       	push	r28
    a6e6:	df 93       	push	r29
    a6e8:	cd b7       	in	r28, 0x3d	; 61
    a6ea:	de b7       	in	r29, 0x3e	; 62
    a6ec:	e4 97       	sbiw	r28, 0x34	; 52
    a6ee:	0f b6       	in	r0, 0x3f	; 63
    a6f0:	f8 94       	cli
    a6f2:	de bf       	out	0x3e, r29	; 62
    a6f4:	0f be       	out	0x3f, r0	; 63
    a6f6:	cd bf       	out	0x3d, r28	; 61
    a6f8:	4c 01       	movw	r8, r24
	/**
	 * Process GPS data into NED position and velocity. 
	 */
	float rotatedVelocityMatrix[3] = {};
    a6fa:	8c e0       	ldi	r24, 0x0C	; 12
    a6fc:	7e 01       	movw	r14, r28
    a6fe:	99 e1       	ldi	r25, 0x19	; 25
    a700:	e9 0e       	add	r14, r25
    a702:	f1 1c       	adc	r15, r1
    a704:	d7 01       	movw	r26, r14
    a706:	e8 2f       	mov	r30, r24
    a708:	1d 92       	st	X+, r1
    a70a:	ea 95       	dec	r30
    a70c:	e9 f7       	brne	.-6      	; 0xa708 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x40>
	float velocityBodyFrame[3] = {};
    a70e:	6e 01       	movw	r12, r28
    a710:	fd e0       	ldi	r31, 0x0D	; 13
    a712:	cf 0e       	add	r12, r31
    a714:	d1 1c       	adc	r13, r1
    a716:	d6 01       	movw	r26, r12
    a718:	1d 92       	st	X+, r1
    a71a:	8a 95       	dec	r24
    a71c:	e9 f7       	brne	.-6      	; 0xa718 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x50>
		
	float velocityMatrix[3] = {(float)model->XVEcefCms(), (float)model->YVEcefCms(), (float)model->ZVEcefCms()};
    a71e:	f4 01       	movw	r30, r8
    a720:	05 85       	ldd	r16, Z+13	; 0x0d
    a722:	16 85       	ldd	r17, Z+14	; 0x0e
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    a724:	f8 01       	movw	r30, r16
    a726:	e6 5f       	subi	r30, 0xF6	; 246
    a728:	fe 4f       	sbci	r31, 0xFE	; 254
    a72a:	60 81       	ld	r22, Z
    a72c:	71 81       	ldd	r23, Z+1	; 0x01
    a72e:	82 81       	ldd	r24, Z+2	; 0x02
    a730:	93 81       	ldd	r25, Z+3	; 0x03
    a732:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    a736:	69 83       	std	Y+1, r22	; 0x01
    a738:	7a 83       	std	Y+2, r23	; 0x02
    a73a:	8b 83       	std	Y+3, r24	; 0x03
    a73c:	9c 83       	std	Y+4, r25	; 0x04
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    a73e:	f8 01       	movw	r30, r16
    a740:	e2 5f       	subi	r30, 0xF2	; 242
    a742:	fe 4f       	sbci	r31, 0xFE	; 254
    a744:	60 81       	ld	r22, Z
    a746:	71 81       	ldd	r23, Z+1	; 0x01
    a748:	82 81       	ldd	r24, Z+2	; 0x02
    a74a:	93 81       	ldd	r25, Z+3	; 0x03
    a74c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    a750:	6d 83       	std	Y+5, r22	; 0x05
    a752:	7e 83       	std	Y+6, r23	; 0x06
    a754:	8f 83       	std	Y+7, r24	; 0x07
    a756:	98 87       	std	Y+8, r25	; 0x08
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    a758:	f8 01       	movw	r30, r16
    a75a:	ee 5e       	subi	r30, 0xEE	; 238
    a75c:	fe 4f       	sbci	r31, 0xFE	; 254
    a75e:	60 81       	ld	r22, Z
    a760:	71 81       	ldd	r23, Z+1	; 0x01
    a762:	82 81       	ldd	r24, Z+2	; 0x02
    a764:	93 81       	ldd	r25, Z+3	; 0x03
    a766:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    a76a:	69 87       	std	Y+9, r22	; 0x09
    a76c:	7a 87       	std	Y+10, r23	; 0x0a
    a76e:	8b 87       	std	Y+11, r24	; 0x0b
    a770:	9c 87       	std	Y+12, r25	; 0x0c
	MatrixUtil::RotateMatrix(model->EcefToLocalNEDRotationMatrix,velocityMatrix,rotatedVelocityMatrix);
    a772:	a7 01       	movw	r20, r14
    a774:	be 01       	movw	r22, r28
    a776:	6f 5f       	subi	r22, 0xFF	; 255
    a778:	7f 4f       	sbci	r23, 0xFF	; 255
    a77a:	c8 01       	movw	r24, r16
    a77c:	82 5e       	subi	r24, 0xE2	; 226
    a77e:	9e 4f       	sbci	r25, 0xFE	; 254
    a780:	0e 94 8e 65 	call	0xcb1c	; 0xcb1c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
    a784:	d4 01       	movw	r26, r8
    a786:	1d 96       	adiw	r26, 0x0d	; 13
    a788:	ed 91       	ld	r30, X+
    a78a:	fc 91       	ld	r31, X
    a78c:	1e 97       	sbiw	r26, 0x0e	; 14
	/*
	MatrixUtil::CreateRotationMatrixTransposed(ahrs->getRollRads(), ahrs->getPitchRads(), ahrs->getYawRads(), nedToBodyFrameMatrix);
	MatrixUtil::RotateMatrix(nedToBodyFrameMatrix,rotatedVelocityMatrix, velocityBodyFrame);
	*/
	
	MatrixUtil::RotateMatrixT(model->Ahrs()->dcm,rotatedVelocityMatrix, velocityBodyFrame);	
    a78e:	80 81       	ld	r24, Z
    a790:	91 81       	ldd	r25, Z+1	; 0x01
    a792:	a6 01       	movw	r20, r12
    a794:	b7 01       	movw	r22, r14
    a796:	80 5c       	subi	r24, 0xC0	; 192
    a798:	9f 4f       	sbci	r25, 0xFF	; 255
    a79a:	0e 94 bf 64 	call	0xc97e	; 0xc97e <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	
	model->XVelocityFRDCms(velocityBodyFrame[0]);
    a79e:	d4 01       	movw	r26, r8
    a7a0:	1d 96       	adiw	r26, 0x0d	; 13
    a7a2:	ed 91       	ld	r30, X+
    a7a4:	fc 91       	ld	r31, X
    a7a6:	1e 97       	sbiw	r26, 0x0e	; 14

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
    a7a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    a7aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    a7ac:	af 85       	ldd	r26, Y+15	; 0x0f
    a7ae:	b8 89       	ldd	r27, Y+16	; 0x10
    a7b0:	82 ab       	std	Z+50, r24	; 0x32
    a7b2:	93 ab       	std	Z+51, r25	; 0x33
    a7b4:	a4 ab       	std	Z+52, r26	; 0x34
    a7b6:	b5 ab       	std	Z+53, r27	; 0x35
	model->YVelocityFRDCms(velocityBodyFrame[1]);
    a7b8:	d4 01       	movw	r26, r8
    a7ba:	1d 96       	adiw	r26, 0x0d	; 13
    a7bc:	ed 91       	ld	r30, X+
    a7be:	fc 91       	ld	r31, X
    a7c0:	1e 97       	sbiw	r26, 0x0e	; 14

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}
    a7c2:	e2 5a       	subi	r30, 0xA2	; 162
    a7c4:	ff 4f       	sbci	r31, 0xFF	; 255
    a7c6:	89 89       	ldd	r24, Y+17	; 0x11
    a7c8:	9a 89       	ldd	r25, Y+18	; 0x12
    a7ca:	ab 89       	ldd	r26, Y+19	; 0x13
    a7cc:	bc 89       	ldd	r27, Y+20	; 0x14
    a7ce:	80 83       	st	Z, r24
    a7d0:	91 83       	std	Z+1, r25	; 0x01
    a7d2:	a2 83       	std	Z+2, r26	; 0x02
    a7d4:	b3 83       	std	Z+3, r27	; 0x03
	

	
	
	if (model->HasNewPressureReading == true)
    a7d6:	f4 01       	movw	r30, r8
    a7d8:	05 85       	ldd	r16, Z+13	; 0x0d
    a7da:	16 85       	ldd	r17, Z+14	; 0x0e
    a7dc:	f8 01       	movw	r30, r16
    a7de:	ee 5b       	subi	r30, 0xBE	; 190
    a7e0:	fe 4f       	sbci	r31, 0xFE	; 254
    a7e2:	80 81       	ld	r24, Z
    a7e4:	88 23       	and	r24, r24
    a7e6:	09 f4       	brne	.+2      	; 0xa7ea <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x122>
    a7e8:	66 c0       	rjmp	.+204    	; 0xa8b6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x1ee>
		 * Multiply by -100 because in NED, 'down' is positive. And to convert meters to cm.
		 * -0.00000687535 = -6.8755856 * 10^-6
		 */
		//float altitudeMslCm = (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		//4433228.712 is a number I came up with from simplifying the expression (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		float altitudeMslCm = (pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712; 
    a7ea:	20 e0       	ldi	r18, 0x00	; 0
    a7ec:	30 e5       	ldi	r19, 0x50	; 80
    a7ee:	4d e7       	ldi	r20, 0x7D	; 125
    a7f0:	54 e4       	ldi	r21, 0x44	; 68
    a7f2:	bc 97       	sbiw	r30, 0x2c	; 44
    a7f4:	60 81       	ld	r22, Z
    a7f6:	71 81       	ldd	r23, Z+1	; 0x01
    a7f8:	82 81       	ldd	r24, Z+2	; 0x02
    a7fa:	93 81       	ldd	r25, Z+3	; 0x03
    a7fc:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a800:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <log10>
    a804:	2b e2       	ldi	r18, 0x2B	; 43
    a806:	30 e3       	ldi	r19, 0x30	; 48
    a808:	48 ea       	ldi	r20, 0xA8	; 168
    a80a:	50 e4       	ldi	r21, 0x40	; 64
    a80c:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    a810:	9b 01       	movw	r18, r22
    a812:	ac 01       	movw	r20, r24
    a814:	60 e0       	ldi	r22, 0x00	; 0
    a816:	70 e0       	ldi	r23, 0x00	; 0
    a818:	80 e2       	ldi	r24, 0x20	; 32
    a81a:	91 e4       	ldi	r25, 0x41	; 65
    a81c:	0e 94 80 6a 	call	0xd500	; 0xd500 <pow>
    a820:	20 e0       	ldi	r18, 0x00	; 0
    a822:	30 e0       	ldi	r19, 0x00	; 0
    a824:	40 e8       	ldi	r20, 0x80	; 128
    a826:	5f e3       	ldi	r21, 0x3F	; 63
    a828:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    a82c:	29 e9       	ldi	r18, 0x99	; 153
    a82e:	3a e4       	ldi	r19, 0x4A	; 74
    a830:	47 e8       	ldi	r20, 0x87	; 135
    a832:	5a e4       	ldi	r21, 0x4A	; 74
    a834:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    a838:	6b 01       	movw	r12, r22
    a83a:	7c 01       	movw	r14, r24
	
		//model->ZNEDLocalFrameCm((float) (altitudeMslCm - model->InitialAltitudeCm()));
	
	
		if (!isnanf(altitudeMslCm) && 
			((altitudeMslCm - model->InitialAltitudeCm()) - model->ZNEDLocalFrameCm()) < 800 && 
    a83c:	9b 01       	movw	r18, r22
    a83e:	ac 01       	movw	r20, r24
    a840:	0e 94 17 6b 	call	0xd62e	; 0xd62e <__unordsf2>
    a844:	81 11       	cpse	r24, r1
    a846:	2f c0       	rjmp	.+94     	; 0xa8a6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x1de>
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
    a848:	f8 01       	movw	r30, r16
    a84a:	e6 53       	subi	r30, 0x36	; 54
    a84c:	ff 4f       	sbci	r31, 0xFF	; 255
    a84e:	20 81       	ld	r18, Z
    a850:	31 81       	ldd	r19, Z+1	; 0x01
    a852:	42 81       	ldd	r20, Z+2	; 0x02
    a854:	53 81       	ldd	r21, Z+3	; 0x03
    a856:	c7 01       	movw	r24, r14
    a858:	b6 01       	movw	r22, r12
    a85a:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    a85e:	69 ab       	std	Y+49, r22	; 0x31
    a860:	7a ab       	std	Y+50, r23	; 0x32
    a862:	8b ab       	std	Y+51, r24	; 0x33
    a864:	9c ab       	std	Y+52, r25	; 0x34
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    a866:	f8 01       	movw	r30, r16
    a868:	e2 58       	subi	r30, 0x82	; 130
    a86a:	ff 4f       	sbci	r31, 0xFF	; 255
    a86c:	40 80       	ld	r4, Z
    a86e:	51 80       	ldd	r5, Z+1	; 0x01
    a870:	62 80       	ldd	r6, Z+2	; 0x02
    a872:	73 80       	ldd	r7, Z+3	; 0x03
    a874:	a3 01       	movw	r20, r6
    a876:	92 01       	movw	r18, r4
    a878:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    a87c:	6b 01       	movw	r12, r22
    a87e:	7c 01       	movw	r14, r24
		//bool hasGoodAltitude = true;
	
		//model->ZNEDLocalFrameCm((float) (altitudeMslCm - model->InitialAltitudeCm()));
	
	
		if (!isnanf(altitudeMslCm) && 
    a880:	20 e0       	ldi	r18, 0x00	; 0
    a882:	30 e0       	ldi	r19, 0x00	; 0
    a884:	48 e4       	ldi	r20, 0x48	; 72
    a886:	54 e4       	ldi	r21, 0x44	; 68
    a888:	0e 94 98 67 	call	0xcf30	; 0xcf30 <__cmpsf2>
    a88c:	88 23       	and	r24, r24
    a88e:	5c f4       	brge	.+22     	; 0xa8a6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x1de>
			((altitudeMslCm - model->InitialAltitudeCm()) - model->ZNEDLocalFrameCm()) < 800 && 
    a890:	20 e0       	ldi	r18, 0x00	; 0
    a892:	30 e0       	ldi	r19, 0x00	; 0
    a894:	48 e4       	ldi	r20, 0x48	; 72
    a896:	54 ec       	ldi	r21, 0xC4	; 196
    a898:	c7 01       	movw	r24, r14
    a89a:	b6 01       	movw	r22, r12
    a89c:	0e 94 c7 69 	call	0xd38e	; 0xd38e <__gesf2>
    a8a0:	18 16       	cp	r1, r24
    a8a2:	0c f4       	brge	.+2      	; 0xa8a6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x1de>
    a8a4:	8d c0       	rjmp	.+282    	; 0xa9c0 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x2f8>
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
		}
					
		
		model->HasNewPressureReading = false;
    a8a6:	d4 01       	movw	r26, r8
    a8a8:	1d 96       	adiw	r26, 0x0d	; 13
    a8aa:	ed 91       	ld	r30, X+
    a8ac:	fc 91       	ld	r31, X
    a8ae:	1e 97       	sbiw	r26, 0x0e	; 14
    a8b0:	ee 5b       	subi	r30, 0xBE	; 190
    a8b2:	fe 4f       	sbci	r31, 0xFE	; 254
    a8b4:	10 82       	st	Z, r1
	
				
	/**
	* Convert position to local NED
	*/
	float localNEDX = 0.0;
    a8b6:	1d a6       	std	Y+45, r1	; 0x2d
    a8b8:	1e a6       	std	Y+46, r1	; 0x2e
    a8ba:	1f a6       	std	Y+47, r1	; 0x2f
    a8bc:	18 aa       	std	Y+48, r1	; 0x30
	float localNEDY = 0.0;
    a8be:	19 a6       	std	Y+41, r1	; 0x29
    a8c0:	1a a6       	std	Y+42, r1	; 0x2a
    a8c2:	1b a6       	std	Y+43, r1	; 0x2b
    a8c4:	1c a6       	std	Y+44, r1	; 0x2c
	float localNEDZ = 0.0;
    a8c6:	1d a2       	std	Y+37, r1	; 0x25
    a8c8:	1e a2       	std	Y+38, r1	; 0x26
    a8ca:	1f a2       	std	Y+39, r1	; 0x27
    a8cc:	18 a6       	std	Y+40, r1	; 0x28
	
	CoordinateUtil::ConvertFromECEFToLocalNED(model->InitialXPositionEcef(), model->InitialYPositionEcef(), model->InitialZPositionEcef(),
		model->XEcefCm(), model->YEcefCm(), model->ZEcefCm(), model->EcefToLocalNEDRotationMatrix,
		localNEDX, localNEDY, localNEDZ);
    a8ce:	f4 01       	movw	r30, r8
    a8d0:	05 85       	ldd	r16, Z+13	; 0x0d
    a8d2:	16 85       	ldd	r17, Z+14	; 0x0e
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    a8d4:	f8 01       	movw	r30, r16
    a8d6:	e2 50       	subi	r30, 0x02	; 2
    a8d8:	ff 4f       	sbci	r31, 0xFF	; 255
    a8da:	a0 80       	ld	r10, Z
    a8dc:	b1 80       	ldd	r11, Z+1	; 0x01
    a8de:	c2 80       	ldd	r12, Z+2	; 0x02
    a8e0:	d3 80       	ldd	r13, Z+3	; 0x03
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
    a8e2:	f8 97       	sbiw	r30, 0x38	; 56
    a8e4:	60 81       	ld	r22, Z
    a8e6:	71 81       	ldd	r23, Z+1	; 0x01
    a8e8:	82 81       	ldd	r24, Z+2	; 0x02
    a8ea:	93 81       	ldd	r25, Z+3	; 0x03
    a8ec:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    a8f0:	69 ab       	std	Y+49, r22	; 0x31
    a8f2:	7a ab       	std	Y+50, r23	; 0x32
    a8f4:	8b ab       	std	Y+51, r24	; 0x33
    a8f6:	9c ab       	std	Y+52, r25	; 0x34
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
    a8f8:	f8 01       	movw	r30, r16
    a8fa:	ee 53       	subi	r30, 0x3E	; 62
    a8fc:	ff 4f       	sbci	r31, 0xFF	; 255
    a8fe:	60 81       	ld	r22, Z
    a900:	71 81       	ldd	r23, Z+1	; 0x01
    a902:	82 81       	ldd	r24, Z+2	; 0x02
    a904:	93 81       	ldd	r25, Z+3	; 0x03
    a906:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    a90a:	2b 01       	movw	r4, r22
    a90c:	3c 01       	movw	r6, r24
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
    a90e:	f8 01       	movw	r30, r16
    a910:	e2 54       	subi	r30, 0x42	; 66
    a912:	ff 4f       	sbci	r31, 0xFF	; 255
    a914:	60 81       	ld	r22, Z
    a916:	71 81       	ldd	r23, Z+1	; 0x01
    a918:	82 81       	ldd	r24, Z+2	; 0x02
    a91a:	93 81       	ldd	r25, Z+3	; 0x03
    a91c:	0e 94 07 68 	call	0xd00e	; 0xd00e <__fixsfsi>
    a920:	9e 01       	movw	r18, r28
    a922:	2b 5d       	subi	r18, 0xDB	; 219
    a924:	3f 4f       	sbci	r19, 0xFF	; 255
    a926:	3f 93       	push	r19
    a928:	2f 93       	push	r18
    a92a:	2c 5f       	subi	r18, 0xFC	; 252
    a92c:	3f 4f       	sbci	r19, 0xFF	; 255
    a92e:	3f 93       	push	r19
    a930:	2f 93       	push	r18
    a932:	2c 5f       	subi	r18, 0xFC	; 252
    a934:	3f 4f       	sbci	r19, 0xFF	; 255
    a936:	3f 93       	push	r19
    a938:	2f 93       	push	r18
    a93a:	98 01       	movw	r18, r16
    a93c:	22 5e       	subi	r18, 0xE2	; 226
    a93e:	3e 4f       	sbci	r19, 0xFE	; 254
    a940:	3f 93       	push	r19
    a942:	2f 93       	push	r18
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    a944:	f8 01       	movw	r30, r16
    a946:	ea 5f       	subi	r30, 0xFA	; 250
    a948:	fe 4f       	sbci	r31, 0xFE	; 254
    a94a:	23 81       	ldd	r18, Z+3	; 0x03
    a94c:	2f 93       	push	r18
    a94e:	22 81       	ldd	r18, Z+2	; 0x02
    a950:	2f 93       	push	r18
    a952:	21 81       	ldd	r18, Z+1	; 0x01
    a954:	2f 93       	push	r18
    a956:	20 81       	ld	r18, Z
    a958:	2f 93       	push	r18
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    a95a:	34 97       	sbiw	r30, 0x04	; 4
    a95c:	23 81       	ldd	r18, Z+3	; 0x03
    a95e:	2f 93       	push	r18
    a960:	22 81       	ldd	r18, Z+2	; 0x02
    a962:	2f 93       	push	r18
    a964:	21 81       	ldd	r18, Z+1	; 0x01
    a966:	2f 93       	push	r18
    a968:	20 81       	ld	r18, Z
    a96a:	2f 93       	push	r18
    a96c:	e9 a8       	ldd	r14, Y+49	; 0x31
    a96e:	fa a8       	ldd	r15, Y+50	; 0x32
    a970:	0b a9       	ldd	r16, Y+51	; 0x33
    a972:	1c a9       	ldd	r17, Y+52	; 0x34
    a974:	a3 01       	movw	r20, r6
    a976:	92 01       	movw	r18, r4
    a978:	0e 94 c6 61 	call	0xc38c	; 0xc38c <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>
	
	model->XNEDLocalFrameCm(localNEDX);
    a97c:	d4 01       	movw	r26, r8
    a97e:	1d 96       	adiw	r26, 0x0d	; 13
    a980:	ed 91       	ld	r30, X+
    a982:	fc 91       	ld	r31, X
    a984:	1e 97       	sbiw	r26, 0x0e	; 14
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
    a986:	8d a5       	ldd	r24, Y+45	; 0x2d
    a988:	9e a5       	ldd	r25, Y+46	; 0x2e
    a98a:	af a5       	ldd	r26, Y+47	; 0x2f
    a98c:	b8 a9       	ldd	r27, Y+48	; 0x30
    a98e:	82 a3       	std	Z+34, r24	; 0x22
    a990:	93 a3       	std	Z+35, r25	; 0x23
    a992:	a4 a3       	std	Z+36, r26	; 0x24
    a994:	b5 a3       	std	Z+37, r27	; 0x25
	model->YNEDLocalFrameCm(localNEDY);
    a996:	d4 01       	movw	r26, r8
    a998:	1d 96       	adiw	r26, 0x0d	; 13
    a99a:	ed 91       	ld	r30, X+
    a99c:	fc 91       	ld	r31, X
    a99e:	1e 97       	sbiw	r26, 0x0e	; 14
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}
    a9a0:	e2 5b       	subi	r30, 0xB2	; 178
    a9a2:	ff 4f       	sbci	r31, 0xFF	; 255
    a9a4:	89 a5       	ldd	r24, Y+41	; 0x29
    a9a6:	9a a5       	ldd	r25, Y+42	; 0x2a
    a9a8:	ab a5       	ldd	r26, Y+43	; 0x2b
    a9aa:	bc a5       	ldd	r27, Y+44	; 0x2c
    a9ac:	80 83       	st	Z, r24
    a9ae:	91 83       	std	Z+1, r25	; 0x01
    a9b0:	a2 83       	std	Z+2, r26	; 0x02
    a9b2:	b3 83       	std	Z+3, r27	; 0x03
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    a9b4:	0f b6       	in	r0, 0x3f	; 63
    a9b6:	f8 94       	cli
    a9b8:	de bf       	out	0x3e, r29	; 62
    a9ba:	0f be       	out	0x3f, r0	; 63
    a9bc:	cd bf       	out	0x3d, r28	; 61
    a9be:	3c c0       	rjmp	.+120    	; 0xaa38 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x370>
	
			//exponential smoothing. http://en.wikipedia.org/wiki/Exponential_smoothing
			//St = aX + (1-a)St-1
			float altitudeCmAglTemp = (float) (altitudeMslCm - model->InitialAltitudeCm());
			float previousAltitudeCmAgl = model->ZNEDLocalFrameCm();
			float currentAltitudeCmAgl = WEIGHT * (altitudeCmAglTemp) + (1 - WEIGHT)*previousAltitudeCmAgl;
    a9c0:	2a e9       	ldi	r18, 0x9A	; 154
    a9c2:	39 e9       	ldi	r19, 0x99	; 153
    a9c4:	49 e1       	ldi	r20, 0x19	; 25
    a9c6:	5e e3       	ldi	r21, 0x3E	; 62
    a9c8:	69 a9       	ldd	r22, Y+49	; 0x31
    a9ca:	7a a9       	ldd	r23, Y+50	; 0x32
    a9cc:	8b a9       	ldd	r24, Y+51	; 0x33
    a9ce:	9c a9       	ldd	r25, Y+52	; 0x34
    a9d0:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    a9d4:	6b 01       	movw	r12, r22
    a9d6:	7c 01       	movw	r14, r24
    a9d8:	2a e9       	ldi	r18, 0x9A	; 154
    a9da:	39 e9       	ldi	r19, 0x99	; 153
    a9dc:	49 e5       	ldi	r20, 0x59	; 89
    a9de:	5f e3       	ldi	r21, 0x3F	; 63
    a9e0:	c3 01       	movw	r24, r6
    a9e2:	b2 01       	movw	r22, r4
    a9e4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    a9e8:	9b 01       	movw	r18, r22
    a9ea:	ac 01       	movw	r20, r24
    a9ec:	c7 01       	movw	r24, r14
    a9ee:	b6 01       	movw	r22, r12
    a9f0:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    a9f4:	6b 01       	movw	r12, r22
    a9f6:	7c 01       	movw	r14, r24

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}
    a9f8:	02 57       	subi	r16, 0x72	; 114
    a9fa:	1f 4f       	sbci	r17, 0xFF	; 255
			//model->AltitudeMetersAgl(currentAltitudeMetersAgl);
	
			//Calculate altitude speed.
			//model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) * BAROMETER_SENSOR_READ_PERIOD));
			model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) / barometerSensorReadPeriod));
    a9fc:	a3 01       	movw	r20, r6
    a9fe:	92 01       	movw	r18, r4
    aa00:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    aa04:	d4 01       	movw	r26, r8
    aa06:	17 96       	adiw	r26, 0x07	; 7
    aa08:	2d 91       	ld	r18, X+
    aa0a:	3d 91       	ld	r19, X+
    aa0c:	4d 91       	ld	r20, X+
    aa0e:	5c 91       	ld	r21, X
    aa10:	1a 97       	sbiw	r26, 0x0a	; 10
    aa12:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    aa16:	f8 01       	movw	r30, r16
    aa18:	60 83       	st	Z, r22
    aa1a:	71 83       	std	Z+1, r23	; 0x01
    aa1c:	82 83       	std	Z+2, r24	; 0x02
    aa1e:	93 83       	std	Z+3, r25	; 0x03
	
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
    aa20:	d4 01       	movw	r26, r8
    aa22:	1d 96       	adiw	r26, 0x0d	; 13
    aa24:	ed 91       	ld	r30, X+
    aa26:	fc 91       	ld	r31, X
    aa28:	1e 97       	sbiw	r26, 0x0e	; 14
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }
    aa2a:	e2 58       	subi	r30, 0x82	; 130
    aa2c:	ff 4f       	sbci	r31, 0xFF	; 255
    aa2e:	c0 82       	st	Z, r12
    aa30:	d1 82       	std	Z+1, r13	; 0x01
    aa32:	e2 82       	std	Z+2, r14	; 0x02
    aa34:	f3 82       	std	Z+3, r15	; 0x03
    aa36:	37 cf       	rjmp	.-402    	; 0xa8a6 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x1de>
	model->YNEDLocalFrameCm(localNEDY);
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    aa38:	e4 96       	adiw	r28, 0x34	; 52
    aa3a:	0f b6       	in	r0, 0x3f	; 63
    aa3c:	f8 94       	cli
    aa3e:	de bf       	out	0x3e, r29	; 62
    aa40:	0f be       	out	0x3f, r0	; 63
    aa42:	cd bf       	out	0x3d, r28	; 61
    aa44:	df 91       	pop	r29
    aa46:	cf 91       	pop	r28
    aa48:	1f 91       	pop	r17
    aa4a:	0f 91       	pop	r16
    aa4c:	ff 90       	pop	r15
    aa4e:	ef 90       	pop	r14
    aa50:	df 90       	pop	r13
    aa52:	cf 90       	pop	r12
    aa54:	bf 90       	pop	r11
    aa56:	af 90       	pop	r10
    aa58:	9f 90       	pop	r9
    aa5a:	8f 90       	pop	r8
    aa5c:	7f 90       	pop	r7
    aa5e:	6f 90       	pop	r6
    aa60:	5f 90       	pop	r5
    aa62:	4f 90       	pop	r4
    aa64:	08 95       	ret

0000aa66 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float PVNavigationTask::WEIGHT = .15;


PVNavigationTask::PVNavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    aa66:	4f 92       	push	r4
    aa68:	5f 92       	push	r5
    aa6a:	6f 92       	push	r6
    aa6c:	7f 92       	push	r7
    aa6e:	af 92       	push	r10
    aa70:	bf 92       	push	r11
    aa72:	cf 92       	push	r12
    aa74:	df 92       	push	r13
    aa76:	ef 92       	push	r14
    aa78:	ff 92       	push	r15
    aa7a:	0f 93       	push	r16
    aa7c:	1f 93       	push	r17
    aa7e:	cf 93       	push	r28
    aa80:	df 93       	push	r29
    aa82:	ec 01       	movw	r28, r24
    aa84:	2a 01       	movw	r4, r20
    aa86:	3b 01       	movw	r6, r22
    aa88:	59 01       	movw	r10, r18
    aa8a:	b7 01       	movw	r22, r14
    aa8c:	a6 01       	movw	r20, r12
Task(delay, period),
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model)
    aa8e:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    aa92:	84 e1       	ldi	r24, 0x14	; 20
    aa94:	93 e0       	ldi	r25, 0x03	; 3
    aa96:	99 83       	std	Y+1, r25	; 0x01
    aa98:	88 83       	st	Y, r24
    aa9a:	4f 82       	std	Y+7, r4	; 0x07
    aa9c:	58 86       	std	Y+8, r5	; 0x08
    aa9e:	69 86       	std	Y+9, r6	; 0x09
    aaa0:	7a 86       	std	Y+10, r7	; 0x0a
    aaa2:	bc 86       	std	Y+12, r11	; 0x0c
    aaa4:	ab 86       	std	Y+11, r10	; 0x0b
    aaa6:	1e 87       	std	Y+14, r17	; 0x0e
    aaa8:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    aaaa:	df 91       	pop	r29
    aaac:	cf 91       	pop	r28
    aaae:	1f 91       	pop	r17
    aab0:	0f 91       	pop	r16
    aab2:	ff 90       	pop	r15
    aab4:	ef 90       	pop	r14
    aab6:	df 90       	pop	r13
    aab8:	cf 90       	pop	r12
    aaba:	bf 90       	pop	r11
    aabc:	af 90       	pop	r10
    aabe:	7f 90       	pop	r7
    aac0:	6f 90       	pop	r6
    aac2:	5f 90       	pop	r5
    aac4:	4f 90       	pop	r4
    aac6:	08 95       	ret

0000aac8 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>:
    aac8:	26 e7       	ldi	r18, 0x76	; 118
    aaca:	33 e0       	ldi	r19, 0x03	; 3
    aacc:	fc 01       	movw	r30, r24
    aace:	31 83       	std	Z+1, r19	; 0x01
    aad0:	20 83       	st	Z, r18
    aad2:	08 95       	ret

0000aad4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>:
    aad4:	26 e7       	ldi	r18, 0x76	; 118
    aad6:	33 e0       	ldi	r19, 0x03	; 3
    aad8:	fc 01       	movw	r30, r24
    aada:	31 83       	std	Z+1, r19	; 0x01
    aadc:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadBarometerSensorTask : public Task
    aade:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    aae2:	08 95       	ret

0000aae4 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>:
	
}


void ReadBarometerSensorTask::runTaskImpl()
{
    aae4:	0f 93       	push	r16
    aae6:	1f 93       	push	r17
    aae8:	cf 93       	push	r28
    aaea:	df 93       	push	r29
    aaec:	ec 01       	movw	r28, r24
	//barometerSensor->readSensor();
	
	switch(step++)
    aaee:	8b 85       	ldd	r24, Y+11	; 0x0b
    aaf0:	9c 85       	ldd	r25, Y+12	; 0x0c
    aaf2:	9c 01       	movw	r18, r24
    aaf4:	2f 5f       	subi	r18, 0xFF	; 255
    aaf6:	3f 4f       	sbci	r19, 0xFF	; 255
    aaf8:	3c 87       	std	Y+12, r19	; 0x0c
    aafa:	2b 87       	std	Y+11, r18	; 0x0b
    aafc:	81 30       	cpi	r24, 0x01	; 1
    aafe:	91 05       	cpc	r25, r1
    ab00:	51 f0       	breq	.+20     	; 0xab16 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x32>
    ab02:	82 30       	cpi	r24, 0x02	; 2
    ab04:	91 05       	cpc	r25, r1
    ab06:	81 f0       	breq	.+32     	; 0xab28 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x44>
    ab08:	89 2b       	or	r24, r25
    ab0a:	d1 f5       	brne	.+116    	; 0xab80 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x9c>
	{
		
		case 0:
			barometerSensor->sendD1Command();
    ab0c:	89 85       	ldd	r24, Y+9	; 0x09
    ab0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    ab10:	0e 94 9e 41 	call	0x833c	; 0x833c <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>
		break;
    ab14:	37 c0       	rjmp	.+110    	; 0xab84 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 1:
			barometerSensor->readD1Data();
    ab16:	89 85       	ldd	r24, Y+9	; 0x09
    ab18:	9a 85       	ldd	r25, Y+10	; 0x0a
    ab1a:	0e 94 a5 41 	call	0x834a	; 0x834a <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>
			barometerSensor->sendD2Command();
    ab1e:	89 85       	ldd	r24, Y+9	; 0x09
    ab20:	9a 85       	ldd	r25, Y+10	; 0x0a
    ab22:	0e 94 e6 41 	call	0x83cc	; 0x83cc <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>
		break;
    ab26:	2e c0       	rjmp	.+92     	; 0xab84 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 2:
			barometerSensor->readD2Data();
    ab28:	89 85       	ldd	r24, Y+9	; 0x09
    ab2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    ab2c:	0e 94 ed 41 	call	0x83da	; 0x83da <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>
			barometerSensor->processBaroData();
    ab30:	89 85       	ldd	r24, Y+9	; 0x09
    ab32:	9a 85       	ldd	r25, Y+10	; 0x0a
    ab34:	0e 94 2e 42 	call	0x845c	; 0x845c <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>
			
			if (model->SensorInput() == SystemModel::RealSensors)
    ab38:	ef 81       	ldd	r30, Y+7	; 0x07
    ab3a:	f8 85       	ldd	r31, Y+8	; 0x08
    ab3c:	84 81       	ldd	r24, Z+4	; 0x04
    ab3e:	81 30       	cpi	r24, 0x01	; 1
    ab40:	e1 f4       	brne	.+56     	; 0xab7a <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x96>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    ab42:	8f 01       	movw	r16, r30
    ab44:	0a 5e       	subi	r16, 0xEA	; 234
    ab46:	1e 4f       	sbci	r17, 0xFE	; 254
					return temperatureCelcius;
				}
				
				long getPressureMillibars()
				{
					return pressureMillibars;
    ab48:	e9 85       	ldd	r30, Y+9	; 0x09
    ab4a:	fa 85       	ldd	r31, Y+10	; 0x0a
			{
				model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
    ab4c:	66 85       	ldd	r22, Z+14	; 0x0e
    ab4e:	77 85       	ldd	r23, Z+15	; 0x0f
    ab50:	80 89       	ldd	r24, Z+16	; 0x10
    ab52:	91 89       	ldd	r25, Z+17	; 0x11
    ab54:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    ab58:	20 e0       	ldi	r18, 0x00	; 0
    ab5a:	30 e0       	ldi	r19, 0x00	; 0
    ab5c:	48 ec       	ldi	r20, 0xC8	; 200
    ab5e:	52 e4       	ldi	r21, 0x42	; 66
    ab60:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    ab64:	f8 01       	movw	r30, r16
    ab66:	60 83       	st	Z, r22
    ab68:	71 83       	std	Z+1, r23	; 0x01
    ab6a:	82 83       	std	Z+2, r24	; 0x02
    ab6c:	93 83       	std	Z+3, r25	; 0x03
				model->HasNewPressureReading = true;
    ab6e:	ef 81       	ldd	r30, Y+7	; 0x07
    ab70:	f8 85       	ldd	r31, Y+8	; 0x08
    ab72:	ee 5b       	subi	r30, 0xBE	; 190
    ab74:	fe 4f       	sbci	r31, 0xFE	; 254
    ab76:	81 e0       	ldi	r24, 0x01	; 1
    ab78:	80 83       	st	Z, r24
			}
			
			
			step = 0;
    ab7a:	1c 86       	std	Y+12, r1	; 0x0c
    ab7c:	1b 86       	std	Y+11, r1	; 0x0b
		break;
    ab7e:	02 c0       	rjmp	.+4      	; 0xab84 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		default:
			step = 0;
    ab80:	1c 86       	std	Y+12, r1	; 0x0c
    ab82:	1b 86       	std	Y+11, r1	; 0x0b
		*/
	}
	
	
	//model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
}
    ab84:	df 91       	pop	r29
    ab86:	cf 91       	pop	r28
    ab88:	1f 91       	pop	r17
    ab8a:	0f 91       	pop	r16
    ab8c:	08 95       	ret

0000ab8e <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>:
 */ 
#include "ReadBarometerSensorTask.h"

using namespace helicopter::tasks;

ReadBarometerSensorTask::ReadBarometerSensorTask (SystemModel *model, BarometerSensor *barometerSensor, int delay, int period) :
    ab8e:	cf 92       	push	r12
    ab90:	df 92       	push	r13
    ab92:	ef 92       	push	r14
    ab94:	ff 92       	push	r15
    ab96:	0f 93       	push	r16
    ab98:	1f 93       	push	r17
    ab9a:	cf 93       	push	r28
    ab9c:	df 93       	push	r29
    ab9e:	ec 01       	movw	r28, r24
    aba0:	6b 01       	movw	r12, r22
    aba2:	7a 01       	movw	r14, r20
    aba4:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
barometerSensor(barometerSensor),
step(0)
    aba6:	b9 01       	movw	r22, r18
    aba8:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    abac:	82 e2       	ldi	r24, 0x22	; 34
    abae:	93 e0       	ldi	r25, 0x03	; 3
    abb0:	99 83       	std	Y+1, r25	; 0x01
    abb2:	88 83       	st	Y, r24
    abb4:	d8 86       	std	Y+8, r13	; 0x08
    abb6:	cf 82       	std	Y+7, r12	; 0x07
    abb8:	fa 86       	std	Y+10, r15	; 0x0a
    abba:	e9 86       	std	Y+9, r14	; 0x09
    abbc:	1c 86       	std	Y+12, r1	; 0x0c
    abbe:	1b 86       	std	Y+11, r1	; 0x0b
{
	
}
    abc0:	df 91       	pop	r29
    abc2:	cf 91       	pop	r28
    abc4:	1f 91       	pop	r17
    abc6:	0f 91       	pop	r16
    abc8:	ff 90       	pop	r15
    abca:	ef 90       	pop	r14
    abcc:	df 90       	pop	r13
    abce:	cf 90       	pop	r12
    abd0:	08 95       	ret

0000abd2 <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>:
    abd2:	26 e7       	ldi	r18, 0x76	; 118
    abd4:	33 e0       	ldi	r19, 0x03	; 3
    abd6:	fc 01       	movw	r30, r24
    abd8:	31 83       	std	Z+1, r19	; 0x01
    abda:	20 83       	st	Z, r18
    abdc:	08 95       	ret

0000abde <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>:
    abde:	26 e7       	ldi	r18, 0x76	; 118
    abe0:	33 e0       	ldi	r19, 0x03	; 3
    abe2:	fc 01       	movw	r30, r24
    abe4:	31 83       	std	Z+1, r19	; 0x01
    abe6:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadGPSSensorTask : public Task
    abe8:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    abec:	08 95       	ret

0000abee <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>:
	
}


void ReadGPSSensorTask::runTaskImpl()
{
    abee:	cf 93       	push	r28
    abf0:	df 93       	push	r29
    abf2:	ec 01       	movw	r28, r24
	
	int status = gpsSensor->processSensorSolution();
    abf4:	89 85       	ldd	r24, Y+9	; 0x09
    abf6:	9a 85       	ldd	r25, Y+10	; 0x0a
    abf8:	0e 94 8f 46 	call	0x8d1e	; 0x8d1e <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    abfc:	ef 81       	ldd	r30, Y+7	; 0x07
    abfe:	f8 85       	ldd	r31, Y+8	; 0x08
    ac00:	24 81       	ldd	r18, Z+4	; 0x04
    ac02:	21 30       	cpi	r18, 0x01	; 1
    ac04:	09 f0       	breq	.+2      	; 0xac08 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0x1a>
    ac06:	65 c0       	rjmp	.+202    	; 0xacd2 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
					return longitudeDegE7;
				}			
					
				long getXEcefCm()
				{
					return xEcefCm;
    ac08:	a9 85       	ldd	r26, Y+9	; 0x09
    ac0a:	ba 85       	ldd	r27, Y+10	; 0x0a
    ac0c:	1a 96       	adiw	r26, 0x0a	; 10
    ac0e:	4d 91       	ld	r20, X+
    ac10:	5d 91       	ld	r21, X+
    ac12:	6d 91       	ld	r22, X+
    ac14:	7c 91       	ld	r23, X
    ac16:	1d 97       	sbiw	r26, 0x0d	; 13
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    ac18:	e2 50       	subi	r30, 0x02	; 2
    ac1a:	ff 4f       	sbci	r31, 0xFF	; 255
    ac1c:	40 83       	st	Z, r20
    ac1e:	51 83       	std	Z+1, r21	; 0x01
    ac20:	62 83       	std	Z+2, r22	; 0x02
    ac22:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYEcefCm()
				{
					return yEcefCm;
    ac24:	e9 85       	ldd	r30, Y+9	; 0x09
    ac26:	fa 85       	ldd	r31, Y+10	; 0x0a
    ac28:	46 85       	ldd	r20, Z+14	; 0x0e
    ac2a:	57 85       	ldd	r21, Z+15	; 0x0f
    ac2c:	60 89       	ldd	r22, Z+16	; 0x10
    ac2e:	71 89       	ldd	r23, Z+17	; 0x11
	{
		model->XEcefCm(gpsSensor->getXEcefCm());
		model->YEcefCm(gpsSensor->getYEcefCm());
    ac30:	ef 81       	ldd	r30, Y+7	; 0x07
    ac32:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    ac34:	ee 5f       	subi	r30, 0xFE	; 254
    ac36:	fe 4f       	sbci	r31, 0xFE	; 254
    ac38:	40 83       	st	Z, r20
    ac3a:	51 83       	std	Z+1, r21	; 0x01
    ac3c:	62 83       	std	Z+2, r22	; 0x02
    ac3e:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZEcefCm()
				{
					return zEcefCm;
    ac40:	e9 85       	ldd	r30, Y+9	; 0x09
    ac42:	fa 85       	ldd	r31, Y+10	; 0x0a
    ac44:	42 89       	ldd	r20, Z+18	; 0x12
    ac46:	53 89       	ldd	r21, Z+19	; 0x13
    ac48:	64 89       	ldd	r22, Z+20	; 0x14
    ac4a:	75 89       	ldd	r23, Z+21	; 0x15
		model->ZEcefCm(gpsSensor->getZEcefCm());
    ac4c:	ef 81       	ldd	r30, Y+7	; 0x07
    ac4e:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    ac50:	ea 5f       	subi	r30, 0xFA	; 250
    ac52:	fe 4f       	sbci	r31, 0xFE	; 254
    ac54:	40 83       	st	Z, r20
    ac56:	51 83       	std	Z+1, r21	; 0x01
    ac58:	62 83       	std	Z+2, r22	; 0x02
    ac5a:	73 83       	std	Z+3, r23	; 0x03
				
				
				
				long getXVEcefCms()
				{
					return xVEcefCms;
    ac5c:	e9 85       	ldd	r30, Y+9	; 0x09
    ac5e:	fa 85       	ldd	r31, Y+10	; 0x0a
    ac60:	42 8d       	ldd	r20, Z+26	; 0x1a
    ac62:	53 8d       	ldd	r21, Z+27	; 0x1b
    ac64:	64 8d       	ldd	r22, Z+28	; 0x1c
    ac66:	75 8d       	ldd	r23, Z+29	; 0x1d
		
		model->XVEcefCms(gpsSensor->getXVEcefCms());
    ac68:	ef 81       	ldd	r30, Y+7	; 0x07
    ac6a:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    ac6c:	e6 5f       	subi	r30, 0xF6	; 246
    ac6e:	fe 4f       	sbci	r31, 0xFE	; 254
    ac70:	40 83       	st	Z, r20
    ac72:	51 83       	std	Z+1, r21	; 0x01
    ac74:	62 83       	std	Z+2, r22	; 0x02
    ac76:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYVEcefCms()
				{
					return yVEcefCms;
    ac78:	e9 85       	ldd	r30, Y+9	; 0x09
    ac7a:	fa 85       	ldd	r31, Y+10	; 0x0a
    ac7c:	46 8d       	ldd	r20, Z+30	; 0x1e
    ac7e:	57 8d       	ldd	r21, Z+31	; 0x1f
    ac80:	60 a1       	ldd	r22, Z+32	; 0x20
    ac82:	71 a1       	ldd	r23, Z+33	; 0x21
		model->YVEcefCms(gpsSensor->getYVEcefCms());
    ac84:	ef 81       	ldd	r30, Y+7	; 0x07
    ac86:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    ac88:	e2 5f       	subi	r30, 0xF2	; 242
    ac8a:	fe 4f       	sbci	r31, 0xFE	; 254
    ac8c:	40 83       	st	Z, r20
    ac8e:	51 83       	std	Z+1, r21	; 0x01
    ac90:	62 83       	std	Z+2, r22	; 0x02
    ac92:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZVEcefCms()
				{
					return zVEcefCms;
    ac94:	e9 85       	ldd	r30, Y+9	; 0x09
    ac96:	fa 85       	ldd	r31, Y+10	; 0x0a
    ac98:	42 a1       	ldd	r20, Z+34	; 0x22
    ac9a:	53 a1       	ldd	r21, Z+35	; 0x23
    ac9c:	64 a1       	ldd	r22, Z+36	; 0x24
    ac9e:	75 a1       	ldd	r23, Z+37	; 0x25
		model->ZVEcefCms(gpsSensor->getZVEcefCms());
    aca0:	ef 81       	ldd	r30, Y+7	; 0x07
    aca2:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    aca4:	ee 5e       	subi	r30, 0xEE	; 238
    aca6:	fe 4f       	sbci	r31, 0xFE	; 254
    aca8:	40 83       	st	Z, r20
    acaa:	51 83       	std	Z+1, r21	; 0x01
    acac:	62 83       	std	Z+2, r22	; 0x02
    acae:	73 83       	std	Z+3, r23	; 0x03
		
		if (status == -1)
    acb0:	01 96       	adiw	r24, 0x01	; 1
    acb2:	79 f4       	brne	.+30     	; 0xacd2 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
		{
			model->ChecksumErrors(model->ChecksumErrors() + 1);
    acb4:	ef 81       	ldd	r30, Y+7	; 0x07
    acb6:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    acb8:	ee 54       	subi	r30, 0x4E	; 78
    acba:	ff 4f       	sbci	r31, 0xFF	; 255
    acbc:	80 81       	ld	r24, Z
    acbe:	91 81       	ldd	r25, Z+1	; 0x01
    acc0:	a2 81       	ldd	r26, Z+2	; 0x02
    acc2:	b3 81       	ldd	r27, Z+3	; 0x03
    acc4:	01 96       	adiw	r24, 0x01	; 1
    acc6:	a1 1d       	adc	r26, r1
    acc8:	b1 1d       	adc	r27, r1
    acca:	80 83       	st	Z, r24
    accc:	91 83       	std	Z+1, r25	; 0x01
    acce:	a2 83       	std	Z+2, r26	; 0x02
    acd0:	b3 83       	std	Z+3, r27	; 0x03
	model->XVEcefCms(gpsSensor->getXVEcefCms());
	model->YVEcefCms(gpsSensor->getYVEcefCms());
	model->ZVEcefCms(gpsSensor->getZVEcefCms());
	*/
	
}
    acd2:	df 91       	pop	r29
    acd4:	cf 91       	pop	r28
    acd6:	08 95       	ret

0000acd8 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>:
 */ 
#include "ReadGPSSensorTask.h"

using namespace helicopter::tasks;

ReadGPSSensorTask::ReadGPSSensorTask (SystemModel *model, GPSSensor *gpsSensor, int delay, int period) :
    acd8:	cf 92       	push	r12
    acda:	df 92       	push	r13
    acdc:	ef 92       	push	r14
    acde:	ff 92       	push	r15
    ace0:	0f 93       	push	r16
    ace2:	1f 93       	push	r17
    ace4:	cf 93       	push	r28
    ace6:	df 93       	push	r29
    ace8:	ec 01       	movw	r28, r24
    acea:	6b 01       	movw	r12, r22
    acec:	7a 01       	movw	r14, r20
    acee:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
gpsSensor(gpsSensor),
sendReadCommand(true)
    acf0:	b9 01       	movw	r22, r18
    acf2:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    acf6:	80 e3       	ldi	r24, 0x30	; 48
    acf8:	93 e0       	ldi	r25, 0x03	; 3
    acfa:	99 83       	std	Y+1, r25	; 0x01
    acfc:	88 83       	st	Y, r24
    acfe:	d8 86       	std	Y+8, r13	; 0x08
    ad00:	cf 82       	std	Y+7, r12	; 0x07
    ad02:	fa 86       	std	Y+10, r15	; 0x0a
    ad04:	e9 86       	std	Y+9, r14	; 0x09
    ad06:	81 e0       	ldi	r24, 0x01	; 1
    ad08:	8b 87       	std	Y+11, r24	; 0x0b
{
	
}
    ad0a:	df 91       	pop	r29
    ad0c:	cf 91       	pop	r28
    ad0e:	1f 91       	pop	r17
    ad10:	0f 91       	pop	r16
    ad12:	ff 90       	pop	r15
    ad14:	ef 90       	pop	r14
    ad16:	df 90       	pop	r13
    ad18:	cf 90       	pop	r12
    ad1a:	08 95       	ret

0000ad1c <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>:
    ad1c:	26 e7       	ldi	r18, 0x76	; 118
    ad1e:	33 e0       	ldi	r19, 0x03	; 3
    ad20:	fc 01       	movw	r30, r24
    ad22:	31 83       	std	Z+1, r19	; 0x01
    ad24:	20 83       	st	Z, r18
    ad26:	08 95       	ret

0000ad28 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>:
    ad28:	26 e7       	ldi	r18, 0x76	; 118
    ad2a:	33 e0       	ldi	r19, 0x03	; 3
    ad2c:	fc 01       	movw	r30, r24
    ad2e:	31 83       	std	Z+1, r19	; 0x01
    ad30:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadIMUSensorTask : public Task
    ad32:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    ad36:	08 95       	ret

0000ad38 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>:
	
}


void ReadIMUSensorTask::runTaskImpl()
{
    ad38:	cf 93       	push	r28
    ad3a:	df 93       	push	r29
    ad3c:	ec 01       	movw	r28, r24
	//Read the sensor values from the IMU Sensor.
	imuSensor->readSensor();
    ad3e:	89 85       	ldd	r24, Y+9	; 0x09
    ad40:	9a 85       	ldd	r25, Y+10	; 0x0a
    ad42:	0e 94 e1 49 	call	0x93c2	; 0x93c2 <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    ad46:	ef 81       	ldd	r30, Y+7	; 0x07
    ad48:	f8 85       	ldd	r31, Y+8	; 0x08
    ad4a:	84 81       	ldd	r24, Z+4	; 0x04
    ad4c:	81 30       	cpi	r24, 0x01	; 1
    ad4e:	09 f0       	breq	.+2      	; 0xad52 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0x1a>
    ad50:	59 c0       	rjmp	.+178    	; 0xae04 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0xcc>
				int getRawGyroZ() { return rawGyroZ;}					
				
				/**
				 * Returns the acceleration in meters per second per second in the X direction in Front (X) Right (Y) Down (Z) coordinate system
				 */
				float getFRDAccXMss() { return frdAccXMss;}
    ad52:	a9 85       	ldd	r26, Y+9	; 0x09
    ad54:	ba 85       	ldd	r27, Y+10	; 0x0a
    ad56:	d2 96       	adiw	r26, 0x32	; 50
    ad58:	4d 91       	ld	r20, X+
    ad5a:	5d 91       	ld	r21, X+
    ad5c:	6d 91       	ld	r22, X+
    ad5e:	7c 91       	ld	r23, X
    ad60:	d5 97       	sbiw	r26, 0x35	; 53
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    ad62:	ea 51       	subi	r30, 0x1A	; 26
    ad64:	ff 4f       	sbci	r31, 0xFF	; 255
    ad66:	40 83       	st	Z, r20
    ad68:	51 83       	std	Z+1, r21	; 0x01
    ad6a:	62 83       	std	Z+2, r22	; 0x02
    ad6c:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Y direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccYMss() { return frdAccYMss;}
    ad6e:	e9 85       	ldd	r30, Y+9	; 0x09
    ad70:	fa 85       	ldd	r31, Y+10	; 0x0a
    ad72:	46 a9       	ldd	r20, Z+54	; 0x36
    ad74:	57 a9       	ldd	r21, Z+55	; 0x37
    ad76:	60 ad       	ldd	r22, Z+56	; 0x38
    ad78:	71 ad       	ldd	r23, Z+57	; 0x39
	{
		model->XAccelFrdMss(imuSensor->getFRDAccXMss());
		model->YAccelFrdMss(imuSensor->getFRDAccYMss());
    ad7a:	ef 81       	ldd	r30, Y+7	; 0x07
    ad7c:	f8 85       	ldd	r31, Y+8	; 0x08

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    ad7e:	e6 51       	subi	r30, 0x16	; 22
    ad80:	ff 4f       	sbci	r31, 0xFF	; 255
    ad82:	40 83       	st	Z, r20
    ad84:	51 83       	std	Z+1, r21	; 0x01
    ad86:	62 83       	std	Z+2, r22	; 0x02
    ad88:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Z direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccZMss() { return frdAccZMss;}
    ad8a:	e9 85       	ldd	r30, Y+9	; 0x09
    ad8c:	fa 85       	ldd	r31, Y+10	; 0x0a
    ad8e:	42 ad       	ldd	r20, Z+58	; 0x3a
    ad90:	53 ad       	ldd	r21, Z+59	; 0x3b
    ad92:	64 ad       	ldd	r22, Z+60	; 0x3c
    ad94:	75 ad       	ldd	r23, Z+61	; 0x3d
		model->ZAccelFrdMss(imuSensor->getFRDAccZMss());
    ad96:	ef 81       	ldd	r30, Y+7	; 0x07
    ad98:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    ad9a:	e2 51       	subi	r30, 0x12	; 18
    ad9c:	ff 4f       	sbci	r31, 0xFF	; 255
    ad9e:	40 83       	st	Z, r20
    ada0:	51 83       	std	Z+1, r21	; 0x01
    ada2:	62 83       	std	Z+2, r22	; 0x02
    ada4:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the X axis in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDGyroXRs() { return frdGyroXRs;}
    ada6:	e9 85       	ldd	r30, Y+9	; 0x09
    ada8:	fa 85       	ldd	r31, Y+10	; 0x0a
    adaa:	fe 96       	adiw	r30, 0x3e	; 62
    adac:	40 81       	ld	r20, Z
    adae:	51 81       	ldd	r21, Z+1	; 0x01
    adb0:	62 81       	ldd	r22, Z+2	; 0x02
    adb2:	73 81       	ldd	r23, Z+3	; 0x03
		
		model->RollAngularVelocityRadsPerSecond(imuSensor->getFRDGyroXRs());
    adb4:	ef 81       	ldd	r30, Y+7	; 0x07
    adb6:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    adb8:	e2 52       	subi	r30, 0x22	; 34
    adba:	ff 4f       	sbci	r31, 0xFF	; 255
    adbc:	40 83       	st	Z, r20
    adbe:	51 83       	std	Z+1, r21	; 0x01
    adc0:	62 83       	std	Z+2, r22	; 0x02
    adc2:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Y axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroYRs() { return frdGyroYRs;}
    adc4:	e9 85       	ldd	r30, Y+9	; 0x09
    adc6:	fa 85       	ldd	r31, Y+10	; 0x0a
    adc8:	ee 5b       	subi	r30, 0xBE	; 190
    adca:	ff 4f       	sbci	r31, 0xFF	; 255
    adcc:	40 81       	ld	r20, Z
    adce:	51 81       	ldd	r21, Z+1	; 0x01
    add0:	62 81       	ldd	r22, Z+2	; 0x02
    add2:	73 81       	ldd	r23, Z+3	; 0x03
		model->PitchAngularVelocityRadsPerSecond(imuSensor->getFRDGyroYRs());
    add4:	ef 81       	ldd	r30, Y+7	; 0x07
    add6:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    add8:	e6 52       	subi	r30, 0x26	; 38
    adda:	ff 4f       	sbci	r31, 0xFF	; 255
    addc:	40 83       	st	Z, r20
    adde:	51 83       	std	Z+1, r21	; 0x01
    ade0:	62 83       	std	Z+2, r22	; 0x02
    ade2:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Z axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroZRs() { return frdGyroZRs;}	
    ade4:	e9 85       	ldd	r30, Y+9	; 0x09
    ade6:	fa 85       	ldd	r31, Y+10	; 0x0a
    ade8:	ea 5b       	subi	r30, 0xBA	; 186
    adea:	ff 4f       	sbci	r31, 0xFF	; 255
    adec:	40 81       	ld	r20, Z
    adee:	51 81       	ldd	r21, Z+1	; 0x01
    adf0:	62 81       	ldd	r22, Z+2	; 0x02
    adf2:	73 81       	ldd	r23, Z+3	; 0x03
		model->YawAngularVelocityRadsPerSecond(imuSensor->getFRDGyroZRs());		
    adf4:	ef 81       	ldd	r30, Y+7	; 0x07
    adf6:	f8 85       	ldd	r31, Y+8	; 0x08
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    adf8:	ee 51       	subi	r30, 0x1E	; 30
    adfa:	ff 4f       	sbci	r31, 0xFF	; 255
    adfc:	40 83       	st	Z, r20
    adfe:	51 83       	std	Z+1, r21	; 0x01
    ae00:	62 83       	std	Z+2, r22	; 0x02
    ae02:	73 83       	std	Z+3, r23	; 0x03
				
	}
}
    ae04:	df 91       	pop	r29
    ae06:	cf 91       	pop	r28
    ae08:	08 95       	ret

0000ae0a <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>:
#include "ReadIMUSensorTask.h"

using namespace helicopter::tasks;

ReadIMUSensorTask::ReadIMUSensorTask (SystemModel *model, IMUSensor *imuSensor, int delay, int period) :
    ae0a:	cf 92       	push	r12
    ae0c:	df 92       	push	r13
    ae0e:	ef 92       	push	r14
    ae10:	ff 92       	push	r15
    ae12:	0f 93       	push	r16
    ae14:	1f 93       	push	r17
    ae16:	cf 93       	push	r28
    ae18:	df 93       	push	r29
    ae1a:	ec 01       	movw	r28, r24
    ae1c:	6b 01       	movw	r12, r22
    ae1e:	7a 01       	movw	r14, r20
    ae20:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
imuSensor(imuSensor)
    ae22:	b9 01       	movw	r22, r18
    ae24:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    ae28:	8e e3       	ldi	r24, 0x3E	; 62
    ae2a:	93 e0       	ldi	r25, 0x03	; 3
    ae2c:	99 83       	std	Y+1, r25	; 0x01
    ae2e:	88 83       	st	Y, r24
    ae30:	d8 86       	std	Y+8, r13	; 0x08
    ae32:	cf 82       	std	Y+7, r12	; 0x07
    ae34:	fa 86       	std	Y+10, r15	; 0x0a
    ae36:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    ae38:	df 91       	pop	r29
    ae3a:	cf 91       	pop	r28
    ae3c:	1f 91       	pop	r17
    ae3e:	0f 91       	pop	r16
    ae40:	ff 90       	pop	r15
    ae42:	ef 90       	pop	r14
    ae44:	df 90       	pop	r13
    ae46:	cf 90       	pop	r12
    ae48:	08 95       	ret

0000ae4a <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>:
    ae4a:	26 e7       	ldi	r18, 0x76	; 118
    ae4c:	33 e0       	ldi	r19, 0x03	; 3
    ae4e:	fc 01       	movw	r30, r24
    ae50:	31 83       	std	Z+1, r19	; 0x01
    ae52:	20 83       	st	Z, r18
    ae54:	08 95       	ret

0000ae56 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>:
    ae56:	26 e7       	ldi	r18, 0x76	; 118
    ae58:	33 e0       	ldi	r19, 0x03	; 3
    ae5a:	fc 01       	movw	r30, r24
    ae5c:	31 83       	std	Z+1, r19	; 0x01
    ae5e:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadMagnetometerSensorTask : public Task
    ae60:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    ae64:	08 95       	ret

0000ae66 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>:
	
}


void ReadMagnetometerSensorTask::runTaskImpl()
{
    ae66:	cf 93       	push	r28
    ae68:	df 93       	push	r29
    ae6a:	ec 01       	movw	r28, r24


	if (magnetometerSensor->readSensor() != 0)
    ae6c:	89 85       	ldd	r24, Y+9	; 0x09
    ae6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    ae70:	0e 94 6e 4d 	call	0x9adc	; 0x9adc <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    ae74:	89 2b       	or	r24, r25
    ae76:	81 f0       	breq	.+32     	; 0xae98 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x32>
	{
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    ae78:	ef 81       	ldd	r30, Y+7	; 0x07
    ae7a:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    ae7c:	ee 54       	subi	r30, 0x4E	; 78
    ae7e:	ff 4f       	sbci	r31, 0xFF	; 255
    ae80:	80 81       	ld	r24, Z
    ae82:	91 81       	ldd	r25, Z+1	; 0x01
    ae84:	a2 81       	ldd	r26, Z+2	; 0x02
    ae86:	b3 81       	ldd	r27, Z+3	; 0x03
    ae88:	01 96       	adiw	r24, 0x01	; 1
    ae8a:	a1 1d       	adc	r26, r1
    ae8c:	b1 1d       	adc	r27, r1
    ae8e:	80 83       	st	Z, r24
    ae90:	91 83       	std	Z+1, r25	; 0x01
    ae92:	a2 83       	std	Z+2, r26	; 0x02
    ae94:	b3 83       	std	Z+3, r27	; 0x03
    ae96:	2f c0       	rjmp	.+94     	; 0xaef6 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
		return;
	}
	
	if(model->SensorInput() == SystemModel::RealSensors)
    ae98:	ef 81       	ldd	r30, Y+7	; 0x07
    ae9a:	f8 85       	ldd	r31, Y+8	; 0x08
    ae9c:	84 81       	ldd	r24, Z+4	; 0x04
    ae9e:	81 30       	cpi	r24, 0x01	; 1
    aea0:	51 f5       	brne	.+84     	; 0xaef6 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
				 * Retrieves the X sensor reading converted so that
				 * it points out the front of the CPU
				 */				
				float getFRDX()
				{
					return frdMagX;
    aea2:	a9 85       	ldd	r26, Y+9	; 0x09
    aea4:	ba 85       	ldd	r27, Y+10	; 0x0a
    aea6:	16 96       	adiw	r26, 0x06	; 6
    aea8:	4d 91       	ld	r20, X+
    aeaa:	5d 91       	ld	r21, X+
    aeac:	6d 91       	ld	r22, X+
    aeae:	7c 91       	ld	r23, X
    aeb0:	19 97       	sbiw	r26, 0x09	; 9
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    aeb2:	ee 50       	subi	r30, 0x0E	; 14
    aeb4:	ff 4f       	sbci	r31, 0xFF	; 255
    aeb6:	40 83       	st	Z, r20
    aeb8:	51 83       	std	Z+1, r21	; 0x01
    aeba:	62 83       	std	Z+2, r22	; 0x02
    aebc:	73 83       	std	Z+3, r23	; 0x03
				 * Retrieves the Y sensor reading converted so that
				 * it points out the right of the CPU
				 */	
				float getFRDY()
				{
					return frdMagY;
    aebe:	e9 85       	ldd	r30, Y+9	; 0x09
    aec0:	fa 85       	ldd	r31, Y+10	; 0x0a
    aec2:	42 85       	ldd	r20, Z+10	; 0x0a
    aec4:	53 85       	ldd	r21, Z+11	; 0x0b
    aec6:	64 85       	ldd	r22, Z+12	; 0x0c
    aec8:	75 85       	ldd	r23, Z+13	; 0x0d
	{
		model->XMagFrd(magnetometerSensor->getFRDX());
		model->YMagFrd(magnetometerSensor->getFRDY());
    aeca:	ef 81       	ldd	r30, Y+7	; 0x07
    aecc:	f8 85       	ldd	r31, Y+8	; 0x08

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    aece:	ea 50       	subi	r30, 0x0A	; 10
    aed0:	ff 4f       	sbci	r31, 0xFF	; 255
    aed2:	40 83       	st	Z, r20
    aed4:	51 83       	std	Z+1, r21	; 0x01
    aed6:	62 83       	std	Z+2, r22	; 0x02
    aed8:	73 83       	std	Z+3, r23	; 0x03
				 * Retrieves the Z sensor reading converted so that
				 * it points down out of the CPU
				 */					
				float getFRDZ()
				{
					return frdMagZ;
    aeda:	e9 85       	ldd	r30, Y+9	; 0x09
    aedc:	fa 85       	ldd	r31, Y+10	; 0x0a
    aede:	46 85       	ldd	r20, Z+14	; 0x0e
    aee0:	57 85       	ldd	r21, Z+15	; 0x0f
    aee2:	60 89       	ldd	r22, Z+16	; 0x10
    aee4:	71 89       	ldd	r23, Z+17	; 0x11
		model->ZMagFrd(magnetometerSensor->getFRDZ());
    aee6:	ef 81       	ldd	r30, Y+7	; 0x07
    aee8:	f8 85       	ldd	r31, Y+8	; 0x08

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    aeea:	e6 50       	subi	r30, 0x06	; 6
    aeec:	ff 4f       	sbci	r31, 0xFF	; 255
    aeee:	40 83       	st	Z, r20
    aef0:	51 83       	std	Z+1, r21	; 0x01
    aef2:	62 83       	std	Z+2, r22	; 0x02
    aef4:	73 83       	std	Z+3, r23	; 0x03
model->off3(magnetometerSensor->debug[2]);
*/

	}
	
}
    aef6:	df 91       	pop	r29
    aef8:	cf 91       	pop	r28
    aefa:	08 95       	ret

0000aefc <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>:
#include "ReadMagnetometerSensorTask.h"
#include <avr/io.h>

using namespace helicopter::tasks;

ReadMagnetometerSensorTask::ReadMagnetometerSensorTask (SystemModel *model, MagnetometerSensor *magnetometerSensor, int delay, int period) :
    aefc:	cf 92       	push	r12
    aefe:	df 92       	push	r13
    af00:	ef 92       	push	r14
    af02:	ff 92       	push	r15
    af04:	0f 93       	push	r16
    af06:	1f 93       	push	r17
    af08:	cf 93       	push	r28
    af0a:	df 93       	push	r29
    af0c:	ec 01       	movw	r28, r24
    af0e:	6b 01       	movw	r12, r22
    af10:	7a 01       	movw	r14, r20
    af12:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
magnetometerSensor(magnetometerSensor)
    af14:	b9 01       	movw	r22, r18
    af16:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    af1a:	8c e4       	ldi	r24, 0x4C	; 76
    af1c:	93 e0       	ldi	r25, 0x03	; 3
    af1e:	99 83       	std	Y+1, r25	; 0x01
    af20:	88 83       	st	Y, r24
    af22:	d8 86       	std	Y+8, r13	; 0x08
    af24:	cf 82       	std	Y+7, r12	; 0x07
    af26:	fa 86       	std	Y+10, r15	; 0x0a
    af28:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    af2a:	df 91       	pop	r29
    af2c:	cf 91       	pop	r28
    af2e:	1f 91       	pop	r17
    af30:	0f 91       	pop	r16
    af32:	ff 90       	pop	r15
    af34:	ef 90       	pop	r14
    af36:	df 90       	pop	r13
    af38:	cf 90       	pop	r12
    af3a:	08 95       	ret

0000af3c <_ZN10helicopter5tasks16ServoControlTaskD1Ev>:
    af3c:	26 e7       	ldi	r18, 0x76	; 118
    af3e:	33 e0       	ldi	r19, 0x03	; 3
    af40:	fc 01       	movw	r30, r24
    af42:	31 83       	std	Z+1, r19	; 0x01
    af44:	20 83       	st	Z, r18
    af46:	08 95       	ret

0000af48 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>:
    af48:	26 e7       	ldi	r18, 0x76	; 118
    af4a:	33 e0       	ldi	r19, 0x03	; 3
    af4c:	fc 01       	movw	r30, r24
    af4e:	31 83       	std	Z+1, r19	; 0x01
    af50:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ServoControlTask : public Task
    af52:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    af56:	08 95       	ret

0000af58 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>:
	
}


void ServoControlTask::runTaskImpl()
{
    af58:	8f 92       	push	r8
    af5a:	9f 92       	push	r9
    af5c:	af 92       	push	r10
    af5e:	bf 92       	push	r11
    af60:	cf 92       	push	r12
    af62:	df 92       	push	r13
    af64:	ef 92       	push	r14
    af66:	ff 92       	push	r15
    af68:	0f 93       	push	r16
    af6a:	1f 93       	push	r17

	radioControllerInterface->controlServos(model->LateralControl(), model->LongitudeControl(), model->MainRotorCollectiveControl(), model->YawControl(), model->AuxChannelValue());
    af6c:	dc 01       	movw	r26, r24
    af6e:	17 96       	adiw	r26, 0x07	; 7
    af70:	ed 91       	ld	r30, X+
    af72:	fc 91       	ld	r31, X
    af74:	18 97       	sbiw	r26, 0x08	; 8
    af76:	82 84       	ldd	r8, Z+10	; 0x0a
    af78:	93 84       	ldd	r9, Z+11	; 0x0b
    af7a:	a4 84       	ldd	r10, Z+12	; 0x0c
    af7c:	b5 84       	ldd	r11, Z+13	; 0x0d

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    af7e:	df 01       	movw	r26, r30
    af80:	aa 57       	subi	r26, 0x7A	; 122
    af82:	bf 4f       	sbci	r27, 0xFF	; 255
    af84:	cd 90       	ld	r12, X+
    af86:	dd 90       	ld	r13, X+
    af88:	ed 90       	ld	r14, X+
    af8a:	fc 90       	ld	r15, X
    af8c:	13 97       	sbiw	r26, 0x03	; 3
    af8e:	06 a5       	ldd	r16, Z+46	; 0x2e
    af90:	17 a5       	ldd	r17, Z+47	; 0x2f
    af92:	20 a9       	ldd	r18, Z+48	; 0x30
    af94:	31 a9       	ldd	r19, Z+49	; 0x31
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    af96:	9c 97       	sbiw	r26, 0x2c	; 44
    af98:	4d 91       	ld	r20, X+
    af9a:	5d 91       	ld	r21, X+
    af9c:	6d 91       	ld	r22, X+
    af9e:	7c 91       	ld	r23, X
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
    afa0:	e6 5e       	subi	r30, 0xE6	; 230
    afa2:	fe 4f       	sbci	r31, 0xFE	; 254
    afa4:	a3 81       	ldd	r26, Z+3	; 0x03
    afa6:	af 93       	push	r26
    afa8:	a2 81       	ldd	r26, Z+2	; 0x02
    afaa:	af 93       	push	r26
    afac:	a1 81       	ldd	r26, Z+1	; 0x01
    afae:	af 93       	push	r26
    afb0:	e0 81       	ld	r30, Z
    afb2:	ef 93       	push	r30
    afb4:	fc 01       	movw	r30, r24
    afb6:	81 85       	ldd	r24, Z+9	; 0x09
    afb8:	92 85       	ldd	r25, Z+10	; 0x0a
    afba:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>
    afbe:	0f 90       	pop	r0
    afc0:	0f 90       	pop	r0
    afc2:	0f 90       	pop	r0
    afc4:	0f 90       	pop	r0
		
		
		
		
	}*/
}
    afc6:	1f 91       	pop	r17
    afc8:	0f 91       	pop	r16
    afca:	ff 90       	pop	r15
    afcc:	ef 90       	pop	r14
    afce:	df 90       	pop	r13
    afd0:	cf 90       	pop	r12
    afd2:	bf 90       	pop	r11
    afd4:	af 90       	pop	r10
    afd6:	9f 90       	pop	r9
    afd8:	8f 90       	pop	r8
    afda:	08 95       	ret

0000afdc <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>:
 */ 
#include "ServoControlTask.h"

using namespace helicopter::tasks;

ServoControlTask::ServoControlTask (SystemModel *model, RadioControllerInterface *radioControllerInterface,int delay, int period) :
    afdc:	cf 92       	push	r12
    afde:	df 92       	push	r13
    afe0:	ef 92       	push	r14
    afe2:	ff 92       	push	r15
    afe4:	0f 93       	push	r16
    afe6:	1f 93       	push	r17
    afe8:	cf 93       	push	r28
    afea:	df 93       	push	r29
    afec:	ec 01       	movw	r28, r24
    afee:	6b 01       	movw	r12, r22
    aff0:	7a 01       	movw	r14, r20
    aff2:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
radioControllerInterface(radioControllerInterface)
    aff4:	b9 01       	movw	r22, r18
    aff6:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    affa:	8a e5       	ldi	r24, 0x5A	; 90
    affc:	93 e0       	ldi	r25, 0x03	; 3
    affe:	99 83       	std	Y+1, r25	; 0x01
    b000:	88 83       	st	Y, r24
    b002:	d8 86       	std	Y+8, r13	; 0x08
    b004:	cf 82       	std	Y+7, r12	; 0x07
    b006:	fa 86       	std	Y+10, r15	; 0x0a
    b008:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b00a:	df 91       	pop	r29
    b00c:	cf 91       	pop	r28
    b00e:	1f 91       	pop	r17
    b010:	0f 91       	pop	r16
    b012:	ff 90       	pop	r15
    b014:	ef 90       	pop	r14
    b016:	df 90       	pop	r13
    b018:	cf 90       	pop	r12
    b01a:	08 95       	ret

0000b01c <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>:
    b01c:	26 e7       	ldi	r18, 0x76	; 118
    b01e:	33 e0       	ldi	r19, 0x03	; 3
    b020:	fc 01       	movw	r30, r24
    b022:	31 83       	std	Z+1, r19	; 0x01
    b024:	20 83       	st	Z, r18
    b026:	08 95       	ret

0000b028 <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>:
    b028:	26 e7       	ldi	r18, 0x76	; 118
    b02a:	33 e0       	ldi	r19, 0x03	; 3
    b02c:	fc 01       	movw	r30, r24
    b02e:	31 83       	std	Z+1, r19	; 0x01
    b030:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * Task to receive simulator telemetry data from the ground control station.
		 */
		class SimTelemetryTask : public Task
    b032:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    b036:	08 95       	ret

0000b038 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>:
//}
//


void SimTelemetryTask::runTaskImpl()
{
    b038:	cf 92       	push	r12
    b03a:	df 92       	push	r13
    b03c:	ef 92       	push	r14
    b03e:	ff 92       	push	r15
    b040:	0f 93       	push	r16
    b042:	1f 93       	push	r17
    b044:	cf 93       	push	r28
    b046:	df 93       	push	r29
    b048:	cd b7       	in	r28, 0x3d	; 61
    b04a:	de b7       	in	r29, 0x3e	; 62
    b04c:	28 97       	sbiw	r28, 0x08	; 8
    b04e:	0f b6       	in	r0, 0x3f	; 63
    b050:	f8 94       	cli
    b052:	de bf       	out	0x3e, r29	; 62
    b054:	0f be       	out	0x3f, r0	; 63
    b056:	cd bf       	out	0x3d, r28	; 61
    b058:	8c 01       	movw	r16, r24
	int status = 0;

	//Use the radio interface to get the telemetry message from the simulator
	Message *message = NULL;
    b05a:	18 86       	std	Y+8, r1	; 0x08
    b05c:	1f 82       	std	Y+7, r1	; 0x07
		
	status = radioInterface->receive(message);
    b05e:	be 01       	movw	r22, r28
    b060:	69 5f       	subi	r22, 0xF9	; 249
    b062:	7f 4f       	sbci	r23, 0xFF	; 255
    b064:	dc 01       	movw	r26, r24
    b066:	17 96       	adiw	r26, 0x07	; 7
    b068:	8d 91       	ld	r24, X+
    b06a:	9c 91       	ld	r25, X
    b06c:	18 97       	sbiw	r26, 0x08	; 8
    b06e:	0e 94 76 1b 	call	0x36ec	; 0x36ec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>
    b072:	7c 01       	movw	r14, r24
		
	if (status == 0 && message != NULL)
    b074:	00 97       	sbiw	r24, 0x00	; 0
    b076:	09 f0       	breq	.+2      	; 0xb07a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x42>
    b078:	40 c4       	rjmp	.+2176   	; 0xb8fa <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8c2>
    b07a:	cf 80       	ldd	r12, Y+7	; 0x07
    b07c:	d8 84       	ldd	r13, Y+8	; 0x08
    b07e:	c1 14       	cp	r12, r1
    b080:	d1 04       	cpc	r13, r1
    b082:	09 f4       	brne	.+2      	; 0xb086 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4e>
    b084:	11 c4       	rjmp	.+2082   	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
				/**
				 * Returns the identifier of this message.
				 */
				byte getType()
				{
					return msgType;
    b086:	f6 01       	movw	r30, r12
    b088:	82 81       	ldd	r24, Z+2	; 0x02
	{
		if (message->getType() == SystemTelemetryMessage::MessageType)
    b08a:	82 30       	cpi	r24, 0x02	; 2
    b08c:	09 f0       	breq	.+2      	; 0xb090 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x58>
    b08e:	3f c1       	rjmp	.+638    	; 0xb30e <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2d6>
		{
			SystemTelemetryMessage *telemMsg = (SystemTelemetryMessage*) message;
				
			//Update the model using the new data received from the simulator.
			telemMsg->updateModelFromMessageFromSimulator(model);
    b090:	d8 01       	movw	r26, r16
    b092:	19 96       	adiw	r26, 0x09	; 9
    b094:	6d 91       	ld	r22, X+
    b096:	7c 91       	ld	r23, X
    b098:	1a 97       	sbiw	r26, 0x0a	; 10
    b09a:	c6 01       	movw	r24, r12
    b09c:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    b0a0:	f6 01       	movw	r30, r12
    b0a2:	85 89       	ldd	r24, Z+21	; 0x15
    b0a4:	96 89       	ldd	r25, Z+22	; 0x16
    b0a6:	a7 89       	ldd	r26, Z+23	; 0x17
    b0a8:	b0 8d       	ldd	r27, Z+24	; 0x18
    b0aa:	f8 01       	movw	r30, r16
    b0ac:	23 85       	ldd	r18, Z+11	; 0x0b
    b0ae:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    b0b0:	f9 01       	movw	r30, r18
    b0b2:	82 83       	std	Z+2, r24	; 0x02
    b0b4:	93 83       	std	Z+3, r25	; 0x03
    b0b6:	a4 83       	std	Z+4, r26	; 0x04
    b0b8:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    b0ba:	f6 01       	movw	r30, r12
    b0bc:	81 8d       	ldd	r24, Z+25	; 0x19
    b0be:	92 8d       	ldd	r25, Z+26	; 0x1a
    b0c0:	a3 8d       	ldd	r26, Z+27	; 0x1b
    b0c2:	b4 8d       	ldd	r27, Z+28	; 0x1c
    b0c4:	f8 01       	movw	r30, r16
    b0c6:	23 85       	ldd	r18, Z+11	; 0x0b
    b0c8:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    b0ca:	f9 01       	movw	r30, r18
    b0cc:	86 83       	std	Z+6, r24	; 0x06
    b0ce:	97 83       	std	Z+7, r25	; 0x07
    b0d0:	a0 87       	std	Z+8, r26	; 0x08
    b0d2:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    b0d4:	f6 01       	movw	r30, r12
    b0d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    b0d8:	96 8d       	ldd	r25, Z+30	; 0x1e
    b0da:	a7 8d       	ldd	r26, Z+31	; 0x1f
    b0dc:	b0 a1       	ldd	r27, Z+32	; 0x20
    b0de:	f8 01       	movw	r30, r16
    b0e0:	23 85       	ldd	r18, Z+11	; 0x0b
    b0e2:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    b0e4:	f9 01       	movw	r30, r18
    b0e6:	82 87       	std	Z+10, r24	; 0x0a
    b0e8:	93 87       	std	Z+11, r25	; 0x0b
    b0ea:	a4 87       	std	Z+12, r26	; 0x0c
    b0ec:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    b0ee:	f6 01       	movw	r30, r12
    b0f0:	81 a1       	ldd	r24, Z+33	; 0x21
    b0f2:	92 a1       	ldd	r25, Z+34	; 0x22
    b0f4:	a3 a1       	ldd	r26, Z+35	; 0x23
    b0f6:	b4 a1       	ldd	r27, Z+36	; 0x24
    b0f8:	f8 01       	movw	r30, r16
    b0fa:	23 85       	ldd	r18, Z+11	; 0x0b
    b0fc:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    b0fe:	f9 01       	movw	r30, r18
    b100:	86 87       	std	Z+14, r24	; 0x0e
    b102:	97 87       	std	Z+15, r25	; 0x0f
    b104:	a0 8b       	std	Z+16, r26	; 0x10
    b106:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    b108:	f6 01       	movw	r30, r12
    b10a:	ef 5b       	subi	r30, 0xBF	; 191
    b10c:	ff 4f       	sbci	r31, 0xFF	; 255
    b10e:	80 81       	ld	r24, Z
    b110:	91 81       	ldd	r25, Z+1	; 0x01
    b112:	a2 81       	ldd	r26, Z+2	; 0x02
    b114:	b3 81       	ldd	r27, Z+3	; 0x03
    b116:	f8 01       	movw	r30, r16
    b118:	23 85       	ldd	r18, Z+11	; 0x0b
    b11a:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    b11c:	f9 01       	movw	r30, r18
    b11e:	82 8b       	std	Z+18, r24	; 0x12
    b120:	93 8b       	std	Z+19, r25	; 0x13
    b122:	a4 8b       	std	Z+20, r26	; 0x14
    b124:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    b126:	f6 01       	movw	r30, r12
    b128:	eb 5b       	subi	r30, 0xBB	; 187
    b12a:	ff 4f       	sbci	r31, 0xFF	; 255
    b12c:	80 81       	ld	r24, Z
    b12e:	91 81       	ldd	r25, Z+1	; 0x01
    b130:	a2 81       	ldd	r26, Z+2	; 0x02
    b132:	b3 81       	ldd	r27, Z+3	; 0x03
    b134:	f8 01       	movw	r30, r16
    b136:	23 85       	ldd	r18, Z+11	; 0x0b
    b138:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    b13a:	f9 01       	movw	r30, r18
    b13c:	86 8b       	std	Z+22, r24	; 0x16
    b13e:	97 8b       	std	Z+23, r25	; 0x17
    b140:	a0 8f       	std	Z+24, r26	; 0x18
    b142:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    b144:	f6 01       	movw	r30, r12
    b146:	e7 5b       	subi	r30, 0xB7	; 183
    b148:	ff 4f       	sbci	r31, 0xFF	; 255
    b14a:	80 81       	ld	r24, Z
    b14c:	91 81       	ldd	r25, Z+1	; 0x01
    b14e:	a2 81       	ldd	r26, Z+2	; 0x02
    b150:	b3 81       	ldd	r27, Z+3	; 0x03
    b152:	f8 01       	movw	r30, r16
    b154:	23 85       	ldd	r18, Z+11	; 0x0b
    b156:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    b158:	f9 01       	movw	r30, r18
    b15a:	82 8f       	std	Z+26, r24	; 0x1a
    b15c:	93 8f       	std	Z+27, r25	; 0x1b
    b15e:	a4 8f       	std	Z+28, r26	; 0x1c
    b160:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    b162:	f6 01       	movw	r30, r12
    b164:	e3 5b       	subi	r30, 0xB3	; 179
    b166:	ff 4f       	sbci	r31, 0xFF	; 255
    b168:	80 81       	ld	r24, Z
    b16a:	91 81       	ldd	r25, Z+1	; 0x01
    b16c:	a2 81       	ldd	r26, Z+2	; 0x02
    b16e:	b3 81       	ldd	r27, Z+3	; 0x03
    b170:	f8 01       	movw	r30, r16
    b172:	23 85       	ldd	r18, Z+11	; 0x0b
    b174:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    b176:	f9 01       	movw	r30, r18
    b178:	86 8f       	std	Z+30, r24	; 0x1e
    b17a:	97 8f       	std	Z+31, r25	; 0x1f
    b17c:	a0 a3       	std	Z+32, r26	; 0x20
    b17e:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    b180:	f6 01       	movw	r30, r12
    b182:	ef 5a       	subi	r30, 0xAF	; 175
    b184:	ff 4f       	sbci	r31, 0xFF	; 255
    b186:	80 81       	ld	r24, Z
    b188:	91 81       	ldd	r25, Z+1	; 0x01
    b18a:	a2 81       	ldd	r26, Z+2	; 0x02
    b18c:	b3 81       	ldd	r27, Z+3	; 0x03
    b18e:	f8 01       	movw	r30, r16
    b190:	23 85       	ldd	r18, Z+11	; 0x0b
    b192:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    b194:	f9 01       	movw	r30, r18
    b196:	82 a3       	std	Z+34, r24	; 0x22
    b198:	93 a3       	std	Z+35, r25	; 0x23
    b19a:	a4 a3       	std	Z+36, r26	; 0x24
    b19c:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    b19e:	f6 01       	movw	r30, r12
    b1a0:	e7 5a       	subi	r30, 0xA7	; 167
    b1a2:	ff 4f       	sbci	r31, 0xFF	; 255
    b1a4:	80 81       	ld	r24, Z
    b1a6:	91 81       	ldd	r25, Z+1	; 0x01
    b1a8:	a2 81       	ldd	r26, Z+2	; 0x02
    b1aa:	b3 81       	ldd	r27, Z+3	; 0x03
    b1ac:	f8 01       	movw	r30, r16
    b1ae:	23 85       	ldd	r18, Z+11	; 0x0b
    b1b0:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    b1b2:	f9 01       	movw	r30, r18
    b1b4:	86 a3       	std	Z+38, r24	; 0x26
    b1b6:	97 a3       	std	Z+39, r25	; 0x27
    b1b8:	a0 a7       	std	Z+40, r26	; 0x28
    b1ba:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    b1bc:	f6 01       	movw	r30, r12
    b1be:	e7 58       	subi	r30, 0x87	; 135
    b1c0:	ff 4f       	sbci	r31, 0xFF	; 255
    b1c2:	80 81       	ld	r24, Z
    b1c4:	91 81       	ldd	r25, Z+1	; 0x01
    b1c6:	a2 81       	ldd	r26, Z+2	; 0x02
    b1c8:	b3 81       	ldd	r27, Z+3	; 0x03
    b1ca:	f8 01       	movw	r30, r16
    b1cc:	23 85       	ldd	r18, Z+11	; 0x0b
    b1ce:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    b1d0:	f9 01       	movw	r30, r18
    b1d2:	82 a7       	std	Z+42, r24	; 0x2a
    b1d4:	93 a7       	std	Z+43, r25	; 0x2b
    b1d6:	a4 a7       	std	Z+44, r26	; 0x2c
    b1d8:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    b1da:	f6 01       	movw	r30, r12
    b1dc:	e3 58       	subi	r30, 0x83	; 131
    b1de:	ff 4f       	sbci	r31, 0xFF	; 255
    b1e0:	80 81       	ld	r24, Z
    b1e2:	91 81       	ldd	r25, Z+1	; 0x01
    b1e4:	a2 81       	ldd	r26, Z+2	; 0x02
    b1e6:	b3 81       	ldd	r27, Z+3	; 0x03
    b1e8:	f8 01       	movw	r30, r16
    b1ea:	23 85       	ldd	r18, Z+11	; 0x0b
    b1ec:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    b1ee:	f9 01       	movw	r30, r18
    b1f0:	86 a7       	std	Z+46, r24	; 0x2e
    b1f2:	97 a7       	std	Z+47, r25	; 0x2f
    b1f4:	a0 ab       	std	Z+48, r26	; 0x30
    b1f6:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    b1f8:	f6 01       	movw	r30, r12
    b1fa:	ef 57       	subi	r30, 0x7F	; 127
    b1fc:	ff 4f       	sbci	r31, 0xFF	; 255
    b1fe:	80 81       	ld	r24, Z
    b200:	91 81       	ldd	r25, Z+1	; 0x01
    b202:	a2 81       	ldd	r26, Z+2	; 0x02
    b204:	b3 81       	ldd	r27, Z+3	; 0x03
    b206:	f8 01       	movw	r30, r16
    b208:	23 85       	ldd	r18, Z+11	; 0x0b
    b20a:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    b20c:	f9 01       	movw	r30, r18
    b20e:	82 ab       	std	Z+50, r24	; 0x32
    b210:	93 ab       	std	Z+51, r25	; 0x33
    b212:	a4 ab       	std	Z+52, r26	; 0x34
    b214:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    b216:	f6 01       	movw	r30, r12
    b218:	eb 57       	subi	r30, 0x7B	; 123
    b21a:	ff 4f       	sbci	r31, 0xFF	; 255
    b21c:	80 81       	ld	r24, Z
    b21e:	91 81       	ldd	r25, Z+1	; 0x01
    b220:	a2 81       	ldd	r26, Z+2	; 0x02
    b222:	b3 81       	ldd	r27, Z+3	; 0x03
    b224:	f8 01       	movw	r30, r16
    b226:	23 85       	ldd	r18, Z+11	; 0x0b
    b228:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    b22a:	f9 01       	movw	r30, r18
    b22c:	86 ab       	std	Z+54, r24	; 0x36
    b22e:	97 ab       	std	Z+55, r25	; 0x37
    b230:	a0 af       	std	Z+56, r26	; 0x38
    b232:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    b234:	f6 01       	movw	r30, r12
    b236:	e7 57       	subi	r30, 0x77	; 119
    b238:	ff 4f       	sbci	r31, 0xFF	; 255
    b23a:	80 81       	ld	r24, Z
    b23c:	91 81       	ldd	r25, Z+1	; 0x01
    b23e:	a2 81       	ldd	r26, Z+2	; 0x02
    b240:	b3 81       	ldd	r27, Z+3	; 0x03
    b242:	f8 01       	movw	r30, r16
    b244:	23 85       	ldd	r18, Z+11	; 0x0b
    b246:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    b248:	f9 01       	movw	r30, r18
    b24a:	82 af       	std	Z+58, r24	; 0x3a
    b24c:	93 af       	std	Z+59, r25	; 0x3b
    b24e:	a4 af       	std	Z+60, r26	; 0x3c
    b250:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    b252:	f6 01       	movw	r30, r12
    b254:	ef 56       	subi	r30, 0x6F	; 111
    b256:	ff 4f       	sbci	r31, 0xFF	; 255
    b258:	80 81       	ld	r24, Z
    b25a:	91 81       	ldd	r25, Z+1	; 0x01
    b25c:	a2 81       	ldd	r26, Z+2	; 0x02
    b25e:	b3 81       	ldd	r27, Z+3	; 0x03
    b260:	f8 01       	movw	r30, r16
    b262:	23 85       	ldd	r18, Z+11	; 0x0b
    b264:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    b266:	f9 01       	movw	r30, r18
    b268:	fe 96       	adiw	r30, 0x3e	; 62
    b26a:	80 83       	st	Z, r24
    b26c:	91 83       	std	Z+1, r25	; 0x01
    b26e:	a2 83       	std	Z+2, r26	; 0x02
    b270:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    b272:	f6 01       	movw	r30, r12
    b274:	ef 54       	subi	r30, 0x4F	; 79
    b276:	ff 4f       	sbci	r31, 0xFF	; 255
    b278:	80 81       	ld	r24, Z
    b27a:	91 81       	ldd	r25, Z+1	; 0x01
    b27c:	a2 81       	ldd	r26, Z+2	; 0x02
    b27e:	b3 81       	ldd	r27, Z+3	; 0x03
    b280:	f8 01       	movw	r30, r16
    b282:	23 85       	ldd	r18, Z+11	; 0x0b
    b284:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    b286:	f9 01       	movw	r30, r18
    b288:	ee 5b       	subi	r30, 0xBE	; 190
    b28a:	ff 4f       	sbci	r31, 0xFF	; 255
    b28c:	80 83       	st	Z, r24
    b28e:	91 83       	std	Z+1, r25	; 0x01
    b290:	a2 83       	std	Z+2, r26	; 0x02
    b292:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    b294:	f6 01       	movw	r30, r12
    b296:	eb 54       	subi	r30, 0x4B	; 75
    b298:	ff 4f       	sbci	r31, 0xFF	; 255
    b29a:	80 81       	ld	r24, Z
    b29c:	91 81       	ldd	r25, Z+1	; 0x01
    b29e:	a2 81       	ldd	r26, Z+2	; 0x02
    b2a0:	b3 81       	ldd	r27, Z+3	; 0x03
    b2a2:	f8 01       	movw	r30, r16
    b2a4:	23 85       	ldd	r18, Z+11	; 0x0b
    b2a6:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    b2a8:	f9 01       	movw	r30, r18
    b2aa:	ea 5b       	subi	r30, 0xBA	; 186
    b2ac:	ff 4f       	sbci	r31, 0xFF	; 255
    b2ae:	80 83       	st	Z, r24
    b2b0:	91 83       	std	Z+1, r25	; 0x01
    b2b2:	a2 83       	std	Z+2, r26	; 0x02
    b2b4:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    b2b6:	f6 01       	movw	r30, r12
    b2b8:	e7 54       	subi	r30, 0x47	; 71
    b2ba:	ff 4f       	sbci	r31, 0xFF	; 255
    b2bc:	80 81       	ld	r24, Z
    b2be:	91 81       	ldd	r25, Z+1	; 0x01
    b2c0:	a2 81       	ldd	r26, Z+2	; 0x02
    b2c2:	b3 81       	ldd	r27, Z+3	; 0x03
    b2c4:	f8 01       	movw	r30, r16
    b2c6:	23 85       	ldd	r18, Z+11	; 0x0b
    b2c8:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    b2ca:	f9 01       	movw	r30, r18
    b2cc:	e6 5b       	subi	r30, 0xB6	; 182
    b2ce:	ff 4f       	sbci	r31, 0xFF	; 255
    b2d0:	80 83       	st	Z, r24
    b2d2:	91 83       	std	Z+1, r25	; 0x01
    b2d4:	a2 83       	std	Z+2, r26	; 0x02
    b2d6:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    b2d8:	f6 01       	movw	r30, r12
    b2da:	e3 54       	subi	r30, 0x43	; 67
    b2dc:	ff 4f       	sbci	r31, 0xFF	; 255
    b2de:	80 81       	ld	r24, Z
    b2e0:	91 81       	ldd	r25, Z+1	; 0x01
    b2e2:	a2 81       	ldd	r26, Z+2	; 0x02
    b2e4:	b3 81       	ldd	r27, Z+3	; 0x03
    b2e6:	f8 01       	movw	r30, r16
    b2e8:	23 85       	ldd	r18, Z+11	; 0x0b
    b2ea:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    b2ec:	f9 01       	movw	r30, r18
    b2ee:	e2 5b       	subi	r30, 0xB2	; 178
    b2f0:	ff 4f       	sbci	r31, 0xFF	; 255
    b2f2:	80 83       	st	Z, r24
    b2f4:	91 83       	std	Z+1, r25	; 0x01
    b2f6:	a2 83       	std	Z+2, r26	; 0x02
    b2f8:	b3 83       	std	Z+3, r27	; 0x03
			
			model->HasNewPressureReading = true;
    b2fa:	d8 01       	movw	r26, r16
    b2fc:	19 96       	adiw	r26, 0x09	; 9
    b2fe:	ed 91       	ld	r30, X+
    b300:	fc 91       	ld	r31, X
    b302:	1a 97       	sbiw	r26, 0x0a	; 10
    b304:	ee 5b       	subi	r30, 0xBE	; 190
    b306:	fe 4f       	sbci	r31, 0xFE	; 254
    b308:	81 e0       	ldi	r24, 0x01	; 1
    b30a:	80 83       	st	Z, r24
    b30c:	5b c2       	rjmp	.+1206   	; 0xb7c4 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
		}else if (message->getType() == SensorDataMessage::MessageType)
    b30e:	84 30       	cpi	r24, 0x04	; 4
    b310:	09 f0       	breq	.+2      	; 0xb314 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2dc>
    b312:	fd c0       	rjmp	.+506    	; 0xb50e <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4d6>
		{
			SensorDataMessage *sensorMsg = (SensorDataMessage*) message;
			model->XAccelFrdMss(sensorMsg->XAccelFrdMss);
    b314:	f6 01       	movw	r30, r12
    b316:	85 81       	ldd	r24, Z+5	; 0x05
    b318:	96 81       	ldd	r25, Z+6	; 0x06
    b31a:	a7 81       	ldd	r26, Z+7	; 0x07
    b31c:	b0 85       	ldd	r27, Z+8	; 0x08
    b31e:	f8 01       	movw	r30, r16
    b320:	21 85       	ldd	r18, Z+9	; 0x09
    b322:	32 85       	ldd	r19, Z+10	; 0x0a
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    b324:	f9 01       	movw	r30, r18
    b326:	ea 51       	subi	r30, 0x1A	; 26
    b328:	ff 4f       	sbci	r31, 0xFF	; 255
    b32a:	80 83       	st	Z, r24
    b32c:	91 83       	std	Z+1, r25	; 0x01
    b32e:	a2 83       	std	Z+2, r26	; 0x02
    b330:	b3 83       	std	Z+3, r27	; 0x03
			model->YAccelFrdMss(sensorMsg->YAccelFrdMss);
    b332:	f6 01       	movw	r30, r12
    b334:	81 85       	ldd	r24, Z+9	; 0x09
    b336:	92 85       	ldd	r25, Z+10	; 0x0a
    b338:	a3 85       	ldd	r26, Z+11	; 0x0b
    b33a:	b4 85       	ldd	r27, Z+12	; 0x0c
    b33c:	f8 01       	movw	r30, r16
    b33e:	21 85       	ldd	r18, Z+9	; 0x09
    b340:	32 85       	ldd	r19, Z+10	; 0x0a

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    b342:	f9 01       	movw	r30, r18
    b344:	e6 51       	subi	r30, 0x16	; 22
    b346:	ff 4f       	sbci	r31, 0xFF	; 255
    b348:	80 83       	st	Z, r24
    b34a:	91 83       	std	Z+1, r25	; 0x01
    b34c:	a2 83       	std	Z+2, r26	; 0x02
    b34e:	b3 83       	std	Z+3, r27	; 0x03
			model->ZAccelFrdMss(sensorMsg->ZAccelFrdMss);
    b350:	f6 01       	movw	r30, r12
    b352:	85 85       	ldd	r24, Z+13	; 0x0d
    b354:	96 85       	ldd	r25, Z+14	; 0x0e
    b356:	a7 85       	ldd	r26, Z+15	; 0x0f
    b358:	b0 89       	ldd	r27, Z+16	; 0x10
    b35a:	f8 01       	movw	r30, r16
    b35c:	21 85       	ldd	r18, Z+9	; 0x09
    b35e:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    b360:	f9 01       	movw	r30, r18
    b362:	e2 51       	subi	r30, 0x12	; 18
    b364:	ff 4f       	sbci	r31, 0xFF	; 255
    b366:	80 83       	st	Z, r24
    b368:	91 83       	std	Z+1, r25	; 0x01
    b36a:	a2 83       	std	Z+2, r26	; 0x02
    b36c:	b3 83       	std	Z+3, r27	; 0x03
			model->YawAngularVelocityRadsPerSecond(sensorMsg->YawAngularVelocityRadsPerSecond);
    b36e:	f6 01       	movw	r30, r12
    b370:	81 89       	ldd	r24, Z+17	; 0x11
    b372:	92 89       	ldd	r25, Z+18	; 0x12
    b374:	a3 89       	ldd	r26, Z+19	; 0x13
    b376:	b4 89       	ldd	r27, Z+20	; 0x14
    b378:	f8 01       	movw	r30, r16
    b37a:	21 85       	ldd	r18, Z+9	; 0x09
    b37c:	32 85       	ldd	r19, Z+10	; 0x0a
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    b37e:	f9 01       	movw	r30, r18
    b380:	ee 51       	subi	r30, 0x1E	; 30
    b382:	ff 4f       	sbci	r31, 0xFF	; 255
    b384:	80 83       	st	Z, r24
    b386:	91 83       	std	Z+1, r25	; 0x01
    b388:	a2 83       	std	Z+2, r26	; 0x02
    b38a:	b3 83       	std	Z+3, r27	; 0x03
			model->PitchAngularVelocityRadsPerSecond(sensorMsg->PitchAngularVelocityRadsPerSecond);
    b38c:	f6 01       	movw	r30, r12
    b38e:	85 89       	ldd	r24, Z+21	; 0x15
    b390:	96 89       	ldd	r25, Z+22	; 0x16
    b392:	a7 89       	ldd	r26, Z+23	; 0x17
    b394:	b0 8d       	ldd	r27, Z+24	; 0x18
    b396:	f8 01       	movw	r30, r16
    b398:	21 85       	ldd	r18, Z+9	; 0x09
    b39a:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    b39c:	f9 01       	movw	r30, r18
    b39e:	e6 52       	subi	r30, 0x26	; 38
    b3a0:	ff 4f       	sbci	r31, 0xFF	; 255
    b3a2:	80 83       	st	Z, r24
    b3a4:	91 83       	std	Z+1, r25	; 0x01
    b3a6:	a2 83       	std	Z+2, r26	; 0x02
    b3a8:	b3 83       	std	Z+3, r27	; 0x03
			model->RollAngularVelocityRadsPerSecond(sensorMsg->RollAngularVelocityRadsPerSecond);
    b3aa:	f6 01       	movw	r30, r12
    b3ac:	81 8d       	ldd	r24, Z+25	; 0x19
    b3ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    b3b0:	a3 8d       	ldd	r26, Z+27	; 0x1b
    b3b2:	b4 8d       	ldd	r27, Z+28	; 0x1c
    b3b4:	f8 01       	movw	r30, r16
    b3b6:	21 85       	ldd	r18, Z+9	; 0x09
    b3b8:	32 85       	ldd	r19, Z+10	; 0x0a

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    b3ba:	f9 01       	movw	r30, r18
    b3bc:	e2 52       	subi	r30, 0x22	; 34
    b3be:	ff 4f       	sbci	r31, 0xFF	; 255
    b3c0:	80 83       	st	Z, r24
    b3c2:	91 83       	std	Z+1, r25	; 0x01
    b3c4:	a2 83       	std	Z+2, r26	; 0x02
    b3c6:	b3 83       	std	Z+3, r27	; 0x03
			model->XMagFrd(sensorMsg->XMagFrd);
    b3c8:	f6 01       	movw	r30, r12
    b3ca:	85 8d       	ldd	r24, Z+29	; 0x1d
    b3cc:	96 8d       	ldd	r25, Z+30	; 0x1e
    b3ce:	a7 8d       	ldd	r26, Z+31	; 0x1f
    b3d0:	b0 a1       	ldd	r27, Z+32	; 0x20
    b3d2:	f8 01       	movw	r30, r16
    b3d4:	21 85       	ldd	r18, Z+9	; 0x09
    b3d6:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    b3d8:	f9 01       	movw	r30, r18
    b3da:	ee 50       	subi	r30, 0x0E	; 14
    b3dc:	ff 4f       	sbci	r31, 0xFF	; 255
    b3de:	80 83       	st	Z, r24
    b3e0:	91 83       	std	Z+1, r25	; 0x01
    b3e2:	a2 83       	std	Z+2, r26	; 0x02
    b3e4:	b3 83       	std	Z+3, r27	; 0x03
			model->YMagFrd(sensorMsg->YMagFrd);
    b3e6:	f6 01       	movw	r30, r12
    b3e8:	81 a1       	ldd	r24, Z+33	; 0x21
    b3ea:	92 a1       	ldd	r25, Z+34	; 0x22
    b3ec:	a3 a1       	ldd	r26, Z+35	; 0x23
    b3ee:	b4 a1       	ldd	r27, Z+36	; 0x24
    b3f0:	f8 01       	movw	r30, r16
    b3f2:	21 85       	ldd	r18, Z+9	; 0x09
    b3f4:	32 85       	ldd	r19, Z+10	; 0x0a

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    b3f6:	f9 01       	movw	r30, r18
    b3f8:	ea 50       	subi	r30, 0x0A	; 10
    b3fa:	ff 4f       	sbci	r31, 0xFF	; 255
    b3fc:	80 83       	st	Z, r24
    b3fe:	91 83       	std	Z+1, r25	; 0x01
    b400:	a2 83       	std	Z+2, r26	; 0x02
    b402:	b3 83       	std	Z+3, r27	; 0x03
			model->ZMagFrd(sensorMsg->ZMagFrd);
    b404:	f6 01       	movw	r30, r12
    b406:	85 a1       	ldd	r24, Z+37	; 0x25
    b408:	96 a1       	ldd	r25, Z+38	; 0x26
    b40a:	a7 a1       	ldd	r26, Z+39	; 0x27
    b40c:	b0 a5       	ldd	r27, Z+40	; 0x28
    b40e:	f8 01       	movw	r30, r16
    b410:	21 85       	ldd	r18, Z+9	; 0x09
    b412:	32 85       	ldd	r19, Z+10	; 0x0a

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    b414:	f9 01       	movw	r30, r18
    b416:	e6 50       	subi	r30, 0x06	; 6
    b418:	ff 4f       	sbci	r31, 0xFF	; 255
    b41a:	80 83       	st	Z, r24
    b41c:	91 83       	std	Z+1, r25	; 0x01
    b41e:	a2 83       	std	Z+2, r26	; 0x02
    b420:	b3 83       	std	Z+3, r27	; 0x03
			model->XEcefCm(sensorMsg->XEcefCm);
    b422:	f6 01       	movw	r30, r12
    b424:	81 a5       	ldd	r24, Z+41	; 0x29
    b426:	92 a5       	ldd	r25, Z+42	; 0x2a
    b428:	a3 a5       	ldd	r26, Z+43	; 0x2b
    b42a:	b4 a5       	ldd	r27, Z+44	; 0x2c
    b42c:	f8 01       	movw	r30, r16
    b42e:	21 85       	ldd	r18, Z+9	; 0x09
    b430:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    b432:	f9 01       	movw	r30, r18
    b434:	e2 50       	subi	r30, 0x02	; 2
    b436:	ff 4f       	sbci	r31, 0xFF	; 255
    b438:	80 83       	st	Z, r24
    b43a:	91 83       	std	Z+1, r25	; 0x01
    b43c:	a2 83       	std	Z+2, r26	; 0x02
    b43e:	b3 83       	std	Z+3, r27	; 0x03
			model->YEcefCm(sensorMsg->YEcefCm);
    b440:	f6 01       	movw	r30, r12
    b442:	85 a5       	ldd	r24, Z+45	; 0x2d
    b444:	96 a5       	ldd	r25, Z+46	; 0x2e
    b446:	a7 a5       	ldd	r26, Z+47	; 0x2f
    b448:	b0 a9       	ldd	r27, Z+48	; 0x30
    b44a:	f8 01       	movw	r30, r16
    b44c:	21 85       	ldd	r18, Z+9	; 0x09
    b44e:	32 85       	ldd	r19, Z+10	; 0x0a
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    b450:	f9 01       	movw	r30, r18
    b452:	ee 5f       	subi	r30, 0xFE	; 254
    b454:	fe 4f       	sbci	r31, 0xFE	; 254
    b456:	80 83       	st	Z, r24
    b458:	91 83       	std	Z+1, r25	; 0x01
    b45a:	a2 83       	std	Z+2, r26	; 0x02
    b45c:	b3 83       	std	Z+3, r27	; 0x03
			model->ZEcefCm(sensorMsg->ZEcefCm);
    b45e:	f6 01       	movw	r30, r12
    b460:	81 a9       	ldd	r24, Z+49	; 0x31
    b462:	92 a9       	ldd	r25, Z+50	; 0x32
    b464:	a3 a9       	ldd	r26, Z+51	; 0x33
    b466:	b4 a9       	ldd	r27, Z+52	; 0x34
    b468:	f8 01       	movw	r30, r16
    b46a:	21 85       	ldd	r18, Z+9	; 0x09
    b46c:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    b46e:	f9 01       	movw	r30, r18
    b470:	ea 5f       	subi	r30, 0xFA	; 250
    b472:	fe 4f       	sbci	r31, 0xFE	; 254
    b474:	80 83       	st	Z, r24
    b476:	91 83       	std	Z+1, r25	; 0x01
    b478:	a2 83       	std	Z+2, r26	; 0x02
    b47a:	b3 83       	std	Z+3, r27	; 0x03
			model->XVEcefCms(sensorMsg->XVEcefCms);
    b47c:	f6 01       	movw	r30, r12
    b47e:	85 a9       	ldd	r24, Z+53	; 0x35
    b480:	96 a9       	ldd	r25, Z+54	; 0x36
    b482:	a7 a9       	ldd	r26, Z+55	; 0x37
    b484:	b0 ad       	ldd	r27, Z+56	; 0x38
    b486:	f8 01       	movw	r30, r16
    b488:	21 85       	ldd	r18, Z+9	; 0x09
    b48a:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    b48c:	f9 01       	movw	r30, r18
    b48e:	e6 5f       	subi	r30, 0xF6	; 246
    b490:	fe 4f       	sbci	r31, 0xFE	; 254
    b492:	80 83       	st	Z, r24
    b494:	91 83       	std	Z+1, r25	; 0x01
    b496:	a2 83       	std	Z+2, r26	; 0x02
    b498:	b3 83       	std	Z+3, r27	; 0x03
			model->YVEcefCms(sensorMsg->YVEcefCms);
    b49a:	f6 01       	movw	r30, r12
    b49c:	81 ad       	ldd	r24, Z+57	; 0x39
    b49e:	92 ad       	ldd	r25, Z+58	; 0x3a
    b4a0:	a3 ad       	ldd	r26, Z+59	; 0x3b
    b4a2:	b4 ad       	ldd	r27, Z+60	; 0x3c
    b4a4:	f8 01       	movw	r30, r16
    b4a6:	21 85       	ldd	r18, Z+9	; 0x09
    b4a8:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    b4aa:	f9 01       	movw	r30, r18
    b4ac:	e2 5f       	subi	r30, 0xF2	; 242
    b4ae:	fe 4f       	sbci	r31, 0xFE	; 254
    b4b0:	80 83       	st	Z, r24
    b4b2:	91 83       	std	Z+1, r25	; 0x01
    b4b4:	a2 83       	std	Z+2, r26	; 0x02
    b4b6:	b3 83       	std	Z+3, r27	; 0x03
			model->ZVEcefCms(sensorMsg->ZVEcefCms);
    b4b8:	f6 01       	movw	r30, r12
    b4ba:	fd 96       	adiw	r30, 0x3d	; 61
    b4bc:	40 81       	ld	r20, Z
    b4be:	51 81       	ldd	r21, Z+1	; 0x01
    b4c0:	62 81       	ldd	r22, Z+2	; 0x02
    b4c2:	73 81       	ldd	r23, Z+3	; 0x03
    b4c4:	d8 01       	movw	r26, r16
    b4c6:	19 96       	adiw	r26, 0x09	; 9
    b4c8:	ed 91       	ld	r30, X+
    b4ca:	fc 91       	ld	r31, X
    b4cc:	1a 97       	sbiw	r26, 0x0a	; 10
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    b4ce:	ee 5e       	subi	r30, 0xEE	; 238
    b4d0:	fe 4f       	sbci	r31, 0xFE	; 254
    b4d2:	40 83       	st	Z, r20
    b4d4:	51 83       	std	Z+1, r21	; 0x01
    b4d6:	62 83       	std	Z+2, r22	; 0x02
    b4d8:	73 83       	std	Z+3, r23	; 0x03
			model->PressureMillibars(sensorMsg->PressureMillibars);
    b4da:	f6 01       	movw	r30, r12
    b4dc:	ef 5b       	subi	r30, 0xBF	; 191
    b4de:	ff 4f       	sbci	r31, 0xFF	; 255
    b4e0:	40 81       	ld	r20, Z
    b4e2:	51 81       	ldd	r21, Z+1	; 0x01
    b4e4:	62 81       	ldd	r22, Z+2	; 0x02
    b4e6:	73 81       	ldd	r23, Z+3	; 0x03
    b4e8:	19 96       	adiw	r26, 0x09	; 9
    b4ea:	ed 91       	ld	r30, X+
    b4ec:	fc 91       	ld	r31, X
    b4ee:	1a 97       	sbiw	r26, 0x0a	; 10
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    b4f0:	ea 5e       	subi	r30, 0xEA	; 234
    b4f2:	fe 4f       	sbci	r31, 0xFE	; 254
    b4f4:	40 83       	st	Z, r20
    b4f6:	51 83       	std	Z+1, r21	; 0x01
    b4f8:	62 83       	std	Z+2, r22	; 0x02
    b4fa:	73 83       	std	Z+3, r23	; 0x03
			
			model->HasNewPressureReading = true;
    b4fc:	19 96       	adiw	r26, 0x09	; 9
    b4fe:	ed 91       	ld	r30, X+
    b500:	fc 91       	ld	r31, X
    b502:	1a 97       	sbiw	r26, 0x0a	; 10
    b504:	ee 5b       	subi	r30, 0xBE	; 190
    b506:	fe 4f       	sbci	r31, 0xFE	; 254
    b508:	81 e0       	ldi	r24, 0x01	; 1
    b50a:	80 83       	st	Z, r24
    b50c:	5b c1       	rjmp	.+694    	; 0xb7c4 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
				
		}else if (message->getType() == GainsMessage::MessageType)
    b50e:	87 30       	cpi	r24, 0x07	; 7
    b510:	09 f0       	breq	.+2      	; 0xb514 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4dc>
    b512:	5e c1       	rjmp	.+700    	; 0xb7d0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
		{
			GainsMessage *telemMsg = (GainsMessage*) message;
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    b514:	f6 01       	movw	r30, r12
    b516:	85 81       	ldd	r24, Z+5	; 0x05
    b518:	96 81       	ldd	r25, Z+6	; 0x06
    b51a:	a7 81       	ldd	r26, Z+7	; 0x07
    b51c:	b0 85       	ldd	r27, Z+8	; 0x08
    b51e:	f8 01       	movw	r30, r16
    b520:	23 85       	ldd	r18, Z+11	; 0x0b
    b522:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    b524:	f9 01       	movw	r30, r18
    b526:	82 83       	std	Z+2, r24	; 0x02
    b528:	93 83       	std	Z+3, r25	; 0x03
    b52a:	a4 83       	std	Z+4, r26	; 0x04
    b52c:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    b52e:	f6 01       	movw	r30, r12
    b530:	81 85       	ldd	r24, Z+9	; 0x09
    b532:	92 85       	ldd	r25, Z+10	; 0x0a
    b534:	a3 85       	ldd	r26, Z+11	; 0x0b
    b536:	b4 85       	ldd	r27, Z+12	; 0x0c
    b538:	f8 01       	movw	r30, r16
    b53a:	23 85       	ldd	r18, Z+11	; 0x0b
    b53c:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    b53e:	f9 01       	movw	r30, r18
    b540:	86 83       	std	Z+6, r24	; 0x06
    b542:	97 83       	std	Z+7, r25	; 0x07
    b544:	a0 87       	std	Z+8, r26	; 0x08
    b546:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    b548:	f6 01       	movw	r30, r12
    b54a:	85 85       	ldd	r24, Z+13	; 0x0d
    b54c:	96 85       	ldd	r25, Z+14	; 0x0e
    b54e:	a7 85       	ldd	r26, Z+15	; 0x0f
    b550:	b0 89       	ldd	r27, Z+16	; 0x10
    b552:	f8 01       	movw	r30, r16
    b554:	23 85       	ldd	r18, Z+11	; 0x0b
    b556:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    b558:	f9 01       	movw	r30, r18
    b55a:	82 87       	std	Z+10, r24	; 0x0a
    b55c:	93 87       	std	Z+11, r25	; 0x0b
    b55e:	a4 87       	std	Z+12, r26	; 0x0c
    b560:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    b562:	f6 01       	movw	r30, r12
    b564:	81 89       	ldd	r24, Z+17	; 0x11
    b566:	92 89       	ldd	r25, Z+18	; 0x12
    b568:	a3 89       	ldd	r26, Z+19	; 0x13
    b56a:	b4 89       	ldd	r27, Z+20	; 0x14
    b56c:	f8 01       	movw	r30, r16
    b56e:	23 85       	ldd	r18, Z+11	; 0x0b
    b570:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    b572:	f9 01       	movw	r30, r18
    b574:	86 87       	std	Z+14, r24	; 0x0e
    b576:	97 87       	std	Z+15, r25	; 0x0f
    b578:	a0 8b       	std	Z+16, r26	; 0x10
    b57a:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    b57c:	f6 01       	movw	r30, r12
    b57e:	85 89       	ldd	r24, Z+21	; 0x15
    b580:	96 89       	ldd	r25, Z+22	; 0x16
    b582:	a7 89       	ldd	r26, Z+23	; 0x17
    b584:	b0 8d       	ldd	r27, Z+24	; 0x18
    b586:	f8 01       	movw	r30, r16
    b588:	23 85       	ldd	r18, Z+11	; 0x0b
    b58a:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    b58c:	f9 01       	movw	r30, r18
    b58e:	82 8b       	std	Z+18, r24	; 0x12
    b590:	93 8b       	std	Z+19, r25	; 0x13
    b592:	a4 8b       	std	Z+20, r26	; 0x14
    b594:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    b596:	f6 01       	movw	r30, r12
    b598:	81 8d       	ldd	r24, Z+25	; 0x19
    b59a:	92 8d       	ldd	r25, Z+26	; 0x1a
    b59c:	a3 8d       	ldd	r26, Z+27	; 0x1b
    b59e:	b4 8d       	ldd	r27, Z+28	; 0x1c
    b5a0:	f8 01       	movw	r30, r16
    b5a2:	23 85       	ldd	r18, Z+11	; 0x0b
    b5a4:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    b5a6:	f9 01       	movw	r30, r18
    b5a8:	86 8b       	std	Z+22, r24	; 0x16
    b5aa:	97 8b       	std	Z+23, r25	; 0x17
    b5ac:	a0 8f       	std	Z+24, r26	; 0x18
    b5ae:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    b5b0:	f6 01       	movw	r30, r12
    b5b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    b5b4:	96 8d       	ldd	r25, Z+30	; 0x1e
    b5b6:	a7 8d       	ldd	r26, Z+31	; 0x1f
    b5b8:	b0 a1       	ldd	r27, Z+32	; 0x20
    b5ba:	f8 01       	movw	r30, r16
    b5bc:	23 85       	ldd	r18, Z+11	; 0x0b
    b5be:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    b5c0:	f9 01       	movw	r30, r18
    b5c2:	82 8f       	std	Z+26, r24	; 0x1a
    b5c4:	93 8f       	std	Z+27, r25	; 0x1b
    b5c6:	a4 8f       	std	Z+28, r26	; 0x1c
    b5c8:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    b5ca:	f6 01       	movw	r30, r12
    b5cc:	81 a1       	ldd	r24, Z+33	; 0x21
    b5ce:	92 a1       	ldd	r25, Z+34	; 0x22
    b5d0:	a3 a1       	ldd	r26, Z+35	; 0x23
    b5d2:	b4 a1       	ldd	r27, Z+36	; 0x24
    b5d4:	f8 01       	movw	r30, r16
    b5d6:	23 85       	ldd	r18, Z+11	; 0x0b
    b5d8:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    b5da:	f9 01       	movw	r30, r18
    b5dc:	86 8f       	std	Z+30, r24	; 0x1e
    b5de:	97 8f       	std	Z+31, r25	; 0x1f
    b5e0:	a0 a3       	std	Z+32, r26	; 0x20
    b5e2:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    b5e4:	f6 01       	movw	r30, r12
    b5e6:	85 a1       	ldd	r24, Z+37	; 0x25
    b5e8:	96 a1       	ldd	r25, Z+38	; 0x26
    b5ea:	a7 a1       	ldd	r26, Z+39	; 0x27
    b5ec:	b0 a5       	ldd	r27, Z+40	; 0x28
    b5ee:	f8 01       	movw	r30, r16
    b5f0:	23 85       	ldd	r18, Z+11	; 0x0b
    b5f2:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    b5f4:	f9 01       	movw	r30, r18
    b5f6:	82 a3       	std	Z+34, r24	; 0x22
    b5f8:	93 a3       	std	Z+35, r25	; 0x23
    b5fa:	a4 a3       	std	Z+36, r26	; 0x24
    b5fc:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    b5fe:	f6 01       	movw	r30, r12
    b600:	81 a5       	ldd	r24, Z+41	; 0x29
    b602:	92 a5       	ldd	r25, Z+42	; 0x2a
    b604:	a3 a5       	ldd	r26, Z+43	; 0x2b
    b606:	b4 a5       	ldd	r27, Z+44	; 0x2c
    b608:	f8 01       	movw	r30, r16
    b60a:	23 85       	ldd	r18, Z+11	; 0x0b
    b60c:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    b60e:	f9 01       	movw	r30, r18
    b610:	86 a3       	std	Z+38, r24	; 0x26
    b612:	97 a3       	std	Z+39, r25	; 0x27
    b614:	a0 a7       	std	Z+40, r26	; 0x28
    b616:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    b618:	f6 01       	movw	r30, r12
    b61a:	85 a5       	ldd	r24, Z+45	; 0x2d
    b61c:	96 a5       	ldd	r25, Z+46	; 0x2e
    b61e:	a7 a5       	ldd	r26, Z+47	; 0x2f
    b620:	b0 a9       	ldd	r27, Z+48	; 0x30
    b622:	f8 01       	movw	r30, r16
    b624:	23 85       	ldd	r18, Z+11	; 0x0b
    b626:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    b628:	f9 01       	movw	r30, r18
    b62a:	82 a7       	std	Z+42, r24	; 0x2a
    b62c:	93 a7       	std	Z+43, r25	; 0x2b
    b62e:	a4 a7       	std	Z+44, r26	; 0x2c
    b630:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    b632:	f6 01       	movw	r30, r12
    b634:	81 a9       	ldd	r24, Z+49	; 0x31
    b636:	92 a9       	ldd	r25, Z+50	; 0x32
    b638:	a3 a9       	ldd	r26, Z+51	; 0x33
    b63a:	b4 a9       	ldd	r27, Z+52	; 0x34
    b63c:	f8 01       	movw	r30, r16
    b63e:	23 85       	ldd	r18, Z+11	; 0x0b
    b640:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    b642:	f9 01       	movw	r30, r18
    b644:	86 a7       	std	Z+46, r24	; 0x2e
    b646:	97 a7       	std	Z+47, r25	; 0x2f
    b648:	a0 ab       	std	Z+48, r26	; 0x30
    b64a:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    b64c:	f6 01       	movw	r30, r12
    b64e:	85 a9       	ldd	r24, Z+53	; 0x35
    b650:	96 a9       	ldd	r25, Z+54	; 0x36
    b652:	a7 a9       	ldd	r26, Z+55	; 0x37
    b654:	b0 ad       	ldd	r27, Z+56	; 0x38
    b656:	f8 01       	movw	r30, r16
    b658:	23 85       	ldd	r18, Z+11	; 0x0b
    b65a:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    b65c:	f9 01       	movw	r30, r18
    b65e:	82 ab       	std	Z+50, r24	; 0x32
    b660:	93 ab       	std	Z+51, r25	; 0x33
    b662:	a4 ab       	std	Z+52, r26	; 0x34
    b664:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    b666:	f6 01       	movw	r30, r12
    b668:	81 ad       	ldd	r24, Z+57	; 0x39
    b66a:	92 ad       	ldd	r25, Z+58	; 0x3a
    b66c:	a3 ad       	ldd	r26, Z+59	; 0x3b
    b66e:	b4 ad       	ldd	r27, Z+60	; 0x3c
    b670:	f8 01       	movw	r30, r16
    b672:	23 85       	ldd	r18, Z+11	; 0x0b
    b674:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    b676:	f9 01       	movw	r30, r18
    b678:	86 ab       	std	Z+54, r24	; 0x36
    b67a:	97 ab       	std	Z+55, r25	; 0x37
    b67c:	a0 af       	std	Z+56, r26	; 0x38
    b67e:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    b680:	f6 01       	movw	r30, r12
    b682:	fd 96       	adiw	r30, 0x3d	; 61
    b684:	80 81       	ld	r24, Z
    b686:	91 81       	ldd	r25, Z+1	; 0x01
    b688:	a2 81       	ldd	r26, Z+2	; 0x02
    b68a:	b3 81       	ldd	r27, Z+3	; 0x03
    b68c:	f8 01       	movw	r30, r16
    b68e:	23 85       	ldd	r18, Z+11	; 0x0b
    b690:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    b692:	f9 01       	movw	r30, r18
    b694:	82 af       	std	Z+58, r24	; 0x3a
    b696:	93 af       	std	Z+59, r25	; 0x3b
    b698:	a4 af       	std	Z+60, r26	; 0x3c
    b69a:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    b69c:	f6 01       	movw	r30, r12
    b69e:	ef 5b       	subi	r30, 0xBF	; 191
    b6a0:	ff 4f       	sbci	r31, 0xFF	; 255
    b6a2:	80 81       	ld	r24, Z
    b6a4:	91 81       	ldd	r25, Z+1	; 0x01
    b6a6:	a2 81       	ldd	r26, Z+2	; 0x02
    b6a8:	b3 81       	ldd	r27, Z+3	; 0x03
    b6aa:	f8 01       	movw	r30, r16
    b6ac:	23 85       	ldd	r18, Z+11	; 0x0b
    b6ae:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    b6b0:	f9 01       	movw	r30, r18
    b6b2:	fe 96       	adiw	r30, 0x3e	; 62
    b6b4:	80 83       	st	Z, r24
    b6b6:	91 83       	std	Z+1, r25	; 0x01
    b6b8:	a2 83       	std	Z+2, r26	; 0x02
    b6ba:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    b6bc:	f6 01       	movw	r30, r12
    b6be:	eb 5b       	subi	r30, 0xBB	; 187
    b6c0:	ff 4f       	sbci	r31, 0xFF	; 255
    b6c2:	80 81       	ld	r24, Z
    b6c4:	91 81       	ldd	r25, Z+1	; 0x01
    b6c6:	a2 81       	ldd	r26, Z+2	; 0x02
    b6c8:	b3 81       	ldd	r27, Z+3	; 0x03
    b6ca:	f8 01       	movw	r30, r16
    b6cc:	23 85       	ldd	r18, Z+11	; 0x0b
    b6ce:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    b6d0:	f9 01       	movw	r30, r18
    b6d2:	ee 5b       	subi	r30, 0xBE	; 190
    b6d4:	ff 4f       	sbci	r31, 0xFF	; 255
    b6d6:	80 83       	st	Z, r24
    b6d8:	91 83       	std	Z+1, r25	; 0x01
    b6da:	a2 83       	std	Z+2, r26	; 0x02
    b6dc:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    b6de:	f6 01       	movw	r30, r12
    b6e0:	e7 5b       	subi	r30, 0xB7	; 183
    b6e2:	ff 4f       	sbci	r31, 0xFF	; 255
    b6e4:	80 81       	ld	r24, Z
    b6e6:	91 81       	ldd	r25, Z+1	; 0x01
    b6e8:	a2 81       	ldd	r26, Z+2	; 0x02
    b6ea:	b3 81       	ldd	r27, Z+3	; 0x03
    b6ec:	f8 01       	movw	r30, r16
    b6ee:	23 85       	ldd	r18, Z+11	; 0x0b
    b6f0:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    b6f2:	f9 01       	movw	r30, r18
    b6f4:	ea 5b       	subi	r30, 0xBA	; 186
    b6f6:	ff 4f       	sbci	r31, 0xFF	; 255
    b6f8:	80 83       	st	Z, r24
    b6fa:	91 83       	std	Z+1, r25	; 0x01
    b6fc:	a2 83       	std	Z+2, r26	; 0x02
    b6fe:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    b700:	f6 01       	movw	r30, r12
    b702:	e3 5b       	subi	r30, 0xB3	; 179
    b704:	ff 4f       	sbci	r31, 0xFF	; 255
    b706:	80 81       	ld	r24, Z
    b708:	91 81       	ldd	r25, Z+1	; 0x01
    b70a:	a2 81       	ldd	r26, Z+2	; 0x02
    b70c:	b3 81       	ldd	r27, Z+3	; 0x03
    b70e:	f8 01       	movw	r30, r16
    b710:	23 85       	ldd	r18, Z+11	; 0x0b
    b712:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    b714:	f9 01       	movw	r30, r18
    b716:	e6 5b       	subi	r30, 0xB6	; 182
    b718:	ff 4f       	sbci	r31, 0xFF	; 255
    b71a:	80 83       	st	Z, r24
    b71c:	91 83       	std	Z+1, r25	; 0x01
    b71e:	a2 83       	std	Z+2, r26	; 0x02
    b720:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    b722:	f6 01       	movw	r30, r12
    b724:	ef 5a       	subi	r30, 0xAF	; 175
    b726:	ff 4f       	sbci	r31, 0xFF	; 255
    b728:	80 81       	ld	r24, Z
    b72a:	91 81       	ldd	r25, Z+1	; 0x01
    b72c:	a2 81       	ldd	r26, Z+2	; 0x02
    b72e:	b3 81       	ldd	r27, Z+3	; 0x03
    b730:	f8 01       	movw	r30, r16
    b732:	23 85       	ldd	r18, Z+11	; 0x0b
    b734:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    b736:	f9 01       	movw	r30, r18
    b738:	e2 5b       	subi	r30, 0xB2	; 178
    b73a:	ff 4f       	sbci	r31, 0xFF	; 255
    b73c:	80 83       	st	Z, r24
    b73e:	91 83       	std	Z+1, r25	; 0x01
    b740:	a2 83       	std	Z+2, r26	; 0x02
    b742:	b3 83       	std	Z+3, r27	; 0x03
				
			model->ReferenceMagYawRads(telemMsg->YawRefSetpoint);
    b744:	f6 01       	movw	r30, r12
    b746:	ef 59       	subi	r30, 0x9F	; 159
    b748:	ff 4f       	sbci	r31, 0xFF	; 255
    b74a:	80 81       	ld	r24, Z
    b74c:	91 81       	ldd	r25, Z+1	; 0x01
    b74e:	a2 81       	ldd	r26, Z+2	; 0x02
    b750:	b3 81       	ldd	r27, Z+3	; 0x03
    b752:	f8 01       	movw	r30, r16
    b754:	21 85       	ldd	r18, Z+9	; 0x09
    b756:	32 85       	ldd	r19, Z+10	; 0x0a
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    b758:	f9 01       	movw	r30, r18
    b75a:	86 83       	std	Z+6, r24	; 0x06
    b75c:	97 83       	std	Z+7, r25	; 0x07
    b75e:	a0 87       	std	Z+8, r26	; 0x08
    b760:	b1 87       	std	Z+9, r27	; 0x09
			model->ReferenceXNEDLocalFrameCm(telemMsg->XRefSetpoint);
    b762:	f6 01       	movw	r30, r12
    b764:	eb 5a       	subi	r30, 0xAB	; 171
    b766:	ff 4f       	sbci	r31, 0xFF	; 255
    b768:	80 81       	ld	r24, Z
    b76a:	91 81       	ldd	r25, Z+1	; 0x01
    b76c:	a2 81       	ldd	r26, Z+2	; 0x02
    b76e:	b3 81       	ldd	r27, Z+3	; 0x03
    b770:	f8 01       	movw	r30, r16
    b772:	21 85       	ldd	r18, Z+9	; 0x09
    b774:	32 85       	ldd	r19, Z+10	; 0x0a
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    b776:	f9 01       	movw	r30, r18
    b778:	86 a3       	std	Z+38, r24	; 0x26
    b77a:	97 a3       	std	Z+39, r25	; 0x27
    b77c:	a0 a7       	std	Z+40, r26	; 0x28
    b77e:	b1 a7       	std	Z+41, r27	; 0x29
			model->ReferenceYNEDLocalFrameCm(telemMsg->YRefSetpoint);
    b780:	f6 01       	movw	r30, r12
    b782:	e7 5a       	subi	r30, 0xA7	; 167
    b784:	ff 4f       	sbci	r31, 0xFF	; 255
    b786:	80 81       	ld	r24, Z
    b788:	91 81       	ldd	r25, Z+1	; 0x01
    b78a:	a2 81       	ldd	r26, Z+2	; 0x02
    b78c:	b3 81       	ldd	r27, Z+3	; 0x03
    b78e:	f8 01       	movw	r30, r16
    b790:	21 85       	ldd	r18, Z+9	; 0x09
    b792:	32 85       	ldd	r19, Z+10	; 0x0a

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    b794:	f9 01       	movw	r30, r18
    b796:	ee 5a       	subi	r30, 0xAE	; 174
    b798:	ff 4f       	sbci	r31, 0xFF	; 255
    b79a:	80 83       	st	Z, r24
    b79c:	91 83       	std	Z+1, r25	; 0x01
    b79e:	a2 83       	std	Z+2, r26	; 0x02
    b7a0:	b3 83       	std	Z+3, r27	; 0x03
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
    b7a2:	f6 01       	movw	r30, r12
    b7a4:	e3 5a       	subi	r30, 0xA3	; 163
    b7a6:	ff 4f       	sbci	r31, 0xFF	; 255
    b7a8:	80 81       	ld	r24, Z
    b7aa:	91 81       	ldd	r25, Z+1	; 0x01
    b7ac:	a2 81       	ldd	r26, Z+2	; 0x02
    b7ae:	b3 81       	ldd	r27, Z+3	; 0x03
    b7b0:	f8 01       	movw	r30, r16
    b7b2:	21 85       	ldd	r18, Z+9	; 0x09
    b7b4:	32 85       	ldd	r19, Z+10	; 0x0a
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    b7b6:	f9 01       	movw	r30, r18
    b7b8:	ee 57       	subi	r30, 0x7E	; 126
    b7ba:	ff 4f       	sbci	r31, 0xFF	; 255
    b7bc:	80 83       	st	Z, r24
    b7be:	91 83       	std	Z+1, r25	; 0x01
    b7c0:	a2 83       	std	Z+2, r26	; 0x02
    b7c2:	b3 83       	std	Z+3, r27	; 0x03
		}
			
	}
		
	if (message != NULL)
    b7c4:	cf 80       	ldd	r12, Y+7	; 0x07
    b7c6:	d8 84       	ldd	r13, Y+8	; 0x08
    b7c8:	c1 14       	cp	r12, r1
    b7ca:	d1 04       	cpc	r13, r1
    b7cc:	09 f4       	brne	.+2      	; 0xb7d0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    b7ce:	6c c0       	rjmp	.+216    	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		delete message;
    b7d0:	d6 01       	movw	r26, r12
    b7d2:	ed 91       	ld	r30, X+
    b7d4:	fc 91       	ld	r31, X
    b7d6:	02 80       	ldd	r0, Z+2	; 0x02
    b7d8:	f3 81       	ldd	r31, Z+3	; 0x03
    b7da:	e0 2d       	mov	r30, r0
    b7dc:	c6 01       	movw	r24, r12
    b7de:	19 95       	eicall
		message = NULL;
    b7e0:	18 86       	std	Y+8, r1	; 0x08
    b7e2:	1f 82       	std	Y+7, r1	; 0x07
	}

	
	//Update instrumentation fields
	switch (status)
    b7e4:	bd ef       	ldi	r27, 0xFD	; 253
    b7e6:	eb 16       	cp	r14, r27
    b7e8:	bf ef       	ldi	r27, 0xFF	; 255
    b7ea:	fb 06       	cpc	r15, r27
    b7ec:	b9 f1       	breq	.+110    	; 0xb85c <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x824>
    b7ee:	3c f4       	brge	.+14     	; 0xb7fe <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c6>
    b7f0:	fc ef       	ldi	r31, 0xFC	; 252
    b7f2:	ef 16       	cp	r14, r31
    b7f4:	ff ef       	ldi	r31, 0xFF	; 255
    b7f6:	ff 06       	cpc	r15, r31
    b7f8:	09 f4       	brne	.+2      	; 0xb7fc <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c4>
    b7fa:	43 c0       	rjmp	.+134    	; 0xb882 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x84a>
    b7fc:	55 c0       	rjmp	.+170    	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
    b7fe:	8e ef       	ldi	r24, 0xFE	; 254
    b800:	e8 16       	cp	r14, r24
    b802:	8f ef       	ldi	r24, 0xFF	; 255
    b804:	f8 06       	cpc	r15, r24
    b806:	b9 f0       	breq	.+46     	; 0xb836 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7fe>
    b808:	ef 20       	and	r14, r15
    b80a:	e0 94       	com	r14
    b80c:	09 f0       	breq	.+2      	; 0xb810 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7d8>
    b80e:	4c c0       	rjmp	.+152    	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		case 0:
		break;
		case -1:
		model->Timeouts(model->Timeouts() + 1);
    b810:	d8 01       	movw	r26, r16
    b812:	19 96       	adiw	r26, 0x09	; 9
    b814:	ed 91       	ld	r30, X+
    b816:	fc 91       	ld	r31, X
    b818:	1a 97       	sbiw	r26, 0x0a	; 10
			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
    b81a:	e6 55       	subi	r30, 0x56	; 86
    b81c:	ff 4f       	sbci	r31, 0xFF	; 255
    b81e:	80 81       	ld	r24, Z
    b820:	91 81       	ldd	r25, Z+1	; 0x01
    b822:	a2 81       	ldd	r26, Z+2	; 0x02
    b824:	b3 81       	ldd	r27, Z+3	; 0x03
    b826:	01 96       	adiw	r24, 0x01	; 1
    b828:	a1 1d       	adc	r26, r1
    b82a:	b1 1d       	adc	r27, r1
    b82c:	80 83       	st	Z, r24
    b82e:	91 83       	std	Z+1, r25	; 0x01
    b830:	a2 83       	std	Z+2, r26	; 0x02
    b832:	b3 83       	std	Z+3, r27	; 0x03
    b834:	39 c0       	rjmp	.+114    	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -2:
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns() + 1);
    b836:	d8 01       	movw	r26, r16
    b838:	19 96       	adiw	r26, 0x09	; 9
    b83a:	ed 91       	ld	r30, X+
    b83c:	fc 91       	ld	r31, X
    b83e:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    b840:	e6 54       	subi	r30, 0x46	; 70
    b842:	ff 4f       	sbci	r31, 0xFF	; 255
    b844:	80 81       	ld	r24, Z
    b846:	91 81       	ldd	r25, Z+1	; 0x01
    b848:	a2 81       	ldd	r26, Z+2	; 0x02
    b84a:	b3 81       	ldd	r27, Z+3	; 0x03
    b84c:	01 96       	adiw	r24, 0x01	; 1
    b84e:	a1 1d       	adc	r26, r1
    b850:	b1 1d       	adc	r27, r1
    b852:	80 83       	st	Z, r24
    b854:	91 83       	std	Z+1, r25	; 0x01
    b856:	a2 83       	std	Z+2, r26	; 0x02
    b858:	b3 83       	std	Z+3, r27	; 0x03
    b85a:	26 c0       	rjmp	.+76     	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -3:
		model->UnrecognizedMsgTypes(model->UnrecognizedMsgTypes() + 1);
    b85c:	d8 01       	movw	r26, r16
    b85e:	19 96       	adiw	r26, 0x09	; 9
    b860:	ed 91       	ld	r30, X+
    b862:	fc 91       	ld	r31, X
    b864:	1a 97       	sbiw	r26, 0x0a	; 10
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
    b866:	e2 55       	subi	r30, 0x52	; 82
    b868:	ff 4f       	sbci	r31, 0xFF	; 255
    b86a:	80 81       	ld	r24, Z
    b86c:	91 81       	ldd	r25, Z+1	; 0x01
    b86e:	a2 81       	ldd	r26, Z+2	; 0x02
    b870:	b3 81       	ldd	r27, Z+3	; 0x03
    b872:	01 96       	adiw	r24, 0x01	; 1
    b874:	a1 1d       	adc	r26, r1
    b876:	b1 1d       	adc	r27, r1
    b878:	80 83       	st	Z, r24
    b87a:	91 83       	std	Z+1, r25	; 0x01
    b87c:	a2 83       	std	Z+2, r26	; 0x02
    b87e:	b3 83       	std	Z+3, r27	; 0x03
    b880:	13 c0       	rjmp	.+38     	; 0xb8a8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -4:
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    b882:	d8 01       	movw	r26, r16
    b884:	19 96       	adiw	r26, 0x09	; 9
    b886:	ed 91       	ld	r30, X+
    b888:	fc 91       	ld	r31, X
    b88a:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    b88c:	ee 54       	subi	r30, 0x4E	; 78
    b88e:	ff 4f       	sbci	r31, 0xFF	; 255
    b890:	40 81       	ld	r20, Z
    b892:	51 81       	ldd	r21, Z+1	; 0x01
    b894:	62 81       	ldd	r22, Z+2	; 0x02
    b896:	73 81       	ldd	r23, Z+3	; 0x03
    b898:	4f 5f       	subi	r20, 0xFF	; 255
    b89a:	5f 4f       	sbci	r21, 0xFF	; 255
    b89c:	6f 4f       	sbci	r22, 0xFF	; 255
    b89e:	7f 4f       	sbci	r23, 0xFF	; 255
    b8a0:	40 83       	st	Z, r20
    b8a2:	51 83       	std	Z+1, r21	; 0x01
    b8a4:	62 83       	std	Z+2, r22	; 0x02
    b8a6:	73 83       	std	Z+3, r23	; 0x03
	
	
	//Send sync message to indicate to the ground control station that we are ready to receive data.
	//Without this sync message, the GCS could send data while the FC is asleep, which would cause the data
	//to overflow the usart buffer.
	SyncMessage syncMsg(dataToReceive);
    b8a8:	f8 01       	movw	r30, r16
    b8aa:	25 85       	ldd	r18, Z+13	; 0x0d
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    b8ac:	83 e0       	ldi	r24, 0x03	; 3
    b8ae:	8b 83       	std	Y+3, r24	; 0x03
    b8b0:	82 e0       	ldi	r24, 0x02	; 2
    b8b2:	90 e0       	ldi	r25, 0x00	; 0
    b8b4:	9d 83       	std	Y+5, r25	; 0x05
    b8b6:	8c 83       	std	Y+4, r24	; 0x04
				byte RequestedMessage;
							
				static const byte MessageSize =
					sizeof(msgType) + sizeof(RequestedMessage);
							
				SyncMessage(byte requestedMessage): Message(MessageType,MessageSize), RequestedMessage(requestedMessage)
    b8b8:	84 e7       	ldi	r24, 0x74	; 116
    b8ba:	92 e0       	ldi	r25, 0x02	; 2
    b8bc:	9a 83       	std	Y+2, r25	; 0x02
    b8be:	89 83       	std	Y+1, r24	; 0x01
    b8c0:	2e 83       	std	Y+6, r18	; 0x06
	
	//Send this out after receiving data so if there is asynchronous processing, the system doesn't try to
	//read a partial message that might have actually been transmitted just after sending the transmit message.
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
    b8c2:	be 01       	movw	r22, r28
    b8c4:	6f 5f       	subi	r22, 0xFF	; 255
    b8c6:	7f 4f       	sbci	r23, 0xFF	; 255
    b8c8:	87 81       	ldd	r24, Z+7	; 0x07
    b8ca:	90 85       	ldd	r25, Z+8	; 0x08
    b8cc:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    b8d0:	89 2b       	or	r24, r25
    b8d2:	d1 f0       	breq	.+52     	; 0xb908 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    b8d4:	d8 01       	movw	r26, r16
    b8d6:	19 96       	adiw	r26, 0x09	; 9
    b8d8:	ed 91       	ld	r30, X+
    b8da:	fc 91       	ld	r31, X
    b8dc:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    b8de:	e6 54       	subi	r30, 0x46	; 70
    b8e0:	ff 4f       	sbci	r31, 0xFF	; 255
    b8e2:	80 81       	ld	r24, Z
    b8e4:	91 81       	ldd	r25, Z+1	; 0x01
    b8e6:	a2 81       	ldd	r26, Z+2	; 0x02
    b8e8:	b3 81       	ldd	r27, Z+3	; 0x03
    b8ea:	01 96       	adiw	r24, 0x01	; 1
    b8ec:	a1 1d       	adc	r26, r1
    b8ee:	b1 1d       	adc	r27, r1
    b8f0:	80 83       	st	Z, r24
    b8f2:	91 83       	std	Z+1, r25	; 0x01
    b8f4:	a2 83       	std	Z+2, r26	; 0x02
    b8f6:	b3 83       	std	Z+3, r27	; 0x03
    b8f8:	07 c0       	rjmp	.+14     	; 0xb908 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
		}
			
	}
		
	if (message != NULL)
    b8fa:	cf 80       	ldd	r12, Y+7	; 0x07
    b8fc:	d8 84       	ldd	r13, Y+8	; 0x08
    b8fe:	c1 14       	cp	r12, r1
    b900:	d1 04       	cpc	r13, r1
    b902:	09 f0       	breq	.+2      	; 0xb906 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8ce>
    b904:	65 cf       	rjmp	.-310    	; 0xb7d0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    b906:	6e cf       	rjmp	.-292    	; 0xb7e4 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7ac>
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
	}
}
    b908:	28 96       	adiw	r28, 0x08	; 8
    b90a:	0f b6       	in	r0, 0x3f	; 63
    b90c:	f8 94       	cli
    b90e:	de bf       	out	0x3e, r29	; 62
    b910:	0f be       	out	0x3f, r0	; 63
    b912:	cd bf       	out	0x3d, r28	; 61
    b914:	df 91       	pop	r29
    b916:	cf 91       	pop	r28
    b918:	1f 91       	pop	r17
    b91a:	0f 91       	pop	r16
    b91c:	ff 90       	pop	r15
    b91e:	ef 90       	pop	r14
    b920:	df 90       	pop	r13
    b922:	cf 90       	pop	r12
    b924:	08 95       	ret

0000b926 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>:
#include "GainsMessage.h"

using namespace helicopter::tasks;
using namespace helicopter::messages;

SimTelemetryTask::SimTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, PIDController *pidController,  DATATORECEIVE dataToReceive, int delay, int period) :
    b926:	6f 92       	push	r6
    b928:	7f 92       	push	r7
    b92a:	8f 92       	push	r8
    b92c:	9f 92       	push	r9
    b92e:	af 92       	push	r10
    b930:	bf 92       	push	r11
    b932:	cf 92       	push	r12
    b934:	df 92       	push	r13
    b936:	ef 92       	push	r14
    b938:	ff 92       	push	r15
    b93a:	0f 93       	push	r16
    b93c:	cf 93       	push	r28
    b93e:	df 93       	push	r29
    b940:	ec 01       	movw	r28, r24
    b942:	3b 01       	movw	r6, r22
    b944:	4a 01       	movw	r8, r20
    b946:	59 01       	movw	r10, r18
    b948:	b7 01       	movw	r22, r14
    b94a:	a6 01       	movw	r20, r12
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	pidController(pidController),
	dataToReceive(dataToReceive)
    b94c:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    b950:	88 e6       	ldi	r24, 0x68	; 104
    b952:	93 e0       	ldi	r25, 0x03	; 3
    b954:	99 83       	std	Y+1, r25	; 0x01
    b956:	88 83       	st	Y, r24
    b958:	78 86       	std	Y+8, r7	; 0x08
    b95a:	6f 82       	std	Y+7, r6	; 0x07
    b95c:	9a 86       	std	Y+10, r9	; 0x0a
    b95e:	89 86       	std	Y+9, r8	; 0x09
    b960:	bc 86       	std	Y+12, r11	; 0x0c
    b962:	ab 86       	std	Y+11, r10	; 0x0b
    b964:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    b966:	df 91       	pop	r29
    b968:	cf 91       	pop	r28
    b96a:	0f 91       	pop	r16
    b96c:	ff 90       	pop	r15
    b96e:	ef 90       	pop	r14
    b970:	df 90       	pop	r13
    b972:	cf 90       	pop	r12
    b974:	bf 90       	pop	r11
    b976:	af 90       	pop	r10
    b978:	9f 90       	pop	r9
    b97a:	8f 90       	pop	r8
    b97c:	7f 90       	pop	r7
    b97e:	6f 90       	pop	r6
    b980:	08 95       	ret

0000b982 <_ZN10helicopter5tasks4Task11runTaskImplEv>:
				
			protected:
				/**
				* Implemented by subclasses for the actual logic to execute
				*/
				virtual void runTaskImpl(){;}
    b982:	08 95       	ret

0000b984 <_ZN10helicopter5tasks4TaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    b984:	26 e7       	ldi	r18, 0x76	; 118
    b986:	33 e0       	ldi	r19, 0x03	; 3
    b988:	fc 01       	movw	r30, r24
    b98a:	31 83       	std	Z+1, r19	; 0x01
    b98c:	20 83       	st	Z, r18
    b98e:	08 95       	ret

0000b990 <_ZN10helicopter5tasks4Task7runTaskEv>:
{
	//Disable interrupts 
	//cli(); //removed because gps serial driver will miss a lot of bytes notifications if a task runs for a long time.
	
	//run task
	this->runTaskImpl();
    b990:	dc 01       	movw	r26, r24
    b992:	ed 91       	ld	r30, X+
    b994:	fc 91       	ld	r31, X
    b996:	01 90       	ld	r0, Z+
    b998:	f0 81       	ld	r31, Z
    b99a:	e0 2d       	mov	r30, r0
    b99c:	19 95       	eicall
    b99e:	08 95       	ret

0000b9a0 <_ZN10helicopter5tasks4TaskD0Ev>:
    b9a0:	26 e7       	ldi	r18, 0x76	; 118
    b9a2:	33 e0       	ldi	r19, 0x03	; 3
    b9a4:	fc 01       	movw	r30, r24
    b9a6:	31 83       	std	Z+1, r19	; 0x01
    b9a8:	20 83       	st	Z, r18
    b9aa:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    b9ae:	08 95       	ret

0000b9b0 <_ZN10helicopter5tasks4TaskC1Eii>:
#include <avr/interrupt.h>
#include "Task.h"

using namespace helicopter::tasks;

Task::Task(int delay, int period)
    b9b0:	fc 01       	movw	r30, r24
    b9b2:	86 e7       	ldi	r24, 0x76	; 118
    b9b4:	93 e0       	ldi	r25, 0x03	; 3
    b9b6:	91 83       	std	Z+1, r25	; 0x01
    b9b8:	80 83       	st	Z, r24
{
	this->delay = delay;
    b9ba:	73 83       	std	Z+3, r23	; 0x03
    b9bc:	62 83       	std	Z+2, r22	; 0x02
	this->period = period;
    b9be:	55 83       	std	Z+5, r21	; 0x05
    b9c0:	44 83       	std	Z+4, r20	; 0x04
	this->isReadyToRun = false;
    b9c2:	16 82       	std	Z+6, r1	; 0x06
    b9c4:	08 95       	ret

0000b9c6 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>:
    b9c6:	26 e7       	ldi	r18, 0x76	; 118
    b9c8:	33 e0       	ldi	r19, 0x03	; 3
    b9ca:	fc 01       	movw	r30, r24
    b9cc:	31 83       	std	Z+1, r19	; 0x01
    b9ce:	20 83       	st	Z, r18
    b9d0:	08 95       	ret

0000b9d2 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>:
    b9d2:	26 e7       	ldi	r18, 0x76	; 118
    b9d4:	33 e0       	ldi	r19, 0x03	; 3
    b9d6:	fc 01       	movw	r30, r24
    b9d8:	31 83       	std	Z+1, r19	; 0x01
    b9da:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class transmits flight computer telemetry information to the ground control station.
		 */
		class TransmitTelemetryTask : public Task
    b9dc:	0e 94 09 61 	call	0xc212	; 0xc212 <_ZdlPv>
    b9e0:	08 95       	ret

0000b9e2 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>:
	
}


void TransmitTelemetryTask::runTaskImpl()
{
    b9e2:	2f 92       	push	r2
    b9e4:	3f 92       	push	r3
    b9e6:	4f 92       	push	r4
    b9e8:	5f 92       	push	r5
    b9ea:	6f 92       	push	r6
    b9ec:	7f 92       	push	r7
    b9ee:	8f 92       	push	r8
    b9f0:	9f 92       	push	r9
    b9f2:	af 92       	push	r10
    b9f4:	bf 92       	push	r11
    b9f6:	cf 92       	push	r12
    b9f8:	df 92       	push	r13
    b9fa:	ef 92       	push	r14
    b9fc:	ff 92       	push	r15
    b9fe:	0f 93       	push	r16
    ba00:	1f 93       	push	r17
    ba02:	cf 93       	push	r28
    ba04:	df 93       	push	r29
    ba06:	cd b7       	in	r28, 0x3d	; 61
    ba08:	de b7       	in	r29, 0x3e	; 62
    ba0a:	62 97       	sbiw	r28, 0x12	; 18
    ba0c:	0f b6       	in	r0, 0x3f	; 63
    ba0e:	f8 94       	cli
    ba10:	de bf       	out	0x3e, r29	; 62
    ba12:	0f be       	out	0x3f, r0	; 63
    ba14:	cd bf       	out	0x3d, r28	; 61
    ba16:	9e 87       	std	Y+14, r25	; 0x0e
    ba18:	8d 87       	std	Y+13, r24	; 0x0d
		model->YawRads(yawRads);
		model->PitchRads(-asin(model->Ahrs()->dcm[2][0]));
		model->RollRads(atan2(model->Ahrs()->dcm[2][1], model->Ahrs()->dcm[2][2]));
	}*/
	
	if (dataToSend == ALLDATA)
    ba1a:	dc 01       	movw	r26, r24
    ba1c:	1b 96       	adiw	r26, 0x0b	; 11
    ba1e:	8c 91       	ld	r24, X
    ba20:	1b 97       	sbiw	r26, 0x0b	; 11
    ba22:	81 11       	cpse	r24, r1
    ba24:	31 c0       	rjmp	.+98     	; 0xba88 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xa6>
	{
		//SystemTelemetryMessage *message = model->CreateTelemetryMessage();
		SystemTelemetryMessage *message = SystemTelemetryMessage::buildMessageFromModel(model);
    ba26:	19 96       	adiw	r26, 0x09	; 9
    ba28:	8d 91       	ld	r24, X+
    ba2a:	9c 91       	ld	r25, X
    ba2c:	1a 97       	sbiw	r26, 0x0a	; 10
    ba2e:	0e 94 bc 34 	call	0x6978	; 0x6978 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>
    ba32:	8c 01       	movw	r16, r24
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();
*/	
	
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    ba34:	bc 01       	movw	r22, r24
    ba36:	ed 85       	ldd	r30, Y+13	; 0x0d
    ba38:	fe 85       	ldd	r31, Y+14	; 0x0e
    ba3a:	87 81       	ldd	r24, Z+7	; 0x07
    ba3c:	90 85       	ldd	r25, Z+8	; 0x08
    ba3e:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    ba42:	89 2b       	or	r24, r25
    ba44:	a1 f0       	breq	.+40     	; 0xba6e <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x8c>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    ba46:	ad 85       	ldd	r26, Y+13	; 0x0d
    ba48:	be 85       	ldd	r27, Y+14	; 0x0e
    ba4a:	19 96       	adiw	r26, 0x09	; 9
    ba4c:	ed 91       	ld	r30, X+
    ba4e:	fc 91       	ld	r31, X
    ba50:	1a 97       	sbiw	r26, 0x0a	; 10
    ba52:	e6 54       	subi	r30, 0x46	; 70
    ba54:	ff 4f       	sbci	r31, 0xFF	; 255
    ba56:	40 81       	ld	r20, Z
    ba58:	51 81       	ldd	r21, Z+1	; 0x01
    ba5a:	62 81       	ldd	r22, Z+2	; 0x02
    ba5c:	73 81       	ldd	r23, Z+3	; 0x03
    ba5e:	4f 5f       	subi	r20, 0xFF	; 255
    ba60:	5f 4f       	sbci	r21, 0xFF	; 255
    ba62:	6f 4f       	sbci	r22, 0xFF	; 255
    ba64:	7f 4f       	sbci	r23, 0xFF	; 255
    ba66:	40 83       	st	Z, r20
    ba68:	51 83       	std	Z+1, r21	; 0x01
    ba6a:	62 83       	std	Z+2, r22	; 0x02
    ba6c:	73 83       	std	Z+3, r23	; 0x03
		}
	
		delete message;
    ba6e:	01 15       	cp	r16, r1
    ba70:	11 05       	cpc	r17, r1
    ba72:	09 f4       	brne	.+2      	; 0xba76 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x94>
    ba74:	8a c3       	rjmp	.+1812   	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
    ba76:	d8 01       	movw	r26, r16
    ba78:	ed 91       	ld	r30, X+
    ba7a:	fc 91       	ld	r31, X
    ba7c:	02 80       	ldd	r0, Z+2	; 0x02
    ba7e:	f3 81       	ldd	r31, Z+3	; 0x03
    ba80:	e0 2d       	mov	r30, r0
    ba82:	c8 01       	movw	r24, r16
    ba84:	19 95       	eicall
    ba86:	81 c3       	rjmp	.+1794   	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
	}else if (dataToSend == CONTROLDATA)
    ba88:	81 30       	cpi	r24, 0x01	; 1
    ba8a:	09 f0       	breq	.+2      	; 0xba8e <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xac>
    ba8c:	89 c0       	rjmp	.+274    	; 0xbba0 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1be>
	{
		ControlMessage *message = new ControlMessage();
    ba8e:	85 e1       	ldi	r24, 0x15	; 21
    ba90:	90 e0       	ldi	r25, 0x00	; 0
    ba92:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    ba96:	8c 01       	movw	r16, r24
    ba98:	85 e0       	ldi	r24, 0x05	; 5
    ba9a:	f8 01       	movw	r30, r16
    ba9c:	82 83       	std	Z+2, r24	; 0x02
    ba9e:	81 e1       	ldi	r24, 0x11	; 17
    baa0:	90 e0       	ldi	r25, 0x00	; 0
    baa2:	94 83       	std	Z+4, r25	; 0x04
    baa4:	83 83       	std	Z+3, r24	; 0x03
				
				ControlMessage(): Message(MessageType,MessageSize),
					MainRotorCollectiveControl(0),
					YawControl(0),
					LongitudeControl(0),
					LateralControl(0)
    baa6:	88 e3       	ldi	r24, 0x38	; 56
    baa8:	92 e0       	ldi	r25, 0x02	; 2
    baaa:	91 83       	std	Z+1, r25	; 0x01
    baac:	80 83       	st	Z, r24
    baae:	15 82       	std	Z+5, r1	; 0x05
    bab0:	16 82       	std	Z+6, r1	; 0x06
    bab2:	17 82       	std	Z+7, r1	; 0x07
    bab4:	10 86       	std	Z+8, r1	; 0x08
    bab6:	11 86       	std	Z+9, r1	; 0x09
    bab8:	12 86       	std	Z+10, r1	; 0x0a
    baba:	13 86       	std	Z+11, r1	; 0x0b
    babc:	14 86       	std	Z+12, r1	; 0x0c
    babe:	15 86       	std	Z+13, r1	; 0x0d
    bac0:	16 86       	std	Z+14, r1	; 0x0e
    bac2:	17 86       	std	Z+15, r1	; 0x0f
    bac4:	10 8a       	std	Z+16, r1	; 0x10
    bac6:	11 8a       	std	Z+17, r1	; 0x11
    bac8:	12 8a       	std	Z+18, r1	; 0x12
    baca:	13 8a       	std	Z+19, r1	; 0x13
    bacc:	14 8a       	std	Z+20, r1	; 0x14
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    bace:	ad 85       	ldd	r26, Y+13	; 0x0d
    bad0:	be 85       	ldd	r27, Y+14	; 0x0e
    bad2:	19 96       	adiw	r26, 0x09	; 9
    bad4:	ed 91       	ld	r30, X+
    bad6:	fc 91       	ld	r31, X
    bad8:	1a 97       	sbiw	r26, 0x0a	; 10
    bada:	e6 5a       	subi	r30, 0xA6	; 166
    badc:	ff 4f       	sbci	r31, 0xFF	; 255
    bade:	80 81       	ld	r24, Z
    bae0:	91 81       	ldd	r25, Z+1	; 0x01
    bae2:	a2 81       	ldd	r26, Z+2	; 0x02
    bae4:	b3 81       	ldd	r27, Z+3	; 0x03
		message->LateralControl = model->LateralControl();
    bae6:	f8 01       	movw	r30, r16
    bae8:	81 8b       	std	Z+17, r24	; 0x11
    baea:	92 8b       	std	Z+18, r25	; 0x12
    baec:	a3 8b       	std	Z+19, r26	; 0x13
    baee:	b4 8b       	std	Z+20, r27	; 0x14
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    baf0:	ad 85       	ldd	r26, Y+13	; 0x0d
    baf2:	be 85       	ldd	r27, Y+14	; 0x0e
    baf4:	19 96       	adiw	r26, 0x09	; 9
    baf6:	ed 91       	ld	r30, X+
    baf8:	fc 91       	ld	r31, X
    bafa:	1a 97       	sbiw	r26, 0x0a	; 10
    bafc:	86 a5       	ldd	r24, Z+46	; 0x2e
    bafe:	97 a5       	ldd	r25, Z+47	; 0x2f
    bb00:	a0 a9       	ldd	r26, Z+48	; 0x30
    bb02:	b1 a9       	ldd	r27, Z+49	; 0x31
		message->LongitudeControl = model->LongitudeControl();
    bb04:	f8 01       	movw	r30, r16
    bb06:	85 87       	std	Z+13, r24	; 0x0d
    bb08:	96 87       	std	Z+14, r25	; 0x0e
    bb0a:	a7 87       	std	Z+15, r26	; 0x0f
    bb0c:	b0 8b       	std	Z+16, r27	; 0x10

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    bb0e:	ad 85       	ldd	r26, Y+13	; 0x0d
    bb10:	be 85       	ldd	r27, Y+14	; 0x0e
    bb12:	19 96       	adiw	r26, 0x09	; 9
    bb14:	ed 91       	ld	r30, X+
    bb16:	fc 91       	ld	r31, X
    bb18:	1a 97       	sbiw	r26, 0x0a	; 10
    bb1a:	ea 57       	subi	r30, 0x7A	; 122
    bb1c:	ff 4f       	sbci	r31, 0xFF	; 255
    bb1e:	80 81       	ld	r24, Z
    bb20:	91 81       	ldd	r25, Z+1	; 0x01
    bb22:	a2 81       	ldd	r26, Z+2	; 0x02
    bb24:	b3 81       	ldd	r27, Z+3	; 0x03
		message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    bb26:	f8 01       	movw	r30, r16
    bb28:	85 83       	std	Z+5, r24	; 0x05
    bb2a:	96 83       	std	Z+6, r25	; 0x06
    bb2c:	a7 83       	std	Z+7, r26	; 0x07
    bb2e:	b0 87       	std	Z+8, r27	; 0x08
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    bb30:	ad 85       	ldd	r26, Y+13	; 0x0d
    bb32:	be 85       	ldd	r27, Y+14	; 0x0e
    bb34:	19 96       	adiw	r26, 0x09	; 9
    bb36:	ed 91       	ld	r30, X+
    bb38:	fc 91       	ld	r31, X
    bb3a:	1a 97       	sbiw	r26, 0x0a	; 10
    bb3c:	42 85       	ldd	r20, Z+10	; 0x0a
    bb3e:	53 85       	ldd	r21, Z+11	; 0x0b
    bb40:	64 85       	ldd	r22, Z+12	; 0x0c
    bb42:	75 85       	ldd	r23, Z+13	; 0x0d
		message->YawControl = model->YawControl();
    bb44:	f8 01       	movw	r30, r16
    bb46:	41 87       	std	Z+9, r20	; 0x09
    bb48:	52 87       	std	Z+10, r21	; 0x0a
    bb4a:	63 87       	std	Z+11, r22	; 0x0b
    bb4c:	74 87       	std	Z+12, r23	; 0x0c
		
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    bb4e:	b8 01       	movw	r22, r16
    bb50:	17 96       	adiw	r26, 0x07	; 7
    bb52:	8d 91       	ld	r24, X+
    bb54:	9c 91       	ld	r25, X
    bb56:	18 97       	sbiw	r26, 0x08	; 8
    bb58:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    bb5c:	89 2b       	or	r24, r25
    bb5e:	99 f0       	breq	.+38     	; 0xbb86 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1a4>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    bb60:	ad 85       	ldd	r26, Y+13	; 0x0d
    bb62:	be 85       	ldd	r27, Y+14	; 0x0e
    bb64:	19 96       	adiw	r26, 0x09	; 9
    bb66:	ed 91       	ld	r30, X+
    bb68:	fc 91       	ld	r31, X
    bb6a:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    bb6c:	e6 54       	subi	r30, 0x46	; 70
    bb6e:	ff 4f       	sbci	r31, 0xFF	; 255
    bb70:	80 81       	ld	r24, Z
    bb72:	91 81       	ldd	r25, Z+1	; 0x01
    bb74:	a2 81       	ldd	r26, Z+2	; 0x02
    bb76:	b3 81       	ldd	r27, Z+3	; 0x03
    bb78:	01 96       	adiw	r24, 0x01	; 1
    bb7a:	a1 1d       	adc	r26, r1
    bb7c:	b1 1d       	adc	r27, r1
    bb7e:	80 83       	st	Z, r24
    bb80:	91 83       	std	Z+1, r25	; 0x01
    bb82:	a2 83       	std	Z+2, r26	; 0x02
    bb84:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		delete message;		
    bb86:	01 15       	cp	r16, r1
    bb88:	11 05       	cpc	r17, r1
    bb8a:	09 f4       	brne	.+2      	; 0xbb8e <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1ac>
    bb8c:	fe c2       	rjmp	.+1532   	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
    bb8e:	d8 01       	movw	r26, r16
    bb90:	ed 91       	ld	r30, X+
    bb92:	fc 91       	ld	r31, X
    bb94:	02 80       	ldd	r0, Z+2	; 0x02
    bb96:	f3 81       	ldd	r31, Z+3	; 0x03
    bb98:	e0 2d       	mov	r30, r0
    bb9a:	c8 01       	movw	r24, r16
    bb9c:	19 95       	eicall
    bb9e:	f5 c2       	rjmp	.+1514   	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
		}else if (dataToSend == SIMPLEDATA)
    bba0:	82 30       	cpi	r24, 0x02	; 2
    bba2:	09 f0       	breq	.+2      	; 0xbba6 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1c4>
    bba4:	f2 c2       	rjmp	.+1508   	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
		{
			SimpleTelemetryMessage *message = new SimpleTelemetryMessage();
    bba6:	8d e7       	ldi	r24, 0x7D	; 125
    bba8:	90 e0       	ldi	r25, 0x00	; 0
    bbaa:	0e 94 06 61 	call	0xc20c	; 0xc20c <_Znwj>
    bbae:	8c 01       	movw	r16, r24
    bbb0:	86 e0       	ldi	r24, 0x06	; 6
    bbb2:	f8 01       	movw	r30, r16
    bbb4:	82 83       	std	Z+2, r24	; 0x02
    bbb6:	89 e7       	ldi	r24, 0x79	; 121
    bbb8:	90 e0       	ldi	r25, 0x00	; 0
    bbba:	94 83       	std	Z+4, r25	; 0x04
    bbbc:	83 83       	std	Z+3, r24	; 0x03
    bbbe:	88 e6       	ldi	r24, 0x68	; 104
    bbc0:	92 e0       	ldi	r25, 0x02	; 2
    bbc2:	91 83       	std	Z+1, r25	; 0x01
    bbc4:	80 83       	st	Z, r24
    bbc6:	15 82       	std	Z+5, r1	; 0x05
    bbc8:	16 82       	std	Z+6, r1	; 0x06
    bbca:	17 82       	std	Z+7, r1	; 0x07
    bbcc:	10 86       	std	Z+8, r1	; 0x08
    bbce:	11 86       	std	Z+9, r1	; 0x09
    bbd0:	12 86       	std	Z+10, r1	; 0x0a
    bbd2:	13 86       	std	Z+11, r1	; 0x0b
    bbd4:	14 86       	std	Z+12, r1	; 0x0c
    bbd6:	15 86       	std	Z+13, r1	; 0x0d
    bbd8:	16 86       	std	Z+14, r1	; 0x0e
    bbda:	17 86       	std	Z+15, r1	; 0x0f
    bbdc:	10 8a       	std	Z+16, r1	; 0x10
    bbde:	11 8a       	std	Z+17, r1	; 0x11
    bbe0:	12 8a       	std	Z+18, r1	; 0x12
    bbe2:	13 8a       	std	Z+19, r1	; 0x13
    bbe4:	14 8a       	std	Z+20, r1	; 0x14
    bbe6:	15 8a       	std	Z+21, r1	; 0x15
    bbe8:	16 8a       	std	Z+22, r1	; 0x16
    bbea:	17 8a       	std	Z+23, r1	; 0x17
    bbec:	10 8e       	std	Z+24, r1	; 0x18
    bbee:	11 8e       	std	Z+25, r1	; 0x19
    bbf0:	12 8e       	std	Z+26, r1	; 0x1a
    bbf2:	13 8e       	std	Z+27, r1	; 0x1b
    bbf4:	14 8e       	std	Z+28, r1	; 0x1c
    bbf6:	15 8e       	std	Z+29, r1	; 0x1d
    bbf8:	16 8e       	std	Z+30, r1	; 0x1e
    bbfa:	17 8e       	std	Z+31, r1	; 0x1f
    bbfc:	10 a2       	std	Z+32, r1	; 0x20
    bbfe:	11 a2       	std	Z+33, r1	; 0x21
    bc00:	12 a2       	std	Z+34, r1	; 0x22
    bc02:	13 a2       	std	Z+35, r1	; 0x23
    bc04:	14 a2       	std	Z+36, r1	; 0x24
    bc06:	15 a2       	std	Z+37, r1	; 0x25
    bc08:	16 a2       	std	Z+38, r1	; 0x26
    bc0a:	17 a2       	std	Z+39, r1	; 0x27
    bc0c:	10 a6       	std	Z+40, r1	; 0x28
    bc0e:	11 a6       	std	Z+41, r1	; 0x29
    bc10:	12 a6       	std	Z+42, r1	; 0x2a
    bc12:	13 a6       	std	Z+43, r1	; 0x2b
    bc14:	14 a6       	std	Z+44, r1	; 0x2c
    bc16:	15 a6       	std	Z+45, r1	; 0x2d
    bc18:	16 a6       	std	Z+46, r1	; 0x2e
    bc1a:	17 a6       	std	Z+47, r1	; 0x2f
    bc1c:	10 aa       	std	Z+48, r1	; 0x30
    bc1e:	11 aa       	std	Z+49, r1	; 0x31
    bc20:	12 aa       	std	Z+50, r1	; 0x32
    bc22:	13 aa       	std	Z+51, r1	; 0x33
    bc24:	14 aa       	std	Z+52, r1	; 0x34
    bc26:	15 aa       	std	Z+53, r1	; 0x35
    bc28:	16 aa       	std	Z+54, r1	; 0x36
    bc2a:	17 aa       	std	Z+55, r1	; 0x37
    bc2c:	10 ae       	std	Z+56, r1	; 0x38
    bc2e:	11 ae       	std	Z+57, r1	; 0x39
    bc30:	12 ae       	std	Z+58, r1	; 0x3a
    bc32:	13 ae       	std	Z+59, r1	; 0x3b
    bc34:	14 ae       	std	Z+60, r1	; 0x3c
    bc36:	78 01       	movw	r14, r16
    bc38:	fd e3       	ldi	r31, 0x3D	; 61
    bc3a:	ef 0e       	add	r14, r31
    bc3c:	f1 1c       	adc	r15, r1
    bc3e:	d7 01       	movw	r26, r14
    bc40:	1d 92       	st	X+, r1
    bc42:	1d 92       	st	X+, r1
    bc44:	1d 92       	st	X+, r1
    bc46:	1c 92       	st	X, r1
    bc48:	13 97       	sbiw	r26, 0x03	; 3
    bc4a:	b8 01       	movw	r22, r16
    bc4c:	6f 5b       	subi	r22, 0xBF	; 191
    bc4e:	7f 4f       	sbci	r23, 0xFF	; 255
    bc50:	fb 01       	movw	r30, r22
    bc52:	10 82       	st	Z, r1
    bc54:	11 82       	std	Z+1, r1	; 0x01
    bc56:	12 82       	std	Z+2, r1	; 0x02
    bc58:	13 82       	std	Z+3, r1	; 0x03
    bc5a:	a8 01       	movw	r20, r16
    bc5c:	4b 5b       	subi	r20, 0xBB	; 187
    bc5e:	5f 4f       	sbci	r21, 0xFF	; 255
    bc60:	da 01       	movw	r26, r20
    bc62:	1d 92       	st	X+, r1
    bc64:	1d 92       	st	X+, r1
    bc66:	1d 92       	st	X+, r1
    bc68:	1c 92       	st	X, r1
    bc6a:	13 97       	sbiw	r26, 0x03	; 3
    bc6c:	98 01       	movw	r18, r16
    bc6e:	27 5b       	subi	r18, 0xB7	; 183
    bc70:	3f 4f       	sbci	r19, 0xFF	; 255
    bc72:	f9 01       	movw	r30, r18
    bc74:	10 82       	st	Z, r1
    bc76:	11 82       	std	Z+1, r1	; 0x01
    bc78:	12 82       	std	Z+2, r1	; 0x02
    bc7a:	13 82       	std	Z+3, r1	; 0x03
    bc7c:	c8 01       	movw	r24, r16
    bc7e:	83 5b       	subi	r24, 0xB3	; 179
    bc80:	9f 4f       	sbci	r25, 0xFF	; 255
    bc82:	98 8b       	std	Y+16, r25	; 0x10
    bc84:	8f 87       	std	Y+15, r24	; 0x0f
    bc86:	dc 01       	movw	r26, r24
    bc88:	1d 92       	st	X+, r1
    bc8a:	1d 92       	st	X+, r1
    bc8c:	1d 92       	st	X+, r1
    bc8e:	1c 92       	st	X, r1
    bc90:	13 97       	sbiw	r26, 0x03	; 3
    bc92:	14 96       	adiw	r26, 0x04	; 4
    bc94:	1d 92       	st	X+, r1
    bc96:	1d 92       	st	X+, r1
    bc98:	1d 92       	st	X+, r1
    bc9a:	1c 92       	st	X, r1
    bc9c:	13 97       	sbiw	r26, 0x03	; 3
    bc9e:	3c 96       	adiw	r30, 0x0c	; 12
    bca0:	fa 8b       	std	Y+18, r31	; 0x12
    bca2:	e9 8b       	std	Y+17, r30	; 0x11
    bca4:	10 82       	st	Z, r1
    bca6:	11 82       	std	Z+1, r1	; 0x01
    bca8:	12 82       	std	Z+2, r1	; 0x02
    bcaa:	13 82       	std	Z+3, r1	; 0x03
    bcac:	58 01       	movw	r10, r16
    bcae:	f9 e5       	ldi	r31, 0x59	; 89
    bcb0:	af 0e       	add	r10, r31
    bcb2:	b1 1c       	adc	r11, r1
    bcb4:	f5 01       	movw	r30, r10
    bcb6:	10 82       	st	Z, r1
    bcb8:	11 82       	std	Z+1, r1	; 0x01
    bcba:	12 82       	std	Z+2, r1	; 0x02
    bcbc:	13 82       	std	Z+3, r1	; 0x03
    bcbe:	48 01       	movw	r8, r16
    bcc0:	fd e5       	ldi	r31, 0x5D	; 93
    bcc2:	8f 0e       	add	r8, r31
    bcc4:	91 1c       	adc	r9, r1
    bcc6:	f4 01       	movw	r30, r8
    bcc8:	10 82       	st	Z, r1
    bcca:	11 82       	std	Z+1, r1	; 0x01
    bccc:	12 82       	std	Z+2, r1	; 0x02
    bcce:	13 82       	std	Z+3, r1	; 0x03
    bcd0:	18 01       	movw	r2, r16
    bcd2:	f1 e6       	ldi	r31, 0x61	; 97
    bcd4:	2f 0e       	add	r2, r31
    bcd6:	31 1c       	adc	r3, r1
    bcd8:	f1 01       	movw	r30, r2
    bcda:	10 82       	st	Z, r1
    bcdc:	11 82       	std	Z+1, r1	; 0x01
    bcde:	12 82       	std	Z+2, r1	; 0x02
    bce0:	13 82       	std	Z+3, r1	; 0x03
    bce2:	48 96       	adiw	r24, 0x18	; 24
    bce4:	9a 83       	std	Y+2, r25	; 0x02
    bce6:	89 83       	std	Y+1, r24	; 0x01
    bce8:	fc 01       	movw	r30, r24
    bcea:	10 82       	st	Z, r1
    bcec:	11 82       	std	Z+1, r1	; 0x01
    bcee:	12 82       	std	Z+2, r1	; 0x02
    bcf0:	13 82       	std	Z+3, r1	; 0x03
    bcf2:	04 96       	adiw	r24, 0x04	; 4
    bcf4:	9c 83       	std	Y+4, r25	; 0x04
    bcf6:	8b 83       	std	Y+3, r24	; 0x03
    bcf8:	fc 01       	movw	r30, r24
    bcfa:	10 82       	st	Z, r1
    bcfc:	11 82       	std	Z+1, r1	; 0x01
    bcfe:	12 82       	std	Z+2, r1	; 0x02
    bd00:	13 82       	std	Z+3, r1	; 0x03
    bd02:	04 96       	adiw	r24, 0x04	; 4
    bd04:	9e 83       	std	Y+6, r25	; 0x06
    bd06:	8d 83       	std	Y+5, r24	; 0x05
    bd08:	fc 01       	movw	r30, r24
    bd0a:	10 82       	st	Z, r1
    bd0c:	11 82       	std	Z+1, r1	; 0x01
    bd0e:	12 82       	std	Z+2, r1	; 0x02
    bd10:	13 82       	std	Z+3, r1	; 0x03
    bd12:	04 96       	adiw	r24, 0x04	; 4
    bd14:	98 87       	std	Y+8, r25	; 0x08
    bd16:	8f 83       	std	Y+7, r24	; 0x07
    bd18:	fc 01       	movw	r30, r24
    bd1a:	10 82       	st	Z, r1
    bd1c:	11 82       	std	Z+1, r1	; 0x01
    bd1e:	12 82       	std	Z+2, r1	; 0x02
    bd20:	13 82       	std	Z+3, r1	; 0x03
    bd22:	04 96       	adiw	r24, 0x04	; 4
    bd24:	9a 87       	std	Y+10, r25	; 0x0a
    bd26:	89 87       	std	Y+9, r24	; 0x09
    bd28:	fc 01       	movw	r30, r24
    bd2a:	10 82       	st	Z, r1
    bd2c:	11 82       	std	Z+1, r1	; 0x01
    bd2e:	12 82       	std	Z+2, r1	; 0x02
    bd30:	13 82       	std	Z+3, r1	; 0x03
    bd32:	04 96       	adiw	r24, 0x04	; 4
    bd34:	9c 87       	std	Y+12, r25	; 0x0c
    bd36:	8b 87       	std	Y+11, r24	; 0x0b
    bd38:	fc 01       	movw	r30, r24
    bd3a:	10 82       	st	Z, r1
    bd3c:	11 82       	std	Z+1, r1	; 0x01
    bd3e:	12 82       	std	Z+2, r1	; 0x02
    bd40:	13 82       	std	Z+3, r1	; 0x03
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    bd42:	ed 85       	ldd	r30, Y+13	; 0x0d
    bd44:	fe 85       	ldd	r31, Y+14	; 0x0e
    bd46:	c1 84       	ldd	r12, Z+9	; 0x09
    bd48:	d2 84       	ldd	r13, Z+10	; 0x0a
    bd4a:	f2 ed       	ldi	r31, 0xD2	; 210
    bd4c:	cf 0e       	add	r12, r31
    bd4e:	d1 1c       	adc	r13, r1
    bd50:	f6 01       	movw	r30, r12
    bd52:	40 80       	ld	r4, Z
    bd54:	51 80       	ldd	r5, Z+1	; 0x01
    bd56:	62 80       	ldd	r6, Z+2	; 0x02
    bd58:	73 80       	ldd	r7, Z+3	; 0x03
			
			message->PitchRads = model->PitchRads();
    bd5a:	f8 01       	movw	r30, r16
    bd5c:	45 86       	std	Z+13, r4	; 0x0d
    bd5e:	56 86       	std	Z+14, r5	; 0x0e
    bd60:	67 86       	std	Z+15, r6	; 0x0f
    bd62:	70 8a       	std	Z+16, r7	; 0x10
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    bd64:	ed 85       	ldd	r30, Y+13	; 0x0d
    bd66:	fe 85       	ldd	r31, Y+14	; 0x0e
    bd68:	c1 84       	ldd	r12, Z+9	; 0x09
    bd6a:	d2 84       	ldd	r13, Z+10	; 0x0a
    bd6c:	f6 01       	movw	r30, r12
    bd6e:	42 a0       	ldd	r4, Z+34	; 0x22
    bd70:	53 a0       	ldd	r5, Z+35	; 0x23
    bd72:	64 a0       	ldd	r6, Z+36	; 0x24
    bd74:	75 a0       	ldd	r7, Z+37	; 0x25
			message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    bd76:	f8 01       	movw	r30, r16
    bd78:	45 82       	std	Z+5, r4	; 0x05
    bd7a:	56 82       	std	Z+6, r5	; 0x06
    bd7c:	67 82       	std	Z+7, r6	; 0x07
    bd7e:	70 86       	std	Z+8, r7	; 0x08
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    bd80:	ed 85       	ldd	r30, Y+13	; 0x0d
    bd82:	fe 85       	ldd	r31, Y+14	; 0x0e
    bd84:	c1 84       	ldd	r12, Z+9	; 0x09
    bd86:	d2 84       	ldd	r13, Z+10	; 0x0a
    bd88:	f6 01       	movw	r30, r12
    bd8a:	42 a8       	ldd	r4, Z+50	; 0x32
    bd8c:	53 a8       	ldd	r5, Z+51	; 0x33
    bd8e:	64 a8       	ldd	r6, Z+52	; 0x34
    bd90:	75 a8       	ldd	r7, Z+53	; 0x35
//message->XNEDLocalFrame = model->LateralControl();			
			message->XVelocityFRDCms = model->XVelocityFRDCms();
    bd92:	f8 01       	movw	r30, r16
    bd94:	41 86       	std	Z+9, r4	; 0x09
    bd96:	52 86       	std	Z+10, r5	; 0x0a
    bd98:	63 86       	std	Z+11, r6	; 0x0b
    bd9a:	74 86       	std	Z+12, r7	; 0x0c
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    bd9c:	ed 85       	ldd	r30, Y+13	; 0x0d
    bd9e:	fe 85       	ldd	r31, Y+14	; 0x0e
    bda0:	c1 84       	ldd	r12, Z+9	; 0x09
    bda2:	d2 84       	ldd	r13, Z+10	; 0x0a
    bda4:	fe ec       	ldi	r31, 0xCE	; 206
    bda6:	cf 0e       	add	r12, r31
    bda8:	d1 1c       	adc	r13, r1
    bdaa:	f6 01       	movw	r30, r12
    bdac:	40 80       	ld	r4, Z
    bdae:	51 80       	ldd	r5, Z+1	; 0x01
    bdb0:	62 80       	ldd	r6, Z+2	; 0x02
    bdb2:	73 80       	ldd	r7, Z+3	; 0x03

			
			message->RollRads = model->RollRads();
    bdb4:	f8 01       	movw	r30, r16
    bdb6:	41 8e       	std	Z+25, r4	; 0x19
    bdb8:	52 8e       	std	Z+26, r5	; 0x1a
    bdba:	63 8e       	std	Z+27, r6	; 0x1b
    bdbc:	74 8e       	std	Z+28, r7	; 0x1c
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    bdbe:	ed 85       	ldd	r30, Y+13	; 0x0d
    bdc0:	fe 85       	ldd	r31, Y+14	; 0x0e
    bdc2:	c1 84       	ldd	r12, Z+9	; 0x09
    bdc4:	d2 84       	ldd	r13, Z+10	; 0x0a
    bdc6:	fe e4       	ldi	r31, 0x4E	; 78
    bdc8:	cf 0e       	add	r12, r31
    bdca:	d1 1c       	adc	r13, r1
    bdcc:	f6 01       	movw	r30, r12
    bdce:	40 80       	ld	r4, Z
    bdd0:	51 80       	ldd	r5, Z+1	; 0x01
    bdd2:	62 80       	ldd	r6, Z+2	; 0x02
    bdd4:	73 80       	ldd	r7, Z+3	; 0x03
			message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    bdd6:	f8 01       	movw	r30, r16
    bdd8:	41 8a       	std	Z+17, r4	; 0x11
    bdda:	52 8a       	std	Z+18, r5	; 0x12
    bddc:	63 8a       	std	Z+19, r6	; 0x13
    bdde:	74 8a       	std	Z+20, r7	; 0x14
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    bde0:	ed 85       	ldd	r30, Y+13	; 0x0d
    bde2:	fe 85       	ldd	r31, Y+14	; 0x0e
    bde4:	c1 84       	ldd	r12, Z+9	; 0x09
    bde6:	d2 84       	ldd	r13, Z+10	; 0x0a
    bde8:	fe e5       	ldi	r31, 0x5E	; 94
    bdea:	cf 0e       	add	r12, r31
    bdec:	d1 1c       	adc	r13, r1
    bdee:	f6 01       	movw	r30, r12
    bdf0:	40 80       	ld	r4, Z
    bdf2:	51 80       	ldd	r5, Z+1	; 0x01
    bdf4:	62 80       	ldd	r6, Z+2	; 0x02
    bdf6:	73 80       	ldd	r7, Z+3	; 0x03
			message->YVelocityFRDCms = model->YVelocityFRDCms();
    bdf8:	f8 01       	movw	r30, r16
    bdfa:	45 8a       	std	Z+21, r4	; 0x15
    bdfc:	56 8a       	std	Z+22, r5	; 0x16
    bdfe:	67 8a       	std	Z+23, r6	; 0x17
    be00:	70 8e       	std	Z+24, r7	; 0x18
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    be02:	ed 85       	ldd	r30, Y+13	; 0x0d
    be04:	fe 85       	ldd	r31, Y+14	; 0x0e
    be06:	c1 84       	ldd	r12, Z+9	; 0x09
    be08:	d2 84       	ldd	r13, Z+10	; 0x0a
    be0a:	f6 ed       	ldi	r31, 0xD6	; 214
    be0c:	cf 0e       	add	r12, r31
    be0e:	d1 1c       	adc	r13, r1
    be10:	f6 01       	movw	r30, r12
    be12:	40 80       	ld	r4, Z
    be14:	51 80       	ldd	r5, Z+1	; 0x01
    be16:	62 80       	ldd	r6, Z+2	; 0x02
    be18:	73 80       	ldd	r7, Z+3	; 0x03
			
			
			
			message->YawRads = model->YawRads();
    be1a:	f8 01       	movw	r30, r16
    be1c:	41 a2       	std	Z+33, r4	; 0x21
    be1e:	52 a2       	std	Z+34, r5	; 0x22
    be20:	63 a2       	std	Z+35, r6	; 0x23
    be22:	74 a2       	std	Z+36, r7	; 0x24
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    be24:	ed 85       	ldd	r30, Y+13	; 0x0d
    be26:	fe 85       	ldd	r31, Y+14	; 0x0e
    be28:	c1 84       	ldd	r12, Z+9	; 0x09
    be2a:	d2 84       	ldd	r13, Z+10	; 0x0a
    be2c:	fe e8       	ldi	r31, 0x8E	; 142
    be2e:	cf 0e       	add	r12, r31
    be30:	d1 1c       	adc	r13, r1
    be32:	f6 01       	movw	r30, r12
    be34:	40 80       	ld	r4, Z
    be36:	51 80       	ldd	r5, Z+1	; 0x01
    be38:	62 80       	ldd	r6, Z+2	; 0x02
    be3a:	73 80       	ldd	r7, Z+3	; 0x03
			message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    be3c:	f8 01       	movw	r30, r16
    be3e:	45 8e       	std	Z+29, r4	; 0x1d
    be40:	56 8e       	std	Z+30, r5	; 0x1e
    be42:	67 8e       	std	Z+31, r6	; 0x1f
    be44:	70 a2       	std	Z+32, r7	; 0x20
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    be46:	ed 85       	ldd	r30, Y+13	; 0x0d
    be48:	fe 85       	ldd	r31, Y+14	; 0x0e
    be4a:	c1 84       	ldd	r12, Z+9	; 0x09
    be4c:	d2 84       	ldd	r13, Z+10	; 0x0a
    be4e:	fe e7       	ldi	r31, 0x7E	; 126
    be50:	cf 0e       	add	r12, r31
    be52:	d1 1c       	adc	r13, r1
    be54:	f6 01       	movw	r30, r12
    be56:	40 80       	ld	r4, Z
    be58:	51 80       	ldd	r5, Z+1	; 0x01
    be5a:	62 80       	ldd	r6, Z+2	; 0x02
    be5c:	73 80       	ldd	r7, Z+3	; 0x03
			message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    be5e:	f8 01       	movw	r30, r16
    be60:	45 a2       	std	Z+37, r4	; 0x25
    be62:	56 a2       	std	Z+38, r5	; 0x26
    be64:	67 a2       	std	Z+39, r6	; 0x27
    be66:	70 a6       	std	Z+40, r7	; 0x28

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    be68:	ed 85       	ldd	r30, Y+13	; 0x0d
    be6a:	fe 85       	ldd	r31, Y+14	; 0x0e
    be6c:	c1 84       	ldd	r12, Z+9	; 0x09
    be6e:	d2 84       	ldd	r13, Z+10	; 0x0a
    be70:	f6 ee       	ldi	r31, 0xE6	; 230
    be72:	cf 0e       	add	r12, r31
    be74:	d1 1c       	adc	r13, r1
    be76:	f6 01       	movw	r30, r12
    be78:	40 80       	ld	r4, Z
    be7a:	51 80       	ldd	r5, Z+1	; 0x01
    be7c:	62 80       	ldd	r6, Z+2	; 0x02
    be7e:	73 80       	ldd	r7, Z+3	; 0x03
			
			
			
			message->XAccelFrdMss = model->XAccelFrdMss();
    be80:	f8 01       	movw	r30, r16
    be82:	41 a6       	std	Z+41, r4	; 0x29
    be84:	52 a6       	std	Z+42, r5	; 0x2a
    be86:	63 a6       	std	Z+43, r6	; 0x2b
    be88:	74 a6       	std	Z+44, r7	; 0x2c
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    be8a:	ed 85       	ldd	r30, Y+13	; 0x0d
    be8c:	fe 85       	ldd	r31, Y+14	; 0x0e
    be8e:	c1 84       	ldd	r12, Z+9	; 0x09
    be90:	d2 84       	ldd	r13, Z+10	; 0x0a
    be92:	fa ee       	ldi	r31, 0xEA	; 234
    be94:	cf 0e       	add	r12, r31
    be96:	d1 1c       	adc	r13, r1
    be98:	f6 01       	movw	r30, r12
    be9a:	40 80       	ld	r4, Z
    be9c:	51 80       	ldd	r5, Z+1	; 0x01
    be9e:	62 80       	ldd	r6, Z+2	; 0x02
    bea0:	73 80       	ldd	r7, Z+3	; 0x03
			message->YAccelFrdMss = model->YAccelFrdMss();
    bea2:	f8 01       	movw	r30, r16
    bea4:	45 a6       	std	Z+45, r4	; 0x2d
    bea6:	56 a6       	std	Z+46, r5	; 0x2e
    bea8:	67 a6       	std	Z+47, r6	; 0x2f
    beaa:	70 aa       	std	Z+48, r7	; 0x30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    beac:	ed 85       	ldd	r30, Y+13	; 0x0d
    beae:	fe 85       	ldd	r31, Y+14	; 0x0e
    beb0:	c1 84       	ldd	r12, Z+9	; 0x09
    beb2:	d2 84       	ldd	r13, Z+10	; 0x0a
    beb4:	fe ee       	ldi	r31, 0xEE	; 238
    beb6:	cf 0e       	add	r12, r31
    beb8:	d1 1c       	adc	r13, r1
    beba:	f6 01       	movw	r30, r12
    bebc:	40 80       	ld	r4, Z
    bebe:	51 80       	ldd	r5, Z+1	; 0x01
    bec0:	62 80       	ldd	r6, Z+2	; 0x02
    bec2:	73 80       	ldd	r7, Z+3	; 0x03
			message->ZAccelFrdMss = model->ZAccelFrdMss();
    bec4:	f8 01       	movw	r30, r16
    bec6:	41 aa       	std	Z+49, r4	; 0x31
    bec8:	52 aa       	std	Z+50, r5	; 0x32
    beca:	63 aa       	std	Z+51, r6	; 0x33
    becc:	74 aa       	std	Z+52, r7	; 0x34
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    bece:	ed 85       	ldd	r30, Y+13	; 0x0d
    bed0:	fe 85       	ldd	r31, Y+14	; 0x0e
    bed2:	c1 84       	ldd	r12, Z+9	; 0x09
    bed4:	d2 84       	ldd	r13, Z+10	; 0x0a
    bed6:	f2 ee       	ldi	r31, 0xE2	; 226
    bed8:	cf 0e       	add	r12, r31
    beda:	d1 1c       	adc	r13, r1
    bedc:	f6 01       	movw	r30, r12
    bede:	40 80       	ld	r4, Z
    bee0:	51 80       	ldd	r5, Z+1	; 0x01
    bee2:	62 80       	ldd	r6, Z+2	; 0x02
    bee4:	73 80       	ldd	r7, Z+3	; 0x03
			message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    bee6:	f8 01       	movw	r30, r16
    bee8:	45 aa       	std	Z+53, r4	; 0x35
    beea:	56 aa       	std	Z+54, r5	; 0x36
    beec:	67 aa       	std	Z+55, r6	; 0x37
    beee:	70 ae       	std	Z+56, r7	; 0x38
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    bef0:	ed 85       	ldd	r30, Y+13	; 0x0d
    bef2:	fe 85       	ldd	r31, Y+14	; 0x0e
    bef4:	c1 84       	ldd	r12, Z+9	; 0x09
    bef6:	d2 84       	ldd	r13, Z+10	; 0x0a
    bef8:	fa ed       	ldi	r31, 0xDA	; 218
    befa:	cf 0e       	add	r12, r31
    befc:	d1 1c       	adc	r13, r1
    befe:	f6 01       	movw	r30, r12
    bf00:	40 80       	ld	r4, Z
    bf02:	51 80       	ldd	r5, Z+1	; 0x01
    bf04:	62 80       	ldd	r6, Z+2	; 0x02
    bf06:	73 80       	ldd	r7, Z+3	; 0x03
			message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    bf08:	f8 01       	movw	r30, r16
    bf0a:	41 ae       	std	Z+57, r4	; 0x39
    bf0c:	52 ae       	std	Z+58, r5	; 0x3a
    bf0e:	63 ae       	std	Z+59, r6	; 0x3b
    bf10:	74 ae       	std	Z+60, r7	; 0x3c
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    bf12:	ed 85       	ldd	r30, Y+13	; 0x0d
    bf14:	fe 85       	ldd	r31, Y+14	; 0x0e
    bf16:	c1 84       	ldd	r12, Z+9	; 0x09
    bf18:	d2 84       	ldd	r13, Z+10	; 0x0a
    bf1a:	fe ed       	ldi	r31, 0xDE	; 222
    bf1c:	cf 0e       	add	r12, r31
    bf1e:	d1 1c       	adc	r13, r1
    bf20:	f6 01       	movw	r30, r12
    bf22:	40 80       	ld	r4, Z
    bf24:	51 80       	ldd	r5, Z+1	; 0x01
    bf26:	62 80       	ldd	r6, Z+2	; 0x02
    bf28:	73 80       	ldd	r7, Z+3	; 0x03
			message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    bf2a:	f7 01       	movw	r30, r14
    bf2c:	40 82       	st	Z, r4
    bf2e:	51 82       	std	Z+1, r5	; 0x01
    bf30:	62 82       	std	Z+2, r6	; 0x02
    bf32:	73 82       	std	Z+3, r7	; 0x03
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    bf34:	ed 85       	ldd	r30, Y+13	; 0x0d
    bf36:	fe 85       	ldd	r31, Y+14	; 0x0e
    bf38:	e1 84       	ldd	r14, Z+9	; 0x09
    bf3a:	f2 84       	ldd	r15, Z+10	; 0x0a
    bf3c:	f2 ef       	ldi	r31, 0xF2	; 242
    bf3e:	ef 0e       	add	r14, r31
    bf40:	f1 1c       	adc	r15, r1
    bf42:	f7 01       	movw	r30, r14
    bf44:	c0 80       	ld	r12, Z
    bf46:	d1 80       	ldd	r13, Z+1	; 0x01
    bf48:	e2 80       	ldd	r14, Z+2	; 0x02
    bf4a:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			message->XMagFrd = model->XMagFrd();
    bf4c:	fb 01       	movw	r30, r22
    bf4e:	c0 82       	st	Z, r12
    bf50:	d1 82       	std	Z+1, r13	; 0x01
    bf52:	e2 82       	std	Z+2, r14	; 0x02
    bf54:	f3 82       	std	Z+3, r15	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    bf56:	ed 85       	ldd	r30, Y+13	; 0x0d
    bf58:	fe 85       	ldd	r31, Y+14	; 0x0e
    bf5a:	61 85       	ldd	r22, Z+9	; 0x09
    bf5c:	72 85       	ldd	r23, Z+10	; 0x0a
    bf5e:	6a 50       	subi	r22, 0x0A	; 10
    bf60:	7f 4f       	sbci	r23, 0xFF	; 255
    bf62:	fb 01       	movw	r30, r22
    bf64:	c0 80       	ld	r12, Z
    bf66:	d1 80       	ldd	r13, Z+1	; 0x01
    bf68:	e2 80       	ldd	r14, Z+2	; 0x02
    bf6a:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YMagFrd = model->YMagFrd();
    bf6c:	fa 01       	movw	r30, r20
    bf6e:	c0 82       	st	Z, r12
    bf70:	d1 82       	std	Z+1, r13	; 0x01
    bf72:	e2 82       	std	Z+2, r14	; 0x02
    bf74:	f3 82       	std	Z+3, r15	; 0x03
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    bf76:	ed 85       	ldd	r30, Y+13	; 0x0d
    bf78:	fe 85       	ldd	r31, Y+14	; 0x0e
    bf7a:	41 85       	ldd	r20, Z+9	; 0x09
    bf7c:	52 85       	ldd	r21, Z+10	; 0x0a
    bf7e:	46 50       	subi	r20, 0x06	; 6
    bf80:	5f 4f       	sbci	r21, 0xFF	; 255
    bf82:	fa 01       	movw	r30, r20
    bf84:	40 81       	ld	r20, Z
    bf86:	51 81       	ldd	r21, Z+1	; 0x01
    bf88:	62 81       	ldd	r22, Z+2	; 0x02
    bf8a:	73 81       	ldd	r23, Z+3	; 0x03
			message->ZMagFrd = model->ZMagFrd();
    bf8c:	f9 01       	movw	r30, r18
    bf8e:	40 83       	st	Z, r20
    bf90:	51 83       	std	Z+1, r21	; 0x01
    bf92:	62 83       	std	Z+2, r22	; 0x02
    bf94:	73 83       	std	Z+3, r23	; 0x03
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    bf96:	ed 85       	ldd	r30, Y+13	; 0x0d
    bf98:	fe 85       	ldd	r31, Y+14	; 0x0e
    bf9a:	21 85       	ldd	r18, Z+9	; 0x09
    bf9c:	32 85       	ldd	r19, Z+10	; 0x0a
    bf9e:	22 50       	subi	r18, 0x02	; 2
    bfa0:	3f 4f       	sbci	r19, 0xFF	; 255
    bfa2:	f9 01       	movw	r30, r18
    bfa4:	40 81       	ld	r20, Z
    bfa6:	51 81       	ldd	r21, Z+1	; 0x01
    bfa8:	62 81       	ldd	r22, Z+2	; 0x02
    bfaa:	73 81       	ldd	r23, Z+3	; 0x03
/*
message->XMagFrd = model->off1();
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();			
*/
			message->XEcefCm = model->XEcefCm();
    bfac:	ef 85       	ldd	r30, Y+15	; 0x0f
    bfae:	f8 89       	ldd	r31, Y+16	; 0x10
    bfb0:	40 83       	st	Z, r20
    bfb2:	51 83       	std	Z+1, r21	; 0x01
    bfb4:	62 83       	std	Z+2, r22	; 0x02
    bfb6:	73 83       	std	Z+3, r23	; 0x03
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    bfb8:	ed 85       	ldd	r30, Y+13	; 0x0d
    bfba:	fe 85       	ldd	r31, Y+14	; 0x0e
    bfbc:	81 85       	ldd	r24, Z+9	; 0x09
    bfbe:	92 85       	ldd	r25, Z+10	; 0x0a
    bfc0:	8e 5f       	subi	r24, 0xFE	; 254
    bfc2:	9e 4f       	sbci	r25, 0xFE	; 254
    bfc4:	fc 01       	movw	r30, r24
    bfc6:	40 81       	ld	r20, Z
    bfc8:	51 81       	ldd	r21, Z+1	; 0x01
    bfca:	62 81       	ldd	r22, Z+2	; 0x02
    bfcc:	73 81       	ldd	r23, Z+3	; 0x03
			message->YEcefCm = model->YEcefCm();
    bfce:	4d 93       	st	X+, r20
    bfd0:	5d 93       	st	X+, r21
    bfd2:	6d 93       	st	X+, r22
    bfd4:	7c 93       	st	X, r23
    bfd6:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    bfd8:	ed 85       	ldd	r30, Y+13	; 0x0d
    bfda:	fe 85       	ldd	r31, Y+14	; 0x0e
    bfdc:	a1 85       	ldd	r26, Z+9	; 0x09
    bfde:	b2 85       	ldd	r27, Z+10	; 0x0a
    bfe0:	aa 5f       	subi	r26, 0xFA	; 250
    bfe2:	be 4f       	sbci	r27, 0xFE	; 254
    bfe4:	8d 91       	ld	r24, X+
    bfe6:	9d 91       	ld	r25, X+
    bfe8:	0d 90       	ld	r0, X+
    bfea:	bc 91       	ld	r27, X
    bfec:	a0 2d       	mov	r26, r0
			message->ZEcefCm = model->ZEcefCm();
    bfee:	e9 89       	ldd	r30, Y+17	; 0x11
    bff0:	fa 89       	ldd	r31, Y+18	; 0x12
    bff2:	80 83       	st	Z, r24
    bff4:	91 83       	std	Z+1, r25	; 0x01
    bff6:	a2 83       	std	Z+2, r26	; 0x02
    bff8:	b3 83       	std	Z+3, r27	; 0x03
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    bffa:	ad 85       	ldd	r26, Y+13	; 0x0d
    bffc:	be 85       	ldd	r27, Y+14	; 0x0e
    bffe:	19 96       	adiw	r26, 0x09	; 9
    c000:	ed 91       	ld	r30, X+
    c002:	fc 91       	ld	r31, X
    c004:	1a 97       	sbiw	r26, 0x0a	; 10
    c006:	e6 5f       	subi	r30, 0xF6	; 246
    c008:	fe 4f       	sbci	r31, 0xFE	; 254
    c00a:	80 81       	ld	r24, Z
    c00c:	91 81       	ldd	r25, Z+1	; 0x01
    c00e:	a2 81       	ldd	r26, Z+2	; 0x02
    c010:	b3 81       	ldd	r27, Z+3	; 0x03
			message->XVEcefCms = model->XVEcefCms();
    c012:	f5 01       	movw	r30, r10
    c014:	80 83       	st	Z, r24
    c016:	91 83       	std	Z+1, r25	; 0x01
    c018:	a2 83       	std	Z+2, r26	; 0x02
    c01a:	b3 83       	std	Z+3, r27	; 0x03
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    c01c:	ad 85       	ldd	r26, Y+13	; 0x0d
    c01e:	be 85       	ldd	r27, Y+14	; 0x0e
    c020:	19 96       	adiw	r26, 0x09	; 9
    c022:	ed 91       	ld	r30, X+
    c024:	fc 91       	ld	r31, X
    c026:	1a 97       	sbiw	r26, 0x0a	; 10
    c028:	e2 5f       	subi	r30, 0xF2	; 242
    c02a:	fe 4f       	sbci	r31, 0xFE	; 254
    c02c:	80 81       	ld	r24, Z
    c02e:	91 81       	ldd	r25, Z+1	; 0x01
    c030:	a2 81       	ldd	r26, Z+2	; 0x02
    c032:	b3 81       	ldd	r27, Z+3	; 0x03
			message->YVEcefCms = model->YVEcefCms();
    c034:	f4 01       	movw	r30, r8
    c036:	80 83       	st	Z, r24
    c038:	91 83       	std	Z+1, r25	; 0x01
    c03a:	a2 83       	std	Z+2, r26	; 0x02
    c03c:	b3 83       	std	Z+3, r27	; 0x03
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    c03e:	ad 85       	ldd	r26, Y+13	; 0x0d
    c040:	be 85       	ldd	r27, Y+14	; 0x0e
    c042:	19 96       	adiw	r26, 0x09	; 9
    c044:	ed 91       	ld	r30, X+
    c046:	fc 91       	ld	r31, X
    c048:	1a 97       	sbiw	r26, 0x0a	; 10
    c04a:	ee 5e       	subi	r30, 0xEE	; 238
    c04c:	fe 4f       	sbci	r31, 0xFE	; 254
    c04e:	80 81       	ld	r24, Z
    c050:	91 81       	ldd	r25, Z+1	; 0x01
    c052:	a2 81       	ldd	r26, Z+2	; 0x02
    c054:	b3 81       	ldd	r27, Z+3	; 0x03
			message->ZVEcefCms = model->ZVEcefCms();
    c056:	f1 01       	movw	r30, r2
    c058:	80 83       	st	Z, r24
    c05a:	91 83       	std	Z+1, r25	; 0x01
    c05c:	a2 83       	std	Z+2, r26	; 0x02
    c05e:	b3 83       	std	Z+3, r27	; 0x03
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    c060:	ad 85       	ldd	r26, Y+13	; 0x0d
    c062:	be 85       	ldd	r27, Y+14	; 0x0e
    c064:	19 96       	adiw	r26, 0x09	; 9
    c066:	ed 91       	ld	r30, X+
    c068:	fc 91       	ld	r31, X
    c06a:	1a 97       	sbiw	r26, 0x0a	; 10
    c06c:	ea 5e       	subi	r30, 0xEA	; 234
    c06e:	fe 4f       	sbci	r31, 0xFE	; 254
    c070:	80 81       	ld	r24, Z
    c072:	91 81       	ldd	r25, Z+1	; 0x01
    c074:	a2 81       	ldd	r26, Z+2	; 0x02
    c076:	b3 81       	ldd	r27, Z+3	; 0x03
			message->PressureMillibars = model->PressureMillibars();
    c078:	e9 81       	ldd	r30, Y+1	; 0x01
    c07a:	fa 81       	ldd	r31, Y+2	; 0x02
    c07c:	80 83       	st	Z, r24
    c07e:	91 83       	std	Z+1, r25	; 0x01
    c080:	a2 83       	std	Z+2, r26	; 0x02
    c082:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    c084:	ad 85       	ldd	r26, Y+13	; 0x0d
    c086:	be 85       	ldd	r27, Y+14	; 0x0e
    c088:	19 96       	adiw	r26, 0x09	; 9
    c08a:	ed 91       	ld	r30, X+
    c08c:	fc 91       	ld	r31, X
    c08e:	1a 97       	sbiw	r26, 0x0a	; 10
    c090:	ee 54       	subi	r30, 0x4E	; 78
    c092:	ff 4f       	sbci	r31, 0xFF	; 255
    c094:	80 81       	ld	r24, Z
    c096:	91 81       	ldd	r25, Z+1	; 0x01
    c098:	a2 81       	ldd	r26, Z+2	; 0x02
    c09a:	b3 81       	ldd	r27, Z+3	; 0x03
			
			
			
			message->ChecksumErrors = model->ChecksumErrors();
    c09c:	ef 81       	ldd	r30, Y+7	; 0x07
    c09e:	f8 85       	ldd	r31, Y+8	; 0x08
    c0a0:	80 83       	st	Z, r24
    c0a2:	91 83       	std	Z+1, r25	; 0x01
    c0a4:	a2 83       	std	Z+2, r26	; 0x02
    c0a6:	b3 83       	std	Z+3, r27	; 0x03

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    c0a8:	ad 85       	ldd	r26, Y+13	; 0x0d
    c0aa:	be 85       	ldd	r27, Y+14	; 0x0e
    c0ac:	19 96       	adiw	r26, 0x09	; 9
    c0ae:	ed 91       	ld	r30, X+
    c0b0:	fc 91       	ld	r31, X
    c0b2:	1a 97       	sbiw	r26, 0x0a	; 10
    c0b4:	e6 55       	subi	r30, 0x56	; 86
    c0b6:	ff 4f       	sbci	r31, 0xFF	; 255
    c0b8:	80 81       	ld	r24, Z
    c0ba:	91 81       	ldd	r25, Z+1	; 0x01
    c0bc:	a2 81       	ldd	r26, Z+2	; 0x02
    c0be:	b3 81       	ldd	r27, Z+3	; 0x03
			message->Timeouts = model->Timeouts();
    c0c0:	eb 81       	ldd	r30, Y+3	; 0x03
    c0c2:	fc 81       	ldd	r31, Y+4	; 0x04
    c0c4:	80 83       	st	Z, r24
    c0c6:	91 83       	std	Z+1, r25	; 0x01
    c0c8:	a2 83       	std	Z+2, r26	; 0x02
    c0ca:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    c0cc:	ad 85       	ldd	r26, Y+13	; 0x0d
    c0ce:	be 85       	ldd	r27, Y+14	; 0x0e
    c0d0:	19 96       	adiw	r26, 0x09	; 9
    c0d2:	ed 91       	ld	r30, X+
    c0d4:	fc 91       	ld	r31, X
    c0d6:	1a 97       	sbiw	r26, 0x0a	; 10
    c0d8:	e2 55       	subi	r30, 0x52	; 82
    c0da:	ff 4f       	sbci	r31, 0xFF	; 255
    c0dc:	80 81       	ld	r24, Z
    c0de:	91 81       	ldd	r25, Z+1	; 0x01
    c0e0:	a2 81       	ldd	r26, Z+2	; 0x02
    c0e2:	b3 81       	ldd	r27, Z+3	; 0x03
			message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    c0e4:	ed 81       	ldd	r30, Y+5	; 0x05
    c0e6:	fe 81       	ldd	r31, Y+6	; 0x06
    c0e8:	80 83       	st	Z, r24
    c0ea:	91 83       	std	Z+1, r25	; 0x01
    c0ec:	a2 83       	std	Z+2, r26	; 0x02
    c0ee:	b3 83       	std	Z+3, r27	; 0x03
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    c0f0:	ad 85       	ldd	r26, Y+13	; 0x0d
    c0f2:	be 85       	ldd	r27, Y+14	; 0x0e
    c0f4:	19 96       	adiw	r26, 0x09	; 9
    c0f6:	ed 91       	ld	r30, X+
    c0f8:	fc 91       	ld	r31, X
    c0fa:	1a 97       	sbiw	r26, 0x0a	; 10
    c0fc:	ea 54       	subi	r30, 0x4A	; 74
    c0fe:	ff 4f       	sbci	r31, 0xFF	; 255
    c100:	80 81       	ld	r24, Z
    c102:	91 81       	ldd	r25, Z+1	; 0x01
    c104:	a2 81       	ldd	r26, Z+2	; 0x02
    c106:	b3 81       	ldd	r27, Z+3	; 0x03
			message->NumOfBlownFrames = model->BlownFrames();
    c108:	e9 85       	ldd	r30, Y+9	; 0x09
    c10a:	fa 85       	ldd	r31, Y+10	; 0x0a
    c10c:	80 83       	st	Z, r24
    c10e:	91 83       	std	Z+1, r25	; 0x01
    c110:	a2 83       	std	Z+2, r26	; 0x02
    c112:	b3 83       	std	Z+3, r27	; 0x03
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    c114:	ad 85       	ldd	r26, Y+13	; 0x0d
    c116:	be 85       	ldd	r27, Y+14	; 0x0e
    c118:	19 96       	adiw	r26, 0x09	; 9
    c11a:	ed 91       	ld	r30, X+
    c11c:	fc 91       	ld	r31, X
    c11e:	1a 97       	sbiw	r26, 0x0a	; 10
    c120:	e6 54       	subi	r30, 0x46	; 70
    c122:	ff 4f       	sbci	r31, 0xFF	; 255
    c124:	80 81       	ld	r24, Z
    c126:	91 81       	ldd	r25, Z+1	; 0x01
    c128:	a2 81       	ldd	r26, Z+2	; 0x02
    c12a:	b3 81       	ldd	r27, Z+3	; 0x03
			message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    c12c:	eb 85       	ldd	r30, Y+11	; 0x0b
    c12e:	fc 85       	ldd	r31, Y+12	; 0x0c
    c130:	80 83       	st	Z, r24
    c132:	91 83       	std	Z+1, r25	; 0x01
    c134:	a2 83       	std	Z+2, r26	; 0x02
    c136:	b3 83       	std	Z+3, r27	; 0x03
			
			if (radioInterface->transmit(message) != 0)
    c138:	b8 01       	movw	r22, r16
    c13a:	ad 85       	ldd	r26, Y+13	; 0x0d
    c13c:	be 85       	ldd	r27, Y+14	; 0x0e
    c13e:	17 96       	adiw	r26, 0x07	; 7
    c140:	8d 91       	ld	r24, X+
    c142:	9c 91       	ld	r25, X
    c144:	18 97       	sbiw	r26, 0x08	; 8
    c146:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c14a:	89 2b       	or	r24, r25
    c14c:	99 f0       	breq	.+38     	; 0xc174 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x792>
			{
				model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c14e:	ad 85       	ldd	r26, Y+13	; 0x0d
    c150:	be 85       	ldd	r27, Y+14	; 0x0e
    c152:	19 96       	adiw	r26, 0x09	; 9
    c154:	ed 91       	ld	r30, X+
    c156:	fc 91       	ld	r31, X
    c158:	1a 97       	sbiw	r26, 0x0a	; 10
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    c15a:	e6 54       	subi	r30, 0x46	; 70
    c15c:	ff 4f       	sbci	r31, 0xFF	; 255
    c15e:	80 81       	ld	r24, Z
    c160:	91 81       	ldd	r25, Z+1	; 0x01
    c162:	a2 81       	ldd	r26, Z+2	; 0x02
    c164:	b3 81       	ldd	r27, Z+3	; 0x03
    c166:	01 96       	adiw	r24, 0x01	; 1
    c168:	a1 1d       	adc	r26, r1
    c16a:	b1 1d       	adc	r27, r1
    c16c:	80 83       	st	Z, r24
    c16e:	91 83       	std	Z+1, r25	; 0x01
    c170:	a2 83       	std	Z+2, r26	; 0x02
    c172:	b3 83       	std	Z+3, r27	; 0x03
			}
	
			delete message;
    c174:	01 15       	cp	r16, r1
    c176:	11 05       	cpc	r17, r1
    c178:	41 f0       	breq	.+16     	; 0xc18a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7a8>
    c17a:	d8 01       	movw	r26, r16
    c17c:	ed 91       	ld	r30, X+
    c17e:	fc 91       	ld	r31, X
    c180:	02 80       	ldd	r0, Z+2	; 0x02
    c182:	f3 81       	ldd	r31, Z+3	; 0x03
    c184:	e0 2d       	mov	r30, r0
    c186:	c8 01       	movw	r24, r16
    c188:	19 95       	eicall
		}
    c18a:	62 96       	adiw	r28, 0x12	; 18
    c18c:	0f b6       	in	r0, 0x3f	; 63
    c18e:	f8 94       	cli
    c190:	de bf       	out	0x3e, r29	; 62
    c192:	0f be       	out	0x3f, r0	; 63
    c194:	cd bf       	out	0x3d, r28	; 61
    c196:	df 91       	pop	r29
    c198:	cf 91       	pop	r28
    c19a:	1f 91       	pop	r17
    c19c:	0f 91       	pop	r16
    c19e:	ff 90       	pop	r15
    c1a0:	ef 90       	pop	r14
    c1a2:	df 90       	pop	r13
    c1a4:	cf 90       	pop	r12
    c1a6:	bf 90       	pop	r11
    c1a8:	af 90       	pop	r10
    c1aa:	9f 90       	pop	r9
    c1ac:	8f 90       	pop	r8
    c1ae:	7f 90       	pop	r7
    c1b0:	6f 90       	pop	r6
    c1b2:	5f 90       	pop	r5
    c1b4:	4f 90       	pop	r4
    c1b6:	3f 90       	pop	r3
    c1b8:	2f 90       	pop	r2
    c1ba:	08 95       	ret

0000c1bc <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>:

#include <math.h>
#include <avr/io.h>
using namespace helicopter::tasks;

TransmitTelemetryTask::TransmitTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, DATATOSEND dataToSend, int delay, int period) :
    c1bc:	9f 92       	push	r9
    c1be:	af 92       	push	r10
    c1c0:	bf 92       	push	r11
    c1c2:	cf 92       	push	r12
    c1c4:	df 92       	push	r13
    c1c6:	ef 92       	push	r14
    c1c8:	ff 92       	push	r15
    c1ca:	0f 93       	push	r16
    c1cc:	1f 93       	push	r17
    c1ce:	cf 93       	push	r28
    c1d0:	df 93       	push	r29
    c1d2:	ec 01       	movw	r28, r24
    c1d4:	5b 01       	movw	r10, r22
    c1d6:	6a 01       	movw	r12, r20
    c1d8:	92 2e       	mov	r9, r18
    c1da:	b8 01       	movw	r22, r16
    c1dc:	a7 01       	movw	r20, r14
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	dataToSend(dataToSend)
    c1de:	0e 94 d8 5c 	call	0xb9b0	; 0xb9b0 <_ZN10helicopter5tasks4TaskC1Eii>
    c1e2:	84 e8       	ldi	r24, 0x84	; 132
    c1e4:	93 e0       	ldi	r25, 0x03	; 3
    c1e6:	99 83       	std	Y+1, r25	; 0x01
    c1e8:	88 83       	st	Y, r24
    c1ea:	b8 86       	std	Y+8, r11	; 0x08
    c1ec:	af 82       	std	Y+7, r10	; 0x07
    c1ee:	da 86       	std	Y+10, r13	; 0x0a
    c1f0:	c9 86       	std	Y+9, r12	; 0x09
    c1f2:	9b 86       	std	Y+11, r9	; 0x0b
{
	
}
    c1f4:	df 91       	pop	r29
    c1f6:	cf 91       	pop	r28
    c1f8:	1f 91       	pop	r17
    c1fa:	0f 91       	pop	r16
    c1fc:	ff 90       	pop	r15
    c1fe:	ef 90       	pop	r14
    c200:	df 90       	pop	r13
    c202:	cf 90       	pop	r12
    c204:	bf 90       	pop	r11
    c206:	af 90       	pop	r10
    c208:	9f 90       	pop	r9
    c20a:	08 95       	ret

0000c20c <_Znwj>:
#include <CommonHeader.h>


void * operator new(size_t size)
{
	return malloc(size);
    c20c:	0e 94 93 6c 	call	0xd926	; 0xd926 <malloc>
}
    c210:	08 95       	ret

0000c212 <_ZdlPv>:

void operator delete(void * ptr)
{
	if (ptr != NULL)
    c212:	00 97       	sbiw	r24, 0x00	; 0
    c214:	11 f0       	breq	.+4      	; 0xc21a <_ZdlPv+0x8>
	{
		free(ptr);
    c216:	0e 94 2b 6d 	call	0xda56	; 0xda56 <free>
    c21a:	08 95       	ret

0000c21c <_Znaj>:
	}
}

void * operator new[](size_t size)
{
	return malloc(size);
    c21c:	0e 94 93 6c 	call	0xd926	; 0xd926 <malloc>
}
    c220:	08 95       	ret

0000c222 <_ZdaPv>:

void operator delete[](void * ptr)
{
	if(ptr != NULL)
    c222:	00 97       	sbiw	r24, 0x00	; 0
    c224:	11 f0       	breq	.+4      	; 0xc22a <_ZdaPv+0x8>
	{
		free(ptr);
    c226:	0e 94 2b 6d 	call	0xda56	; 0xda56 <free>
    c22a:	08 95       	ret

0000c22c <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>:


const float CoordinateUtil::PIOVER180 = M_PI / 180.0f;

void CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(float latitudeDegrees, float longitudeDegrees, float  (&ecefToLocalNEDRotationMatrix)[3][3])
{
    c22c:	4f 92       	push	r4
    c22e:	5f 92       	push	r5
    c230:	6f 92       	push	r6
    c232:	7f 92       	push	r7
    c234:	8f 92       	push	r8
    c236:	9f 92       	push	r9
    c238:	af 92       	push	r10
    c23a:	bf 92       	push	r11
    c23c:	cf 92       	push	r12
    c23e:	df 92       	push	r13
    c240:	ef 92       	push	r14
    c242:	ff 92       	push	r15
    c244:	0f 93       	push	r16
    c246:	1f 93       	push	r17
    c248:	cf 93       	push	r28
    c24a:	df 93       	push	r29
    c24c:	00 d0       	rcall	.+0      	; 0xc24e <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f+0x22>
    c24e:	1f 92       	push	r1
    c250:	cd b7       	in	r28, 0x3d	; 61
    c252:	de b7       	in	r29, 0x3e	; 62
    c254:	49 01       	movw	r8, r18
    c256:	5a 01       	movw	r10, r20
				/**
				 * Converts degrees to radians
				 */
				inline static float DegreesToRad(float valueDegrees)
				{
					return valueDegrees * PIOVER180;
    c258:	25 e3       	ldi	r18, 0x35	; 53
    c25a:	3a ef       	ldi	r19, 0xFA	; 250
    c25c:	4e e8       	ldi	r20, 0x8E	; 142
    c25e:	5c e3       	ldi	r21, 0x3C	; 60
    c260:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c264:	6b 01       	movw	r12, r22
    c266:	7c 01       	movw	r14, r24
    c268:	25 e3       	ldi	r18, 0x35	; 53
    c26a:	3a ef       	ldi	r19, 0xFA	; 250
    c26c:	4e e8       	ldi	r20, 0x8E	; 142
    c26e:	5c e3       	ldi	r21, 0x3C	; 60
    c270:	c5 01       	movw	r24, r10
    c272:	b4 01       	movw	r22, r8
    c274:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c278:	4b 01       	movw	r8, r22
    c27a:	5c 01       	movw	r10, r24
	float radLat = DegreesToRad(latitudeDegrees);
	float radLong = DegreesToRad(longitudeDegrees);
	
	float sinLat = sin(radLat);
    c27c:	c7 01       	movw	r24, r14
    c27e:	b6 01       	movw	r22, r12
    c280:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c284:	69 83       	std	Y+1, r22	; 0x01
    c286:	7a 83       	std	Y+2, r23	; 0x02
    c288:	8b 83       	std	Y+3, r24	; 0x03
    c28a:	9c 83       	std	Y+4, r25	; 0x04
	float cosLat = cos(radLat);
    c28c:	c7 01       	movw	r24, r14
    c28e:	b6 01       	movw	r22, r12
    c290:	0e 94 9c 67 	call	0xcf38	; 0xcf38 <cos>
    c294:	2b 01       	movw	r4, r22
    c296:	3c 01       	movw	r6, r24
	
	float sinLong = sin(radLong);
    c298:	c5 01       	movw	r24, r10
    c29a:	b4 01       	movw	r22, r8
    c29c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c2a0:	6b 01       	movw	r12, r22
    c2a2:	7c 01       	movw	r14, r24
	float cosLong = cos(radLong);
    c2a4:	c5 01       	movw	r24, r10
    c2a6:	b4 01       	movw	r22, r8
    c2a8:	0e 94 9c 67 	call	0xcf38	; 0xcf38 <cos>
    c2ac:	4b 01       	movw	r8, r22
    c2ae:	5c 01       	movw	r10, r24

	//Create a rotation matrix for rotating earth-centered-earth-fixed coordinates
	//into Local North-East-Down coordinates.
	ecefToLocalNEDRotationMatrix[0][0] = -1 * sinLat * cosLong;
    c2b0:	89 81       	ldd	r24, Y+1	; 0x01
    c2b2:	9a 81       	ldd	r25, Y+2	; 0x02
    c2b4:	ab 81       	ldd	r26, Y+3	; 0x03
    c2b6:	bc 81       	ldd	r27, Y+4	; 0x04
    c2b8:	b0 58       	subi	r27, 0x80	; 128
    c2ba:	89 83       	std	Y+1, r24	; 0x01
    c2bc:	9a 83       	std	Y+2, r25	; 0x02
    c2be:	ab 83       	std	Y+3, r26	; 0x03
    c2c0:	bc 83       	std	Y+4, r27	; 0x04
    c2c2:	a5 01       	movw	r20, r10
    c2c4:	94 01       	movw	r18, r8
    c2c6:	bc 01       	movw	r22, r24
    c2c8:	cd 01       	movw	r24, r26
    c2ca:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c2ce:	d8 01       	movw	r26, r16
    c2d0:	6d 93       	st	X+, r22
    c2d2:	7d 93       	st	X+, r23
    c2d4:	8d 93       	st	X+, r24
    c2d6:	9c 93       	st	X, r25
    c2d8:	13 97       	sbiw	r26, 0x03	; 3
	ecefToLocalNEDRotationMatrix[0][1] = -1 * sinLat * sinLong;
    c2da:	29 81       	ldd	r18, Y+1	; 0x01
    c2dc:	3a 81       	ldd	r19, Y+2	; 0x02
    c2de:	4b 81       	ldd	r20, Y+3	; 0x03
    c2e0:	5c 81       	ldd	r21, Y+4	; 0x04
    c2e2:	c7 01       	movw	r24, r14
    c2e4:	b6 01       	movw	r22, r12
    c2e6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c2ea:	f8 01       	movw	r30, r16
    c2ec:	64 83       	std	Z+4, r22	; 0x04
    c2ee:	75 83       	std	Z+5, r23	; 0x05
    c2f0:	86 83       	std	Z+6, r24	; 0x06
    c2f2:	97 83       	std	Z+7, r25	; 0x07
	ecefToLocalNEDRotationMatrix[0][2] = cosLat;
    c2f4:	40 86       	std	Z+8, r4	; 0x08
    c2f6:	51 86       	std	Z+9, r5	; 0x09
    c2f8:	62 86       	std	Z+10, r6	; 0x0a
    c2fa:	73 86       	std	Z+11, r7	; 0x0b
	ecefToLocalNEDRotationMatrix[1][0] = -1 * sinLong;
    c2fc:	d7 01       	movw	r26, r14
    c2fe:	c6 01       	movw	r24, r12
    c300:	b0 58       	subi	r27, 0x80	; 128
    c302:	84 87       	std	Z+12, r24	; 0x0c
    c304:	95 87       	std	Z+13, r25	; 0x0d
    c306:	a6 87       	std	Z+14, r26	; 0x0e
    c308:	b7 87       	std	Z+15, r27	; 0x0f
	ecefToLocalNEDRotationMatrix[1][1] = cosLong;
    c30a:	80 8a       	std	Z+16, r8	; 0x10
    c30c:	91 8a       	std	Z+17, r9	; 0x11
    c30e:	a2 8a       	std	Z+18, r10	; 0x12
    c310:	b3 8a       	std	Z+19, r11	; 0x13
	ecefToLocalNEDRotationMatrix[1][2] = 0;
    c312:	14 8a       	std	Z+20, r1	; 0x14
    c314:	15 8a       	std	Z+21, r1	; 0x15
    c316:	16 8a       	std	Z+22, r1	; 0x16
    c318:	17 8a       	std	Z+23, r1	; 0x17
	ecefToLocalNEDRotationMatrix[2][0] = -1 * cosLat * cosLong;
    c31a:	77 fa       	bst	r7, 7
    c31c:	70 94       	com	r7
    c31e:	77 f8       	bld	r7, 7
    c320:	70 94       	com	r7
    c322:	a5 01       	movw	r20, r10
    c324:	94 01       	movw	r18, r8
    c326:	c3 01       	movw	r24, r6
    c328:	b2 01       	movw	r22, r4
    c32a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c32e:	d8 01       	movw	r26, r16
    c330:	58 96       	adiw	r26, 0x18	; 24
    c332:	6d 93       	st	X+, r22
    c334:	7d 93       	st	X+, r23
    c336:	8d 93       	st	X+, r24
    c338:	9c 93       	st	X, r25
    c33a:	5b 97       	sbiw	r26, 0x1b	; 27
	ecefToLocalNEDRotationMatrix[2][1] = -1 * cosLat * sinLong;
    c33c:	a3 01       	movw	r20, r6
    c33e:	92 01       	movw	r18, r4
    c340:	c7 01       	movw	r24, r14
    c342:	b6 01       	movw	r22, r12
    c344:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c348:	f8 01       	movw	r30, r16
    c34a:	64 8f       	std	Z+28, r22	; 0x1c
    c34c:	75 8f       	std	Z+29, r23	; 0x1d
    c34e:	86 8f       	std	Z+30, r24	; 0x1e
    c350:	97 8f       	std	Z+31, r25	; 0x1f
	ecefToLocalNEDRotationMatrix[2][2] = -1 * sinLat;
    c352:	89 81       	ldd	r24, Y+1	; 0x01
    c354:	9a 81       	ldd	r25, Y+2	; 0x02
    c356:	ab 81       	ldd	r26, Y+3	; 0x03
    c358:	bc 81       	ldd	r27, Y+4	; 0x04
    c35a:	80 a3       	std	Z+32, r24	; 0x20
    c35c:	91 a3       	std	Z+33, r25	; 0x21
    c35e:	a2 a3       	std	Z+34, r26	; 0x22
    c360:	b3 a3       	std	Z+35, r27	; 0x23
}
    c362:	0f 90       	pop	r0
    c364:	0f 90       	pop	r0
    c366:	0f 90       	pop	r0
    c368:	0f 90       	pop	r0
    c36a:	df 91       	pop	r29
    c36c:	cf 91       	pop	r28
    c36e:	1f 91       	pop	r17
    c370:	0f 91       	pop	r16
    c372:	ff 90       	pop	r15
    c374:	ef 90       	pop	r14
    c376:	df 90       	pop	r13
    c378:	cf 90       	pop	r12
    c37a:	bf 90       	pop	r11
    c37c:	af 90       	pop	r10
    c37e:	9f 90       	pop	r9
    c380:	8f 90       	pop	r8
    c382:	7f 90       	pop	r7
    c384:	6f 90       	pop	r6
    c386:	5f 90       	pop	r5
    c388:	4f 90       	pop	r4
    c38a:	08 95       	ret

0000c38c <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>:


void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
    c38c:	4f 92       	push	r4
    c38e:	5f 92       	push	r5
    c390:	6f 92       	push	r6
    c392:	7f 92       	push	r7
    c394:	af 92       	push	r10
    c396:	bf 92       	push	r11
    c398:	cf 92       	push	r12
    c39a:	df 92       	push	r13
    c39c:	ef 92       	push	r14
    c39e:	ff 92       	push	r15
    c3a0:	0f 93       	push	r16
    c3a2:	1f 93       	push	r17
    c3a4:	cf 93       	push	r28
    c3a6:	df 93       	push	r29
    c3a8:	cd b7       	in	r28, 0x3d	; 61
    c3aa:	de b7       	in	r29, 0x3e	; 62
    c3ac:	6c 97       	sbiw	r28, 0x1c	; 28
    c3ae:	0f b6       	in	r0, 0x3f	; 63
    c3b0:	f8 94       	cli
    c3b2:	de bf       	out	0x3e, r29	; 62
    c3b4:	0f be       	out	0x3f, r0	; 63
    c3b6:	cd bf       	out	0x3d, r28	; 61
    c3b8:	29 8f       	std	Y+25, r18	; 0x19
    c3ba:	3a 8f       	std	Y+26, r19	; 0x1a
    c3bc:	4b 8f       	std	Y+27, r20	; 0x1b
    c3be:	5c 8f       	std	Y+28, r21	; 0x1c
    c3c0:	27 01       	movw	r4, r14
    c3c2:	38 01       	movw	r6, r16
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
    c3c4:	8e 01       	movw	r16, r28
    c3c6:	03 5f       	subi	r16, 0xF3	; 243
    c3c8:	1f 4f       	sbci	r17, 0xFF	; 255
    c3ca:	2c e0       	ldi	r18, 0x0C	; 12
    c3cc:	f8 01       	movw	r30, r16
    c3ce:	11 92       	st	Z+, r1
    c3d0:	2a 95       	dec	r18
    c3d2:	e9 f7       	brne	.-6      	; 0xc3ce <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_+0x42>
void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
    c3d4:	a6 01       	movw	r20, r12
    c3d6:	95 01       	movw	r18, r10
    c3d8:	26 1b       	sub	r18, r22
    c3da:	37 0b       	sbc	r19, r23
    c3dc:	48 0b       	sbc	r20, r24
    c3de:	59 0b       	sbc	r21, r25
    c3e0:	ca 01       	movw	r24, r20
    c3e2:	b9 01       	movw	r22, r18
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    c3e4:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    c3e8:	69 83       	std	Y+1, r22	; 0x01
    c3ea:	7a 83       	std	Y+2, r23	; 0x02
    c3ec:	8b 83       	std	Y+3, r24	; 0x03
    c3ee:	9c 83       	std	Y+4, r25	; 0x04
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
    c3f0:	8e a5       	ldd	r24, Y+46	; 0x2e
    c3f2:	9f a5       	ldd	r25, Y+47	; 0x2f
    c3f4:	a8 a9       	ldd	r26, Y+48	; 0x30
    c3f6:	b9 a9       	ldd	r27, Y+49	; 0x31
    c3f8:	bc 01       	movw	r22, r24
    c3fa:	cd 01       	movw	r24, r26
    c3fc:	29 8d       	ldd	r18, Y+25	; 0x19
    c3fe:	3a 8d       	ldd	r19, Y+26	; 0x1a
    c400:	4b 8d       	ldd	r20, Y+27	; 0x1b
    c402:	5c 8d       	ldd	r21, Y+28	; 0x1c
    c404:	62 1b       	sub	r22, r18
    c406:	73 0b       	sbc	r23, r19
    c408:	84 0b       	sbc	r24, r20
    c40a:	95 0b       	sbc	r25, r21
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    c40c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    c410:	6d 83       	std	Y+5, r22	; 0x05
    c412:	7e 83       	std	Y+6, r23	; 0x06
    c414:	8f 83       	std	Y+7, r24	; 0x07
    c416:	98 87       	std	Y+8, r25	; 0x08
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
    c418:	8a a9       	ldd	r24, Y+50	; 0x32
    c41a:	9b a9       	ldd	r25, Y+51	; 0x33
    c41c:	ac a9       	ldd	r26, Y+52	; 0x34
    c41e:	bd a9       	ldd	r27, Y+53	; 0x35
    c420:	bc 01       	movw	r22, r24
    c422:	cd 01       	movw	r24, r26
    c424:	64 19       	sub	r22, r4
    c426:	75 09       	sbc	r23, r5
    c428:	86 09       	sbc	r24, r6
    c42a:	97 09       	sbc	r25, r7
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    c42c:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    c430:	69 87       	std	Y+9, r22	; 0x09
    c432:	7a 87       	std	Y+10, r23	; 0x0a
    c434:	8b 87       	std	Y+11, r24	; 0x0b
    c436:	9c 87       	std	Y+12, r25	; 0x0c
	
	//Rotate the current ecef position from earth centered earth fixed (ECEF) into North-East-Down(NED).
	//Iterate through the rows of the rotation matrix
	MatrixUtil::RotateMatrix(ecefToLocalNEDRotationMatrix,positionMatrix,rotatedMatrix);
    c438:	a8 01       	movw	r20, r16
    c43a:	be 01       	movw	r22, r28
    c43c:	6f 5f       	subi	r22, 0xFF	; 255
    c43e:	7f 4f       	sbci	r23, 0xFF	; 255
    c440:	8e a9       	ldd	r24, Y+54	; 0x36
    c442:	9f a9       	ldd	r25, Y+55	; 0x37
    c444:	0e 94 8e 65 	call	0xcb1c	; 0xcb1c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
	
	localNEDX = rotatedMatrix[0];
    c448:	8d 85       	ldd	r24, Y+13	; 0x0d
    c44a:	9e 85       	ldd	r25, Y+14	; 0x0e
    c44c:	af 85       	ldd	r26, Y+15	; 0x0f
    c44e:	b8 89       	ldd	r27, Y+16	; 0x10
    c450:	e8 ad       	ldd	r30, Y+56	; 0x38
    c452:	f9 ad       	ldd	r31, Y+57	; 0x39
    c454:	80 83       	st	Z, r24
    c456:	91 83       	std	Z+1, r25	; 0x01
    c458:	a2 83       	std	Z+2, r26	; 0x02
    c45a:	b3 83       	std	Z+3, r27	; 0x03
	localNEDY = rotatedMatrix[1];
    c45c:	89 89       	ldd	r24, Y+17	; 0x11
    c45e:	9a 89       	ldd	r25, Y+18	; 0x12
    c460:	ab 89       	ldd	r26, Y+19	; 0x13
    c462:	bc 89       	ldd	r27, Y+20	; 0x14
    c464:	ea ad       	ldd	r30, Y+58	; 0x3a
    c466:	fb ad       	ldd	r31, Y+59	; 0x3b
    c468:	80 83       	st	Z, r24
    c46a:	91 83       	std	Z+1, r25	; 0x01
    c46c:	a2 83       	std	Z+2, r26	; 0x02
    c46e:	b3 83       	std	Z+3, r27	; 0x03
	localNEDZ = rotatedMatrix[2];
    c470:	8d 89       	ldd	r24, Y+21	; 0x15
    c472:	9e 89       	ldd	r25, Y+22	; 0x16
    c474:	af 89       	ldd	r26, Y+23	; 0x17
    c476:	b8 8d       	ldd	r27, Y+24	; 0x18
    c478:	ec ad       	ldd	r30, Y+60	; 0x3c
    c47a:	fd ad       	ldd	r31, Y+61	; 0x3d
    c47c:	80 83       	st	Z, r24
    c47e:	91 83       	std	Z+1, r25	; 0x01
    c480:	a2 83       	std	Z+2, r26	; 0x02
    c482:	b3 83       	std	Z+3, r27	; 0x03
}
    c484:	6c 96       	adiw	r28, 0x1c	; 28
    c486:	0f b6       	in	r0, 0x3f	; 63
    c488:	f8 94       	cli
    c48a:	de bf       	out	0x3e, r29	; 62
    c48c:	0f be       	out	0x3f, r0	; 63
    c48e:	cd bf       	out	0x3d, r28	; 61
    c490:	df 91       	pop	r29
    c492:	cf 91       	pop	r28
    c494:	1f 91       	pop	r17
    c496:	0f 91       	pop	r16
    c498:	ff 90       	pop	r15
    c49a:	ef 90       	pop	r14
    c49c:	df 90       	pop	r13
    c49e:	cf 90       	pop	r12
    c4a0:	bf 90       	pop	r11
    c4a2:	af 90       	pop	r10
    c4a4:	7f 90       	pop	r7
    c4a6:	6f 90       	pop	r6
    c4a8:	5f 90       	pop	r5
    c4aa:	4f 90       	pop	r4
    c4ac:	08 95       	ret

0000c4ae <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>:
//float MatrixUtil::sinTable[91] = {0};
	
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
    c4ae:	0f 93       	push	r16
    c4b0:	1f 93       	push	r17
    c4b2:	cf 93       	push	r28
    c4b4:	df 93       	push	r29
    c4b6:	02 e3       	ldi	r16, 0x32	; 50
    c4b8:	14 e0       	ldi	r17, 0x04	; 4
	
	for (int i = 0; i <= max; i++)
    c4ba:	c0 e0       	ldi	r28, 0x00	; 0
    c4bc:	d0 e0       	ldi	r29, 0x00	; 0
	{
		sinTable[i] = sin((float)i/(float)RESOLUTION);
    c4be:	be 01       	movw	r22, r28
    c4c0:	88 27       	eor	r24, r24
    c4c2:	77 fd       	sbrc	r23, 7
    c4c4:	80 95       	com	r24
    c4c6:	98 2f       	mov	r25, r24
    c4c8:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    c4cc:	20 e0       	ldi	r18, 0x00	; 0
    c4ce:	30 e0       	ldi	r19, 0x00	; 0
    c4d0:	4a ef       	ldi	r20, 0xFA	; 250
    c4d2:	53 e4       	ldi	r21, 0x43	; 67
    c4d4:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    c4d8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c4dc:	f8 01       	movw	r30, r16
    c4de:	61 93       	st	Z+, r22
    c4e0:	71 93       	st	Z+, r23
    c4e2:	81 93       	st	Z+, r24
    c4e4:	91 93       	st	Z+, r25
    c4e6:	8f 01       	movw	r16, r30
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
	
	for (int i = 0; i <= max; i++)
    c4e8:	21 96       	adiw	r28, 0x01	; 1
    c4ea:	c2 31       	cpi	r28, 0x12	; 18
    c4ec:	f3 e0       	ldi	r31, 0x03	; 3
    c4ee:	df 07       	cpc	r29, r31
    c4f0:	31 f7       	brne	.-52     	; 0xc4be <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv+0x10>
	for (int i = 1; i <= 1000; i++)
	{
		sinTable[i-1] = sin(M_PI * i / 1000.0);
	}
	*/
}
    c4f2:	df 91       	pop	r29
    c4f4:	cf 91       	pop	r28
    c4f6:	1f 91       	pop	r17
    c4f8:	0f 91       	pop	r16
    c4fa:	08 95       	ret

0000c4fc <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>:
	*/
}


void MatrixUtil::CrossProduct(float vector1[3], float vector2[3], float (&crossProduct)[3])
{
    c4fc:	af 92       	push	r10
    c4fe:	bf 92       	push	r11
    c500:	cf 92       	push	r12
    c502:	df 92       	push	r13
    c504:	ef 92       	push	r14
    c506:	ff 92       	push	r15
    c508:	0f 93       	push	r16
    c50a:	1f 93       	push	r17
    c50c:	cf 93       	push	r28
    c50e:	df 93       	push	r29
    c510:	ec 01       	movw	r28, r24
    c512:	8b 01       	movw	r16, r22
    c514:	5a 01       	movw	r10, r20
	crossProduct[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
    c516:	fb 01       	movw	r30, r22
    c518:	20 85       	ldd	r18, Z+8	; 0x08
    c51a:	31 85       	ldd	r19, Z+9	; 0x09
    c51c:	42 85       	ldd	r20, Z+10	; 0x0a
    c51e:	53 85       	ldd	r21, Z+11	; 0x0b
    c520:	6c 81       	ldd	r22, Y+4	; 0x04
    c522:	7d 81       	ldd	r23, Y+5	; 0x05
    c524:	8e 81       	ldd	r24, Y+6	; 0x06
    c526:	9f 81       	ldd	r25, Y+7	; 0x07
    c528:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c52c:	6b 01       	movw	r12, r22
    c52e:	7c 01       	movw	r14, r24
    c530:	f8 01       	movw	r30, r16
    c532:	24 81       	ldd	r18, Z+4	; 0x04
    c534:	35 81       	ldd	r19, Z+5	; 0x05
    c536:	46 81       	ldd	r20, Z+6	; 0x06
    c538:	57 81       	ldd	r21, Z+7	; 0x07
    c53a:	68 85       	ldd	r22, Y+8	; 0x08
    c53c:	79 85       	ldd	r23, Y+9	; 0x09
    c53e:	8a 85       	ldd	r24, Y+10	; 0x0a
    c540:	9b 85       	ldd	r25, Y+11	; 0x0b
    c542:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c546:	9b 01       	movw	r18, r22
    c548:	ac 01       	movw	r20, r24
    c54a:	c7 01       	movw	r24, r14
    c54c:	b6 01       	movw	r22, r12
    c54e:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    c552:	f5 01       	movw	r30, r10
    c554:	60 83       	st	Z, r22
    c556:	71 83       	std	Z+1, r23	; 0x01
    c558:	82 83       	std	Z+2, r24	; 0x02
    c55a:	93 83       	std	Z+3, r25	; 0x03
	crossProduct[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];//-1 * (vector1[0] * vector2[2] - vector1[2]*vector2[0]);
    c55c:	f8 01       	movw	r30, r16
    c55e:	20 81       	ld	r18, Z
    c560:	31 81       	ldd	r19, Z+1	; 0x01
    c562:	42 81       	ldd	r20, Z+2	; 0x02
    c564:	53 81       	ldd	r21, Z+3	; 0x03
    c566:	68 85       	ldd	r22, Y+8	; 0x08
    c568:	79 85       	ldd	r23, Y+9	; 0x09
    c56a:	8a 85       	ldd	r24, Y+10	; 0x0a
    c56c:	9b 85       	ldd	r25, Y+11	; 0x0b
    c56e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c572:	6b 01       	movw	r12, r22
    c574:	7c 01       	movw	r14, r24
    c576:	f8 01       	movw	r30, r16
    c578:	20 85       	ldd	r18, Z+8	; 0x08
    c57a:	31 85       	ldd	r19, Z+9	; 0x09
    c57c:	42 85       	ldd	r20, Z+10	; 0x0a
    c57e:	53 85       	ldd	r21, Z+11	; 0x0b
    c580:	68 81       	ld	r22, Y
    c582:	79 81       	ldd	r23, Y+1	; 0x01
    c584:	8a 81       	ldd	r24, Y+2	; 0x02
    c586:	9b 81       	ldd	r25, Y+3	; 0x03
    c588:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c58c:	9b 01       	movw	r18, r22
    c58e:	ac 01       	movw	r20, r24
    c590:	c7 01       	movw	r24, r14
    c592:	b6 01       	movw	r22, r12
    c594:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    c598:	f5 01       	movw	r30, r10
    c59a:	64 83       	std	Z+4, r22	; 0x04
    c59c:	75 83       	std	Z+5, r23	; 0x05
    c59e:	86 83       	std	Z+6, r24	; 0x06
    c5a0:	97 83       	std	Z+7, r25	; 0x07
	crossProduct[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
    c5a2:	f8 01       	movw	r30, r16
    c5a4:	24 81       	ldd	r18, Z+4	; 0x04
    c5a6:	35 81       	ldd	r19, Z+5	; 0x05
    c5a8:	46 81       	ldd	r20, Z+6	; 0x06
    c5aa:	57 81       	ldd	r21, Z+7	; 0x07
    c5ac:	68 81       	ld	r22, Y
    c5ae:	79 81       	ldd	r23, Y+1	; 0x01
    c5b0:	8a 81       	ldd	r24, Y+2	; 0x02
    c5b2:	9b 81       	ldd	r25, Y+3	; 0x03
    c5b4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c5b8:	6b 01       	movw	r12, r22
    c5ba:	7c 01       	movw	r14, r24
    c5bc:	f8 01       	movw	r30, r16
    c5be:	20 81       	ld	r18, Z
    c5c0:	31 81       	ldd	r19, Z+1	; 0x01
    c5c2:	42 81       	ldd	r20, Z+2	; 0x02
    c5c4:	53 81       	ldd	r21, Z+3	; 0x03
    c5c6:	6c 81       	ldd	r22, Y+4	; 0x04
    c5c8:	7d 81       	ldd	r23, Y+5	; 0x05
    c5ca:	8e 81       	ldd	r24, Y+6	; 0x06
    c5cc:	9f 81       	ldd	r25, Y+7	; 0x07
    c5ce:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c5d2:	9b 01       	movw	r18, r22
    c5d4:	ac 01       	movw	r20, r24
    c5d6:	c7 01       	movw	r24, r14
    c5d8:	b6 01       	movw	r22, r12
    c5da:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    c5de:	f5 01       	movw	r30, r10
    c5e0:	60 87       	std	Z+8, r22	; 0x08
    c5e2:	71 87       	std	Z+9, r23	; 0x09
    c5e4:	82 87       	std	Z+10, r24	; 0x0a
    c5e6:	93 87       	std	Z+11, r25	; 0x0b
}
    c5e8:	df 91       	pop	r29
    c5ea:	cf 91       	pop	r28
    c5ec:	1f 91       	pop	r17
    c5ee:	0f 91       	pop	r16
    c5f0:	ff 90       	pop	r15
    c5f2:	ef 90       	pop	r14
    c5f4:	df 90       	pop	r13
    c5f6:	cf 90       	pop	r12
    c5f8:	bf 90       	pop	r11
    c5fa:	af 90       	pop	r10
    c5fc:	08 95       	ret

0000c5fe <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>:

void MatrixUtil::Normalize(float (&vector)[3])
{
    c5fe:	4f 92       	push	r4
    c600:	5f 92       	push	r5
    c602:	6f 92       	push	r6
    c604:	7f 92       	push	r7
    c606:	8f 92       	push	r8
    c608:	9f 92       	push	r9
    c60a:	af 92       	push	r10
    c60c:	bf 92       	push	r11
    c60e:	cf 92       	push	r12
    c610:	df 92       	push	r13
    c612:	ef 92       	push	r14
    c614:	ff 92       	push	r15
    c616:	0f 93       	push	r16
    c618:	1f 93       	push	r17
    c61a:	cf 93       	push	r28
    c61c:	df 93       	push	r29
    c61e:	00 d0       	rcall	.+0      	; 0xc620 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f+0x22>
    c620:	1f 92       	push	r1
    c622:	cd b7       	in	r28, 0x3d	; 61
    c624:	de b7       	in	r29, 0x3e	; 62
    c626:	8c 01       	movw	r16, r24
	float magnitude = 0;
	
	//Square each vector value and add it to the magnitude
	for (int i = 0; i < 3; i++)
	{
		magnitude += vector[i] * vector[i];
    c628:	dc 01       	movw	r26, r24
    c62a:	4d 90       	ld	r4, X+
    c62c:	5d 90       	ld	r5, X+
    c62e:	6d 90       	ld	r6, X+
    c630:	7c 90       	ld	r7, X
    c632:	a3 01       	movw	r20, r6
    c634:	92 01       	movw	r18, r4
    c636:	c3 01       	movw	r24, r6
    c638:	b2 01       	movw	r22, r4
    c63a:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c63e:	20 e0       	ldi	r18, 0x00	; 0
    c640:	30 e0       	ldi	r19, 0x00	; 0
    c642:	a9 01       	movw	r20, r18
    c644:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    c648:	6b 01       	movw	r12, r22
    c64a:	7c 01       	movw	r14, r24
    c64c:	f8 01       	movw	r30, r16
    c64e:	84 80       	ldd	r8, Z+4	; 0x04
    c650:	95 80       	ldd	r9, Z+5	; 0x05
    c652:	a6 80       	ldd	r10, Z+6	; 0x06
    c654:	b7 80       	ldd	r11, Z+7	; 0x07
    c656:	a5 01       	movw	r20, r10
    c658:	94 01       	movw	r18, r8
    c65a:	c5 01       	movw	r24, r10
    c65c:	b4 01       	movw	r22, r8
    c65e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c662:	9b 01       	movw	r18, r22
    c664:	ac 01       	movw	r20, r24
    c666:	c7 01       	movw	r24, r14
    c668:	b6 01       	movw	r22, r12
    c66a:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    c66e:	6b 01       	movw	r12, r22
    c670:	7c 01       	movw	r14, r24
    c672:	d8 01       	movw	r26, r16
    c674:	18 96       	adiw	r26, 0x08	; 8
    c676:	8d 91       	ld	r24, X+
    c678:	9d 91       	ld	r25, X+
    c67a:	0d 90       	ld	r0, X+
    c67c:	bc 91       	ld	r27, X
    c67e:	a0 2d       	mov	r26, r0
    c680:	89 83       	std	Y+1, r24	; 0x01
    c682:	9a 83       	std	Y+2, r25	; 0x02
    c684:	ab 83       	std	Y+3, r26	; 0x03
    c686:	bc 83       	std	Y+4, r27	; 0x04
    c688:	9c 01       	movw	r18, r24
    c68a:	ad 01       	movw	r20, r26
    c68c:	bc 01       	movw	r22, r24
    c68e:	cd 01       	movw	r24, r26
    c690:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c694:	a7 01       	movw	r20, r14
    c696:	96 01       	movw	r18, r12
    c698:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
	}
	
	magnitude = sqrt(magnitude);
    c69c:	0e 94 d6 6a 	call	0xd5ac	; 0xd5ac <sqrt>
    c6a0:	6b 01       	movw	r12, r22
    c6a2:	7c 01       	movw	r14, r24
	
	for (int i = 0; i < 3; i++)
	{
		vector[i] = vector[i] / magnitude;
    c6a4:	9b 01       	movw	r18, r22
    c6a6:	ac 01       	movw	r20, r24
    c6a8:	c3 01       	movw	r24, r6
    c6aa:	b2 01       	movw	r22, r4
    c6ac:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    c6b0:	f8 01       	movw	r30, r16
    c6b2:	60 83       	st	Z, r22
    c6b4:	71 83       	std	Z+1, r23	; 0x01
    c6b6:	82 83       	std	Z+2, r24	; 0x02
    c6b8:	93 83       	std	Z+3, r25	; 0x03
    c6ba:	a7 01       	movw	r20, r14
    c6bc:	96 01       	movw	r18, r12
    c6be:	c5 01       	movw	r24, r10
    c6c0:	b4 01       	movw	r22, r8
    c6c2:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    c6c6:	d8 01       	movw	r26, r16
    c6c8:	14 96       	adiw	r26, 0x04	; 4
    c6ca:	6d 93       	st	X+, r22
    c6cc:	7d 93       	st	X+, r23
    c6ce:	8d 93       	st	X+, r24
    c6d0:	9c 93       	st	X, r25
    c6d2:	17 97       	sbiw	r26, 0x07	; 7
    c6d4:	a7 01       	movw	r20, r14
    c6d6:	96 01       	movw	r18, r12
    c6d8:	69 81       	ldd	r22, Y+1	; 0x01
    c6da:	7a 81       	ldd	r23, Y+2	; 0x02
    c6dc:	8b 81       	ldd	r24, Y+3	; 0x03
    c6de:	9c 81       	ldd	r25, Y+4	; 0x04
    c6e0:	0e 94 9f 67 	call	0xcf3e	; 0xcf3e <__divsf3>
    c6e4:	f8 01       	movw	r30, r16
    c6e6:	60 87       	std	Z+8, r22	; 0x08
    c6e8:	71 87       	std	Z+9, r23	; 0x09
    c6ea:	82 87       	std	Z+10, r24	; 0x0a
    c6ec:	93 87       	std	Z+11, r25	; 0x0b
	}
}
    c6ee:	0f 90       	pop	r0
    c6f0:	0f 90       	pop	r0
    c6f2:	0f 90       	pop	r0
    c6f4:	0f 90       	pop	r0
    c6f6:	df 91       	pop	r29
    c6f8:	cf 91       	pop	r28
    c6fa:	1f 91       	pop	r17
    c6fc:	0f 91       	pop	r16
    c6fe:	ff 90       	pop	r15
    c700:	ef 90       	pop	r14
    c702:	df 90       	pop	r13
    c704:	cf 90       	pop	r12
    c706:	bf 90       	pop	r11
    c708:	af 90       	pop	r10
    c70a:	9f 90       	pop	r9
    c70c:	8f 90       	pop	r8
    c70e:	7f 90       	pop	r7
    c710:	6f 90       	pop	r6
    c712:	5f 90       	pop	r5
    c714:	4f 90       	pop	r4
    c716:	08 95       	ret

0000c718 <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>:
		}
	}
}

void MatrixUtil::CreateRotationMatrix( float phiRotationAboutXRads, float thetaRotationAboutYRads, float saiRotationAboutZRads, float (&rotationMatrix)[3][3] )
{
    c718:	4f 92       	push	r4
    c71a:	5f 92       	push	r5
    c71c:	6f 92       	push	r6
    c71e:	7f 92       	push	r7
    c720:	8f 92       	push	r8
    c722:	9f 92       	push	r9
    c724:	af 92       	push	r10
    c726:	bf 92       	push	r11
    c728:	cf 92       	push	r12
    c72a:	df 92       	push	r13
    c72c:	ef 92       	push	r14
    c72e:	ff 92       	push	r15
    c730:	0f 93       	push	r16
    c732:	1f 93       	push	r17
    c734:	cf 93       	push	r28
    c736:	df 93       	push	r29
    c738:	cd b7       	in	r28, 0x3d	; 61
    c73a:	de b7       	in	r29, 0x3e	; 62
    c73c:	68 97       	sbiw	r28, 0x18	; 24
    c73e:	0f b6       	in	r0, 0x3f	; 63
    c740:	f8 94       	cli
    c742:	de bf       	out	0x3e, r29	; 62
    c744:	0f be       	out	0x3f, r0	; 63
    c746:	cd bf       	out	0x3d, r28	; 61
    c748:	4b 01       	movw	r8, r22
    c74a:	5c 01       	movw	r10, r24
    c74c:	29 01       	movw	r4, r18
    c74e:	3a 01       	movw	r6, r20
    c750:	e9 82       	std	Y+1, r14	; 0x01
    c752:	fa 82       	std	Y+2, r15	; 0x02
    c754:	0b 83       	std	Y+3, r16	; 0x03
    c756:	1c 83       	std	Y+4, r17	; 0x04
    c758:	86 01       	movw	r16, r12
	rotationMatrix[2][1] = sin(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	rotationMatrix[2][2] = cos(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	*/
	
	
	float sinSai = sin(saiRotationAboutZRads);
    c75a:	69 81       	ldd	r22, Y+1	; 0x01
    c75c:	7a 81       	ldd	r23, Y+2	; 0x02
    c75e:	8b 81       	ldd	r24, Y+3	; 0x03
    c760:	9c 81       	ldd	r25, Y+4	; 0x04
    c762:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c766:	6d 83       	std	Y+5, r22	; 0x05
    c768:	7e 83       	std	Y+6, r23	; 0x06
    c76a:	8f 83       	std	Y+7, r24	; 0x07
    c76c:	98 87       	std	Y+8, r25	; 0x08
	float sinTheta = sin(thetaRotationAboutYRads);
    c76e:	c3 01       	movw	r24, r6
    c770:	b2 01       	movw	r22, r4
    c772:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c776:	6d 87       	std	Y+13, r22	; 0x0d
    c778:	7e 87       	std	Y+14, r23	; 0x0e
    c77a:	8f 87       	std	Y+15, r24	; 0x0f
    c77c:	98 8b       	std	Y+16, r25	; 0x10
	float sinPhi = sin(phiRotationAboutXRads);
    c77e:	c5 01       	movw	r24, r10
    c780:	b4 01       	movw	r22, r8
    c782:	0e 94 cc 6a 	call	0xd598	; 0xd598 <sin>
    c786:	69 87       	std	Y+9, r22	; 0x09
    c788:	7a 87       	std	Y+10, r23	; 0x0a
    c78a:	8b 87       	std	Y+11, r24	; 0x0b
    c78c:	9c 87       	std	Y+12, r25	; 0x0c
	
	float cosSai = cos(saiRotationAboutZRads);
    c78e:	69 81       	ldd	r22, Y+1	; 0x01
    c790:	7a 81       	ldd	r23, Y+2	; 0x02
    c792:	8b 81       	ldd	r24, Y+3	; 0x03
    c794:	9c 81       	ldd	r25, Y+4	; 0x04
    c796:	0e 94 9c 67 	call	0xcf38	; 0xcf38 <cos>
    c79a:	6b 01       	movw	r12, r22
    c79c:	7c 01       	movw	r14, r24
	float cosTheta = cos(thetaRotationAboutYRads);
    c79e:	c3 01       	movw	r24, r6
    c7a0:	b2 01       	movw	r22, r4
    c7a2:	0e 94 9c 67 	call	0xcf38	; 0xcf38 <cos>
    c7a6:	69 83       	std	Y+1, r22	; 0x01
    c7a8:	7a 83       	std	Y+2, r23	; 0x02
    c7aa:	8b 83       	std	Y+3, r24	; 0x03
    c7ac:	9c 83       	std	Y+4, r25	; 0x04
	float cosPhi = cos(phiRotationAboutXRads);	
    c7ae:	c5 01       	movw	r24, r10
    c7b0:	b4 01       	movw	r22, r8
    c7b2:	0e 94 9c 67 	call	0xcf38	; 0xcf38 <cos>
    c7b6:	4b 01       	movw	r8, r22
    c7b8:	5c 01       	movw	r10, r24
	float cosTheta = fcos(thetaRotationAboutYRads);
	float cosPhi = fcos(phiRotationAboutXRads);
*/
	
	
	rotationMatrix[0][0] = cosTheta*cosSai;
    c7ba:	a7 01       	movw	r20, r14
    c7bc:	96 01       	movw	r18, r12
    c7be:	69 81       	ldd	r22, Y+1	; 0x01
    c7c0:	7a 81       	ldd	r23, Y+2	; 0x02
    c7c2:	8b 81       	ldd	r24, Y+3	; 0x03
    c7c4:	9c 81       	ldd	r25, Y+4	; 0x04
    c7c6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c7ca:	f8 01       	movw	r30, r16
    c7cc:	60 83       	st	Z, r22
    c7ce:	71 83       	std	Z+1, r23	; 0x01
    c7d0:	82 83       	std	Z+2, r24	; 0x02
    c7d2:	93 83       	std	Z+3, r25	; 0x03
	rotationMatrix[0][1] = sinPhi*sinTheta*cosSai - cosPhi*sinSai;
    c7d4:	2d 85       	ldd	r18, Y+13	; 0x0d
    c7d6:	3e 85       	ldd	r19, Y+14	; 0x0e
    c7d8:	4f 85       	ldd	r20, Y+15	; 0x0f
    c7da:	58 89       	ldd	r21, Y+16	; 0x10
    c7dc:	69 85       	ldd	r22, Y+9	; 0x09
    c7de:	7a 85       	ldd	r23, Y+10	; 0x0a
    c7e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    c7e2:	9c 85       	ldd	r25, Y+12	; 0x0c
    c7e4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c7e8:	69 8b       	std	Y+17, r22	; 0x11
    c7ea:	7a 8b       	std	Y+18, r23	; 0x12
    c7ec:	8b 8b       	std	Y+19, r24	; 0x13
    c7ee:	9c 8b       	std	Y+20, r25	; 0x14
    c7f0:	a7 01       	movw	r20, r14
    c7f2:	96 01       	movw	r18, r12
    c7f4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c7f8:	2b 01       	movw	r4, r22
    c7fa:	3c 01       	movw	r6, r24
    c7fc:	2d 81       	ldd	r18, Y+5	; 0x05
    c7fe:	3e 81       	ldd	r19, Y+6	; 0x06
    c800:	4f 81       	ldd	r20, Y+7	; 0x07
    c802:	58 85       	ldd	r21, Y+8	; 0x08
    c804:	c5 01       	movw	r24, r10
    c806:	b4 01       	movw	r22, r8
    c808:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c80c:	9b 01       	movw	r18, r22
    c80e:	ac 01       	movw	r20, r24
    c810:	c3 01       	movw	r24, r6
    c812:	b2 01       	movw	r22, r4
    c814:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    c818:	f8 01       	movw	r30, r16
    c81a:	64 83       	std	Z+4, r22	; 0x04
    c81c:	75 83       	std	Z+5, r23	; 0x05
    c81e:	86 83       	std	Z+6, r24	; 0x06
    c820:	97 83       	std	Z+7, r25	; 0x07
	rotationMatrix[0][2] = cosPhi*sinTheta*cosSai + sinPhi*sinSai;
    c822:	2d 85       	ldd	r18, Y+13	; 0x0d
    c824:	3e 85       	ldd	r19, Y+14	; 0x0e
    c826:	4f 85       	ldd	r20, Y+15	; 0x0f
    c828:	58 89       	ldd	r21, Y+16	; 0x10
    c82a:	c5 01       	movw	r24, r10
    c82c:	b4 01       	movw	r22, r8
    c82e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c832:	6d 8b       	std	Y+21, r22	; 0x15
    c834:	7e 8b       	std	Y+22, r23	; 0x16
    c836:	8f 8b       	std	Y+23, r24	; 0x17
    c838:	98 8f       	std	Y+24, r25	; 0x18
    c83a:	a7 01       	movw	r20, r14
    c83c:	96 01       	movw	r18, r12
    c83e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c842:	2b 01       	movw	r4, r22
    c844:	3c 01       	movw	r6, r24
    c846:	2d 81       	ldd	r18, Y+5	; 0x05
    c848:	3e 81       	ldd	r19, Y+6	; 0x06
    c84a:	4f 81       	ldd	r20, Y+7	; 0x07
    c84c:	58 85       	ldd	r21, Y+8	; 0x08
    c84e:	69 85       	ldd	r22, Y+9	; 0x09
    c850:	7a 85       	ldd	r23, Y+10	; 0x0a
    c852:	8b 85       	ldd	r24, Y+11	; 0x0b
    c854:	9c 85       	ldd	r25, Y+12	; 0x0c
    c856:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c85a:	9b 01       	movw	r18, r22
    c85c:	ac 01       	movw	r20, r24
    c85e:	c3 01       	movw	r24, r6
    c860:	b2 01       	movw	r22, r4
    c862:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    c866:	f8 01       	movw	r30, r16
    c868:	60 87       	std	Z+8, r22	; 0x08
    c86a:	71 87       	std	Z+9, r23	; 0x09
    c86c:	82 87       	std	Z+10, r24	; 0x0a
    c86e:	93 87       	std	Z+11, r25	; 0x0b
	rotationMatrix[1][0] = cosTheta*sinSai;
    c870:	2d 81       	ldd	r18, Y+5	; 0x05
    c872:	3e 81       	ldd	r19, Y+6	; 0x06
    c874:	4f 81       	ldd	r20, Y+7	; 0x07
    c876:	58 85       	ldd	r21, Y+8	; 0x08
    c878:	69 81       	ldd	r22, Y+1	; 0x01
    c87a:	7a 81       	ldd	r23, Y+2	; 0x02
    c87c:	8b 81       	ldd	r24, Y+3	; 0x03
    c87e:	9c 81       	ldd	r25, Y+4	; 0x04
    c880:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c884:	f8 01       	movw	r30, r16
    c886:	64 87       	std	Z+12, r22	; 0x0c
    c888:	75 87       	std	Z+13, r23	; 0x0d
    c88a:	86 87       	std	Z+14, r24	; 0x0e
    c88c:	97 87       	std	Z+15, r25	; 0x0f
	rotationMatrix[1][1] = sinPhi*sinTheta*sinSai + cosPhi*cosSai;
    c88e:	29 89       	ldd	r18, Y+17	; 0x11
    c890:	3a 89       	ldd	r19, Y+18	; 0x12
    c892:	4b 89       	ldd	r20, Y+19	; 0x13
    c894:	5c 89       	ldd	r21, Y+20	; 0x14
    c896:	6d 81       	ldd	r22, Y+5	; 0x05
    c898:	7e 81       	ldd	r23, Y+6	; 0x06
    c89a:	8f 81       	ldd	r24, Y+7	; 0x07
    c89c:	98 85       	ldd	r25, Y+8	; 0x08
    c89e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c8a2:	2b 01       	movw	r4, r22
    c8a4:	3c 01       	movw	r6, r24
    c8a6:	a7 01       	movw	r20, r14
    c8a8:	96 01       	movw	r18, r12
    c8aa:	c5 01       	movw	r24, r10
    c8ac:	b4 01       	movw	r22, r8
    c8ae:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c8b2:	9b 01       	movw	r18, r22
    c8b4:	ac 01       	movw	r20, r24
    c8b6:	c3 01       	movw	r24, r6
    c8b8:	b2 01       	movw	r22, r4
    c8ba:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    c8be:	f8 01       	movw	r30, r16
    c8c0:	60 8b       	std	Z+16, r22	; 0x10
    c8c2:	71 8b       	std	Z+17, r23	; 0x11
    c8c4:	82 8b       	std	Z+18, r24	; 0x12
    c8c6:	93 8b       	std	Z+19, r25	; 0x13
	rotationMatrix[1][2] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
    c8c8:	2d 89       	ldd	r18, Y+21	; 0x15
    c8ca:	3e 89       	ldd	r19, Y+22	; 0x16
    c8cc:	4f 89       	ldd	r20, Y+23	; 0x17
    c8ce:	58 8d       	ldd	r21, Y+24	; 0x18
    c8d0:	6d 81       	ldd	r22, Y+5	; 0x05
    c8d2:	7e 81       	ldd	r23, Y+6	; 0x06
    c8d4:	8f 81       	ldd	r24, Y+7	; 0x07
    c8d6:	98 85       	ldd	r25, Y+8	; 0x08
    c8d8:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c8dc:	2b 01       	movw	r4, r22
    c8de:	3c 01       	movw	r6, r24
    c8e0:	a7 01       	movw	r20, r14
    c8e2:	96 01       	movw	r18, r12
    c8e4:	69 85       	ldd	r22, Y+9	; 0x09
    c8e6:	7a 85       	ldd	r23, Y+10	; 0x0a
    c8e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    c8ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    c8ec:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c8f0:	9b 01       	movw	r18, r22
    c8f2:	ac 01       	movw	r20, r24
    c8f4:	c3 01       	movw	r24, r6
    c8f6:	b2 01       	movw	r22, r4
    c8f8:	0e 94 ba 66 	call	0xcd74	; 0xcd74 <__subsf3>
    c8fc:	f8 01       	movw	r30, r16
    c8fe:	64 8b       	std	Z+20, r22	; 0x14
    c900:	75 8b       	std	Z+21, r23	; 0x15
    c902:	86 8b       	std	Z+22, r24	; 0x16
    c904:	97 8b       	std	Z+23, r25	; 0x17
	rotationMatrix[2][0] = -sinTheta;
    c906:	8d 85       	ldd	r24, Y+13	; 0x0d
    c908:	9e 85       	ldd	r25, Y+14	; 0x0e
    c90a:	af 85       	ldd	r26, Y+15	; 0x0f
    c90c:	b8 89       	ldd	r27, Y+16	; 0x10
    c90e:	b0 58       	subi	r27, 0x80	; 128
    c910:	80 8f       	std	Z+24, r24	; 0x18
    c912:	91 8f       	std	Z+25, r25	; 0x19
    c914:	a2 8f       	std	Z+26, r26	; 0x1a
    c916:	b3 8f       	std	Z+27, r27	; 0x1b
	rotationMatrix[2][1] = sinPhi*cosTheta;
    c918:	29 81       	ldd	r18, Y+1	; 0x01
    c91a:	3a 81       	ldd	r19, Y+2	; 0x02
    c91c:	4b 81       	ldd	r20, Y+3	; 0x03
    c91e:	5c 81       	ldd	r21, Y+4	; 0x04
    c920:	69 85       	ldd	r22, Y+9	; 0x09
    c922:	7a 85       	ldd	r23, Y+10	; 0x0a
    c924:	8b 85       	ldd	r24, Y+11	; 0x0b
    c926:	9c 85       	ldd	r25, Y+12	; 0x0c
    c928:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c92c:	f8 01       	movw	r30, r16
    c92e:	64 8f       	std	Z+28, r22	; 0x1c
    c930:	75 8f       	std	Z+29, r23	; 0x1d
    c932:	86 8f       	std	Z+30, r24	; 0x1e
    c934:	97 8f       	std	Z+31, r25	; 0x1f
	rotationMatrix[2][2] = cosPhi*cosTheta;
    c936:	29 81       	ldd	r18, Y+1	; 0x01
    c938:	3a 81       	ldd	r19, Y+2	; 0x02
    c93a:	4b 81       	ldd	r20, Y+3	; 0x03
    c93c:	5c 81       	ldd	r21, Y+4	; 0x04
    c93e:	c5 01       	movw	r24, r10
    c940:	b4 01       	movw	r22, r8
    c942:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c946:	f8 01       	movw	r30, r16
    c948:	60 a3       	std	Z+32, r22	; 0x20
    c94a:	71 a3       	std	Z+33, r23	; 0x21
    c94c:	82 a3       	std	Z+34, r24	; 0x22
    c94e:	93 a3       	std	Z+35, r25	; 0x23
}
    c950:	68 96       	adiw	r28, 0x18	; 24
    c952:	0f b6       	in	r0, 0x3f	; 63
    c954:	f8 94       	cli
    c956:	de bf       	out	0x3e, r29	; 62
    c958:	0f be       	out	0x3f, r0	; 63
    c95a:	cd bf       	out	0x3d, r28	; 61
    c95c:	df 91       	pop	r29
    c95e:	cf 91       	pop	r28
    c960:	1f 91       	pop	r17
    c962:	0f 91       	pop	r16
    c964:	ff 90       	pop	r15
    c966:	ef 90       	pop	r14
    c968:	df 90       	pop	r13
    c96a:	cf 90       	pop	r12
    c96c:	bf 90       	pop	r11
    c96e:	af 90       	pop	r10
    c970:	9f 90       	pop	r9
    c972:	8f 90       	pop	r8
    c974:	7f 90       	pop	r7
    c976:	6f 90       	pop	r6
    c978:	5f 90       	pop	r5
    c97a:	4f 90       	pop	r4
    c97c:	08 95       	ret

0000c97e <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>:
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    c97e:	4f 92       	push	r4
    c980:	5f 92       	push	r5
    c982:	6f 92       	push	r6
    c984:	7f 92       	push	r7
    c986:	8f 92       	push	r8
    c988:	9f 92       	push	r9
    c98a:	af 92       	push	r10
    c98c:	bf 92       	push	r11
    c98e:	cf 92       	push	r12
    c990:	df 92       	push	r13
    c992:	ef 92       	push	r14
    c994:	ff 92       	push	r15
    c996:	0f 93       	push	r16
    c998:	1f 93       	push	r17
    c99a:	cf 93       	push	r28
    c99c:	df 93       	push	r29
    c99e:	4c 01       	movw	r8, r24
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    c9a0:	8c e0       	ldi	r24, 0x0C	; 12
    c9a2:	fa 01       	movw	r30, r20
    c9a4:	11 92       	st	Z+, r1
    c9a6:	8a 95       	dec	r24
    c9a8:	e9 f7       	brne	.-6      	; 0xc9a4 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x26>
    c9aa:	7a 01       	movw	r14, r20
    c9ac:	c1 2c       	mov	r12, r1
    c9ae:	d1 2c       	mov	r13, r1
    c9b0:	46 2e       	mov	r4, r22
    c9b2:	57 2e       	mov	r5, r23
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    c9b4:	61 2c       	mov	r6, r1
    c9b6:	71 2c       	mov	r7, r1
    c9b8:	2b c0       	rjmp	.+86     	; 0xca10 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x92>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
    c9ba:	f8 01       	movw	r30, r16
    c9bc:	61 91       	ld	r22, Z+
    c9be:	71 91       	ld	r23, Z+
    c9c0:	81 91       	ld	r24, Z+
    c9c2:	91 91       	ld	r25, Z+
    c9c4:	8f 01       	movw	r16, r30
    c9c6:	f5 01       	movw	r30, r10
    c9c8:	ec 0f       	add	r30, r28
    c9ca:	fd 1f       	adc	r31, r29
    c9cc:	20 81       	ld	r18, Z
    c9ce:	31 81       	ldd	r19, Z+1	; 0x01
    c9d0:	42 81       	ldd	r20, Z+2	; 0x02
    c9d2:	53 81       	ldd	r21, Z+3	; 0x03
    c9d4:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    c9d8:	9b 01       	movw	r18, r22
    c9da:	ac 01       	movw	r20, r24
    c9dc:	f7 01       	movw	r30, r14
    c9de:	60 81       	ld	r22, Z
    c9e0:	71 81       	ldd	r23, Z+1	; 0x01
    c9e2:	82 81       	ldd	r24, Z+2	; 0x02
    c9e4:	93 81       	ldd	r25, Z+3	; 0x03
    c9e6:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    c9ea:	f7 01       	movw	r30, r14
    c9ec:	60 83       	st	Z, r22
    c9ee:	71 83       	std	Z+1, r23	; 0x01
    c9f0:	82 83       	std	Z+2, r24	; 0x02
    c9f2:	93 83       	std	Z+3, r25	; 0x03
    c9f4:	2c 96       	adiw	r28, 0x0c	; 12
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    c9f6:	c4 32       	cpi	r28, 0x24	; 36
    c9f8:	d1 05       	cpc	r29, r1
    c9fa:	f9 f6       	brne	.-66     	; 0xc9ba <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x3c>
    c9fc:	f4 e0       	ldi	r31, 0x04	; 4
    c9fe:	cf 0e       	add	r12, r31
    ca00:	d1 1c       	adc	r13, r1
    ca02:	84 e0       	ldi	r24, 0x04	; 4
    ca04:	e8 0e       	add	r14, r24
    ca06:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    ca08:	ec e0       	ldi	r30, 0x0C	; 12
    ca0a:	ce 16       	cp	r12, r30
    ca0c:	d1 04       	cpc	r13, r1
    ca0e:	41 f0       	breq	.+16     	; 0xca20 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0xa2>
    ca10:	04 2d       	mov	r16, r4
    ca12:	15 2d       	mov	r17, r5
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    ca14:	c6 2d       	mov	r28, r6
    ca16:	d7 2d       	mov	r29, r7
    ca18:	54 01       	movw	r10, r8
    ca1a:	ac 0c       	add	r10, r12
    ca1c:	bd 1c       	adc	r11, r13
    ca1e:	cd cf       	rjmp	.-102    	; 0xc9ba <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x3c>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}
    ca20:	df 91       	pop	r29
    ca22:	cf 91       	pop	r28
    ca24:	1f 91       	pop	r17
    ca26:	0f 91       	pop	r16
    ca28:	ff 90       	pop	r15
    ca2a:	ef 90       	pop	r14
    ca2c:	df 90       	pop	r13
    ca2e:	cf 90       	pop	r12
    ca30:	bf 90       	pop	r11
    ca32:	af 90       	pop	r10
    ca34:	9f 90       	pop	r9
    ca36:	8f 90       	pop	r8
    ca38:	7f 90       	pop	r7
    ca3a:	6f 90       	pop	r6
    ca3c:	5f 90       	pop	r5
    ca3e:	4f 90       	pop	r4
    ca40:	08 95       	ret

0000ca42 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
{
    ca42:	2f 92       	push	r2
    ca44:	3f 92       	push	r3
    ca46:	4f 92       	push	r4
    ca48:	5f 92       	push	r5
    ca4a:	6f 92       	push	r6
    ca4c:	7f 92       	push	r7
    ca4e:	8f 92       	push	r8
    ca50:	9f 92       	push	r9
    ca52:	af 92       	push	r10
    ca54:	bf 92       	push	r11
    ca56:	cf 92       	push	r12
    ca58:	df 92       	push	r13
    ca5a:	ef 92       	push	r14
    ca5c:	ff 92       	push	r15
    ca5e:	0f 93       	push	r16
    ca60:	1f 93       	push	r17
    ca62:	cf 93       	push	r28
    ca64:	df 93       	push	r29
    ca66:	4c 01       	movw	r8, r24
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    ca68:	8c e0       	ldi	r24, 0x0C	; 12
    ca6a:	fa 01       	movw	r30, r20
    ca6c:	11 92       	st	Z+, r1
    ca6e:	8a 95       	dec	r24
    ca70:	e9 f7       	brne	.-6      	; 0xca6c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x2a>
    ca72:	7a 01       	movw	r14, r20
    ca74:	a1 2c       	mov	r10, r1
    ca76:	b1 2c       	mov	r11, r1
    ca78:	36 2e       	mov	r3, r22
    ca7a:	27 2e       	mov	r2, r23
    ca7c:	32 c0       	rjmp	.+100    	; 0xcae2 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xa0>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    ca7e:	f6 01       	movw	r30, r12
    ca80:	41 90       	ld	r4, Z+
    ca82:	51 90       	ld	r5, Z+
    ca84:	61 90       	ld	r6, Z+
    ca86:	71 90       	ld	r7, Z+
    ca88:	6f 01       	movw	r12, r30
    ca8a:	f8 01       	movw	r30, r16
    ca8c:	61 91       	ld	r22, Z+
    ca8e:	71 91       	ld	r23, Z+
    ca90:	8f 01       	movw	r16, r30
    ca92:	88 27       	eor	r24, r24
    ca94:	77 fd       	sbrc	r23, 7
    ca96:	80 95       	com	r24
    ca98:	98 2f       	mov	r25, r24
    ca9a:	0e 94 3a 68 	call	0xd074	; 0xd074 <__floatsisf>
    ca9e:	9b 01       	movw	r18, r22
    caa0:	ac 01       	movw	r20, r24
    caa2:	c3 01       	movw	r24, r6
    caa4:	b2 01       	movw	r22, r4
    caa6:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    caaa:	9b 01       	movw	r18, r22
    caac:	ac 01       	movw	r20, r24
    caae:	f7 01       	movw	r30, r14
    cab0:	60 81       	ld	r22, Z
    cab2:	71 81       	ldd	r23, Z+1	; 0x01
    cab4:	82 81       	ldd	r24, Z+2	; 0x02
    cab6:	93 81       	ldd	r25, Z+3	; 0x03
    cab8:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    cabc:	f7 01       	movw	r30, r14
    cabe:	60 83       	st	Z, r22
    cac0:	71 83       	std	Z+1, r23	; 0x01
    cac2:	82 83       	std	Z+2, r24	; 0x02
    cac4:	93 83       	std	Z+3, r25	; 0x03
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    cac6:	21 96       	adiw	r28, 0x01	; 1
    cac8:	c3 30       	cpi	r28, 0x03	; 3
    caca:	d1 05       	cpc	r29, r1
    cacc:	c1 f6       	brne	.-80     	; 0xca7e <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x3c>
    cace:	fc e0       	ldi	r31, 0x0C	; 12
    cad0:	af 0e       	add	r10, r31
    cad2:	b1 1c       	adc	r11, r1
    cad4:	84 e0       	ldi	r24, 0x04	; 4
    cad6:	e8 0e       	add	r14, r24
    cad8:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    cada:	e4 e2       	ldi	r30, 0x24	; 36
    cadc:	ae 16       	cp	r10, r30
    cade:	b1 04       	cpc	r11, r1
    cae0:	51 f0       	breq	.+20     	; 0xcaf6 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xb4>
    cae2:	03 2d       	mov	r16, r3
    cae4:	12 2d       	mov	r17, r2
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
{
    cae6:	64 01       	movw	r12, r8
    cae8:	ca 0c       	add	r12, r10
    caea:	db 1c       	adc	r13, r11
    caec:	f0 e0       	ldi	r31, 0x00	; 0
    caee:	cf 2f       	mov	r28, r31
    caf0:	80 e0       	ldi	r24, 0x00	; 0
    caf2:	d8 2f       	mov	r29, r24
    caf4:	c4 cf       	rjmp	.-120    	; 0xca7e <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x3c>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    caf6:	df 91       	pop	r29
    caf8:	cf 91       	pop	r28
    cafa:	1f 91       	pop	r17
    cafc:	0f 91       	pop	r16
    cafe:	ff 90       	pop	r15
    cb00:	ef 90       	pop	r14
    cb02:	df 90       	pop	r13
    cb04:	cf 90       	pop	r12
    cb06:	bf 90       	pop	r11
    cb08:	af 90       	pop	r10
    cb0a:	9f 90       	pop	r9
    cb0c:	8f 90       	pop	r8
    cb0e:	7f 90       	pop	r7
    cb10:	6f 90       	pop	r6
    cb12:	5f 90       	pop	r5
    cb14:	4f 90       	pop	r4
    cb16:	3f 90       	pop	r3
    cb18:	2f 90       	pop	r2
    cb1a:	08 95       	ret

0000cb1c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    cb1c:	4f 92       	push	r4
    cb1e:	5f 92       	push	r5
    cb20:	6f 92       	push	r6
    cb22:	7f 92       	push	r7
    cb24:	8f 92       	push	r8
    cb26:	9f 92       	push	r9
    cb28:	af 92       	push	r10
    cb2a:	bf 92       	push	r11
    cb2c:	cf 92       	push	r12
    cb2e:	df 92       	push	r13
    cb30:	ef 92       	push	r14
    cb32:	ff 92       	push	r15
    cb34:	0f 93       	push	r16
    cb36:	1f 93       	push	r17
    cb38:	cf 93       	push	r28
    cb3a:	df 93       	push	r29
    cb3c:	4c 01       	movw	r8, r24
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    cb3e:	8c e0       	ldi	r24, 0x0C	; 12
    cb40:	fa 01       	movw	r30, r20
    cb42:	11 92       	st	Z+, r1
    cb44:	8a 95       	dec	r24
    cb46:	e9 f7       	brne	.-6      	; 0xcb42 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x26>
    cb48:	7a 01       	movw	r14, r20
    cb4a:	a1 2c       	mov	r10, r1
    cb4c:	b1 2c       	mov	r11, r1
    cb4e:	46 2e       	mov	r4, r22
    cb50:	57 2e       	mov	r5, r23
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    cb52:	61 2c       	mov	r6, r1
    cb54:	71 2c       	mov	r7, r1
    cb56:	2a c0       	rjmp	.+84     	; 0xcbac <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x90>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    cb58:	f6 01       	movw	r30, r12
    cb5a:	61 91       	ld	r22, Z+
    cb5c:	71 91       	ld	r23, Z+
    cb5e:	81 91       	ld	r24, Z+
    cb60:	91 91       	ld	r25, Z+
    cb62:	6f 01       	movw	r12, r30
    cb64:	f8 01       	movw	r30, r16
    cb66:	21 91       	ld	r18, Z+
    cb68:	31 91       	ld	r19, Z+
    cb6a:	41 91       	ld	r20, Z+
    cb6c:	51 91       	ld	r21, Z+
    cb6e:	8f 01       	movw	r16, r30
    cb70:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    cb74:	9b 01       	movw	r18, r22
    cb76:	ac 01       	movw	r20, r24
    cb78:	f7 01       	movw	r30, r14
    cb7a:	60 81       	ld	r22, Z
    cb7c:	71 81       	ldd	r23, Z+1	; 0x01
    cb7e:	82 81       	ldd	r24, Z+2	; 0x02
    cb80:	93 81       	ldd	r25, Z+3	; 0x03
    cb82:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    cb86:	f7 01       	movw	r30, r14
    cb88:	60 83       	st	Z, r22
    cb8a:	71 83       	std	Z+1, r23	; 0x01
    cb8c:	82 83       	std	Z+2, r24	; 0x02
    cb8e:	93 83       	std	Z+3, r25	; 0x03
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    cb90:	21 96       	adiw	r28, 0x01	; 1
    cb92:	c3 30       	cpi	r28, 0x03	; 3
    cb94:	d1 05       	cpc	r29, r1
    cb96:	01 f7       	brne	.-64     	; 0xcb58 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x3c>
    cb98:	fc e0       	ldi	r31, 0x0C	; 12
    cb9a:	af 0e       	add	r10, r31
    cb9c:	b1 1c       	adc	r11, r1
    cb9e:	84 e0       	ldi	r24, 0x04	; 4
    cba0:	e8 0e       	add	r14, r24
    cba2:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    cba4:	e4 e2       	ldi	r30, 0x24	; 36
    cba6:	ae 16       	cp	r10, r30
    cba8:	b1 04       	cpc	r11, r1
    cbaa:	41 f0       	breq	.+16     	; 0xcbbc <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0xa0>
    cbac:	04 2d       	mov	r16, r4
    cbae:	15 2d       	mov	r17, r5
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    cbb0:	64 01       	movw	r12, r8
    cbb2:	ca 0c       	add	r12, r10
    cbb4:	db 1c       	adc	r13, r11
    cbb6:	c6 2d       	mov	r28, r6
    cbb8:	d7 2d       	mov	r29, r7
    cbba:	ce cf       	rjmp	.-100    	; 0xcb58 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x3c>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    cbbc:	df 91       	pop	r29
    cbbe:	cf 91       	pop	r28
    cbc0:	1f 91       	pop	r17
    cbc2:	0f 91       	pop	r16
    cbc4:	ff 90       	pop	r15
    cbc6:	ef 90       	pop	r14
    cbc8:	df 90       	pop	r13
    cbca:	cf 90       	pop	r12
    cbcc:	bf 90       	pop	r11
    cbce:	af 90       	pop	r10
    cbd0:	9f 90       	pop	r9
    cbd2:	8f 90       	pop	r8
    cbd4:	7f 90       	pop	r7
    cbd6:	6f 90       	pop	r6
    cbd8:	5f 90       	pop	r5
    cbda:	4f 90       	pop	r4
    cbdc:	08 95       	ret

0000cbde <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>:
	RotateMatrix(rotationMatrix, valuesToRotate, rotatedValues);
}


float MatrixUtil::DotProduct( float vector1[3], float vector2[3] )
{
    cbde:	cf 92       	push	r12
    cbe0:	df 92       	push	r13
    cbe2:	ef 92       	push	r14
    cbe4:	ff 92       	push	r15
    cbe6:	0f 93       	push	r16
    cbe8:	1f 93       	push	r17
    cbea:	cf 93       	push	r28
    cbec:	df 93       	push	r29
    cbee:	ec 01       	movw	r28, r24
    cbf0:	8b 01       	movw	r16, r22
	return vector1[0]*vector2[0] + vector1[1]*vector2[1] + vector1[2]*vector2[2];
    cbf2:	fb 01       	movw	r30, r22
    cbf4:	20 81       	ld	r18, Z
    cbf6:	31 81       	ldd	r19, Z+1	; 0x01
    cbf8:	42 81       	ldd	r20, Z+2	; 0x02
    cbfa:	53 81       	ldd	r21, Z+3	; 0x03
    cbfc:	68 81       	ld	r22, Y
    cbfe:	79 81       	ldd	r23, Y+1	; 0x01
    cc00:	8a 81       	ldd	r24, Y+2	; 0x02
    cc02:	9b 81       	ldd	r25, Y+3	; 0x03
    cc04:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    cc08:	6b 01       	movw	r12, r22
    cc0a:	7c 01       	movw	r14, r24
    cc0c:	f8 01       	movw	r30, r16
    cc0e:	24 81       	ldd	r18, Z+4	; 0x04
    cc10:	35 81       	ldd	r19, Z+5	; 0x05
    cc12:	46 81       	ldd	r20, Z+6	; 0x06
    cc14:	57 81       	ldd	r21, Z+7	; 0x07
    cc16:	6c 81       	ldd	r22, Y+4	; 0x04
    cc18:	7d 81       	ldd	r23, Y+5	; 0x05
    cc1a:	8e 81       	ldd	r24, Y+6	; 0x06
    cc1c:	9f 81       	ldd	r25, Y+7	; 0x07
    cc1e:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    cc22:	9b 01       	movw	r18, r22
    cc24:	ac 01       	movw	r20, r24
    cc26:	c7 01       	movw	r24, r14
    cc28:	b6 01       	movw	r22, r12
    cc2a:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
    cc2e:	6b 01       	movw	r12, r22
    cc30:	7c 01       	movw	r14, r24
    cc32:	f8 01       	movw	r30, r16
    cc34:	20 85       	ldd	r18, Z+8	; 0x08
    cc36:	31 85       	ldd	r19, Z+9	; 0x09
    cc38:	42 85       	ldd	r20, Z+10	; 0x0a
    cc3a:	53 85       	ldd	r21, Z+11	; 0x0b
    cc3c:	68 85       	ldd	r22, Y+8	; 0x08
    cc3e:	79 85       	ldd	r23, Y+9	; 0x09
    cc40:	8a 85       	ldd	r24, Y+10	; 0x0a
    cc42:	9b 85       	ldd	r25, Y+11	; 0x0b
    cc44:	0e 94 1d 6a 	call	0xd43a	; 0xd43a <__mulsf3>
    cc48:	9b 01       	movw	r18, r22
    cc4a:	ac 01       	movw	r20, r24
    cc4c:	c7 01       	movw	r24, r14
    cc4e:	b6 01       	movw	r22, r12
    cc50:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <__addsf3>
}
    cc54:	df 91       	pop	r29
    cc56:	cf 91       	pop	r28
    cc58:	1f 91       	pop	r17
    cc5a:	0f 91       	pop	r16
    cc5c:	ff 90       	pop	r15
    cc5e:	ef 90       	pop	r14
    cc60:	df 90       	pop	r13
    cc62:	cf 90       	pop	r12
    cc64:	08 95       	ret

0000cc66 <_ZN10helicopter4util5Timer11hasTimedoutEv>:
{
	//Check the Timer Interrupt Flags Register (TIFR) to determine if the flag was set indicating
	//that the timer has timed out.
	//return (TIFR0 & (1<<OCF0A)) != 0;
	
	return timeoutCounter>=numberOfTimeouts;
    cc66:	61 e0       	ldi	r22, 0x01	; 1
    cc68:	fc 01       	movw	r30, r24
    cc6a:	40 85       	ldd	r20, Z+8	; 0x08
    cc6c:	51 85       	ldd	r21, Z+9	; 0x09
    cc6e:	20 91 7a 10 	lds	r18, 0x107A
    cc72:	30 91 7b 10 	lds	r19, 0x107B
    cc76:	24 17       	cp	r18, r20
    cc78:	35 07       	cpc	r19, r21
    cc7a:	0c f4       	brge	.+2      	; 0xcc7e <_ZN10helicopter4util5Timer11hasTimedoutEv+0x18>
    cc7c:	60 e0       	ldi	r22, 0x00	; 0
}
    cc7e:	86 2f       	mov	r24, r22
    cc80:	08 95       	ret

0000cc82 <_ZN10helicopter4util5Timer9stopTimerEv>:

void Timer::stopTimer()
{
	//Disable interrupt.
	TIMSK0 &= ~(1 << OCIE0A);
    cc82:	ee e6       	ldi	r30, 0x6E	; 110
    cc84:	f0 e0       	ldi	r31, 0x00	; 0
    cc86:	80 81       	ld	r24, Z
    cc88:	8d 7f       	andi	r24, 0xFD	; 253
    cc8a:	80 83       	st	Z, r24
	
	//stop the timer
	TCCR0B = 0;
    cc8c:	15 bc       	out	0x25, r1	; 37
	
	//Then clear the timer counter (sets the count back to 0 so when the timer starts again, it starts from 0). 
	//Clear after stopping in order to avoid missing a compare match.
	TCNT0 = 0;
    cc8e:	16 bc       	out	0x26, r1	; 38
	
	//clear the timeout flag.
	TIFR0 |= (1<<OCF0A);
    cc90:	a9 9a       	sbi	0x15, 1	; 21
	
	timeoutCounter = 0;
    cc92:	10 92 7b 10 	sts	0x107B, r1
    cc96:	10 92 7a 10 	sts	0x107A, r1
    cc9a:	08 95       	ret

0000cc9c <_ZN10helicopter4util5Timer10startTimerEv>:

int Timer::timeoutCounter = 0;


void Timer::startTimer()
{
    cc9c:	cf 93       	push	r28
    cc9e:	df 93       	push	r29
    cca0:	ec 01       	movw	r28, r24
	//stop timer in case it was already started.
	stopTimer();
    cca2:	0e 94 41 66 	call	0xcc82	; 0xcc82 <_ZN10helicopter4util5Timer9stopTimerEv>
	//setup timer.
	//set the output compare register so that when the Timer Counter (TCNT) matches this output register
	//it indicates that the timer has timed out.
	OCR0A = ((cpuSpeed /  timerPrescaler) / frequency);
	*/ 
	OCR0A = ((cpuSpeed /  timerPrescaler) / 100); //fire off every 10 ms. 
    cca6:	2c 81       	ldd	r18, Y+4	; 0x04
    cca8:	3d 81       	ldd	r19, Y+5	; 0x05
    ccaa:	44 27       	eor	r20, r20
    ccac:	37 fd       	sbrc	r19, 7
    ccae:	40 95       	com	r20
    ccb0:	54 2f       	mov	r21, r20
    ccb2:	68 81       	ld	r22, Y
    ccb4:	79 81       	ldd	r23, Y+1	; 0x01
    ccb6:	8a 81       	ldd	r24, Y+2	; 0x02
    ccb8:	9b 81       	ldd	r25, Y+3	; 0x03
    ccba:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    ccbe:	ca 01       	movw	r24, r20
    ccc0:	b9 01       	movw	r22, r18
    ccc2:	24 e6       	ldi	r18, 0x64	; 100
    ccc4:	30 e0       	ldi	r19, 0x00	; 0
    ccc6:	40 e0       	ldi	r20, 0x00	; 0
    ccc8:	50 e0       	ldi	r21, 0x00	; 0
    ccca:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__udivmodsi4>
    ccce:	27 bd       	out	0x27, r18	; 39
	timeoutCounter = 0;
    ccd0:	10 92 7b 10 	sts	0x107B, r1
    ccd4:	10 92 7a 10 	sts	0x107A, r1
		
	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
	//note, this is different than the 8 bit timer which sets wgmn1 on tccrna to set CTC.
	TCCR0A |= (1 << WGM01); 
    ccd8:	84 b5       	in	r24, 0x24	; 36
    ccda:	82 60       	ori	r24, 0x02	; 2
    ccdc:	84 bd       	out	0x24, r24	; 36
		
	//TCCR3A |= (1 << WGM31);	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
		
	
	
	TIMSK0 |= (1 << OCIE0A); //enable ctc interrupt for OCR0A
    ccde:	ee e6       	ldi	r30, 0x6E	; 110
    cce0:	f0 e0       	ldi	r31, 0x00	; 0
    cce2:	80 81       	ld	r24, Z
    cce4:	82 60       	ori	r24, 0x02	; 2
    cce6:	80 83       	st	Z, r24
		
		
		
	//Set the Timer Counter Control Register (TCCR) with the appropriate prescaller
	//which causes the timer counter to start (i.e. the timer starts).
	switch(timerPrescaler)
    cce8:	8c 81       	ldd	r24, Y+4	; 0x04
    ccea:	9d 81       	ldd	r25, Y+5	; 0x05
    ccec:	80 34       	cpi	r24, 0x40	; 64
    ccee:	91 05       	cpc	r25, r1
    ccf0:	b9 f0       	breq	.+46     	; 0xcd20 <_ZN10helicopter4util5Timer10startTimerEv+0x84>
    ccf2:	34 f4       	brge	.+12     	; 0xcd00 <_ZN10helicopter4util5Timer10startTimerEv+0x64>
    ccf4:	81 30       	cpi	r24, 0x01	; 1
    ccf6:	91 05       	cpc	r25, r1
    ccf8:	59 f0       	breq	.+22     	; 0xcd10 <_ZN10helicopter4util5Timer10startTimerEv+0x74>
    ccfa:	08 97       	sbiw	r24, 0x08	; 8
    ccfc:	69 f0       	breq	.+26     	; 0xcd18 <_ZN10helicopter4util5Timer10startTimerEv+0x7c>
    ccfe:	1c c0       	rjmp	.+56     	; 0xcd38 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
    cd00:	81 15       	cp	r24, r1
    cd02:	21 e0       	ldi	r18, 0x01	; 1
    cd04:	92 07       	cpc	r25, r18
    cd06:	81 f0       	breq	.+32     	; 0xcd28 <_ZN10helicopter4util5Timer10startTimerEv+0x8c>
    cd08:	81 15       	cp	r24, r1
    cd0a:	94 40       	sbci	r25, 0x04	; 4
    cd0c:	89 f0       	breq	.+34     	; 0xcd30 <_ZN10helicopter4util5Timer10startTimerEv+0x94>
    cd0e:	14 c0       	rjmp	.+40     	; 0xcd38 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
	{
		case NO_PRESCALER:
		TCCR0B |= NoPrescaling;
    cd10:	85 b5       	in	r24, 0x25	; 37
    cd12:	81 60       	ori	r24, 0x01	; 1
    cd14:	85 bd       	out	0x25, r24	; 37
		break;
    cd16:	13 c0       	rjmp	.+38     	; 0xcd3e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_EIGHT:
		TCCR0B |= PrescaleByEight;
    cd18:	85 b5       	in	r24, 0x25	; 37
    cd1a:	82 60       	ori	r24, 0x02	; 2
    cd1c:	85 bd       	out	0x25, r24	; 37
		break;
    cd1e:	0f c0       	rjmp	.+30     	; 0xcd3e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_SIXTYFOUR:
		TCCR0B |= PrescaleBySixtyFour;
    cd20:	85 b5       	in	r24, 0x25	; 37
    cd22:	83 60       	ori	r24, 0x03	; 3
    cd24:	85 bd       	out	0x25, r24	; 37
		break;
    cd26:	0b c0       	rjmp	.+22     	; 0xcd3e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TWOFIFTYSIX:
		TCCR0B |= PrescaleByTwofiftysix;
    cd28:	85 b5       	in	r24, 0x25	; 37
    cd2a:	84 60       	ori	r24, 0x04	; 4
    cd2c:	85 bd       	out	0x25, r24	; 37
		break;
    cd2e:	07 c0       	rjmp	.+14     	; 0xcd3e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TENTWENTYFOUR:
		TCCR0B |= PrescaleByTentwentyfour;
    cd30:	85 b5       	in	r24, 0x25	; 37
    cd32:	85 60       	ori	r24, 0x05	; 5
    cd34:	85 bd       	out	0x25, r24	; 37
		break;
    cd36:	03 c0       	rjmp	.+6      	; 0xcd3e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		default:
		TCCR0B |= NoPrescaling;
    cd38:	85 b5       	in	r24, 0x25	; 37
    cd3a:	81 60       	ori	r24, 0x01	; 1
    cd3c:	85 bd       	out	0x25, r24	; 37
	}
	
	sei();
    cd3e:	78 94       	sei
}
    cd40:	df 91       	pop	r29
    cd42:	cf 91       	pop	r28
    cd44:	08 95       	ret

0000cd46 <__vector_21>:
	
	timeoutCounter = 0;
}

ISR(TIMER0_COMPA_vect)
{
    cd46:	1f 92       	push	r1
    cd48:	0f 92       	push	r0
    cd4a:	0f b6       	in	r0, 0x3f	; 63
    cd4c:	0f 92       	push	r0
    cd4e:	11 24       	eor	r1, r1
    cd50:	8f 93       	push	r24
    cd52:	9f 93       	push	r25
	Timer::timeoutCounter++;
    cd54:	80 91 7a 10 	lds	r24, 0x107A
    cd58:	90 91 7b 10 	lds	r25, 0x107B
    cd5c:	01 96       	adiw	r24, 0x01	; 1
    cd5e:	90 93 7b 10 	sts	0x107B, r25
    cd62:	80 93 7a 10 	sts	0x107A, r24
    cd66:	9f 91       	pop	r25
    cd68:	8f 91       	pop	r24
    cd6a:	0f 90       	pop	r0
    cd6c:	0f be       	out	0x3f, r0	; 63
    cd6e:	0f 90       	pop	r0
    cd70:	1f 90       	pop	r1
    cd72:	18 95       	reti

0000cd74 <__subsf3>:
    cd74:	50 58       	subi	r21, 0x80	; 128

0000cd76 <__addsf3>:
    cd76:	bb 27       	eor	r27, r27
    cd78:	aa 27       	eor	r26, r26
    cd7a:	0e d0       	rcall	.+28     	; 0xcd98 <__addsf3x>
    cd7c:	a6 c2       	rjmp	.+1356   	; 0xd2ca <__fp_round>
    cd7e:	6f d2       	rcall	.+1246   	; 0xd25e <__fp_pscA>
    cd80:	30 f0       	brcs	.+12     	; 0xcd8e <__addsf3+0x18>
    cd82:	74 d2       	rcall	.+1256   	; 0xd26c <__fp_pscB>
    cd84:	20 f0       	brcs	.+8      	; 0xcd8e <__addsf3+0x18>
    cd86:	31 f4       	brne	.+12     	; 0xcd94 <__addsf3+0x1e>
    cd88:	9f 3f       	cpi	r25, 0xFF	; 255
    cd8a:	11 f4       	brne	.+4      	; 0xcd90 <__addsf3+0x1a>
    cd8c:	1e f4       	brtc	.+6      	; 0xcd94 <__addsf3+0x1e>
    cd8e:	2e c2       	rjmp	.+1116   	; 0xd1ec <__fp_nan>
    cd90:	0e f4       	brtc	.+2      	; 0xcd94 <__addsf3+0x1e>
    cd92:	e0 95       	com	r30
    cd94:	e7 fb       	bst	r30, 7
    cd96:	fb c1       	rjmp	.+1014   	; 0xd18e <__fp_inf>

0000cd98 <__addsf3x>:
    cd98:	e9 2f       	mov	r30, r25
    cd9a:	b9 d2       	rcall	.+1394   	; 0xd30e <__fp_split3>
    cd9c:	80 f3       	brcs	.-32     	; 0xcd7e <__addsf3+0x8>
    cd9e:	ba 17       	cp	r27, r26
    cda0:	62 07       	cpc	r22, r18
    cda2:	73 07       	cpc	r23, r19
    cda4:	84 07       	cpc	r24, r20
    cda6:	95 07       	cpc	r25, r21
    cda8:	18 f0       	brcs	.+6      	; 0xcdb0 <__addsf3x+0x18>
    cdaa:	71 f4       	brne	.+28     	; 0xcdc8 <__addsf3x+0x30>
    cdac:	9e f5       	brtc	.+102    	; 0xce14 <__addsf3x+0x7c>
    cdae:	e8 c2       	rjmp	.+1488   	; 0xd380 <__fp_zero>
    cdb0:	0e f4       	brtc	.+2      	; 0xcdb4 <__addsf3x+0x1c>
    cdb2:	e0 95       	com	r30
    cdb4:	0b 2e       	mov	r0, r27
    cdb6:	ba 2f       	mov	r27, r26
    cdb8:	a0 2d       	mov	r26, r0
    cdba:	0b 01       	movw	r0, r22
    cdbc:	b9 01       	movw	r22, r18
    cdbe:	90 01       	movw	r18, r0
    cdc0:	0c 01       	movw	r0, r24
    cdc2:	ca 01       	movw	r24, r20
    cdc4:	a0 01       	movw	r20, r0
    cdc6:	11 24       	eor	r1, r1
    cdc8:	ff 27       	eor	r31, r31
    cdca:	59 1b       	sub	r21, r25
    cdcc:	99 f0       	breq	.+38     	; 0xcdf4 <__addsf3x+0x5c>
    cdce:	59 3f       	cpi	r21, 0xF9	; 249
    cdd0:	50 f4       	brcc	.+20     	; 0xcde6 <__addsf3x+0x4e>
    cdd2:	50 3e       	cpi	r21, 0xE0	; 224
    cdd4:	68 f1       	brcs	.+90     	; 0xce30 <__addsf3x+0x98>
    cdd6:	1a 16       	cp	r1, r26
    cdd8:	f0 40       	sbci	r31, 0x00	; 0
    cdda:	a2 2f       	mov	r26, r18
    cddc:	23 2f       	mov	r18, r19
    cdde:	34 2f       	mov	r19, r20
    cde0:	44 27       	eor	r20, r20
    cde2:	58 5f       	subi	r21, 0xF8	; 248
    cde4:	f3 cf       	rjmp	.-26     	; 0xcdcc <__addsf3x+0x34>
    cde6:	46 95       	lsr	r20
    cde8:	37 95       	ror	r19
    cdea:	27 95       	ror	r18
    cdec:	a7 95       	ror	r26
    cdee:	f0 40       	sbci	r31, 0x00	; 0
    cdf0:	53 95       	inc	r21
    cdf2:	c9 f7       	brne	.-14     	; 0xcde6 <__addsf3x+0x4e>
    cdf4:	7e f4       	brtc	.+30     	; 0xce14 <__addsf3x+0x7c>
    cdf6:	1f 16       	cp	r1, r31
    cdf8:	ba 0b       	sbc	r27, r26
    cdfa:	62 0b       	sbc	r22, r18
    cdfc:	73 0b       	sbc	r23, r19
    cdfe:	84 0b       	sbc	r24, r20
    ce00:	ba f0       	brmi	.+46     	; 0xce30 <__addsf3x+0x98>
    ce02:	91 50       	subi	r25, 0x01	; 1
    ce04:	a1 f0       	breq	.+40     	; 0xce2e <__addsf3x+0x96>
    ce06:	ff 0f       	add	r31, r31
    ce08:	bb 1f       	adc	r27, r27
    ce0a:	66 1f       	adc	r22, r22
    ce0c:	77 1f       	adc	r23, r23
    ce0e:	88 1f       	adc	r24, r24
    ce10:	c2 f7       	brpl	.-16     	; 0xce02 <__addsf3x+0x6a>
    ce12:	0e c0       	rjmp	.+28     	; 0xce30 <__addsf3x+0x98>
    ce14:	ba 0f       	add	r27, r26
    ce16:	62 1f       	adc	r22, r18
    ce18:	73 1f       	adc	r23, r19
    ce1a:	84 1f       	adc	r24, r20
    ce1c:	48 f4       	brcc	.+18     	; 0xce30 <__addsf3x+0x98>
    ce1e:	87 95       	ror	r24
    ce20:	77 95       	ror	r23
    ce22:	67 95       	ror	r22
    ce24:	b7 95       	ror	r27
    ce26:	f7 95       	ror	r31
    ce28:	9e 3f       	cpi	r25, 0xFE	; 254
    ce2a:	08 f0       	brcs	.+2      	; 0xce2e <__addsf3x+0x96>
    ce2c:	b3 cf       	rjmp	.-154    	; 0xcd94 <__addsf3+0x1e>
    ce2e:	93 95       	inc	r25
    ce30:	88 0f       	add	r24, r24
    ce32:	08 f0       	brcs	.+2      	; 0xce36 <__addsf3x+0x9e>
    ce34:	99 27       	eor	r25, r25
    ce36:	ee 0f       	add	r30, r30
    ce38:	97 95       	ror	r25
    ce3a:	87 95       	ror	r24
    ce3c:	08 95       	ret

0000ce3e <asin>:
    ce3e:	9f 93       	push	r25
    ce40:	9f 77       	andi	r25, 0x7F	; 127
    ce42:	ee e3       	ldi	r30, 0x3E	; 62
    ce44:	89 37       	cpi	r24, 0x79	; 121
    ce46:	9e 07       	cpc	r25, r30
    ce48:	20 f4       	brcc	.+8      	; 0xce52 <asin+0x14>
    ce4a:	e4 ee       	ldi	r30, 0xE4	; 228
    ce4c:	f0 e0       	ldi	r31, 0x00	; 0
    ce4e:	f6 d1       	rcall	.+1004   	; 0xd23c <__fp_powsodd>
    ce50:	09 c0       	rjmp	.+18     	; 0xce64 <asin+0x26>
    ce52:	5e d1       	rcall	.+700    	; 0xd110 <__fp_arccos>
    ce54:	90 58       	subi	r25, 0x80	; 128
    ce56:	a2 ea       	ldi	r26, 0xA2	; 162
    ce58:	2a ed       	ldi	r18, 0xDA	; 218
    ce5a:	3f e0       	ldi	r19, 0x0F	; 15
    ce5c:	49 ec       	ldi	r20, 0xC9	; 201
    ce5e:	5f e3       	ldi	r21, 0x3F	; 63
    ce60:	9b df       	rcall	.-202    	; 0xcd98 <__addsf3x>
    ce62:	33 d2       	rcall	.+1126   	; 0xd2ca <__fp_round>
    ce64:	0f 90       	pop	r0
    ce66:	07 fc       	sbrc	r0, 7
    ce68:	90 58       	subi	r25, 0x80	; 128
    ce6a:	08 95       	ret
    ce6c:	f8 d1       	rcall	.+1008   	; 0xd25e <__fp_pscA>
    ce6e:	58 f0       	brcs	.+22     	; 0xce86 <asin+0x48>
    ce70:	80 e8       	ldi	r24, 0x80	; 128
    ce72:	91 e0       	ldi	r25, 0x01	; 1
    ce74:	09 f4       	brne	.+2      	; 0xce78 <asin+0x3a>
    ce76:	9e ef       	ldi	r25, 0xFE	; 254
    ce78:	f9 d1       	rcall	.+1010   	; 0xd26c <__fp_pscB>
    ce7a:	28 f0       	brcs	.+10     	; 0xce86 <asin+0x48>
    ce7c:	40 e8       	ldi	r20, 0x80	; 128
    ce7e:	51 e0       	ldi	r21, 0x01	; 1
    ce80:	59 f4       	brne	.+22     	; 0xce98 <atan2+0xe>
    ce82:	5e ef       	ldi	r21, 0xFE	; 254
    ce84:	09 c0       	rjmp	.+18     	; 0xce98 <atan2+0xe>
    ce86:	b2 c1       	rjmp	.+868    	; 0xd1ec <__fp_nan>
    ce88:	7b c2       	rjmp	.+1270   	; 0xd380 <__fp_zero>

0000ce8a <atan2>:
    ce8a:	e9 2f       	mov	r30, r25
    ce8c:	e0 78       	andi	r30, 0x80	; 128
    ce8e:	3f d2       	rcall	.+1150   	; 0xd30e <__fp_split3>
    ce90:	68 f3       	brcs	.-38     	; 0xce6c <asin+0x2e>
    ce92:	09 2e       	mov	r0, r25
    ce94:	05 2a       	or	r0, r21
    ce96:	c1 f3       	breq	.-16     	; 0xce88 <asin+0x4a>
    ce98:	26 17       	cp	r18, r22
    ce9a:	37 07       	cpc	r19, r23
    ce9c:	48 07       	cpc	r20, r24
    ce9e:	59 07       	cpc	r21, r25
    cea0:	38 f0       	brcs	.+14     	; 0xceb0 <atan2+0x26>
    cea2:	0e 2e       	mov	r0, r30
    cea4:	07 f8       	bld	r0, 7
    cea6:	e0 25       	eor	r30, r0
    cea8:	69 f0       	breq	.+26     	; 0xcec4 <atan2+0x3a>
    ceaa:	e0 25       	eor	r30, r0
    ceac:	e0 64       	ori	r30, 0x40	; 64
    ceae:	0a c0       	rjmp	.+20     	; 0xcec4 <atan2+0x3a>
    ceb0:	ef 63       	ori	r30, 0x3F	; 63
    ceb2:	07 f8       	bld	r0, 7
    ceb4:	00 94       	com	r0
    ceb6:	07 fa       	bst	r0, 7
    ceb8:	db 01       	movw	r26, r22
    ceba:	b9 01       	movw	r22, r18
    cebc:	9d 01       	movw	r18, r26
    cebe:	dc 01       	movw	r26, r24
    cec0:	ca 01       	movw	r24, r20
    cec2:	ad 01       	movw	r20, r26
    cec4:	ef 93       	push	r30
    cec6:	4a d0       	rcall	.+148    	; 0xcf5c <__divsf3_pse>
    cec8:	00 d2       	rcall	.+1024   	; 0xd2ca <__fp_round>
    ceca:	0a d0       	rcall	.+20     	; 0xcee0 <atan>
    cecc:	5f 91       	pop	r21
    cece:	55 23       	and	r21, r21
    ced0:	31 f0       	breq	.+12     	; 0xcede <atan2+0x54>
    ced2:	2b ed       	ldi	r18, 0xDB	; 219
    ced4:	3f e0       	ldi	r19, 0x0F	; 15
    ced6:	49 e4       	ldi	r20, 0x49	; 73
    ced8:	50 fd       	sbrc	r21, 0
    ceda:	49 ec       	ldi	r20, 0xC9	; 201
    cedc:	4c cf       	rjmp	.-360    	; 0xcd76 <__addsf3>
    cede:	08 95       	ret

0000cee0 <atan>:
    cee0:	df 93       	push	r29
    cee2:	dd 27       	eor	r29, r29
    cee4:	b9 2f       	mov	r27, r25
    cee6:	bf 77       	andi	r27, 0x7F	; 127
    cee8:	40 e8       	ldi	r20, 0x80	; 128
    ceea:	5f e3       	ldi	r21, 0x3F	; 63
    ceec:	16 16       	cp	r1, r22
    ceee:	17 06       	cpc	r1, r23
    cef0:	48 07       	cpc	r20, r24
    cef2:	5b 07       	cpc	r21, r27
    cef4:	10 f4       	brcc	.+4      	; 0xcefa <atan+0x1a>
    cef6:	d9 2f       	mov	r29, r25
    cef8:	4e d2       	rcall	.+1180   	; 0xd396 <inverse>
    cefa:	9f 93       	push	r25
    cefc:	8f 93       	push	r24
    cefe:	7f 93       	push	r23
    cf00:	6f 93       	push	r22
    cf02:	92 d3       	rcall	.+1828   	; 0xd628 <square>
    cf04:	e8 ef       	ldi	r30, 0xF8	; 248
    cf06:	f0 e0       	ldi	r31, 0x00	; 0
    cf08:	74 d1       	rcall	.+744    	; 0xd1f2 <__fp_powser>
    cf0a:	df d1       	rcall	.+958    	; 0xd2ca <__fp_round>
    cf0c:	2f 91       	pop	r18
    cf0e:	3f 91       	pop	r19
    cf10:	4f 91       	pop	r20
    cf12:	5f 91       	pop	r21
    cf14:	9e d2       	rcall	.+1340   	; 0xd452 <__mulsf3x>
    cf16:	dd 23       	and	r29, r29
    cf18:	49 f0       	breq	.+18     	; 0xcf2c <atan+0x4c>
    cf1a:	90 58       	subi	r25, 0x80	; 128
    cf1c:	a2 ea       	ldi	r26, 0xA2	; 162
    cf1e:	2a ed       	ldi	r18, 0xDA	; 218
    cf20:	3f e0       	ldi	r19, 0x0F	; 15
    cf22:	49 ec       	ldi	r20, 0xC9	; 201
    cf24:	5f e3       	ldi	r21, 0x3F	; 63
    cf26:	d0 78       	andi	r29, 0x80	; 128
    cf28:	5d 27       	eor	r21, r29
    cf2a:	36 df       	rcall	.-404    	; 0xcd98 <__addsf3x>
    cf2c:	df 91       	pop	r29
    cf2e:	cd c1       	rjmp	.+922    	; 0xd2ca <__fp_round>

0000cf30 <__cmpsf2>:
    cf30:	0a d1       	rcall	.+532    	; 0xd146 <__fp_cmp>
    cf32:	08 f4       	brcc	.+2      	; 0xcf36 <__cmpsf2+0x6>
    cf34:	81 e0       	ldi	r24, 0x01	; 1
    cf36:	08 95       	ret

0000cf38 <cos>:
    cf38:	a1 d1       	rcall	.+834    	; 0xd27c <__fp_rempio2>
    cf3a:	e3 95       	inc	r30
    cf3c:	d7 c1       	rjmp	.+942    	; 0xd2ec <__fp_sinus>

0000cf3e <__divsf3>:
    cf3e:	0c d0       	rcall	.+24     	; 0xcf58 <__divsf3x>
    cf40:	c4 c1       	rjmp	.+904    	; 0xd2ca <__fp_round>
    cf42:	94 d1       	rcall	.+808    	; 0xd26c <__fp_pscB>
    cf44:	40 f0       	brcs	.+16     	; 0xcf56 <__divsf3+0x18>
    cf46:	8b d1       	rcall	.+790    	; 0xd25e <__fp_pscA>
    cf48:	30 f0       	brcs	.+12     	; 0xcf56 <__divsf3+0x18>
    cf4a:	21 f4       	brne	.+8      	; 0xcf54 <__divsf3+0x16>
    cf4c:	5f 3f       	cpi	r21, 0xFF	; 255
    cf4e:	19 f0       	breq	.+6      	; 0xcf56 <__divsf3+0x18>
    cf50:	1e c1       	rjmp	.+572    	; 0xd18e <__fp_inf>
    cf52:	51 11       	cpse	r21, r1
    cf54:	16 c2       	rjmp	.+1068   	; 0xd382 <__fp_szero>
    cf56:	4a c1       	rjmp	.+660    	; 0xd1ec <__fp_nan>

0000cf58 <__divsf3x>:
    cf58:	da d1       	rcall	.+948    	; 0xd30e <__fp_split3>
    cf5a:	98 f3       	brcs	.-26     	; 0xcf42 <__divsf3+0x4>

0000cf5c <__divsf3_pse>:
    cf5c:	99 23       	and	r25, r25
    cf5e:	c9 f3       	breq	.-14     	; 0xcf52 <__divsf3+0x14>
    cf60:	55 23       	and	r21, r21
    cf62:	b1 f3       	breq	.-20     	; 0xcf50 <__divsf3+0x12>
    cf64:	95 1b       	sub	r25, r21
    cf66:	55 0b       	sbc	r21, r21
    cf68:	bb 27       	eor	r27, r27
    cf6a:	aa 27       	eor	r26, r26
    cf6c:	62 17       	cp	r22, r18
    cf6e:	73 07       	cpc	r23, r19
    cf70:	84 07       	cpc	r24, r20
    cf72:	38 f0       	brcs	.+14     	; 0xcf82 <__divsf3_pse+0x26>
    cf74:	9f 5f       	subi	r25, 0xFF	; 255
    cf76:	5f 4f       	sbci	r21, 0xFF	; 255
    cf78:	22 0f       	add	r18, r18
    cf7a:	33 1f       	adc	r19, r19
    cf7c:	44 1f       	adc	r20, r20
    cf7e:	aa 1f       	adc	r26, r26
    cf80:	a9 f3       	breq	.-22     	; 0xcf6c <__divsf3_pse+0x10>
    cf82:	33 d0       	rcall	.+102    	; 0xcfea <__divsf3_pse+0x8e>
    cf84:	0e 2e       	mov	r0, r30
    cf86:	3a f0       	brmi	.+14     	; 0xcf96 <__divsf3_pse+0x3a>
    cf88:	e0 e8       	ldi	r30, 0x80	; 128
    cf8a:	30 d0       	rcall	.+96     	; 0xcfec <__divsf3_pse+0x90>
    cf8c:	91 50       	subi	r25, 0x01	; 1
    cf8e:	50 40       	sbci	r21, 0x00	; 0
    cf90:	e6 95       	lsr	r30
    cf92:	00 1c       	adc	r0, r0
    cf94:	ca f7       	brpl	.-14     	; 0xcf88 <__divsf3_pse+0x2c>
    cf96:	29 d0       	rcall	.+82     	; 0xcfea <__divsf3_pse+0x8e>
    cf98:	fe 2f       	mov	r31, r30
    cf9a:	27 d0       	rcall	.+78     	; 0xcfea <__divsf3_pse+0x8e>
    cf9c:	66 0f       	add	r22, r22
    cf9e:	77 1f       	adc	r23, r23
    cfa0:	88 1f       	adc	r24, r24
    cfa2:	bb 1f       	adc	r27, r27
    cfa4:	26 17       	cp	r18, r22
    cfa6:	37 07       	cpc	r19, r23
    cfa8:	48 07       	cpc	r20, r24
    cfaa:	ab 07       	cpc	r26, r27
    cfac:	b0 e8       	ldi	r27, 0x80	; 128
    cfae:	09 f0       	breq	.+2      	; 0xcfb2 <__divsf3_pse+0x56>
    cfb0:	bb 0b       	sbc	r27, r27
    cfb2:	80 2d       	mov	r24, r0
    cfb4:	bf 01       	movw	r22, r30
    cfb6:	ff 27       	eor	r31, r31
    cfb8:	93 58       	subi	r25, 0x83	; 131
    cfba:	5f 4f       	sbci	r21, 0xFF	; 255
    cfbc:	2a f0       	brmi	.+10     	; 0xcfc8 <__divsf3_pse+0x6c>
    cfbe:	9e 3f       	cpi	r25, 0xFE	; 254
    cfc0:	51 05       	cpc	r21, r1
    cfc2:	68 f0       	brcs	.+26     	; 0xcfde <__divsf3_pse+0x82>
    cfc4:	e4 c0       	rjmp	.+456    	; 0xd18e <__fp_inf>
    cfc6:	dd c1       	rjmp	.+954    	; 0xd382 <__fp_szero>
    cfc8:	5f 3f       	cpi	r21, 0xFF	; 255
    cfca:	ec f3       	brlt	.-6      	; 0xcfc6 <__divsf3_pse+0x6a>
    cfcc:	98 3e       	cpi	r25, 0xE8	; 232
    cfce:	dc f3       	brlt	.-10     	; 0xcfc6 <__divsf3_pse+0x6a>
    cfd0:	86 95       	lsr	r24
    cfd2:	77 95       	ror	r23
    cfd4:	67 95       	ror	r22
    cfd6:	b7 95       	ror	r27
    cfd8:	f7 95       	ror	r31
    cfda:	9f 5f       	subi	r25, 0xFF	; 255
    cfdc:	c9 f7       	brne	.-14     	; 0xcfd0 <__divsf3_pse+0x74>
    cfde:	88 0f       	add	r24, r24
    cfe0:	91 1d       	adc	r25, r1
    cfe2:	96 95       	lsr	r25
    cfe4:	87 95       	ror	r24
    cfe6:	97 f9       	bld	r25, 7
    cfe8:	08 95       	ret
    cfea:	e1 e0       	ldi	r30, 0x01	; 1
    cfec:	66 0f       	add	r22, r22
    cfee:	77 1f       	adc	r23, r23
    cff0:	88 1f       	adc	r24, r24
    cff2:	bb 1f       	adc	r27, r27
    cff4:	62 17       	cp	r22, r18
    cff6:	73 07       	cpc	r23, r19
    cff8:	84 07       	cpc	r24, r20
    cffa:	ba 07       	cpc	r27, r26
    cffc:	20 f0       	brcs	.+8      	; 0xd006 <__divsf3_pse+0xaa>
    cffe:	62 1b       	sub	r22, r18
    d000:	73 0b       	sbc	r23, r19
    d002:	84 0b       	sbc	r24, r20
    d004:	ba 0b       	sbc	r27, r26
    d006:	ee 1f       	adc	r30, r30
    d008:	88 f7       	brcc	.-30     	; 0xcfec <__divsf3_pse+0x90>
    d00a:	e0 95       	com	r30
    d00c:	08 95       	ret

0000d00e <__fixsfsi>:
    d00e:	04 d0       	rcall	.+8      	; 0xd018 <__fixunssfsi>
    d010:	68 94       	set
    d012:	b1 11       	cpse	r27, r1
    d014:	b6 c1       	rjmp	.+876    	; 0xd382 <__fp_szero>
    d016:	08 95       	ret

0000d018 <__fixunssfsi>:
    d018:	82 d1       	rcall	.+772    	; 0xd31e <__fp_splitA>
    d01a:	88 f0       	brcs	.+34     	; 0xd03e <__fixunssfsi+0x26>
    d01c:	9f 57       	subi	r25, 0x7F	; 127
    d01e:	90 f0       	brcs	.+36     	; 0xd044 <__fixunssfsi+0x2c>
    d020:	b9 2f       	mov	r27, r25
    d022:	99 27       	eor	r25, r25
    d024:	b7 51       	subi	r27, 0x17	; 23
    d026:	a0 f0       	brcs	.+40     	; 0xd050 <__fixunssfsi+0x38>
    d028:	d1 f0       	breq	.+52     	; 0xd05e <__fixunssfsi+0x46>
    d02a:	66 0f       	add	r22, r22
    d02c:	77 1f       	adc	r23, r23
    d02e:	88 1f       	adc	r24, r24
    d030:	99 1f       	adc	r25, r25
    d032:	1a f0       	brmi	.+6      	; 0xd03a <__fixunssfsi+0x22>
    d034:	ba 95       	dec	r27
    d036:	c9 f7       	brne	.-14     	; 0xd02a <__fixunssfsi+0x12>
    d038:	12 c0       	rjmp	.+36     	; 0xd05e <__fixunssfsi+0x46>
    d03a:	b1 30       	cpi	r27, 0x01	; 1
    d03c:	81 f0       	breq	.+32     	; 0xd05e <__fixunssfsi+0x46>
    d03e:	a0 d1       	rcall	.+832    	; 0xd380 <__fp_zero>
    d040:	b1 e0       	ldi	r27, 0x01	; 1
    d042:	08 95       	ret
    d044:	9d c1       	rjmp	.+826    	; 0xd380 <__fp_zero>
    d046:	67 2f       	mov	r22, r23
    d048:	78 2f       	mov	r23, r24
    d04a:	88 27       	eor	r24, r24
    d04c:	b8 5f       	subi	r27, 0xF8	; 248
    d04e:	39 f0       	breq	.+14     	; 0xd05e <__fixunssfsi+0x46>
    d050:	b9 3f       	cpi	r27, 0xF9	; 249
    d052:	cc f3       	brlt	.-14     	; 0xd046 <__fixunssfsi+0x2e>
    d054:	86 95       	lsr	r24
    d056:	77 95       	ror	r23
    d058:	67 95       	ror	r22
    d05a:	b3 95       	inc	r27
    d05c:	d9 f7       	brne	.-10     	; 0xd054 <__fixunssfsi+0x3c>
    d05e:	3e f4       	brtc	.+14     	; 0xd06e <__fixunssfsi+0x56>
    d060:	90 95       	com	r25
    d062:	80 95       	com	r24
    d064:	70 95       	com	r23
    d066:	61 95       	neg	r22
    d068:	7f 4f       	sbci	r23, 0xFF	; 255
    d06a:	8f 4f       	sbci	r24, 0xFF	; 255
    d06c:	9f 4f       	sbci	r25, 0xFF	; 255
    d06e:	08 95       	ret

0000d070 <__floatunsisf>:
    d070:	e8 94       	clt
    d072:	09 c0       	rjmp	.+18     	; 0xd086 <__floatsisf+0x12>

0000d074 <__floatsisf>:
    d074:	97 fb       	bst	r25, 7
    d076:	3e f4       	brtc	.+14     	; 0xd086 <__floatsisf+0x12>
    d078:	90 95       	com	r25
    d07a:	80 95       	com	r24
    d07c:	70 95       	com	r23
    d07e:	61 95       	neg	r22
    d080:	7f 4f       	sbci	r23, 0xFF	; 255
    d082:	8f 4f       	sbci	r24, 0xFF	; 255
    d084:	9f 4f       	sbci	r25, 0xFF	; 255
    d086:	99 23       	and	r25, r25
    d088:	a9 f0       	breq	.+42     	; 0xd0b4 <__floatsisf+0x40>
    d08a:	f9 2f       	mov	r31, r25
    d08c:	96 e9       	ldi	r25, 0x96	; 150
    d08e:	bb 27       	eor	r27, r27
    d090:	93 95       	inc	r25
    d092:	f6 95       	lsr	r31
    d094:	87 95       	ror	r24
    d096:	77 95       	ror	r23
    d098:	67 95       	ror	r22
    d09a:	b7 95       	ror	r27
    d09c:	f1 11       	cpse	r31, r1
    d09e:	f8 cf       	rjmp	.-16     	; 0xd090 <__floatsisf+0x1c>
    d0a0:	fa f4       	brpl	.+62     	; 0xd0e0 <__floatsisf+0x6c>
    d0a2:	bb 0f       	add	r27, r27
    d0a4:	11 f4       	brne	.+4      	; 0xd0aa <__floatsisf+0x36>
    d0a6:	60 ff       	sbrs	r22, 0
    d0a8:	1b c0       	rjmp	.+54     	; 0xd0e0 <__floatsisf+0x6c>
    d0aa:	6f 5f       	subi	r22, 0xFF	; 255
    d0ac:	7f 4f       	sbci	r23, 0xFF	; 255
    d0ae:	8f 4f       	sbci	r24, 0xFF	; 255
    d0b0:	9f 4f       	sbci	r25, 0xFF	; 255
    d0b2:	16 c0       	rjmp	.+44     	; 0xd0e0 <__floatsisf+0x6c>
    d0b4:	88 23       	and	r24, r24
    d0b6:	11 f0       	breq	.+4      	; 0xd0bc <__floatsisf+0x48>
    d0b8:	96 e9       	ldi	r25, 0x96	; 150
    d0ba:	11 c0       	rjmp	.+34     	; 0xd0de <__floatsisf+0x6a>
    d0bc:	77 23       	and	r23, r23
    d0be:	21 f0       	breq	.+8      	; 0xd0c8 <__floatsisf+0x54>
    d0c0:	9e e8       	ldi	r25, 0x8E	; 142
    d0c2:	87 2f       	mov	r24, r23
    d0c4:	76 2f       	mov	r23, r22
    d0c6:	05 c0       	rjmp	.+10     	; 0xd0d2 <__floatsisf+0x5e>
    d0c8:	66 23       	and	r22, r22
    d0ca:	71 f0       	breq	.+28     	; 0xd0e8 <__floatsisf+0x74>
    d0cc:	96 e8       	ldi	r25, 0x86	; 134
    d0ce:	86 2f       	mov	r24, r22
    d0d0:	70 e0       	ldi	r23, 0x00	; 0
    d0d2:	60 e0       	ldi	r22, 0x00	; 0
    d0d4:	2a f0       	brmi	.+10     	; 0xd0e0 <__floatsisf+0x6c>
    d0d6:	9a 95       	dec	r25
    d0d8:	66 0f       	add	r22, r22
    d0da:	77 1f       	adc	r23, r23
    d0dc:	88 1f       	adc	r24, r24
    d0de:	da f7       	brpl	.-10     	; 0xd0d6 <__floatsisf+0x62>
    d0e0:	88 0f       	add	r24, r24
    d0e2:	96 95       	lsr	r25
    d0e4:	87 95       	ror	r24
    d0e6:	97 f9       	bld	r25, 7
    d0e8:	08 95       	ret

0000d0ea <floor>:
    d0ea:	33 d1       	rcall	.+614    	; 0xd352 <__fp_trunc>
    d0ec:	80 f0       	brcs	.+32     	; 0xd10e <floor+0x24>
    d0ee:	9f 37       	cpi	r25, 0x7F	; 127
    d0f0:	40 f4       	brcc	.+16     	; 0xd102 <floor+0x18>
    d0f2:	91 11       	cpse	r25, r1
    d0f4:	0e f0       	brts	.+2      	; 0xd0f8 <floor+0xe>
    d0f6:	45 c1       	rjmp	.+650    	; 0xd382 <__fp_szero>
    d0f8:	60 e0       	ldi	r22, 0x00	; 0
    d0fa:	70 e0       	ldi	r23, 0x00	; 0
    d0fc:	80 e8       	ldi	r24, 0x80	; 128
    d0fe:	9f eb       	ldi	r25, 0xBF	; 191
    d100:	08 95       	ret
    d102:	26 f4       	brtc	.+8      	; 0xd10c <floor+0x22>
    d104:	1b 16       	cp	r1, r27
    d106:	61 1d       	adc	r22, r1
    d108:	71 1d       	adc	r23, r1
    d10a:	81 1d       	adc	r24, r1
    d10c:	46 c0       	rjmp	.+140    	; 0xd19a <__fp_mintl>
    d10e:	60 c0       	rjmp	.+192    	; 0xd1d0 <__fp_mpack>

0000d110 <__fp_arccos>:
    d110:	df 93       	push	r29
    d112:	cf 93       	push	r28
    d114:	1f 93       	push	r17
    d116:	0f 93       	push	r16
    d118:	8b 01       	movw	r16, r22
    d11a:	ec 01       	movw	r28, r24
    d11c:	e5 e2       	ldi	r30, 0x25	; 37
    d11e:	f1 e0       	ldi	r31, 0x01	; 1
    d120:	68 d0       	rcall	.+208    	; 0xd1f2 <__fp_powser>
    d122:	d3 d0       	rcall	.+422    	; 0xd2ca <__fp_round>
    d124:	98 01       	movw	r18, r16
    d126:	ae 01       	movw	r20, r28
    d128:	8b 01       	movw	r16, r22
    d12a:	ec 01       	movw	r28, r24
    d12c:	60 e0       	ldi	r22, 0x00	; 0
    d12e:	70 e0       	ldi	r23, 0x00	; 0
    d130:	80 e8       	ldi	r24, 0x80	; 128
    d132:	9f e3       	ldi	r25, 0x3F	; 63
    d134:	1f de       	rcall	.-962    	; 0xcd74 <__subsf3>
    d136:	3a d2       	rcall	.+1140   	; 0xd5ac <sqrt>
    d138:	98 01       	movw	r18, r16
    d13a:	ae 01       	movw	r20, r28
    d13c:	0f 91       	pop	r16
    d13e:	1f 91       	pop	r17
    d140:	cf 91       	pop	r28
    d142:	df 91       	pop	r29
    d144:	86 c1       	rjmp	.+780    	; 0xd452 <__mulsf3x>

0000d146 <__fp_cmp>:
    d146:	99 0f       	add	r25, r25
    d148:	00 08       	sbc	r0, r0
    d14a:	55 0f       	add	r21, r21
    d14c:	aa 0b       	sbc	r26, r26
    d14e:	e0 e8       	ldi	r30, 0x80	; 128
    d150:	fe ef       	ldi	r31, 0xFE	; 254
    d152:	16 16       	cp	r1, r22
    d154:	17 06       	cpc	r1, r23
    d156:	e8 07       	cpc	r30, r24
    d158:	f9 07       	cpc	r31, r25
    d15a:	c0 f0       	brcs	.+48     	; 0xd18c <__fp_cmp+0x46>
    d15c:	12 16       	cp	r1, r18
    d15e:	13 06       	cpc	r1, r19
    d160:	e4 07       	cpc	r30, r20
    d162:	f5 07       	cpc	r31, r21
    d164:	98 f0       	brcs	.+38     	; 0xd18c <__fp_cmp+0x46>
    d166:	62 1b       	sub	r22, r18
    d168:	73 0b       	sbc	r23, r19
    d16a:	84 0b       	sbc	r24, r20
    d16c:	95 0b       	sbc	r25, r21
    d16e:	39 f4       	brne	.+14     	; 0xd17e <__fp_cmp+0x38>
    d170:	0a 26       	eor	r0, r26
    d172:	61 f0       	breq	.+24     	; 0xd18c <__fp_cmp+0x46>
    d174:	23 2b       	or	r18, r19
    d176:	24 2b       	or	r18, r20
    d178:	25 2b       	or	r18, r21
    d17a:	21 f4       	brne	.+8      	; 0xd184 <__fp_cmp+0x3e>
    d17c:	08 95       	ret
    d17e:	0a 26       	eor	r0, r26
    d180:	09 f4       	brne	.+2      	; 0xd184 <__fp_cmp+0x3e>
    d182:	a1 40       	sbci	r26, 0x01	; 1
    d184:	a6 95       	lsr	r26
    d186:	8f ef       	ldi	r24, 0xFF	; 255
    d188:	81 1d       	adc	r24, r1
    d18a:	81 1d       	adc	r24, r1
    d18c:	08 95       	ret

0000d18e <__fp_inf>:
    d18e:	97 f9       	bld	r25, 7
    d190:	9f 67       	ori	r25, 0x7F	; 127
    d192:	80 e8       	ldi	r24, 0x80	; 128
    d194:	70 e0       	ldi	r23, 0x00	; 0
    d196:	60 e0       	ldi	r22, 0x00	; 0
    d198:	08 95       	ret

0000d19a <__fp_mintl>:
    d19a:	88 23       	and	r24, r24
    d19c:	71 f4       	brne	.+28     	; 0xd1ba <__fp_mintl+0x20>
    d19e:	77 23       	and	r23, r23
    d1a0:	21 f0       	breq	.+8      	; 0xd1aa <__fp_mintl+0x10>
    d1a2:	98 50       	subi	r25, 0x08	; 8
    d1a4:	87 2b       	or	r24, r23
    d1a6:	76 2f       	mov	r23, r22
    d1a8:	07 c0       	rjmp	.+14     	; 0xd1b8 <__fp_mintl+0x1e>
    d1aa:	66 23       	and	r22, r22
    d1ac:	11 f4       	brne	.+4      	; 0xd1b2 <__fp_mintl+0x18>
    d1ae:	99 27       	eor	r25, r25
    d1b0:	0d c0       	rjmp	.+26     	; 0xd1cc <__fp_mintl+0x32>
    d1b2:	90 51       	subi	r25, 0x10	; 16
    d1b4:	86 2b       	or	r24, r22
    d1b6:	70 e0       	ldi	r23, 0x00	; 0
    d1b8:	60 e0       	ldi	r22, 0x00	; 0
    d1ba:	2a f0       	brmi	.+10     	; 0xd1c6 <__fp_mintl+0x2c>
    d1bc:	9a 95       	dec	r25
    d1be:	66 0f       	add	r22, r22
    d1c0:	77 1f       	adc	r23, r23
    d1c2:	88 1f       	adc	r24, r24
    d1c4:	da f7       	brpl	.-10     	; 0xd1bc <__fp_mintl+0x22>
    d1c6:	88 0f       	add	r24, r24
    d1c8:	96 95       	lsr	r25
    d1ca:	87 95       	ror	r24
    d1cc:	97 f9       	bld	r25, 7
    d1ce:	08 95       	ret

0000d1d0 <__fp_mpack>:
    d1d0:	9f 3f       	cpi	r25, 0xFF	; 255
    d1d2:	31 f0       	breq	.+12     	; 0xd1e0 <__fp_mpack_finite+0xc>

0000d1d4 <__fp_mpack_finite>:
    d1d4:	91 50       	subi	r25, 0x01	; 1
    d1d6:	20 f4       	brcc	.+8      	; 0xd1e0 <__fp_mpack_finite+0xc>
    d1d8:	87 95       	ror	r24
    d1da:	77 95       	ror	r23
    d1dc:	67 95       	ror	r22
    d1de:	b7 95       	ror	r27
    d1e0:	88 0f       	add	r24, r24
    d1e2:	91 1d       	adc	r25, r1
    d1e4:	96 95       	lsr	r25
    d1e6:	87 95       	ror	r24
    d1e8:	97 f9       	bld	r25, 7
    d1ea:	08 95       	ret

0000d1ec <__fp_nan>:
    d1ec:	9f ef       	ldi	r25, 0xFF	; 255
    d1ee:	80 ec       	ldi	r24, 0xC0	; 192
    d1f0:	08 95       	ret

0000d1f2 <__fp_powser>:
    d1f2:	df 93       	push	r29
    d1f4:	cf 93       	push	r28
    d1f6:	1f 93       	push	r17
    d1f8:	0f 93       	push	r16
    d1fa:	ff 92       	push	r15
    d1fc:	ef 92       	push	r14
    d1fe:	df 92       	push	r13
    d200:	7b 01       	movw	r14, r22
    d202:	8c 01       	movw	r16, r24
    d204:	68 94       	set
    d206:	05 c0       	rjmp	.+10     	; 0xd212 <__fp_powser+0x20>
    d208:	da 2e       	mov	r13, r26
    d20a:	ef 01       	movw	r28, r30
    d20c:	22 d1       	rcall	.+580    	; 0xd452 <__mulsf3x>
    d20e:	fe 01       	movw	r30, r28
    d210:	e8 94       	clt
    d212:	a5 91       	lpm	r26, Z+
    d214:	25 91       	lpm	r18, Z+
    d216:	35 91       	lpm	r19, Z+
    d218:	45 91       	lpm	r20, Z+
    d21a:	55 91       	lpm	r21, Z+
    d21c:	ae f3       	brts	.-22     	; 0xd208 <__fp_powser+0x16>
    d21e:	ef 01       	movw	r28, r30
    d220:	bb dd       	rcall	.-1162   	; 0xcd98 <__addsf3x>
    d222:	fe 01       	movw	r30, r28
    d224:	97 01       	movw	r18, r14
    d226:	a8 01       	movw	r20, r16
    d228:	da 94       	dec	r13
    d22a:	79 f7       	brne	.-34     	; 0xd20a <__fp_powser+0x18>
    d22c:	df 90       	pop	r13
    d22e:	ef 90       	pop	r14
    d230:	ff 90       	pop	r15
    d232:	0f 91       	pop	r16
    d234:	1f 91       	pop	r17
    d236:	cf 91       	pop	r28
    d238:	df 91       	pop	r29
    d23a:	08 95       	ret

0000d23c <__fp_powsodd>:
    d23c:	9f 93       	push	r25
    d23e:	8f 93       	push	r24
    d240:	7f 93       	push	r23
    d242:	6f 93       	push	r22
    d244:	ff 93       	push	r31
    d246:	ef 93       	push	r30
    d248:	9b 01       	movw	r18, r22
    d24a:	ac 01       	movw	r20, r24
    d24c:	f6 d0       	rcall	.+492    	; 0xd43a <__mulsf3>
    d24e:	ef 91       	pop	r30
    d250:	ff 91       	pop	r31
    d252:	cf df       	rcall	.-98     	; 0xd1f2 <__fp_powser>
    d254:	2f 91       	pop	r18
    d256:	3f 91       	pop	r19
    d258:	4f 91       	pop	r20
    d25a:	5f 91       	pop	r21
    d25c:	ee c0       	rjmp	.+476    	; 0xd43a <__mulsf3>

0000d25e <__fp_pscA>:
    d25e:	00 24       	eor	r0, r0
    d260:	0a 94       	dec	r0
    d262:	16 16       	cp	r1, r22
    d264:	17 06       	cpc	r1, r23
    d266:	18 06       	cpc	r1, r24
    d268:	09 06       	cpc	r0, r25
    d26a:	08 95       	ret

0000d26c <__fp_pscB>:
    d26c:	00 24       	eor	r0, r0
    d26e:	0a 94       	dec	r0
    d270:	12 16       	cp	r1, r18
    d272:	13 06       	cpc	r1, r19
    d274:	14 06       	cpc	r1, r20
    d276:	05 06       	cpc	r0, r21
    d278:	08 95       	ret
    d27a:	b8 cf       	rjmp	.-144    	; 0xd1ec <__fp_nan>

0000d27c <__fp_rempio2>:
    d27c:	50 d0       	rcall	.+160    	; 0xd31e <__fp_splitA>
    d27e:	e8 f3       	brcs	.-6      	; 0xd27a <__fp_pscB+0xe>
    d280:	e8 94       	clt
    d282:	e0 e0       	ldi	r30, 0x00	; 0
    d284:	bb 27       	eor	r27, r27
    d286:	9f 57       	subi	r25, 0x7F	; 127
    d288:	f0 f0       	brcs	.+60     	; 0xd2c6 <__fp_rempio2+0x4a>
    d28a:	2a ed       	ldi	r18, 0xDA	; 218
    d28c:	3f e0       	ldi	r19, 0x0F	; 15
    d28e:	49 ec       	ldi	r20, 0xC9	; 201
    d290:	06 c0       	rjmp	.+12     	; 0xd29e <__fp_rempio2+0x22>
    d292:	ee 0f       	add	r30, r30
    d294:	bb 0f       	add	r27, r27
    d296:	66 1f       	adc	r22, r22
    d298:	77 1f       	adc	r23, r23
    d29a:	88 1f       	adc	r24, r24
    d29c:	28 f0       	brcs	.+10     	; 0xd2a8 <__fp_rempio2+0x2c>
    d29e:	b2 3a       	cpi	r27, 0xA2	; 162
    d2a0:	62 07       	cpc	r22, r18
    d2a2:	73 07       	cpc	r23, r19
    d2a4:	84 07       	cpc	r24, r20
    d2a6:	28 f0       	brcs	.+10     	; 0xd2b2 <__fp_rempio2+0x36>
    d2a8:	b2 5a       	subi	r27, 0xA2	; 162
    d2aa:	62 0b       	sbc	r22, r18
    d2ac:	73 0b       	sbc	r23, r19
    d2ae:	84 0b       	sbc	r24, r20
    d2b0:	e3 95       	inc	r30
    d2b2:	9a 95       	dec	r25
    d2b4:	72 f7       	brpl	.-36     	; 0xd292 <__fp_rempio2+0x16>
    d2b6:	80 38       	cpi	r24, 0x80	; 128
    d2b8:	30 f4       	brcc	.+12     	; 0xd2c6 <__fp_rempio2+0x4a>
    d2ba:	9a 95       	dec	r25
    d2bc:	bb 0f       	add	r27, r27
    d2be:	66 1f       	adc	r22, r22
    d2c0:	77 1f       	adc	r23, r23
    d2c2:	88 1f       	adc	r24, r24
    d2c4:	d2 f7       	brpl	.-12     	; 0xd2ba <__fp_rempio2+0x3e>
    d2c6:	90 48       	sbci	r25, 0x80	; 128
    d2c8:	85 cf       	rjmp	.-246    	; 0xd1d4 <__fp_mpack_finite>

0000d2ca <__fp_round>:
    d2ca:	09 2e       	mov	r0, r25
    d2cc:	03 94       	inc	r0
    d2ce:	00 0c       	add	r0, r0
    d2d0:	11 f4       	brne	.+4      	; 0xd2d6 <__fp_round+0xc>
    d2d2:	88 23       	and	r24, r24
    d2d4:	52 f0       	brmi	.+20     	; 0xd2ea <__fp_round+0x20>
    d2d6:	bb 0f       	add	r27, r27
    d2d8:	40 f4       	brcc	.+16     	; 0xd2ea <__fp_round+0x20>
    d2da:	bf 2b       	or	r27, r31
    d2dc:	11 f4       	brne	.+4      	; 0xd2e2 <__fp_round+0x18>
    d2de:	60 ff       	sbrs	r22, 0
    d2e0:	04 c0       	rjmp	.+8      	; 0xd2ea <__fp_round+0x20>
    d2e2:	6f 5f       	subi	r22, 0xFF	; 255
    d2e4:	7f 4f       	sbci	r23, 0xFF	; 255
    d2e6:	8f 4f       	sbci	r24, 0xFF	; 255
    d2e8:	9f 4f       	sbci	r25, 0xFF	; 255
    d2ea:	08 95       	ret

0000d2ec <__fp_sinus>:
    d2ec:	ef 93       	push	r30
    d2ee:	e0 ff       	sbrs	r30, 0
    d2f0:	06 c0       	rjmp	.+12     	; 0xd2fe <__fp_sinus+0x12>
    d2f2:	a2 ea       	ldi	r26, 0xA2	; 162
    d2f4:	2a ed       	ldi	r18, 0xDA	; 218
    d2f6:	3f e0       	ldi	r19, 0x0F	; 15
    d2f8:	49 ec       	ldi	r20, 0xC9	; 201
    d2fa:	5f eb       	ldi	r21, 0xBF	; 191
    d2fc:	4d dd       	rcall	.-1382   	; 0xcd98 <__addsf3x>
    d2fe:	e5 df       	rcall	.-54     	; 0xd2ca <__fp_round>
    d300:	0f 90       	pop	r0
    d302:	03 94       	inc	r0
    d304:	01 fc       	sbrc	r0, 1
    d306:	90 58       	subi	r25, 0x80	; 128
    d308:	ed e4       	ldi	r30, 0x4D	; 77
    d30a:	f1 e0       	ldi	r31, 0x01	; 1
    d30c:	97 cf       	rjmp	.-210    	; 0xd23c <__fp_powsodd>

0000d30e <__fp_split3>:
    d30e:	57 fd       	sbrc	r21, 7
    d310:	90 58       	subi	r25, 0x80	; 128
    d312:	44 0f       	add	r20, r20
    d314:	55 1f       	adc	r21, r21
    d316:	59 f0       	breq	.+22     	; 0xd32e <__fp_splitA+0x10>
    d318:	5f 3f       	cpi	r21, 0xFF	; 255
    d31a:	71 f0       	breq	.+28     	; 0xd338 <__fp_splitA+0x1a>
    d31c:	47 95       	ror	r20

0000d31e <__fp_splitA>:
    d31e:	88 0f       	add	r24, r24
    d320:	97 fb       	bst	r25, 7
    d322:	99 1f       	adc	r25, r25
    d324:	61 f0       	breq	.+24     	; 0xd33e <__fp_splitA+0x20>
    d326:	9f 3f       	cpi	r25, 0xFF	; 255
    d328:	79 f0       	breq	.+30     	; 0xd348 <__fp_splitA+0x2a>
    d32a:	87 95       	ror	r24
    d32c:	08 95       	ret
    d32e:	12 16       	cp	r1, r18
    d330:	13 06       	cpc	r1, r19
    d332:	14 06       	cpc	r1, r20
    d334:	55 1f       	adc	r21, r21
    d336:	f2 cf       	rjmp	.-28     	; 0xd31c <__fp_split3+0xe>
    d338:	46 95       	lsr	r20
    d33a:	f1 df       	rcall	.-30     	; 0xd31e <__fp_splitA>
    d33c:	08 c0       	rjmp	.+16     	; 0xd34e <__fp_splitA+0x30>
    d33e:	16 16       	cp	r1, r22
    d340:	17 06       	cpc	r1, r23
    d342:	18 06       	cpc	r1, r24
    d344:	99 1f       	adc	r25, r25
    d346:	f1 cf       	rjmp	.-30     	; 0xd32a <__fp_splitA+0xc>
    d348:	86 95       	lsr	r24
    d34a:	71 05       	cpc	r23, r1
    d34c:	61 05       	cpc	r22, r1
    d34e:	08 94       	sec
    d350:	08 95       	ret

0000d352 <__fp_trunc>:
    d352:	e5 df       	rcall	.-54     	; 0xd31e <__fp_splitA>
    d354:	a0 f0       	brcs	.+40     	; 0xd37e <__fp_trunc+0x2c>
    d356:	be e7       	ldi	r27, 0x7E	; 126
    d358:	b9 17       	cp	r27, r25
    d35a:	88 f4       	brcc	.+34     	; 0xd37e <__fp_trunc+0x2c>
    d35c:	bb 27       	eor	r27, r27
    d35e:	9f 38       	cpi	r25, 0x8F	; 143
    d360:	60 f4       	brcc	.+24     	; 0xd37a <__fp_trunc+0x28>
    d362:	16 16       	cp	r1, r22
    d364:	b1 1d       	adc	r27, r1
    d366:	67 2f       	mov	r22, r23
    d368:	78 2f       	mov	r23, r24
    d36a:	88 27       	eor	r24, r24
    d36c:	98 5f       	subi	r25, 0xF8	; 248
    d36e:	f7 cf       	rjmp	.-18     	; 0xd35e <__fp_trunc+0xc>
    d370:	86 95       	lsr	r24
    d372:	77 95       	ror	r23
    d374:	67 95       	ror	r22
    d376:	b1 1d       	adc	r27, r1
    d378:	93 95       	inc	r25
    d37a:	96 39       	cpi	r25, 0x96	; 150
    d37c:	c8 f3       	brcs	.-14     	; 0xd370 <__fp_trunc+0x1e>
    d37e:	08 95       	ret

0000d380 <__fp_zero>:
    d380:	e8 94       	clt

0000d382 <__fp_szero>:
    d382:	bb 27       	eor	r27, r27
    d384:	66 27       	eor	r22, r22
    d386:	77 27       	eor	r23, r23
    d388:	cb 01       	movw	r24, r22
    d38a:	97 f9       	bld	r25, 7
    d38c:	08 95       	ret

0000d38e <__gesf2>:
    d38e:	db de       	rcall	.-586    	; 0xd146 <__fp_cmp>
    d390:	08 f4       	brcc	.+2      	; 0xd394 <__gesf2+0x6>
    d392:	8f ef       	ldi	r24, 0xFF	; 255
    d394:	08 95       	ret

0000d396 <inverse>:
    d396:	9b 01       	movw	r18, r22
    d398:	ac 01       	movw	r20, r24
    d39a:	60 e0       	ldi	r22, 0x00	; 0
    d39c:	70 e0       	ldi	r23, 0x00	; 0
    d39e:	80 e8       	ldi	r24, 0x80	; 128
    d3a0:	9f e3       	ldi	r25, 0x3F	; 63
    d3a2:	cd cd       	rjmp	.-1126   	; 0xcf3e <__divsf3>

0000d3a4 <log10>:
    d3a4:	0a d0       	rcall	.+20     	; 0xd3ba <log>
    d3a6:	29 ed       	ldi	r18, 0xD9	; 217
    d3a8:	3b e5       	ldi	r19, 0x5B	; 91
    d3aa:	4e ed       	ldi	r20, 0xDE	; 222
    d3ac:	5e e3       	ldi	r21, 0x3E	; 62
    d3ae:	45 c0       	rjmp	.+138    	; 0xd43a <__mulsf3>
    d3b0:	0e f0       	brts	.+2      	; 0xd3b4 <log10+0x10>
    d3b2:	0e cf       	rjmp	.-484    	; 0xd1d0 <__fp_mpack>
    d3b4:	1b cf       	rjmp	.-458    	; 0xd1ec <__fp_nan>
    d3b6:	68 94       	set
    d3b8:	ea ce       	rjmp	.-556    	; 0xd18e <__fp_inf>

0000d3ba <log>:
    d3ba:	b1 df       	rcall	.-158    	; 0xd31e <__fp_splitA>
    d3bc:	c8 f3       	brcs	.-14     	; 0xd3b0 <log10+0xc>
    d3be:	99 23       	and	r25, r25
    d3c0:	d1 f3       	breq	.-12     	; 0xd3b6 <log10+0x12>
    d3c2:	c6 f3       	brts	.-16     	; 0xd3b4 <log10+0x10>
    d3c4:	df 93       	push	r29
    d3c6:	cf 93       	push	r28
    d3c8:	1f 93       	push	r17
    d3ca:	0f 93       	push	r16
    d3cc:	ff 92       	push	r15
    d3ce:	c9 2f       	mov	r28, r25
    d3d0:	dd 27       	eor	r29, r29
    d3d2:	88 23       	and	r24, r24
    d3d4:	2a f0       	brmi	.+10     	; 0xd3e0 <log+0x26>
    d3d6:	21 97       	sbiw	r28, 0x01	; 1
    d3d8:	66 0f       	add	r22, r22
    d3da:	77 1f       	adc	r23, r23
    d3dc:	88 1f       	adc	r24, r24
    d3de:	da f7       	brpl	.-10     	; 0xd3d6 <log+0x1c>
    d3e0:	20 e0       	ldi	r18, 0x00	; 0
    d3e2:	30 e0       	ldi	r19, 0x00	; 0
    d3e4:	40 e8       	ldi	r20, 0x80	; 128
    d3e6:	5f eb       	ldi	r21, 0xBF	; 191
    d3e8:	9f e3       	ldi	r25, 0x3F	; 63
    d3ea:	88 39       	cpi	r24, 0x98	; 152
    d3ec:	20 f0       	brcs	.+8      	; 0xd3f6 <log+0x3c>
    d3ee:	80 3e       	cpi	r24, 0xE0	; 224
    d3f0:	30 f0       	brcs	.+12     	; 0xd3fe <log+0x44>
    d3f2:	21 96       	adiw	r28, 0x01	; 1
    d3f4:	8f 77       	andi	r24, 0x7F	; 127
    d3f6:	bf dc       	rcall	.-1666   	; 0xcd76 <__addsf3>
    d3f8:	eb e6       	ldi	r30, 0x6B	; 107
    d3fa:	f1 e0       	ldi	r31, 0x01	; 1
    d3fc:	03 c0       	rjmp	.+6      	; 0xd404 <log+0x4a>
    d3fe:	bb dc       	rcall	.-1674   	; 0xcd76 <__addsf3>
    d400:	e8 e9       	ldi	r30, 0x98	; 152
    d402:	f1 e0       	ldi	r31, 0x01	; 1
    d404:	f6 de       	rcall	.-532    	; 0xd1f2 <__fp_powser>
    d406:	8b 01       	movw	r16, r22
    d408:	be 01       	movw	r22, r28
    d40a:	ec 01       	movw	r28, r24
    d40c:	fb 2e       	mov	r15, r27
    d40e:	6f 57       	subi	r22, 0x7F	; 127
    d410:	71 09       	sbc	r23, r1
    d412:	75 95       	asr	r23
    d414:	77 1f       	adc	r23, r23
    d416:	88 0b       	sbc	r24, r24
    d418:	99 0b       	sbc	r25, r25
    d41a:	2c de       	rcall	.-936    	; 0xd074 <__floatsisf>
    d41c:	28 e1       	ldi	r18, 0x18	; 24
    d41e:	32 e7       	ldi	r19, 0x72	; 114
    d420:	41 e3       	ldi	r20, 0x31	; 49
    d422:	5f e3       	ldi	r21, 0x3F	; 63
    d424:	16 d0       	rcall	.+44     	; 0xd452 <__mulsf3x>
    d426:	af 2d       	mov	r26, r15
    d428:	98 01       	movw	r18, r16
    d42a:	ae 01       	movw	r20, r28
    d42c:	ff 90       	pop	r15
    d42e:	0f 91       	pop	r16
    d430:	1f 91       	pop	r17
    d432:	cf 91       	pop	r28
    d434:	df 91       	pop	r29
    d436:	b0 dc       	rcall	.-1696   	; 0xcd98 <__addsf3x>
    d438:	48 cf       	rjmp	.-368    	; 0xd2ca <__fp_round>

0000d43a <__mulsf3>:
    d43a:	0b d0       	rcall	.+22     	; 0xd452 <__mulsf3x>
    d43c:	46 cf       	rjmp	.-372    	; 0xd2ca <__fp_round>
    d43e:	0f df       	rcall	.-482    	; 0xd25e <__fp_pscA>
    d440:	28 f0       	brcs	.+10     	; 0xd44c <__mulsf3+0x12>
    d442:	14 df       	rcall	.-472    	; 0xd26c <__fp_pscB>
    d444:	18 f0       	brcs	.+6      	; 0xd44c <__mulsf3+0x12>
    d446:	95 23       	and	r25, r21
    d448:	09 f0       	breq	.+2      	; 0xd44c <__mulsf3+0x12>
    d44a:	a1 ce       	rjmp	.-702    	; 0xd18e <__fp_inf>
    d44c:	cf ce       	rjmp	.-610    	; 0xd1ec <__fp_nan>
    d44e:	11 24       	eor	r1, r1
    d450:	98 cf       	rjmp	.-208    	; 0xd382 <__fp_szero>

0000d452 <__mulsf3x>:
    d452:	5d df       	rcall	.-326    	; 0xd30e <__fp_split3>
    d454:	a0 f3       	brcs	.-24     	; 0xd43e <__mulsf3+0x4>

0000d456 <__mulsf3_pse>:
    d456:	95 9f       	mul	r25, r21
    d458:	d1 f3       	breq	.-12     	; 0xd44e <__mulsf3+0x14>
    d45a:	95 0f       	add	r25, r21
    d45c:	50 e0       	ldi	r21, 0x00	; 0
    d45e:	55 1f       	adc	r21, r21
    d460:	62 9f       	mul	r22, r18
    d462:	f0 01       	movw	r30, r0
    d464:	72 9f       	mul	r23, r18
    d466:	bb 27       	eor	r27, r27
    d468:	f0 0d       	add	r31, r0
    d46a:	b1 1d       	adc	r27, r1
    d46c:	63 9f       	mul	r22, r19
    d46e:	aa 27       	eor	r26, r26
    d470:	f0 0d       	add	r31, r0
    d472:	b1 1d       	adc	r27, r1
    d474:	aa 1f       	adc	r26, r26
    d476:	64 9f       	mul	r22, r20
    d478:	66 27       	eor	r22, r22
    d47a:	b0 0d       	add	r27, r0
    d47c:	a1 1d       	adc	r26, r1
    d47e:	66 1f       	adc	r22, r22
    d480:	82 9f       	mul	r24, r18
    d482:	22 27       	eor	r18, r18
    d484:	b0 0d       	add	r27, r0
    d486:	a1 1d       	adc	r26, r1
    d488:	62 1f       	adc	r22, r18
    d48a:	73 9f       	mul	r23, r19
    d48c:	b0 0d       	add	r27, r0
    d48e:	a1 1d       	adc	r26, r1
    d490:	62 1f       	adc	r22, r18
    d492:	83 9f       	mul	r24, r19
    d494:	a0 0d       	add	r26, r0
    d496:	61 1d       	adc	r22, r1
    d498:	22 1f       	adc	r18, r18
    d49a:	74 9f       	mul	r23, r20
    d49c:	33 27       	eor	r19, r19
    d49e:	a0 0d       	add	r26, r0
    d4a0:	61 1d       	adc	r22, r1
    d4a2:	23 1f       	adc	r18, r19
    d4a4:	84 9f       	mul	r24, r20
    d4a6:	60 0d       	add	r22, r0
    d4a8:	21 1d       	adc	r18, r1
    d4aa:	82 2f       	mov	r24, r18
    d4ac:	76 2f       	mov	r23, r22
    d4ae:	6a 2f       	mov	r22, r26
    d4b0:	11 24       	eor	r1, r1
    d4b2:	9f 57       	subi	r25, 0x7F	; 127
    d4b4:	50 40       	sbci	r21, 0x00	; 0
    d4b6:	8a f0       	brmi	.+34     	; 0xd4da <__mulsf3_pse+0x84>
    d4b8:	e1 f0       	breq	.+56     	; 0xd4f2 <__mulsf3_pse+0x9c>
    d4ba:	88 23       	and	r24, r24
    d4bc:	4a f0       	brmi	.+18     	; 0xd4d0 <__mulsf3_pse+0x7a>
    d4be:	ee 0f       	add	r30, r30
    d4c0:	ff 1f       	adc	r31, r31
    d4c2:	bb 1f       	adc	r27, r27
    d4c4:	66 1f       	adc	r22, r22
    d4c6:	77 1f       	adc	r23, r23
    d4c8:	88 1f       	adc	r24, r24
    d4ca:	91 50       	subi	r25, 0x01	; 1
    d4cc:	50 40       	sbci	r21, 0x00	; 0
    d4ce:	a9 f7       	brne	.-22     	; 0xd4ba <__mulsf3_pse+0x64>
    d4d0:	9e 3f       	cpi	r25, 0xFE	; 254
    d4d2:	51 05       	cpc	r21, r1
    d4d4:	70 f0       	brcs	.+28     	; 0xd4f2 <__mulsf3_pse+0x9c>
    d4d6:	5b ce       	rjmp	.-842    	; 0xd18e <__fp_inf>
    d4d8:	54 cf       	rjmp	.-344    	; 0xd382 <__fp_szero>
    d4da:	5f 3f       	cpi	r21, 0xFF	; 255
    d4dc:	ec f3       	brlt	.-6      	; 0xd4d8 <__mulsf3_pse+0x82>
    d4de:	98 3e       	cpi	r25, 0xE8	; 232
    d4e0:	dc f3       	brlt	.-10     	; 0xd4d8 <__mulsf3_pse+0x82>
    d4e2:	86 95       	lsr	r24
    d4e4:	77 95       	ror	r23
    d4e6:	67 95       	ror	r22
    d4e8:	b7 95       	ror	r27
    d4ea:	f7 95       	ror	r31
    d4ec:	e7 95       	ror	r30
    d4ee:	9f 5f       	subi	r25, 0xFF	; 255
    d4f0:	c1 f7       	brne	.-16     	; 0xd4e2 <__mulsf3_pse+0x8c>
    d4f2:	fe 2b       	or	r31, r30
    d4f4:	88 0f       	add	r24, r24
    d4f6:	91 1d       	adc	r25, r1
    d4f8:	96 95       	lsr	r25
    d4fa:	87 95       	ror	r24
    d4fc:	97 f9       	bld	r25, 7
    d4fe:	08 95       	ret

0000d500 <pow>:
    d500:	fa 01       	movw	r30, r20
    d502:	ee 0f       	add	r30, r30
    d504:	ff 1f       	adc	r31, r31
    d506:	30 96       	adiw	r30, 0x00	; 0
    d508:	21 05       	cpc	r18, r1
    d50a:	31 05       	cpc	r19, r1
    d50c:	99 f1       	breq	.+102    	; 0xd574 <pow+0x74>
    d50e:	61 15       	cp	r22, r1
    d510:	71 05       	cpc	r23, r1
    d512:	61 f4       	brne	.+24     	; 0xd52c <pow+0x2c>
    d514:	80 38       	cpi	r24, 0x80	; 128
    d516:	bf e3       	ldi	r27, 0x3F	; 63
    d518:	9b 07       	cpc	r25, r27
    d51a:	49 f1       	breq	.+82     	; 0xd56e <pow+0x6e>
    d51c:	68 94       	set
    d51e:	90 38       	cpi	r25, 0x80	; 128
    d520:	81 05       	cpc	r24, r1
    d522:	61 f0       	breq	.+24     	; 0xd53c <pow+0x3c>
    d524:	80 38       	cpi	r24, 0x80	; 128
    d526:	bf ef       	ldi	r27, 0xFF	; 255
    d528:	9b 07       	cpc	r25, r27
    d52a:	41 f0       	breq	.+16     	; 0xd53c <pow+0x3c>
    d52c:	99 23       	and	r25, r25
    d52e:	42 f5       	brpl	.+80     	; 0xd580 <pow+0x80>
    d530:	ff 3f       	cpi	r31, 0xFF	; 255
    d532:	e1 05       	cpc	r30, r1
    d534:	31 05       	cpc	r19, r1
    d536:	21 05       	cpc	r18, r1
    d538:	11 f1       	breq	.+68     	; 0xd57e <pow+0x7e>
    d53a:	e8 94       	clt
    d53c:	08 94       	sec
    d53e:	e7 95       	ror	r30
    d540:	d9 01       	movw	r26, r18
    d542:	aa 23       	and	r26, r26
    d544:	29 f4       	brne	.+10     	; 0xd550 <pow+0x50>
    d546:	ab 2f       	mov	r26, r27
    d548:	be 2f       	mov	r27, r30
    d54a:	f8 5f       	subi	r31, 0xF8	; 248
    d54c:	d0 f3       	brcs	.-12     	; 0xd542 <pow+0x42>
    d54e:	10 c0       	rjmp	.+32     	; 0xd570 <pow+0x70>
    d550:	ff 5f       	subi	r31, 0xFF	; 255
    d552:	70 f4       	brcc	.+28     	; 0xd570 <pow+0x70>
    d554:	a6 95       	lsr	r26
    d556:	e0 f7       	brcc	.-8      	; 0xd550 <pow+0x50>
    d558:	f7 39       	cpi	r31, 0x97	; 151
    d55a:	50 f0       	brcs	.+20     	; 0xd570 <pow+0x70>
    d55c:	19 f0       	breq	.+6      	; 0xd564 <pow+0x64>
    d55e:	ff 3a       	cpi	r31, 0xAF	; 175
    d560:	38 f4       	brcc	.+14     	; 0xd570 <pow+0x70>
    d562:	9f 77       	andi	r25, 0x7F	; 127
    d564:	9f 93       	push	r25
    d566:	0c d0       	rcall	.+24     	; 0xd580 <pow+0x80>
    d568:	0f 90       	pop	r0
    d56a:	07 fc       	sbrc	r0, 7
    d56c:	90 58       	subi	r25, 0x80	; 128
    d56e:	08 95       	ret
    d570:	3e f0       	brts	.+14     	; 0xd580 <pow+0x80>
    d572:	3c ce       	rjmp	.-904    	; 0xd1ec <__fp_nan>
    d574:	60 e0       	ldi	r22, 0x00	; 0
    d576:	70 e0       	ldi	r23, 0x00	; 0
    d578:	80 e8       	ldi	r24, 0x80	; 128
    d57a:	9f e3       	ldi	r25, 0x3F	; 63
    d57c:	08 95       	ret
    d57e:	4f e7       	ldi	r20, 0x7F	; 127
    d580:	9f 77       	andi	r25, 0x7F	; 127
    d582:	5f 93       	push	r21
    d584:	4f 93       	push	r20
    d586:	3f 93       	push	r19
    d588:	2f 93       	push	r18
    d58a:	17 df       	rcall	.-466    	; 0xd3ba <log>
    d58c:	2f 91       	pop	r18
    d58e:	3f 91       	pop	r19
    d590:	4f 91       	pop	r20
    d592:	5f 91       	pop	r21
    d594:	52 df       	rcall	.-348    	; 0xd43a <__mulsf3>
    d596:	54 c0       	rjmp	.+168    	; 0xd640 <exp>

0000d598 <sin>:
    d598:	9f 93       	push	r25
    d59a:	70 de       	rcall	.-800    	; 0xd27c <__fp_rempio2>
    d59c:	0f 90       	pop	r0
    d59e:	07 fc       	sbrc	r0, 7
    d5a0:	ee 5f       	subi	r30, 0xFE	; 254
    d5a2:	a4 ce       	rjmp	.-696    	; 0xd2ec <__fp_sinus>
    d5a4:	11 f4       	brne	.+4      	; 0xd5aa <sin+0x12>
    d5a6:	0e f4       	brtc	.+2      	; 0xd5aa <sin+0x12>
    d5a8:	21 ce       	rjmp	.-958    	; 0xd1ec <__fp_nan>
    d5aa:	12 ce       	rjmp	.-988    	; 0xd1d0 <__fp_mpack>

0000d5ac <sqrt>:
    d5ac:	b8 de       	rcall	.-656    	; 0xd31e <__fp_splitA>
    d5ae:	d0 f3       	brcs	.-12     	; 0xd5a4 <sin+0xc>
    d5b0:	99 23       	and	r25, r25
    d5b2:	d9 f3       	breq	.-10     	; 0xd5aa <sin+0x12>
    d5b4:	ce f3       	brts	.-14     	; 0xd5a8 <sin+0x10>
    d5b6:	9f 57       	subi	r25, 0x7F	; 127
    d5b8:	55 0b       	sbc	r21, r21
    d5ba:	87 ff       	sbrs	r24, 7
    d5bc:	6d d0       	rcall	.+218    	; 0xd698 <__fp_norm2>
    d5be:	00 24       	eor	r0, r0
    d5c0:	a0 e6       	ldi	r26, 0x60	; 96
    d5c2:	40 ea       	ldi	r20, 0xA0	; 160
    d5c4:	90 01       	movw	r18, r0
    d5c6:	80 58       	subi	r24, 0x80	; 128
    d5c8:	56 95       	lsr	r21
    d5ca:	97 95       	ror	r25
    d5cc:	28 f4       	brcc	.+10     	; 0xd5d8 <sqrt+0x2c>
    d5ce:	80 5c       	subi	r24, 0xC0	; 192
    d5d0:	66 0f       	add	r22, r22
    d5d2:	77 1f       	adc	r23, r23
    d5d4:	88 1f       	adc	r24, r24
    d5d6:	20 f0       	brcs	.+8      	; 0xd5e0 <sqrt+0x34>
    d5d8:	26 17       	cp	r18, r22
    d5da:	37 07       	cpc	r19, r23
    d5dc:	48 07       	cpc	r20, r24
    d5de:	30 f4       	brcc	.+12     	; 0xd5ec <sqrt+0x40>
    d5e0:	62 1b       	sub	r22, r18
    d5e2:	73 0b       	sbc	r23, r19
    d5e4:	84 0b       	sbc	r24, r20
    d5e6:	20 29       	or	r18, r0
    d5e8:	31 29       	or	r19, r1
    d5ea:	4a 2b       	or	r20, r26
    d5ec:	a6 95       	lsr	r26
    d5ee:	17 94       	ror	r1
    d5f0:	07 94       	ror	r0
    d5f2:	20 25       	eor	r18, r0
    d5f4:	31 25       	eor	r19, r1
    d5f6:	4a 27       	eor	r20, r26
    d5f8:	58 f7       	brcc	.-42     	; 0xd5d0 <sqrt+0x24>
    d5fa:	66 0f       	add	r22, r22
    d5fc:	77 1f       	adc	r23, r23
    d5fe:	88 1f       	adc	r24, r24
    d600:	20 f0       	brcs	.+8      	; 0xd60a <sqrt+0x5e>
    d602:	26 17       	cp	r18, r22
    d604:	37 07       	cpc	r19, r23
    d606:	48 07       	cpc	r20, r24
    d608:	30 f4       	brcc	.+12     	; 0xd616 <sqrt+0x6a>
    d60a:	62 0b       	sbc	r22, r18
    d60c:	73 0b       	sbc	r23, r19
    d60e:	84 0b       	sbc	r24, r20
    d610:	20 0d       	add	r18, r0
    d612:	31 1d       	adc	r19, r1
    d614:	41 1d       	adc	r20, r1
    d616:	a0 95       	com	r26
    d618:	81 f7       	brne	.-32     	; 0xd5fa <sqrt+0x4e>
    d61a:	b9 01       	movw	r22, r18
    d61c:	84 2f       	mov	r24, r20
    d61e:	91 58       	subi	r25, 0x81	; 129
    d620:	88 0f       	add	r24, r24
    d622:	96 95       	lsr	r25
    d624:	87 95       	ror	r24
    d626:	08 95       	ret

0000d628 <square>:
    d628:	9b 01       	movw	r18, r22
    d62a:	ac 01       	movw	r20, r24
    d62c:	06 cf       	rjmp	.-500    	; 0xd43a <__mulsf3>

0000d62e <__unordsf2>:
    d62e:	8b dd       	rcall	.-1258   	; 0xd146 <__fp_cmp>
    d630:	88 0b       	sbc	r24, r24
    d632:	99 0b       	sbc	r25, r25
    d634:	08 95       	ret
    d636:	19 f4       	brne	.+6      	; 0xd63e <__unordsf2+0x10>
    d638:	0e f0       	brts	.+2      	; 0xd63c <__unordsf2+0xe>
    d63a:	a9 cd       	rjmp	.-1198   	; 0xd18e <__fp_inf>
    d63c:	a1 ce       	rjmp	.-702    	; 0xd380 <__fp_zero>
    d63e:	d6 cd       	rjmp	.-1108   	; 0xd1ec <__fp_nan>

0000d640 <exp>:
    d640:	6e de       	rcall	.-804    	; 0xd31e <__fp_splitA>
    d642:	c8 f3       	brcs	.-14     	; 0xd636 <__unordsf2+0x8>
    d644:	96 38       	cpi	r25, 0x86	; 134
    d646:	c0 f7       	brcc	.-16     	; 0xd638 <__unordsf2+0xa>
    d648:	07 f8       	bld	r0, 7
    d64a:	0f 92       	push	r0
    d64c:	e8 94       	clt
    d64e:	2b e3       	ldi	r18, 0x3B	; 59
    d650:	3a ea       	ldi	r19, 0xAA	; 170
    d652:	48 eb       	ldi	r20, 0xB8	; 184
    d654:	5f e7       	ldi	r21, 0x7F	; 127
    d656:	ff de       	rcall	.-514    	; 0xd456 <__mulsf3_pse>
    d658:	0f 92       	push	r0
    d65a:	0f 92       	push	r0
    d65c:	0f 92       	push	r0
    d65e:	4d b7       	in	r20, 0x3d	; 61
    d660:	5e b7       	in	r21, 0x3e	; 62
    d662:	0f 92       	push	r0
    d664:	56 d0       	rcall	.+172    	; 0xd712 <modf>
    d666:	e5 ec       	ldi	r30, 0xC5	; 197
    d668:	f1 e0       	ldi	r31, 0x01	; 1
    d66a:	c3 dd       	rcall	.-1146   	; 0xd1f2 <__fp_powser>
    d66c:	4f 91       	pop	r20
    d66e:	5f 91       	pop	r21
    d670:	ef 91       	pop	r30
    d672:	ff 91       	pop	r31
    d674:	e5 95       	asr	r30
    d676:	ee 1f       	adc	r30, r30
    d678:	ff 1f       	adc	r31, r31
    d67a:	49 f0       	breq	.+18     	; 0xd68e <exp+0x4e>
    d67c:	fe 57       	subi	r31, 0x7E	; 126
    d67e:	e0 68       	ori	r30, 0x80	; 128
    d680:	44 27       	eor	r20, r20
    d682:	ee 0f       	add	r30, r30
    d684:	44 1f       	adc	r20, r20
    d686:	fa 95       	dec	r31
    d688:	e1 f7       	brne	.-8      	; 0xd682 <exp+0x42>
    d68a:	41 95       	neg	r20
    d68c:	55 0b       	sbc	r21, r21
    d68e:	0d d0       	rcall	.+26     	; 0xd6aa <ldexp>
    d690:	0f 90       	pop	r0
    d692:	07 fe       	sbrs	r0, 7
    d694:	80 ce       	rjmp	.-768    	; 0xd396 <inverse>
    d696:	08 95       	ret

0000d698 <__fp_norm2>:
    d698:	91 50       	subi	r25, 0x01	; 1
    d69a:	50 40       	sbci	r21, 0x00	; 0
    d69c:	66 0f       	add	r22, r22
    d69e:	77 1f       	adc	r23, r23
    d6a0:	88 1f       	adc	r24, r24
    d6a2:	d2 f7       	brpl	.-12     	; 0xd698 <__fp_norm2>
    d6a4:	08 95       	ret
    d6a6:	73 cd       	rjmp	.-1306   	; 0xd18e <__fp_inf>
    d6a8:	93 cd       	rjmp	.-1242   	; 0xd1d0 <__fp_mpack>

0000d6aa <ldexp>:
    d6aa:	39 de       	rcall	.-910    	; 0xd31e <__fp_splitA>
    d6ac:	e8 f3       	brcs	.-6      	; 0xd6a8 <__fp_norm2+0x10>
    d6ae:	99 23       	and	r25, r25
    d6b0:	d9 f3       	breq	.-10     	; 0xd6a8 <__fp_norm2+0x10>
    d6b2:	94 0f       	add	r25, r20
    d6b4:	51 1d       	adc	r21, r1
    d6b6:	bb f3       	brvs	.-18     	; 0xd6a6 <__fp_norm2+0xe>
    d6b8:	91 50       	subi	r25, 0x01	; 1
    d6ba:	50 40       	sbci	r21, 0x00	; 0
    d6bc:	94 f0       	brlt	.+36     	; 0xd6e2 <ldexp+0x38>
    d6be:	59 f0       	breq	.+22     	; 0xd6d6 <ldexp+0x2c>
    d6c0:	88 23       	and	r24, r24
    d6c2:	32 f0       	brmi	.+12     	; 0xd6d0 <ldexp+0x26>
    d6c4:	66 0f       	add	r22, r22
    d6c6:	77 1f       	adc	r23, r23
    d6c8:	88 1f       	adc	r24, r24
    d6ca:	91 50       	subi	r25, 0x01	; 1
    d6cc:	50 40       	sbci	r21, 0x00	; 0
    d6ce:	c1 f7       	brne	.-16     	; 0xd6c0 <ldexp+0x16>
    d6d0:	9e 3f       	cpi	r25, 0xFE	; 254
    d6d2:	51 05       	cpc	r21, r1
    d6d4:	44 f7       	brge	.-48     	; 0xd6a6 <__fp_norm2+0xe>
    d6d6:	88 0f       	add	r24, r24
    d6d8:	91 1d       	adc	r25, r1
    d6da:	96 95       	lsr	r25
    d6dc:	87 95       	ror	r24
    d6de:	97 f9       	bld	r25, 7
    d6e0:	08 95       	ret
    d6e2:	5f 3f       	cpi	r21, 0xFF	; 255
    d6e4:	ac f0       	brlt	.+42     	; 0xd710 <ldexp+0x66>
    d6e6:	98 3e       	cpi	r25, 0xE8	; 232
    d6e8:	9c f0       	brlt	.+38     	; 0xd710 <ldexp+0x66>
    d6ea:	bb 27       	eor	r27, r27
    d6ec:	86 95       	lsr	r24
    d6ee:	77 95       	ror	r23
    d6f0:	67 95       	ror	r22
    d6f2:	b7 95       	ror	r27
    d6f4:	08 f4       	brcc	.+2      	; 0xd6f8 <ldexp+0x4e>
    d6f6:	b1 60       	ori	r27, 0x01	; 1
    d6f8:	93 95       	inc	r25
    d6fa:	c1 f7       	brne	.-16     	; 0xd6ec <ldexp+0x42>
    d6fc:	bb 0f       	add	r27, r27
    d6fe:	58 f7       	brcc	.-42     	; 0xd6d6 <ldexp+0x2c>
    d700:	11 f4       	brne	.+4      	; 0xd706 <ldexp+0x5c>
    d702:	60 ff       	sbrs	r22, 0
    d704:	e8 cf       	rjmp	.-48     	; 0xd6d6 <ldexp+0x2c>
    d706:	6f 5f       	subi	r22, 0xFF	; 255
    d708:	7f 4f       	sbci	r23, 0xFF	; 255
    d70a:	8f 4f       	sbci	r24, 0xFF	; 255
    d70c:	9f 4f       	sbci	r25, 0xFF	; 255
    d70e:	e3 cf       	rjmp	.-58     	; 0xd6d6 <ldexp+0x2c>
    d710:	38 ce       	rjmp	.-912    	; 0xd382 <__fp_szero>

0000d712 <modf>:
    d712:	fa 01       	movw	r30, r20
    d714:	dc 01       	movw	r26, r24
    d716:	aa 0f       	add	r26, r26
    d718:	bb 1f       	adc	r27, r27
    d71a:	9b 01       	movw	r18, r22
    d71c:	ac 01       	movw	r20, r24
    d71e:	bf 57       	subi	r27, 0x7F	; 127
    d720:	28 f4       	brcc	.+10     	; 0xd72c <modf+0x1a>
    d722:	22 27       	eor	r18, r18
    d724:	33 27       	eor	r19, r19
    d726:	44 27       	eor	r20, r20
    d728:	50 78       	andi	r21, 0x80	; 128
    d72a:	1f c0       	rjmp	.+62     	; 0xd76a <modf+0x58>
    d72c:	b7 51       	subi	r27, 0x17	; 23
    d72e:	88 f4       	brcc	.+34     	; 0xd752 <modf+0x40>
    d730:	ab 2f       	mov	r26, r27
    d732:	00 24       	eor	r0, r0
    d734:	46 95       	lsr	r20
    d736:	37 95       	ror	r19
    d738:	27 95       	ror	r18
    d73a:	01 1c       	adc	r0, r1
    d73c:	a3 95       	inc	r26
    d73e:	d2 f3       	brmi	.-12     	; 0xd734 <modf+0x22>
    d740:	00 20       	and	r0, r0
    d742:	69 f0       	breq	.+26     	; 0xd75e <modf+0x4c>
    d744:	22 0f       	add	r18, r18
    d746:	33 1f       	adc	r19, r19
    d748:	44 1f       	adc	r20, r20
    d74a:	b3 95       	inc	r27
    d74c:	da f3       	brmi	.-10     	; 0xd744 <modf+0x32>
    d74e:	0d d0       	rcall	.+26     	; 0xd76a <modf+0x58>
    d750:	11 cb       	rjmp	.-2526   	; 0xcd74 <__subsf3>
    d752:	61 30       	cpi	r22, 0x01	; 1
    d754:	71 05       	cpc	r23, r1
    d756:	a0 e8       	ldi	r26, 0x80	; 128
    d758:	8a 07       	cpc	r24, r26
    d75a:	b9 46       	sbci	r27, 0x69	; 105
    d75c:	30 f4       	brcc	.+12     	; 0xd76a <modf+0x58>
    d75e:	9b 01       	movw	r18, r22
    d760:	ac 01       	movw	r20, r24
    d762:	66 27       	eor	r22, r22
    d764:	77 27       	eor	r23, r23
    d766:	88 27       	eor	r24, r24
    d768:	90 78       	andi	r25, 0x80	; 128
    d76a:	30 96       	adiw	r30, 0x00	; 0
    d76c:	21 f0       	breq	.+8      	; 0xd776 <modf+0x64>
    d76e:	20 83       	st	Z, r18
    d770:	31 83       	std	Z+1, r19	; 0x01
    d772:	42 83       	std	Z+2, r20	; 0x02
    d774:	53 83       	std	Z+3, r21	; 0x03
    d776:	08 95       	ret

0000d778 <__udivmodsi4>:
    d778:	a1 e2       	ldi	r26, 0x21	; 33
    d77a:	1a 2e       	mov	r1, r26
    d77c:	aa 1b       	sub	r26, r26
    d77e:	bb 1b       	sub	r27, r27
    d780:	fd 01       	movw	r30, r26
    d782:	0d c0       	rjmp	.+26     	; 0xd79e <__udivmodsi4_ep>

0000d784 <__udivmodsi4_loop>:
    d784:	aa 1f       	adc	r26, r26
    d786:	bb 1f       	adc	r27, r27
    d788:	ee 1f       	adc	r30, r30
    d78a:	ff 1f       	adc	r31, r31
    d78c:	a2 17       	cp	r26, r18
    d78e:	b3 07       	cpc	r27, r19
    d790:	e4 07       	cpc	r30, r20
    d792:	f5 07       	cpc	r31, r21
    d794:	20 f0       	brcs	.+8      	; 0xd79e <__udivmodsi4_ep>
    d796:	a2 1b       	sub	r26, r18
    d798:	b3 0b       	sbc	r27, r19
    d79a:	e4 0b       	sbc	r30, r20
    d79c:	f5 0b       	sbc	r31, r21

0000d79e <__udivmodsi4_ep>:
    d79e:	66 1f       	adc	r22, r22
    d7a0:	77 1f       	adc	r23, r23
    d7a2:	88 1f       	adc	r24, r24
    d7a4:	99 1f       	adc	r25, r25
    d7a6:	1a 94       	dec	r1
    d7a8:	69 f7       	brne	.-38     	; 0xd784 <__udivmodsi4_loop>
    d7aa:	60 95       	com	r22
    d7ac:	70 95       	com	r23
    d7ae:	80 95       	com	r24
    d7b0:	90 95       	com	r25
    d7b2:	9b 01       	movw	r18, r22
    d7b4:	ac 01       	movw	r20, r24
    d7b6:	bd 01       	movw	r22, r26
    d7b8:	cf 01       	movw	r24, r30
    d7ba:	08 95       	ret

0000d7bc <__muldi3>:
    d7bc:	df 93       	push	r29
    d7be:	cf 93       	push	r28
    d7c0:	1f 93       	push	r17
    d7c2:	0f 93       	push	r16
    d7c4:	9a 9d       	mul	r25, r10
    d7c6:	f0 2d       	mov	r31, r0
    d7c8:	21 9f       	mul	r18, r17
    d7ca:	f0 0d       	add	r31, r0
    d7cc:	8b 9d       	mul	r24, r11
    d7ce:	f0 0d       	add	r31, r0
    d7d0:	8a 9d       	mul	r24, r10
    d7d2:	e0 2d       	mov	r30, r0
    d7d4:	f1 0d       	add	r31, r1
    d7d6:	03 9f       	mul	r16, r19
    d7d8:	f0 0d       	add	r31, r0
    d7da:	02 9f       	mul	r16, r18
    d7dc:	e0 0d       	add	r30, r0
    d7de:	f1 1d       	adc	r31, r1
    d7e0:	4e 9d       	mul	r20, r14
    d7e2:	e0 0d       	add	r30, r0
    d7e4:	f1 1d       	adc	r31, r1
    d7e6:	5e 9d       	mul	r21, r14
    d7e8:	f0 0d       	add	r31, r0
    d7ea:	4f 9d       	mul	r20, r15
    d7ec:	f0 0d       	add	r31, r0
    d7ee:	7f 93       	push	r23
    d7f0:	6f 93       	push	r22
    d7f2:	bf 92       	push	r11
    d7f4:	af 92       	push	r10
    d7f6:	5f 93       	push	r21
    d7f8:	4f 93       	push	r20
    d7fa:	d5 01       	movw	r26, r10
    d7fc:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d800:	8b 01       	movw	r16, r22
    d802:	ac 01       	movw	r20, r24
    d804:	d7 01       	movw	r26, r14
    d806:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d80a:	eb 01       	movw	r28, r22
    d80c:	e8 0f       	add	r30, r24
    d80e:	f9 1f       	adc	r31, r25
    d810:	d6 01       	movw	r26, r12
    d812:	0e 94 2e 6c 	call	0xd85c	; 0xd85c <__muldi3_6>
    d816:	2f 91       	pop	r18
    d818:	3f 91       	pop	r19
    d81a:	d6 01       	movw	r26, r12
    d81c:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d820:	c6 0f       	add	r28, r22
    d822:	d7 1f       	adc	r29, r23
    d824:	e8 1f       	adc	r30, r24
    d826:	f9 1f       	adc	r31, r25
    d828:	af 91       	pop	r26
    d82a:	bf 91       	pop	r27
    d82c:	0e 94 2e 6c 	call	0xd85c	; 0xd85c <__muldi3_6>
    d830:	2f 91       	pop	r18
    d832:	3f 91       	pop	r19
    d834:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d838:	c6 0f       	add	r28, r22
    d83a:	d7 1f       	adc	r29, r23
    d83c:	e8 1f       	adc	r30, r24
    d83e:	f9 1f       	adc	r31, r25
    d840:	d6 01       	movw	r26, r12
    d842:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d846:	e6 0f       	add	r30, r22
    d848:	f7 1f       	adc	r31, r23
    d84a:	98 01       	movw	r18, r16
    d84c:	be 01       	movw	r22, r28
    d84e:	cf 01       	movw	r24, r30
    d850:	11 24       	eor	r1, r1
    d852:	0f 91       	pop	r16
    d854:	1f 91       	pop	r17
    d856:	cf 91       	pop	r28
    d858:	df 91       	pop	r29
    d85a:	08 95       	ret

0000d85c <__muldi3_6>:
    d85c:	0e 94 84 6c 	call	0xd908	; 0xd908 <__umulhisi3>
    d860:	46 0f       	add	r20, r22
    d862:	57 1f       	adc	r21, r23
    d864:	c8 1f       	adc	r28, r24
    d866:	d9 1f       	adc	r29, r25
    d868:	08 f4       	brcc	.+2      	; 0xd86c <__muldi3_6+0x10>
    d86a:	31 96       	adiw	r30, 0x01	; 1
    d86c:	08 95       	ret

0000d86e <__tablejump_elpm__>:
    d86e:	07 90       	elpm	r0, Z+
    d870:	f6 91       	elpm	r31, Z
    d872:	e0 2d       	mov	r30, r0
    d874:	19 94       	eijmp

0000d876 <__ashldi3>:
    d876:	0f 93       	push	r16
    d878:	08 30       	cpi	r16, 0x08	; 8
    d87a:	90 f0       	brcs	.+36     	; 0xd8a0 <__ashldi3+0x2a>
    d87c:	98 2f       	mov	r25, r24
    d87e:	87 2f       	mov	r24, r23
    d880:	76 2f       	mov	r23, r22
    d882:	65 2f       	mov	r22, r21
    d884:	54 2f       	mov	r21, r20
    d886:	43 2f       	mov	r20, r19
    d888:	32 2f       	mov	r19, r18
    d88a:	22 27       	eor	r18, r18
    d88c:	08 50       	subi	r16, 0x08	; 8
    d88e:	f4 cf       	rjmp	.-24     	; 0xd878 <__ashldi3+0x2>
    d890:	22 0f       	add	r18, r18
    d892:	33 1f       	adc	r19, r19
    d894:	44 1f       	adc	r20, r20
    d896:	55 1f       	adc	r21, r21
    d898:	66 1f       	adc	r22, r22
    d89a:	77 1f       	adc	r23, r23
    d89c:	88 1f       	adc	r24, r24
    d89e:	99 1f       	adc	r25, r25
    d8a0:	0a 95       	dec	r16
    d8a2:	b2 f7       	brpl	.-20     	; 0xd890 <__ashldi3+0x1a>
    d8a4:	0f 91       	pop	r16
    d8a6:	08 95       	ret

0000d8a8 <__ashrdi3>:
    d8a8:	97 fb       	bst	r25, 7
    d8aa:	10 f8       	bld	r1, 0

0000d8ac <__lshrdi3>:
    d8ac:	16 94       	lsr	r1
    d8ae:	00 08       	sbc	r0, r0
    d8b0:	0f 93       	push	r16
    d8b2:	08 30       	cpi	r16, 0x08	; 8
    d8b4:	98 f0       	brcs	.+38     	; 0xd8dc <__lshrdi3+0x30>
    d8b6:	08 50       	subi	r16, 0x08	; 8
    d8b8:	23 2f       	mov	r18, r19
    d8ba:	34 2f       	mov	r19, r20
    d8bc:	45 2f       	mov	r20, r21
    d8be:	56 2f       	mov	r21, r22
    d8c0:	67 2f       	mov	r22, r23
    d8c2:	78 2f       	mov	r23, r24
    d8c4:	89 2f       	mov	r24, r25
    d8c6:	90 2d       	mov	r25, r0
    d8c8:	f4 cf       	rjmp	.-24     	; 0xd8b2 <__lshrdi3+0x6>
    d8ca:	05 94       	asr	r0
    d8cc:	97 95       	ror	r25
    d8ce:	87 95       	ror	r24
    d8d0:	77 95       	ror	r23
    d8d2:	67 95       	ror	r22
    d8d4:	57 95       	ror	r21
    d8d6:	47 95       	ror	r20
    d8d8:	37 95       	ror	r19
    d8da:	27 95       	ror	r18
    d8dc:	0a 95       	dec	r16
    d8de:	aa f7       	brpl	.-22     	; 0xd8ca <__lshrdi3+0x1e>
    d8e0:	0f 91       	pop	r16
    d8e2:	08 95       	ret

0000d8e4 <__adddi3>:
    d8e4:	2a 0d       	add	r18, r10
    d8e6:	3b 1d       	adc	r19, r11
    d8e8:	4c 1d       	adc	r20, r12
    d8ea:	5d 1d       	adc	r21, r13
    d8ec:	6e 1d       	adc	r22, r14
    d8ee:	7f 1d       	adc	r23, r15
    d8f0:	80 1f       	adc	r24, r16
    d8f2:	91 1f       	adc	r25, r17
    d8f4:	08 95       	ret

0000d8f6 <__subdi3>:
    d8f6:	2a 19       	sub	r18, r10
    d8f8:	3b 09       	sbc	r19, r11
    d8fa:	4c 09       	sbc	r20, r12
    d8fc:	5d 09       	sbc	r21, r13
    d8fe:	6e 09       	sbc	r22, r14
    d900:	7f 09       	sbc	r23, r15
    d902:	80 0b       	sbc	r24, r16
    d904:	91 0b       	sbc	r25, r17
    d906:	08 95       	ret

0000d908 <__umulhisi3>:
    d908:	a2 9f       	mul	r26, r18
    d90a:	b0 01       	movw	r22, r0
    d90c:	b3 9f       	mul	r27, r19
    d90e:	c0 01       	movw	r24, r0
    d910:	a3 9f       	mul	r26, r19
    d912:	70 0d       	add	r23, r0
    d914:	81 1d       	adc	r24, r1
    d916:	11 24       	eor	r1, r1
    d918:	91 1d       	adc	r25, r1
    d91a:	b2 9f       	mul	r27, r18
    d91c:	70 0d       	add	r23, r0
    d91e:	81 1d       	adc	r24, r1
    d920:	11 24       	eor	r1, r1
    d922:	91 1d       	adc	r25, r1
    d924:	08 95       	ret

0000d926 <malloc>:
    d926:	cf 93       	push	r28
    d928:	df 93       	push	r29
    d92a:	82 30       	cpi	r24, 0x02	; 2
    d92c:	91 05       	cpc	r25, r1
    d92e:	10 f4       	brcc	.+4      	; 0xd934 <malloc+0xe>
    d930:	82 e0       	ldi	r24, 0x02	; 2
    d932:	90 e0       	ldi	r25, 0x00	; 0
    d934:	e0 91 7e 10 	lds	r30, 0x107E
    d938:	f0 91 7f 10 	lds	r31, 0x107F
    d93c:	20 e0       	ldi	r18, 0x00	; 0
    d93e:	30 e0       	ldi	r19, 0x00	; 0
    d940:	a0 e0       	ldi	r26, 0x00	; 0
    d942:	b0 e0       	ldi	r27, 0x00	; 0
    d944:	30 97       	sbiw	r30, 0x00	; 0
    d946:	39 f1       	breq	.+78     	; 0xd996 <malloc+0x70>
    d948:	40 81       	ld	r20, Z
    d94a:	51 81       	ldd	r21, Z+1	; 0x01
    d94c:	48 17       	cp	r20, r24
    d94e:	59 07       	cpc	r21, r25
    d950:	b8 f0       	brcs	.+46     	; 0xd980 <malloc+0x5a>
    d952:	48 17       	cp	r20, r24
    d954:	59 07       	cpc	r21, r25
    d956:	71 f4       	brne	.+28     	; 0xd974 <malloc+0x4e>
    d958:	82 81       	ldd	r24, Z+2	; 0x02
    d95a:	93 81       	ldd	r25, Z+3	; 0x03
    d95c:	10 97       	sbiw	r26, 0x00	; 0
    d95e:	29 f0       	breq	.+10     	; 0xd96a <malloc+0x44>
    d960:	13 96       	adiw	r26, 0x03	; 3
    d962:	9c 93       	st	X, r25
    d964:	8e 93       	st	-X, r24
    d966:	12 97       	sbiw	r26, 0x02	; 2
    d968:	2c c0       	rjmp	.+88     	; 0xd9c2 <malloc+0x9c>
    d96a:	90 93 7f 10 	sts	0x107F, r25
    d96e:	80 93 7e 10 	sts	0x107E, r24
    d972:	27 c0       	rjmp	.+78     	; 0xd9c2 <malloc+0x9c>
    d974:	21 15       	cp	r18, r1
    d976:	31 05       	cpc	r19, r1
    d978:	31 f0       	breq	.+12     	; 0xd986 <malloc+0x60>
    d97a:	42 17       	cp	r20, r18
    d97c:	53 07       	cpc	r21, r19
    d97e:	18 f0       	brcs	.+6      	; 0xd986 <malloc+0x60>
    d980:	a9 01       	movw	r20, r18
    d982:	db 01       	movw	r26, r22
    d984:	01 c0       	rjmp	.+2      	; 0xd988 <malloc+0x62>
    d986:	ef 01       	movw	r28, r30
    d988:	9a 01       	movw	r18, r20
    d98a:	bd 01       	movw	r22, r26
    d98c:	df 01       	movw	r26, r30
    d98e:	02 80       	ldd	r0, Z+2	; 0x02
    d990:	f3 81       	ldd	r31, Z+3	; 0x03
    d992:	e0 2d       	mov	r30, r0
    d994:	d7 cf       	rjmp	.-82     	; 0xd944 <malloc+0x1e>
    d996:	21 15       	cp	r18, r1
    d998:	31 05       	cpc	r19, r1
    d99a:	f9 f0       	breq	.+62     	; 0xd9da <malloc+0xb4>
    d99c:	28 1b       	sub	r18, r24
    d99e:	39 0b       	sbc	r19, r25
    d9a0:	24 30       	cpi	r18, 0x04	; 4
    d9a2:	31 05       	cpc	r19, r1
    d9a4:	80 f4       	brcc	.+32     	; 0xd9c6 <malloc+0xa0>
    d9a6:	8a 81       	ldd	r24, Y+2	; 0x02
    d9a8:	9b 81       	ldd	r25, Y+3	; 0x03
    d9aa:	61 15       	cp	r22, r1
    d9ac:	71 05       	cpc	r23, r1
    d9ae:	21 f0       	breq	.+8      	; 0xd9b8 <malloc+0x92>
    d9b0:	fb 01       	movw	r30, r22
    d9b2:	93 83       	std	Z+3, r25	; 0x03
    d9b4:	82 83       	std	Z+2, r24	; 0x02
    d9b6:	04 c0       	rjmp	.+8      	; 0xd9c0 <malloc+0x9a>
    d9b8:	90 93 7f 10 	sts	0x107F, r25
    d9bc:	80 93 7e 10 	sts	0x107E, r24
    d9c0:	fe 01       	movw	r30, r28
    d9c2:	32 96       	adiw	r30, 0x02	; 2
    d9c4:	44 c0       	rjmp	.+136    	; 0xda4e <malloc+0x128>
    d9c6:	fe 01       	movw	r30, r28
    d9c8:	e2 0f       	add	r30, r18
    d9ca:	f3 1f       	adc	r31, r19
    d9cc:	81 93       	st	Z+, r24
    d9ce:	91 93       	st	Z+, r25
    d9d0:	22 50       	subi	r18, 0x02	; 2
    d9d2:	31 09       	sbc	r19, r1
    d9d4:	39 83       	std	Y+1, r19	; 0x01
    d9d6:	28 83       	st	Y, r18
    d9d8:	3a c0       	rjmp	.+116    	; 0xda4e <malloc+0x128>
    d9da:	20 91 7c 10 	lds	r18, 0x107C
    d9de:	30 91 7d 10 	lds	r19, 0x107D
    d9e2:	23 2b       	or	r18, r19
    d9e4:	41 f4       	brne	.+16     	; 0xd9f6 <malloc+0xd0>
    d9e6:	20 91 02 02 	lds	r18, 0x0202
    d9ea:	30 91 03 02 	lds	r19, 0x0203
    d9ee:	30 93 7d 10 	sts	0x107D, r19
    d9f2:	20 93 7c 10 	sts	0x107C, r18
    d9f6:	20 91 00 02 	lds	r18, 0x0200
    d9fa:	30 91 01 02 	lds	r19, 0x0201
    d9fe:	21 15       	cp	r18, r1
    da00:	31 05       	cpc	r19, r1
    da02:	41 f4       	brne	.+16     	; 0xda14 <malloc+0xee>
    da04:	2d b7       	in	r18, 0x3d	; 61
    da06:	3e b7       	in	r19, 0x3e	; 62
    da08:	40 91 04 02 	lds	r20, 0x0204
    da0c:	50 91 05 02 	lds	r21, 0x0205
    da10:	24 1b       	sub	r18, r20
    da12:	35 0b       	sbc	r19, r21
    da14:	e0 91 7c 10 	lds	r30, 0x107C
    da18:	f0 91 7d 10 	lds	r31, 0x107D
    da1c:	e2 17       	cp	r30, r18
    da1e:	f3 07       	cpc	r31, r19
    da20:	a0 f4       	brcc	.+40     	; 0xda4a <malloc+0x124>
    da22:	2e 1b       	sub	r18, r30
    da24:	3f 0b       	sbc	r19, r31
    da26:	28 17       	cp	r18, r24
    da28:	39 07       	cpc	r19, r25
    da2a:	78 f0       	brcs	.+30     	; 0xda4a <malloc+0x124>
    da2c:	ac 01       	movw	r20, r24
    da2e:	4e 5f       	subi	r20, 0xFE	; 254
    da30:	5f 4f       	sbci	r21, 0xFF	; 255
    da32:	24 17       	cp	r18, r20
    da34:	35 07       	cpc	r19, r21
    da36:	48 f0       	brcs	.+18     	; 0xda4a <malloc+0x124>
    da38:	4e 0f       	add	r20, r30
    da3a:	5f 1f       	adc	r21, r31
    da3c:	50 93 7d 10 	sts	0x107D, r21
    da40:	40 93 7c 10 	sts	0x107C, r20
    da44:	81 93       	st	Z+, r24
    da46:	91 93       	st	Z+, r25
    da48:	02 c0       	rjmp	.+4      	; 0xda4e <malloc+0x128>
    da4a:	e0 e0       	ldi	r30, 0x00	; 0
    da4c:	f0 e0       	ldi	r31, 0x00	; 0
    da4e:	cf 01       	movw	r24, r30
    da50:	df 91       	pop	r29
    da52:	cf 91       	pop	r28
    da54:	08 95       	ret

0000da56 <free>:
    da56:	cf 93       	push	r28
    da58:	df 93       	push	r29
    da5a:	00 97       	sbiw	r24, 0x00	; 0
    da5c:	09 f4       	brne	.+2      	; 0xda60 <free+0xa>
    da5e:	87 c0       	rjmp	.+270    	; 0xdb6e <free+0x118>
    da60:	fc 01       	movw	r30, r24
    da62:	32 97       	sbiw	r30, 0x02	; 2
    da64:	13 82       	std	Z+3, r1	; 0x03
    da66:	12 82       	std	Z+2, r1	; 0x02
    da68:	c0 91 7e 10 	lds	r28, 0x107E
    da6c:	d0 91 7f 10 	lds	r29, 0x107F
    da70:	20 97       	sbiw	r28, 0x00	; 0
    da72:	81 f4       	brne	.+32     	; 0xda94 <free+0x3e>
    da74:	20 81       	ld	r18, Z
    da76:	31 81       	ldd	r19, Z+1	; 0x01
    da78:	28 0f       	add	r18, r24
    da7a:	39 1f       	adc	r19, r25
    da7c:	80 91 7c 10 	lds	r24, 0x107C
    da80:	90 91 7d 10 	lds	r25, 0x107D
    da84:	82 17       	cp	r24, r18
    da86:	93 07       	cpc	r25, r19
    da88:	79 f5       	brne	.+94     	; 0xdae8 <free+0x92>
    da8a:	f0 93 7d 10 	sts	0x107D, r31
    da8e:	e0 93 7c 10 	sts	0x107C, r30
    da92:	6d c0       	rjmp	.+218    	; 0xdb6e <free+0x118>
    da94:	de 01       	movw	r26, r28
    da96:	20 e0       	ldi	r18, 0x00	; 0
    da98:	30 e0       	ldi	r19, 0x00	; 0
    da9a:	ae 17       	cp	r26, r30
    da9c:	bf 07       	cpc	r27, r31
    da9e:	50 f4       	brcc	.+20     	; 0xdab4 <free+0x5e>
    daa0:	12 96       	adiw	r26, 0x02	; 2
    daa2:	4d 91       	ld	r20, X+
    daa4:	5c 91       	ld	r21, X
    daa6:	13 97       	sbiw	r26, 0x03	; 3
    daa8:	9d 01       	movw	r18, r26
    daaa:	41 15       	cp	r20, r1
    daac:	51 05       	cpc	r21, r1
    daae:	09 f1       	breq	.+66     	; 0xdaf2 <free+0x9c>
    dab0:	da 01       	movw	r26, r20
    dab2:	f3 cf       	rjmp	.-26     	; 0xda9a <free+0x44>
    dab4:	b3 83       	std	Z+3, r27	; 0x03
    dab6:	a2 83       	std	Z+2, r26	; 0x02
    dab8:	40 81       	ld	r20, Z
    daba:	51 81       	ldd	r21, Z+1	; 0x01
    dabc:	84 0f       	add	r24, r20
    dabe:	95 1f       	adc	r25, r21
    dac0:	8a 17       	cp	r24, r26
    dac2:	9b 07       	cpc	r25, r27
    dac4:	71 f4       	brne	.+28     	; 0xdae2 <free+0x8c>
    dac6:	8d 91       	ld	r24, X+
    dac8:	9c 91       	ld	r25, X
    daca:	11 97       	sbiw	r26, 0x01	; 1
    dacc:	84 0f       	add	r24, r20
    dace:	95 1f       	adc	r25, r21
    dad0:	02 96       	adiw	r24, 0x02	; 2
    dad2:	91 83       	std	Z+1, r25	; 0x01
    dad4:	80 83       	st	Z, r24
    dad6:	12 96       	adiw	r26, 0x02	; 2
    dad8:	8d 91       	ld	r24, X+
    dada:	9c 91       	ld	r25, X
    dadc:	13 97       	sbiw	r26, 0x03	; 3
    dade:	93 83       	std	Z+3, r25	; 0x03
    dae0:	82 83       	std	Z+2, r24	; 0x02
    dae2:	21 15       	cp	r18, r1
    dae4:	31 05       	cpc	r19, r1
    dae6:	29 f4       	brne	.+10     	; 0xdaf2 <free+0x9c>
    dae8:	f0 93 7f 10 	sts	0x107F, r31
    daec:	e0 93 7e 10 	sts	0x107E, r30
    daf0:	3e c0       	rjmp	.+124    	; 0xdb6e <free+0x118>
    daf2:	d9 01       	movw	r26, r18
    daf4:	13 96       	adiw	r26, 0x03	; 3
    daf6:	fc 93       	st	X, r31
    daf8:	ee 93       	st	-X, r30
    dafa:	12 97       	sbiw	r26, 0x02	; 2
    dafc:	4d 91       	ld	r20, X+
    dafe:	5d 91       	ld	r21, X+
    db00:	a4 0f       	add	r26, r20
    db02:	b5 1f       	adc	r27, r21
    db04:	ea 17       	cp	r30, r26
    db06:	fb 07       	cpc	r31, r27
    db08:	79 f4       	brne	.+30     	; 0xdb28 <free+0xd2>
    db0a:	80 81       	ld	r24, Z
    db0c:	91 81       	ldd	r25, Z+1	; 0x01
    db0e:	84 0f       	add	r24, r20
    db10:	95 1f       	adc	r25, r21
    db12:	02 96       	adiw	r24, 0x02	; 2
    db14:	d9 01       	movw	r26, r18
    db16:	11 96       	adiw	r26, 0x01	; 1
    db18:	9c 93       	st	X, r25
    db1a:	8e 93       	st	-X, r24
    db1c:	82 81       	ldd	r24, Z+2	; 0x02
    db1e:	93 81       	ldd	r25, Z+3	; 0x03
    db20:	13 96       	adiw	r26, 0x03	; 3
    db22:	9c 93       	st	X, r25
    db24:	8e 93       	st	-X, r24
    db26:	12 97       	sbiw	r26, 0x02	; 2
    db28:	e0 e0       	ldi	r30, 0x00	; 0
    db2a:	f0 e0       	ldi	r31, 0x00	; 0
    db2c:	8a 81       	ldd	r24, Y+2	; 0x02
    db2e:	9b 81       	ldd	r25, Y+3	; 0x03
    db30:	00 97       	sbiw	r24, 0x00	; 0
    db32:	19 f0       	breq	.+6      	; 0xdb3a <free+0xe4>
    db34:	fe 01       	movw	r30, r28
    db36:	ec 01       	movw	r28, r24
    db38:	f9 cf       	rjmp	.-14     	; 0xdb2c <free+0xd6>
    db3a:	ce 01       	movw	r24, r28
    db3c:	02 96       	adiw	r24, 0x02	; 2
    db3e:	28 81       	ld	r18, Y
    db40:	39 81       	ldd	r19, Y+1	; 0x01
    db42:	82 0f       	add	r24, r18
    db44:	93 1f       	adc	r25, r19
    db46:	20 91 7c 10 	lds	r18, 0x107C
    db4a:	30 91 7d 10 	lds	r19, 0x107D
    db4e:	28 17       	cp	r18, r24
    db50:	39 07       	cpc	r19, r25
    db52:	69 f4       	brne	.+26     	; 0xdb6e <free+0x118>
    db54:	30 97       	sbiw	r30, 0x00	; 0
    db56:	29 f4       	brne	.+10     	; 0xdb62 <free+0x10c>
    db58:	10 92 7f 10 	sts	0x107F, r1
    db5c:	10 92 7e 10 	sts	0x107E, r1
    db60:	02 c0       	rjmp	.+4      	; 0xdb66 <free+0x110>
    db62:	13 82       	std	Z+3, r1	; 0x03
    db64:	12 82       	std	Z+2, r1	; 0x02
    db66:	d0 93 7d 10 	sts	0x107D, r29
    db6a:	c0 93 7c 10 	sts	0x107C, r28
    db6e:	df 91       	pop	r29
    db70:	cf 91       	pop	r28
    db72:	08 95       	ret

0000db74 <memcpy>:
    db74:	fb 01       	movw	r30, r22
    db76:	dc 01       	movw	r26, r24
    db78:	02 c0       	rjmp	.+4      	; 0xdb7e <memcpy+0xa>
    db7a:	01 90       	ld	r0, Z+
    db7c:	0d 92       	st	X+, r0
    db7e:	41 50       	subi	r20, 0x01	; 1
    db80:	50 40       	sbci	r21, 0x00	; 0
    db82:	d8 f7       	brcc	.-10     	; 0xdb7a <memcpy+0x6>
    db84:	08 95       	ret

0000db86 <memset>:
    db86:	dc 01       	movw	r26, r24
    db88:	01 c0       	rjmp	.+2      	; 0xdb8c <memset+0x6>
    db8a:	6d 93       	st	X+, r22
    db8c:	41 50       	subi	r20, 0x01	; 1
    db8e:	50 40       	sbci	r21, 0x00	; 0
    db90:	e0 f7       	brcc	.-8      	; 0xdb8a <memset+0x4>
    db92:	08 95       	ret

0000db94 <__do_global_dtors>:
    db94:	13 e0       	ldi	r17, 0x03	; 3
    db96:	c8 e3       	ldi	r28, 0x38	; 56
    db98:	d3 e0       	ldi	r29, 0x03	; 3
    db9a:	00 e0       	ldi	r16, 0x00	; 0
    db9c:	06 c0       	rjmp	.+12     	; 0xdbaa <__do_global_dtors+0x16>
    db9e:	22 97       	sbiw	r28, 0x02	; 2
    dba0:	01 09       	sbc	r16, r1
    dba2:	fe 01       	movw	r30, r28
    dba4:	0b bf       	out	0x3b, r16	; 59
    dba6:	0e 94 37 6c 	call	0xd86e	; 0xd86e <__tablejump_elpm__>
    dbaa:	ca 33       	cpi	r28, 0x3A	; 58
    dbac:	d1 07       	cpc	r29, r17
    dbae:	80 e0       	ldi	r24, 0x00	; 0
    dbb0:	08 07       	cpc	r16, r24
    dbb2:	a9 f7       	brne	.-22     	; 0xdb9e <__do_global_dtors+0xa>
    dbb4:	f8 94       	cli

0000dbb6 <__stop_program>:
    dbb6:	ff cf       	rjmp	.-2      	; 0xdbb6 <__stop_program>
