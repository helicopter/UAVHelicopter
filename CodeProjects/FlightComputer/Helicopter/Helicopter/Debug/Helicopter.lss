
Helicopter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000018e  00800200  0000e302  0000e396  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000e302  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cf2  0080038e  0080038e  0000e524  2**0
                  ALLOC
  3 .stab         00004d34  00000000  00000000  0000e524  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001555  00000000  00000000  00013258  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000147ad  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000bf8  00000000  00000000  000147dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00044c90  00000000  00000000  000153d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000844b  00000000  00000000  0005a064  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000065ea  00000000  00000000  000624af  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00002f1c  00000000  00000000  00068a9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000c1a1  00000000  00000000  0006b9b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001fb61  00000000  00000000  00077b59  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000ec8  00000000  00000000  000976ba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	//TODO should this be delete[]?
	delete this->records;
}

void Buffer::enqueue(Record *record)
{
       0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__dtors_end>
       4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	if (record != NULL)
       8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	{
		//Copy the record
		//TODO danger not deep copy. 
		Record *newRecord = record->Copy();
       c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      10:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		
		//Add the record to the linked list.
		if (this->records == NULL)
      14:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      18:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		{
			records = newRecord;
      1c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			firstRecord = newRecord;
      20:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			lastRecord = newRecord;
      24:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		}else
		{
			lastRecord->setNextRecord(newRecord);
      28:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
					return nextRecord;
				}
				
				void setNextRecord(Record *record)
				{
					nextRecord = record;
      2c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			newRecord->setPreviousRecord(lastRecord);
      30:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
					return previousRecord;	
				}					
				
				void setPreviousRecord(Record *record)
				{
					previousRecord = record;
      34:	0c 94 3a 43 	jmp	0x8674	; 0x8674 <__vector_13>
      38:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
			lastRecord = newRecord;
      3c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
		}
		
		bufferSize++;
      40:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      44:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
	}
}
      48:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      4c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      50:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      54:	0c 94 53 6a 	jmp	0xd4a6	; 0xd4a6 <__vector_21>
      58:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      5c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      60:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      64:	0c 94 af 0e 	jmp	0x1d5e	; 0x1d5e <__vector_25>
      68:	0c 94 db 0e 	jmp	0x1db6	; 0x1db6 <__vector_26>
      6c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      70:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      74:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      78:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      7c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      80:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      84:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      88:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      8c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      90:	0c 94 13 4c 	jmp	0x9826	; 0x9826 <__vector_36>
      94:	0c 94 1b 0f 	jmp	0x1e36	; 0x1e36 <__vector_37>
      98:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      9c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      a8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      ac:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      b8:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__vector_46>
      bc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      c8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      cc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d4:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      d8:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      dc:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e0:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__bad_interrupt>
      e4:	03 6e       	ori	r16, 0xE3	; 227
      e6:	db 36       	cpi	r29, 0x6B	; 107
      e8:	3d 9a       	sbi	0x07, 5	; 7
      ea:	99 99       	sbic	0x13, 1	; 19
      ec:	99 3d       	cpi	r25, 0xD9	; 217
      ee:	ab aa       	std	Y+51, r10	; 0x33
      f0:	aa 2a       	or	r10, r26
      f2:	3e 00       	.word	0x003e	; ????
      f4:	00 00       	nop
      f6:	80 3f       	cpi	r24, 0xF0	; 240
      f8:	08 4a       	sbci	r16, 0xA8	; 168
      fa:	d7 3b       	cpi	r29, 0xB7	; 183
      fc:	3b ce       	rjmp	.-906    	; 0xfffffd74 <__eeprom_end+0xff7efd74>
      fe:	01 6e       	ori	r16, 0xE1	; 225
     100:	84 bc       	out	0x24, r8	; 36
     102:	bf fd       	.word	0xfdbf	; ????
     104:	c1 2f       	mov	r28, r17
     106:	3d 6c       	ori	r19, 0xCD	; 205
     108:	74 31       	cpi	r23, 0x14	; 20
     10a:	9a bd       	out	0x2a, r25	; 42
     10c:	56 83       	std	Z+6, r21	; 0x06
     10e:	3d da       	rcall	.-2950   	; 0xfffff58a <__eeprom_end+0xff7ef58a>
     110:	3d 00       	.word	0x003d	; ????
     112:	c7 7f       	andi	r28, 0xF7	; 247
     114:	11 be       	out	0x31, r1	; 49
     116:	d9 e4       	ldi	r29, 0x49	; 73
     118:	bb 4c       	sbci	r27, 0xCB	; 203
     11a:	3e 91       	ld	r19, -X
     11c:	6b aa       	std	Y+51, r6	; 0x33
     11e:	aa be       	out	0x3a, r10	; 58
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	3f 07       	cpc	r19, r31
     126:	2c 7a       	andi	r18, 0xAC	; 172
     128:	a5 ba       	out	0x15, r10	; 21
     12a:	6c c5       	rjmp	.+2776   	; 0xc04 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf+0x9c>
     12c:	90 da       	rcall	.-2784   	; 0xfffff64e <__eeprom_end+0xff7ef64e>
     12e:	3b 93       	.word	0x933b	; ????
     130:	65 fc       	sbrc	r6, 5
     132:	8b bc       	out	0x2b, r8	; 43
     134:	53 f8       	bld	r5, 3
     136:	10 fd       	sbrc	r17, 0
     138:	3c 56       	subi	r19, 0x6C	; 108
     13a:	92 83       	std	Z+2, r25	; 0x02
     13c:	4d bd       	out	0x2d, r20	; 45
     13e:	87 9d       	mul	r24, r7
     140:	3a b6       	in	r3, 0x3a	; 58
     142:	3d cb       	rjmp	.-2438   	; 0xfffff7be <__eeprom_end+0xff7ef7be>
     144:	c9 bf       	out	0x39, r28	; 57
     146:	5b be       	out	0x3b, r5	; 59
     148:	73 da       	rcall	.-2842   	; 0xfffff630 <__eeprom_end+0xff7ef630>
     14a:	0f c9       	rjmp	.-3554   	; 0xfffff36a <__eeprom_end+0xff7ef36a>
     14c:	3f 05       	cpc	r19, r15
     14e:	a8 4c       	sbci	r26, 0xC8	; 200
     150:	cd b2       	in	r12, 0x1d	; 29
     152:	d4 4e       	sbci	r29, 0xE4	; 228
     154:	b9 38       	cpi	r27, 0x89	; 137
     156:	36 a9       	ldd	r19, Z+54	; 0x36
     158:	02 0c       	add	r0, r2
     15a:	50 b9       	out	0x00, r21	; 0
     15c:	91 86       	std	Z+9, r9	; 0x09
     15e:	88 08       	sbc	r8, r8
     160:	3c a6       	std	Y+44, r3	; 0x2c
     162:	aa aa       	std	Y+50, r10	; 0x32
     164:	2a be       	out	0x3a, r2	; 58
     166:	00 00       	nop
     168:	00 80       	ld	r0, Z
     16a:	3f 08       	sbc	r3, r15
     16c:	00 00       	nop
     16e:	00 be       	out	0x30, r0	; 48
     170:	92 24       	eor	r9, r2
     172:	49 12       	cpse	r4, r25
     174:	3e ab       	std	Y+54, r19	; 0x36
     176:	aa aa       	std	Y+50, r10	; 0x32
     178:	2a be       	out	0x3a, r2	; 58
     17a:	cd cc       	rjmp	.-1638   	; 0xfffffb16 <__eeprom_end+0xff7efb16>
     17c:	cc 4c       	sbci	r28, 0xCC	; 204
     17e:	3e 00       	.word	0x003e	; ????
     180:	00 00       	nop
     182:	80 be       	out	0x30, r8	; 48
     184:	ab aa       	std	Y+51, r10	; 0x33
     186:	aa aa       	std	Y+50, r10	; 0x32
     188:	3e 00       	.word	0x003e	; ????
     18a:	00 00       	nop
     18c:	00 bf       	out	0x30, r16	; 48
     18e:	00 00       	nop
     190:	00 80       	ld	r0, Z
     192:	3f 00       	.word	0x003f	; ????
     194:	00 00       	nop
     196:	00 00       	nop
     198:	08 41       	sbci	r16, 0x18	; 24
     19a:	78 d3       	rcall	.+1776   	; 0x88c <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x7e>
     19c:	bb 43       	sbci	r27, 0x3B	; 59
     19e:	87 d1       	rcall	.+782    	; 0x4ae <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x20>
     1a0:	13 3d       	cpi	r17, 0xD3	; 211
     1a2:	19 0e       	add	r1, r25
     1a4:	3c c3       	rjmp	.+1656   	; 0x81e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x10>
     1a6:	bd 42       	sbci	r27, 0x2D	; 45
     1a8:	82 ad       	ldd	r24, Z+58	; 0x3a
     1aa:	2b 3e       	cpi	r18, 0xEB	; 235
     1ac:	68 ec       	ldi	r22, 0xC8	; 200
     1ae:	82 76       	andi	r24, 0x62	; 98
     1b0:	be d9       	rcall	.-3204   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     1b2:	8f e1       	ldi	r24, 0x1F	; 31
     1b4:	a9 3e       	cpi	r26, 0xE9	; 233
     1b6:	4c 80       	ldd	r4, Y+4	; 0x04
     1b8:	ef ff       	.word	0xffef	; ????
     1ba:	be 01       	movw	r22, r28
     1bc:	c4 ff       	sbrs	r28, 4
     1be:	7f 3f       	cpi	r23, 0xFF	; 255
     1c0:	00 00       	nop
     1c2:	00 00       	nop
     1c4:	00 07       	cpc	r16, r16
     1c6:	63 42       	sbci	r22, 0x23	; 35
     1c8:	36 b7       	in	r19, 0x36	; 54
     1ca:	9b d8       	rcall	.-3786   	; 0xfffff302 <__eeprom_end+0xff7ef302>
     1cc:	a7 1a       	sub	r10, r23
     1ce:	39 68       	ori	r19, 0x89	; 137
     1d0:	56 18       	sub	r5, r6
     1d2:	ae ba       	out	0x1e, r10	; 30
     1d4:	ab 55       	subi	r26, 0x5B	; 91
     1d6:	8c 1d       	adc	r24, r12
     1d8:	3c b7       	in	r19, 0x3c	; 60
     1da:	cc 57       	subi	r28, 0x7C	; 124
     1dc:	63 bd       	out	0x23, r22	; 35
     1de:	6d ed       	ldi	r22, 0xDD	; 221
     1e0:	fd 75       	andi	r31, 0x5D	; 93
     1e2:	3e f6       	brtc	.-114    	; 0x172 <__SREG__+0x133>
     1e4:	17 72       	andi	r17, 0x27	; 39
     1e6:	31 bf       	out	0x31, r19	; 49
     1e8:	00 00       	nop
     1ea:	00 80       	ld	r0, Z
     1ec:	3f 00       	.word	0x003f	; ????

000001ee <__trampolines_start>:
     1ee:	0c 94 64 2c 	jmp	0x58c8	; 0x58c8 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>
     1f2:	0c 94 5b 0f 	jmp	0x1eb6	; 0x1eb6 <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     1f6:	0c 94 e4 29 	jmp	0x53c8	; 0x53c8 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
     1fa:	0c 94 14 5b 	jmp	0xb628	; 0xb628 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>
     1fe:	0c 94 bc 30 	jmp	0x6178	; 0x6178 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>
     202:	0c 94 5c 2c 	jmp	0x58b8	; 0x58b8 <_ZN10helicopter8messages11SyncMessageD0Ev>
     206:	0c 94 49 56 	jmp	0xac92	; 0xac92 <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>
     20a:	0c 94 57 59 	jmp	0xb2ae	; 0xb2ae <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>
     20e:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>
     212:	0c 94 8d 5a 	jmp	0xb51a	; 0xb51a <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>
     216:	0c 94 5c 28 	jmp	0x50b8	; 0x50b8 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>
     21a:	0c 94 51 59 	jmp	0xb2a2	; 0xb2a2 <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>
     21e:	0c 94 4b 2c 	jmp	0x5896	; 0x5896 <_ZN10helicopter8messages11SyncMessage8getBytesEv>
     222:	0c 94 c4 24 	jmp	0x4988	; 0x4988 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
     226:	0c 94 93 5a 	jmp	0xb526	; 0xb526 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>
     22a:	0c 94 86 0a 	jmp	0x150c	; 0x150c <_ZN10helicopter7drivers12SerialDriver8transmitEf>
     22e:	0c 94 2a 60 	jmp	0xc054	; 0xc054 <_ZN10helicopter5tasks4Task11runTaskImplEv>
     232:	0c 94 c8 0a 	jmp	0x1590	; 0x1590 <_ZN10helicopter7drivers12SerialDriver8transmitEi>
     236:	0c 94 ea 0a 	jmp	0x15d4	; 0x15d4 <_ZN10helicopter7drivers12SerialDriver8transmitEm>
     23a:	0c 94 5a 60 	jmp	0xc0b4	; 0xc0b4 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>
     23e:	0c 94 2b 60 	jmp	0xc056	; 0xc056 <_ZN10helicopter5tasks4TaskD1Ev>
     242:	0c 94 39 2c 	jmp	0x5872	; 0x5872 <_ZN10helicopter8messages11SyncMessageD1Ev>
     246:	0c 94 62 0f 	jmp	0x1ec4	; 0x1ec4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>
     24a:	0c 94 80 0a 	jmp	0x1500	; 0x1500 <_ZN10helicopter7drivers12SerialDriverD1Ev>
     24e:	0c 94 f6 59 	jmp	0xb3ec	; 0xb3ec <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>
     252:	0c 94 8a 0c 	jmp	0x1914	; 0x1914 <_ZN10helicopter7drivers12SerialDriver7receiveERh>
     256:	0c 94 99 10 	jmp	0x2132	; 0x2132 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>
     25a:	0c 94 7a 56 	jmp	0xacf4	; 0xacf4 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>
     25e:	0c 94 39 0b 	jmp	0x1672	; 0x1672 <_ZN10helicopter7drivers12SerialDriver8transmitEl>
     262:	0c 94 6a 28 	jmp	0x50d4	; 0x50d4 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>
     266:	0c 94 5f 59 	jmp	0xb2be	; 0xb2be <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>
     26a:	0c 94 ab 26 	jmp	0x4d56	; 0x4d56 <_ZN10helicopter8messages17SensorDataMessageD0Ev>
     26e:	0c 94 98 26 	jmp	0x4d30	; 0x4d30 <_ZN10helicopter8messages7Message12buildMessageEPh>
     272:	0c 94 52 60 	jmp	0xc0a4	; 0xc0a4 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>
     276:	0c 94 6a 2c 	jmp	0x58d4	; 0x58d4 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>
     27a:	0c 94 77 5b 	jmp	0xb6ee	; 0xb6ee <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>
     27e:	0c 94 4c 60 	jmp	0xc098	; 0xc098 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>
     282:	0c 94 b3 26 	jmp	0x4d66	; 0x4d66 <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>
     286:	0c 94 3a 23 	jmp	0x4674	; 0x4674 <_ZN10helicopter8messages14ControlMessageD0Ev>
     28a:	0c 94 0f 55 	jmp	0xaa1e	; 0xaa1e <_ZN10helicopter5tasks14NavigationTaskD0Ev>
     28e:	0c 94 cc 58 	jmp	0xb198	; 0xb198 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>
     292:	0c 94 95 26 	jmp	0x4d2a	; 0x4d2a <_ZN10helicopter8messages7Message8getBytesEv>
     296:	0c 94 a2 23 	jmp	0x4744	; 0x4744 <_ZN10helicopter8messages12GainsMessageD0Ev>
     29a:	0c 94 fc 0d 	jmp	0x1bf8	; 0x1bf8 <_ZN10helicopter7drivers12SerialDriverD0Ev>
     29e:	0c 94 4d 0d 	jmp	0x1a9a	; 0x1a9a <_ZN10helicopter7drivers12SerialDriver4initEv>
     2a2:	0c 94 0c 5b 	jmp	0xb618	; 0xb618 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>
     2a6:	0c 94 d2 58 	jmp	0xb1a4	; 0xb1a4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>
     2aa:	0c 94 39 60 	jmp	0xc072	; 0xc072 <_ZN10helicopter5tasks4TaskD0Ev>
     2ae:	0c 94 09 55 	jmp	0xaa12	; 0xaa12 <_ZN10helicopter5tasks14NavigationTaskD1Ev>
     2b2:	0c 94 9d 56 	jmp	0xad3a	; 0xad3a <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>
     2b6:	0c 94 3f 2c 	jmp	0x587e	; 0x587e <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>
     2ba:	0c 94 fc 59 	jmp	0xb3f8	; 0xb3f8 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>
     2be:	0c 94 7d 5b 	jmp	0xb6fa	; 0xb6fa <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>
     2c2:	0c 94 06 5b 	jmp	0xb60c	; 0xb60c <_ZN10helicopter5tasks16ServoControlTaskD1Ev>
     2c6:	0c 94 74 56 	jmp	0xace8	; 0xace8 <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>
     2ca:	0c 94 62 28 	jmp	0x50c4	; 0x50c4 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>
     2ce:	0c 94 a3 56 	jmp	0xad46	; 0xad46 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>
     2d2:	0c 94 31 60 	jmp	0xc062	; 0xc062 <_ZN10helicopter5tasks4Task7runTaskEv>
     2d6:	0c 94 51 56 	jmp	0xaca2	; 0xaca2 <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>
     2da:	0c 94 49 27 	jmp	0x4e92	; 0x4e92 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
     2de:	0c 94 da 58 	jmp	0xb1b4	; 0xb1b4 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>
     2e2:	0c 94 42 23 	jmp	0x4684	; 0x4684 <_ZN10helicopter8messages14ControlMessage8getBytesEv>
     2e6:	0c 94 9b 5a 	jmp	0xb536	; 0xb536 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>
     2ea:	0c 94 8f 26 	jmp	0x4d1e	; 0x4d1e <_ZN10helicopter8messages7MessageD1Ev>
     2ee:	0c 94 34 23 	jmp	0x4668	; 0x4668 <_ZN10helicopter8messages14ControlMessageD1Ev>
     2f2:	0c 94 71 23 	jmp	0x46e2	; 0x46e2 <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>
     2f6:	0c 94 aa 23 	jmp	0x4754	; 0x4754 <_ZN10helicopter8messages12GainsMessage8getBytesEv>
     2fa:	0c 94 99 26 	jmp	0x4d32	; 0x4d32 <_ZN10helicopter8messages7MessageD0Ev>
     2fe:	0c 94 a5 26 	jmp	0x4d4a	; 0x4d4a <_ZN10helicopter8messages17SensorDataMessageD1Ev>
     302:	0c 94 17 55 	jmp	0xaa2e	; 0xaa2e <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>
     306:	0c 94 43 56 	jmp	0xac86	; 0xac86 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>
     30a:	0c 94 9c 23 	jmp	0x4738	; 0x4738 <_ZN10helicopter8messages12GainsMessageD1Ev>
     30e:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <_ZN10helicopter7drivers12SerialDriver8transmitEx>
     312:	0c 94 85 5b 	jmp	0xb70a	; 0xb70a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>
     316:	0c 94 77 10 	jmp	0x20ee	; 0x20ee <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>
     31a:	0c 94 9f 10 	jmp	0x213e	; 0x213e <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>
     31e:	0c 94 f5 0c 	jmp	0x19ea	; 0x19ea <_ZN10helicopter7drivers12SerialDriver8transmitEh>
     322:	0c 94 6a 10 	jmp	0x20d4	; 0x20d4 <_ZN10helicopter5tasks12FlashLEDTask4initEv>
     326:	0c 94 04 5a 	jmp	0xb408	; 0xb408 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>
     32a:	0c 94 82 56 	jmp	0xad04	; 0xad04 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>
     32e:	0c 94 ab 56 	jmp	0xad56	; 0xad56 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>
     332:	0c 94 08 55 	jmp	0xaa10	; 0xaa10 <_ZN10helicopter5tasks4Task4initEv>

00000336 <__ctors_start>:
     336:	5b 0f       	add	r21, r27

00000338 <__ctors_end>:
     338:	62 0f       	add	r22, r18

0000033a <__dtors_end>:
     33a:	11 24       	eor	r1, r1
     33c:	1f be       	out	0x3f, r1	; 63
     33e:	cf ef       	ldi	r28, 0xFF	; 255
     340:	d1 e2       	ldi	r29, 0x21	; 33
     342:	de bf       	out	0x3e, r29	; 62
     344:	cd bf       	out	0x3d, r28	; 61
     346:	00 e0       	ldi	r16, 0x00	; 0
     348:	0c bf       	out	0x3c, r16	; 60

0000034a <__do_copy_data>:
     34a:	13 e0       	ldi	r17, 0x03	; 3
     34c:	a0 e0       	ldi	r26, 0x00	; 0
     34e:	b2 e0       	ldi	r27, 0x02	; 2
     350:	e2 e0       	ldi	r30, 0x02	; 2
     352:	f3 ee       	ldi	r31, 0xE3	; 227
     354:	00 e0       	ldi	r16, 0x00	; 0
     356:	0b bf       	out	0x3b, r16	; 59
     358:	02 c0       	rjmp	.+4      	; 0x35e <__do_copy_data+0x14>
     35a:	07 90       	elpm	r0, Z+
     35c:	0d 92       	st	X+, r0
     35e:	ae 38       	cpi	r26, 0x8E	; 142
     360:	b1 07       	cpc	r27, r17
     362:	d9 f7       	brne	.-10     	; 0x35a <__do_copy_data+0x10>

00000364 <__do_clear_bss>:
     364:	20 e1       	ldi	r18, 0x10	; 16
     366:	ae e8       	ldi	r26, 0x8E	; 142
     368:	b3 e0       	ldi	r27, 0x03	; 3
     36a:	01 c0       	rjmp	.+2      	; 0x36e <.do_clear_bss_start>

0000036c <.do_clear_bss_loop>:
     36c:	1d 92       	st	X+, r1

0000036e <.do_clear_bss_start>:
     36e:	a0 38       	cpi	r26, 0x80	; 128
     370:	b2 07       	cpc	r27, r18
     372:	e1 f7       	brne	.-8      	; 0x36c <.do_clear_bss_loop>

00000374 <__do_global_ctors>:
     374:	13 e0       	ldi	r17, 0x03	; 3
     376:	c8 e3       	ldi	r28, 0x38	; 56
     378:	d3 e0       	ldi	r29, 0x03	; 3
     37a:	00 e0       	ldi	r16, 0x00	; 0
     37c:	06 c0       	rjmp	.+12     	; 0x38a <__do_global_ctors+0x16>
     37e:	22 97       	sbiw	r28, 0x02	; 2
     380:	01 09       	sbc	r16, r1
     382:	fe 01       	movw	r30, r28
     384:	0b bf       	out	0x3b, r16	; 59
     386:	0e 94 e5 6f 	call	0xdfca	; 0xdfca <__tablejump_elpm__>
     38a:	c6 33       	cpi	r28, 0x36	; 54
     38c:	d1 07       	cpc	r29, r17
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	08 07       	cpc	r16, r24
     392:	a9 f7       	brne	.-22     	; 0x37e <__do_global_ctors+0xa>
     394:	0e 94 3b 14 	call	0x2876	; 0x2876 <main>
     398:	0c 94 6f 71 	jmp	0xe2de	; 0xe2de <__do_global_dtors>

0000039c <__bad_interrupt>:
     39c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>:
#include <avr/interrupt.h>

using namespace helicopter::buffer;

bool CircularBuffer::enqueue(byte val)
{	
     3a0:	fc 01       	movw	r30, r24
	PORTA &= ~(1<<PA5);
}
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     3a2:	20 85       	ldd	r18, Z+8	; 0x08
     3a4:	31 85       	ldd	r19, Z+9	; 0x09
     3a6:	82 81       	ldd	r24, Z+2	; 0x02
     3a8:	93 81       	ldd	r25, Z+3	; 0x03
     3aa:	28 17       	cp	r18, r24
     3ac:	39 07       	cpc	r19, r25
     3ae:	d4 f4       	brge	.+52     	; 0x3e4 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x44>
	{
		return false;
	}
cli();		
     3b0:	f8 94       	cli
	buffer[tailIndex++] = val;
     3b2:	86 81       	ldd	r24, Z+6	; 0x06
     3b4:	97 81       	ldd	r25, Z+7	; 0x07
     3b6:	a0 81       	ld	r26, Z
     3b8:	b1 81       	ldd	r27, Z+1	; 0x01
     3ba:	a8 0f       	add	r26, r24
     3bc:	b9 1f       	adc	r27, r25
     3be:	6c 93       	st	X, r22
     3c0:	01 96       	adiw	r24, 0x01	; 1
     3c2:	97 83       	std	Z+7, r25	; 0x07
     3c4:	86 83       	std	Z+6, r24	; 0x06
	
	if (tailIndex >= bufferSize)
     3c6:	22 81       	ldd	r18, Z+2	; 0x02
     3c8:	33 81       	ldd	r19, Z+3	; 0x03
     3ca:	82 17       	cp	r24, r18
     3cc:	93 07       	cpc	r25, r19
     3ce:	14 f0       	brlt	.+4      	; 0x3d4 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh+0x34>
	{
		tailIndex = 0;
     3d0:	17 82       	std	Z+7, r1	; 0x07
     3d2:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     3d4:	80 85       	ldd	r24, Z+8	; 0x08
     3d6:	91 85       	ldd	r25, Z+9	; 0x09
     3d8:	01 96       	adiw	r24, 0x01	; 1
     3da:	91 87       	std	Z+9, r25	; 0x09
     3dc:	80 87       	std	Z+8, r24	; 0x08
	
	
sei();
     3de:	78 94       	sei
	return true;
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	08 95       	ret
*/

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     3e4:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	
sei();
	return true;
}
     3e6:	08 95       	ret

000003e8 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>:

bool CircularBuffer::dequeue(byte &val)
{
     3e8:	fc 01       	movw	r30, r24
if ((tailIndex == headIndex) && bytesInQueue != 0)
{
	PORTA &= ~(1<<PA5);
}
*/
	val = 0;
     3ea:	db 01       	movw	r26, r22
     3ec:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     3ee:	80 85       	ldd	r24, Z+8	; 0x08
     3f0:	91 85       	ldd	r25, Z+9	; 0x09
     3f2:	89 2b       	or	r24, r25
     3f4:	e1 f0       	breq	.+56     	; 0x42e <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x46>
	{
		return false;
	}
	cli();	
     3f6:	f8 94       	cli
	val = buffer[headIndex++];
     3f8:	84 81       	ldd	r24, Z+4	; 0x04
     3fa:	95 81       	ldd	r25, Z+5	; 0x05
     3fc:	a0 81       	ld	r26, Z
     3fe:	b1 81       	ldd	r27, Z+1	; 0x01
     400:	a8 0f       	add	r26, r24
     402:	b9 1f       	adc	r27, r25
     404:	2c 91       	ld	r18, X
     406:	db 01       	movw	r26, r22
     408:	2c 93       	st	X, r18
     40a:	01 96       	adiw	r24, 0x01	; 1
     40c:	95 83       	std	Z+5, r25	; 0x05
     40e:	84 83       	std	Z+4, r24	; 0x04
	
	if (headIndex >= bufferSize)
     410:	22 81       	ldd	r18, Z+2	; 0x02
     412:	33 81       	ldd	r19, Z+3	; 0x03
     414:	82 17       	cp	r24, r18
     416:	93 07       	cpc	r25, r19
     418:	14 f0       	brlt	.+4      	; 0x41e <_ZN10helicopter6buffer14CircularBuffer7dequeueERh+0x36>
	{
		headIndex = 0;
     41a:	15 82       	std	Z+5, r1	; 0x05
     41c:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     41e:	80 85       	ldd	r24, Z+8	; 0x08
     420:	91 85       	ldd	r25, Z+9	; 0x09
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	91 87       	std	Z+9, r25	; 0x09
     426:	80 87       	std	Z+8, r24	; 0x08
	
	sei();
     428:	78 94       	sei
	return true;
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     42e:	80 e0       	ldi	r24, 0x00	; 0
	
	bytesInQueue--;
	
	sei();
	return true;
}
     430:	08 95       	ret

00000432 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>:



bool CircularBuffer::enqueueInt(byte val)
{
     432:	fc 01       	movw	r30, r24

	if ((tailIndex == headIndex) && bytesInQueue != 0)
     434:	26 81       	ldd	r18, Z+6	; 0x06
     436:	37 81       	ldd	r19, Z+7	; 0x07
     438:	84 81       	ldd	r24, Z+4	; 0x04
     43a:	95 81       	ldd	r25, Z+5	; 0x05
     43c:	28 17       	cp	r18, r24
     43e:	39 07       	cpc	r19, r25
     440:	29 f4       	brne	.+10     	; 0x44c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
     442:	80 85       	ldd	r24, Z+8	; 0x08
     444:	91 85       	ldd	r25, Z+9	; 0x09
     446:	89 2b       	or	r24, r25
     448:	09 f0       	breq	.+2      	; 0x44c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     44a:	15 98       	cbi	0x02, 5	; 2
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
     44c:	20 85       	ldd	r18, Z+8	; 0x08
     44e:	31 85       	ldd	r19, Z+9	; 0x09
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
     454:	28 17       	cp	r18, r24
     456:	39 07       	cpc	r19, r25
     458:	c4 f4       	brge	.+48     	; 0x48a <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x58>
	{
		return false;
	}
	
	buffer[tailIndex++] = val;
     45a:	86 81       	ldd	r24, Z+6	; 0x06
     45c:	97 81       	ldd	r25, Z+7	; 0x07
     45e:	a0 81       	ld	r26, Z
     460:	b1 81       	ldd	r27, Z+1	; 0x01
     462:	a8 0f       	add	r26, r24
     464:	b9 1f       	adc	r27, r25
     466:	6c 93       	st	X, r22
     468:	01 96       	adiw	r24, 0x01	; 1
     46a:	97 83       	std	Z+7, r25	; 0x07
     46c:	86 83       	std	Z+6, r24	; 0x06
	
	if (tailIndex >= bufferSize)
     46e:	22 81       	ldd	r18, Z+2	; 0x02
     470:	33 81       	ldd	r19, Z+3	; 0x03
     472:	82 17       	cp	r24, r18
     474:	93 07       	cpc	r25, r19
     476:	14 f0       	brlt	.+4      	; 0x47c <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh+0x4a>
	{
		tailIndex = 0;
     478:	17 82       	std	Z+7, r1	; 0x07
     47a:	16 82       	std	Z+6, r1	; 0x06
	}
	
	bytesInQueue++;
     47c:	80 85       	ldd	r24, Z+8	; 0x08
     47e:	91 85       	ldd	r25, Z+9	; 0x09
     480:	01 96       	adiw	r24, 0x01	; 1
     482:	91 87       	std	Z+9, r25	; 0x09
     484:	80 87       	std	Z+8, r24	; 0x08
	
	

	return true;
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	08 95       	ret
	}

	//if the buffer is full, return false.
	if (bytesInQueue >= bufferSize)
	{
		return false;
     48a:	80 e0       	ldi	r24, 0x00	; 0
	bytesInQueue++;
	
	

	return true;
}
     48c:	08 95       	ret

0000048e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>:

bool CircularBuffer::dequeueInt(byte &val)
{
     48e:	fc 01       	movw	r30, r24
	if ((tailIndex == headIndex) && bytesInQueue != 0)
     490:	26 81       	ldd	r18, Z+6	; 0x06
     492:	37 81       	ldd	r19, Z+7	; 0x07
     494:	84 81       	ldd	r24, Z+4	; 0x04
     496:	95 81       	ldd	r25, Z+5	; 0x05
     498:	28 17       	cp	r18, r24
     49a:	39 07       	cpc	r19, r25
     49c:	29 f4       	brne	.+10     	; 0x4a8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
     49e:	80 85       	ldd	r24, Z+8	; 0x08
     4a0:	91 85       	ldd	r25, Z+9	; 0x09
     4a2:	89 2b       	or	r24, r25
     4a4:	09 f0       	breq	.+2      	; 0x4a8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x1a>
	{
		PORTA &= ~(1<<PA5);
     4a6:	15 98       	cbi	0x02, 5	; 2
	}
	val = 0;
     4a8:	db 01       	movw	r26, r22
     4aa:	1c 92       	st	X, r1
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
     4ac:	80 85       	ldd	r24, Z+8	; 0x08
     4ae:	91 85       	ldd	r25, Z+9	; 0x09
     4b0:	89 2b       	or	r24, r25
     4b2:	d1 f0       	breq	.+52     	; 0x4e8 <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x5a>
	{
		return false;
	}
	
	val = buffer[headIndex++];
     4b4:	84 81       	ldd	r24, Z+4	; 0x04
     4b6:	95 81       	ldd	r25, Z+5	; 0x05
     4b8:	a0 81       	ld	r26, Z
     4ba:	b1 81       	ldd	r27, Z+1	; 0x01
     4bc:	a8 0f       	add	r26, r24
     4be:	b9 1f       	adc	r27, r25
     4c0:	2c 91       	ld	r18, X
     4c2:	db 01       	movw	r26, r22
     4c4:	2c 93       	st	X, r18
     4c6:	01 96       	adiw	r24, 0x01	; 1
     4c8:	95 83       	std	Z+5, r25	; 0x05
     4ca:	84 83       	std	Z+4, r24	; 0x04
	
	if (headIndex >= bufferSize)
     4cc:	22 81       	ldd	r18, Z+2	; 0x02
     4ce:	33 81       	ldd	r19, Z+3	; 0x03
     4d0:	82 17       	cp	r24, r18
     4d2:	93 07       	cpc	r25, r19
     4d4:	14 f0       	brlt	.+4      	; 0x4da <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh+0x4c>
	{
		headIndex = 0;
     4d6:	15 82       	std	Z+5, r1	; 0x05
     4d8:	14 82       	std	Z+4, r1	; 0x04
	}
	
	bytesInQueue--;
     4da:	80 85       	ldd	r24, Z+8	; 0x08
     4dc:	91 85       	ldd	r25, Z+9	; 0x09
     4de:	01 97       	sbiw	r24, 0x01	; 1
     4e0:	91 87       	std	Z+9, r25	; 0x09
     4e2:	80 87       	std	Z+8, r24	; 0x08
	
	return true;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	08 95       	ret
	val = 0;
	
	//return false if there is no data to return.
	if (bytesInQueue == 0)
	{
		return false;
     4e8:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	bytesInQueue--;
	
	return true;
}
     4ea:	08 95       	ret

000004ec <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>:
#include "MatrixUtil.h"

using namespace helicopter::controller;
using namespace helicopter::util;

PIDController::PIDController(SystemModel *model): 
     4ec:	fc 01       	movw	r30, r24
minMainRotorServoControlValue(0),
maxMainRotorServoControlValue(0),

intervalPeriodSecs(0),
controlMaxValue(0),
controlMinValue(0)
     4ee:	71 83       	std	Z+1, r23	; 0x01
     4f0:	60 83       	st	Z, r22
     4f2:	12 82       	std	Z+2, r1	; 0x02
     4f4:	13 82       	std	Z+3, r1	; 0x03
     4f6:	14 82       	std	Z+4, r1	; 0x04
     4f8:	15 82       	std	Z+5, r1	; 0x05
     4fa:	16 82       	std	Z+6, r1	; 0x06
     4fc:	17 82       	std	Z+7, r1	; 0x07
     4fe:	10 86       	std	Z+8, r1	; 0x08
     500:	11 86       	std	Z+9, r1	; 0x09
     502:	12 86       	std	Z+10, r1	; 0x0a
     504:	13 86       	std	Z+11, r1	; 0x0b
     506:	14 86       	std	Z+12, r1	; 0x0c
     508:	15 86       	std	Z+13, r1	; 0x0d
     50a:	16 86       	std	Z+14, r1	; 0x0e
     50c:	17 86       	std	Z+15, r1	; 0x0f
     50e:	10 8a       	std	Z+16, r1	; 0x10
     510:	11 8a       	std	Z+17, r1	; 0x11
     512:	12 8a       	std	Z+18, r1	; 0x12
     514:	13 8a       	std	Z+19, r1	; 0x13
     516:	14 8a       	std	Z+20, r1	; 0x14
     518:	15 8a       	std	Z+21, r1	; 0x15
     51a:	16 8a       	std	Z+22, r1	; 0x16
     51c:	17 8a       	std	Z+23, r1	; 0x17
     51e:	10 8e       	std	Z+24, r1	; 0x18
     520:	11 8e       	std	Z+25, r1	; 0x19
     522:	12 8e       	std	Z+26, r1	; 0x1a
     524:	13 8e       	std	Z+27, r1	; 0x1b
     526:	14 8e       	std	Z+28, r1	; 0x1c
     528:	15 8e       	std	Z+29, r1	; 0x1d
     52a:	16 8e       	std	Z+30, r1	; 0x1e
     52c:	17 8e       	std	Z+31, r1	; 0x1f
     52e:	10 a2       	std	Z+32, r1	; 0x20
     530:	11 a2       	std	Z+33, r1	; 0x21
     532:	12 a2       	std	Z+34, r1	; 0x22
     534:	13 a2       	std	Z+35, r1	; 0x23
     536:	14 a2       	std	Z+36, r1	; 0x24
     538:	15 a2       	std	Z+37, r1	; 0x25
     53a:	12 a6       	std	Z+42, r1	; 0x2a
     53c:	13 a6       	std	Z+43, r1	; 0x2b
     53e:	14 a6       	std	Z+44, r1	; 0x2c
     540:	15 a6       	std	Z+45, r1	; 0x2d
     542:	16 a6       	std	Z+46, r1	; 0x2e
     544:	17 a6       	std	Z+47, r1	; 0x2f
     546:	10 aa       	std	Z+48, r1	; 0x30
     548:	11 aa       	std	Z+49, r1	; 0x31
     54a:	12 aa       	std	Z+50, r1	; 0x32
     54c:	13 aa       	std	Z+51, r1	; 0x33
     54e:	14 aa       	std	Z+52, r1	; 0x34
     550:	15 aa       	std	Z+53, r1	; 0x35
     552:	16 aa       	std	Z+54, r1	; 0x36
     554:	17 aa       	std	Z+55, r1	; 0x37
     556:	10 ae       	std	Z+56, r1	; 0x38
     558:	11 ae       	std	Z+57, r1	; 0x39
     55a:	12 ae       	std	Z+58, r1	; 0x3a
     55c:	13 ae       	std	Z+59, r1	; 0x3b
     55e:	14 ae       	std	Z+60, r1	; 0x3c
     560:	15 ae       	std	Z+61, r1	; 0x3d
     562:	dc 01       	movw	r26, r24
     564:	ae 5b       	subi	r26, 0xBE	; 190
     566:	bf 4f       	sbci	r27, 0xFF	; 255
     568:	1d 92       	st	X+, r1
     56a:	1d 92       	st	X+, r1
     56c:	1d 92       	st	X+, r1
     56e:	1c 92       	st	X, r1
     570:	13 97       	sbiw	r26, 0x03	; 3
     572:	dc 01       	movw	r26, r24
     574:	aa 5b       	subi	r26, 0xBA	; 186
     576:	bf 4f       	sbci	r27, 0xFF	; 255
     578:	1d 92       	st	X+, r1
     57a:	1d 92       	st	X+, r1
     57c:	1d 92       	st	X+, r1
     57e:	1c 92       	st	X, r1
     580:	13 97       	sbiw	r26, 0x03	; 3
     582:	dc 01       	movw	r26, r24
     584:	a6 5b       	subi	r26, 0xB6	; 182
     586:	bf 4f       	sbci	r27, 0xFF	; 255
     588:	1d 92       	st	X+, r1
     58a:	1d 92       	st	X+, r1
     58c:	1d 92       	st	X+, r1
     58e:	1c 92       	st	X, r1
     590:	13 97       	sbiw	r26, 0x03	; 3
     592:	dc 01       	movw	r26, r24
     594:	a2 5b       	subi	r26, 0xB2	; 178
     596:	bf 4f       	sbci	r27, 0xFF	; 255
     598:	1d 92       	st	X+, r1
     59a:	1d 92       	st	X+, r1
     59c:	1d 92       	st	X+, r1
     59e:	1c 92       	st	X, r1
     5a0:	13 97       	sbiw	r26, 0x03	; 3
     5a2:	dc 01       	movw	r26, r24
     5a4:	ae 5a       	subi	r26, 0xAE	; 174
     5a6:	bf 4f       	sbci	r27, 0xFF	; 255
     5a8:	1d 92       	st	X+, r1
     5aa:	1d 92       	st	X+, r1
     5ac:	1d 92       	st	X+, r1
     5ae:	1c 92       	st	X, r1
     5b0:	13 97       	sbiw	r26, 0x03	; 3
     5b2:	dc 01       	movw	r26, r24
     5b4:	aa 5a       	subi	r26, 0xAA	; 170
     5b6:	bf 4f       	sbci	r27, 0xFF	; 255
     5b8:	1d 92       	st	X+, r1
     5ba:	1d 92       	st	X+, r1
     5bc:	1d 92       	st	X+, r1
     5be:	1c 92       	st	X, r1
     5c0:	13 97       	sbiw	r26, 0x03	; 3
     5c2:	dc 01       	movw	r26, r24
     5c4:	a6 5a       	subi	r26, 0xA6	; 166
     5c6:	bf 4f       	sbci	r27, 0xFF	; 255
     5c8:	1d 92       	st	X+, r1
     5ca:	1d 92       	st	X+, r1
     5cc:	1d 92       	st	X+, r1
     5ce:	1c 92       	st	X, r1
     5d0:	13 97       	sbiw	r26, 0x03	; 3
     5d2:	dc 01       	movw	r26, r24
     5d4:	a2 5a       	subi	r26, 0xA2	; 162
     5d6:	bf 4f       	sbci	r27, 0xFF	; 255
     5d8:	1d 92       	st	X+, r1
     5da:	1d 92       	st	X+, r1
     5dc:	1d 92       	st	X+, r1
     5de:	1c 92       	st	X, r1
     5e0:	13 97       	sbiw	r26, 0x03	; 3
     5e2:	dc 01       	movw	r26, r24
     5e4:	ae 59       	subi	r26, 0x9E	; 158
     5e6:	bf 4f       	sbci	r27, 0xFF	; 255
     5e8:	1d 92       	st	X+, r1
     5ea:	1d 92       	st	X+, r1
     5ec:	1d 92       	st	X+, r1
     5ee:	1c 92       	st	X, r1
     5f0:	13 97       	sbiw	r26, 0x03	; 3
     5f2:	dc 01       	movw	r26, r24
     5f4:	aa 59       	subi	r26, 0x9A	; 154
     5f6:	bf 4f       	sbci	r27, 0xFF	; 255
     5f8:	1d 92       	st	X+, r1
     5fa:	1d 92       	st	X+, r1
     5fc:	1d 92       	st	X+, r1
     5fe:	1c 92       	st	X, r1
     600:	13 97       	sbiw	r26, 0x03	; 3
     602:	dc 01       	movw	r26, r24
     604:	a6 59       	subi	r26, 0x96	; 150
     606:	bf 4f       	sbci	r27, 0xFF	; 255
     608:	1d 92       	st	X+, r1
     60a:	1d 92       	st	X+, r1
     60c:	1d 92       	st	X+, r1
     60e:	1c 92       	st	X, r1
     610:	13 97       	sbiw	r26, 0x03	; 3
     612:	dc 01       	movw	r26, r24
     614:	a2 59       	subi	r26, 0x92	; 146
     616:	bf 4f       	sbci	r27, 0xFF	; 255
     618:	1d 92       	st	X+, r1
     61a:	1d 92       	st	X+, r1
     61c:	1d 92       	st	X+, r1
     61e:	1c 92       	st	X, r1
     620:	13 97       	sbiw	r26, 0x03	; 3
     622:	dc 01       	movw	r26, r24
     624:	ae 57       	subi	r26, 0x7E	; 126
     626:	bf 4f       	sbci	r27, 0xFF	; 255
     628:	1d 92       	st	X+, r1
     62a:	1d 92       	st	X+, r1
     62c:	1d 92       	st	X+, r1
     62e:	1c 92       	st	X, r1
     630:	13 97       	sbiw	r26, 0x03	; 3
     632:	dc 01       	movw	r26, r24
     634:	aa 57       	subi	r26, 0x7A	; 122
     636:	bf 4f       	sbci	r27, 0xFF	; 255
     638:	1d 92       	st	X+, r1
     63a:	1d 92       	st	X+, r1
     63c:	1d 92       	st	X+, r1
     63e:	1c 92       	st	X, r1
     640:	13 97       	sbiw	r26, 0x03	; 3
     642:	e6 57       	subi	r30, 0x76	; 118
     644:	ff 4f       	sbci	r31, 0xFF	; 255
     646:	10 82       	st	Z, r1
     648:	11 82       	std	Z+1, r1	; 0x01
     64a:	12 82       	std	Z+2, r1	; 0x02
     64c:	13 82       	std	Z+3, r1	; 0x03
     64e:	08 95       	ret

00000650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>:




float PIDController::calculateOuterLoopControlValue(float proportionalError, float velocityError, float integral, float proportionalGain, float derivativeGain, int directionFactor)
{
     650:	4f 92       	push	r4
     652:	5f 92       	push	r5
     654:	6f 92       	push	r6
     656:	7f 92       	push	r7
     658:	8f 92       	push	r8
     65a:	9f 92       	push	r9
     65c:	af 92       	push	r10
     65e:	bf 92       	push	r11
     660:	cf 92       	push	r12
     662:	df 92       	push	r13
     664:	ef 92       	push	r14
     666:	ff 92       	push	r15
     668:	0f 93       	push	r16
     66a:	1f 93       	push	r17
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	cd b7       	in	r28, 0x3d	; 61
     672:	de b7       	in	r29, 0x3e	; 62
     674:	28 97       	sbiw	r28, 0x08	; 8
     676:	0f b6       	in	r0, 0x3f	; 63
     678:	f8 94       	cli
     67a:	de bf       	out	0x3e, r29	; 62
     67c:	0f be       	out	0x3f, r0	; 63
     67e:	cd bf       	out	0x3d, r28	; 61
     680:	2a 01       	movw	r4, r20
     682:	3b 01       	movw	r6, r22
     684:	09 83       	std	Y+1, r16	; 0x01
     686:	1a 83       	std	Y+2, r17	; 0x02
     688:	2b 83       	std	Y+3, r18	; 0x03
     68a:	3c 83       	std	Y+4, r19	; 0x04
	float controlValue = 0;
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
     68c:	68 a1       	ldd	r22, Y+32	; 0x20
     68e:	79 a1       	ldd	r23, Y+33	; 0x21
     690:	88 27       	eor	r24, r24
     692:	77 fd       	sbrc	r23, 7
     694:	80 95       	com	r24
     696:	98 2f       	mov	r25, r24
     698:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
     69c:	6d 83       	std	Y+5, r22	; 0x05
     69e:	7e 83       	std	Y+6, r23	; 0x06
     6a0:	8f 83       	std	Y+7, r24	; 0x07
     6a2:	98 87       	std	Y+8, r25	; 0x08
     6a4:	a5 01       	movw	r20, r10
     6a6:	94 01       	movw	r18, r8
     6a8:	c3 01       	movw	r24, r6
     6aa:	b2 01       	movw	r22, r4
     6ac:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     6b0:	a7 01       	movw	r20, r14
     6b2:	96 01       	movw	r18, r12
     6b4:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     6b8:	4b 01       	movw	r8, r22
     6ba:	5c 01       	movw	r10, r24
     6bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6be:	3d 8d       	ldd	r19, Y+29	; 0x1d
     6c0:	4e 8d       	ldd	r20, Y+30	; 0x1e
     6c2:	5f 8d       	ldd	r21, Y+31	; 0x1f
     6c4:	69 81       	ldd	r22, Y+1	; 0x01
     6c6:	7a 81       	ldd	r23, Y+2	; 0x02
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	9c 81       	ldd	r25, Y+4	; 0x04
     6cc:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     6d0:	9b 01       	movw	r18, r22
     6d2:	ac 01       	movw	r20, r24
     6d4:	c5 01       	movw	r24, r10
     6d6:	b4 01       	movw	r22, r8
     6d8:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     6dc:	9b 01       	movw	r18, r22
     6de:	ac 01       	movw	r20, r24
     6e0:	6d 81       	ldd	r22, Y+5	; 0x05
     6e2:	7e 81       	ldd	r23, Y+6	; 0x06
     6e4:	8f 81       	ldd	r24, Y+7	; 0x07
     6e6:	98 85       	ldd	r25, Y+8	; 0x08
     6e8:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
	
	controlValue = directionFactor * (integral  + proportionalError * proportionalGain + velocityError * derivativeGain);
	
	return controlValue;
	*/
}
     6ec:	28 96       	adiw	r28, 0x08	; 8
     6ee:	0f b6       	in	r0, 0x3f	; 63
     6f0:	f8 94       	cli
     6f2:	de bf       	out	0x3e, r29	; 62
     6f4:	0f be       	out	0x3f, r0	; 63
     6f6:	cd bf       	out	0x3d, r28	; 61
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	1f 91       	pop	r17
     6fe:	0f 91       	pop	r16
     700:	ff 90       	pop	r15
     702:	ef 90       	pop	r14
     704:	df 90       	pop	r13
     706:	cf 90       	pop	r12
     708:	bf 90       	pop	r11
     70a:	af 90       	pop	r10
     70c:	9f 90       	pop	r9
     70e:	8f 90       	pop	r8
     710:	7f 90       	pop	r7
     712:	6f 90       	pop	r6
     714:	5f 90       	pop	r5
     716:	4f 90       	pop	r4
     718:	08 95       	ret

0000071a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>:


float PIDController::adjustControlForServoLimits( float controlValueToAdjust, float minServoControlValue, float maxServoControlValue )
{
     71a:	8f 92       	push	r8
     71c:	9f 92       	push	r9
     71e:	af 92       	push	r10
     720:	bf 92       	push	r11
     722:	cf 92       	push	r12
     724:	df 92       	push	r13
     726:	ef 92       	push	r14
     728:	ff 92       	push	r15
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	a4 2e       	mov	r10, r20
     734:	b5 2e       	mov	r11, r21
     736:	d6 2f       	mov	r29, r22
     738:	c7 2f       	mov	r28, r23
     73a:	82 2e       	mov	r8, r18
     73c:	93 2e       	mov	r9, r19

	//TODO: when generalizing ensure to change this value. 
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
     73e:	2c 2d       	mov	r18, r12
     740:	3d 2d       	mov	r19, r13
     742:	4e 2d       	mov	r20, r14
     744:	5f 2d       	mov	r21, r15
     746:	6a 2d       	mov	r22, r10
     748:	7b 2d       	mov	r23, r11
     74a:	8d 2f       	mov	r24, r29
     74c:	9c 2f       	mov	r25, r28
     74e:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
     752:	18 16       	cp	r1, r24
     754:	6c f0       	brlt	.+26     	; 0x770 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x56>
	{
		controlValueToAdjust = maxServoControlValue;
	}else if (controlValueToAdjust < minServoControlValue)
     756:	20 2f       	mov	r18, r16
     758:	31 2f       	mov	r19, r17
     75a:	48 2d       	mov	r20, r8
     75c:	59 2d       	mov	r21, r9
     75e:	6a 2d       	mov	r22, r10
     760:	7b 2d       	mov	r23, r11
     762:	8d 2f       	mov	r24, r29
     764:	9c 2f       	mov	r25, r28
     766:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
     76a:	88 23       	and	r24, r24
     76c:	34 f0       	brlt	.+12     	; 0x77a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x60>
     76e:	09 c0       	rjmp	.+18     	; 0x782 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x68>
	//Todo revisit including trim.
	//controlValue += yawServoTrim;
	
	if (controlValueToAdjust > maxServoControlValue)
	{
		controlValueToAdjust = maxServoControlValue;
     770:	ac 2c       	mov	r10, r12
     772:	bd 2c       	mov	r11, r13
     774:	de 2d       	mov	r29, r14
     776:	cf 2d       	mov	r28, r15
     778:	04 c0       	rjmp	.+8      	; 0x782 <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff+0x68>
	}else if (controlValueToAdjust < minServoControlValue)
	{
		controlValueToAdjust = minServoControlValue;
     77a:	a0 2e       	mov	r10, r16
     77c:	b1 2e       	mov	r11, r17
     77e:	d8 2d       	mov	r29, r8
     780:	c9 2d       	mov	r28, r9
	}
	
	return controlValueToAdjust;
}
     782:	6a 2d       	mov	r22, r10
     784:	7b 2d       	mov	r23, r11
     786:	8d 2f       	mov	r24, r29
     788:	9c 2f       	mov	r25, r28
     78a:	df 91       	pop	r29
     78c:	cf 91       	pop	r28
     78e:	1f 91       	pop	r17
     790:	0f 91       	pop	r16
     792:	ff 90       	pop	r15
     794:	ef 90       	pop	r14
     796:	df 90       	pop	r13
     798:	cf 90       	pop	r12
     79a:	bf 90       	pop	r11
     79c:	af 90       	pop	r10
     79e:	9f 90       	pop	r9
     7a0:	8f 90       	pop	r8
     7a2:	08 95       	ret

000007a4 <_Z30calculateInnerLoopControlValuefffff>:


float calculateInnerLoopControlValue( float outerLoopSetpoint, float measuredValue, float gain, float angularVelocity, float angularVelocityGain )
{
     7a4:	4f 92       	push	r4
     7a6:	5f 92       	push	r5
     7a8:	6f 92       	push	r6
     7aa:	7f 92       	push	r7
     7ac:	af 92       	push	r10
     7ae:	bf 92       	push	r11
     7b0:	cf 92       	push	r12
     7b2:	df 92       	push	r13
     7b4:	ef 92       	push	r14
     7b6:	ff 92       	push	r15
     7b8:	0f 93       	push	r16
     7ba:	1f 93       	push	r17
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	cd b7       	in	r28, 0x3d	; 61
     7c2:	de b7       	in	r29, 0x3e	; 62
	return (gain * (outerLoopSetpoint - measuredValue)) - (angularVelocity * angularVelocityGain);
     7c4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     7c8:	a8 01       	movw	r20, r16
     7ca:	97 01       	movw	r18, r14
     7cc:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     7d0:	2b 01       	movw	r4, r22
     7d2:	3c 01       	movw	r6, r24
     7d4:	2a 89       	ldd	r18, Y+18	; 0x12
     7d6:	3b 89       	ldd	r19, Y+19	; 0x13
     7d8:	4c 89       	ldd	r20, Y+20	; 0x14
     7da:	5d 89       	ldd	r21, Y+21	; 0x15
     7dc:	c6 01       	movw	r24, r12
     7de:	b5 01       	movw	r22, r10
     7e0:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     7e4:	9b 01       	movw	r18, r22
     7e6:	ac 01       	movw	r20, r24
     7e8:	c3 01       	movw	r24, r6
     7ea:	b2 01       	movw	r22, r4
     7ec:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
	//float workingSetpoint = gain * (outerLoopSetpoint - measuredValue);
	//float multiplier = workingSetpoint < 0 ? -1.0f : 1.0f;
	//
	////Subtract the abs values to ensure that one always 'subtracts' from the other.
	//return multiplier * (fabs(workingSetpoint) - fabs(angularVelocity*angularVelocityGain));
}
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	1f 91       	pop	r17
     7f6:	0f 91       	pop	r16
     7f8:	ff 90       	pop	r15
     7fa:	ef 90       	pop	r14
     7fc:	df 90       	pop	r13
     7fe:	cf 90       	pop	r12
     800:	bf 90       	pop	r11
     802:	af 90       	pop	r10
     804:	7f 90       	pop	r7
     806:	6f 90       	pop	r6
     808:	5f 90       	pop	r5
     80a:	4f 90       	pop	r4
     80c:	08 95       	ret

0000080e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>:


float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
     80e:	8f 92       	push	r8
     810:	9f 92       	push	r9
     812:	af 92       	push	r10
     814:	bf 92       	push	r11
     816:	cf 92       	push	r12
     818:	df 92       	push	r13
     81a:	ef 92       	push	r14
     81c:	ff 92       	push	r15
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	cf 93       	push	r28
     824:	df 93       	push	r29
     826:	a4 2e       	mov	r10, r20
     828:	b5 2e       	mov	r11, r21
     82a:	d6 2f       	mov	r29, r22
     82c:	c7 2f       	mov	r28, r23
     82e:	82 2e       	mov	r8, r18
     830:	93 2e       	mov	r9, r19
	if (outerLoopControlSetpoint < minSetpointLimitRads)
     832:	20 2f       	mov	r18, r16
     834:	31 2f       	mov	r19, r17
     836:	48 2d       	mov	r20, r8
     838:	59 2d       	mov	r21, r9
     83a:	6a 2d       	mov	r22, r10
     83c:	7b 2d       	mov	r23, r11
     83e:	8d 2f       	mov	r24, r29
     840:	9c 2f       	mov	r25, r28
     842:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
     846:	88 23       	and	r24, r24
     848:	6c f0       	brlt	.+26     	; 0x864 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x56>
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
     84a:	2c 2d       	mov	r18, r12
     84c:	3d 2d       	mov	r19, r13
     84e:	4e 2d       	mov	r20, r14
     850:	5f 2d       	mov	r21, r15
     852:	6a 2d       	mov	r22, r10
     854:	7b 2d       	mov	r23, r11
     856:	8d 2f       	mov	r24, r29
     858:	9c 2f       	mov	r25, r28
     85a:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
     85e:	18 16       	cp	r1, r24
     860:	34 f0       	brlt	.+12     	; 0x86e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x60>
     862:	09 c0       	rjmp	.+18     	; 0x876 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x68>

float PIDController::adjustForSetpointLimits( float outerLoopControlSetpoint, float minSetpointLimitRads, float maxSetpointLimitRads )
{
	if (outerLoopControlSetpoint < minSetpointLimitRads)
	{
		outerLoopControlSetpoint = minSetpointLimitRads;
     864:	a0 2e       	mov	r10, r16
     866:	b1 2e       	mov	r11, r17
     868:	d8 2d       	mov	r29, r8
     86a:	c9 2d       	mov	r28, r9
     86c:	04 c0       	rjmp	.+8      	; 0x876 <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff+0x68>
	}else if (outerLoopControlSetpoint > maxSetpointLimitRads)
	{
		outerLoopControlSetpoint = maxSetpointLimitRads;
     86e:	ac 2c       	mov	r10, r12
     870:	bd 2c       	mov	r11, r13
     872:	de 2d       	mov	r29, r14
     874:	cf 2d       	mov	r28, r15
	}
	
	return outerLoopControlSetpoint;
}
     876:	6a 2d       	mov	r22, r10
     878:	7b 2d       	mov	r23, r11
     87a:	8d 2f       	mov	r24, r29
     87c:	9c 2f       	mov	r25, r28
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	ff 90       	pop	r15
     888:	ef 90       	pop	r14
     88a:	df 90       	pop	r13
     88c:	cf 90       	pop	r12
     88e:	bf 90       	pop	r11
     890:	af 90       	pop	r10
     892:	9f 90       	pop	r9
     894:	8f 90       	pop	r8
     896:	08 95       	ret

00000898 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>:


//TODO WTF IS THIS DOING HERE?? THIS IS THE WRONG CONTROLLER!!
void PIDController::addBlownFrame()
{
	model->BlownFrames(model->BlownFrames() + 1);
     898:	dc 01       	movw	r26, r24
     89a:	ed 91       	ld	r30, X+
     89c:	fc 91       	ld	r31, X
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
     89e:	ea 54       	subi	r30, 0x4A	; 74
     8a0:	ff 4f       	sbci	r31, 0xFF	; 255
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	a2 81       	ldd	r26, Z+2	; 0x02
     8a8:	b3 81       	ldd	r27, Z+3	; 0x03
     8aa:	01 96       	adiw	r24, 0x01	; 1
     8ac:	a1 1d       	adc	r26, r1
     8ae:	b1 1d       	adc	r27, r1
     8b0:	80 83       	st	Z, r24
     8b2:	91 83       	std	Z+1, r25	; 0x01
     8b4:	a2 83       	std	Z+2, r26	; 0x02
     8b6:	b3 83       	std	Z+3, r27	; 0x03
     8b8:	08 95       	ret

000008ba <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>:
	}
}


void PIDController::tailRotorCollectiveOuterLoopUpdate()
{
     8ba:	2f 92       	push	r2
     8bc:	3f 92       	push	r3
     8be:	4f 92       	push	r4
     8c0:	5f 92       	push	r5
     8c2:	6f 92       	push	r6
     8c4:	7f 92       	push	r7
     8c6:	8f 92       	push	r8
     8c8:	9f 92       	push	r9
     8ca:	af 92       	push	r10
     8cc:	bf 92       	push	r11
     8ce:	cf 92       	push	r12
     8d0:	df 92       	push	r13
     8d2:	ef 92       	push	r14
     8d4:	ff 92       	push	r15
     8d6:	0f 93       	push	r16
     8d8:	1f 93       	push	r17
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	cd b7       	in	r28, 0x3d	; 61
     8e0:	de b7       	in	r29, 0x3e	; 62
     8e2:	2a 97       	sbiw	r28, 0x0a	; 10
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	de bf       	out	0x3e, r29	; 62
     8ea:	0f be       	out	0x3f, r0	; 63
     8ec:	cd bf       	out	0x3d, r28	; 61
     8ee:	9a 87       	std	Y+10, r25	; 0x0a
     8f0:	89 87       	std	Y+9, r24	; 0x09
	float yawProportional = calculateProportional(model->YawRads(), model->ReferenceMagYawRads());
     8f2:	dc 01       	movw	r26, r24
     8f4:	2d 90       	ld	r2, X+
     8f6:	3c 90       	ld	r3, X
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
     8f8:	f1 01       	movw	r30, r2
     8fa:	ea 52       	subi	r30, 0x2A	; 42
     8fc:	ff 4f       	sbci	r31, 0xFF	; 255
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
     8fe:	d1 01       	movw	r26, r2
     900:	16 96       	adiw	r26, 0x06	; 6
     902:	2d 91       	ld	r18, X+
     904:	3d 91       	ld	r19, X+
     906:	4d 91       	ld	r20, X+
     908:	5c 91       	ld	r21, X
     90a:	19 97       	sbiw	r26, 0x09	; 9
     90c:	60 81       	ld	r22, Z
     90e:	71 81       	ldd	r23, Z+1	; 0x01
     910:	82 81       	ldd	r24, Z+2	; 0x02
     912:	93 81       	ldd	r25, Z+3	; 0x03
     914:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     918:	e6 2e       	mov	r14, r22
     91a:	f7 2e       	mov	r15, r23
     91c:	08 2f       	mov	r16, r24
     91e:	19 2f       	mov	r17, r25
     920:	46 2e       	mov	r4, r22
     922:	57 2e       	mov	r5, r23
     924:	68 2e       	mov	r6, r24
     926:	79 2e       	mov	r7, r25
				/**
				 * Converts the error from 0-360, to -180 - 180 (in the equivalent of rads - i.e. yawError should be rads).
				 */
				inline float convertYawErrorFrom2PitoPlusMinusPi( float  yawErrorRads )
				{
					if (yawErrorRads >= M_PI)
     928:	2b ed       	ldi	r18, 0xDB	; 219
     92a:	3f e0       	ldi	r19, 0x0F	; 15
     92c:	49 e4       	ldi	r20, 0x49	; 73
     92e:	50 e4       	ldi	r21, 0x40	; 64
     930:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
     934:	88 23       	and	r24, r24
     936:	7c f0       	brlt	.+30     	; 0x956 <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0x9c>
					{
						yawErrorRads = yawErrorRads - (2 * M_PI);
     938:	2b ed       	ldi	r18, 0xDB	; 219
     93a:	3f e0       	ldi	r19, 0x0F	; 15
     93c:	49 ec       	ldi	r20, 0xC9	; 201
     93e:	50 e4       	ldi	r21, 0x40	; 64
     940:	6e 2d       	mov	r22, r14
     942:	7f 2d       	mov	r23, r15
     944:	80 2f       	mov	r24, r16
     946:	91 2f       	mov	r25, r17
     948:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     94c:	46 2e       	mov	r4, r22
     94e:	57 2e       	mov	r5, r23
     950:	68 2e       	mov	r6, r24
     952:	79 2e       	mov	r7, r25
     954:	1a c0       	rjmp	.+52     	; 0x98a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xd0>
					}
					else if (yawErrorRads < -M_PI)
     956:	2b ed       	ldi	r18, 0xDB	; 219
     958:	3f e0       	ldi	r19, 0x0F	; 15
     95a:	49 e4       	ldi	r20, 0x49	; 73
     95c:	50 ec       	ldi	r21, 0xC0	; 192
     95e:	6e 2d       	mov	r22, r14
     960:	7f 2d       	mov	r23, r15
     962:	80 2f       	mov	r24, r16
     964:	91 2f       	mov	r25, r17
     966:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
     96a:	88 23       	and	r24, r24
     96c:	74 f4       	brge	.+28     	; 0x98a <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv+0xd0>
					{
						yawErrorRads = yawErrorRads + (2 * M_PI);
     96e:	2b ed       	ldi	r18, 0xDB	; 219
     970:	3f e0       	ldi	r19, 0x0F	; 15
     972:	49 ec       	ldi	r20, 0xC9	; 201
     974:	50 e4       	ldi	r21, 0x40	; 64
     976:	6e 2d       	mov	r22, r14
     978:	7f 2d       	mov	r23, r15
     97a:	80 2f       	mov	r24, r16
     97c:	91 2f       	mov	r25, r17
     97e:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     982:	46 2e       	mov	r4, r22
     984:	57 2e       	mov	r5, r23
     986:	68 2e       	mov	r6, r24
     988:	79 2e       	mov	r7, r25
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     98a:	f1 01       	movw	r30, r2
     98c:	26 85       	ldd	r18, Z+14	; 0x0e
     98e:	37 85       	ldd	r19, Z+15	; 0x0f
     990:	40 89       	ldd	r20, Z+16	; 0x10
     992:	51 89       	ldd	r21, Z+17	; 0x11
     994:	62 85       	ldd	r22, Z+10	; 0x0a
     996:	73 85       	ldd	r23, Z+11	; 0x0b
     998:	84 85       	ldd	r24, Z+12	; 0x0c
     99a:	95 85       	ldd	r25, Z+13	; 0x0d
     99c:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     9a0:	a9 85       	ldd	r26, Y+9	; 0x09
     9a2:	ba 85       	ldd	r27, Y+10	; 0x0a
     9a4:	1e 96       	adiw	r26, 0x0e	; 14
     9a6:	2d 91       	ld	r18, X+
     9a8:	3d 91       	ld	r19, X+
     9aa:	4d 91       	ld	r20, X+
     9ac:	5c 91       	ld	r21, X
     9ae:	51 97       	sbiw	r26, 0x11	; 17
     9b0:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     9b4:	6b 01       	movw	r12, r22
     9b6:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     9b8:	e9 85       	ldd	r30, Y+9	; 0x09
     9ba:	fa 85       	ldd	r31, Y+10	; 0x0a
     9bc:	22 81       	ldd	r18, Z+2	; 0x02
     9be:	33 81       	ldd	r19, Z+3	; 0x03
     9c0:	44 81       	ldd	r20, Z+4	; 0x04
     9c2:	55 81       	ldd	r21, Z+5	; 0x05
     9c4:	64 2d       	mov	r22, r4
     9c6:	75 2d       	mov	r23, r5
     9c8:	86 2d       	mov	r24, r6
     9ca:	97 2d       	mov	r25, r7
     9cc:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     9d0:	9b 01       	movw	r18, r22
     9d2:	ac 01       	movw	r20, r24
     9d4:	c7 01       	movw	r24, r14
     9d6:	b6 01       	movw	r22, r12
     9d8:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     9dc:	e9 85       	ldd	r30, Y+9	; 0x09
     9de:	fa 85       	ldd	r31, Y+10	; 0x0a
     9e0:	ee 57       	subi	r30, 0x7E	; 126
     9e2:	ff 4f       	sbci	r31, 0xFF	; 255
     9e4:	20 81       	ld	r18, Z
     9e6:	31 81       	ldd	r19, Z+1	; 0x01
     9e8:	42 81       	ldd	r20, Z+2	; 0x02
     9ea:	53 81       	ldd	r21, Z+3	; 0x03
     9ec:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     9f0:	d1 01       	movw	r26, r2
     9f2:	56 96       	adiw	r26, 0x16	; 22
     9f4:	2d 91       	ld	r18, X+
     9f6:	3d 91       	ld	r19, X+
     9f8:	4d 91       	ld	r20, X+
     9fa:	5c 91       	ld	r21, X
     9fc:	59 97       	sbiw	r26, 0x19	; 25
     9fe:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     a02:	69 83       	std	Y+1, r22	; 0x01
     a04:	7a 83       	std	Y+2, r23	; 0x02
     a06:	8b 83       	std	Y+3, r24	; 0x03
     a08:	9c 83       	std	Y+4, r25	; 0x04
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
     a0a:	f1 01       	movw	r30, r2
     a0c:	ee 51       	subi	r30, 0x1E	; 30
     a0e:	ff 4f       	sbci	r31, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     a10:	d1 01       	movw	r26, r2
     a12:	52 96       	adiw	r26, 0x12	; 18
     a14:	2d 91       	ld	r18, X+
     a16:	3d 91       	ld	r19, X+
     a18:	4d 91       	ld	r20, X+
     a1a:	5c 91       	ld	r21, X
     a1c:	55 97       	sbiw	r26, 0x15	; 21
     a1e:	60 81       	ld	r22, Z
     a20:	71 81       	ldd	r23, Z+1	; 0x01
     a22:	82 81       	ldd	r24, Z+2	; 0x02
     a24:	93 81       	ldd	r25, Z+3	; 0x03
     a26:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     a2a:	6d 83       	std	Y+5, r22	; 0x05
     a2c:	7e 83       	std	Y+6, r23	; 0x06
     a2e:	8f 83       	std	Y+7, r24	; 0x07
     a30:	98 87       	std	Y+8, r25	; 0x08
	yawProportional = convertYawErrorFrom2PitoPlusMinusPi(yawProportional);
	
	float yawIntegralAntiWindup = calculateIntegralAntiWindup(model->YawControlBeforeServoLimitsAdjustment(), model->YawControl(), yawAntiWindupGain);
	float weightedYawIntegral = calculateIntegral(yawProportional, model->YawIntegral(), yawIntegralAntiWindup, yawIntegralGain);
	float yawDerivativeError = calculateVelocityError(model->YawAngularVelocityRadsPerSecond(), model->ReferenceYawVelocityRadsPerSecond());
	float yawControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(yawProportional, yawDerivativeError, weightedYawIntegral, yawProportionalGain, yawDerivativeGain, 1);
     a32:	e9 85       	ldd	r30, Y+9	; 0x09
     a34:	fa 85       	ldd	r31, Y+10	; 0x0a
     a36:	82 84       	ldd	r8, Z+10	; 0x0a
     a38:	93 84       	ldd	r9, Z+11	; 0x0b
     a3a:	a4 84       	ldd	r10, Z+12	; 0x0c
     a3c:	b5 84       	ldd	r11, Z+13	; 0x0d
     a3e:	1f 92       	push	r1
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	8f 93       	push	r24
     a44:	81 85       	ldd	r24, Z+9	; 0x09
     a46:	8f 93       	push	r24
     a48:	80 85       	ldd	r24, Z+8	; 0x08
     a4a:	8f 93       	push	r24
     a4c:	87 81       	ldd	r24, Z+7	; 0x07
     a4e:	8f 93       	push	r24
     a50:	86 81       	ldd	r24, Z+6	; 0x06
     a52:	8f 93       	push	r24
     a54:	39 81       	ldd	r19, Y+1	; 0x01
     a56:	2a 81       	ldd	r18, Y+2	; 0x02
     a58:	9b 81       	ldd	r25, Y+3	; 0x03
     a5a:	8c 81       	ldd	r24, Y+4	; 0x04
     a5c:	c3 2e       	mov	r12, r19
     a5e:	d2 2e       	mov	r13, r18
     a60:	e9 2e       	mov	r14, r25
     a62:	f8 2e       	mov	r15, r24
     a64:	5d 81       	ldd	r21, Y+5	; 0x05
     a66:	4e 81       	ldd	r20, Y+6	; 0x06
     a68:	9f 81       	ldd	r25, Y+7	; 0x07
     a6a:	88 85       	ldd	r24, Y+8	; 0x08
     a6c:	05 2f       	mov	r16, r21
     a6e:	14 2f       	mov	r17, r20
     a70:	29 2f       	mov	r18, r25
     a72:	38 2f       	mov	r19, r24
     a74:	44 2d       	mov	r20, r4
     a76:	55 2d       	mov	r21, r5
     a78:	66 2d       	mov	r22, r6
     a7a:	77 2d       	mov	r23, r7
     a7c:	89 85       	ldd	r24, Y+9	; 0x09
     a7e:	9a 85       	ldd	r25, Y+10	; 0x0a
     a80:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	0f 90       	pop	r0
     a8c:	0f 90       	pop	r0
     a8e:	0f 90       	pop	r0
     a90:	4b 01       	movw	r8, r22
     a92:	5c 01       	movw	r10, r24
	float yawControl = adjustControlForServoLimits(yawControlBeforeServoLimitsAdjustment, minYawServoControlValue, maxYawServoControlValue);
     a94:	e9 85       	ldd	r30, Y+9	; 0x09
     a96:	fa 85       	ldd	r31, Y+10	; 0x0a
     a98:	ea 5a       	subi	r30, 0xAA	; 170
     a9a:	ff 4f       	sbci	r31, 0xFF	; 255
     a9c:	c0 80       	ld	r12, Z
     a9e:	d1 80       	ldd	r13, Z+1	; 0x01
     aa0:	e2 80       	ldd	r14, Z+2	; 0x02
     aa2:	f3 80       	ldd	r15, Z+3	; 0x03
     aa4:	e9 85       	ldd	r30, Y+9	; 0x09
     aa6:	fa 85       	ldd	r31, Y+10	; 0x0a
     aa8:	ee 5a       	subi	r30, 0xAE	; 174
     aaa:	ff 4f       	sbci	r31, 0xFF	; 255
     aac:	00 81       	ld	r16, Z
     aae:	11 81       	ldd	r17, Z+1	; 0x01
     ab0:	22 81       	ldd	r18, Z+2	; 0x02
     ab2:	33 81       	ldd	r19, Z+3	; 0x03
     ab4:	ab 01       	movw	r20, r22
     ab6:	bc 01       	movw	r22, r24
     ab8:	89 85       	ldd	r24, Y+9	; 0x09
     aba:	9a 85       	ldd	r25, Y+10	; 0x0a
     abc:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
	
	//model->YawControl(yawControl);
	//Multiply by -1 because in the simulator, +1 results in counter clockwise yaw, but on the helicopter, it's a clockwise yaw. 
	model->YawControl(yawControl * -1);
     ac0:	dc 01       	movw	r26, r24
     ac2:	cb 01       	movw	r24, r22
     ac4:	b0 58       	subi	r27, 0x80	; 128
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
			void YawControl(float val) { yawControl = val;}
     ac6:	f1 01       	movw	r30, r2
     ac8:	82 87       	std	Z+10, r24	; 0x0a
     aca:	93 87       	std	Z+11, r25	; 0x0b
     acc:	a4 87       	std	Z+12, r26	; 0x0c
     ace:	b5 87       	std	Z+13, r27	; 0x0d
	model->YawControlBeforeServoLimitsAdjustment(yawControlBeforeServoLimitsAdjustment);
     ad0:	a9 85       	ldd	r26, Y+9	; 0x09
     ad2:	ba 85       	ldd	r27, Y+10	; 0x0a
     ad4:	ed 91       	ld	r30, X+
     ad6:	fc 91       	ld	r31, X
     ad8:	11 97       	sbiw	r26, 0x01	; 1
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
     ada:	86 86       	std	Z+14, r8	; 0x0e
     adc:	97 86       	std	Z+15, r9	; 0x0f
     ade:	a0 8a       	std	Z+16, r10	; 0x10
     ae0:	b1 8a       	std	Z+17, r11	; 0x11
	model->YawIntegral(weightedYawIntegral);
     ae2:	ed 91       	ld	r30, X+
     ae4:	fc 91       	ld	r31, X
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
			void YawIntegral(float val) { yawIntegral = val;}
     ae6:	59 81       	ldd	r21, Y+1	; 0x01
     ae8:	4a 81       	ldd	r20, Y+2	; 0x02
     aea:	3b 81       	ldd	r19, Y+3	; 0x03
     aec:	2c 81       	ldd	r18, Y+4	; 0x04
     aee:	85 2f       	mov	r24, r21
     af0:	94 2f       	mov	r25, r20
     af2:	a3 2f       	mov	r26, r19
     af4:	b2 2f       	mov	r27, r18
     af6:	86 8b       	std	Z+22, r24	; 0x16
     af8:	97 8b       	std	Z+23, r25	; 0x17
     afa:	a0 8f       	std	Z+24, r26	; 0x18
     afc:	b1 8f       	std	Z+25, r27	; 0x19
	model->YawProportional(yawProportional);
     afe:	a9 85       	ldd	r26, Y+9	; 0x09
     b00:	ba 85       	ldd	r27, Y+10	; 0x0a
     b02:	ed 91       	ld	r30, X+
     b04:	fc 91       	ld	r31, X

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}
     b06:	84 2d       	mov	r24, r4
     b08:	95 2d       	mov	r25, r5
     b0a:	a6 2d       	mov	r26, r6
     b0c:	b7 2d       	mov	r27, r7
     b0e:	82 8f       	std	Z+26, r24	; 0x1a
     b10:	93 8f       	std	Z+27, r25	; 0x1b
     b12:	a4 8f       	std	Z+28, r26	; 0x1c
     b14:	b5 8f       	std	Z+29, r27	; 0x1d
	model->YawDerivativeError(yawDerivativeError);
     b16:	a9 85       	ldd	r26, Y+9	; 0x09
     b18:	ba 85       	ldd	r27, Y+10	; 0x0a
     b1a:	ed 91       	ld	r30, X+
     b1c:	fc 91       	ld	r31, X

			float YawDerivativeError() const {return yawDerivativeError;}
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
     b1e:	5d 81       	ldd	r21, Y+5	; 0x05
     b20:	4e 81       	ldd	r20, Y+6	; 0x06
     b22:	3f 81       	ldd	r19, Y+7	; 0x07
     b24:	28 85       	ldd	r18, Y+8	; 0x08
     b26:	85 2f       	mov	r24, r21
     b28:	94 2f       	mov	r25, r20
     b2a:	a3 2f       	mov	r26, r19
     b2c:	b2 2f       	mov	r27, r18
     b2e:	86 8f       	std	Z+30, r24	; 0x1e
     b30:	97 8f       	std	Z+31, r25	; 0x1f
     b32:	a0 a3       	std	Z+32, r26	; 0x20
     b34:	b1 a3       	std	Z+33, r27	; 0x21
}
     b36:	2a 96       	adiw	r28, 0x0a	; 10
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	de bf       	out	0x3e, r29	; 62
     b3e:	0f be       	out	0x3f, r0	; 63
     b40:	cd bf       	out	0x3d, r28	; 61
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	1f 91       	pop	r17
     b48:	0f 91       	pop	r16
     b4a:	ff 90       	pop	r15
     b4c:	ef 90       	pop	r14
     b4e:	df 90       	pop	r13
     b50:	cf 90       	pop	r12
     b52:	bf 90       	pop	r11
     b54:	af 90       	pop	r10
     b56:	9f 90       	pop	r9
     b58:	8f 90       	pop	r8
     b5a:	7f 90       	pop	r7
     b5c:	6f 90       	pop	r6
     b5e:	5f 90       	pop	r5
     b60:	4f 90       	pop	r4
     b62:	3f 90       	pop	r3
     b64:	2f 90       	pop	r2
     b66:	08 95       	ret

00000b68 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>:

void PIDController::mainRotorCollectiveOuterLoopUpdate(float zProportional)
{
     b68:	2f 92       	push	r2
     b6a:	3f 92       	push	r3
     b6c:	4f 92       	push	r4
     b6e:	5f 92       	push	r5
     b70:	6f 92       	push	r6
     b72:	7f 92       	push	r7
     b74:	8f 92       	push	r8
     b76:	9f 92       	push	r9
     b78:	af 92       	push	r10
     b7a:	bf 92       	push	r11
     b7c:	cf 92       	push	r12
     b7e:	df 92       	push	r13
     b80:	ef 92       	push	r14
     b82:	ff 92       	push	r15
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	2a 97       	sbiw	r28, 0x0a	; 10
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	de bf       	out	0x3e, r29	; 62
     b98:	0f be       	out	0x3f, r0	; 63
     b9a:	cd bf       	out	0x3d, r28	; 61
     b9c:	9a 87       	std	Y+10, r25	; 0x0a
     b9e:	89 87       	std	Y+9, r24	; 0x09
     ba0:	2a 01       	movw	r4, r20
     ba2:	3b 01       	movw	r6, r22

	//float zProportional = calculateProportional(model->ZNEDLocalFrame(), model->ReferenceZNEDLocalFrameMeters());
	
	float zIntegralAntiWindup = calculateIntegralAntiWindup(model->MainRotorControlBeforeServoLimitsAdjustment(), model->MainRotorCollectiveControl(), zAntiWindupGain);
     ba4:	dc 01       	movw	r26, r24
     ba6:	0d 91       	ld	r16, X+
     ba8:	1c 91       	ld	r17, X
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
     baa:	78 01       	movw	r14, r16
     bac:	b6 e9       	ldi	r27, 0x96	; 150
     bae:	eb 0e       	add	r14, r27
     bb0:	f1 1c       	adc	r15, r1
     bb2:	6c 01       	movw	r12, r24
     bb4:	ee e4       	ldi	r30, 0x4E	; 78
     bb6:	ce 0e       	add	r12, r30
     bb8:	d1 1c       	adc	r13, r1

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
     bba:	c8 01       	movw	r24, r16
     bbc:	8a 57       	subi	r24, 0x7A	; 122
     bbe:	9f 4f       	sbci	r25, 0xFF	; 255
     bc0:	9a 83       	std	Y+2, r25	; 0x02
     bc2:	89 83       	std	Y+1, r24	; 0x01
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
     bc4:	f8 01       	movw	r30, r16
     bc6:	e6 57       	subi	r30, 0x76	; 118
     bc8:	ff 4f       	sbci	r31, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     bca:	20 81       	ld	r18, Z
     bcc:	31 81       	ldd	r19, Z+1	; 0x01
     bce:	42 81       	ldd	r20, Z+2	; 0x02
     bd0:	53 81       	ldd	r21, Z+3	; 0x03
     bd2:	dc 01       	movw	r26, r24
     bd4:	6d 91       	ld	r22, X+
     bd6:	7d 91       	ld	r23, X+
     bd8:	8d 91       	ld	r24, X+
     bda:	9c 91       	ld	r25, X
     bdc:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     be0:	f6 01       	movw	r30, r12
     be2:	20 81       	ld	r18, Z
     be4:	31 81       	ldd	r19, Z+1	; 0x01
     be6:	42 81       	ldd	r20, Z+2	; 0x02
     be8:	53 81       	ldd	r21, Z+3	; 0x03
     bea:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     bee:	4b 01       	movw	r8, r22
     bf0:	5c 01       	movw	r10, r24
	float weightedZIntegral = calculateIntegral(zProportional, model->ZIntegral(), zIntegralAntiWindup, zIntegralGain);
     bf2:	e9 85       	ldd	r30, Y+9	; 0x09
     bf4:	fa 85       	ldd	r31, Y+10	; 0x0a
     bf6:	ee 5b       	subi	r30, 0xBE	; 190
     bf8:	ff 4f       	sbci	r31, 0xFF	; 255
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     bfa:	20 81       	ld	r18, Z
     bfc:	31 81       	ldd	r19, Z+1	; 0x01
     bfe:	42 81       	ldd	r20, Z+2	; 0x02
     c00:	53 81       	ldd	r21, Z+3	; 0x03
     c02:	c3 01       	movw	r24, r6
     c04:	b2 01       	movw	r22, r4
     c06:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     c0a:	9b 01       	movw	r18, r22
     c0c:	ac 01       	movw	r20, r24
     c0e:	c5 01       	movw	r24, r10
     c10:	b4 01       	movw	r22, r8
     c12:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     c16:	e9 85       	ldd	r30, Y+9	; 0x09
     c18:	fa 85       	ldd	r31, Y+10	; 0x0a
     c1a:	ee 57       	subi	r30, 0x7E	; 126
     c1c:	ff 4f       	sbci	r31, 0xFF	; 255
     c1e:	20 81       	ld	r18, Z
     c20:	31 81       	ldd	r19, Z+1	; 0x01
     c22:	42 81       	ldd	r20, Z+2	; 0x02
     c24:	53 81       	ldd	r21, Z+3	; 0x03
     c26:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     c2a:	d7 01       	movw	r26, r14
     c2c:	2d 91       	ld	r18, X+
     c2e:	3d 91       	ld	r19, X+
     c30:	4d 91       	ld	r20, X+
     c32:	5c 91       	ld	r21, X
     c34:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     c38:	26 2e       	mov	r2, r22
     c3a:	37 2e       	mov	r3, r23
     c3c:	8b 83       	std	Y+3, r24	; 0x03
     c3e:	9c 83       	std	Y+4, r25	; 0x04
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
     c40:	f8 01       	movw	r30, r16
     c42:	e2 57       	subi	r30, 0x72	; 114
     c44:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
     c46:	d8 01       	movw	r26, r16
     c48:	ae 56       	subi	r26, 0x6E	; 110
     c4a:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     c4c:	2d 91       	ld	r18, X+
     c4e:	3d 91       	ld	r19, X+
     c50:	4d 91       	ld	r20, X+
     c52:	5c 91       	ld	r21, X
     c54:	60 81       	ld	r22, Z
     c56:	71 81       	ldd	r23, Z+1	; 0x01
     c58:	82 81       	ldd	r24, Z+2	; 0x02
     c5a:	93 81       	ldd	r25, Z+3	; 0x03
     c5c:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     c60:	6d 83       	std	Y+5, r22	; 0x05
     c62:	7e 83       	std	Y+6, r23	; 0x06
     c64:	8f 83       	std	Y+7, r24	; 0x07
     c66:	98 87       	std	Y+8, r25	; 0x08
	float zDerivativeError = calculateVelocityError(model->ZVelocityFRDCms(), model->ReferenceZVelocityCms());
	float mainRotorControlBeforeServoLimitsAdjustment = calculateOuterLoopControlValue(zProportional, zDerivativeError, weightedZIntegral, zProportionalGain, zDerivativeGain, 1);
     c68:	e9 85       	ldd	r30, Y+9	; 0x09
     c6a:	fa 85       	ldd	r31, Y+10	; 0x0a
     c6c:	e6 5b       	subi	r30, 0xB6	; 182
     c6e:	ff 4f       	sbci	r31, 0xFF	; 255
     c70:	80 80       	ld	r8, Z
     c72:	91 80       	ldd	r9, Z+1	; 0x01
     c74:	a2 80       	ldd	r10, Z+2	; 0x02
     c76:	b3 80       	ldd	r11, Z+3	; 0x03
     c78:	1f 92       	push	r1
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	8f 93       	push	r24
     c7e:	e9 85       	ldd	r30, Y+9	; 0x09
     c80:	fa 85       	ldd	r31, Y+10	; 0x0a
     c82:	ea 5b       	subi	r30, 0xBA	; 186
     c84:	ff 4f       	sbci	r31, 0xFF	; 255
     c86:	83 81       	ldd	r24, Z+3	; 0x03
     c88:	8f 93       	push	r24
     c8a:	82 81       	ldd	r24, Z+2	; 0x02
     c8c:	8f 93       	push	r24
     c8e:	81 81       	ldd	r24, Z+1	; 0x01
     c90:	8f 93       	push	r24
     c92:	80 81       	ld	r24, Z
     c94:	8f 93       	push	r24
     c96:	9b 81       	ldd	r25, Y+3	; 0x03
     c98:	8c 81       	ldd	r24, Y+4	; 0x04
     c9a:	c2 2c       	mov	r12, r2
     c9c:	d3 2c       	mov	r13, r3
     c9e:	e9 2e       	mov	r14, r25
     ca0:	f8 2e       	mov	r15, r24
     ca2:	5d 81       	ldd	r21, Y+5	; 0x05
     ca4:	4e 81       	ldd	r20, Y+6	; 0x06
     ca6:	9f 81       	ldd	r25, Y+7	; 0x07
     ca8:	88 85       	ldd	r24, Y+8	; 0x08
     caa:	05 2f       	mov	r16, r21
     cac:	14 2f       	mov	r17, r20
     cae:	29 2f       	mov	r18, r25
     cb0:	38 2f       	mov	r19, r24
     cb2:	b3 01       	movw	r22, r6
     cb4:	a2 01       	movw	r20, r4
     cb6:	89 85       	ldd	r24, Y+9	; 0x09
     cb8:	9a 85       	ldd	r25, Y+10	; 0x0a
     cba:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     cbe:	0f 90       	pop	r0
     cc0:	0f 90       	pop	r0
     cc2:	0f 90       	pop	r0
     cc4:	0f 90       	pop	r0
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	4b 01       	movw	r8, r22
     ccc:	5c 01       	movw	r10, r24
	float mainRotorControl = adjustControlForServoLimits(mainRotorControlBeforeServoLimitsAdjustment, minMainRotorServoControlValue, maxMainRotorServoControlValue);
     cce:	e9 85       	ldd	r30, Y+9	; 0x09
     cd0:	fa 85       	ldd	r31, Y+10	; 0x0a
     cd2:	e2 59       	subi	r30, 0x92	; 146
     cd4:	ff 4f       	sbci	r31, 0xFF	; 255
     cd6:	c0 80       	ld	r12, Z
     cd8:	d1 80       	ldd	r13, Z+1	; 0x01
     cda:	e2 80       	ldd	r14, Z+2	; 0x02
     cdc:	f3 80       	ldd	r15, Z+3	; 0x03
     cde:	e9 85       	ldd	r30, Y+9	; 0x09
     ce0:	fa 85       	ldd	r31, Y+10	; 0x0a
     ce2:	e6 59       	subi	r30, 0x96	; 150
     ce4:	ff 4f       	sbci	r31, 0xFF	; 255
     ce6:	00 81       	ld	r16, Z
     ce8:	11 81       	ldd	r17, Z+1	; 0x01
     cea:	22 81       	ldd	r18, Z+2	; 0x02
     cec:	33 81       	ldd	r19, Z+3	; 0x03
     cee:	ab 01       	movw	r20, r22
     cf0:	bc 01       	movw	r22, r24
     cf2:	89 85       	ldd	r24, Y+9	; 0x09
     cf4:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf6:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}
     cfa:	e9 81       	ldd	r30, Y+1	; 0x01
     cfc:	fa 81       	ldd	r31, Y+2	; 0x02
     cfe:	60 83       	st	Z, r22
     d00:	71 83       	std	Z+1, r23	; 0x01
     d02:	82 83       	std	Z+2, r24	; 0x02
     d04:	93 83       	std	Z+3, r25	; 0x03
	
	model->MainRotorCollectiveControl(mainRotorControl);
	model->MainRotorControlBeforeServoLimitsAdjustment(mainRotorControlBeforeServoLimitsAdjustment);
     d06:	a9 85       	ldd	r26, Y+9	; 0x09
     d08:	ba 85       	ldd	r27, Y+10	; 0x0a
     d0a:	ed 91       	ld	r30, X+
     d0c:	fc 91       	ld	r31, X
     d0e:	11 97       	sbiw	r26, 0x01	; 1

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}
     d10:	e6 57       	subi	r30, 0x76	; 118
     d12:	ff 4f       	sbci	r31, 0xFF	; 255
     d14:	80 82       	st	Z, r8
     d16:	91 82       	std	Z+1, r9	; 0x01
     d18:	a2 82       	std	Z+2, r10	; 0x02
     d1a:	b3 82       	std	Z+3, r11	; 0x03
	model->ZIntegral(weightedZIntegral);
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
			void ZIntegral(float val) { zIntegral = val;}
     d20:	ea 56       	subi	r30, 0x6A	; 106
     d22:	ff 4f       	sbci	r31, 0xFF	; 255
     d24:	3b 81       	ldd	r19, Y+3	; 0x03
     d26:	2c 81       	ldd	r18, Y+4	; 0x04
     d28:	82 2d       	mov	r24, r2
     d2a:	93 2d       	mov	r25, r3
     d2c:	a3 2f       	mov	r26, r19
     d2e:	b2 2f       	mov	r27, r18
     d30:	80 83       	st	Z, r24
     d32:	91 83       	std	Z+1, r25	; 0x01
     d34:	a2 83       	std	Z+2, r26	; 0x02
     d36:	b3 83       	std	Z+3, r27	; 0x03
	model->ZProportional(zProportional);
     d38:	a9 85       	ldd	r26, Y+9	; 0x09
     d3a:	ba 85       	ldd	r27, Y+10	; 0x0a
     d3c:	ed 91       	ld	r30, X+
     d3e:	fc 91       	ld	r31, X
     d40:	11 97       	sbiw	r26, 0x01	; 1

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}
     d42:	e6 56       	subi	r30, 0x66	; 102
     d44:	ff 4f       	sbci	r31, 0xFF	; 255
     d46:	40 82       	st	Z, r4
     d48:	51 82       	std	Z+1, r5	; 0x01
     d4a:	62 82       	std	Z+2, r6	; 0x02
     d4c:	73 82       	std	Z+3, r7	; 0x03
	model->ZDerivativeError(zDerivativeError);
     d4e:	ed 91       	ld	r30, X+
     d50:	fc 91       	ld	r31, X

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
     d52:	e2 56       	subi	r30, 0x62	; 98
     d54:	ff 4f       	sbci	r31, 0xFF	; 255
     d56:	5d 81       	ldd	r21, Y+5	; 0x05
     d58:	4e 81       	ldd	r20, Y+6	; 0x06
     d5a:	3f 81       	ldd	r19, Y+7	; 0x07
     d5c:	28 85       	ldd	r18, Y+8	; 0x08
     d5e:	85 2f       	mov	r24, r21
     d60:	94 2f       	mov	r25, r20
     d62:	a3 2f       	mov	r26, r19
     d64:	b2 2f       	mov	r27, r18
     d66:	80 83       	st	Z, r24
     d68:	91 83       	std	Z+1, r25	; 0x01
     d6a:	a2 83       	std	Z+2, r26	; 0x02
     d6c:	b3 83       	std	Z+3, r27	; 0x03
}
     d6e:	2a 96       	adiw	r28, 0x0a	; 10
     d70:	0f b6       	in	r0, 0x3f	; 63
     d72:	f8 94       	cli
     d74:	de bf       	out	0x3e, r29	; 62
     d76:	0f be       	out	0x3f, r0	; 63
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	df 91       	pop	r29
     d7c:	cf 91       	pop	r28
     d7e:	1f 91       	pop	r17
     d80:	0f 91       	pop	r16
     d82:	ff 90       	pop	r15
     d84:	ef 90       	pop	r14
     d86:	df 90       	pop	r13
     d88:	cf 90       	pop	r12
     d8a:	bf 90       	pop	r11
     d8c:	af 90       	pop	r10
     d8e:	9f 90       	pop	r9
     d90:	8f 90       	pop	r8
     d92:	7f 90       	pop	r7
     d94:	6f 90       	pop	r6
     d96:	5f 90       	pop	r5
     d98:	4f 90       	pop	r4
     d9a:	3f 90       	pop	r3
     d9c:	2f 90       	pop	r2
     d9e:	08 95       	ret

00000da0 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>:

void PIDController::cyclicLongitudeOuterLoopUpdate(float xProportional)
{
     da0:	2f 92       	push	r2
     da2:	3f 92       	push	r3
     da4:	4f 92       	push	r4
     da6:	5f 92       	push	r5
     da8:	6f 92       	push	r6
     daa:	7f 92       	push	r7
     dac:	8f 92       	push	r8
     dae:	9f 92       	push	r9
     db0:	af 92       	push	r10
     db2:	bf 92       	push	r11
     db4:	cf 92       	push	r12
     db6:	df 92       	push	r13
     db8:	ef 92       	push	r14
     dba:	ff 92       	push	r15
     dbc:	0f 93       	push	r16
     dbe:	1f 93       	push	r17
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	cd b7       	in	r28, 0x3d	; 61
     dc6:	de b7       	in	r29, 0x3e	; 62
     dc8:	2a 97       	sbiw	r28, 0x0a	; 10
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	de bf       	out	0x3e, r29	; 62
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	cd bf       	out	0x3d, r28	; 61
     dd4:	9a 87       	std	Y+10, r25	; 0x0a
     dd6:	89 87       	std	Y+9, r24	; 0x09
     dd8:	2a 01       	movw	r4, r20
     dda:	3b 01       	movw	r6, r22
	//float xProportional = calculateProportional(model->XNEDLocalFrame(), model->ReferenceXNEDLocalFrame());
	float xIntegralAntiWindup = calculateIntegralAntiWindup(model->LongitudeControlBeforeServoLimitsAdjustment(), model->LongitudeControl(), xAntiWindupGain);
     ddc:	dc 01       	movw	r26, r24
     dde:	2d 90       	ld	r2, X+
     de0:	3c 90       	ld	r3, X
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
     de2:	81 01       	movw	r16, r2
     de4:	0e 5b       	subi	r16, 0xBE	; 190
     de6:	1f 4f       	sbci	r17, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     de8:	f1 01       	movw	r30, r2
     dea:	22 a5       	ldd	r18, Z+42	; 0x2a
     dec:	33 a5       	ldd	r19, Z+43	; 0x2b
     dee:	44 a5       	ldd	r20, Z+44	; 0x2c
     df0:	55 a5       	ldd	r21, Z+45	; 0x2d
     df2:	66 a5       	ldd	r22, Z+46	; 0x2e
     df4:	77 a5       	ldd	r23, Z+47	; 0x2f
     df6:	80 a9       	ldd	r24, Z+48	; 0x30
     df8:	91 a9       	ldd	r25, Z+49	; 0x31
     dfa:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     dfe:	a9 85       	ldd	r26, Y+9	; 0x09
     e00:	ba 85       	ldd	r27, Y+10	; 0x0a
     e02:	5e 96       	adiw	r26, 0x1e	; 30
     e04:	2d 91       	ld	r18, X+
     e06:	3d 91       	ld	r19, X+
     e08:	4d 91       	ld	r20, X+
     e0a:	5c 91       	ld	r21, X
     e0c:	91 97       	sbiw	r26, 0x21	; 33
     e0e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     e12:	6b 01       	movw	r12, r22
     e14:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
     e16:	e9 85       	ldd	r30, Y+9	; 0x09
     e18:	fa 85       	ldd	r31, Y+10	; 0x0a
     e1a:	22 89       	ldd	r18, Z+18	; 0x12
     e1c:	33 89       	ldd	r19, Z+19	; 0x13
     e1e:	44 89       	ldd	r20, Z+20	; 0x14
     e20:	55 89       	ldd	r21, Z+21	; 0x15
     e22:	c3 01       	movw	r24, r6
     e24:	b2 01       	movw	r22, r4
     e26:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     e2a:	9b 01       	movw	r18, r22
     e2c:	ac 01       	movw	r20, r24
     e2e:	c7 01       	movw	r24, r14
     e30:	b6 01       	movw	r22, r12
     e32:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
     e36:	e9 85       	ldd	r30, Y+9	; 0x09
     e38:	fa 85       	ldd	r31, Y+10	; 0x0a
     e3a:	ee 57       	subi	r30, 0x7E	; 126
     e3c:	ff 4f       	sbci	r31, 0xFF	; 255
     e3e:	20 81       	ld	r18, Z
     e40:	31 81       	ldd	r19, Z+1	; 0x01
     e42:	42 81       	ldd	r20, Z+2	; 0x02
     e44:	53 81       	ldd	r21, Z+3	; 0x03
     e46:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
     e4a:	d8 01       	movw	r26, r16
     e4c:	2d 91       	ld	r18, X+
     e4e:	3d 91       	ld	r19, X+
     e50:	4d 91       	ld	r20, X+
     e52:	5c 91       	ld	r21, X
     e54:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
     e58:	69 83       	std	Y+1, r22	; 0x01
     e5a:	7a 83       	std	Y+2, r23	; 0x02
     e5c:	8b 83       	std	Y+3, r24	; 0x03
     e5e:	9c 83       	std	Y+4, r25	; 0x04
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
     e60:	f1 01       	movw	r30, r2
     e62:	26 a9       	ldd	r18, Z+54	; 0x36
     e64:	37 a9       	ldd	r19, Z+55	; 0x37
     e66:	40 ad       	ldd	r20, Z+56	; 0x38
     e68:	51 ad       	ldd	r21, Z+57	; 0x39
     e6a:	62 a9       	ldd	r22, Z+50	; 0x32
     e6c:	73 a9       	ldd	r23, Z+51	; 0x33
     e6e:	84 a9       	ldd	r24, Z+52	; 0x34
     e70:	95 a9       	ldd	r25, Z+53	; 0x35
     e72:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
     e76:	6d 83       	std	Y+5, r22	; 0x05
     e78:	7e 83       	std	Y+6, r23	; 0x06
     e7a:	8f 83       	std	Y+7, r24	; 0x07
     e7c:	98 87       	std	Y+8, r25	; 0x08
	float weightedXIntegral = calculateIntegral(xProportional, model->XIntegral(), xIntegralAntiWindup, xIntegralGain);
	float xDerivativeError = calculateVelocityError(model->XVelocityFRDCms(), model->ReferenceXVelocityCms());
	float xLongitudinalOuterLoopSetpoint = calculateOuterLoopControlValue(xProportional, xDerivativeError, weightedXIntegral, xProportionalGain, xDerivativeGain, 1);
     e7e:	a9 85       	ldd	r26, Y+9	; 0x09
     e80:	ba 85       	ldd	r27, Y+10	; 0x0a
     e82:	5a 96       	adiw	r26, 0x1a	; 26
     e84:	8d 90       	ld	r8, X+
     e86:	9d 90       	ld	r9, X+
     e88:	ad 90       	ld	r10, X+
     e8a:	bc 90       	ld	r11, X
     e8c:	5d 97       	sbiw	r26, 0x1d	; 29
     e8e:	1f 92       	push	r1
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	8f 93       	push	r24
     e94:	59 96       	adiw	r26, 0x19	; 25
     e96:	8c 91       	ld	r24, X
     e98:	59 97       	sbiw	r26, 0x19	; 25
     e9a:	8f 93       	push	r24
     e9c:	58 96       	adiw	r26, 0x18	; 24
     e9e:	8c 91       	ld	r24, X
     ea0:	58 97       	sbiw	r26, 0x18	; 24
     ea2:	8f 93       	push	r24
     ea4:	57 96       	adiw	r26, 0x17	; 23
     ea6:	8c 91       	ld	r24, X
     ea8:	57 97       	sbiw	r26, 0x17	; 23
     eaa:	8f 93       	push	r24
     eac:	56 96       	adiw	r26, 0x16	; 22
     eae:	8c 91       	ld	r24, X
     eb0:	8f 93       	push	r24
     eb2:	39 81       	ldd	r19, Y+1	; 0x01
     eb4:	2a 81       	ldd	r18, Y+2	; 0x02
     eb6:	9b 81       	ldd	r25, Y+3	; 0x03
     eb8:	8c 81       	ldd	r24, Y+4	; 0x04
     eba:	c3 2e       	mov	r12, r19
     ebc:	d2 2e       	mov	r13, r18
     ebe:	e9 2e       	mov	r14, r25
     ec0:	f8 2e       	mov	r15, r24
     ec2:	5d 81       	ldd	r21, Y+5	; 0x05
     ec4:	4e 81       	ldd	r20, Y+6	; 0x06
     ec6:	9f 81       	ldd	r25, Y+7	; 0x07
     ec8:	88 85       	ldd	r24, Y+8	; 0x08
     eca:	05 2f       	mov	r16, r21
     ecc:	14 2f       	mov	r17, r20
     ece:	29 2f       	mov	r18, r25
     ed0:	38 2f       	mov	r19, r24
     ed2:	b3 01       	movw	r22, r6
     ed4:	a2 01       	movw	r20, r4
     ed6:	89 85       	ldd	r24, Y+9	; 0x09
     ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
     eda:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
     ede:	0f 90       	pop	r0
     ee0:	0f 90       	pop	r0
     ee2:	0f 90       	pop	r0
     ee4:	0f 90       	pop	r0
     ee6:	0f 90       	pop	r0
     ee8:	0f 90       	pop	r0
     eea:	ab 01       	movw	r20, r22
     eec:	bc 01       	movw	r22, r24

	
	
	xLongitudinalOuterLoopSetpoint = adjustForSetpointLimits(xLongitudinalOuterLoopSetpoint, minPitchSetpointRads, maxPitchSetpointRads);
     eee:	e9 85       	ldd	r30, Y+9	; 0x09
     ef0:	fa 85       	ldd	r31, Y+10	; 0x0a
     ef2:	ea 58       	subi	r30, 0x8A	; 138
     ef4:	ff 4f       	sbci	r31, 0xFF	; 255
     ef6:	c0 80       	ld	r12, Z
     ef8:	d1 80       	ldd	r13, Z+1	; 0x01
     efa:	e2 80       	ldd	r14, Z+2	; 0x02
     efc:	f3 80       	ldd	r15, Z+3	; 0x03
     efe:	e9 85       	ldd	r30, Y+9	; 0x09
     f00:	fa 85       	ldd	r31, Y+10	; 0x0a
     f02:	ee 58       	subi	r30, 0x8E	; 142
     f04:	ff 4f       	sbci	r31, 0xFF	; 255
     f06:	00 81       	ld	r16, Z
     f08:	11 81       	ldd	r17, Z+1	; 0x01
     f0a:	22 81       	ldd	r18, Z+2	; 0x02
     f0c:	33 81       	ldd	r19, Z+3	; 0x03
     f0e:	89 85       	ldd	r24, Y+9	; 0x09
     f10:	9a 85       	ldd	r25, Y+10	; 0x0a
     f12:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
     f16:	f1 01       	movw	r30, r2
     f18:	62 af       	std	Z+58, r22	; 0x3a
     f1a:	73 af       	std	Z+59, r23	; 0x3b
     f1c:	84 af       	std	Z+60, r24	; 0x3c
     f1e:	95 af       	std	Z+61, r25	; 0x3d

	model->XLongitudeOuterLoopSetpoint(xLongitudinalOuterLoopSetpoint);
	model->XIntegral(weightedXIntegral);
     f20:	a9 85       	ldd	r26, Y+9	; 0x09
     f22:	ba 85       	ldd	r27, Y+10	; 0x0a
     f24:	ed 91       	ld	r30, X+
     f26:	fc 91       	ld	r31, X
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
     f28:	ee 5b       	subi	r30, 0xBE	; 190
     f2a:	ff 4f       	sbci	r31, 0xFF	; 255
     f2c:	59 81       	ldd	r21, Y+1	; 0x01
     f2e:	4a 81       	ldd	r20, Y+2	; 0x02
     f30:	3b 81       	ldd	r19, Y+3	; 0x03
     f32:	2c 81       	ldd	r18, Y+4	; 0x04
     f34:	85 2f       	mov	r24, r21
     f36:	94 2f       	mov	r25, r20
     f38:	a3 2f       	mov	r26, r19
     f3a:	b2 2f       	mov	r27, r18
     f3c:	80 83       	st	Z, r24
     f3e:	91 83       	std	Z+1, r25	; 0x01
     f40:	a2 83       	std	Z+2, r26	; 0x02
     f42:	b3 83       	std	Z+3, r27	; 0x03
	model->XProportional(xProportional);
     f44:	a9 85       	ldd	r26, Y+9	; 0x09
     f46:	ba 85       	ldd	r27, Y+10	; 0x0a
     f48:	ed 91       	ld	r30, X+
     f4a:	fc 91       	ld	r31, X
     f4c:	11 97       	sbiw	r26, 0x01	; 1
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
     f4e:	fe 96       	adiw	r30, 0x3e	; 62
     f50:	40 82       	st	Z, r4
     f52:	51 82       	std	Z+1, r5	; 0x01
     f54:	62 82       	std	Z+2, r6	; 0x02
     f56:	73 82       	std	Z+3, r7	; 0x03
	model->XDerivativeError(xDerivativeError);
     f58:	ed 91       	ld	r30, X+
     f5a:	fc 91       	ld	r31, X
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
			void XDerivativeError(float val) { xDerivativeError = val;}
     f5c:	ea 5b       	subi	r30, 0xBA	; 186
     f5e:	ff 4f       	sbci	r31, 0xFF	; 255
     f60:	5d 81       	ldd	r21, Y+5	; 0x05
     f62:	4e 81       	ldd	r20, Y+6	; 0x06
     f64:	3f 81       	ldd	r19, Y+7	; 0x07
     f66:	28 85       	ldd	r18, Y+8	; 0x08
     f68:	85 2f       	mov	r24, r21
     f6a:	94 2f       	mov	r25, r20
     f6c:	a3 2f       	mov	r26, r19
     f6e:	b2 2f       	mov	r27, r18
     f70:	80 83       	st	Z, r24
     f72:	91 83       	std	Z+1, r25	; 0x01
     f74:	a2 83       	std	Z+2, r26	; 0x02
     f76:	b3 83       	std	Z+3, r27	; 0x03
}
     f78:	2a 96       	adiw	r28, 0x0a	; 10
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	de bf       	out	0x3e, r29	; 62
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	cd bf       	out	0x3d, r28	; 61
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	0f 91       	pop	r16
     f8c:	ff 90       	pop	r15
     f8e:	ef 90       	pop	r14
     f90:	df 90       	pop	r13
     f92:	cf 90       	pop	r12
     f94:	bf 90       	pop	r11
     f96:	af 90       	pop	r10
     f98:	9f 90       	pop	r9
     f9a:	8f 90       	pop	r8
     f9c:	7f 90       	pop	r7
     f9e:	6f 90       	pop	r6
     fa0:	5f 90       	pop	r5
     fa2:	4f 90       	pop	r4
     fa4:	3f 90       	pop	r3
     fa6:	2f 90       	pop	r2
     fa8:	08 95       	ret

00000faa <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>:

void PIDController::cyclicLateralOuterLoopUpdate(float yProportional)
{
     faa:	2f 92       	push	r2
     fac:	3f 92       	push	r3
     fae:	4f 92       	push	r4
     fb0:	5f 92       	push	r5
     fb2:	6f 92       	push	r6
     fb4:	7f 92       	push	r7
     fb6:	8f 92       	push	r8
     fb8:	9f 92       	push	r9
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
     fd2:	2a 97       	sbiw	r28, 0x0a	; 10
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	de bf       	out	0x3e, r29	; 62
     fda:	0f be       	out	0x3f, r0	; 63
     fdc:	cd bf       	out	0x3d, r28	; 61
     fde:	9a 87       	std	Y+10, r25	; 0x0a
     fe0:	89 87       	std	Y+9, r24	; 0x09
     fe2:	2a 01       	movw	r4, r20
     fe4:	3b 01       	movw	r6, r22
	//float yProportional = calculateProportional(model->YNEDLocalFrame(), model->ReferenceYNEDLocalFrame());
	float yIntegralAntiWindup = calculateIntegralAntiWindup(model->LateralControlBeforeServoLimitsAdjustment(), model->LateralControl(), yAntiWindupGain);
     fe6:	dc 01       	movw	r26, r24
     fe8:	2d 90       	ld	r2, X+
     fea:	3c 90       	ld	r3, X
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
     fec:	81 01       	movw	r16, r2
     fee:	02 59       	subi	r16, 0x92	; 146
     ff0:	1f 4f       	sbci	r17, 0xFF	; 255
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
     ff2:	f1 01       	movw	r30, r2
     ff4:	e6 5a       	subi	r30, 0xA6	; 166
     ff6:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
     ff8:	d1 01       	movw	r26, r2
     ffa:	aa 5a       	subi	r26, 0xAA	; 170
     ffc:	bf 4f       	sbci	r27, 0xFF	; 255
				inline float calculateIntegralAntiWindup(float oldControlPreServoAdj, float oldControl, float antiWindupGain)
				{
					float antiWindup = 0;
					
					//antiWindup = antiWindupGain * (oldControlPreServoAdj - oldControl);
					antiWindup = antiWindupGain * (oldControl - oldControlPreServoAdj);
     ffe:	2d 91       	ld	r18, X+
    1000:	3d 91       	ld	r19, X+
    1002:	4d 91       	ld	r20, X+
    1004:	5c 91       	ld	r21, X
    1006:	60 81       	ld	r22, Z
    1008:	71 81       	ldd	r23, Z+1	; 0x01
    100a:	82 81       	ldd	r24, Z+2	; 0x02
    100c:	93 81       	ldd	r25, Z+3	; 0x03
    100e:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    1012:	e9 85       	ldd	r30, Y+9	; 0x09
    1014:	fa 85       	ldd	r31, Y+10	; 0x0a
    1016:	26 a9       	ldd	r18, Z+54	; 0x36
    1018:	37 a9       	ldd	r19, Z+55	; 0x37
    101a:	40 ad       	ldd	r20, Z+56	; 0x38
    101c:	51 ad       	ldd	r21, Z+57	; 0x39
    101e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    1022:	6b 01       	movw	r12, r22
    1024:	7c 01       	movw	r14, r24
				 * I'm not directly using their algorithms
				 */
				inline float calculateIntegral(float proportional, float oldIntegral, float antiWindup, float integralGain)
				{
					float workingIntegral = 0;
					workingIntegral = proportional * integralGain + antiWindup;
    1026:	a9 85       	ldd	r26, Y+9	; 0x09
    1028:	ba 85       	ldd	r27, Y+10	; 0x0a
    102a:	9a 96       	adiw	r26, 0x2a	; 42
    102c:	2d 91       	ld	r18, X+
    102e:	3d 91       	ld	r19, X+
    1030:	4d 91       	ld	r20, X+
    1032:	5c 91       	ld	r21, X
    1034:	9d 97       	sbiw	r26, 0x2d	; 45
    1036:	c3 01       	movw	r24, r6
    1038:	b2 01       	movw	r22, r4
    103a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    103e:	9b 01       	movw	r18, r22
    1040:	ac 01       	movw	r20, r24
    1042:	c7 01       	movw	r24, r14
    1044:	b6 01       	movw	r22, r12
    1046:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
					workingIntegral = workingIntegral * intervalPeriodSecs + oldIntegral;
    104a:	e9 85       	ldd	r30, Y+9	; 0x09
    104c:	fa 85       	ldd	r31, Y+10	; 0x0a
    104e:	ee 57       	subi	r30, 0x7E	; 126
    1050:	ff 4f       	sbci	r31, 0xFF	; 255
    1052:	20 81       	ld	r18, Z
    1054:	31 81       	ldd	r19, Z+1	; 0x01
    1056:	42 81       	ldd	r20, Z+2	; 0x02
    1058:	53 81       	ldd	r21, Z+3	; 0x03
    105a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    105e:	f8 01       	movw	r30, r16
    1060:	20 81       	ld	r18, Z
    1062:	31 81       	ldd	r19, Z+1	; 0x01
    1064:	42 81       	ldd	r20, Z+2	; 0x02
    1066:	53 81       	ldd	r21, Z+3	; 0x03
    1068:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    106c:	69 83       	std	Y+1, r22	; 0x01
    106e:	7a 83       	std	Y+2, r23	; 0x02
    1070:	8b 83       	std	Y+3, r24	; 0x03
    1072:	9c 83       	std	Y+4, r25	; 0x04
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    1074:	f1 01       	movw	r30, r2
    1076:	e2 5a       	subi	r30, 0xA2	; 162
    1078:	ff 4f       	sbci	r31, 0xFF	; 255
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
    107a:	d1 01       	movw	r26, r2
    107c:	ae 59       	subi	r26, 0x9E	; 158
    107e:	bf 4f       	sbci	r27, 0xFF	; 255
				 * @referenceYawVelocityDegreesPerSecond the desired velocity of rotation in the yaw direction in degrees per second
				 * @return the difference between the two parameters in degrees per second.
				 */
				inline float calculateVelocityError(float currentVelocity, float referenceVelocity)
				{
					return currentVelocity - referenceVelocity;
    1080:	2d 91       	ld	r18, X+
    1082:	3d 91       	ld	r19, X+
    1084:	4d 91       	ld	r20, X+
    1086:	5c 91       	ld	r21, X
    1088:	60 81       	ld	r22, Z
    108a:	71 81       	ldd	r23, Z+1	; 0x01
    108c:	82 81       	ldd	r24, Z+2	; 0x02
    108e:	93 81       	ldd	r25, Z+3	; 0x03
    1090:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    1094:	6d 83       	std	Y+5, r22	; 0x05
    1096:	7e 83       	std	Y+6, r23	; 0x06
    1098:	8f 83       	std	Y+7, r24	; 0x07
    109a:	98 87       	std	Y+8, r25	; 0x08
	//we use a -1 direction factor because unlike other controls, if we have a positive proportional error, we actually need a 'negative' desired 
	//roll setpoint in order for the helicopter to track back towards the desired position. So if the helicopter is directly 'east' of the desired position,
	//the proportional error will correctly be positive (in a North-east-down coordinate system), but the helicopter will have to roll counter clockwise
	//to return to the desired position. This differs from if the helicopter was directly north of the desired position. The x proportional would be positive
	//(in NED), but it would take a positive pitch angle setpoint to get the helicopter to return to the desired position.
	float yLateralOuterLoopSetpoint = calculateOuterLoopControlValue(yProportional, yDerivativeError, weightedYIntegral, yProportionalGain, yDerivativeGain, -1);
    109c:	a9 85       	ldd	r26, Y+9	; 0x09
    109e:	ba 85       	ldd	r27, Y+10	; 0x0a
    10a0:	d2 96       	adiw	r26, 0x32	; 50
    10a2:	8d 90       	ld	r8, X+
    10a4:	9d 90       	ld	r9, X+
    10a6:	ad 90       	ld	r10, X+
    10a8:	bc 90       	ld	r11, X
    10aa:	d5 97       	sbiw	r26, 0x35	; 53
    10ac:	8f ef       	ldi	r24, 0xFF	; 255
    10ae:	8f 93       	push	r24
    10b0:	8f 93       	push	r24
    10b2:	d1 96       	adiw	r26, 0x31	; 49
    10b4:	8c 91       	ld	r24, X
    10b6:	d1 97       	sbiw	r26, 0x31	; 49
    10b8:	8f 93       	push	r24
    10ba:	d0 96       	adiw	r26, 0x30	; 48
    10bc:	8c 91       	ld	r24, X
    10be:	d0 97       	sbiw	r26, 0x30	; 48
    10c0:	8f 93       	push	r24
    10c2:	9f 96       	adiw	r26, 0x2f	; 47
    10c4:	8c 91       	ld	r24, X
    10c6:	9f 97       	sbiw	r26, 0x2f	; 47
    10c8:	8f 93       	push	r24
    10ca:	9e 96       	adiw	r26, 0x2e	; 46
    10cc:	8c 91       	ld	r24, X
    10ce:	8f 93       	push	r24
    10d0:	39 81       	ldd	r19, Y+1	; 0x01
    10d2:	2a 81       	ldd	r18, Y+2	; 0x02
    10d4:	9b 81       	ldd	r25, Y+3	; 0x03
    10d6:	8c 81       	ldd	r24, Y+4	; 0x04
    10d8:	c3 2e       	mov	r12, r19
    10da:	d2 2e       	mov	r13, r18
    10dc:	e9 2e       	mov	r14, r25
    10de:	f8 2e       	mov	r15, r24
    10e0:	5d 81       	ldd	r21, Y+5	; 0x05
    10e2:	4e 81       	ldd	r20, Y+6	; 0x06
    10e4:	9f 81       	ldd	r25, Y+7	; 0x07
    10e6:	88 85       	ldd	r24, Y+8	; 0x08
    10e8:	05 2f       	mov	r16, r21
    10ea:	14 2f       	mov	r17, r20
    10ec:	29 2f       	mov	r18, r25
    10ee:	38 2f       	mov	r19, r24
    10f0:	b3 01       	movw	r22, r6
    10f2:	a2 01       	movw	r20, r4
    10f4:	89 85       	ldd	r24, Y+9	; 0x09
    10f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f8:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10helicopter10controller13PIDController30calculateOuterLoopControlValueEfffffi>
    10fc:	0f 90       	pop	r0
    10fe:	0f 90       	pop	r0
    1100:	0f 90       	pop	r0
    1102:	0f 90       	pop	r0
    1104:	0f 90       	pop	r0
    1106:	0f 90       	pop	r0
    1108:	ab 01       	movw	r20, r22
    110a:	bc 01       	movw	r22, r24

	yLateralOuterLoopSetpoint = adjustForSetpointLimits(yLateralOuterLoopSetpoint, minRollSetpointRads, maxRollSetpointRads);
    110c:	e9 85       	ldd	r30, Y+9	; 0x09
    110e:	fa 85       	ldd	r31, Y+10	; 0x0a
    1110:	e2 58       	subi	r30, 0x82	; 130
    1112:	ff 4f       	sbci	r31, 0xFF	; 255
    1114:	c0 80       	ld	r12, Z
    1116:	d1 80       	ldd	r13, Z+1	; 0x01
    1118:	e2 80       	ldd	r14, Z+2	; 0x02
    111a:	f3 80       	ldd	r15, Z+3	; 0x03
    111c:	e9 85       	ldd	r30, Y+9	; 0x09
    111e:	fa 85       	ldd	r31, Y+10	; 0x0a
    1120:	e6 58       	subi	r30, 0x86	; 134
    1122:	ff 4f       	sbci	r31, 0xFF	; 255
    1124:	00 81       	ld	r16, Z
    1126:	11 81       	ldd	r17, Z+1	; 0x01
    1128:	22 81       	ldd	r18, Z+2	; 0x02
    112a:	33 81       	ldd	r19, Z+3	; 0x03
    112c:	89 85       	ldd	r24, Y+9	; 0x09
    112e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1130:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN10helicopter10controller13PIDController23adjustForSetpointLimitsEfff>
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}
    1134:	f1 01       	movw	r30, r2
    1136:	ea 59       	subi	r30, 0x9A	; 154
    1138:	ff 4f       	sbci	r31, 0xFF	; 255
    113a:	60 83       	st	Z, r22
    113c:	71 83       	std	Z+1, r23	; 0x01
    113e:	82 83       	std	Z+2, r24	; 0x02
    1140:	93 83       	std	Z+3, r25	; 0x03
	
	model->YLateralOuterLoopSetpoint(yLateralOuterLoopSetpoint);
	model->YIntegral(weightedYIntegral);
    1142:	a9 85       	ldd	r26, Y+9	; 0x09
    1144:	ba 85       	ldd	r27, Y+10	; 0x0a
    1146:	ed 91       	ld	r30, X+
    1148:	fc 91       	ld	r31, X

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}
    114a:	e2 59       	subi	r30, 0x92	; 146
    114c:	ff 4f       	sbci	r31, 0xFF	; 255
    114e:	59 81       	ldd	r21, Y+1	; 0x01
    1150:	4a 81       	ldd	r20, Y+2	; 0x02
    1152:	3b 81       	ldd	r19, Y+3	; 0x03
    1154:	2c 81       	ldd	r18, Y+4	; 0x04
    1156:	85 2f       	mov	r24, r21
    1158:	94 2f       	mov	r25, r20
    115a:	a3 2f       	mov	r26, r19
    115c:	b2 2f       	mov	r27, r18
    115e:	80 83       	st	Z, r24
    1160:	91 83       	std	Z+1, r25	; 0x01
    1162:	a2 83       	std	Z+2, r26	; 0x02
    1164:	b3 83       	std	Z+3, r27	; 0x03
	model->YProportional(yProportional);
    1166:	a9 85       	ldd	r26, Y+9	; 0x09
    1168:	ba 85       	ldd	r27, Y+10	; 0x0a
    116a:	ed 91       	ld	r30, X+
    116c:	fc 91       	ld	r31, X
    116e:	11 97       	sbiw	r26, 0x01	; 1

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}
    1170:	e6 59       	subi	r30, 0x96	; 150
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	40 82       	st	Z, r4
    1176:	51 82       	std	Z+1, r5	; 0x01
    1178:	62 82       	std	Z+2, r6	; 0x02
    117a:	73 82       	std	Z+3, r7	; 0x03
	model->YDerivativeError(yDerivativeError);
    117c:	ed 91       	ld	r30, X+
    117e:	fc 91       	ld	r31, X

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
			void YDerivativeError(float val) { yDerivativeError = val;}
    1180:	ee 58       	subi	r30, 0x8E	; 142
    1182:	ff 4f       	sbci	r31, 0xFF	; 255
    1184:	5d 81       	ldd	r21, Y+5	; 0x05
    1186:	4e 81       	ldd	r20, Y+6	; 0x06
    1188:	3f 81       	ldd	r19, Y+7	; 0x07
    118a:	28 85       	ldd	r18, Y+8	; 0x08
    118c:	85 2f       	mov	r24, r21
    118e:	94 2f       	mov	r25, r20
    1190:	a3 2f       	mov	r26, r19
    1192:	b2 2f       	mov	r27, r18
    1194:	80 83       	st	Z, r24
    1196:	91 83       	std	Z+1, r25	; 0x01
    1198:	a2 83       	std	Z+2, r26	; 0x02
    119a:	b3 83       	std	Z+3, r27	; 0x03
}
    119c:	2a 96       	adiw	r28, 0x0a	; 10
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	df 91       	pop	r29
    11aa:	cf 91       	pop	r28
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	df 90       	pop	r13
    11b6:	cf 90       	pop	r12
    11b8:	bf 90       	pop	r11
    11ba:	af 90       	pop	r10
    11bc:	9f 90       	pop	r9
    11be:	8f 90       	pop	r8
    11c0:	7f 90       	pop	r7
    11c2:	6f 90       	pop	r6
    11c4:	5f 90       	pop	r5
    11c6:	4f 90       	pop	r4
    11c8:	3f 90       	pop	r3
    11ca:	2f 90       	pop	r2
    11cc:	08 95       	ret

000011ce <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>:




void PIDController::outerLoopUpdate()
{
    11ce:	2f 92       	push	r2
    11d0:	3f 92       	push	r3
    11d2:	4f 92       	push	r4
    11d4:	5f 92       	push	r5
    11d6:	6f 92       	push	r6
    11d8:	7f 92       	push	r7
    11da:	8f 92       	push	r8
    11dc:	9f 92       	push	r9
    11de:	af 92       	push	r10
    11e0:	bf 92       	push	r11
    11e2:	cf 92       	push	r12
    11e4:	df 92       	push	r13
    11e6:	ef 92       	push	r14
    11e8:	ff 92       	push	r15
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	cd b7       	in	r28, 0x3d	; 61
    11f4:	de b7       	in	r29, 0x3e	; 62
    11f6:	68 97       	sbiw	r28, 0x18	; 24
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	cd bf       	out	0x3d, r28	; 61
    1202:	8c 01       	movw	r16, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1204:	fc 01       	movw	r30, r24
    1206:	a0 80       	ld	r10, Z
    1208:	b1 80       	ldd	r11, Z+1	; 0x01
    120a:	f5 01       	movw	r30, r10
    120c:	82 81       	ldd	r24, Z+2	; 0x02
    120e:	81 30       	cpi	r24, 0x01	; 1
    1210:	09 f0       	breq	.+2      	; 0x1214 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x46>
    1212:	78 c0       	rjmp	.+240    	; 0x1304 <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0x136>
					this->controlMinValue = controlMinValue;
				}			
				
				inline float calculateProportional(float currentValue, float referenceValue)
				{
					return currentValue - referenceValue;
    1214:	26 a1       	ldd	r18, Z+38	; 0x26
    1216:	37 a1       	ldd	r19, Z+39	; 0x27
    1218:	40 a5       	ldd	r20, Z+40	; 0x28
    121a:	51 a5       	ldd	r21, Z+41	; 0x29
    121c:	62 a1       	ldd	r22, Z+34	; 0x22
    121e:	73 a1       	ldd	r23, Z+35	; 0x23
    1220:	84 a1       	ldd	r24, Z+36	; 0x24
    1222:	95 a1       	ldd	r25, Z+37	; 0x25
    1224:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    1228:	26 2e       	mov	r2, r22
    122a:	37 2e       	mov	r3, r23
    122c:	48 2e       	mov	r4, r24
    122e:	59 2e       	mov	r5, r25
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    1230:	f5 01       	movw	r30, r10
    1232:	e2 5b       	subi	r30, 0xB2	; 178
    1234:	ff 4f       	sbci	r31, 0xFF	; 255
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    1236:	d5 01       	movw	r26, r10
    1238:	ae 5a       	subi	r26, 0xAE	; 174
    123a:	bf 4f       	sbci	r27, 0xFF	; 255
    123c:	2d 91       	ld	r18, X+
    123e:	3d 91       	ld	r19, X+
    1240:	4d 91       	ld	r20, X+
    1242:	5c 91       	ld	r21, X
    1244:	60 81       	ld	r22, Z
    1246:	71 81       	ldd	r23, Z+1	; 0x01
    1248:	82 81       	ldd	r24, Z+2	; 0x02
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    1250:	c6 2e       	mov	r12, r22
    1252:	d7 2e       	mov	r13, r23
    1254:	e8 2e       	mov	r14, r24
    1256:	f9 2e       	mov	r15, r25
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    1258:	f5 01       	movw	r30, r10
    125a:	e2 58       	subi	r30, 0x82	; 130
    125c:	ff 4f       	sbci	r31, 0xFF	; 255
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    125e:	d5 01       	movw	r26, r10
    1260:	ae 57       	subi	r26, 0x7E	; 126
    1262:	bf 4f       	sbci	r27, 0xFF	; 255
    1264:	2d 91       	ld	r18, X+
    1266:	3d 91       	ld	r19, X+
    1268:	4d 91       	ld	r20, X+
    126a:	5c 91       	ld	r21, X
    126c:	60 81       	ld	r22, Z
    126e:	71 81       	ldd	r23, Z+1	; 0x01
    1270:	82 81       	ldd	r24, Z+2	; 0x02
    1272:	93 81       	ldd	r25, Z+3	; 0x03
    1274:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    1278:	66 2e       	mov	r6, r22
    127a:	77 2e       	mov	r7, r23
    127c:	88 2e       	mov	r8, r24
    127e:	99 2e       	mov	r9, r25
		float yErrorNED = calculateProportional(model->YNEDLocalFrameCm(), model->ReferenceYNEDLocalFrameCm());
		float zErrorNED = calculateProportional(model->ZNEDLocalFrameCm(), model->ReferenceZNEDLocalFrameCm());
	
	
		//convert position error from NED to FRD Body frame.
		float bodyFrameErrors[3] = {};
    1280:	ae 01       	movw	r20, r28
    1282:	43 5f       	subi	r20, 0xF3	; 243
    1284:	5f 4f       	sbci	r21, 0xFF	; 255
    1286:	8c e0       	ldi	r24, 0x0C	; 12
    1288:	fa 01       	movw	r30, r20
    128a:	11 92       	st	Z+, r1
    128c:	8a 95       	dec	r24
    128e:	e9 f7       	brne	.-6      	; 0x128a <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv+0xbc>
		float nedToBodyFrameRotationMatrix[3][3] = {};
		float positionErrorsLocalNED[3] = {xErrorNED, yErrorNED, zErrorNED};
    1290:	82 2d       	mov	r24, r2
    1292:	93 2d       	mov	r25, r3
    1294:	a4 2d       	mov	r26, r4
    1296:	b5 2d       	mov	r27, r5
    1298:	89 83       	std	Y+1, r24	; 0x01
    129a:	9a 83       	std	Y+2, r25	; 0x02
    129c:	ab 83       	std	Y+3, r26	; 0x03
    129e:	bc 83       	std	Y+4, r27	; 0x04
    12a0:	8c 2d       	mov	r24, r12
    12a2:	9d 2d       	mov	r25, r13
    12a4:	ae 2d       	mov	r26, r14
    12a6:	bf 2d       	mov	r27, r15
    12a8:	8d 83       	std	Y+5, r24	; 0x05
    12aa:	9e 83       	std	Y+6, r25	; 0x06
    12ac:	af 83       	std	Y+7, r26	; 0x07
    12ae:	b8 87       	std	Y+8, r27	; 0x08
    12b0:	c6 2c       	mov	r12, r6
    12b2:	d7 2c       	mov	r13, r7
    12b4:	e8 2c       	mov	r14, r8
    12b6:	f9 2c       	mov	r15, r9
    12b8:	c9 86       	std	Y+9, r12	; 0x09
    12ba:	da 86       	std	Y+10, r13	; 0x0a
    12bc:	eb 86       	std	Y+11, r14	; 0x0b
    12be:	fc 86       	std	Y+12, r15	; 0x0c
	
		//MatrixUtil::CreateRotationMatrixTransposed(model->RollRads(), model->PitchRads(), model->YawRads(), nedToBodyFrameRotationMatrix);
		//MatrixUtil::RotateMatrix(nedToBodyFrameRotationMatrix, positionErrorsLocalNED, bodyFrameErrors);
	
	
		MatrixUtil::RotateMatrixT(model->Ahrs()->dcm, positionErrorsLocalNED, bodyFrameErrors);
    12c0:	f5 01       	movw	r30, r10
    12c2:	80 81       	ld	r24, Z
    12c4:	91 81       	ldd	r25, Z+1	; 0x01
    12c6:	be 01       	movw	r22, r28
    12c8:	6f 5f       	subi	r22, 0xFF	; 255
    12ca:	7f 4f       	sbci	r23, 0xFF	; 255
    12cc:	80 5c       	subi	r24, 0xC0	; 192
    12ce:	9f 4f       	sbci	r25, 0xFF	; 255
    12d0:	0e 94 57 68 	call	0xd0ae	; 0xd0ae <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	

		this->cyclicLongitudeOuterLoopUpdate(bodyFrameErrors[0]);
    12d4:	4d 85       	ldd	r20, Y+13	; 0x0d
    12d6:	5e 85       	ldd	r21, Y+14	; 0x0e
    12d8:	6f 85       	ldd	r22, Y+15	; 0x0f
    12da:	78 89       	ldd	r23, Y+16	; 0x10
    12dc:	c8 01       	movw	r24, r16
    12de:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZN10helicopter10controller13PIDController30cyclicLongitudeOuterLoopUpdateEf>
		this->cyclicLateralOuterLoopUpdate(bodyFrameErrors[1]);	
    12e2:	49 89       	ldd	r20, Y+17	; 0x11
    12e4:	5a 89       	ldd	r21, Y+18	; 0x12
    12e6:	6b 89       	ldd	r22, Y+19	; 0x13
    12e8:	7c 89       	ldd	r23, Y+20	; 0x14
    12ea:	c8 01       	movw	r24, r16
    12ec:	0e 94 d5 07 	call	0xfaa	; 0xfaa <_ZN10helicopter10controller13PIDController28cyclicLateralOuterLoopUpdateEf>
//		this->mainRotorCollectiveOuterLoopUpdate(bodyFrameErrors[2]);	
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
    12f0:	46 2d       	mov	r20, r6
    12f2:	57 2d       	mov	r21, r7
    12f4:	68 2d       	mov	r22, r8
    12f6:	79 2d       	mov	r23, r9
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 b4 05 	call	0xb68	; 0xb68 <_ZN10helicopter10controller13PIDController34mainRotorCollectiveOuterLoopUpdateEf>
		this->tailRotorCollectiveOuterLoopUpdate();
    12fe:	c8 01       	movw	r24, r16
    1300:	0e 94 5d 04 	call	0x8ba	; 0x8ba <_ZN10helicopter10controller13PIDController34tailRotorCollectiveOuterLoopUpdateEv>
		this->cyclicLongitudeOuterLoopUpdate(xErrorNED);
		this->cyclicLateralOuterLoopUpdate(yErrorNED);
		this->mainRotorCollectiveOuterLoopUpdate(zErrorNED);	//Just use regular error NED because altitude doesn't care about orientation.
		this->tailRotorCollectiveOuterLoopUpdate();*/
	}
}
    1304:	68 96       	adiw	r28, 0x18	; 24
    1306:	0f b6       	in	r0, 0x3f	; 63
    1308:	f8 94       	cli
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	0f be       	out	0x3f, r0	; 63
    130e:	cd bf       	out	0x3d, r28	; 61
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	9f 90       	pop	r9
    1326:	8f 90       	pop	r8
    1328:	7f 90       	pop	r7
    132a:	6f 90       	pop	r6
    132c:	5f 90       	pop	r5
    132e:	4f 90       	pop	r4
    1330:	3f 90       	pop	r3
    1332:	2f 90       	pop	r2
    1334:	08 95       	ret

00001336 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>:
	model->YProportional(yProportional);
	model->YDerivativeError(yDerivativeError);
}

void PIDController::cyclicLongitudeInnerLoopUpdate()
{
    1336:	4f 92       	push	r4
    1338:	5f 92       	push	r5
    133a:	6f 92       	push	r6
    133c:	7f 92       	push	r7
    133e:	8f 92       	push	r8
    1340:	9f 92       	push	r9
    1342:	af 92       	push	r10
    1344:	bf 92       	push	r11
    1346:	cf 92       	push	r12
    1348:	df 92       	push	r13
    134a:	ef 92       	push	r14
    134c:	ff 92       	push	r15
    134e:	0f 93       	push	r16
    1350:	1f 93       	push	r17
    1352:	cf 93       	push	r28
    1354:	df 93       	push	r29
    1356:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1358:	88 80       	ld	r8, Y
    135a:	99 80       	ldd	r9, Y+1	; 0x01
    135c:	f4 01       	movw	r30, r8
    135e:	82 81       	ldd	r24, Z+2	; 0x02
    1360:	81 30       	cpi	r24, 0x01	; 1
    1362:	09 f0       	breq	.+2      	; 0x1366 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0x30>
    1364:	47 c0       	rjmp	.+142    	; 0x13f4 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv+0xbe>
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    1366:	e6 52       	subi	r30, 0x26	; 38
    1368:	ff 4f       	sbci	r31, 0xFF	; 255
	{
		float xLongitudinalInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->XLongitudeOuterLoopSetpoint(), model->PitchRads(), longitudeInnerLoopGain, model->PitchAngularVelocityRadsPerSecond(), pitchAngularVelocityGain);
    136a:	a0 80       	ld	r10, Z
    136c:	b1 80       	ldd	r11, Z+1	; 0x01
    136e:	c2 80       	ldd	r12, Z+2	; 0x02
    1370:	d3 80       	ldd	r13, Z+3	; 0x03
    1372:	ea a0       	ldd	r14, Y+34	; 0x22
    1374:	fb a0       	ldd	r15, Y+35	; 0x23
    1376:	0c a1       	ldd	r16, Y+36	; 0x24
    1378:	1d a1       	ldd	r17, Y+37	; 0x25
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    137a:	f4 01       	movw	r30, r8
    137c:	ee 52       	subi	r30, 0x2E	; 46
    137e:	ff 4f       	sbci	r31, 0xFF	; 255
    1380:	20 81       	ld	r18, Z
    1382:	31 81       	ldd	r19, Z+1	; 0x01
    1384:	42 81       	ldd	r20, Z+2	; 0x02
    1386:	53 81       	ldd	r21, Z+3	; 0x03
    1388:	f4 01       	movw	r30, r8
    138a:	62 ad       	ldd	r22, Z+58	; 0x3a
    138c:	73 ad       	ldd	r23, Z+59	; 0x3b
    138e:	84 ad       	ldd	r24, Z+60	; 0x3c
    1390:	95 ad       	ldd	r25, Z+61	; 0x3d
    1392:	e9 a5       	ldd	r30, Y+41	; 0x29
    1394:	ef 93       	push	r30
    1396:	e8 a5       	ldd	r30, Y+40	; 0x28
    1398:	ef 93       	push	r30
    139a:	ef a1       	ldd	r30, Y+39	; 0x27
    139c:	ef 93       	push	r30
    139e:	ee a1       	ldd	r30, Y+38	; 0x26
    13a0:	ef 93       	push	r30
    13a2:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <_Z30calculateInnerLoopControlValuefffff>
    13a6:	0f 90       	pop	r0
    13a8:	0f 90       	pop	r0
    13aa:	0f 90       	pop	r0
    13ac:	0f 90       	pop	r0
    13ae:	2b 01       	movw	r4, r22
    13b0:	3c 01       	movw	r6, r24
		
		float xLongitudinalInnerLoopControl = adjustControlForServoLimits(xLongitudinalInnerLoopControlBeforeServoLimits, minLongitudeServoControlValue, maxLongitudeServoControlValue);
    13b2:	fe 01       	movw	r30, r28
    13b4:	e2 5a       	subi	r30, 0xA2	; 162
    13b6:	ff 4f       	sbci	r31, 0xFF	; 255
    13b8:	c0 80       	ld	r12, Z
    13ba:	d1 80       	ldd	r13, Z+1	; 0x01
    13bc:	e2 80       	ldd	r14, Z+2	; 0x02
    13be:	f3 80       	ldd	r15, Z+3	; 0x03
    13c0:	fe 01       	movw	r30, r28
    13c2:	e6 5a       	subi	r30, 0xA6	; 166
    13c4:	ff 4f       	sbci	r31, 0xFF	; 255
    13c6:	00 81       	ld	r16, Z
    13c8:	11 81       	ldd	r17, Z+1	; 0x01
    13ca:	22 81       	ldd	r18, Z+2	; 0x02
    13cc:	33 81       	ldd	r19, Z+3	; 0x03
    13ce:	ab 01       	movw	r20, r22
    13d0:	bc 01       	movw	r22, r24
    13d2:	ce 01       	movw	r24, r28
    13d4:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}
    13d8:	f4 01       	movw	r30, r8
    13da:	42 a6       	std	Z+42, r4	; 0x2a
    13dc:	53 a6       	std	Z+43, r5	; 0x2b
    13de:	64 a6       	std	Z+44, r6	; 0x2c
    13e0:	75 a6       	std	Z+45, r7	; 0x2d
		model->LongitudeControlBeforeServoLimitsAdjustment(xLongitudinalInnerLoopControlBeforeServoLimits);
	
//		model->LongitudeControl(xLongitudinalInnerLoopControl);

		//Multiply by -1 because in the simulator, a control value of +1 results in the helicopter pitching up, but the real helicopter pitches down.
		model->LongitudeControl(xLongitudinalInnerLoopControl * -1);
    13e2:	e8 81       	ld	r30, Y
    13e4:	f9 81       	ldd	r31, Y+1	; 0x01
    13e6:	dc 01       	movw	r26, r24
    13e8:	cb 01       	movw	r24, r22
    13ea:	b0 58       	subi	r27, 0x80	; 128

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
    13ec:	86 a7       	std	Z+46, r24	; 0x2e
    13ee:	97 a7       	std	Z+47, r25	; 0x2f
    13f0:	a0 ab       	std	Z+48, r26	; 0x30
    13f2:	b1 ab       	std	Z+49, r27	; 0x31
	}
}
    13f4:	df 91       	pop	r29
    13f6:	cf 91       	pop	r28
    13f8:	1f 91       	pop	r17
    13fa:	0f 91       	pop	r16
    13fc:	ff 90       	pop	r15
    13fe:	ef 90       	pop	r14
    1400:	df 90       	pop	r13
    1402:	cf 90       	pop	r12
    1404:	bf 90       	pop	r11
    1406:	af 90       	pop	r10
    1408:	9f 90       	pop	r9
    140a:	8f 90       	pop	r8
    140c:	7f 90       	pop	r7
    140e:	6f 90       	pop	r6
    1410:	5f 90       	pop	r5
    1412:	4f 90       	pop	r4
    1414:	08 95       	ret

00001416 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>:

void PIDController::cyclicLateralInnerLoopUpdate()
{
    1416:	4f 92       	push	r4
    1418:	5f 92       	push	r5
    141a:	6f 92       	push	r6
    141c:	7f 92       	push	r7
    141e:	8f 92       	push	r8
    1420:	9f 92       	push	r9
    1422:	af 92       	push	r10
    1424:	bf 92       	push	r11
    1426:	cf 92       	push	r12
    1428:	df 92       	push	r13
    142a:	ef 92       	push	r14
    142c:	ff 92       	push	r15
    142e:	0f 93       	push	r16
    1430:	1f 93       	push	r17
    1432:	cf 93       	push	r28
    1434:	df 93       	push	r29
    1436:	ec 01       	movw	r28, r24
	if (model->OperationalState() == SystemModel::AutoPilot)
    1438:	88 80       	ld	r8, Y
    143a:	99 80       	ldd	r9, Y+1	; 0x01
    143c:	f4 01       	movw	r30, r8
    143e:	82 81       	ldd	r24, Z+2	; 0x02
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	09 f0       	breq	.+2      	; 0x1446 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0x30>
    1444:	4c c0       	rjmp	.+152    	; 0x14de <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv+0xc8>
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    1446:	e2 52       	subi	r30, 0x22	; 34
    1448:	ff 4f       	sbci	r31, 0xFF	; 255
	{
		float yLateralInnerLoopControlBeforeServoLimits = calculateInnerLoopControlValue(model->YLateralOuterLoopSetpoint(), model->RollRads(), lateralInnerLoopGain, model->RollAngularVelocityRadsPerSecond(), rollAngularVelocityGain);
    144a:	a0 80       	ld	r10, Z
    144c:	b1 80       	ldd	r11, Z+1	; 0x01
    144e:	c2 80       	ldd	r12, Z+2	; 0x02
    1450:	d3 80       	ldd	r13, Z+3	; 0x03
    1452:	ea ac       	ldd	r14, Y+58	; 0x3a
    1454:	fb ac       	ldd	r15, Y+59	; 0x3b
    1456:	0c ad       	ldd	r16, Y+60	; 0x3c
    1458:	1d ad       	ldd	r17, Y+61	; 0x3d
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    145a:	f4 01       	movw	r30, r8
    145c:	e2 53       	subi	r30, 0x32	; 50
    145e:	ff 4f       	sbci	r31, 0xFF	; 255
    1460:	20 81       	ld	r18, Z
    1462:	31 81       	ldd	r19, Z+1	; 0x01
    1464:	42 81       	ldd	r20, Z+2	; 0x02
    1466:	53 81       	ldd	r21, Z+3	; 0x03
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
    1468:	f4 01       	movw	r30, r8
    146a:	ea 59       	subi	r30, 0x9A	; 154
    146c:	ff 4f       	sbci	r31, 0xFF	; 255
    146e:	60 81       	ld	r22, Z
    1470:	71 81       	ldd	r23, Z+1	; 0x01
    1472:	82 81       	ldd	r24, Z+2	; 0x02
    1474:	93 81       	ldd	r25, Z+3	; 0x03
    1476:	fe 01       	movw	r30, r28
    1478:	fe 96       	adiw	r30, 0x3e	; 62
    147a:	a3 81       	ldd	r26, Z+3	; 0x03
    147c:	af 93       	push	r26
    147e:	a2 81       	ldd	r26, Z+2	; 0x02
    1480:	af 93       	push	r26
    1482:	a1 81       	ldd	r26, Z+1	; 0x01
    1484:	af 93       	push	r26
    1486:	e0 81       	ld	r30, Z
    1488:	ef 93       	push	r30
    148a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <_Z30calculateInnerLoopControlValuefffff>
    148e:	0f 90       	pop	r0
    1490:	0f 90       	pop	r0
    1492:	0f 90       	pop	r0
    1494:	0f 90       	pop	r0
    1496:	2b 01       	movw	r4, r22
    1498:	3c 01       	movw	r6, r24
		
		float yLateralInnerLoopControl = adjustControlForServoLimits(yLateralInnerLoopControlBeforeServoLimits, minLateralServoControlValue, maxLateralServoControlValue);
    149a:	fe 01       	movw	r30, r28
    149c:	ea 59       	subi	r30, 0x9A	; 154
    149e:	ff 4f       	sbci	r31, 0xFF	; 255
    14a0:	c0 80       	ld	r12, Z
    14a2:	d1 80       	ldd	r13, Z+1	; 0x01
    14a4:	e2 80       	ldd	r14, Z+2	; 0x02
    14a6:	f3 80       	ldd	r15, Z+3	; 0x03
    14a8:	fe 01       	movw	r30, r28
    14aa:	ee 59       	subi	r30, 0x9E	; 158
    14ac:	ff 4f       	sbci	r31, 0xFF	; 255
    14ae:	00 81       	ld	r16, Z
    14b0:	11 81       	ldd	r17, Z+1	; 0x01
    14b2:	22 81       	ldd	r18, Z+2	; 0x02
    14b4:	33 81       	ldd	r19, Z+3	; 0x03
    14b6:	ab 01       	movw	r20, r22
    14b8:	bc 01       	movw	r22, r24
    14ba:	ce 01       	movw	r24, r28
    14bc:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN10helicopter10controller13PIDController27adjustControlForServoLimitsEfff>

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}
    14c0:	f4 01       	movw	r30, r8
    14c2:	ea 5a       	subi	r30, 0xAA	; 170
    14c4:	ff 4f       	sbci	r31, 0xFF	; 255
    14c6:	40 82       	st	Z, r4
    14c8:	51 82       	std	Z+1, r5	; 0x01
    14ca:	62 82       	std	Z+2, r6	; 0x02
    14cc:	73 82       	std	Z+3, r7	; 0x03
		
		model->LateralControlBeforeServoLimitsAdjustment(yLateralInnerLoopControlBeforeServoLimits);
		
		model->LateralControl(yLateralInnerLoopControl);		
    14ce:	e8 81       	ld	r30, Y
    14d0:	f9 81       	ldd	r31, Y+1	; 0x01

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}
    14d2:	e6 5a       	subi	r30, 0xA6	; 166
    14d4:	ff 4f       	sbci	r31, 0xFF	; 255
    14d6:	60 83       	st	Z, r22
    14d8:	71 83       	std	Z+1, r23	; 0x01
    14da:	82 83       	std	Z+2, r24	; 0x02
    14dc:	93 83       	std	Z+3, r25	; 0x03
	}
}
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	df 90       	pop	r13
    14ec:	cf 90       	pop	r12
    14ee:	bf 90       	pop	r11
    14f0:	af 90       	pop	r10
    14f2:	9f 90       	pop	r9
    14f4:	8f 90       	pop	r8
    14f6:	7f 90       	pop	r7
    14f8:	6f 90       	pop	r6
    14fa:	5f 90       	pop	r5
    14fc:	4f 90       	pop	r4
    14fe:	08 95       	ret

00001500 <_ZN10helicopter7drivers12SerialDriverD1Ev>:
				{

				}
						
				virtual ~SerialDriver()
				{
    1500:	22 e1       	ldi	r18, 0x12	; 18
    1502:	32 e0       	ldi	r19, 0x02	; 2
    1504:	fc 01       	movw	r30, r24
    1506:	31 83       	std	Z+1, r19	; 0x01
    1508:	20 83       	st	Z, r18
    150a:	08 95       	ret

0000150c <_ZN10helicopter7drivers12SerialDriver8transmitEf>:
		sei();
	}
}

int SerialDriver::transmit(float valueToSend)
{
    150c:	bf 92       	push	r11
    150e:	cf 92       	push	r12
    1510:	df 92       	push	r13
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	ec 01       	movw	r28, r24
    1520:	05 2f       	mov	r16, r21
    1522:	16 2f       	mov	r17, r22
    1524:	b7 2e       	mov	r11, r23
	
	//Memcpy the float into an array of bytes because the compiler doesn't like
	//bit shifting floats. 
	memcpy(bytes, (void*) &valueToSend, 4);
	
	status1 = transmit(bytes[0]);
    1526:	e8 81       	ld	r30, Y
    1528:	f9 81       	ldd	r31, Y+1	; 0x01
    152a:	06 80       	ldd	r0, Z+6	; 0x06
    152c:	f7 81       	ldd	r31, Z+7	; 0x07
    152e:	e0 2d       	mov	r30, r0
    1530:	64 2f       	mov	r22, r20
    1532:	19 95       	eicall
    1534:	7c 01       	movw	r14, r24
	status2 = transmit(bytes[1]);
    1536:	e8 81       	ld	r30, Y
    1538:	f9 81       	ldd	r31, Y+1	; 0x01
    153a:	06 80       	ldd	r0, Z+6	; 0x06
    153c:	f7 81       	ldd	r31, Z+7	; 0x07
    153e:	e0 2d       	mov	r30, r0
    1540:	60 2f       	mov	r22, r16
    1542:	ce 01       	movw	r24, r28
    1544:	19 95       	eicall
    1546:	6c 01       	movw	r12, r24
	status3 = transmit(bytes[2]);
    1548:	e8 81       	ld	r30, Y
    154a:	f9 81       	ldd	r31, Y+1	; 0x01
    154c:	06 80       	ldd	r0, Z+6	; 0x06
    154e:	f7 81       	ldd	r31, Z+7	; 0x07
    1550:	e0 2d       	mov	r30, r0
    1552:	61 2f       	mov	r22, r17
    1554:	ce 01       	movw	r24, r28
    1556:	19 95       	eicall
    1558:	8c 01       	movw	r16, r24
	status4 = transmit(bytes[3]);
    155a:	e8 81       	ld	r30, Y
    155c:	f9 81       	ldd	r31, Y+1	; 0x01
    155e:	06 80       	ldd	r0, Z+6	; 0x06
    1560:	f7 81       	ldd	r31, Z+7	; 0x07
    1562:	e0 2d       	mov	r30, r0
    1564:	6b 2d       	mov	r22, r11
    1566:	ce 01       	movw	r24, r28
    1568:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    156a:	96 01       	movw	r18, r12
    156c:	2e 29       	or	r18, r14
    156e:	3f 29       	or	r19, r15
    1570:	20 2b       	or	r18, r16
    1572:	31 2b       	or	r19, r17
    1574:	28 2b       	or	r18, r24
    1576:	39 2b       	or	r19, r25
}
    1578:	82 2f       	mov	r24, r18
    157a:	93 2f       	mov	r25, r19
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	df 90       	pop	r13
    158a:	cf 90       	pop	r12
    158c:	bf 90       	pop	r11
    158e:	08 95       	ret

00001590 <_ZN10helicopter7drivers12SerialDriver8transmitEi>:

int SerialDriver::transmit(int valueToSend)
{
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	ec 01       	movw	r28, r24
    159c:	f6 2e       	mov	r15, r22
    159e:	67 2f       	mov	r22, r23
	int status1 = 0;
	int status2 = 0;
	
	status1 = transmit((byte)((valueToSend >> 8) & 0xFF));
    15a0:	e8 81       	ld	r30, Y
    15a2:	f9 81       	ldd	r31, Y+1	; 0x01
    15a4:	06 80       	ldd	r0, Z+6	; 0x06
    15a6:	f7 81       	ldd	r31, Z+7	; 0x07
    15a8:	e0 2d       	mov	r30, r0
    15aa:	19 95       	eicall
    15ac:	8c 01       	movw	r16, r24
	status2 = transmit((byte)valueToSend);	
    15ae:	e8 81       	ld	r30, Y
    15b0:	f9 81       	ldd	r31, Y+1	; 0x01
    15b2:	06 80       	ldd	r0, Z+6	; 0x06
    15b4:	f7 81       	ldd	r31, Z+7	; 0x07
    15b6:	e0 2d       	mov	r30, r0
    15b8:	6f 2d       	mov	r22, r15
    15ba:	ce 01       	movw	r24, r28
    15bc:	19 95       	eicall
	
	return status1 | status2;
    15be:	9c 01       	movw	r18, r24
    15c0:	20 2b       	or	r18, r16
    15c2:	31 2b       	or	r19, r17
}
    15c4:	82 2f       	mov	r24, r18
    15c6:	93 2f       	mov	r25, r19
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	08 95       	ret

000015d4 <_ZN10helicopter7drivers12SerialDriver8transmitEm>:

int SerialDriver::transmit(unsigned long valueToSend)
{
    15d4:	8f 92       	push	r8
    15d6:	9f 92       	push	r9
    15d8:	af 92       	push	r10
    15da:	bf 92       	push	r11
    15dc:	cf 92       	push	r12
    15de:	df 92       	push	r13
    15e0:	ef 92       	push	r14
    15e2:	ff 92       	push	r15
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	ec 01       	movw	r28, r24
    15ee:	4a 01       	movw	r8, r20
    15f0:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    15f2:	e8 81       	ld	r30, Y
    15f4:	f9 81       	ldd	r31, Y+1	; 0x01
    15f6:	67 2f       	mov	r22, r23
    15f8:	77 27       	eor	r23, r23
    15fa:	88 27       	eor	r24, r24
    15fc:	99 27       	eor	r25, r25
    15fe:	06 80       	ldd	r0, Z+6	; 0x06
    1600:	f7 81       	ldd	r31, Z+7	; 0x07
    1602:	e0 2d       	mov	r30, r0
    1604:	ce 01       	movw	r24, r28
    1606:	19 95       	eicall
    1608:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    160a:	e8 81       	ld	r30, Y
    160c:	f9 81       	ldd	r31, Y+1	; 0x01
    160e:	b5 01       	movw	r22, r10
    1610:	88 27       	eor	r24, r24
    1612:	99 27       	eor	r25, r25
    1614:	06 80       	ldd	r0, Z+6	; 0x06
    1616:	f7 81       	ldd	r31, Z+7	; 0x07
    1618:	e0 2d       	mov	r30, r0
    161a:	ce 01       	movw	r24, r28
    161c:	19 95       	eicall
    161e:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1620:	e8 81       	ld	r30, Y
    1622:	f9 81       	ldd	r31, Y+1	; 0x01
    1624:	99 27       	eor	r25, r25
    1626:	8b 2d       	mov	r24, r11
    1628:	7a 2d       	mov	r23, r10
    162a:	69 2d       	mov	r22, r9
    162c:	06 80       	ldd	r0, Z+6	; 0x06
    162e:	f7 81       	ldd	r31, Z+7	; 0x07
    1630:	e0 2d       	mov	r30, r0
    1632:	ce 01       	movw	r24, r28
    1634:	19 95       	eicall
    1636:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    1638:	e8 81       	ld	r30, Y
    163a:	f9 81       	ldd	r31, Y+1	; 0x01
    163c:	06 80       	ldd	r0, Z+6	; 0x06
    163e:	f7 81       	ldd	r31, Z+7	; 0x07
    1640:	e0 2d       	mov	r30, r0
    1642:	68 2d       	mov	r22, r8
    1644:	ce 01       	movw	r24, r28
    1646:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    1648:	ec 28       	or	r14, r12
    164a:	fd 28       	or	r15, r13
    164c:	0e 29       	or	r16, r14
    164e:	1f 29       	or	r17, r15
    1650:	08 2b       	or	r16, r24
    1652:	19 2b       	or	r17, r25
}
    1654:	80 2f       	mov	r24, r16
    1656:	91 2f       	mov	r25, r17
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	1f 91       	pop	r17
    165e:	0f 91       	pop	r16
    1660:	ff 90       	pop	r15
    1662:	ef 90       	pop	r14
    1664:	df 90       	pop	r13
    1666:	cf 90       	pop	r12
    1668:	bf 90       	pop	r11
    166a:	af 90       	pop	r10
    166c:	9f 90       	pop	r9
    166e:	8f 90       	pop	r8
    1670:	08 95       	ret

00001672 <_ZN10helicopter7drivers12SerialDriver8transmitEl>:

int SerialDriver::transmit(long valueToSend)
{
    1672:	8f 92       	push	r8
    1674:	9f 92       	push	r9
    1676:	af 92       	push	r10
    1678:	bf 92       	push	r11
    167a:	cf 92       	push	r12
    167c:	df 92       	push	r13
    167e:	ef 92       	push	r14
    1680:	ff 92       	push	r15
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	ec 01       	movw	r28, r24
    168c:	4a 01       	movw	r8, r20
    168e:	5b 01       	movw	r10, r22
	int status2 = 0;
	int status3 = 0;
	int status4 = 0;
	

	status1 = transmit((byte)((valueToSend >> 24) & 0xFF));
    1690:	e8 81       	ld	r30, Y
    1692:	f9 81       	ldd	r31, Y+1	; 0x01
    1694:	67 2f       	mov	r22, r23
    1696:	77 27       	eor	r23, r23
    1698:	88 27       	eor	r24, r24
    169a:	99 27       	eor	r25, r25
    169c:	06 80       	ldd	r0, Z+6	; 0x06
    169e:	f7 81       	ldd	r31, Z+7	; 0x07
    16a0:	e0 2d       	mov	r30, r0
    16a2:	ce 01       	movw	r24, r28
    16a4:	19 95       	eicall
    16a6:	7c 01       	movw	r14, r24
	status2 = transmit((byte)((valueToSend >> 16) & 0xFF));
    16a8:	e8 81       	ld	r30, Y
    16aa:	f9 81       	ldd	r31, Y+1	; 0x01
    16ac:	b5 01       	movw	r22, r10
    16ae:	99 27       	eor	r25, r25
    16b0:	77 fd       	sbrc	r23, 7
    16b2:	90 95       	com	r25
    16b4:	89 2f       	mov	r24, r25
    16b6:	06 80       	ldd	r0, Z+6	; 0x06
    16b8:	f7 81       	ldd	r31, Z+7	; 0x07
    16ba:	e0 2d       	mov	r30, r0
    16bc:	ce 01       	movw	r24, r28
    16be:	19 95       	eicall
    16c0:	6c 01       	movw	r12, r24
	status3 = transmit((byte)((valueToSend >> 8) & 0xFF));
    16c2:	e8 81       	ld	r30, Y
    16c4:	f9 81       	ldd	r31, Y+1	; 0x01
    16c6:	99 27       	eor	r25, r25
    16c8:	b7 fc       	sbrc	r11, 7
    16ca:	9a 95       	dec	r25
    16cc:	8b 2d       	mov	r24, r11
    16ce:	7a 2d       	mov	r23, r10
    16d0:	69 2d       	mov	r22, r9
    16d2:	06 80       	ldd	r0, Z+6	; 0x06
    16d4:	f7 81       	ldd	r31, Z+7	; 0x07
    16d6:	e0 2d       	mov	r30, r0
    16d8:	ce 01       	movw	r24, r28
    16da:	19 95       	eicall
    16dc:	8c 01       	movw	r16, r24
	status4 = transmit((byte)(valueToSend & 0xFF));
    16de:	e8 81       	ld	r30, Y
    16e0:	f9 81       	ldd	r31, Y+1	; 0x01
    16e2:	06 80       	ldd	r0, Z+6	; 0x06
    16e4:	f7 81       	ldd	r31, Z+7	; 0x07
    16e6:	e0 2d       	mov	r30, r0
    16e8:	68 2d       	mov	r22, r8
    16ea:	ce 01       	movw	r24, r28
    16ec:	19 95       	eicall
	
	return status1 | status2 | status3 | status4;
    16ee:	ec 28       	or	r14, r12
    16f0:	fd 28       	or	r15, r13
    16f2:	0e 29       	or	r16, r14
    16f4:	1f 29       	or	r17, r15
    16f6:	08 2b       	or	r16, r24
    16f8:	19 2b       	or	r17, r25
}
    16fa:	80 2f       	mov	r24, r16
    16fc:	91 2f       	mov	r25, r17
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	ff 90       	pop	r15
    1708:	ef 90       	pop	r14
    170a:	df 90       	pop	r13
    170c:	cf 90       	pop	r12
    170e:	bf 90       	pop	r11
    1710:	af 90       	pop	r10
    1712:	9f 90       	pop	r9
    1714:	8f 90       	pop	r8
    1716:	08 95       	ret

00001718 <_ZN10helicopter7drivers12SerialDriver8transmitEx>:

int SerialDriver::transmit(int64_t valueToSend)
{
    1718:	3f 92       	push	r3
    171a:	4f 92       	push	r4
    171c:	5f 92       	push	r5
    171e:	6f 92       	push	r6
    1720:	7f 92       	push	r7
    1722:	8f 92       	push	r8
    1724:	9f 92       	push	r9
    1726:	af 92       	push	r10
    1728:	bf 92       	push	r11
    172a:	cf 92       	push	r12
    172c:	df 92       	push	r13
    172e:	ef 92       	push	r14
    1730:	ff 92       	push	r15
    1732:	0f 93       	push	r16
    1734:	1f 93       	push	r17
    1736:	cf 93       	push	r28
    1738:	df 93       	push	r29
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
    173e:	28 97       	sbiw	r28, 0x08	; 8
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	cd bf       	out	0x3d, r28	; 61
    174a:	98 87       	std	Y+8, r25	; 0x08
    174c:	8f 83       	std	Y+7, r24	; 0x07
    174e:	70 2e       	mov	r7, r16
    1750:	32 2e       	mov	r3, r18
    1752:	43 2e       	mov	r4, r19
    1754:	54 2e       	mov	r5, r20
    1756:	65 2e       	mov	r6, r21
    1758:	e6 2e       	mov	r14, r22
    175a:	f7 2e       	mov	r15, r23
	int status5 = 0;
	int status6 = 0;
	int status7 = 0;
	int status8 = 0;	

	status1 = transmit((byte)((valueToSend >> 56) & 0xFF));
    175c:	dc 01       	movw	r26, r24
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	11 97       	sbiw	r26, 0x01	; 1
    1764:	20 2f       	mov	r18, r16
    1766:	31 2f       	mov	r19, r17
    1768:	43 2d       	mov	r20, r3
    176a:	54 2d       	mov	r21, r4
    176c:	65 2d       	mov	r22, r5
    176e:	76 2d       	mov	r23, r6
    1770:	8e 2d       	mov	r24, r14
    1772:	9f 2d       	mov	r25, r15
    1774:	08 e3       	ldi	r16, 0x38	; 56
    1776:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    177a:	06 80       	ldd	r0, Z+6	; 0x06
    177c:	f7 81       	ldd	r31, Z+7	; 0x07
    177e:	e0 2d       	mov	r30, r0
    1780:	62 2f       	mov	r22, r18
    1782:	cd 01       	movw	r24, r26
    1784:	19 95       	eicall
    1786:	5c 01       	movw	r10, r24
	status2 = transmit((byte)((valueToSend >> 48) & 0xFF));
    1788:	af 81       	ldd	r26, Y+7	; 0x07
    178a:	b8 85       	ldd	r27, Y+8	; 0x08
    178c:	ed 91       	ld	r30, X+
    178e:	fc 91       	ld	r31, X
    1790:	11 97       	sbiw	r26, 0x01	; 1
    1792:	27 2d       	mov	r18, r7
    1794:	31 2f       	mov	r19, r17
    1796:	43 2d       	mov	r20, r3
    1798:	54 2d       	mov	r21, r4
    179a:	65 2d       	mov	r22, r5
    179c:	76 2d       	mov	r23, r6
    179e:	8e 2d       	mov	r24, r14
    17a0:	9f 2d       	mov	r25, r15
    17a2:	00 e3       	ldi	r16, 0x30	; 48
    17a4:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    17a8:	06 80       	ldd	r0, Z+6	; 0x06
    17aa:	f7 81       	ldd	r31, Z+7	; 0x07
    17ac:	e0 2d       	mov	r30, r0
    17ae:	62 2f       	mov	r22, r18
    17b0:	cd 01       	movw	r24, r26
    17b2:	19 95       	eicall
    17b4:	4c 01       	movw	r8, r24
	status3 = transmit((byte)((valueToSend >> 40) & 0xFF));
    17b6:	af 81       	ldd	r26, Y+7	; 0x07
    17b8:	b8 85       	ldd	r27, Y+8	; 0x08
    17ba:	ed 91       	ld	r30, X+
    17bc:	fc 91       	ld	r31, X
    17be:	11 97       	sbiw	r26, 0x01	; 1
    17c0:	27 2d       	mov	r18, r7
    17c2:	31 2f       	mov	r19, r17
    17c4:	43 2d       	mov	r20, r3
    17c6:	54 2d       	mov	r21, r4
    17c8:	65 2d       	mov	r22, r5
    17ca:	76 2d       	mov	r23, r6
    17cc:	8e 2d       	mov	r24, r14
    17ce:	9f 2d       	mov	r25, r15
    17d0:	08 e2       	ldi	r16, 0x28	; 40
    17d2:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    17d6:	06 80       	ldd	r0, Z+6	; 0x06
    17d8:	f7 81       	ldd	r31, Z+7	; 0x07
    17da:	e0 2d       	mov	r30, r0
    17dc:	62 2f       	mov	r22, r18
    17de:	cd 01       	movw	r24, r26
    17e0:	19 95       	eicall
    17e2:	9a 83       	std	Y+2, r25	; 0x02
    17e4:	89 83       	std	Y+1, r24	; 0x01
	status4 = transmit((byte)((valueToSend >> 32) & 0xFF));
    17e6:	af 81       	ldd	r26, Y+7	; 0x07
    17e8:	b8 85       	ldd	r27, Y+8	; 0x08
    17ea:	ed 91       	ld	r30, X+
    17ec:	fc 91       	ld	r31, X
    17ee:	11 97       	sbiw	r26, 0x01	; 1
    17f0:	27 2d       	mov	r18, r7
    17f2:	31 2f       	mov	r19, r17
    17f4:	43 2d       	mov	r20, r3
    17f6:	54 2d       	mov	r21, r4
    17f8:	65 2d       	mov	r22, r5
    17fa:	76 2d       	mov	r23, r6
    17fc:	8e 2d       	mov	r24, r14
    17fe:	9f 2d       	mov	r25, r15
    1800:	00 e2       	ldi	r16, 0x20	; 32
    1802:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    1806:	06 80       	ldd	r0, Z+6	; 0x06
    1808:	f7 81       	ldd	r31, Z+7	; 0x07
    180a:	e0 2d       	mov	r30, r0
    180c:	62 2f       	mov	r22, r18
    180e:	cd 01       	movw	r24, r26
    1810:	19 95       	eicall
    1812:	9c 83       	std	Y+4, r25	; 0x04
    1814:	8b 83       	std	Y+3, r24	; 0x03
	status5 = transmit((byte)((valueToSend >> 24) & 0xFF));
    1816:	af 81       	ldd	r26, Y+7	; 0x07
    1818:	b8 85       	ldd	r27, Y+8	; 0x08
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	11 97       	sbiw	r26, 0x01	; 1
    1820:	27 2d       	mov	r18, r7
    1822:	31 2f       	mov	r19, r17
    1824:	43 2d       	mov	r20, r3
    1826:	54 2d       	mov	r21, r4
    1828:	65 2d       	mov	r22, r5
    182a:	76 2d       	mov	r23, r6
    182c:	8e 2d       	mov	r24, r14
    182e:	9f 2d       	mov	r25, r15
    1830:	08 e1       	ldi	r16, 0x18	; 24
    1832:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    1836:	06 80       	ldd	r0, Z+6	; 0x06
    1838:	f7 81       	ldd	r31, Z+7	; 0x07
    183a:	e0 2d       	mov	r30, r0
    183c:	62 2f       	mov	r22, r18
    183e:	cd 01       	movw	r24, r26
    1840:	19 95       	eicall
    1842:	9e 83       	std	Y+6, r25	; 0x06
    1844:	8d 83       	std	Y+5, r24	; 0x05
	status6 = transmit((byte)((valueToSend >> 16) & 0xFF));
    1846:	af 81       	ldd	r26, Y+7	; 0x07
    1848:	b8 85       	ldd	r27, Y+8	; 0x08
    184a:	ed 91       	ld	r30, X+
    184c:	fc 91       	ld	r31, X
    184e:	11 97       	sbiw	r26, 0x01	; 1
    1850:	27 2d       	mov	r18, r7
    1852:	31 2f       	mov	r19, r17
    1854:	43 2d       	mov	r20, r3
    1856:	54 2d       	mov	r21, r4
    1858:	65 2d       	mov	r22, r5
    185a:	76 2d       	mov	r23, r6
    185c:	8e 2d       	mov	r24, r14
    185e:	9f 2d       	mov	r25, r15
    1860:	00 e1       	ldi	r16, 0x10	; 16
    1862:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    1866:	06 80       	ldd	r0, Z+6	; 0x06
    1868:	f7 81       	ldd	r31, Z+7	; 0x07
    186a:	e0 2d       	mov	r30, r0
    186c:	62 2f       	mov	r22, r18
    186e:	cd 01       	movw	r24, r26
    1870:	19 95       	eicall
    1872:	6c 01       	movw	r12, r24
	status7 = transmit((byte)((valueToSend >> 8) & 0xFF));
    1874:	af 81       	ldd	r26, Y+7	; 0x07
    1876:	b8 85       	ldd	r27, Y+8	; 0x08
    1878:	ed 91       	ld	r30, X+
    187a:	fc 91       	ld	r31, X
    187c:	11 97       	sbiw	r26, 0x01	; 1
    187e:	27 2d       	mov	r18, r7
    1880:	31 2f       	mov	r19, r17
    1882:	43 2d       	mov	r20, r3
    1884:	54 2d       	mov	r21, r4
    1886:	65 2d       	mov	r22, r5
    1888:	76 2d       	mov	r23, r6
    188a:	8e 2d       	mov	r24, r14
    188c:	9f 2d       	mov	r25, r15
    188e:	08 e0       	ldi	r16, 0x08	; 8
    1890:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    1894:	06 80       	ldd	r0, Z+6	; 0x06
    1896:	f7 81       	ldd	r31, Z+7	; 0x07
    1898:	e0 2d       	mov	r30, r0
    189a:	62 2f       	mov	r22, r18
    189c:	cd 01       	movw	r24, r26
    189e:	19 95       	eicall
    18a0:	7c 01       	movw	r14, r24
	status8 = transmit((byte)(valueToSend & 0xFF));
    18a2:	af 81       	ldd	r26, Y+7	; 0x07
    18a4:	b8 85       	ldd	r27, Y+8	; 0x08
    18a6:	ed 91       	ld	r30, X+
    18a8:	fc 91       	ld	r31, X
    18aa:	11 97       	sbiw	r26, 0x01	; 1
    18ac:	06 80       	ldd	r0, Z+6	; 0x06
    18ae:	f7 81       	ldd	r31, Z+7	; 0x07
    18b0:	e0 2d       	mov	r30, r0
    18b2:	67 2d       	mov	r22, r7
    18b4:	cd 01       	movw	r24, r26
    18b6:	19 95       	eicall
	
	return status1 | status2 | status3 | status4 | status5 | status6 | status7 | status8;
    18b8:	a8 28       	or	r10, r8
    18ba:	b9 28       	or	r11, r9
    18bc:	e9 81       	ldd	r30, Y+1	; 0x01
    18be:	fa 81       	ldd	r31, Y+2	; 0x02
    18c0:	ae 2a       	or	r10, r30
    18c2:	bf 2a       	or	r11, r31
    18c4:	2b 81       	ldd	r18, Y+3	; 0x03
    18c6:	3c 81       	ldd	r19, Y+4	; 0x04
    18c8:	a2 2a       	or	r10, r18
    18ca:	b3 2a       	or	r11, r19
    18cc:	ad 81       	ldd	r26, Y+5	; 0x05
    18ce:	be 81       	ldd	r27, Y+6	; 0x06
    18d0:	aa 2a       	or	r10, r26
    18d2:	bb 2a       	or	r11, r27
    18d4:	ca 28       	or	r12, r10
    18d6:	db 28       	or	r13, r11
    18d8:	ec 28       	or	r14, r12
    18da:	fd 28       	or	r15, r13
    18dc:	e8 2a       	or	r14, r24
    18de:	f9 2a       	or	r15, r25
}
    18e0:	8e 2d       	mov	r24, r14
    18e2:	9f 2d       	mov	r25, r15
    18e4:	28 96       	adiw	r28, 0x08	; 8
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	de bf       	out	0x3e, r29	; 62
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	cd bf       	out	0x3d, r28	; 61
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	ff 90       	pop	r15
    18fa:	ef 90       	pop	r14
    18fc:	df 90       	pop	r13
    18fe:	cf 90       	pop	r12
    1900:	bf 90       	pop	r11
    1902:	af 90       	pop	r10
    1904:	9f 90       	pop	r9
    1906:	8f 90       	pop	r8
    1908:	7f 90       	pop	r7
    190a:	6f 90       	pop	r6
    190c:	5f 90       	pop	r5
    190e:	4f 90       	pop	r4
    1910:	3f 90       	pop	r3
    1912:	08 95       	ret

00001914 <_ZN10helicopter7drivers12SerialDriver7receiveERh>:

	return status;
}

int SerialDriver::receive(byte &receivedByte)
{
    1914:	ef 92       	push	r14
    1916:	ff 92       	push	r15
    1918:	0f 93       	push	r16
    191a:	1f 93       	push	r17
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	ec 01       	movw	r28, r24
    1922:	7b 01       	movw	r14, r22
	int status = 0;
	
	if (asyncReceiveTransmitData)
    1924:	88 85       	ldd	r24, Y+8	; 0x08
    1926:	88 23       	and	r24, r24
    1928:	49 f0       	breq	.+18     	; 0x193c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x28>
	{
		bool status = receiveBuffer.dequeue(receivedByte);
    192a:	88 e9       	ldi	r24, 0x98	; 152
    192c:	93 e0       	ldi	r25, 0x03	; 3
    192e:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <_ZN10helicopter6buffer14CircularBuffer7dequeueERh>
		
		if (!status)
    1932:	81 11       	cpse	r24, r1
    1934:	3a c0       	rjmp	.+116    	; 0x19aa <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x96>
		{
			return -1;
    1936:	2f ef       	ldi	r18, 0xFF	; 255
    1938:	3f ef       	ldi	r19, 0xFF	; 255
    193a:	3f c0       	rjmp	.+126    	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		}
		
		return 0;
	}
	
	if (uartPort == Zero)
    193c:	8e 81       	ldd	r24, Y+6	; 0x06
    193e:	88 23       	and	r24, r24
    1940:	51 f0       	breq	.+20     	; 0x1956 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x42>
    1942:	17 c0       	rjmp	.+46     	; 0x1972 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x5e>
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
		{
			if (timer != NULL && timer->hasTimedout())
    1944:	89 85       	ldd	r24, Y+9	; 0x09
    1946:	9a 85       	ldd	r25, Y+10	; 0x0a
    1948:	00 97       	sbiw	r24, 0x00	; 0
    194a:	39 f0       	breq	.+14     	; 0x195a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x46>
    194c:	0e 94 e3 69 	call	0xd3c6	; 0xd3c6 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1950:	88 23       	and	r24, r24
    1952:	19 f0       	breq	.+6      	; 0x195a <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x46>
    1954:	2d c0       	rjmp	.+90     	; 0x19b0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x9c>
		
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR0A & (1<<RXC0)))
    1956:	00 ec       	ldi	r16, 0xC0	; 192
    1958:	10 e0       	ldi	r17, 0x00	; 0
    195a:	f8 01       	movw	r30, r16
    195c:	80 81       	ld	r24, Z
    195e:	88 23       	and	r24, r24
    1960:	8c f7       	brge	.-30     	; 0x1944 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x30>
    1962:	2e c0       	rjmp	.+92     	; 0x19c0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xac>
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
			{
				status = -2;
    1964:	2e ef       	ldi	r18, 0xFE	; 254
    1966:	3f ef       	ldi	r19, 0xFF	; 255

			//// Stop interrupts
			//cli();
		
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR0;
    1968:	80 91 c6 00 	lds	r24, 0x00C6
    196c:	f7 01       	movw	r30, r14
    196e:	80 83       	st	Z, r24
    1970:	24 c0       	rjmp	.+72     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
			
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;			
		}
	} else if (uartPort == One)
    1972:	81 30       	cpi	r24, 0x01	; 1
    1974:	61 f0       	breq	.+24     	; 0x198e <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7a>
	return status;
}

int SerialDriver::receive(byte &receivedByte)
{
	int status = 0;
    1976:	20 e0       	ldi	r18, 0x00	; 0
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	1f c0       	rjmp	.+62     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
		{
			if (timer != NULL && timer->hasTimedout())
    197c:	89 85       	ldd	r24, Y+9	; 0x09
    197e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1980:	00 97       	sbiw	r24, 0x00	; 0
    1982:	39 f0       	breq	.+14     	; 0x1992 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
    1984:	0e 94 e3 69 	call	0xd3c6	; 0xd3c6 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1988:	88 23       	and	r24, r24
    198a:	19 f0       	breq	.+6      	; 0x1992 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x7e>
    198c:	14 c0       	rjmp	.+40     	; 0x19b6 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa2>
			
		/* 
		* Wait for data on the receive buffer. This is done by
		* checking the Receiver Complete register (RXC)
		*/
		while ( !(UCSR1A & (1<<RXC1)))
    198e:	08 ec       	ldi	r16, 0xC8	; 200
    1990:	10 e0       	ldi	r17, 0x00	; 0
    1992:	f8 01       	movw	r30, r16
    1994:	80 81       	ld	r24, Z
    1996:	88 23       	and	r24, r24
    1998:	8c f7       	brge	.-30     	; 0x197c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x68>
    199a:	19 c0       	rjmp	.+50     	; 0x19ce <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xba>
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
			{
				status = -2;
    199c:	2e ef       	ldi	r18, 0xFE	; 254
    199e:	3f ef       	ldi	r19, 0xFF	; 255
			//// Stop interrupts
			//cli();
						
				
			/* Read the data from the serial port buffer, even if the buffer was overrun */
			receivedByte = UDR1;
    19a0:	80 91 ce 00 	lds	r24, 0x00CE
    19a4:	f7 01       	movw	r30, r14
    19a6:	80 83       	st	Z, r24
    19a8:	08 c0       	rjmp	.+16     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		if (!status)
		{
			return -1;
		}
		
		return 0;
    19aa:	20 e0       	ldi	r18, 0x00	; 0
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	05 c0       	rjmp	.+10     	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		*/
		while ( !(UCSR0A & (1<<RXC0)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    19b0:	2f ef       	ldi	r18, 0xFF	; 255
    19b2:	3f ef       	ldi	r19, 0xFF	; 255
    19b4:	02 c0       	rjmp	.+4      	; 0x19ba <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xa6>
		*/
		while ( !(UCSR1A & (1<<RXC1)))
		{
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    19b6:	2f ef       	ldi	r18, 0xFF	; 255
    19b8:	3f ef       	ldi	r19, 0xFF	; 255
    19ba:	82 2f       	mov	r24, r18
    19bc:	93 2f       	mov	r25, r19
    19be:	0e c0       	rjmp	.+28     	; 0x19dc <_ZN10helicopter7drivers12SerialDriver7receiveERh+0xc8>
			* Determine if there has been:
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/
			if ((UCSR0A & ((1 << DOR0) | (1<<FE0) | (1<<UPE0))) != 0)
    19c0:	80 91 c0 00 	lds	r24, 0x00C0
    19c4:	8c 71       	andi	r24, 0x1C	; 28
    19c6:	71 f6       	brne	.-100    	; 0x1964 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x50>
    19c8:	20 e0       	ldi	r18, 0x00	; 0
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	cd cf       	rjmp	.-102    	; 0x1968 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x54>
			* a Data Overrun (Data Overrun Register (DOR))
			* a parity error (USART parity error (UPE))
			* a Frame error (Frame Error (FE))
			*/

			if ((UCSR1A & ((1 << DOR1) | (1<<FE1) | (1<<UPE1))) != 0)
    19ce:	80 91 c8 00 	lds	r24, 0x00C8
    19d2:	8c 71       	andi	r24, 0x1C	; 28
    19d4:	19 f7       	brne	.-58     	; 0x199c <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x88>
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0
    19da:	e2 cf       	rjmp	.-60     	; 0x19a0 <_ZN10helicopter7drivers12SerialDriver7receiveERh+0x8c>
			//SREG = SREG_tmp;			
		}
	}

	return status;
}
    19dc:	df 91       	pop	r29
    19de:	cf 91       	pop	r28
    19e0:	1f 91       	pop	r17
    19e2:	0f 91       	pop	r16
    19e4:	ff 90       	pop	r15
    19e6:	ef 90       	pop	r14
    19e8:	08 95       	ret

000019ea <_ZN10helicopter7drivers12SerialDriver8transmitEh>:
	
	return status;
}

int SerialDriver::transmit(byte valueToSend)
{
    19ea:	ff 92       	push	r15
    19ec:	0f 93       	push	r16
    19ee:	1f 93       	push	r17
    19f0:	cf 93       	push	r28
    19f2:	df 93       	push	r29
    19f4:	ec 01       	movw	r28, r24
    19f6:	f6 2e       	mov	r15, r22
	
	if (asyncReceiveTransmitData)
    19f8:	88 85       	ldd	r24, Y+8	; 0x08
    19fa:	88 23       	and	r24, r24
    19fc:	39 f0       	breq	.+14     	; 0x1a0c <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x22>
	{
		bool status = transmitBuffer.enqueue(valueToSend);
    19fe:	8e e8       	ldi	r24, 0x8E	; 142
    1a00:	93 e0       	ldi	r25, 0x03	; 3
    1a02:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <_ZN10helicopter6buffer14CircularBuffer7enqueueEh>

		if (!status)
    1a06:	81 11       	cpse	r24, r1
    1a08:	2d c0       	rjmp	.+90     	; 0x1a64 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x7a>
    1a0a:	29 c0       	rjmp	.+82     	; 0x1a5e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x74>
		
	
	int status = 0;

	
	if (uartPort == Zero)
    1a0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0e:	88 23       	and	r24, r24
    1a10:	51 f0       	breq	.+20     	; 0x1a26 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x3c>
    1a12:	10 c0       	rjmp	.+32     	; 0x1a34 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x4a>

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    1a14:	89 85       	ldd	r24, Y+9	; 0x09
    1a16:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a18:	00 97       	sbiw	r24, 0x00	; 0
    1a1a:	39 f0       	breq	.+14     	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x40>
    1a1c:	0e 94 e3 69 	call	0xd3c6	; 0xd3c6 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1a20:	88 23       	and	r24, r24
    1a22:	19 f0       	breq	.+6      	; 0x1a2a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x40>
    1a24:	22 c0       	rjmp	.+68     	; 0x1a6a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x80>
	
	if (uartPort == Zero)
	{

		/* Wait for empty transmit buffer */
		while ( !( UCSR0A & (1<<UDRE0)) )
    1a26:	00 ec       	ldi	r16, 0xC0	; 192
    1a28:	10 e0       	ldi	r17, 0x00	; 0
    1a2a:	f8 01       	movw	r30, r16
    1a2c:	80 81       	ld	r24, Z
    1a2e:	85 ff       	sbrs	r24, 5
    1a30:	f1 cf       	rjmp	.-30     	; 0x1a14 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x2a>
    1a32:	23 c0       	rjmp	.+70     	; 0x1a7a <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x90>
			
			//// Restore interrupt status and register flags
			//SREG = SREG_tmp;
		}

	}else if (uartPort == One)
    1a34:	81 30       	cpi	r24, 0x01	; 1
    1a36:	61 f0       	breq	.+24     	; 0x1a50 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x66>
		return 0;
	}
	
		
	
	int status = 0;
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	1b c0       	rjmp	.+54     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
    1a3e:	89 85       	ldd	r24, Y+9	; 0x09
    1a40:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	39 f0       	breq	.+14     	; 0x1a54 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
    1a46:	0e 94 e3 69 	call	0xd3c6	; 0xd3c6 <_ZN10helicopter4util5Timer11hasTimedoutEv>
    1a4a:	88 23       	and	r24, r24
    1a4c:	19 f0       	breq	.+6      	; 0x1a54 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x6a>
    1a4e:	10 c0       	rjmp	.+32     	; 0x1a70 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x86>
		}

	}else if (uartPort == One)
	{
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) )
    1a50:	08 ec       	ldi	r16, 0xC8	; 200
    1a52:	10 e0       	ldi	r17, 0x00	; 0
    1a54:	f8 01       	movw	r30, r16
    1a56:	80 81       	ld	r24, Z
    1a58:	85 ff       	sbrs	r24, 5
    1a5a:	f1 cf       	rjmp	.-30     	; 0x1a3e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x54>
    1a5c:	13 c0       	rjmp	.+38     	; 0x1a84 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x9a>
	{
		bool status = transmitBuffer.enqueue(valueToSend);

		if (!status)
		{
			return -1;
    1a5e:	2f ef       	ldi	r18, 0xFF	; 255
    1a60:	3f ef       	ldi	r19, 0xFF	; 255
    1a62:	08 c0       	rjmp	.+16     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		{
			UCSR1B |= (1<<UDRIE1);
		}
		*/
		
		return 0;
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	05 c0       	rjmp	.+10     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		while ( !( UCSR0A & (1<<UDRE0)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1a6a:	2f ef       	ldi	r18, 0xFF	; 255
    1a6c:	3f ef       	ldi	r19, 0xFF	; 255
    1a6e:	02 c0       	rjmp	.+4      	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		while ( !( UCSR1A & (1<<UDRE1)) )
		{
			//Check for timeout
			if (timer != NULL && timer->hasTimedout())
			{
				status = -1;
    1a70:	2f ef       	ldi	r18, 0xFF	; 255
    1a72:	3f ef       	ldi	r19, 0xFF	; 255
    1a74:	82 2f       	mov	r24, r18
    1a76:	93 2f       	mov	r25, r19
    1a78:	0a c0       	rjmp	.+20     	; 0x1a8e <_ZN10helicopter7drivers12SerialDriver8transmitEh+0xa4>
//
			//// Stop interrupts
			//cli();
			
			/* Put data into buffer, sends the data */
			UDR0 = valueToSend;			
    1a7a:	f0 92 c6 00 	sts	0x00C6, r15
    1a7e:	20 e0       	ldi	r18, 0x00	; 0
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	f8 cf       	rjmp	.-16     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
//
			//// Stop interrupts
			//cli();
						
			/* Put data into buffer, sends the data */
			UDR1 = valueToSend;
    1a84:	f0 92 ce 00 	sts	0x00CE, r15
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	f3 cf       	rjmp	.-26     	; 0x1a74 <_ZN10helicopter7drivers12SerialDriver8transmitEh+0x8a>
		}		
	}
	

	return status;
}
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	1f 91       	pop	r17
    1a94:	0f 91       	pop	r16
    1a96:	ff 90       	pop	r15
    1a98:	08 95       	ret

00001a9a <_ZN10helicopter7drivers12SerialDriver4initEv>:
		timer->stopTimer();
	}
}

void SerialDriver::init()
{
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	ec 01       	movw	r28, r24
	unsigned int baudPrescaller = 0;
	
	if (useDoubleSpeedMode)
    1aa0:	8f 81       	ldd	r24, Y+7	; 0x07
    1aa2:	88 23       	and	r24, r24
    1aa4:	29 f1       	breq	.+74     	; 0x1af0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x56>
	{
		baudPrescaller = floor((((F_CPU / (baudRate * 8UL))) - 1UL));
    1aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aaa:	ac 81       	ldd	r26, Y+4	; 0x04
    1aac:	bd 81       	ldd	r27, Y+5	; 0x05
    1aae:	88 0f       	add	r24, r24
    1ab0:	99 1f       	adc	r25, r25
    1ab2:	aa 1f       	adc	r26, r26
    1ab4:	bb 1f       	adc	r27, r27
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	aa 1f       	adc	r26, r26
    1abc:	bb 1f       	adc	r27, r27
    1abe:	9c 01       	movw	r18, r24
    1ac0:	ad 01       	movw	r20, r26
    1ac2:	22 0f       	add	r18, r18
    1ac4:	33 1f       	adc	r19, r19
    1ac6:	44 1f       	adc	r20, r20
    1ac8:	55 1f       	adc	r21, r21
    1aca:	60 e0       	ldi	r22, 0x00	; 0
    1acc:	74 e2       	ldi	r23, 0x24	; 36
    1ace:	84 ef       	ldi	r24, 0xF4	; 244
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    1ad6:	ca 01       	movw	r24, r20
    1ad8:	b9 01       	movw	r22, r18
    1ada:	61 50       	subi	r22, 0x01	; 1
    1adc:	71 09       	sbc	r23, r1
    1ade:	81 09       	sbc	r24, r1
    1ae0:	91 09       	sbc	r25, r1
    1ae2:	0e 94 e8 6b 	call	0xd7d0	; 0xd7d0 <__floatunsisf>
    1ae6:	0e 94 25 6c 	call	0xd84a	; 0xd84a <floor>
    1aea:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    1aee:	28 c0       	rjmp	.+80     	; 0x1b40 <_ZN10helicopter7drivers12SerialDriver4initEv+0xa6>
	}else
	{
		//Calculation for the baud prescaller 
		baudPrescaller = floor((((F_CPU / (baudRate * 16UL))) - 1UL));
    1af0:	8a 81       	ldd	r24, Y+2	; 0x02
    1af2:	9b 81       	ldd	r25, Y+3	; 0x03
    1af4:	ac 81       	ldd	r26, Y+4	; 0x04
    1af6:	bd 81       	ldd	r27, Y+5	; 0x05
    1af8:	88 0f       	add	r24, r24
    1afa:	99 1f       	adc	r25, r25
    1afc:	aa 1f       	adc	r26, r26
    1afe:	bb 1f       	adc	r27, r27
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	aa 1f       	adc	r26, r26
    1b06:	bb 1f       	adc	r27, r27
    1b08:	9c 01       	movw	r18, r24
    1b0a:	ad 01       	movw	r20, r26
    1b0c:	22 0f       	add	r18, r18
    1b0e:	33 1f       	adc	r19, r19
    1b10:	44 1f       	adc	r20, r20
    1b12:	55 1f       	adc	r21, r21
    1b14:	22 0f       	add	r18, r18
    1b16:	33 1f       	adc	r19, r19
    1b18:	44 1f       	adc	r20, r20
    1b1a:	55 1f       	adc	r21, r21
    1b1c:	60 e0       	ldi	r22, 0x00	; 0
    1b1e:	74 e2       	ldi	r23, 0x24	; 36
    1b20:	84 ef       	ldi	r24, 0xF4	; 244
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    1b28:	ca 01       	movw	r24, r20
    1b2a:	b9 01       	movw	r22, r18
    1b2c:	61 50       	subi	r22, 0x01	; 1
    1b2e:	71 09       	sbc	r23, r1
    1b30:	81 09       	sbc	r24, r1
    1b32:	91 09       	sbc	r25, r1
    1b34:	0e 94 e8 6b 	call	0xd7d0	; 0xd7d0 <__floatunsisf>
    1b38:	0e 94 25 6c 	call	0xd84a	; 0xd84a <floor>
    1b3c:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
	}
	
	
	if (uartPort == Zero)
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
    1b42:	81 11       	cpse	r24, r1
    1b44:	20 c0       	rjmp	.+64     	; 0x1b86 <_ZN10helicopter7drivers12SerialDriver4initEv+0xec>
	{
		/* Set baud rate */
		UBRR0 = baudPrescaller;
    1b46:	70 93 c5 00 	sts	0x00C5, r23
    1b4a:	60 93 c4 00 	sts	0x00C4, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);
    1b4e:	e2 ec       	ldi	r30, 0xC2	; 194
    1b50:	f0 e0       	ldi	r31, 0x00	; 0
    1b52:	80 81       	ld	r24, Z
    1b54:	86 60       	ori	r24, 0x06	; 6
    1b56:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    1b58:	8f 81       	ldd	r24, Y+7	; 0x07
    1b5a:	88 23       	and	r24, r24
    1b5c:	31 f0       	breq	.+12     	; 0x1b6a <_ZN10helicopter7drivers12SerialDriver4initEv+0xd0>
		{
			UCSR0A |= (1<<U2X0);
    1b5e:	e0 ec       	ldi	r30, 0xC0	; 192
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	80 81       	ld	r24, Z
    1b64:	82 60       	ori	r24, 0x02	; 2
    1b66:	80 83       	st	Z, r24
    1b68:	05 c0       	rjmp	.+10     	; 0x1b74 <_ZN10helicopter7drivers12SerialDriver4initEv+0xda>
		}else
		{
			UCSR0A &= ~(1<<U2X0);
    1b6a:	e0 ec       	ldi	r30, 0xC0	; 192
    1b6c:	f0 e0       	ldi	r31, 0x00	; 0
    1b6e:	80 81       	ld	r24, Z
    1b70:	8d 7f       	andi	r24, 0xFD	; 253
    1b72:	80 83       	st	Z, r24
		}
		
		//The spec says to set this flag to 0 whenever UCSR0A is set if you are going to be using it.  
		UCSR0B &= ~(1<<UDRIE0);
    1b74:	e1 ec       	ldi	r30, 0xC1	; 193
    1b76:	f0 e0       	ldi	r31, 0x00	; 0
    1b78:	80 81       	ld	r24, Z
    1b7a:	8f 7d       	andi	r24, 0xDF	; 223
    1b7c:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR0B |= (1<<RXEN0) | (1<<TXEN0);
    1b7e:	80 81       	ld	r24, Z
    1b80:	88 61       	ori	r24, 0x18	; 24
    1b82:	80 83       	st	Z, r24
    1b84:	21 c0       	rjmp	.+66     	; 0x1bc8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	} else if (uartPort == One)
    1b86:	81 30       	cpi	r24, 0x01	; 1
    1b88:	f9 f4       	brne	.+62     	; 0x1bc8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x12e>
	{	
		
				
		/* Set baud rate */
		UBRR1 = baudPrescaller;
    1b8a:	70 93 cd 00 	sts	0x00CD, r23
    1b8e:	60 93 cc 00 	sts	0x00CC, r22
		
		/* Set frame format: asynchronous usart, no parity 1stop bit, 8 bits of data, */
		UCSR1C |= (1<<UCSZ11)|(1<<UCSZ10);
    1b92:	ea ec       	ldi	r30, 0xCA	; 202
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	80 81       	ld	r24, Z
    1b98:	86 60       	ori	r24, 0x06	; 6
    1b9a:	80 83       	st	Z, r24
		
		//If double speed mode flag was set, set the U2X0 flag to enable double speed mode.
		if (useDoubleSpeedMode)
    1b9c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b9e:	88 23       	and	r24, r24
    1ba0:	31 f0       	breq	.+12     	; 0x1bae <_ZN10helicopter7drivers12SerialDriver4initEv+0x114>
		{
			UCSR1A |= (1<<U2X1);
    1ba2:	e8 ec       	ldi	r30, 0xC8	; 200
    1ba4:	f0 e0       	ldi	r31, 0x00	; 0
    1ba6:	80 81       	ld	r24, Z
    1ba8:	82 60       	ori	r24, 0x02	; 2
    1baa:	80 83       	st	Z, r24
    1bac:	05 c0       	rjmp	.+10     	; 0x1bb8 <_ZN10helicopter7drivers12SerialDriver4initEv+0x11e>
		}else
		{
			UCSR1A &= ~(1<<U2X1);
    1bae:	e8 ec       	ldi	r30, 0xC8	; 200
    1bb0:	f0 e0       	ldi	r31, 0x00	; 0
    1bb2:	80 81       	ld	r24, Z
    1bb4:	8d 7f       	andi	r24, 0xFD	; 253
    1bb6:	80 83       	st	Z, r24
		}
		
		UCSR1B &= ~(1<<UDRIE1);
    1bb8:	e9 ec       	ldi	r30, 0xC9	; 201
    1bba:	f0 e0       	ldi	r31, 0x00	; 0
    1bbc:	80 81       	ld	r24, Z
    1bbe:	8f 7d       	andi	r24, 0xDF	; 223
    1bc0:	80 83       	st	Z, r24

		/* Enable receiver and transmitter. Receiver Enable(RXEN), Transmitter Enable (TXEN) */
		UCSR1B |= (1<<RXEN1) | (1<<TXEN1);		
    1bc2:	80 81       	ld	r24, Z
    1bc4:	88 61       	ori	r24, 0x18	; 24
    1bc6:	80 83       	st	Z, r24
	}
	
	
	if (asyncReceiveTransmitData)
    1bc8:	88 85       	ldd	r24, Y+8	; 0x08
    1bca:	88 23       	and	r24, r24
    1bcc:	91 f0       	breq	.+36     	; 0x1bf2 <_ZN10helicopter7drivers12SerialDriver4initEv+0x158>
	{
		cli();
    1bce:	f8 94       	cli
		//enable interrupts for asynchronously receiving/transmitting data. 
		if (uartPort == Zero)
    1bd0:	8e 81       	ldd	r24, Y+6	; 0x06
    1bd2:	81 11       	cpse	r24, r1
    1bd4:	06 c0       	rjmp	.+12     	; 0x1be2 <_ZN10helicopter7drivers12SerialDriver4initEv+0x148>
		{
			UCSR0B |= (1<<RXCIE0);
    1bd6:	e1 ec       	ldi	r30, 0xC1	; 193
    1bd8:	f0 e0       	ldi	r31, 0x00	; 0
    1bda:	80 81       	ld	r24, Z
    1bdc:	80 68       	ori	r24, 0x80	; 128
    1bde:	80 83       	st	Z, r24
    1be0:	07 c0       	rjmp	.+14     	; 0x1bf0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		}
		else if (uartPort == One)
    1be2:	81 30       	cpi	r24, 0x01	; 1
    1be4:	29 f4       	brne	.+10     	; 0x1bf0 <_ZN10helicopter7drivers12SerialDriver4initEv+0x156>
		{
			UCSR1B |= (1<<RXCIE1);
    1be6:	e9 ec       	ldi	r30, 0xC9	; 201
    1be8:	f0 e0       	ldi	r31, 0x00	; 0
    1bea:	80 81       	ld	r24, Z
    1bec:	80 68       	ori	r24, 0x80	; 128
    1bee:	80 83       	st	Z, r24
		}
		
		sei();
    1bf0:	78 94       	sei
	}
}
    1bf2:	df 91       	pop	r29
    1bf4:	cf 91       	pop	r28
    1bf6:	08 95       	ret

00001bf8 <_ZN10helicopter7drivers12SerialDriverD0Ev>:
    1bf8:	22 e1       	ldi	r18, 0x12	; 18
    1bfa:	32 e0       	ldi	r19, 0x02	; 2
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	31 83       	std	Z+1, r19	; 0x01
    1c00:	20 83       	st	Z, r18
					
				}
    1c02:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    1c06:	08 95       	ret

00001c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>:
				int headIndex;
				int tailIndex;
				int bytesInQueue;
			
			public:
				CircularBuffer(int bufferSize) :  buffer(NULL), bufferSize(bufferSize), headIndex(0), tailIndex(0), bytesInQueue(0)
    1c08:	0f 93       	push	r16
    1c0a:	1f 93       	push	r17
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24
    1c12:	06 2f       	mov	r16, r22
    1c14:	17 2f       	mov	r17, r23
    1c16:	19 82       	std	Y+1, r1	; 0x01
    1c18:	18 82       	st	Y, r1
    1c1a:	6a 83       	std	Y+2, r22	; 0x02
    1c1c:	7b 83       	std	Y+3, r23	; 0x03
    1c1e:	1d 82       	std	Y+5, r1	; 0x05
    1c20:	1c 82       	std	Y+4, r1	; 0x04
    1c22:	1f 82       	std	Y+7, r1	; 0x07
    1c24:	1e 82       	std	Y+6, r1	; 0x06
    1c26:	19 86       	std	Y+9, r1	; 0x09
    1c28:	18 86       	std	Y+8, r1	; 0x08
				{
					buffer = new byte[bufferSize];
    1c2a:	86 2f       	mov	r24, r22
    1c2c:	97 2f       	mov	r25, r23
    1c2e:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    1c32:	88 83       	st	Y, r24
    1c34:	99 83       	std	Y+1, r25	; 0x01
					
					memset(buffer, 0, bufferSize);
    1c36:	40 2f       	mov	r20, r16
    1c38:	51 2f       	mov	r21, r17
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	70 e0       	ldi	r23, 0x00	; 0
    1c3e:	0e 94 68 71 	call	0xe2d0	; 0xe2d0 <memset>
				}
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	1f 91       	pop	r17
    1c48:	0f 91       	pop	r16
    1c4a:	08 95       	ret

00001c4c <_Z41__static_initialization_and_destruction_0ii>:
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR1B &= ~(1<<UDRIE1);
	}	
    1c4c:	81 30       	cpi	r24, 0x01	; 1
    1c4e:	91 05       	cpc	r25, r1
    1c50:	81 f4       	brne	.+32     	; 0x1c72 <_Z41__static_initialization_and_destruction_0ii+0x26>
    1c52:	6f 3f       	cpi	r22, 0xFF	; 255
    1c54:	7f 4f       	sbci	r23, 0xFF	; 255
    1c56:	11 f5       	brne	.+68     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
#include "SerialDriver.h"
#include "CommonHeader.h"

using namespace helicopter::drivers;

CircularBuffer SerialDriver::receiveBuffer(1000);
    1c58:	68 ee       	ldi	r22, 0xE8	; 232
    1c5a:	73 e0       	ldi	r23, 0x03	; 3
    1c5c:	88 e9       	ldi	r24, 0x98	; 152
    1c5e:	93 e0       	ldi	r25, 0x03	; 3
    1c60:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>
CircularBuffer SerialDriver::transmitBuffer(1000);
    1c64:	68 ee       	ldi	r22, 0xE8	; 232
    1c66:	73 e0       	ldi	r23, 0x03	; 3
    1c68:	8e e8       	ldi	r24, 0x8E	; 142
    1c6a:	93 e0       	ldi	r25, 0x03	; 3
    1c6c:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_ZN10helicopter6buffer14CircularBufferC1Ei>
    1c70:	08 95       	ret
    1c72:	89 2b       	or	r24, r25
    1c74:	99 f4       	brne	.+38     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
    1c76:	6f 3f       	cpi	r22, 0xFF	; 255
    1c78:	7f 4f       	sbci	r23, 0xFF	; 255
    1c7a:	81 f4       	brne	.+32     	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
				~CircularBuffer()
				{
					delete [] buffer;
    1c7c:	80 91 8e 03 	lds	r24, 0x038E
    1c80:	90 91 8f 03 	lds	r25, 0x038F
    1c84:	00 97       	sbiw	r24, 0x00	; 0
    1c86:	11 f0       	breq	.+4      	; 0x1c8c <_Z41__static_initialization_and_destruction_0ii+0x40>
    1c88:	0e 94 87 64 	call	0xc90e	; 0xc90e <_ZdaPv>
    1c8c:	80 91 98 03 	lds	r24, 0x0398
    1c90:	90 91 99 03 	lds	r25, 0x0399
    1c94:	00 97       	sbiw	r24, 0x00	; 0
    1c96:	11 f0       	breq	.+4      	; 0x1c9c <_Z41__static_initialization_and_destruction_0ii+0x50>
    1c98:	0e 94 87 64 	call	0xc90e	; 0xc90e <_ZdaPv>
    1c9c:	08 95       	ret

00001c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>:

void SerialDriver::startTimer()
{
	if (timer != NULL)
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	81 85       	ldd	r24, Z+9	; 0x09
    1ca2:	92 85       	ldd	r25, Z+10	; 0x0a
    1ca4:	00 97       	sbiw	r24, 0x00	; 0
    1ca6:	11 f0       	breq	.+4      	; 0x1cac <_ZN10helicopter7drivers12SerialDriver10startTimerEv+0xe>
	{
		timer->startTimer();
    1ca8:	0e 94 fe 69 	call	0xd3fc	; 0xd3fc <_ZN10helicopter4util5Timer10startTimerEv>
    1cac:	08 95       	ret

00001cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>:
	
}

void SerialDriver::stopTimer()
{
	if (timer != NULL)
    1cae:	fc 01       	movw	r30, r24
    1cb0:	81 85       	ldd	r24, Z+9	; 0x09
    1cb2:	92 85       	ldd	r25, Z+10	; 0x0a
    1cb4:	00 97       	sbiw	r24, 0x00	; 0
    1cb6:	11 f0       	breq	.+4      	; 0x1cbc <_ZN10helicopter7drivers12SerialDriver9stopTimerEv+0xe>
	{
		timer->stopTimer();
    1cb8:	0e 94 f1 69 	call	0xd3e2	; 0xd3e2 <_ZN10helicopter4util5Timer9stopTimerEv>
    1cbc:	08 95       	ret

00001cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>:
	
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
    1cbe:	cf 92       	push	r12
    1cc0:	df 92       	push	r13
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	6c 01       	movw	r12, r24
    1cd0:	8a 01       	movw	r16, r20
    1cd2:	e6 2e       	mov	r14, r22
    1cd4:	f7 2e       	mov	r15, r23
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1cd6:	c0 e0       	ldi	r28, 0x00	; 0
    1cd8:	d0 e0       	ldi	r29, 0x00	; 0
	return transmit (buffer, length);
}

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;
    1cda:	20 e0       	ldi	r18, 0x00	; 0
    1cdc:	30 e0       	ldi	r19, 0x00	; 0

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1cde:	c0 17       	cp	r28, r16
    1ce0:	d1 07       	cpc	r29, r17
    1ce2:	1c f4       	brge	.+6      	; 0x1cea <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x2c>
    1ce4:	21 15       	cp	r18, r1
    1ce6:	31 05       	cpc	r19, r1
    1ce8:	19 f0       	breq	.+6      	; 0x1cf0 <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x32>
	{
		status = transmit((byte) buffer[i]);
	}
	
	return status;
    1cea:	82 2f       	mov	r24, r18
    1cec:	93 2f       	mov	r25, r19
    1cee:	0e c0       	rjmp	.+28     	; 0x1d0c <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x4e>
{
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
	{
		status = transmit((byte) buffer[i]);
    1cf0:	d7 01       	movw	r26, r14
    1cf2:	6d 91       	ld	r22, X+
    1cf4:	7d 01       	movw	r14, r26
    1cf6:	d6 01       	movw	r26, r12
    1cf8:	ed 91       	ld	r30, X+
    1cfa:	fc 91       	ld	r31, X
    1cfc:	06 80       	ldd	r0, Z+6	; 0x06
    1cfe:	f7 81       	ldd	r31, Z+7	; 0x07
    1d00:	e0 2d       	mov	r30, r0
    1d02:	c6 01       	movw	r24, r12
    1d04:	19 95       	eicall
    1d06:	9c 01       	movw	r18, r24

int SerialDriver::transmit(const char *buffer, int numOfBytes)
{
	int status = 0;

	for (int i = 0; i < numOfBytes && status == 0; i++)
    1d08:	21 96       	adiw	r28, 0x01	; 1
    1d0a:	e9 cf       	rjmp	.-46     	; 0x1cde <_ZN10helicopter7drivers12SerialDriver8transmitEPKci+0x20>
	{
		status = transmit((byte) buffer[i]);
	}
	
	return status;
}
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	1f 91       	pop	r17
    1d12:	0f 91       	pop	r16
    1d14:	ff 90       	pop	r15
    1d16:	ef 90       	pop	r14
    1d18:	df 90       	pop	r13
    1d1a:	cf 90       	pop	r12
    1d1c:	08 95       	ret

00001d1e <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>:

void SerialDriver::clearBuffer()
{
	byte dummy = 0;
	
	if (uartPort == Zero)
    1d1e:	fc 01       	movw	r30, r24
    1d20:	86 81       	ldd	r24, Z+6	; 0x06
    1d22:	81 11       	cpse	r24, r1
    1d24:	0d c0       	rjmp	.+26     	; 0x1d40 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x22>
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d26:	80 91 c0 00 	lds	r24, 0x00C0
    1d2a:	88 23       	and	r24, r24
    1d2c:	bc f4       	brge	.+46     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR0;
    1d2e:	a6 ec       	ldi	r26, 0xC6	; 198
    1d30:	b0 e0       	ldi	r27, 0x00	; 0
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d32:	e0 ec       	ldi	r30, 0xC0	; 192
    1d34:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR0;
    1d36:	8c 91       	ld	r24, X
	
	if (uartPort == Zero)
	{
		//This clears the buffers, and since the byte is shifted off of the
		//Usart Data Register (UDR),  any buffer overrun or other error flags are cleared as well
		while (UCSR0A & (1<<RXC0) )
    1d38:	80 81       	ld	r24, Z
    1d3a:	88 23       	and	r24, r24
    1d3c:	e4 f3       	brlt	.-8      	; 0x1d36 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x18>
    1d3e:	08 95       	ret
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
    1d40:	81 30       	cpi	r24, 0x01	; 1
    1d42:	61 f4       	brne	.+24     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
	{
		while (UCSR1A & (1<<RXC1) )
    1d44:	80 91 c8 00 	lds	r24, 0x00C8
    1d48:	88 23       	and	r24, r24
    1d4a:	44 f4       	brge	.+16     	; 0x1d5c <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x3e>
		{
			dummy = UDR1;
    1d4c:	ae ec       	ldi	r26, 0xCE	; 206
    1d4e:	b0 e0       	ldi	r27, 0x00	; 0
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1d50:	e8 ec       	ldi	r30, 0xC8	; 200
    1d52:	f0 e0       	ldi	r31, 0x00	; 0
		{
			dummy = UDR1;
    1d54:	8c 91       	ld	r24, X
		{
			dummy = UDR0;
		}
	} else if (uartPort == One)
	{
		while (UCSR1A & (1<<RXC1) )
    1d56:	80 81       	ld	r24, Z
    1d58:	88 23       	and	r24, r24
    1d5a:	e4 f3       	brlt	.-8      	; 0x1d54 <_ZN10helicopter7drivers12SerialDriver11clearBufferEv+0x36>
    1d5c:	08 95       	ret

00001d5e <__vector_25>:
}


//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART0_RX_vect)
{
    1d5e:	1f 92       	push	r1
    1d60:	0f 92       	push	r0
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	0f 92       	push	r0
    1d66:	11 24       	eor	r1, r1
    1d68:	0b b6       	in	r0, 0x3b	; 59
    1d6a:	0f 92       	push	r0
    1d6c:	2f 93       	push	r18
    1d6e:	3f 93       	push	r19
    1d70:	4f 93       	push	r20
    1d72:	5f 93       	push	r21
    1d74:	6f 93       	push	r22
    1d76:	7f 93       	push	r23
    1d78:	8f 93       	push	r24
    1d7a:	9f 93       	push	r25
    1d7c:	af 93       	push	r26
    1d7e:	bf 93       	push	r27
    1d80:	ef 93       	push	r30
    1d82:	ff 93       	push	r31
{
	PORTA &= ~(1<<PA5);
}	
*/		
			
	byte b = UDR0;
    1d84:	60 91 c6 00 	lds	r22, 0x00C6
	SerialDriver::receiveBuffer.enqueueInt(b);
    1d88:	88 e9       	ldi	r24, 0x98	; 152
    1d8a:	93 e0       	ldi	r25, 0x03	; 3
    1d8c:	0e 94 19 02 	call	0x432	; 0x432 <_ZN10helicopter6buffer14CircularBuffer10enqueueIntEh>
}
    1d90:	ff 91       	pop	r31
    1d92:	ef 91       	pop	r30
    1d94:	bf 91       	pop	r27
    1d96:	af 91       	pop	r26
    1d98:	9f 91       	pop	r25
    1d9a:	8f 91       	pop	r24
    1d9c:	7f 91       	pop	r23
    1d9e:	6f 91       	pop	r22
    1da0:	5f 91       	pop	r21
    1da2:	4f 91       	pop	r20
    1da4:	3f 91       	pop	r19
    1da6:	2f 91       	pop	r18
    1da8:	0f 90       	pop	r0
    1daa:	0b be       	out	0x3b, r0	; 59
    1dac:	0f 90       	pop	r0
    1dae:	0f be       	out	0x3f, r0	; 63
    1db0:	0f 90       	pop	r0
    1db2:	1f 90       	pop	r1
    1db4:	18 95       	reti

00001db6 <__vector_26>:

ISR(USART0_UDRE_vect)
{
    1db6:	1f 92       	push	r1
    1db8:	0f 92       	push	r0
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	0f 92       	push	r0
    1dbe:	11 24       	eor	r1, r1
    1dc0:	0b b6       	in	r0, 0x3b	; 59
    1dc2:	0f 92       	push	r0
    1dc4:	2f 93       	push	r18
    1dc6:	3f 93       	push	r19
    1dc8:	4f 93       	push	r20
    1dca:	5f 93       	push	r21
    1dcc:	6f 93       	push	r22
    1dce:	7f 93       	push	r23
    1dd0:	8f 93       	push	r24
    1dd2:	9f 93       	push	r25
    1dd4:	af 93       	push	r26
    1dd6:	bf 93       	push	r27
    1dd8:	ef 93       	push	r30
    1dda:	ff 93       	push	r31
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    1de0:	1f 92       	push	r1
    1de2:	cd b7       	in	r28, 0x3d	; 61
    1de4:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1de6:	be 01       	movw	r22, r28
    1de8:	6f 5f       	subi	r22, 0xFF	; 255
    1dea:	7f 4f       	sbci	r23, 0xFF	; 255
    1dec:	8e e8       	ldi	r24, 0x8E	; 142
    1dee:	93 e0       	ldi	r25, 0x03	; 3
    1df0:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1df4:	88 23       	and	r24, r24
    1df6:	21 f0       	breq	.+8      	; 0x1e00 <__vector_26+0x4a>
	{
		UDR0 = val;
    1df8:	89 81       	ldd	r24, Y+1	; 0x01
    1dfa:	80 93 c6 00 	sts	0x00C6, r24
    1dfe:	05 c0       	rjmp	.+10     	; 0x1e0a <__vector_26+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR0B &= ~(1<<UDRIE0);
    1e00:	e1 ec       	ldi	r30, 0xC1	; 193
    1e02:	f0 e0       	ldi	r31, 0x00	; 0
    1e04:	80 81       	ld	r24, Z
    1e06:	8f 7d       	andi	r24, 0xDF	; 223
    1e08:	80 83       	st	Z, r24
	}
}
    1e0a:	0f 90       	pop	r0
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	ff 91       	pop	r31
    1e12:	ef 91       	pop	r30
    1e14:	bf 91       	pop	r27
    1e16:	af 91       	pop	r26
    1e18:	9f 91       	pop	r25
    1e1a:	8f 91       	pop	r24
    1e1c:	7f 91       	pop	r23
    1e1e:	6f 91       	pop	r22
    1e20:	5f 91       	pop	r21
    1e22:	4f 91       	pop	r20
    1e24:	3f 91       	pop	r19
    1e26:	2f 91       	pop	r18
    1e28:	0f 90       	pop	r0
    1e2a:	0b be       	out	0x3b, r0	; 59
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	0f 90       	pop	r0
    1e32:	1f 90       	pop	r1
    1e34:	18 95       	reti

00001e36 <__vector_37>:
ISR(USART1_UDRE_vect)
{
    1e36:	1f 92       	push	r1
    1e38:	0f 92       	push	r0
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	0f 92       	push	r0
    1e3e:	11 24       	eor	r1, r1
    1e40:	0b b6       	in	r0, 0x3b	; 59
    1e42:	0f 92       	push	r0
    1e44:	2f 93       	push	r18
    1e46:	3f 93       	push	r19
    1e48:	4f 93       	push	r20
    1e4a:	5f 93       	push	r21
    1e4c:	6f 93       	push	r22
    1e4e:	7f 93       	push	r23
    1e50:	8f 93       	push	r24
    1e52:	9f 93       	push	r25
    1e54:	af 93       	push	r26
    1e56:	bf 93       	push	r27
    1e58:	ef 93       	push	r30
    1e5a:	ff 93       	push	r31
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	1f 92       	push	r1
    1e62:	cd b7       	in	r28, 0x3d	; 61
    1e64:	de b7       	in	r29, 0x3e	; 62
	byte val;
	if (SerialDriver::transmitBuffer.dequeueInt(val) == true)
    1e66:	be 01       	movw	r22, r28
    1e68:	6f 5f       	subi	r22, 0xFF	; 255
    1e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e6c:	8e e8       	ldi	r24, 0x8E	; 142
    1e6e:	93 e0       	ldi	r25, 0x03	; 3
    1e70:	0e 94 47 02 	call	0x48e	; 0x48e <_ZN10helicopter6buffer14CircularBuffer10dequeueIntERh>
    1e74:	88 23       	and	r24, r24
    1e76:	21 f0       	breq	.+8      	; 0x1e80 <__vector_37+0x4a>
	{
		UDR1 = val;
    1e78:	89 81       	ldd	r24, Y+1	; 0x01
    1e7a:	80 93 ce 00 	sts	0x00CE, r24
    1e7e:	05 c0       	rjmp	.+10     	; 0x1e8a <__vector_37+0x54>
	}else
	{
		//no more data to transmit so disable data register empty interrupt (page 214 of spec)
		UCSR1B &= ~(1<<UDRIE1);
    1e80:	e9 ec       	ldi	r30, 0xC9	; 201
    1e82:	f0 e0       	ldi	r31, 0x00	; 0
    1e84:	80 81       	ld	r24, Z
    1e86:	8f 7d       	andi	r24, 0xDF	; 223
    1e88:	80 83       	st	Z, r24
	}	
    1e8a:	0f 90       	pop	r0
    1e8c:	df 91       	pop	r29
    1e8e:	cf 91       	pop	r28
    1e90:	ff 91       	pop	r31
    1e92:	ef 91       	pop	r30
    1e94:	bf 91       	pop	r27
    1e96:	af 91       	pop	r26
    1e98:	9f 91       	pop	r25
    1e9a:	8f 91       	pop	r24
    1e9c:	7f 91       	pop	r23
    1e9e:	6f 91       	pop	r22
    1ea0:	5f 91       	pop	r21
    1ea2:	4f 91       	pop	r20
    1ea4:	3f 91       	pop	r19
    1ea6:	2f 91       	pop	r18
    1ea8:	0f 90       	pop	r0
    1eaa:	0b be       	out	0x3b, r0	; 59
    1eac:	0f 90       	pop	r0
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	0f 90       	pop	r0
    1eb2:	1f 90       	pop	r1
    1eb4:	18 95       	reti

00001eb6 <_GLOBAL__sub_I__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
    1eb6:	6f ef       	ldi	r22, 0xFF	; 255
    1eb8:	7f ef       	ldi	r23, 0xFF	; 255
    1eba:	81 e0       	ldi	r24, 0x01	; 1
    1ebc:	90 e0       	ldi	r25, 0x00	; 0
    1ebe:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <_Z41__static_initialization_and_destruction_0ii>
    1ec2:	08 95       	ret

00001ec4 <_GLOBAL__sub_D__ZN10helicopter7drivers12SerialDriver13receiveBufferE>:
    1ec4:	6f ef       	ldi	r22, 0xFF	; 255
    1ec6:	7f ef       	ldi	r23, 0xFF	; 255
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <_Z41__static_initialization_and_destruction_0ii>
    1ed0:	08 95       	ret

00001ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>:
{
	/**
	* Configure the MOSI (DDB2) pin, SCK (DDB1), and SS (DDB0) pin (the SS pin for the accelerometer/IMU)
	* as output
	*/
	DDRB = (1<<DDB2) | (1<<DDB1) | (1<<DDB0);
    1ed2:	87 e0       	ldi	r24, 0x07	; 7
    1ed4:	84 b9       	out	0x04, r24	; 4
	
	/**
	 * Configure the SS pin for the barometer as output
	 */
	DDRG |= (1<<DDG1);
    1ed6:	99 9a       	sbi	0x13, 1	; 19
	//Set the slave select lines 'high', therefore freeing up the SPI line. (This would otherwise default to 0, making this device
	//hold onto the SPI line). This turns the line 'off' to 'end' any current transactions. These lines
	//default to low (active) so they have to be pulled high in order to free up the SS lines so a device
	//can communicate on the line.
	//Note: Slave Select for the IMU (accelerometer, etc) is PB0, while slave select for the barometer is PG1.
	PORTB |= (1<<PB0);
    1ed8:	28 9a       	sbi	0x05, 0	; 5
	PORTG |= (1<<PG1);
    1eda:	a1 9a       	sbi	0x14, 1	; 20
	 * SPI Control Register (SPCR)
	 * Enable SPI (1<<SPE)
	 * Set this device as the master device on the SPI line (1<<MSTR)
	 * Set clock frequency to Fosc / 16 (1<<SPR0) (clock speed divided by 16)
	 */
	SPCR |= (1<<SPE) | (1<<MSTR) | (1<<SPR0);
    1edc:	8c b5       	in	r24, 0x2c	; 44
    1ede:	81 65       	ori	r24, 0x51	; 81
    1ee0:	8c bd       	out	0x2c, r24	; 44
    1ee2:	08 95       	ret

00001ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>:
{
	/**
	* Set the Slave Select to 0 indicating that the master will be sending
	* data across the SPI line.
	*/
	if (ssLine == SPIDriver::SS_B)
    1ee4:	fc 01       	movw	r30, r24
    1ee6:	80 81       	ld	r24, Z
    1ee8:	81 30       	cpi	r24, 0x01	; 1
    1eea:	11 f4       	brne	.+4      	; 0x1ef0 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0xc>
	{	
		PORTB &= ~(1<<PB0);
    1eec:	28 98       	cbi	0x05, 0	; 5
    1eee:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1ef0:	82 30       	cpi	r24, 0x02	; 2
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv+0x12>
	{
		PORTG &= ~(1<<PG1);
    1ef4:	a1 98       	cbi	0x14, 1	; 20
    1ef6:	08 95       	ret

00001ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>:
{
	/**
	 * Set the Slave Select line to 1 indicating that the master
	 * is finished communicating (release the SPI line)
	 */
	if (ssLine == SPIDriver::SS_B)
    1ef8:	fc 01       	movw	r30, r24
    1efa:	80 81       	ld	r24, Z
    1efc:	81 30       	cpi	r24, 0x01	; 1
    1efe:	11 f4       	brne	.+4      	; 0x1f04 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0xc>
	{	
		PORTB |= (1<<PB0);	
    1f00:	28 9a       	sbi	0x05, 0	; 5
    1f02:	08 95       	ret
	}else if (ssLine == SPIDriver::SS_G)
    1f04:	82 30       	cpi	r24, 0x02	; 2
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <_ZN10helicopter7drivers9SPIDriver14endTransactionEv+0x12>
	{
		PORTG |= (1<<PG1);	
    1f08:	a1 9a       	sbi	0x14, 1	; 20
    1f0a:	08 95       	ret

00001f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>:
	 * we are communicating with, uses the same clock cycles that are used
	 * to push each bit in the message we put into the register, to send
	 * this device data. 1 clock cycle used to push data to the device
	 * is also used to push data to THIS device.
	 */
	SPDR = 0;
    1f0c:	1e bc       	out	0x2e, r1	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1f0e:	0d b4       	in	r0, 0x2d	; 45
    1f10:	07 fe       	sbrs	r0, 7
    1f12:	fd cf       	rjmp	.-6      	; 0x1f0e <_ZN10helicopter7drivers9SPIDriver8readByteEv+0x2>
	
	/**
	 * Return the value of SPDR because now the data register
	 * contains the data that was sent to us by the device.
	 */
	return SPDR;
    1f14:	8e b5       	in	r24, 0x2e	; 46
}
    1f16:	08 95       	ret

00001f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>:
	
	return  ((int) highByte<<8) | lowByte;
}

unsigned int SPIDriver::readUInt()
{
    1f18:	1f 93       	push	r17
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1f20:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1f24:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1f26:	ce 01       	movw	r24, r28
    1f28:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	//
	//return hb | lb;
	
	unsigned int returnValue = 0;
	
	returnValue = (highByte << 8) | lowByte;
    1f2c:	20 e0       	ldi	r18, 0x00	; 0
    1f2e:	28 2b       	or	r18, r24
	
	return returnValue;
	
	
//	return  (((unsigned int) highByte)<<8) | lowByte;
}
    1f30:	82 2f       	mov	r24, r18
    1f32:	91 2f       	mov	r25, r17
    1f34:	df 91       	pop	r29
    1f36:	cf 91       	pop	r28
    1f38:	1f 91       	pop	r17
    1f3a:	08 95       	ret

00001f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>:
		PORTG |= (1<<PG1);	
	}
}

int SPIDriver::readInt()
{
    1f3c:	1f 93       	push	r17
    1f3e:	cf 93       	push	r28
    1f40:	df 93       	push	r29
    1f42:	ec 01       	movw	r28, r24
	byte highByte = readByte();
    1f44:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    1f48:	18 2f       	mov	r17, r24
	byte lowByte = readByte();
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
	
	return  ((int) highByte<<8) | lowByte;
    1f50:	20 e0       	ldi	r18, 0x00	; 0
    1f52:	28 2b       	or	r18, r24
}
    1f54:	82 2f       	mov	r24, r18
    1f56:	91 2f       	mov	r25, r17
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	1f 91       	pop	r17
    1f5e:	08 95       	ret

00001f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>:
void SPIDriver::write( byte data )
{
	/**
	 * Write the byte to SPI Data Register
	 */
	SPDR = data;
    1f60:	6e bd       	out	0x2e, r22	; 46
	 * Wait until the SPI Status Register's
	 * SPI Interrupt flag to be set which is set
	 * when data transfer is complete, and is cleared
	 * when the SPSR register is read.
	 */
	while(!(SPSR & (1<<SPIF)));
    1f62:	0d b4       	in	r0, 0x2d	; 45
    1f64:	07 fe       	sbrs	r0, 7
    1f66:	fd cf       	rjmp	.-6      	; 0x1f62 <_ZN10helicopter7drivers9SPIDriver5writeEh+0x2>
}
    1f68:	08 95       	ret

00001f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>:

void SPIDriver::transactionWrite( byte data )
{
    1f6a:	1f 93       	push	r17
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
    1f70:	ec 01       	movw	r28, r24
    1f72:	16 2f       	mov	r17, r22
	beginTransaction();
    1f74:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(data);
    1f78:	61 2f       	mov	r22, r17
    1f7a:	ce 01       	movw	r24, r28
    1f7c:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1f80:	ce 01       	movw	r24, r28
    1f82:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	1f 91       	pop	r17
    1f8c:	08 95       	ret

00001f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>:
	write(commandAddress);
	write(commandValue);
}

void SPIDriver::transactionWrite( byte commandAddress, byte commandValue )
{
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	cf 93       	push	r28
    1f94:	df 93       	push	r29
    1f96:	ec 01       	movw	r28, r24
    1f98:	06 2f       	mov	r16, r22
    1f9a:	14 2f       	mov	r17, r20
	beginTransaction();
    1f9c:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	write(commandAddress);
    1fa0:	60 2f       	mov	r22, r16
    1fa2:	ce 01       	movw	r24, r28
    1fa4:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	write(commandValue);
    1fa8:	61 2f       	mov	r22, r17
    1faa:	ce 01       	movw	r24, r28
    1fac:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	endTransaction();
    1fb0:	ce 01       	movw	r24, r28
    1fb2:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	08 95       	ret

00001fc0 <_ZN10helicopter7drivers9TWIDriver4initEv>:
	 * because if you run it in conjunction with the servo radio controller, it'll cause the wait for twint to wait forever
	 * if you don't set up the bit rate.
	 */	
	
	//Set the data line and clock line to output. 
	DDRD |= (1<<PD0);
    1fc0:	50 9a       	sbi	0x0a, 0	; 10
	DDRD |= (1<<PD1);
    1fc2:	51 9a       	sbi	0x0a, 1	; 10

	//Set the prescaler for twi to 1
	TWSR &= ~(1<<TWPS0);
    1fc4:	e9 eb       	ldi	r30, 0xB9	; 185
    1fc6:	f0 e0       	ldi	r31, 0x00	; 0
    1fc8:	80 81       	ld	r24, Z
    1fca:	8e 7f       	andi	r24, 0xFE	; 254
    1fcc:	80 83       	st	Z, r24
	TWSR &= ~(1<<TWPS1);
    1fce:	80 81       	ld	r24, Z
    1fd0:	8d 7f       	andi	r24, 0xFD	; 253
    1fd2:	80 83       	st	Z, r24

	//set the bit rate (page 248 of atmega2560 data sheet)
	//this is 200khz clock rate. 
	//equation is here http://www.ermicro.com/blog/?p=744
	//SCL freq = cpu clock freq / (16 + 2(TWBR) * prescaler)
	TWBR = ((16000000UL / 400000UL) - 16UL) / 2UL;
    1fd4:	8c e0       	ldi	r24, 0x0C	; 12
    1fd6:	80 93 b8 00 	sts	0x00B8, r24
    1fda:	08 95       	ret

00001fdc <_ZN10helicopter7drivers9TWIDriver5startEv>:
}

bool TWIDriver::start()
{
	//Send the Start condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    1fdc:	84 ea       	ldi	r24, 0xA4	; 164
    1fde:	80 93 bc 00 	sts	0x00BC, r24
    1fe2:	84 e6       	ldi	r24, 0x64	; 100
    1fe4:	90 e0       	ldi	r25, 0x00	; 0

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    1fe6:	ec eb       	ldi	r30, 0xBC	; 188
    1fe8:	f0 e0       	ldi	r31, 0x00	; 0
    1fea:	20 81       	ld	r18, Z
    1fec:	22 23       	and	r18, r18
    1fee:	bc f4       	brge	.+46     	; 0x201e <_ZN10helicopter7drivers9TWIDriver5startEv+0x42>
    1ff0:	11 c0       	rjmp	.+34     	; 0x2014 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
	}
	
	
	
	//Verify that start condition was successfully sent.
	int status = TWSR & 0xF8;
    1ff2:	20 91 b9 00 	lds	r18, 0x00B9
    1ff6:	28 7f       	andi	r18, 0xF8	; 248
    1ff8:	30 e0       	ldi	r19, 0x00	; 0
	
	if (status == START ||
    1ffa:	28 30       	cpi	r18, 0x08	; 8
    1ffc:	31 05       	cpc	r19, r1
    1ffe:	31 f0       	breq	.+12     	; 0x200c <_ZN10helicopter7drivers9TWIDriver5startEv+0x30>
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	20 31       	cpi	r18, 0x10	; 16
    2004:	31 05       	cpc	r19, r1
    2006:	71 f0       	breq	.+28     	; 0x2024 <_ZN10helicopter7drivers9TWIDriver5startEv+0x48>
    2008:	80 e0       	ldi	r24, 0x00	; 0
    200a:	08 95       	ret
	 status == REPEATED_START)
	{	
		return true;
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    2010:	80 e0       	ldi	r24, 0x00	; 0
    2012:	08 95       	ret
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    2014:	80 91 bc 00 	lds	r24, 0x00BC
    2018:	88 23       	and	r24, r24
    201a:	d4 f7       	brge	.-12     	; 0x2010 <_ZN10helicopter7drivers9TWIDriver5startEv+0x34>
    201c:	ea cf       	rjmp	.-44     	; 0x1ff2 <_ZN10helicopter7drivers9TWIDriver5startEv+0x16>
    201e:	01 97       	sbiw	r24, 0x01	; 1

	//wait for twint flag to be set.
	//This indicates that the start condition was sent.
//	while (!(TWCR & (1<<TWINT)))
//	;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    2020:	c9 f3       	breq	.-14     	; 0x2014 <_ZN10helicopter7drivers9TWIDriver5startEv+0x38>
    2022:	e3 cf       	rjmp	.-58     	; 0x1fea <_ZN10helicopter7drivers9TWIDriver5startEv+0xe>
		return true;
	}

	
	return false;
}
    2024:	08 95       	ret

00002026 <_ZN10helicopter7drivers9TWIDriver4stopEv>:


void TWIDriver::stop()
{
	//Send the stop condition.
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    2026:	84 e9       	ldi	r24, 0x94	; 148
    2028:	80 93 bc 00 	sts	0x00BC, r24
    202c:	08 95       	ret

0000202e <_ZN10helicopter7drivers9TWIDriver5resetEv>:

using namespace helicopter::drivers;

void TWIDriver::reset()
{
	this->stop();
    202e:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	TWCR &= ~(1<<TWEN);
    2032:	ec eb       	ldi	r30, 0xBC	; 188
    2034:	f0 e0       	ldi	r31, 0x00	; 0
    2036:	80 81       	ld	r24, Z
    2038:	8b 7f       	andi	r24, 0xFB	; 251
    203a:	80 83       	st	Z, r24
    203c:	08 95       	ret

0000203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>:
}

bool TWIDriver::write( byte data, byte acknowledgeValue)
{
	//Place data onto the Two Wire Data Register
	TWDR = data; 
    203e:	60 93 bb 00 	sts	0x00BB, r22

	//Start the transmission of the data.
	//Writing 1 to TWINT clears TWINT. Otherwise, TWINT could hold the SCL line low so that other transmissions
	//arn't allowed. Writing 1 clears it so transmissions are allowed. 
	//Setting TWEN free's up the pin so that the clock can take control of it for managing clock cycles between the two devices. 
	TWCR = (1<<TWINT) | (1<<TWEN); 
    2042:	84 e8       	ldi	r24, 0x84	; 132
    2044:	80 93 bc 00 	sts	0x00BC, r24
    2048:	84 e6       	ldi	r24, 0x64	; 100
    204a:	90 e0       	ldi	r25, 0x00	; 0
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    204c:	ec eb       	ldi	r30, 0xBC	; 188
    204e:	f0 e0       	ldi	r31, 0x00	; 0
    2050:	20 81       	ld	r18, Z
    2052:	22 23       	and	r18, r18
    2054:	cc f4       	brge	.+50     	; 0x2088 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x4a>
    2056:	13 c0       	rjmp	.+38     	; 0x207e <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>

	
	//If an acknowledgment value was given,
	//check to ensure that the ack value received from TW matched
	//the parameter
	if (acknowledgeValue != 0 && 
    2058:	44 23       	and	r20, r20
    205a:	59 f0       	breq	.+22     	; 0x2072 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x34>
    205c:	20 91 b9 00 	lds	r18, 0x00B9
    2060:	28 7f       	andi	r18, 0xF8	; 248
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	50 e0       	ldi	r21, 0x00	; 0
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	24 17       	cp	r18, r20
    206a:	35 07       	cpc	r19, r21
    206c:	19 f4       	brne	.+6      	; 0x2074 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    206e:	80 e0       	ldi	r24, 0x00	; 0
    2070:	01 c0       	rjmp	.+2      	; 0x2074 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x36>
    2072:	80 e0       	ldi	r24, 0x00	; 0
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	89 27       	eor	r24, r25
    2078:	08 95       	ret
	{
	}

	if (!(TWCR & (1<<TWINT)))
	{
		return false;
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	08 95       	ret
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}

	if (!(TWCR & (1<<TWINT)))
    207e:	80 91 bc 00 	lds	r24, 0x00BC
    2082:	88 23       	and	r24, r24
    2084:	d4 f7       	brge	.-12     	; 0x207a <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x3c>
    2086:	e8 cf       	rjmp	.-48     	; 0x2058 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x1a>
    2088:	01 97       	sbiw	r24, 0x01	; 1
	
	//Wait for TWINT flag to be set. This indicates that the data has been transmitted
	//and the ack/nack has been received.  
	//while (!(TWCR & (1<<TWINT)))
	//;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    208a:	c9 f3       	breq	.-14     	; 0x207e <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x40>
    208c:	e1 cf       	rjmp	.-62     	; 0x2050 <_ZN10helicopter7drivers9TWIDriver5writeEhh+0x12>

0000208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>:

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
	//Clear the interrupt to start receiving data (why acknowledge?)*** clocks out data??
	//TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
	if (acknowledge)
    208e:	66 23       	and	r22, r22
    2090:	21 f0       	breq	.+8      	; 0x209a <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0xc>
	{
		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
    2092:	84 ec       	ldi	r24, 0xC4	; 196
    2094:	80 93 bc 00 	sts	0x00BC, r24
    2098:	03 c0       	rjmp	.+6      	; 0x20a0 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x12>
	}else
	{
		TWCR = (1<<TWINT) | (1<<TWEN);
    209a:	84 e8       	ldi	r24, 0x84	; 132
    209c:	80 93 bc 00 	sts	0x00BC, r24
	
	return true;
}

bool TWIDriver::readByte(bool acknowledge, byte& val)
{
    20a0:	84 e6       	ldi	r24, 0x64	; 100
    20a2:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    20a4:	ec eb       	ldi	r30, 0xBC	; 188
    20a6:	f0 e0       	ldi	r31, 0x00	; 0
    20a8:	20 81       	ld	r18, Z
    20aa:	22 23       	and	r18, r18
    20ac:	84 f4       	brge	.+32     	; 0x20ce <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x40>
    20ae:	0a c0       	rjmp	.+20     	; 0x20c4 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
	{
		val = 0;
    20b0:	fa 01       	movw	r30, r20
    20b2:	10 82       	st	Z, r1
		return false;
    20b4:	80 e0       	ldi	r24, 0x00	; 0
    20b6:	08 95       	ret
	}

	
	//Read the data.
	//byte receivedValue = TWDR;
	val = TWDR;
    20b8:	80 91 bb 00 	lds	r24, 0x00BB
    20bc:	fa 01       	movw	r30, r20
    20be:	80 83       	st	Z, r24
	
	//return receivedValue;
	return true;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	08 95       	ret
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
	{
	}
	
	if (!(TWCR & (1<<TWINT)))
    20c4:	80 91 bc 00 	lds	r24, 0x00BC
    20c8:	88 23       	and	r24, r24
    20ca:	94 f7       	brge	.-28     	; 0x20b0 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x22>
    20cc:	f5 cf       	rjmp	.-22     	; 0x20b8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x2a>
    20ce:	01 97       	sbiw	r24, 0x01	; 1
	}
	
	
	//Wait for the interrupt to be reset, indicating that we received the data
	//while (!(TWCR & (1<<TWINT))) ;
	for (int i = 0; i < 100  && !(TWCR & (1<<TWINT)); i++)
    20d0:	c9 f3       	breq	.-14     	; 0x20c4 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x36>
    20d2:	ea cf       	rjmp	.-44     	; 0x20a8 <_ZN10helicopter7drivers9TWIDriver8readByteEbRh+0x1a>

000020d4 <_ZN10helicopter5tasks12FlashLEDTask4initEv>:
					
			}
	
			void init()
			{
				DDRA |= (1<<ledToBlink);
    20d4:	41 b1       	in	r20, 0x01	; 1
    20d6:	21 e0       	ldi	r18, 0x01	; 1
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	fc 01       	movw	r30, r24
    20dc:	00 84       	ldd	r0, Z+8	; 0x08
    20de:	02 c0       	rjmp	.+4      	; 0x20e4 <_ZN10helicopter5tasks12FlashLEDTask4initEv+0x10>
    20e0:	22 0f       	add	r18, r18
    20e2:	33 1f       	adc	r19, r19
    20e4:	0a 94       	dec	r0
    20e6:	e2 f7       	brpl	.-8      	; 0x20e0 <_ZN10helicopter5tasks12FlashLEDTask4initEv+0xc>
    20e8:	24 2b       	or	r18, r20
    20ea:	21 b9       	out	0x01, r18	; 1
    20ec:	08 95       	ret

000020ee <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv>:
			}
	
			/**
				* Flashes the LED
				*/
			void runTaskImpl() {
    20ee:	fc 01       	movw	r30, r24
				if (isOff)
    20f0:	87 81       	ldd	r24, Z+7	; 0x07
    20f2:	88 23       	and	r24, r24
    20f4:	79 f0       	breq	.+30     	; 0x2114 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x26>
				{
					//Turn On the LED
					PORTA &= ~(1<<ledToBlink);
    20f6:	42 b1       	in	r20, 0x02	; 2
    20f8:	21 e0       	ldi	r18, 0x01	; 1
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	c9 01       	movw	r24, r18
    20fe:	00 84       	ldd	r0, Z+8	; 0x08
    2100:	02 c0       	rjmp	.+4      	; 0x2106 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x18>
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	0a 94       	dec	r0
    2108:	e2 f7       	brpl	.-8      	; 0x2102 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x14>
    210a:	80 95       	com	r24
    210c:	84 23       	and	r24, r20
    210e:	82 b9       	out	0x02, r24	; 2
					isOff = false;
    2110:	17 82       	std	Z+7, r1	; 0x07
    2112:	08 95       	ret
				}else
				{
					//Turn Off the LED
					PORTA |= (1<<ledToBlink);
    2114:	42 b1       	in	r20, 0x02	; 2
    2116:	21 e0       	ldi	r18, 0x01	; 1
    2118:	30 e0       	ldi	r19, 0x00	; 0
    211a:	c9 01       	movw	r24, r18
    211c:	00 84       	ldd	r0, Z+8	; 0x08
    211e:	02 c0       	rjmp	.+4      	; 0x2124 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x36>
    2120:	88 0f       	add	r24, r24
    2122:	99 1f       	adc	r25, r25
    2124:	0a 94       	dec	r0
    2126:	e2 f7       	brpl	.-8      	; 0x2120 <_ZN10helicopter5tasks12FlashLEDTask11runTaskImplEv+0x32>
    2128:	84 2b       	or	r24, r20
    212a:	82 b9       	out	0x02, r24	; 2
					isOff = true;
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	87 83       	std	Z+7, r24	; 0x07
    2130:	08 95       	ret

00002132 <_ZN10helicopter5tasks12FlashLEDTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    2132:	26 e7       	ldi	r18, 0x76	; 118
    2134:	33 e0       	ldi	r19, 0x03	; 3
    2136:	fc 01       	movw	r30, r24
    2138:	31 83       	std	Z+1, r19	; 0x01
    213a:	20 83       	st	Z, r18
    213c:	08 95       	ret

0000213e <_ZN10helicopter5tasks12FlashLEDTaskD0Ev>:
    213e:	26 e7       	ldi	r18, 0x76	; 118
    2140:	33 e0       	ldi	r19, 0x03	; 3
    2142:	fc 01       	movw	r30, r24
    2144:	31 83       	std	Z+1, r19	; 0x01
    2146:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
			* This task is used to periodically flash an LED on the flight computer.
			*/
		class FlashLEDTask : public Task
    2148:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    214c:	08 95       	ret

0000214e <_ZN10helicopter5model11SystemModelC1Ev>:
			
			float EcefToLocalNEDRotationMatrix[3][3];
			
			bool HasNewPressureReading;
			
			SystemModel():
    214e:	fc 01       	movw	r30, r24
				xVEcefCms(0),
				yVEcefCms(0),
				zVEcefCms(0),
				pressureMillibars(0),
				auxChannelValue(0),
				HasNewPressureReading(false)				
    2150:	11 82       	std	Z+1, r1	; 0x01
    2152:	10 82       	st	Z, r1
    2154:	12 82       	std	Z+2, r1	; 0x02
    2156:	13 82       	std	Z+3, r1	; 0x03
    2158:	14 82       	std	Z+4, r1	; 0x04
    215a:	15 82       	std	Z+5, r1	; 0x05
    215c:	16 82       	std	Z+6, r1	; 0x06
    215e:	17 82       	std	Z+7, r1	; 0x07
    2160:	10 86       	std	Z+8, r1	; 0x08
    2162:	11 86       	std	Z+9, r1	; 0x09
    2164:	12 86       	std	Z+10, r1	; 0x0a
    2166:	13 86       	std	Z+11, r1	; 0x0b
    2168:	14 86       	std	Z+12, r1	; 0x0c
    216a:	15 86       	std	Z+13, r1	; 0x0d
    216c:	16 86       	std	Z+14, r1	; 0x0e
    216e:	17 86       	std	Z+15, r1	; 0x0f
    2170:	10 8a       	std	Z+16, r1	; 0x10
    2172:	11 8a       	std	Z+17, r1	; 0x11
    2174:	12 8a       	std	Z+18, r1	; 0x12
    2176:	13 8a       	std	Z+19, r1	; 0x13
    2178:	14 8a       	std	Z+20, r1	; 0x14
    217a:	15 8a       	std	Z+21, r1	; 0x15
    217c:	16 8a       	std	Z+22, r1	; 0x16
    217e:	17 8a       	std	Z+23, r1	; 0x17
    2180:	10 8e       	std	Z+24, r1	; 0x18
    2182:	11 8e       	std	Z+25, r1	; 0x19
    2184:	12 8e       	std	Z+26, r1	; 0x1a
    2186:	13 8e       	std	Z+27, r1	; 0x1b
    2188:	14 8e       	std	Z+28, r1	; 0x1c
    218a:	15 8e       	std	Z+29, r1	; 0x1d
    218c:	16 8e       	std	Z+30, r1	; 0x1e
    218e:	17 8e       	std	Z+31, r1	; 0x1f
    2190:	10 a2       	std	Z+32, r1	; 0x20
    2192:	11 a2       	std	Z+33, r1	; 0x21
    2194:	12 a2       	std	Z+34, r1	; 0x22
    2196:	13 a2       	std	Z+35, r1	; 0x23
    2198:	14 a2       	std	Z+36, r1	; 0x24
    219a:	15 a2       	std	Z+37, r1	; 0x25
    219c:	16 a2       	std	Z+38, r1	; 0x26
    219e:	17 a2       	std	Z+39, r1	; 0x27
    21a0:	10 a6       	std	Z+40, r1	; 0x28
    21a2:	11 a6       	std	Z+41, r1	; 0x29
    21a4:	12 a6       	std	Z+42, r1	; 0x2a
    21a6:	13 a6       	std	Z+43, r1	; 0x2b
    21a8:	14 a6       	std	Z+44, r1	; 0x2c
    21aa:	15 a6       	std	Z+45, r1	; 0x2d
    21ac:	16 a6       	std	Z+46, r1	; 0x2e
    21ae:	17 a6       	std	Z+47, r1	; 0x2f
    21b0:	10 aa       	std	Z+48, r1	; 0x30
    21b2:	11 aa       	std	Z+49, r1	; 0x31
    21b4:	12 aa       	std	Z+50, r1	; 0x32
    21b6:	13 aa       	std	Z+51, r1	; 0x33
    21b8:	14 aa       	std	Z+52, r1	; 0x34
    21ba:	15 aa       	std	Z+53, r1	; 0x35
    21bc:	16 aa       	std	Z+54, r1	; 0x36
    21be:	17 aa       	std	Z+55, r1	; 0x37
    21c0:	10 ae       	std	Z+56, r1	; 0x38
    21c2:	11 ae       	std	Z+57, r1	; 0x39
    21c4:	12 ae       	std	Z+58, r1	; 0x3a
    21c6:	13 ae       	std	Z+59, r1	; 0x3b
    21c8:	14 ae       	std	Z+60, r1	; 0x3c
    21ca:	15 ae       	std	Z+61, r1	; 0x3d
    21cc:	dc 01       	movw	r26, r24
    21ce:	de 96       	adiw	r26, 0x3e	; 62
    21d0:	1d 92       	st	X+, r1
    21d2:	1d 92       	st	X+, r1
    21d4:	1d 92       	st	X+, r1
    21d6:	1c 92       	st	X, r1
    21d8:	13 97       	sbiw	r26, 0x03	; 3
    21da:	dc 01       	movw	r26, r24
    21dc:	ae 5b       	subi	r26, 0xBE	; 190
    21de:	bf 4f       	sbci	r27, 0xFF	; 255
    21e0:	1d 92       	st	X+, r1
    21e2:	1d 92       	st	X+, r1
    21e4:	1d 92       	st	X+, r1
    21e6:	1c 92       	st	X, r1
    21e8:	13 97       	sbiw	r26, 0x03	; 3
    21ea:	dc 01       	movw	r26, r24
    21ec:	aa 5b       	subi	r26, 0xBA	; 186
    21ee:	bf 4f       	sbci	r27, 0xFF	; 255
    21f0:	1d 92       	st	X+, r1
    21f2:	1d 92       	st	X+, r1
    21f4:	1d 92       	st	X+, r1
    21f6:	1c 92       	st	X, r1
    21f8:	13 97       	sbiw	r26, 0x03	; 3
    21fa:	dc 01       	movw	r26, r24
    21fc:	a6 5b       	subi	r26, 0xB6	; 182
    21fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2200:	1d 92       	st	X+, r1
    2202:	1d 92       	st	X+, r1
    2204:	1d 92       	st	X+, r1
    2206:	1c 92       	st	X, r1
    2208:	13 97       	sbiw	r26, 0x03	; 3
    220a:	dc 01       	movw	r26, r24
    220c:	a2 5b       	subi	r26, 0xB2	; 178
    220e:	bf 4f       	sbci	r27, 0xFF	; 255
    2210:	1d 92       	st	X+, r1
    2212:	1d 92       	st	X+, r1
    2214:	1d 92       	st	X+, r1
    2216:	1c 92       	st	X, r1
    2218:	13 97       	sbiw	r26, 0x03	; 3
    221a:	dc 01       	movw	r26, r24
    221c:	ae 5a       	subi	r26, 0xAE	; 174
    221e:	bf 4f       	sbci	r27, 0xFF	; 255
    2220:	1d 92       	st	X+, r1
    2222:	1d 92       	st	X+, r1
    2224:	1d 92       	st	X+, r1
    2226:	1c 92       	st	X, r1
    2228:	13 97       	sbiw	r26, 0x03	; 3
    222a:	dc 01       	movw	r26, r24
    222c:	aa 5a       	subi	r26, 0xAA	; 170
    222e:	bf 4f       	sbci	r27, 0xFF	; 255
    2230:	1d 92       	st	X+, r1
    2232:	1d 92       	st	X+, r1
    2234:	1d 92       	st	X+, r1
    2236:	1c 92       	st	X, r1
    2238:	13 97       	sbiw	r26, 0x03	; 3
    223a:	dc 01       	movw	r26, r24
    223c:	a6 5a       	subi	r26, 0xA6	; 166
    223e:	bf 4f       	sbci	r27, 0xFF	; 255
    2240:	1d 92       	st	X+, r1
    2242:	1d 92       	st	X+, r1
    2244:	1d 92       	st	X+, r1
    2246:	1c 92       	st	X, r1
    2248:	13 97       	sbiw	r26, 0x03	; 3
    224a:	dc 01       	movw	r26, r24
    224c:	a2 5a       	subi	r26, 0xA2	; 162
    224e:	bf 4f       	sbci	r27, 0xFF	; 255
    2250:	1d 92       	st	X+, r1
    2252:	1d 92       	st	X+, r1
    2254:	1d 92       	st	X+, r1
    2256:	1c 92       	st	X, r1
    2258:	13 97       	sbiw	r26, 0x03	; 3
    225a:	dc 01       	movw	r26, r24
    225c:	ae 59       	subi	r26, 0x9E	; 158
    225e:	bf 4f       	sbci	r27, 0xFF	; 255
    2260:	1d 92       	st	X+, r1
    2262:	1d 92       	st	X+, r1
    2264:	1d 92       	st	X+, r1
    2266:	1c 92       	st	X, r1
    2268:	13 97       	sbiw	r26, 0x03	; 3
    226a:	dc 01       	movw	r26, r24
    226c:	aa 59       	subi	r26, 0x9A	; 154
    226e:	bf 4f       	sbci	r27, 0xFF	; 255
    2270:	1d 92       	st	X+, r1
    2272:	1d 92       	st	X+, r1
    2274:	1d 92       	st	X+, r1
    2276:	1c 92       	st	X, r1
    2278:	13 97       	sbiw	r26, 0x03	; 3
    227a:	dc 01       	movw	r26, r24
    227c:	a6 59       	subi	r26, 0x96	; 150
    227e:	bf 4f       	sbci	r27, 0xFF	; 255
    2280:	1d 92       	st	X+, r1
    2282:	1d 92       	st	X+, r1
    2284:	1d 92       	st	X+, r1
    2286:	1c 92       	st	X, r1
    2288:	13 97       	sbiw	r26, 0x03	; 3
    228a:	dc 01       	movw	r26, r24
    228c:	a2 59       	subi	r26, 0x92	; 146
    228e:	bf 4f       	sbci	r27, 0xFF	; 255
    2290:	1d 92       	st	X+, r1
    2292:	1d 92       	st	X+, r1
    2294:	1d 92       	st	X+, r1
    2296:	1c 92       	st	X, r1
    2298:	13 97       	sbiw	r26, 0x03	; 3
    229a:	dc 01       	movw	r26, r24
    229c:	ae 58       	subi	r26, 0x8E	; 142
    229e:	bf 4f       	sbci	r27, 0xFF	; 255
    22a0:	1d 92       	st	X+, r1
    22a2:	1d 92       	st	X+, r1
    22a4:	1d 92       	st	X+, r1
    22a6:	1c 92       	st	X, r1
    22a8:	13 97       	sbiw	r26, 0x03	; 3
    22aa:	dc 01       	movw	r26, r24
    22ac:	aa 58       	subi	r26, 0x8A	; 138
    22ae:	bf 4f       	sbci	r27, 0xFF	; 255
    22b0:	1d 92       	st	X+, r1
    22b2:	1d 92       	st	X+, r1
    22b4:	1d 92       	st	X+, r1
    22b6:	1c 92       	st	X, r1
    22b8:	13 97       	sbiw	r26, 0x03	; 3
    22ba:	dc 01       	movw	r26, r24
    22bc:	a6 58       	subi	r26, 0x86	; 134
    22be:	bf 4f       	sbci	r27, 0xFF	; 255
    22c0:	1d 92       	st	X+, r1
    22c2:	1d 92       	st	X+, r1
    22c4:	1d 92       	st	X+, r1
    22c6:	1c 92       	st	X, r1
    22c8:	13 97       	sbiw	r26, 0x03	; 3
    22ca:	dc 01       	movw	r26, r24
    22cc:	a2 58       	subi	r26, 0x82	; 130
    22ce:	bf 4f       	sbci	r27, 0xFF	; 255
    22d0:	1d 92       	st	X+, r1
    22d2:	1d 92       	st	X+, r1
    22d4:	1d 92       	st	X+, r1
    22d6:	1c 92       	st	X, r1
    22d8:	13 97       	sbiw	r26, 0x03	; 3
    22da:	dc 01       	movw	r26, r24
    22dc:	ae 57       	subi	r26, 0x7E	; 126
    22de:	bf 4f       	sbci	r27, 0xFF	; 255
    22e0:	1d 92       	st	X+, r1
    22e2:	1d 92       	st	X+, r1
    22e4:	1d 92       	st	X+, r1
    22e6:	1c 92       	st	X, r1
    22e8:	13 97       	sbiw	r26, 0x03	; 3
    22ea:	dc 01       	movw	r26, r24
    22ec:	aa 57       	subi	r26, 0x7A	; 122
    22ee:	bf 4f       	sbci	r27, 0xFF	; 255
    22f0:	1d 92       	st	X+, r1
    22f2:	1d 92       	st	X+, r1
    22f4:	1d 92       	st	X+, r1
    22f6:	1c 92       	st	X, r1
    22f8:	13 97       	sbiw	r26, 0x03	; 3
    22fa:	dc 01       	movw	r26, r24
    22fc:	a6 57       	subi	r26, 0x76	; 118
    22fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2300:	1d 92       	st	X+, r1
    2302:	1d 92       	st	X+, r1
    2304:	1d 92       	st	X+, r1
    2306:	1c 92       	st	X, r1
    2308:	13 97       	sbiw	r26, 0x03	; 3
    230a:	dc 01       	movw	r26, r24
    230c:	a2 57       	subi	r26, 0x72	; 114
    230e:	bf 4f       	sbci	r27, 0xFF	; 255
    2310:	1d 92       	st	X+, r1
    2312:	1d 92       	st	X+, r1
    2314:	1d 92       	st	X+, r1
    2316:	1c 92       	st	X, r1
    2318:	13 97       	sbiw	r26, 0x03	; 3
    231a:	dc 01       	movw	r26, r24
    231c:	ae 56       	subi	r26, 0x6E	; 110
    231e:	bf 4f       	sbci	r27, 0xFF	; 255
    2320:	1d 92       	st	X+, r1
    2322:	1d 92       	st	X+, r1
    2324:	1d 92       	st	X+, r1
    2326:	1c 92       	st	X, r1
    2328:	13 97       	sbiw	r26, 0x03	; 3
    232a:	dc 01       	movw	r26, r24
    232c:	aa 56       	subi	r26, 0x6A	; 106
    232e:	bf 4f       	sbci	r27, 0xFF	; 255
    2330:	1d 92       	st	X+, r1
    2332:	1d 92       	st	X+, r1
    2334:	1d 92       	st	X+, r1
    2336:	1c 92       	st	X, r1
    2338:	13 97       	sbiw	r26, 0x03	; 3
    233a:	dc 01       	movw	r26, r24
    233c:	a6 56       	subi	r26, 0x66	; 102
    233e:	bf 4f       	sbci	r27, 0xFF	; 255
    2340:	1d 92       	st	X+, r1
    2342:	1d 92       	st	X+, r1
    2344:	1d 92       	st	X+, r1
    2346:	1c 92       	st	X, r1
    2348:	13 97       	sbiw	r26, 0x03	; 3
    234a:	dc 01       	movw	r26, r24
    234c:	a2 56       	subi	r26, 0x62	; 98
    234e:	bf 4f       	sbci	r27, 0xFF	; 255
    2350:	1d 92       	st	X+, r1
    2352:	1d 92       	st	X+, r1
    2354:	1d 92       	st	X+, r1
    2356:	1c 92       	st	X, r1
    2358:	13 97       	sbiw	r26, 0x03	; 3
    235a:	dc 01       	movw	r26, r24
    235c:	ae 55       	subi	r26, 0x5E	; 94
    235e:	bf 4f       	sbci	r27, 0xFF	; 255
    2360:	1d 92       	st	X+, r1
    2362:	1d 92       	st	X+, r1
    2364:	1d 92       	st	X+, r1
    2366:	1c 92       	st	X, r1
    2368:	13 97       	sbiw	r26, 0x03	; 3
    236a:	dc 01       	movw	r26, r24
    236c:	aa 55       	subi	r26, 0x5A	; 90
    236e:	bf 4f       	sbci	r27, 0xFF	; 255
    2370:	1d 92       	st	X+, r1
    2372:	1d 92       	st	X+, r1
    2374:	1d 92       	st	X+, r1
    2376:	1c 92       	st	X, r1
    2378:	13 97       	sbiw	r26, 0x03	; 3
    237a:	dc 01       	movw	r26, r24
    237c:	a6 55       	subi	r26, 0x56	; 86
    237e:	bf 4f       	sbci	r27, 0xFF	; 255
    2380:	1d 92       	st	X+, r1
    2382:	1d 92       	st	X+, r1
    2384:	1d 92       	st	X+, r1
    2386:	1c 92       	st	X, r1
    2388:	13 97       	sbiw	r26, 0x03	; 3
    238a:	dc 01       	movw	r26, r24
    238c:	a2 55       	subi	r26, 0x52	; 82
    238e:	bf 4f       	sbci	r27, 0xFF	; 255
    2390:	1d 92       	st	X+, r1
    2392:	1d 92       	st	X+, r1
    2394:	1d 92       	st	X+, r1
    2396:	1c 92       	st	X, r1
    2398:	13 97       	sbiw	r26, 0x03	; 3
    239a:	dc 01       	movw	r26, r24
    239c:	ae 54       	subi	r26, 0x4E	; 78
    239e:	bf 4f       	sbci	r27, 0xFF	; 255
    23a0:	1d 92       	st	X+, r1
    23a2:	1d 92       	st	X+, r1
    23a4:	1d 92       	st	X+, r1
    23a6:	1c 92       	st	X, r1
    23a8:	13 97       	sbiw	r26, 0x03	; 3
    23aa:	dc 01       	movw	r26, r24
    23ac:	aa 54       	subi	r26, 0x4A	; 74
    23ae:	bf 4f       	sbci	r27, 0xFF	; 255
    23b0:	1d 92       	st	X+, r1
    23b2:	1d 92       	st	X+, r1
    23b4:	1d 92       	st	X+, r1
    23b6:	1c 92       	st	X, r1
    23b8:	13 97       	sbiw	r26, 0x03	; 3
    23ba:	dc 01       	movw	r26, r24
    23bc:	a6 54       	subi	r26, 0x46	; 70
    23be:	bf 4f       	sbci	r27, 0xFF	; 255
    23c0:	1d 92       	st	X+, r1
    23c2:	1d 92       	st	X+, r1
    23c4:	1d 92       	st	X+, r1
    23c6:	1c 92       	st	X, r1
    23c8:	13 97       	sbiw	r26, 0x03	; 3
    23ca:	dc 01       	movw	r26, r24
    23cc:	a2 54       	subi	r26, 0x42	; 66
    23ce:	bf 4f       	sbci	r27, 0xFF	; 255
    23d0:	1d 92       	st	X+, r1
    23d2:	1d 92       	st	X+, r1
    23d4:	1d 92       	st	X+, r1
    23d6:	1c 92       	st	X, r1
    23d8:	13 97       	sbiw	r26, 0x03	; 3
    23da:	dc 01       	movw	r26, r24
    23dc:	ae 53       	subi	r26, 0x3E	; 62
    23de:	bf 4f       	sbci	r27, 0xFF	; 255
    23e0:	1d 92       	st	X+, r1
    23e2:	1d 92       	st	X+, r1
    23e4:	1d 92       	st	X+, r1
    23e6:	1c 92       	st	X, r1
    23e8:	13 97       	sbiw	r26, 0x03	; 3
    23ea:	dc 01       	movw	r26, r24
    23ec:	aa 53       	subi	r26, 0x3A	; 58
    23ee:	bf 4f       	sbci	r27, 0xFF	; 255
    23f0:	1d 92       	st	X+, r1
    23f2:	1d 92       	st	X+, r1
    23f4:	1d 92       	st	X+, r1
    23f6:	1c 92       	st	X, r1
    23f8:	13 97       	sbiw	r26, 0x03	; 3
    23fa:	dc 01       	movw	r26, r24
    23fc:	a2 53       	subi	r26, 0x32	; 50
    23fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2400:	1d 92       	st	X+, r1
    2402:	1d 92       	st	X+, r1
    2404:	1d 92       	st	X+, r1
    2406:	1c 92       	st	X, r1
    2408:	13 97       	sbiw	r26, 0x03	; 3
    240a:	dc 01       	movw	r26, r24
    240c:	ae 52       	subi	r26, 0x2E	; 46
    240e:	bf 4f       	sbci	r27, 0xFF	; 255
    2410:	1d 92       	st	X+, r1
    2412:	1d 92       	st	X+, r1
    2414:	1d 92       	st	X+, r1
    2416:	1c 92       	st	X, r1
    2418:	13 97       	sbiw	r26, 0x03	; 3
    241a:	dc 01       	movw	r26, r24
    241c:	aa 52       	subi	r26, 0x2A	; 42
    241e:	bf 4f       	sbci	r27, 0xFF	; 255
    2420:	1d 92       	st	X+, r1
    2422:	1d 92       	st	X+, r1
    2424:	1d 92       	st	X+, r1
    2426:	1c 92       	st	X, r1
    2428:	13 97       	sbiw	r26, 0x03	; 3
    242a:	dc 01       	movw	r26, r24
    242c:	a6 52       	subi	r26, 0x26	; 38
    242e:	bf 4f       	sbci	r27, 0xFF	; 255
    2430:	1d 92       	st	X+, r1
    2432:	1d 92       	st	X+, r1
    2434:	1d 92       	st	X+, r1
    2436:	1c 92       	st	X, r1
    2438:	13 97       	sbiw	r26, 0x03	; 3
    243a:	dc 01       	movw	r26, r24
    243c:	a2 52       	subi	r26, 0x22	; 34
    243e:	bf 4f       	sbci	r27, 0xFF	; 255
    2440:	1d 92       	st	X+, r1
    2442:	1d 92       	st	X+, r1
    2444:	1d 92       	st	X+, r1
    2446:	1c 92       	st	X, r1
    2448:	13 97       	sbiw	r26, 0x03	; 3
    244a:	dc 01       	movw	r26, r24
    244c:	ae 51       	subi	r26, 0x1E	; 30
    244e:	bf 4f       	sbci	r27, 0xFF	; 255
    2450:	1d 92       	st	X+, r1
    2452:	1d 92       	st	X+, r1
    2454:	1d 92       	st	X+, r1
    2456:	1c 92       	st	X, r1
    2458:	13 97       	sbiw	r26, 0x03	; 3
    245a:	dc 01       	movw	r26, r24
    245c:	aa 51       	subi	r26, 0x1A	; 26
    245e:	bf 4f       	sbci	r27, 0xFF	; 255
    2460:	1d 92       	st	X+, r1
    2462:	1d 92       	st	X+, r1
    2464:	1d 92       	st	X+, r1
    2466:	1c 92       	st	X, r1
    2468:	13 97       	sbiw	r26, 0x03	; 3
    246a:	dc 01       	movw	r26, r24
    246c:	a6 51       	subi	r26, 0x16	; 22
    246e:	bf 4f       	sbci	r27, 0xFF	; 255
    2470:	1d 92       	st	X+, r1
    2472:	1d 92       	st	X+, r1
    2474:	1d 92       	st	X+, r1
    2476:	1c 92       	st	X, r1
    2478:	13 97       	sbiw	r26, 0x03	; 3
    247a:	dc 01       	movw	r26, r24
    247c:	a2 51       	subi	r26, 0x12	; 18
    247e:	bf 4f       	sbci	r27, 0xFF	; 255
    2480:	1d 92       	st	X+, r1
    2482:	1d 92       	st	X+, r1
    2484:	1d 92       	st	X+, r1
    2486:	1c 92       	st	X, r1
    2488:	13 97       	sbiw	r26, 0x03	; 3
    248a:	dc 01       	movw	r26, r24
    248c:	ae 50       	subi	r26, 0x0E	; 14
    248e:	bf 4f       	sbci	r27, 0xFF	; 255
    2490:	1d 92       	st	X+, r1
    2492:	1d 92       	st	X+, r1
    2494:	1d 92       	st	X+, r1
    2496:	1c 92       	st	X, r1
    2498:	13 97       	sbiw	r26, 0x03	; 3
    249a:	dc 01       	movw	r26, r24
    249c:	aa 50       	subi	r26, 0x0A	; 10
    249e:	bf 4f       	sbci	r27, 0xFF	; 255
    24a0:	1d 92       	st	X+, r1
    24a2:	1d 92       	st	X+, r1
    24a4:	1d 92       	st	X+, r1
    24a6:	1c 92       	st	X, r1
    24a8:	13 97       	sbiw	r26, 0x03	; 3
    24aa:	dc 01       	movw	r26, r24
    24ac:	a6 50       	subi	r26, 0x06	; 6
    24ae:	bf 4f       	sbci	r27, 0xFF	; 255
    24b0:	1d 92       	st	X+, r1
    24b2:	1d 92       	st	X+, r1
    24b4:	1d 92       	st	X+, r1
    24b6:	1c 92       	st	X, r1
    24b8:	13 97       	sbiw	r26, 0x03	; 3
    24ba:	dc 01       	movw	r26, r24
    24bc:	a2 50       	subi	r26, 0x02	; 2
    24be:	bf 4f       	sbci	r27, 0xFF	; 255
    24c0:	1d 92       	st	X+, r1
    24c2:	1d 92       	st	X+, r1
    24c4:	1d 92       	st	X+, r1
    24c6:	1c 92       	st	X, r1
    24c8:	13 97       	sbiw	r26, 0x03	; 3
    24ca:	dc 01       	movw	r26, r24
    24cc:	ae 5f       	subi	r26, 0xFE	; 254
    24ce:	be 4f       	sbci	r27, 0xFE	; 254
    24d0:	1d 92       	st	X+, r1
    24d2:	1d 92       	st	X+, r1
    24d4:	1d 92       	st	X+, r1
    24d6:	1c 92       	st	X, r1
    24d8:	13 97       	sbiw	r26, 0x03	; 3
    24da:	dc 01       	movw	r26, r24
    24dc:	aa 5f       	subi	r26, 0xFA	; 250
    24de:	be 4f       	sbci	r27, 0xFE	; 254
    24e0:	1d 92       	st	X+, r1
    24e2:	1d 92       	st	X+, r1
    24e4:	1d 92       	st	X+, r1
    24e6:	1c 92       	st	X, r1
    24e8:	13 97       	sbiw	r26, 0x03	; 3
    24ea:	dc 01       	movw	r26, r24
    24ec:	a6 5f       	subi	r26, 0xF6	; 246
    24ee:	be 4f       	sbci	r27, 0xFE	; 254
    24f0:	1d 92       	st	X+, r1
    24f2:	1d 92       	st	X+, r1
    24f4:	1d 92       	st	X+, r1
    24f6:	1c 92       	st	X, r1
    24f8:	13 97       	sbiw	r26, 0x03	; 3
    24fa:	dc 01       	movw	r26, r24
    24fc:	a2 5f       	subi	r26, 0xF2	; 242
    24fe:	be 4f       	sbci	r27, 0xFE	; 254
    2500:	1d 92       	st	X+, r1
    2502:	1d 92       	st	X+, r1
    2504:	1d 92       	st	X+, r1
    2506:	1c 92       	st	X, r1
    2508:	13 97       	sbiw	r26, 0x03	; 3
    250a:	dc 01       	movw	r26, r24
    250c:	ae 5e       	subi	r26, 0xEE	; 238
    250e:	be 4f       	sbci	r27, 0xFE	; 254
    2510:	1d 92       	st	X+, r1
    2512:	1d 92       	st	X+, r1
    2514:	1d 92       	st	X+, r1
    2516:	1c 92       	st	X, r1
    2518:	13 97       	sbiw	r26, 0x03	; 3
    251a:	dc 01       	movw	r26, r24
    251c:	aa 5e       	subi	r26, 0xEA	; 234
    251e:	be 4f       	sbci	r27, 0xFE	; 254
    2520:	1d 92       	st	X+, r1
    2522:	1d 92       	st	X+, r1
    2524:	1d 92       	st	X+, r1
    2526:	1c 92       	st	X, r1
    2528:	13 97       	sbiw	r26, 0x03	; 3
    252a:	dc 01       	movw	r26, r24
    252c:	a6 5e       	subi	r26, 0xE6	; 230
    252e:	be 4f       	sbci	r27, 0xFE	; 254
    2530:	1d 92       	st	X+, r1
    2532:	1d 92       	st	X+, r1
    2534:	1d 92       	st	X+, r1
    2536:	1c 92       	st	X, r1
    2538:	13 97       	sbiw	r26, 0x03	; 3
    253a:	dc 01       	movw	r26, r24
    253c:	ae 5b       	subi	r26, 0xBE	; 190
    253e:	be 4f       	sbci	r27, 0xFE	; 254
    2540:	1c 92       	st	X, r1
			{
				EcefToLocalNEDRotationMatrix[0][0] = 0;
    2542:	dc 01       	movw	r26, r24
    2544:	a2 5e       	subi	r26, 0xE2	; 226
    2546:	be 4f       	sbci	r27, 0xFE	; 254
    2548:	1d 92       	st	X+, r1
    254a:	1d 92       	st	X+, r1
    254c:	1d 92       	st	X+, r1
    254e:	1c 92       	st	X, r1
    2550:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][1] = 0;
    2552:	dc 01       	movw	r26, r24
    2554:	ae 5d       	subi	r26, 0xDE	; 222
    2556:	be 4f       	sbci	r27, 0xFE	; 254
    2558:	1d 92       	st	X+, r1
    255a:	1d 92       	st	X+, r1
    255c:	1d 92       	st	X+, r1
    255e:	1c 92       	st	X, r1
    2560:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[0][2] = 0;
    2562:	dc 01       	movw	r26, r24
    2564:	aa 5d       	subi	r26, 0xDA	; 218
    2566:	be 4f       	sbci	r27, 0xFE	; 254
    2568:	1d 92       	st	X+, r1
    256a:	1d 92       	st	X+, r1
    256c:	1d 92       	st	X+, r1
    256e:	1c 92       	st	X, r1
    2570:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][0] = 0;
    2572:	dc 01       	movw	r26, r24
    2574:	a6 5d       	subi	r26, 0xD6	; 214
    2576:	be 4f       	sbci	r27, 0xFE	; 254
    2578:	1d 92       	st	X+, r1
    257a:	1d 92       	st	X+, r1
    257c:	1d 92       	st	X+, r1
    257e:	1c 92       	st	X, r1
    2580:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][1] = 0;
    2582:	dc 01       	movw	r26, r24
    2584:	a2 5d       	subi	r26, 0xD2	; 210
    2586:	be 4f       	sbci	r27, 0xFE	; 254
    2588:	1d 92       	st	X+, r1
    258a:	1d 92       	st	X+, r1
    258c:	1d 92       	st	X+, r1
    258e:	1c 92       	st	X, r1
    2590:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[1][2] = 0;
    2592:	dc 01       	movw	r26, r24
    2594:	ae 5c       	subi	r26, 0xCE	; 206
    2596:	be 4f       	sbci	r27, 0xFE	; 254
    2598:	1d 92       	st	X+, r1
    259a:	1d 92       	st	X+, r1
    259c:	1d 92       	st	X+, r1
    259e:	1c 92       	st	X, r1
    25a0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
    25a2:	dc 01       	movw	r26, r24
    25a4:	aa 5c       	subi	r26, 0xCA	; 202
    25a6:	be 4f       	sbci	r27, 0xFE	; 254
    25a8:	1d 92       	st	X+, r1
    25aa:	1d 92       	st	X+, r1
    25ac:	1d 92       	st	X+, r1
    25ae:	1c 92       	st	X, r1
    25b0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][1] = 0;
    25b2:	dc 01       	movw	r26, r24
    25b4:	a6 5c       	subi	r26, 0xC6	; 198
    25b6:	be 4f       	sbci	r27, 0xFE	; 254
    25b8:	1d 92       	st	X+, r1
    25ba:	1d 92       	st	X+, r1
    25bc:	1d 92       	st	X+, r1
    25be:	1c 92       	st	X, r1
    25c0:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
    25c2:	e2 5c       	subi	r30, 0xC2	; 194
    25c4:	fe 4f       	sbci	r31, 0xFE	; 254
    25c6:	10 82       	st	Z, r1
    25c8:	11 82       	std	Z+1, r1	; 0x01
    25ca:	12 82       	std	Z+2, r1	; 0x02
    25cc:	13 82       	std	Z+3, r1	; 0x03
    25ce:	08 95       	ret

000025d0 <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>:
using namespace helicopter::util;
using namespace helicopter::sensors;
using namespace helicopter::navigation;

void setupDefaultsandReferencePosition(SystemModel *model, PIDController *pidController)
{	
    25d0:	0f 93       	push	r16
    25d2:	1f 93       	push	r17
    25d4:	cf 93       	push	r28
    25d6:	df 93       	push	r29
    25d8:	dc 01       	movw	r26, r24
    25da:	fb 01       	movw	r30, r22
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    25dc:	16 96       	adiw	r26, 0x06	; 6
    25de:	1d 92       	st	X+, r1
    25e0:	1d 92       	st	X+, r1
    25e2:	1d 92       	st	X+, r1
    25e4:	1c 92       	st	X, r1
    25e6:	19 97       	sbiw	r26, 0x09	; 9
				
			float YawControlBeforeServoLimitsAdjustment() const {return yawControlBeforeServoLimitsAdjustment;}
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
    25e8:	52 96       	adiw	r26, 0x12	; 18
    25ea:	1d 92       	st	X+, r1
    25ec:	1d 92       	st	X+, r1
    25ee:	1d 92       	st	X+, r1
    25f0:	1c 92       	st	X, r1
    25f2:	55 97       	sbiw	r26, 0x15	; 21
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    25f4:	ec 01       	movw	r28, r24
    25f6:	ce 57       	subi	r28, 0x7E	; 126
    25f8:	df 4f       	sbci	r29, 0xFF	; 255
    25fa:	4a e9       	ldi	r20, 0x9A	; 154
    25fc:	59 e9       	ldi	r21, 0x99	; 153
    25fe:	64 e6       	ldi	r22, 0x64	; 100
    2600:	74 ec       	ldi	r23, 0xC4	; 196
    2602:	48 83       	st	Y, r20
    2604:	59 83       	std	Y+1, r21	; 0x01
    2606:	6a 83       	std	Y+2, r22	; 0x02
    2608:	7b 83       	std	Y+3, r23	; 0x03

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}
    260a:	ec 01       	movw	r28, r24
    260c:	ce 56       	subi	r28, 0x6E	; 110
    260e:	df 4f       	sbci	r29, 0xFF	; 255
    2610:	18 82       	st	Y, r1
    2612:	19 82       	std	Y+1, r1	; 0x01
    2614:	1a 82       	std	Y+2, r1	; 0x02
    2616:	1b 82       	std	Y+3, r1	; 0x03
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    2618:	96 96       	adiw	r26, 0x26	; 38
    261a:	1d 92       	st	X+, r1
    261c:	1d 92       	st	X+, r1
    261e:	1d 92       	st	X+, r1
    2620:	1c 92       	st	X, r1
    2622:	99 97       	sbiw	r26, 0x29	; 41
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
    2624:	d6 96       	adiw	r26, 0x36	; 54
    2626:	1d 92       	st	X+, r1
    2628:	1d 92       	st	X+, r1
    262a:	1d 92       	st	X+, r1
    262c:	1c 92       	st	X, r1
    262e:	d9 97       	sbiw	r26, 0x39	; 57

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    2630:	ec 01       	movw	r28, r24
    2632:	ce 5a       	subi	r28, 0xAE	; 174
    2634:	df 4f       	sbci	r29, 0xFF	; 255
    2636:	18 82       	st	Y, r1
    2638:	19 82       	std	Y+1, r1	; 0x01
    263a:	1a 82       	std	Y+2, r1	; 0x02
    263c:	1b 82       	std	Y+3, r1	; 0x03

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}
    263e:	ae 59       	subi	r26, 0x9E	; 158
    2640:	bf 4f       	sbci	r27, 0xFF	; 255
    2642:	1d 92       	st	X+, r1
    2644:	1d 92       	st	X+, r1
    2646:	1d 92       	st	X+, r1
    2648:	1c 92       	st	X, r1
    264a:	13 97       	sbiw	r26, 0x03	; 3
					xDerivativeGain = val;
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    264c:	82 e7       	ldi	r24, 0x72	; 114
    264e:	93 e3       	ldi	r25, 0x33	; 51
    2650:	ac e5       	ldi	r26, 0x5C	; 92
    2652:	b9 e3       	ldi	r27, 0x39	; 57
    2654:	82 8f       	std	Z+26, r24	; 0x1a
    2656:	93 8f       	std	Z+27, r25	; 0x1b
    2658:	a4 8f       	std	Z+28, r26	; 0x1c
    265a:	b5 8f       	std	Z+29, r27	; 0x1d
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    265c:	12 8a       	std	Z+18, r1	; 0x12
    265e:	13 8a       	std	Z+19, r1	; 0x13
    2660:	14 8a       	std	Z+20, r1	; 0x14
    2662:	15 8a       	std	Z+21, r1	; 0x15
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    2664:	85 e4       	ldi	r24, 0x45	; 69
    2666:	95 ef       	ldi	r25, 0xF5	; 245
    2668:	a6 ed       	ldi	r26, 0xD6	; 214
    266a:	b9 e3       	ldi	r27, 0x39	; 57
    266c:	86 8b       	std	Z+22, r24	; 0x16
    266e:	97 8b       	std	Z+23, r25	; 0x17
    2670:	a0 8f       	std	Z+24, r26	; 0x18
    2672:	b1 8f       	std	Z+25, r27	; 0x19
					xProportionalGain = val;
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    2674:	16 8e       	std	Z+30, r1	; 0x1e
    2676:	17 8e       	std	Z+31, r1	; 0x1f
    2678:	10 a2       	std	Z+32, r1	; 0x20
    267a:	11 a2       	std	Z+33, r1	; 0x21
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    267c:	80 e0       	ldi	r24, 0x00	; 0
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	a0 e8       	ldi	r26, 0x80	; 128
    2682:	bf e3       	ldi	r27, 0x3F	; 63
    2684:	82 a3       	std	Z+34, r24	; 0x22
    2686:	93 a3       	std	Z+35, r25	; 0x23
    2688:	a4 a3       	std	Z+36, r26	; 0x24
    268a:	b5 a3       	std	Z+37, r27	; 0x25
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    268c:	16 a2       	std	Z+38, r1	; 0x26
    268e:	17 a2       	std	Z+39, r1	; 0x27
    2690:	10 a6       	std	Z+40, r1	; 0x28
    2692:	11 a6       	std	Z+41, r1	; 0x29
					yDerivativeGain = val;
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    2694:	4f e6       	ldi	r20, 0x6F	; 111
    2696:	52 e1       	ldi	r21, 0x12	; 18
    2698:	63 e8       	ldi	r22, 0x83	; 131
    269a:	79 e3       	ldi	r23, 0x39	; 57
    269c:	42 ab       	std	Z+50, r20	; 0x32
    269e:	53 ab       	std	Z+51, r21	; 0x33
    26a0:	64 ab       	std	Z+52, r22	; 0x34
    26a2:	75 ab       	std	Z+53, r23	; 0x35
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    26a4:	12 a6       	std	Z+42, r1	; 0x2a
    26a6:	13 a6       	std	Z+43, r1	; 0x2b
    26a8:	14 a6       	std	Z+44, r1	; 0x2c
    26aa:	15 a6       	std	Z+45, r1	; 0x2d
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    26ac:	4a e8       	ldi	r20, 0x8A	; 138
    26ae:	55 e5       	ldi	r21, 0x55	; 85
    26b0:	63 e0       	ldi	r22, 0x03	; 3
    26b2:	7a e3       	ldi	r23, 0x3A	; 58
    26b4:	46 a7       	std	Z+46, r20	; 0x2e
    26b6:	57 a7       	std	Z+47, r21	; 0x2f
    26b8:	60 ab       	std	Z+48, r22	; 0x30
    26ba:	71 ab       	std	Z+49, r23	; 0x31
					yProportionalGain = val;
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    26bc:	16 aa       	std	Z+54, r1	; 0x36
    26be:	17 aa       	std	Z+55, r1	; 0x37
    26c0:	10 ae       	std	Z+56, r1	; 0x38
    26c2:	11 ae       	std	Z+57, r1	; 0x39
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    26c4:	82 af       	std	Z+58, r24	; 0x3a
    26c6:	93 af       	std	Z+59, r25	; 0x3b
    26c8:	a4 af       	std	Z+60, r26	; 0x3c
    26ca:	b5 af       	std	Z+61, r27	; 0x3d
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    26cc:	ef 01       	movw	r28, r30
    26ce:	ee 96       	adiw	r28, 0x3e	; 62
    26d0:	18 82       	st	Y, r1
    26d2:	19 82       	std	Y+1, r1	; 0x01
    26d4:	1a 82       	std	Y+2, r1	; 0x02
    26d6:	1b 82       	std	Y+3, r1	; 0x03
					zDerivativeGain = val;
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    26d8:	ef 01       	movw	r28, r30
    26da:	c6 5b       	subi	r28, 0xB6	; 182
    26dc:	df 4f       	sbci	r29, 0xFF	; 255
    26de:	4f e6       	ldi	r20, 0x6F	; 111
    26e0:	52 e1       	ldi	r21, 0x12	; 18
    26e2:	63 e0       	ldi	r22, 0x03	; 3
    26e4:	7b e3       	ldi	r23, 0x3B	; 59
    26e6:	48 83       	st	Y, r20
    26e8:	59 83       	std	Y+1, r21	; 0x01
    26ea:	6a 83       	std	Y+2, r22	; 0x02
    26ec:	7b 83       	std	Y+3, r23	; 0x03
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    26ee:	ef 01       	movw	r28, r30
    26f0:	ce 5b       	subi	r28, 0xBE	; 190
    26f2:	df 4f       	sbci	r29, 0xFF	; 255
    26f4:	18 82       	st	Y, r1
    26f6:	19 82       	std	Y+1, r1	; 0x01
    26f8:	1a 82       	std	Y+2, r1	; 0x02
    26fa:	1b 82       	std	Y+3, r1	; 0x03
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    26fc:	ef 01       	movw	r28, r30
    26fe:	ca 5b       	subi	r28, 0xBA	; 186
    2700:	df 4f       	sbci	r29, 0xFF	; 255
    2702:	46 ea       	ldi	r20, 0xA6	; 166
    2704:	5b e9       	ldi	r21, 0x9B	; 155
    2706:	64 ec       	ldi	r22, 0xC4	; 196
    2708:	7a e3       	ldi	r23, 0x3A	; 58
    270a:	48 83       	st	Y, r20
    270c:	59 83       	std	Y+1, r21	; 0x01
    270e:	6a 83       	std	Y+2, r22	; 0x02
    2710:	7b 83       	std	Y+3, r23	; 0x03
					zProportionalGain = val;
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    2712:	ef 01       	movw	r28, r30
    2714:	c2 5b       	subi	r28, 0xB2	; 178
    2716:	df 4f       	sbci	r29, 0xFF	; 255
    2718:	18 82       	st	Y, r1
    271a:	19 82       	std	Y+1, r1	; 0x01
    271c:	1a 82       	std	Y+2, r1	; 0x02
    271e:	1b 82       	std	Y+3, r1	; 0x03
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    2720:	4a e9       	ldi	r20, 0x9A	; 154
    2722:	59 e9       	ldi	r21, 0x99	; 153
    2724:	69 e9       	ldi	r22, 0x99	; 153
    2726:	7f e3       	ldi	r23, 0x3F	; 63
    2728:	42 87       	std	Z+10, r20	; 0x0a
    272a:	53 87       	std	Z+11, r21	; 0x0b
    272c:	64 87       	std	Z+12, r22	; 0x0c
    272e:	75 87       	std	Z+13, r23	; 0x0d
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    2730:	12 82       	std	Z+2, r1	; 0x02
    2732:	13 82       	std	Z+3, r1	; 0x03
    2734:	14 82       	std	Z+4, r1	; 0x04
    2736:	15 82       	std	Z+5, r1	; 0x05
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    2738:	4d ec       	ldi	r20, 0xCD	; 205
    273a:	5c ec       	ldi	r21, 0xCC	; 204
    273c:	6c e8       	ldi	r22, 0x8C	; 140
    273e:	7e e3       	ldi	r23, 0x3E	; 62
    2740:	46 83       	std	Z+6, r20	; 0x06
    2742:	57 83       	std	Z+7, r21	; 0x07
    2744:	60 87       	std	Z+8, r22	; 0x08
    2746:	71 87       	std	Z+9, r23	; 0x09
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    2748:	16 86       	std	Z+14, r1	; 0x0e
    274a:	17 86       	std	Z+15, r1	; 0x0f
    274c:	10 8a       	std	Z+16, r1	; 0x10
    274e:	11 8a       	std	Z+17, r1	; 0x11
				 * The number of seconds between pid controller updates. This number
				 * should generally be less than 1. Like .05 for a 20 hz rate.
				 */
				void setIntervalPeriodSecs(float intervalPeriodSecs)
				{
					this->intervalPeriodSecs = intervalPeriodSecs;
    2750:	ef 01       	movw	r28, r30
    2752:	ce 57       	subi	r28, 0x7E	; 126
    2754:	df 4f       	sbci	r29, 0xFF	; 255
    2756:	4d ec       	ldi	r20, 0xCD	; 205
    2758:	5c ec       	ldi	r21, 0xCC	; 204
    275a:	6c e4       	ldi	r22, 0x4C	; 76
    275c:	7d e3       	ldi	r23, 0x3D	; 61
    275e:	48 83       	st	Y, r20
    2760:	59 83       	std	Y+1, r21	; 0x01
    2762:	6a 83       	std	Y+2, r22	; 0x02
    2764:	7b 83       	std	Y+3, r23	; 0x03
				 * This is the maximum possible output value for a control signal.
				 * Generally, this should be set to 1.
				 */
				void setControlMaxValue(float controlMaxValue)
				{
					this->controlMaxValue = controlMaxValue;
    2766:	ef 01       	movw	r28, r30
    2768:	ca 57       	subi	r28, 0x7A	; 122
    276a:	df 4f       	sbci	r29, 0xFF	; 255
    276c:	88 83       	st	Y, r24
    276e:	99 83       	std	Y+1, r25	; 0x01
    2770:	aa 83       	std	Y+2, r26	; 0x02
    2772:	bb 83       	std	Y+3, r27	; 0x03
				 * This is the minimum possible value for a control signal.
				 * Generally, this should be set to -1.
				 */
				void setControlMinValue(float controlMinValue)
				{
					this->controlMinValue = controlMinValue;
    2774:	ef 01       	movw	r28, r30
    2776:	c6 57       	subi	r28, 0x76	; 118
    2778:	df 4f       	sbci	r29, 0xFF	; 255
    277a:	40 e0       	ldi	r20, 0x00	; 0
    277c:	50 e0       	ldi	r21, 0x00	; 0
    277e:	60 e8       	ldi	r22, 0x80	; 128
    2780:	7f eb       	ldi	r23, 0xBF	; 191
    2782:	48 83       	st	Y, r20
    2784:	59 83       	std	Y+1, r21	; 0x01
    2786:	6a 83       	std	Y+2, r22	; 0x02
    2788:	7b 83       	std	Y+3, r23	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no smaller than the controlMinValue (e.g. no less than -1)
				 */
				void setMinYawServoControl(float minYawServoControlValue)
				{
					this->minYawServoControlValue = minYawServoControlValue;
    278a:	ef 01       	movw	r28, r30
    278c:	ce 5a       	subi	r28, 0xAE	; 174
    278e:	df 4f       	sbci	r29, 0xFF	; 255
    2790:	0f e8       	ldi	r16, 0x8F	; 143
    2792:	12 ec       	ldi	r17, 0xC2	; 194
    2794:	25 e7       	ldi	r18, 0x75	; 117
    2796:	3f eb       	ldi	r19, 0xBF	; 191
    2798:	08 83       	st	Y, r16
    279a:	19 83       	std	Y+1, r17	; 0x01
    279c:	2a 83       	std	Y+2, r18	; 0x02
    279e:	3b 83       	std	Y+3, r19	; 0x03
				 * integral anti-windup to determine when the actuators would be saturated.
				 * The value should be no larger than the controlMaxValue (e.g. no greater than 1)
				 */
				void setMaxYawServoControl(float maxYawServoControlValue)
				{
					this->maxYawServoControlValue = maxYawServoControlValue;
    27a0:	ef 01       	movw	r28, r30
    27a2:	ca 5a       	subi	r28, 0xAA	; 170
    27a4:	df 4f       	sbci	r29, 0xFF	; 255
    27a6:	0f e8       	ldi	r16, 0x8F	; 143
    27a8:	12 ec       	ldi	r17, 0xC2	; 194
    27aa:	25 e7       	ldi	r18, 0x75	; 117
    27ac:	3f e3       	ldi	r19, 0x3F	; 63
    27ae:	08 83       	st	Y, r16
    27b0:	19 83       	std	Y+1, r17	; 0x01
    27b2:	2a 83       	std	Y+2, r18	; 0x02
    27b4:	3b 83       	std	Y+3, r19	; 0x03
					minLongitudeServoControlValue = val;
				}
				
				void setMaxLongitudeServoControlValue(float val)
				{
					maxLongitudeServoControlValue = val;
    27b6:	ef 01       	movw	r28, r30
    27b8:	c2 5a       	subi	r28, 0xA2	; 162
    27ba:	df 4f       	sbci	r29, 0xFF	; 255
    27bc:	88 83       	st	Y, r24
    27be:	99 83       	std	Y+1, r25	; 0x01
    27c0:	aa 83       	std	Y+2, r26	; 0x02
    27c2:	bb 83       	std	Y+3, r27	; 0x03
					pitchAngularVelocityGain = val;
				}
				
				void setMinLongitudeServoControlValue(float val)
				{
					minLongitudeServoControlValue = val;
    27c4:	ef 01       	movw	r28, r30
    27c6:	c6 5a       	subi	r28, 0xA6	; 166
    27c8:	df 4f       	sbci	r29, 0xFF	; 255
    27ca:	48 83       	st	Y, r20
    27cc:	59 83       	std	Y+1, r21	; 0x01
    27ce:	6a 83       	std	Y+2, r22	; 0x02
    27d0:	7b 83       	std	Y+3, r23	; 0x03
					minLateralServoControlValue = val;
				}
				
				void setMaxLateralServoControlValue(float val)
				{
					maxLateralServoControlValue = val;
    27d2:	ef 01       	movw	r28, r30
    27d4:	ca 59       	subi	r28, 0x9A	; 154
    27d6:	df 4f       	sbci	r29, 0xFF	; 255
    27d8:	88 83       	st	Y, r24
    27da:	99 83       	std	Y+1, r25	; 0x01
    27dc:	aa 83       	std	Y+2, r26	; 0x02
    27de:	bb 83       	std	Y+3, r27	; 0x03
					rollAngularVelocityGain = val;
				}
				
				void setMinLateralServoControlValue(float val)
				{
					minLateralServoControlValue = val;
    27e0:	df 01       	movw	r26, r30
    27e2:	ae 59       	subi	r26, 0x9E	; 158
    27e4:	bf 4f       	sbci	r27, 0xFF	; 255
    27e6:	4d 93       	st	X+, r20
    27e8:	5d 93       	st	X+, r21
    27ea:	6d 93       	st	X+, r22
    27ec:	7c 93       	st	X, r23
    27ee:	13 97       	sbiw	r26, 0x03	; 3
					minMainRotorServoControlValue = val;
				}
				
				void setMaxMainRotorServoControlValue(float val)
				{
					maxMainRotorServoControlValue = val;
    27f0:	ef 01       	movw	r28, r30
    27f2:	c2 59       	subi	r28, 0x92	; 146
    27f4:	df 4f       	sbci	r29, 0xFF	; 255
    27f6:	80 e0       	ldi	r24, 0x00	; 0
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	a0 e0       	ldi	r26, 0x00	; 0
    27fc:	bf e3       	ldi	r27, 0x3F	; 63
    27fe:	88 83       	st	Y, r24
    2800:	99 83       	std	Y+1, r25	; 0x01
    2802:	aa 83       	std	Y+2, r26	; 0x02
    2804:	bb 83       	std	Y+3, r27	; 0x03
					zAntiWindupGain = val;
				}
				
				void setMinMainRotorServoControlValue(float val)
				{
					minMainRotorServoControlValue = val;
    2806:	df 01       	movw	r26, r30
    2808:	a6 59       	subi	r26, 0x96	; 150
    280a:	bf 4f       	sbci	r27, 0xFF	; 255
    280c:	1d 92       	st	X+, r1
    280e:	1d 92       	st	X+, r1
    2810:	1d 92       	st	X+, r1
    2812:	1c 92       	st	X, r1
    2814:	13 97       	sbiw	r26, 0x03	; 3
				}


				void setMaxRollSetpointRads(float val)
				{
					maxRollSetpointRads = val;
    2816:	ef 01       	movw	r28, r30
    2818:	c2 58       	subi	r28, 0x82	; 130
    281a:	df 4f       	sbci	r29, 0xFF	; 255
    281c:	82 ec       	ldi	r24, 0xC2	; 194
    281e:	98 eb       	ldi	r25, 0xB8	; 184
    2820:	a2 eb       	ldi	r26, 0xB2	; 178
    2822:	bd e3       	ldi	r27, 0x3D	; 61
    2824:	88 83       	st	Y, r24
    2826:	99 83       	std	Y+1, r25	; 0x01
    2828:	aa 83       	std	Y+2, r26	; 0x02
    282a:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinRollSetpointRads(float val)
				{
					minRollSetpointRads = val;
    282c:	ef 01       	movw	r28, r30
    282e:	c6 58       	subi	r28, 0x86	; 134
    2830:	df 4f       	sbci	r29, 0xFF	; 255
    2832:	82 ec       	ldi	r24, 0xC2	; 194
    2834:	98 eb       	ldi	r25, 0xB8	; 184
    2836:	a2 eb       	ldi	r26, 0xB2	; 178
    2838:	bd eb       	ldi	r27, 0xBD	; 189
    283a:	88 83       	st	Y, r24
    283c:	99 83       	std	Y+1, r25	; 0x01
    283e:	aa 83       	std	Y+2, r26	; 0x02
    2840:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMaxPitchSetpointRads(float val)
				{
					maxPitchSetpointRads = val;
    2842:	ef 01       	movw	r28, r30
    2844:	ca 58       	subi	r28, 0x8A	; 138
    2846:	df 4f       	sbci	r29, 0xFF	; 255
    2848:	86 e9       	ldi	r24, 0x96	; 150
    284a:	96 e5       	ldi	r25, 0x56	; 86
    284c:	a8 e6       	ldi	r26, 0x68	; 104
    284e:	be e3       	ldi	r27, 0x3E	; 62
    2850:	88 83       	st	Y, r24
    2852:	99 83       	std	Y+1, r25	; 0x01
    2854:	aa 83       	std	Y+2, r26	; 0x02
    2856:	bb 83       	std	Y+3, r27	; 0x03
				}
				
				void setMinPitchSetpointRads(float val)
				{	
					minPitchSetpointRads = val;
    2858:	ee 58       	subi	r30, 0x8E	; 142
    285a:	ff 4f       	sbci	r31, 0xFF	; 255
    285c:	86 e9       	ldi	r24, 0x96	; 150
    285e:	96 e5       	ldi	r25, 0x56	; 86
    2860:	a8 e6       	ldi	r26, 0x68	; 104
    2862:	be eb       	ldi	r27, 0xBE	; 190
    2864:	80 83       	st	Z, r24
    2866:	91 83       	std	Z+1, r25	; 0x01
    2868:	a2 83       	std	Z+2, r26	; 0x02
    286a:	b3 83       	std	Z+3, r27	; 0x03
	pidController->setMaxPitchSetpointRads(0.226892803);
	pidController->setMinPitchSetpointRads(-0.226892803);	
	
	
	
}
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	1f 91       	pop	r17
    2872:	0f 91       	pop	r16
    2874:	08 95       	ret

00002876 <main>:

//SystemModel *publicModel = NULL;
//static SystemModel *publicModel = new SystemModel();

int main(void)
{	
    2876:	cf 93       	push	r28
    2878:	df 93       	push	r29
    287a:	cd b7       	in	r28, 0x3d	; 61
    287c:	de b7       	in	r29, 0x3e	; 62
    287e:	a8 97       	sbiw	r28, 0x28	; 40
    2880:	0f b6       	in	r0, 0x3f	; 63
    2882:	f8 94       	cli
    2884:	de bf       	out	0x3e, r29	; 62
    2886:	0f be       	out	0x3f, r0	; 63
    2888:	cd bf       	out	0x3d, r28	; 61
	
	
	DDRA |= (1<<PA4);
    288a:	0c 9a       	sbi	0x01, 4	; 1
	PORTA &= ~(1<<PA4);
    288c:	14 98       	cbi	0x02, 4	; 2
	
	MatrixUtil::createLookupTables();
    288e:	0e 94 d9 65 	call	0xcbb2	; 0xcbb2 <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>

	
	bool sendControlToServos = false;
	bool receiveGains = false;
	
	Scheduler *scheduler = Scheduler::getScheduler();
    2892:	0e 94 44 42 	call	0x8488	; 0x8488 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    2896:	98 a7       	std	Y+40, r25	; 0x28
    2898:	8f a3       	std	Y+39, r24	; 0x27
	
	SystemModel *model = new SystemModel();
    289a:	8f e4       	ldi	r24, 0x4F	; 79
    289c:	91 e0       	ldi	r25, 0x01	; 1
    289e:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    28a2:	4c 01       	movw	r8, r24
    28a4:	0e 94 a7 10 	call	0x214e	; 0x214e <_ZN10helicopter5model11SystemModelC1Ev>
	SystemModel::publicModel = model;
    28a8:	90 92 a5 03 	sts	0x03A5, r9
    28ac:	80 92 a4 03 	sts	0x03A4, r8
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
			void FlightMode( FlightModes val ) { flightMode = val;}
    28b0:	81 e0       	ldi	r24, 0x01	; 1
    28b2:	d4 01       	movw	r26, r8
    28b4:	13 96       	adiw	r26, 0x03	; 3
    28b6:	8c 93       	st	X, r24
    28b8:	13 97       	sbiw	r26, 0x03	; 3
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
    28ba:	14 96       	adiw	r26, 0x04	; 4
    28bc:	8c 93       	st	X, r24
    28be:	14 97       	sbiw	r26, 0x04	; 4
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
    28c0:	15 96       	adiw	r26, 0x05	; 5
    28c2:	8c 93       	st	X, r24
	}
	
	

	
	PIDController *pidController = new PIDController(model);
    28c4:	8e e8       	ldi	r24, 0x8E	; 142
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    28cc:	3c 01       	movw	r6, r24
    28ce:	b4 01       	movw	r22, r8
    28d0:	0e 94 76 02 	call	0x4ec	; 0x4ec <_ZN10helicopter10controller13PIDControllerC1EPNS_5model11SystemModelE>
	
	setupDefaultsandReferencePosition(model, pidController);
    28d4:	b3 01       	movw	r22, r6
    28d6:	c4 01       	movw	r24, r8
    28d8:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_Z33setupDefaultsandReferencePositionPN10helicopter5model11SystemModelEPNS_10controller13PIDControllerE>
			void FlightMode( FlightModes val ) { flightMode = val;}
				
			SensorInputs  SensorInput() const {return sensorInput;}
			void SensorInput( SensorInputs val ) { sensorInput = val;}								
				
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
    28dc:	f4 01       	movw	r30, r8
    28de:	85 81       	ldd	r24, Z+5	; 0x05
	Timer *timer = NULL;
	
	unsigned long serialDriverBaudRate = 0;
	
		
	if (model->CommunicationMethod() == SystemModel::USB)
    28e0:	81 11       	cpse	r24, r1
    28e2:	34 c0       	rjmp	.+104    	; 0x294c <main+0xd6>
	{
		serialDriverBaudRate = 250000;
		
		//Timer *timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 100); //Good timeout when using the USB
		timer = new Timer(F_CPU, PRESCALE_BY_TENTWENTYFOUR, 50); //Good timeout when using the USB
    28e4:	8a e0       	ldi	r24, 0x0A	; 10
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    28ec:	8c 01       	movw	r16, r24
				 * Now that this is using an 8 bit timer, prescaler has to be 1024, and timeout millizeconds
				 * has to be divisible by 10 and greater than 10. E.g. 10, 20, 30, 200, etc. 
				 */
				Timer (unsigned long cpuSpeed, PRESCALER timerPrescaler, unsigned long timeoutMilliseconds):
					cpuSpeed(cpuSpeed), timerPrescaler(timerPrescaler), timeoutMilliseconds(timeoutMilliseconds),
					numberOfTimeouts(timeoutMilliseconds / 10)
    28ee:	80 e0       	ldi	r24, 0x00	; 0
    28f0:	94 e2       	ldi	r25, 0x24	; 36
    28f2:	a4 ef       	ldi	r26, 0xF4	; 244
    28f4:	b0 e0       	ldi	r27, 0x00	; 0
    28f6:	f8 01       	movw	r30, r16
    28f8:	80 83       	st	Z, r24
    28fa:	91 83       	std	Z+1, r25	; 0x01
    28fc:	a2 83       	std	Z+2, r26	; 0x02
    28fe:	b3 83       	std	Z+3, r27	; 0x03
    2900:	80 e0       	ldi	r24, 0x00	; 0
    2902:	94 e0       	ldi	r25, 0x04	; 4
    2904:	95 83       	std	Z+5, r25	; 0x05
    2906:	84 83       	std	Z+4, r24	; 0x04
    2908:	82 e3       	ldi	r24, 0x32	; 50
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	97 83       	std	Z+7, r25	; 0x07
    290e:	86 83       	std	Z+6, r24	; 0x06
    2910:	85 e0       	ldi	r24, 0x05	; 5
    2912:	90 e0       	ldi	r25, 0x00	; 0
    2914:	91 87       	std	Z+9, r25	; 0x09
    2916:	80 87       	std	Z+8, r24	; 0x08
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, timer);//MOSTRECENT
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, true, timer); //latest 12/3/2014
    2918:	8b e0       	ldi	r24, 0x0B	; 11
    291a:	90 e0       	ldi	r25, 0x00	; 0
    291c:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2920:	5c 01       	movw	r10, r24
					Timer *timer = NULL) :
				baudRate(baudRate),
				uartPort(uartPort),
				useDoubleSpeedMode(useDoubleSpeedMode),
				asyncReceiveTransmitData(asyncReceiveTransmitData),
				timer(timer)
    2922:	82 e1       	ldi	r24, 0x12	; 18
    2924:	92 e0       	ldi	r25, 0x02	; 2
    2926:	d5 01       	movw	r26, r10
    2928:	8d 93       	st	X+, r24
    292a:	9c 93       	st	X, r25
    292c:	80 e9       	ldi	r24, 0x90	; 144
    292e:	90 ed       	ldi	r25, 0xD0	; 208
    2930:	a3 e0       	ldi	r26, 0x03	; 3
    2932:	b0 e0       	ldi	r27, 0x00	; 0
    2934:	f5 01       	movw	r30, r10
    2936:	82 83       	std	Z+2, r24	; 0x02
    2938:	93 83       	std	Z+3, r25	; 0x03
    293a:	a4 83       	std	Z+4, r26	; 0x04
    293c:	b5 83       	std	Z+5, r27	; 0x05
    293e:	16 82       	std	Z+6, r1	; 0x06
    2940:	17 82       	std	Z+7, r1	; 0x07
    2942:	81 e0       	ldi	r24, 0x01	; 1
    2944:	80 87       	std	Z+8, r24	; 0x08
    2946:	12 87       	std	Z+10, r17	; 0x0a
    2948:	01 87       	std	Z+9, r16	; 0x09
    294a:	38 c0       	rjmp	.+112    	; 0x29bc <main+0x146>
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, false, false, timer);
		//serialDriver = new SerialDriver(250000, SerialDriver::Zero, true, NULL);
	}else if (model->CommunicationMethod() == SystemModel::Radio)
    294c:	81 30       	cpi	r24, 0x01	; 1
    294e:	a1 f5       	brne	.+104    	; 0x29b8 <main+0x142>
	{
		//serialDriverBaudRate = 57600;
		serialDriverBaudRate = 115200;
		//timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,75); //Good timeout when using the radio
		
		timer = new Timer(F_CPU,PRESCALE_BY_TENTWENTYFOUR,200);//unfortunately for radio, the initial setup is a huge amount of data which takes a long time.
    2950:	8a e0       	ldi	r24, 0x0A	; 10
    2952:	90 e0       	ldi	r25, 0x00	; 0
    2954:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2958:	8c 01       	movw	r16, r24
    295a:	80 e0       	ldi	r24, 0x00	; 0
    295c:	94 e2       	ldi	r25, 0x24	; 36
    295e:	a4 ef       	ldi	r26, 0xF4	; 244
    2960:	b0 e0       	ldi	r27, 0x00	; 0
    2962:	f8 01       	movw	r30, r16
    2964:	80 83       	st	Z, r24
    2966:	91 83       	std	Z+1, r25	; 0x01
    2968:	a2 83       	std	Z+2, r26	; 0x02
    296a:	b3 83       	std	Z+3, r27	; 0x03
    296c:	80 e0       	ldi	r24, 0x00	; 0
    296e:	94 e0       	ldi	r25, 0x04	; 4
    2970:	95 83       	std	Z+5, r25	; 0x05
    2972:	84 83       	std	Z+4, r24	; 0x04
    2974:	88 ec       	ldi	r24, 0xC8	; 200
    2976:	90 e0       	ldi	r25, 0x00	; 0
    2978:	97 83       	std	Z+7, r25	; 0x07
    297a:	86 83       	std	Z+6, r24	; 0x06
    297c:	84 e1       	ldi	r24, 0x14	; 20
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	91 87       	std	Z+9, r25	; 0x09
    2982:	80 87       	std	Z+8, r24	; 0x08
			
		//Use a slower baud rate because the real helicopter uses the radio for communication
		//which is slower than USB.
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
    2984:	8b e0       	ldi	r24, 0x0B	; 11
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    298c:	5c 01       	movw	r10, r24
    298e:	82 e1       	ldi	r24, 0x12	; 18
    2990:	92 e0       	ldi	r25, 0x02	; 2
    2992:	d5 01       	movw	r26, r10
    2994:	8d 93       	st	X+, r24
    2996:	9c 93       	st	X, r25
    2998:	80 e0       	ldi	r24, 0x00	; 0
    299a:	92 ec       	ldi	r25, 0xC2	; 194
    299c:	a1 e0       	ldi	r26, 0x01	; 1
    299e:	b0 e0       	ldi	r27, 0x00	; 0
    29a0:	f5 01       	movw	r30, r10
    29a2:	82 83       	std	Z+2, r24	; 0x02
    29a4:	93 83       	std	Z+3, r25	; 0x03
    29a6:	a4 83       	std	Z+4, r26	; 0x04
    29a8:	b5 83       	std	Z+5, r27	; 0x05
    29aa:	16 82       	std	Z+6, r1	; 0x06
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	87 83       	std	Z+7, r24	; 0x07
    29b0:	80 87       	std	Z+8, r24	; 0x08
    29b2:	12 87       	std	Z+10, r17	; 0x0a
    29b4:	01 87       	std	Z+9, r16	; 0x09
    29b6:	02 c0       	rjmp	.+4      	; 0x29bc <main+0x146>
	setupDefaultsandReferencePosition(model, pidController);
	
	//Create a driver for communicating with the Ground Control Station (GCS).
	//SerialDriver *serialDriver = new SerialDriver(57600, SerialDriver::Zero, timer, true, true);
	//SerialDriver *serialDriver = new SerialDriver(76800, SerialDriver::Zero, true);
	SerialDriver *serialDriver = NULL;
    29b8:	a1 2c       	mov	r10, r1
    29ba:	b1 2c       	mov	r11, r1
		serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, timer);
		
		//serialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, false, timer);
	}
	
	serialDriver->init();
    29bc:	d5 01       	movw	r26, r10
    29be:	ed 91       	ld	r30, X+
    29c0:	fc 91       	ld	r31, X
    29c2:	04 80       	ldd	r0, Z+4	; 0x04
    29c4:	f5 81       	ldd	r31, Z+5	; 0x05
    29c6:	e0 2d       	mov	r30, r0
    29c8:	c5 01       	movw	r24, r10
    29ca:	19 95       	eicall
	//SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, false, gpsTimer);
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, gpsTimer);//LATEST
	
	//Don't care about gps timer anymore since it's only used on initialization. 
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, true, NULL);
	SerialDriver *gpsSerialDriver = new SerialDriver(38400, SerialDriver::One, true, false, NULL);
    29cc:	8b e0       	ldi	r24, 0x0B	; 11
    29ce:	90 e0       	ldi	r25, 0x00	; 0
    29d0:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    29d4:	9a 87       	std	Y+10, r25	; 0x0a
    29d6:	89 87       	std	Y+9, r24	; 0x09
    29d8:	82 e1       	ldi	r24, 0x12	; 18
    29da:	92 e0       	ldi	r25, 0x02	; 2
    29dc:	e9 85       	ldd	r30, Y+9	; 0x09
    29de:	fa 85       	ldd	r31, Y+10	; 0x0a
    29e0:	91 83       	std	Z+1, r25	; 0x01
    29e2:	80 83       	st	Z, r24
    29e4:	80 e0       	ldi	r24, 0x00	; 0
    29e6:	96 e9       	ldi	r25, 0x96	; 150
    29e8:	a0 e0       	ldi	r26, 0x00	; 0
    29ea:	b0 e0       	ldi	r27, 0x00	; 0
    29ec:	82 83       	std	Z+2, r24	; 0x02
    29ee:	93 83       	std	Z+3, r25	; 0x03
    29f0:	a4 83       	std	Z+4, r26	; 0x04
    29f2:	b5 83       	std	Z+5, r27	; 0x05
    29f4:	81 e0       	ldi	r24, 0x01	; 1
    29f6:	86 83       	std	Z+6, r24	; 0x06
    29f8:	87 83       	std	Z+7, r24	; 0x07
    29fa:	10 86       	std	Z+8, r1	; 0x08
    29fc:	12 86       	std	Z+10, r1	; 0x0a
    29fe:	11 86       	std	Z+9, r1	; 0x09
	//SerialDriver *gpsSerialDriver = new SerialDriver(9600, SerialDriver::One, false, gpsTimer);
	gpsSerialDriver->init();
    2a00:	cf 01       	movw	r24, r30
    2a02:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <_ZN10helicopter7drivers12SerialDriver4initEv>

	
	
	
	
	TWIDriver *twiDriver = new TWIDriver();
    2a06:	81 e0       	ldi	r24, 0x01	; 1
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2a0e:	9a a3       	std	Y+34, r25	; 0x22
    2a10:	89 a3       	std	Y+33, r24	; 0x21
	twiDriver->init();
    2a12:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <_ZN10helicopter7drivers9TWIDriver4initEv>

	
	
	GroundControlStationInterface *gcsInterface = new GroundControlStationInterface(serialDriver);
    2a16:	82 e0       	ldi	r24, 0x02	; 2
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2a1e:	2c 01       	movw	r4, r24
				 * as receiving a byte.
				 * @param serialDriver the driver used to communicate with the serial port
				 * which is used to communicate with the Ground Control Station.
				 */
				GroundControlStationInterface(SerialDriver *serialDriver):
					serialDriver(serialDriver)
    2a20:	dc 01       	movw	r26, r24
    2a22:	ad 92       	st	X+, r10
    2a24:	bc 92       	st	X, r11
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}

			FlightModes  FlightMode() const {return flightMode;}
    2a26:	f4 01       	movw	r30, r8
    2a28:	83 81       	ldd	r24, Z+3	; 0x03
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;

	if (model->FlightMode() == SystemModel::RealFlightTest)
    2a2a:	81 30       	cpi	r24, 0x01	; 1
    2a2c:	b1 f5       	brne	.+108    	; 0x2a9a <main+0x224>
		barometerInitReadings = 1300;
		sensorInitReadings = 100;
		*/
		
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2a2e:	8c e0       	ldi	r24, 0x0C	; 12
    2a30:	90 e0       	ldi	r25, 0x00	; 0
    2a32:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2a36:	9e 83       	std	Y+6, r25	; 0x06
    2a38:	8d 83       	std	Y+5, r24	; 0x05
    2a3a:	0f 2e       	mov	r0, r31
    2a3c:	f4 e6       	ldi	r31, 0x64	; 100
    2a3e:	ef 2e       	mov	r14, r31
    2a40:	f1 2c       	mov	r15, r1
    2a42:	f0 2d       	mov	r31, r0
    2a44:	01 e0       	ldi	r16, 0x01	; 1
    2a46:	10 e0       	ldi	r17, 0x00	; 0
    2a48:	22 e0       	ldi	r18, 0x02	; 2
    2a4a:	a4 01       	movw	r20, r8
    2a4c:	b2 01       	movw	r22, r4
    2a4e:	0e 94 54 64 	call	0xc8a8	; 0xc8a8 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
			gainsTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}*/
		
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
    2a52:	8e e0       	ldi	r24, 0x0E	; 14
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2a5a:	9a 83       	std	Y+2, r25	; 0x02
    2a5c:	89 83       	std	Y+1, r24	; 0x01
    2a5e:	0f 2e       	mov	r0, r31
    2a60:	f8 ec       	ldi	r31, 0xC8	; 200
    2a62:	cf 2e       	mov	r12, r31
    2a64:	d1 2c       	mov	r13, r1
    2a66:	f0 2d       	mov	r31, r0
    2a68:	e1 2c       	mov	r14, r1
    2a6a:	f1 2c       	mov	r15, r1
    2a6c:	02 e0       	ldi	r16, 0x02	; 2
    2a6e:	93 01       	movw	r18, r6
    2a70:	a4 01       	movw	r20, r8
    2a72:	b2 01       	movw	r22, r4
    2a74:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    2a78:	24 e6       	ldi	r18, 0x64	; 100
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	3a 8f       	std	Y+26, r19	; 0x1a
    2a7e:	29 8f       	std	Y+25, r18	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2a80:	45 e0       	ldi	r20, 0x05	; 5
    2a82:	50 e0       	ldi	r21, 0x00	; 0
    2a84:	58 8b       	std	Y+16, r21	; 0x10
    2a86:	4f 87       	std	Y+15, r20	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2a88:	80 e2       	ldi	r24, 0x20	; 32
    2a8a:	9e e4       	ldi	r25, 0x4E	; 78
    2a8c:	a0 e0       	ldi	r26, 0x00	; 0
    2a8e:	b0 e0       	ldi	r27, 0x00	; 0
    2a90:	8d 8b       	std	Y+21, r24	; 0x15
    2a92:	9e 8b       	std	Y+22, r25	; 0x16
    2a94:	af 8b       	std	Y+23, r26	; 0x17
    2a96:	b8 8f       	std	Y+24, r27	; 0x18
    2a98:	bc c0       	rjmp	.+376    	; 0x2c12 <main+0x39c>
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
    2a9a:	83 30       	cpi	r24, 0x03	; 3
    2a9c:	b1 f5       	brne	.+108    	; 0x2b0a <main+0x294>
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
		
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
    2a9e:	8c e0       	ldi	r24, 0x0C	; 12
    2aa0:	90 e0       	ldi	r25, 0x00	; 0
    2aa2:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2aa6:	9e 83       	std	Y+6, r25	; 0x06
    2aa8:	8d 83       	std	Y+5, r24	; 0x05
    2aaa:	0f 2e       	mov	r0, r31
    2aac:	f4 e6       	ldi	r31, 0x64	; 100
    2aae:	ef 2e       	mov	r14, r31
    2ab0:	f1 2c       	mov	r15, r1
    2ab2:	f0 2d       	mov	r31, r0
    2ab4:	01 e0       	ldi	r16, 0x01	; 1
    2ab6:	10 e0       	ldi	r17, 0x00	; 0
    2ab8:	22 e0       	ldi	r18, 0x02	; 2
    2aba:	a4 01       	movw	r20, r8
    2abc:	b2 01       	movw	r22, r4
    2abe:	0e 94 54 64 	call	0xc8a8	; 0xc8a8 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		if (receiveGains)
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
    2ac2:	8e e0       	ldi	r24, 0x0E	; 14
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2aca:	9a 83       	std	Y+2, r25	; 0x02
    2acc:	89 83       	std	Y+1, r24	; 0x01
    2ace:	0f 2e       	mov	r0, r31
    2ad0:	f8 ec       	ldi	r31, 0xC8	; 200
    2ad2:	cf 2e       	mov	r12, r31
    2ad4:	d1 2c       	mov	r13, r1
    2ad6:	f0 2d       	mov	r31, r0
    2ad8:	e1 2c       	mov	r14, r1
    2ada:	f1 2c       	mov	r15, r1
    2adc:	02 e0       	ldi	r16, 0x02	; 2
    2ade:	93 01       	movw	r18, r6
    2ae0:	a4 01       	movw	r20, r8
    2ae2:	b2 01       	movw	r22, r4
    2ae4:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
		sensorInitReadings = 500;
    2ae8:	a4 ef       	ldi	r26, 0xF4	; 244
    2aea:	b1 e0       	ldi	r27, 0x01	; 1
    2aec:	ba 8f       	std	Y+26, r27	; 0x1a
    2aee:	a9 8f       	std	Y+25, r26	; 0x19
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
		barometerInitReadings = 1000;
    2af0:	e8 ee       	ldi	r30, 0xE8	; 232
    2af2:	f3 e0       	ldi	r31, 0x03	; 3
    2af4:	f8 8b       	std	Y+16, r31	; 0x10
    2af6:	ef 87       	std	Y+15, r30	; 0x0f
		}
		
		
	}else if (model->FlightMode() == SystemModel::RealFlight)
	{
		gpsAcceptanceThreshold = 900;
    2af8:	24 e8       	ldi	r18, 0x84	; 132
    2afa:	33 e0       	ldi	r19, 0x03	; 3
    2afc:	40 e0       	ldi	r20, 0x00	; 0
    2afe:	50 e0       	ldi	r21, 0x00	; 0
    2b00:	2d 8b       	std	Y+21, r18	; 0x15
    2b02:	3e 8b       	std	Y+22, r19	; 0x16
    2b04:	4f 8b       	std	Y+23, r20	; 0x17
    2b06:	58 8f       	std	Y+24, r21	; 0x18
    2b08:	84 c0       	rjmp	.+264    	; 0x2c12 <main+0x39c>
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::GAINSDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ)); //execute once a sec
		}else
		{
			simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .5));
		}
	}else if (model->FlightMode() == SystemModel::SimulatedFlight)
    2b0a:	81 11       	cpse	r24, r1
    2b0c:	36 c0       	rjmp	.+108    	; 0x2b7a <main+0x304>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05)); //latest 12/3/2014
    2b0e:	8c e0       	ldi	r24, 0x0C	; 12
    2b10:	90 e0       	ldi	r25, 0x00	; 0
    2b12:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2b16:	9e 83       	std	Y+6, r25	; 0x06
    2b18:	8d 83       	std	Y+5, r24	; 0x05
    2b1a:	0f 2e       	mov	r0, r31
    2b1c:	fa e0       	ldi	r31, 0x0A	; 10
    2b1e:	ef 2e       	mov	r14, r31
    2b20:	f1 2c       	mov	r15, r1
    2b22:	f0 2d       	mov	r31, r0
    2b24:	01 e0       	ldi	r16, 0x01	; 1
    2b26:	10 e0       	ldi	r17, 0x00	; 0
    2b28:	20 e0       	ldi	r18, 0x00	; 0
    2b2a:	a4 01       	movw	r20, r8
    2b2c:	b2 01       	movw	r22, r4
    2b2e:	0e 94 54 64 	call	0xc8a8	; 0xc8a8 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    2b32:	8e e0       	ldi	r24, 0x0E	; 14
    2b34:	90 e0       	ldi	r25, 0x00	; 0
    2b36:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2b3a:	9a 83       	std	Y+2, r25	; 0x02
    2b3c:	89 83       	std	Y+1, r24	; 0x01
    2b3e:	0f 2e       	mov	r0, r31
    2b40:	fa e0       	ldi	r31, 0x0A	; 10
    2b42:	cf 2e       	mov	r12, r31
    2b44:	d1 2c       	mov	r13, r1
    2b46:	f0 2d       	mov	r31, r0
    2b48:	e1 2c       	mov	r14, r1
    2b4a:	f1 2c       	mov	r15, r1
    2b4c:	00 e0       	ldi	r16, 0x00	; 0
    2b4e:	93 01       	movw	r18, r6
    2b50:	a4 01       	movw	r20, r8
    2b52:	b2 01       	movw	r22, r4
    2b54:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    2b58:	44 e6       	ldi	r20, 0x64	; 100
    2b5a:	50 e0       	ldi	r21, 0x00	; 0
    2b5c:	5a 8f       	std	Y+26, r21	; 0x1a
    2b5e:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2b60:	85 e0       	ldi	r24, 0x05	; 5
    2b62:	90 e0       	ldi	r25, 0x00	; 0
    2b64:	98 8b       	std	Y+16, r25	; 0x10
    2b66:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2b68:	20 e2       	ldi	r18, 0x20	; 32
    2b6a:	3e e4       	ldi	r19, 0x4E	; 78
    2b6c:	40 e0       	ldi	r20, 0x00	; 0
    2b6e:	50 e0       	ldi	r21, 0x00	; 0
    2b70:	2d 8b       	std	Y+21, r18	; 0x15
    2b72:	3e 8b       	std	Y+22, r19	; 0x16
    2b74:	4f 8b       	std	Y+23, r20	; 0x17
    2b76:	58 8f       	std	Y+24, r21	; 0x18
    2b78:	4c c0       	rjmp	.+152    	; 0x2c12 <main+0x39c>
		//transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
		//simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .02));
		
	}else if (model->FlightMode() == SystemModel::HardwareInLoopSimulatedFlight)
    2b7a:	82 30       	cpi	r24, 0x02	; 2
    2b7c:	b1 f5       	brne	.+108    	; 0x2bea <main+0x374>
	{
		transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::CONTROLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
    2b7e:	8c e0       	ldi	r24, 0x0C	; 12
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2b86:	9e 83       	std	Y+6, r25	; 0x06
    2b88:	8d 83       	std	Y+5, r24	; 0x05
    2b8a:	0f 2e       	mov	r0, r31
    2b8c:	fa e0       	ldi	r31, 0x0A	; 10
    2b8e:	ef 2e       	mov	r14, r31
    2b90:	f1 2c       	mov	r15, r1
    2b92:	f0 2d       	mov	r31, r0
    2b94:	01 e0       	ldi	r16, 0x01	; 1
    2b96:	10 e0       	ldi	r17, 0x00	; 0
    2b98:	21 e0       	ldi	r18, 0x01	; 1
    2b9a:	a4 01       	movw	r20, r8
    2b9c:	b2 01       	movw	r22, r4
    2b9e:	0e 94 54 64 	call	0xc8a8	; 0xc8a8 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>
		simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    2ba2:	8e e0       	ldi	r24, 0x0E	; 14
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2baa:	9a 83       	std	Y+2, r25	; 0x02
    2bac:	89 83       	std	Y+1, r24	; 0x01
    2bae:	0f 2e       	mov	r0, r31
    2bb0:	fa e0       	ldi	r31, 0x0A	; 10
    2bb2:	cf 2e       	mov	r12, r31
    2bb4:	d1 2c       	mov	r13, r1
    2bb6:	f0 2d       	mov	r31, r0
    2bb8:	e1 2c       	mov	r14, r1
    2bba:	f1 2c       	mov	r15, r1
    2bbc:	01 e0       	ldi	r16, 0x01	; 1
    2bbe:	93 01       	movw	r18, r6
    2bc0:	a4 01       	movw	r20, r8
    2bc2:	b2 01       	movw	r22, r4
    2bc4:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    2bc8:	44 e6       	ldi	r20, 0x64	; 100
    2bca:	50 e0       	ldi	r21, 0x00	; 0
    2bcc:	5a 8f       	std	Y+26, r21	; 0x1a
    2bce:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2bd0:	85 e0       	ldi	r24, 0x05	; 5
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	98 8b       	std	Y+16, r25	; 0x10
    2bd6:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2bd8:	20 e2       	ldi	r18, 0x20	; 32
    2bda:	3e e4       	ldi	r19, 0x4E	; 78
    2bdc:	40 e0       	ldi	r20, 0x00	; 0
    2bde:	50 e0       	ldi	r21, 0x00	; 0
    2be0:	2d 8b       	std	Y+21, r18	; 0x15
    2be2:	3e 8b       	std	Y+22, r19	; 0x16
    2be4:	4f 8b       	std	Y+23, r20	; 0x17
    2be6:	58 8f       	std	Y+24, r21	; 0x18
    2be8:	14 c0       	rjmp	.+40     	; 0x2c12 <main+0x39c>
	int barometerInitReadings = 5;
	int sensorInitReadings = 100;
    2bea:	44 e6       	ldi	r20, 0x64	; 100
    2bec:	50 e0       	ldi	r21, 0x00	; 0
    2bee:	5a 8f       	std	Y+26, r21	; 0x1a
    2bf0:	49 8f       	std	Y+25, r20	; 0x19
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
	int barometerInitReadings = 5;
    2bf2:	85 e0       	ldi	r24, 0x05	; 5
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	98 8b       	std	Y+16, r25	; 0x10
    2bf8:	8f 87       	std	Y+15, r24	; 0x0f
	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
	
	
	unsigned long gpsAcceptanceThreshold = 20000;
    2bfa:	20 e2       	ldi	r18, 0x20	; 32
    2bfc:	3e e4       	ldi	r19, 0x4E	; 78
    2bfe:	40 e0       	ldi	r20, 0x00	; 0
    2c00:	50 e0       	ldi	r21, 0x00	; 0
    2c02:	2d 8b       	std	Y+21, r18	; 0x15
    2c04:	3e 8b       	std	Y+22, r19	; 0x16
    2c06:	4f 8b       	std	Y+23, r20	; 0x17
    2c08:	58 8f       	std	Y+24, r21	; 0x18
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
	//SimTelemetryTask *gainsTelemTask = NULL;
	TransmitTelemetryTask *transTelemTask = NULL;
    2c0a:	1e 82       	std	Y+6, r1	; 0x06
    2c0c:	1d 82       	std	Y+5, r1	; 0x05
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,SimTelemetryTask::SENSORDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::ALLDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));
	//TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, TransmitTelemetryTask::SIMPLEDATA, 1, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));

	SimTelemetryTask *simTelemTask = NULL;
    2c0e:	1a 82       	std	Y+2, r1	; 0x02
    2c10:	19 82       	std	Y+1, r1	; 0x01
SimTelemetryTask *simTelemTask = new SimTelemetryTask(gcsInterface, model, pidController,0, SCHEDULER_TICK_FREQUENCY_HZ);//execute 1 hz
TransmitTelemetryTask *transTelemTask = new TransmitTelemetryTask(gcsInterface, model, 0, SCHEDULER_TICK_FREQUENCY_HZ);
*/
	
	
	FlashLEDTask *flashTask = new FlashLEDTask(2, SCHEDULER_TICK_FREQUENCY_HZ);//starting at tick 2, execute once a second
    2c12:	8a e0       	ldi	r24, 0x0A	; 10
    2c14:	90 e0       	ldi	r25, 0x00	; 0
    2c16:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2c1a:	9c 8f       	std	Y+28, r25	; 0x1c
    2c1c:	8b 8f       	std	Y+27, r24	; 0x1b
			public:

			FlashLEDTask (int delay, int period, int ledToBlink = BLUELED) : 
				Task(delay, period),
				isOff(false),
				ledToBlink(ledToBlink)
    2c1e:	48 ec       	ldi	r20, 0xC8	; 200
    2c20:	50 e0       	ldi	r21, 0x00	; 0
    2c22:	62 e0       	ldi	r22, 0x02	; 2
    2c24:	70 e0       	ldi	r23, 0x00	; 0
    2c26:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    2c2a:	8a e2       	ldi	r24, 0x2A	; 42
    2c2c:	92 e0       	ldi	r25, 0x02	; 2
    2c2e:	ab 8d       	ldd	r26, Y+27	; 0x1b
    2c30:	bc 8d       	ldd	r27, Y+28	; 0x1c
    2c32:	11 96       	adiw	r26, 0x01	; 1
    2c34:	9c 93       	st	X, r25
    2c36:	8e 93       	st	-X, r24
    2c38:	17 96       	adiw	r26, 0x07	; 7
    2c3a:	1c 92       	st	X, r1
    2c3c:	17 97       	sbiw	r26, 0x07	; 7
    2c3e:	83 e0       	ldi	r24, 0x03	; 3
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	19 96       	adiw	r26, 0x09	; 9
    2c44:	9c 93       	st	X, r25
    2c46:	8e 93       	st	-X, r24
    2c48:	18 97       	sbiw	r26, 0x08	; 8
		
//	SensorProcessingTask *sensorProcessingTask = new SensorProcessingTask(model, 5, 4);
		
	//execute the pid outer loop at the PID_OUTER_LOOP_PERIOD rate. The division is to convert the period into ticks for the scheduler.

	PIDOuterLoopTask *pidOuterLoop = new PIDOuterLoopTask(pidController, 3, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_OUTER_LOOP_PERIOD));
    2c4a:	89 e0       	ldi	r24, 0x09	; 9
    2c4c:	90 e0       	ldi	r25, 0x00	; 0
    2c4e:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2c52:	9c a3       	std	Y+36, r25	; 0x24
    2c54:	8b a3       	std	Y+35, r24	; 0x23
    2c56:	2a e0       	ldi	r18, 0x0A	; 10
    2c58:	30 e0       	ldi	r19, 0x00	; 0
    2c5a:	43 e0       	ldi	r20, 0x03	; 3
    2c5c:	50 e0       	ldi	r21, 0x00	; 0
    2c5e:	b3 01       	movw	r22, r6
    2c60:	0e 94 88 56 	call	0xad10	; 0xad10 <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
    2c64:	89 e0       	ldi	r24, 0x09	; 9
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2c6c:	9e a3       	std	Y+38, r25	; 0x26
    2c6e:	8d a3       	std	Y+37, r24	; 0x25
    2c70:	24 e0       	ldi	r18, 0x04	; 4
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	44 e0       	ldi	r20, 0x04	; 4
    2c76:	50 e0       	ldi	r21, 0x00	; 0
    2c78:	b3 01       	movw	r22, r6
    2c7a:	0e 94 5f 56 	call	0xacbe	; 0xacbe <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>
	//float barometerSensorReadPeriod = 1/50.0f;
	float simulatorSensorReadPeriod = barometerSensorReadPeriod;
	
	float sensorReadPeriod = 0;
		
	if (model->SensorInput() == SystemModel::SimulatedSensors)
    2c7e:	f4 01       	movw	r30, r8
    2c80:	84 81       	ldd	r24, Z+4	; 0x04
    2c82:	81 11       	cpse	r24, r1
    2c84:	13 c0       	rjmp	.+38     	; 0x2cac <main+0x436>
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
    2c86:	0f 2e       	mov	r0, r31
    2c88:	fd ec       	ldi	r31, 0xCD	; 205
    2c8a:	cf 2e       	mov	r12, r31
    2c8c:	fc ec       	ldi	r31, 0xCC	; 204
    2c8e:	df 2e       	mov	r13, r31
    2c90:	fc e4       	ldi	r31, 0x4C	; 76
    2c92:	ef 2e       	mov	r14, r31
    2c94:	fd e3       	ldi	r31, 0x3D	; 61
    2c96:	ff 2e       	mov	r15, r31
    2c98:	f0 2d       	mov	r31, r0
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
	float newBarometerSensorReadPeriod = barometerSensorReadPeriod;// how frequently NEW barometer sensor data is received. 
    2c9a:	c9 8a       	std	Y+17, r12	; 0x11
    2c9c:	da 8a       	std	Y+18, r13	; 0x12
    2c9e:	eb 8a       	std	Y+19, r14	; 0x13
    2ca0:	fc 8a       	std	Y+20, r15	; 0x14
	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, (SCHEDULER_TICK_FREQUENCY_HZ  * PID_INNER_LOOP_PERIOD));
	
	
//	PIDInnerLoopTask *pidInnerLoop = new PIDInnerLoopTask(pidController, 4, 1);
	
	float barometerSensorReadPeriod = 1/20.0f; //will be 1/50 for production (or will it? because the ahrs uses this too. //latest 12/3/2014
    2ca2:	cb 86       	std	Y+11, r12	; 0x0b
    2ca4:	dc 86       	std	Y+12, r13	; 0x0c
    2ca6:	ed 86       	std	Y+13, r14	; 0x0d
    2ca8:	fe 86       	std	Y+14, r15	; 0x0e
    2caa:	1a c0       	rjmp	.+52     	; 0x2ce0 <main+0x46a>
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
		sensorReadPeriod = GYRO_SENSOR_READ_PERIOD;
    2cac:	0f 2e       	mov	r0, r31
    2cae:	f5 e0       	ldi	r31, 0x05	; 5
    2cb0:	cf 2e       	mov	r12, r31
    2cb2:	ff e2       	ldi	r31, 0x2F	; 47
    2cb4:	df 2e       	mov	r13, r31
    2cb6:	f7 e2       	ldi	r31, 0x27	; 39
    2cb8:	ef 2e       	mov	r14, r31
    2cba:	fc e3       	ldi	r31, 0x3C	; 60
    2cbc:	ff 2e       	mov	r15, r31
    2cbe:	f0 2d       	mov	r31, r0
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
		newBarometerSensorReadPeriod = 1.0f/(50.0f/3.0f); //This is multiplied by 3 because reading the baro data is a 3 step process. So you only get actual new baro data every third sensor reading. But when you are using the simulator, it updates with every new message that comes in, so thats 1/20 seconds. 
    2cc0:	20 e9       	ldi	r18, 0x90	; 144
    2cc2:	32 ec       	ldi	r19, 0xC2	; 194
    2cc4:	45 e7       	ldi	r20, 0x75	; 117
    2cc6:	5d e3       	ldi	r21, 0x3D	; 61
    2cc8:	29 8b       	std	Y+17, r18	; 0x11
    2cca:	3a 8b       	std	Y+18, r19	; 0x12
    2ccc:	4b 8b       	std	Y+19, r20	; 0x13
    2cce:	5c 8b       	std	Y+20, r21	; 0x14
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    2cd0:	8a e0       	ldi	r24, 0x0A	; 10
    2cd2:	97 ed       	ldi	r25, 0xD7	; 215
    2cd4:	a3 ea       	ldi	r26, 0xA3	; 163
    2cd6:	bc e3       	ldi	r27, 0x3C	; 60
    2cd8:	8b 87       	std	Y+11, r24	; 0x0b
    2cda:	9c 87       	std	Y+12, r25	; 0x0c
    2cdc:	ad 87       	std	Y+13, r26	; 0x0d
    2cde:	be 87       	std	Y+14, r27	; 0x0e
	}
	
		
	//AHRS *ahrs = new AHRS(GYRO_SENSOR_READ_PERIOD);
	//AHRS *ahrs = new AHRS(simulatorSensorReadPeriod); //for simulator angular velocity reads.
	AHRS *ahrs = new AHRS(sensorReadPeriod);
    2ce0:	80 e7       	ldi	r24, 0x70	; 112
    2ce2:	90 e0       	ldi	r25, 0x00	; 0
    2ce4:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2ce8:	2c 01       	movw	r4, r24
					yawRads(0),
					pitchRads(0),
					rollRads(0),
					linearAccelerationXMss(0),
					linearAccelerationYMss(0),
					linearAccelerationZMss(0)	
    2cea:	dc 01       	movw	r26, r24
    2cec:	cd 92       	st	X+, r12
    2cee:	dd 92       	st	X+, r13
    2cf0:	ed 92       	st	X+, r14
    2cf2:	fc 92       	st	X, r15
    2cf4:	13 97       	sbiw	r26, 0x03	; 3
    2cf6:	fc 01       	movw	r30, r24
    2cf8:	14 82       	std	Z+4, r1	; 0x04
    2cfa:	15 82       	std	Z+5, r1	; 0x05
    2cfc:	16 82       	std	Z+6, r1	; 0x06
    2cfe:	17 82       	std	Z+7, r1	; 0x07
    2d00:	18 96       	adiw	r26, 0x08	; 8
    2d02:	1d 92       	st	X+, r1
    2d04:	1d 92       	st	X+, r1
    2d06:	1d 92       	st	X+, r1
    2d08:	1c 92       	st	X, r1
    2d0a:	1b 97       	sbiw	r26, 0x0b	; 11
    2d0c:	14 86       	std	Z+12, r1	; 0x0c
    2d0e:	15 86       	std	Z+13, r1	; 0x0d
    2d10:	16 86       	std	Z+14, r1	; 0x0e
    2d12:	17 86       	std	Z+15, r1	; 0x0f
    2d14:	50 96       	adiw	r26, 0x10	; 16
    2d16:	1d 92       	st	X+, r1
    2d18:	1d 92       	st	X+, r1
    2d1a:	1d 92       	st	X+, r1
    2d1c:	1c 92       	st	X, r1
    2d1e:	53 97       	sbiw	r26, 0x13	; 19
    2d20:	14 8a       	std	Z+20, r1	; 0x14
    2d22:	15 8a       	std	Z+21, r1	; 0x15
    2d24:	16 8a       	std	Z+22, r1	; 0x16
    2d26:	17 8a       	std	Z+23, r1	; 0x17
    2d28:	58 96       	adiw	r26, 0x18	; 24
    2d2a:	1d 92       	st	X+, r1
    2d2c:	1d 92       	st	X+, r1
    2d2e:	1d 92       	st	X+, r1
    2d30:	1c 92       	st	X, r1
    2d32:	5b 97       	sbiw	r26, 0x1b	; 27
    2d34:	14 8e       	std	Z+28, r1	; 0x1c
    2d36:	15 8e       	std	Z+29, r1	; 0x1d
    2d38:	16 8e       	std	Z+30, r1	; 0x1e
    2d3a:	17 8e       	std	Z+31, r1	; 0x1f
    2d3c:	90 96       	adiw	r26, 0x20	; 32
    2d3e:	1d 92       	st	X+, r1
    2d40:	1d 92       	st	X+, r1
    2d42:	1d 92       	st	X+, r1
    2d44:	1c 92       	st	X, r1
    2d46:	93 97       	sbiw	r26, 0x23	; 35
    2d48:	14 a2       	std	Z+36, r1	; 0x24
    2d4a:	15 a2       	std	Z+37, r1	; 0x25
    2d4c:	16 a2       	std	Z+38, r1	; 0x26
    2d4e:	17 a2       	std	Z+39, r1	; 0x27
    2d50:	98 96       	adiw	r26, 0x28	; 40
    2d52:	1d 92       	st	X+, r1
    2d54:	1d 92       	st	X+, r1
    2d56:	1d 92       	st	X+, r1
    2d58:	1c 92       	st	X, r1
    2d5a:	9b 97       	sbiw	r26, 0x2b	; 43
    2d5c:	14 a6       	std	Z+44, r1	; 0x2c
    2d5e:	15 a6       	std	Z+45, r1	; 0x2d
    2d60:	16 a6       	std	Z+46, r1	; 0x2e
    2d62:	17 a6       	std	Z+47, r1	; 0x2f
    2d64:	d0 96       	adiw	r26, 0x30	; 48
    2d66:	1d 92       	st	X+, r1
    2d68:	1d 92       	st	X+, r1
    2d6a:	1d 92       	st	X+, r1
    2d6c:	1c 92       	st	X, r1
    2d6e:	d3 97       	sbiw	r26, 0x33	; 51
    2d70:	14 aa       	std	Z+52, r1	; 0x34
    2d72:	15 aa       	std	Z+53, r1	; 0x35
    2d74:	16 aa       	std	Z+54, r1	; 0x36
    2d76:	17 aa       	std	Z+55, r1	; 0x37
    2d78:	d8 96       	adiw	r26, 0x38	; 56
    2d7a:	1d 92       	st	X+, r1
    2d7c:	1d 92       	st	X+, r1
    2d7e:	1d 92       	st	X+, r1
    2d80:	1c 92       	st	X, r1
    2d82:	db 97       	sbiw	r26, 0x3b	; 59
    2d84:	14 ae       	std	Z+60, r1	; 0x3c
    2d86:	15 ae       	std	Z+61, r1	; 0x3d
    2d88:	16 ae       	std	Z+62, r1	; 0x3e
    2d8a:	17 ae       	std	Z+63, r1	; 0x3f
				{
					/**
					 * Setup initial state of the DCM matrix with initial unit vectors
					 * {{1,0,0},{0,1,0},{0,0,-1}}
					 */
					dcm[0][0] = 1;
    2d8c:	e0 5c       	subi	r30, 0xC0	; 192
    2d8e:	ff 4f       	sbci	r31, 0xFF	; 255
    2d90:	80 e0       	ldi	r24, 0x00	; 0
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    2d94:	a0 e8       	ldi	r26, 0x80	; 128
    2d96:	bf e3       	ldi	r27, 0x3F	; 63
    2d98:	80 83       	st	Z, r24
    2d9a:	91 83       	std	Z+1, r25	; 0x01
    2d9c:	a2 83       	std	Z+2, r26	; 0x02
    2d9e:	b3 83       	std	Z+3, r27	; 0x03
					dcm[0][1] = 0;
    2da0:	f2 01       	movw	r30, r4
    2da2:	ec 5b       	subi	r30, 0xBC	; 188
    2da4:	ff 4f       	sbci	r31, 0xFF	; 255
    2da6:	10 82       	st	Z, r1
    2da8:	11 82       	std	Z+1, r1	; 0x01
    2daa:	12 82       	std	Z+2, r1	; 0x02
    2dac:	13 82       	std	Z+3, r1	; 0x03
					dcm[0][2] = 0;
    2dae:	f2 01       	movw	r30, r4
    2db0:	e8 5b       	subi	r30, 0xB8	; 184
    2db2:	ff 4f       	sbci	r31, 0xFF	; 255
    2db4:	10 82       	st	Z, r1
    2db6:	11 82       	std	Z+1, r1	; 0x01
    2db8:	12 82       	std	Z+2, r1	; 0x02
    2dba:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][0] = 0;
    2dbc:	f2 01       	movw	r30, r4
    2dbe:	e4 5b       	subi	r30, 0xB4	; 180
    2dc0:	ff 4f       	sbci	r31, 0xFF	; 255
    2dc2:	10 82       	st	Z, r1
    2dc4:	11 82       	std	Z+1, r1	; 0x01
    2dc6:	12 82       	std	Z+2, r1	; 0x02
    2dc8:	13 82       	std	Z+3, r1	; 0x03
					dcm[1][1] = 1;
    2dca:	f2 01       	movw	r30, r4
    2dcc:	e0 5b       	subi	r30, 0xB0	; 176
    2dce:	ff 4f       	sbci	r31, 0xFF	; 255
    2dd0:	80 83       	st	Z, r24
    2dd2:	91 83       	std	Z+1, r25	; 0x01
    2dd4:	a2 83       	std	Z+2, r26	; 0x02
    2dd6:	b3 83       	std	Z+3, r27	; 0x03
					dcm[1][2] = 0;
    2dd8:	f2 01       	movw	r30, r4
    2dda:	ec 5a       	subi	r30, 0xAC	; 172
    2ddc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dde:	10 82       	st	Z, r1
    2de0:	11 82       	std	Z+1, r1	; 0x01
    2de2:	12 82       	std	Z+2, r1	; 0x02
    2de4:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][0] = 0;
    2de6:	f2 01       	movw	r30, r4
    2de8:	e8 5a       	subi	r30, 0xA8	; 168
    2dea:	ff 4f       	sbci	r31, 0xFF	; 255
    2dec:	10 82       	st	Z, r1
    2dee:	11 82       	std	Z+1, r1	; 0x01
    2df0:	12 82       	std	Z+2, r1	; 0x02
    2df2:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][1] = 0;
    2df4:	f2 01       	movw	r30, r4
    2df6:	e4 5a       	subi	r30, 0xA4	; 164
    2df8:	ff 4f       	sbci	r31, 0xFF	; 255
    2dfa:	10 82       	st	Z, r1
    2dfc:	11 82       	std	Z+1, r1	; 0x01
    2dfe:	12 82       	std	Z+2, r1	; 0x02
    2e00:	13 82       	std	Z+3, r1	; 0x03
					dcm[2][2] = 1;
    2e02:	f2 01       	movw	r30, r4
    2e04:	e0 5a       	subi	r30, 0xA0	; 160
    2e06:	ff 4f       	sbci	r31, 0xFF	; 255
    2e08:	80 83       	st	Z, r24
    2e0a:	91 83       	std	Z+1, r25	; 0x01
    2e0c:	a2 83       	std	Z+2, r26	; 0x02
    2e0e:	b3 83       	std	Z+3, r27	; 0x03
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
			void Ahrs(AHRS *val) {ahrs = val;}
    2e10:	d4 01       	movw	r26, r8
    2e12:	4d 92       	st	X+, r4
    2e14:	5c 92       	st	X, r5
	NavigationTask *navTask = NULL;
	PVNavigationTask *pvNavTask = NULL;
	

	//navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * sensorReadPeriod)); //run at 98 hz.
	navTask = new NavigationTask(barometerSensorReadPeriod, ahrs, model, 5, (SCHEDULER_TICK_FREQUENCY_HZ * .01f)); //run at 100 hz.
    2e16:	8b e1       	ldi	r24, 0x1B	; 27
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2e1e:	9e 8f       	std	Y+30, r25	; 0x1e
    2e20:	8d 8f       	std	Y+29, r24	; 0x1d
    2e22:	68 94       	set
    2e24:	cc 24       	eor	r12, r12
    2e26:	c1 f8       	bld	r12, 1
    2e28:	d1 2c       	mov	r13, r1
    2e2a:	0f 2e       	mov	r0, r31
    2e2c:	f5 e0       	ldi	r31, 0x05	; 5
    2e2e:	ef 2e       	mov	r14, r31
    2e30:	f1 2c       	mov	r15, r1
    2e32:	f0 2d       	mov	r31, r0
    2e34:	84 01       	movw	r16, r8
    2e36:	92 01       	movw	r18, r4
    2e38:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e3a:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e3c:	6d 85       	ldd	r22, Y+13	; 0x0d
    2e3e:	7e 85       	ldd	r23, Y+14	; 0x0e
    2e40:	0e 94 06 56 	call	0xac0c	; 0xac0c <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>
	pvNavTask = new PVNavigationTask(newBarometerSensorReadPeriod, ahrs, model, 6, (SCHEDULER_TICK_FREQUENCY_HZ * barometerSensorReadPeriod)); //run at 50 hz
    2e44:	8f e0       	ldi	r24, 0x0F	; 15
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2e4c:	98 a3       	std	Y+32, r25	; 0x20
    2e4e:	8f 8f       	std	Y+31, r24	; 0x1f
    2e50:	20 e0       	ldi	r18, 0x00	; 0
    2e52:	30 e0       	ldi	r19, 0x00	; 0
    2e54:	48 e4       	ldi	r20, 0x48	; 72
    2e56:	53 e4       	ldi	r21, 0x43	; 67
    2e58:	6b 85       	ldd	r22, Y+11	; 0x0b
    2e5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    2e5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e60:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    2e64:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    2e68:	6b 01       	movw	r12, r22
    2e6a:	0f 2e       	mov	r0, r31
    2e6c:	f6 e0       	ldi	r31, 0x06	; 6
    2e6e:	ef 2e       	mov	r14, r31
    2e70:	f1 2c       	mov	r15, r1
    2e72:	f0 2d       	mov	r31, r0
    2e74:	92 01       	movw	r18, r4
    2e76:	49 89       	ldd	r20, Y+17	; 0x11
    2e78:	5a 89       	ldd	r21, Y+18	; 0x12
    2e7a:	6b 89       	ldd	r22, Y+19	; 0x13
    2e7c:	7c 89       	ldd	r23, Y+20	; 0x14
    2e7e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e80:	98 a1       	ldd	r25, Y+32	; 0x20
    2e82:	0e 94 9b 58 	call	0xb136	; 0xb136 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>



	SPIDriver *spiDriver = new SPIDriver();
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	90 e0       	ldi	r25, 0x00	; 0
    2e8a:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2e8e:	8c 01       	movw	r16, r24
				SLAVE_SELECT_LINE ssLine;
			
			public: 
			
				SPIDriver(SLAVE_SELECT_LINE ssLine = SS_B):
					ssLine(ssLine)
    2e90:	21 e0       	ldi	r18, 0x01	; 1
    2e92:	fc 01       	movw	r30, r24
    2e94:	20 83       	st	Z, r18
	spiDriver->init();
    2e96:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	SPIDriver *baroSpiDriver = new SPIDriver(SPIDriver::SS_G);
    2e9a:	81 e0       	ldi	r24, 0x01	; 1
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2ea2:	9c 87       	std	Y+12, r25	; 0x0c
    2ea4:	8b 87       	std	Y+11, r24	; 0x0b
    2ea6:	82 e0       	ldi	r24, 0x02	; 2
    2ea8:	ab 85       	ldd	r26, Y+11	; 0x0b
    2eaa:	bc 85       	ldd	r27, Y+12	; 0x0c
    2eac:	8c 93       	st	X, r24
	baroSpiDriver->init();
    2eae:	cd 01       	movw	r24, r26
    2eb0:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <_ZN10helicopter7drivers9SPIDriver4initEv>
	
	IMUSensor *imuSensor = new IMUSensor(spiDriver);
    2eb4:	88 e5       	ldi	r24, 0x58	; 88
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2ebc:	1c 01       	movw	r2, r24
					frdAccZMss(0),
					frdGyroXRs(0),
					frdGyroYRs(0),
					frdGyroZRs(0),
					hasBeenRead(true),
					missedRead(false)
    2ebe:	fc 01       	movw	r30, r24
    2ec0:	15 a3       	std	Z+37, r17	; 0x25
    2ec2:	04 a3       	std	Z+36, r16	; 0x24
    2ec4:	17 a2       	std	Z+39, r1	; 0x27
    2ec6:	16 a2       	std	Z+38, r1	; 0x26
    2ec8:	11 a6       	std	Z+41, r1	; 0x29
    2eca:	10 a6       	std	Z+40, r1	; 0x28
    2ecc:	13 a6       	std	Z+43, r1	; 0x2b
    2ece:	12 a6       	std	Z+42, r1	; 0x2a
    2ed0:	15 a6       	std	Z+45, r1	; 0x2d
    2ed2:	14 a6       	std	Z+44, r1	; 0x2c
    2ed4:	17 a6       	std	Z+47, r1	; 0x2f
    2ed6:	16 a6       	std	Z+46, r1	; 0x2e
    2ed8:	11 aa       	std	Z+49, r1	; 0x31
    2eda:	10 aa       	std	Z+48, r1	; 0x30
    2edc:	12 aa       	std	Z+50, r1	; 0x32
    2ede:	13 aa       	std	Z+51, r1	; 0x33
    2ee0:	14 aa       	std	Z+52, r1	; 0x34
    2ee2:	15 aa       	std	Z+53, r1	; 0x35
    2ee4:	16 aa       	std	Z+54, r1	; 0x36
    2ee6:	17 aa       	std	Z+55, r1	; 0x37
    2ee8:	10 ae       	std	Z+56, r1	; 0x38
    2eea:	11 ae       	std	Z+57, r1	; 0x39
    2eec:	12 ae       	std	Z+58, r1	; 0x3a
    2eee:	13 ae       	std	Z+59, r1	; 0x3b
    2ef0:	14 ae       	std	Z+60, r1	; 0x3c
    2ef2:	15 ae       	std	Z+61, r1	; 0x3d
    2ef4:	fe 96       	adiw	r30, 0x3e	; 62
    2ef6:	10 82       	st	Z, r1
    2ef8:	11 82       	std	Z+1, r1	; 0x01
    2efa:	12 82       	std	Z+2, r1	; 0x02
    2efc:	13 82       	std	Z+3, r1	; 0x03
    2efe:	fc 01       	movw	r30, r24
    2f00:	ee 5b       	subi	r30, 0xBE	; 190
    2f02:	ff 4f       	sbci	r31, 0xFF	; 255
    2f04:	10 82       	st	Z, r1
    2f06:	11 82       	std	Z+1, r1	; 0x01
    2f08:	12 82       	std	Z+2, r1	; 0x02
    2f0a:	13 82       	std	Z+3, r1	; 0x03
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	ea 5b       	subi	r30, 0xBA	; 186
    2f10:	ff 4f       	sbci	r31, 0xFF	; 255
    2f12:	10 82       	st	Z, r1
    2f14:	11 82       	std	Z+1, r1	; 0x01
    2f16:	12 82       	std	Z+2, r1	; 0x02
    2f18:	13 82       	std	Z+3, r1	; 0x03
    2f1a:	fc 01       	movw	r30, r24
    2f1c:	e6 5b       	subi	r30, 0xB6	; 182
    2f1e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f20:	b1 e0       	ldi	r27, 0x01	; 1
    2f22:	b0 83       	st	Z, r27
    2f24:	fc 01       	movw	r30, r24
    2f26:	e5 5b       	subi	r30, 0xB5	; 181
    2f28:	ff 4f       	sbci	r31, 0xFF	; 255
    2f2a:	10 82       	st	Z, r1
					/**
					 * Create a rotation matrix to rotate the accelerometer sensor data by
					 * 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
					 * clockwise on the Z axis.
					 */
					memset(imuRFUToFRDRotationMatrix,0,sizeof(imuRFUToFRDRotationMatrix));
    2f2c:	e8 2f       	mov	r30, r24
    2f2e:	f3 2d       	mov	r31, r3
    2f30:	84 e2       	ldi	r24, 0x24	; 36
    2f32:	df 01       	movw	r26, r30
    2f34:	1d 92       	st	X+, r1
    2f36:	8a 95       	dec	r24
    2f38:	e9 f7       	brne	.-6      	; 0x2f34 <main+0x6be>
					
					MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, (M_PI/2), imuRFUToFRDRotationMatrix);
    2f3a:	c2 2c       	mov	r12, r2
    2f3c:	d3 2c       	mov	r13, r3
    2f3e:	1b ed       	ldi	r17, 0xDB	; 219
    2f40:	e1 2e       	mov	r14, r17
    2f42:	1f e0       	ldi	r17, 0x0F	; 15
    2f44:	f1 2e       	mov	r15, r17
    2f46:	09 ec       	ldi	r16, 0xC9	; 201
    2f48:	1f e3       	ldi	r17, 0x3F	; 63
    2f4a:	20 e0       	ldi	r18, 0x00	; 0
    2f4c:	30 e0       	ldi	r19, 0x00	; 0
    2f4e:	a9 01       	movw	r20, r18
    2f50:	6b ed       	ldi	r22, 0xDB	; 219
    2f52:	7f e0       	ldi	r23, 0x0F	; 15
    2f54:	89 e4       	ldi	r24, 0x49	; 73
    2f56:	90 e4       	ldi	r25, 0x40	; 64
    2f58:	0e 94 17 67 	call	0xce2e	; 0xce2e <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
					
					gyroOffsets[0] = 0;
    2f5c:	f1 01       	movw	r30, r2
    2f5e:	e4 5b       	subi	r30, 0xB4	; 180
    2f60:	ff 4f       	sbci	r31, 0xFF	; 255
    2f62:	10 82       	st	Z, r1
    2f64:	11 82       	std	Z+1, r1	; 0x01
    2f66:	12 82       	std	Z+2, r1	; 0x02
    2f68:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[1] = 0;
    2f6a:	f1 01       	movw	r30, r2
    2f6c:	e0 5b       	subi	r30, 0xB0	; 176
    2f6e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f70:	10 82       	st	Z, r1
    2f72:	11 82       	std	Z+1, r1	; 0x01
    2f74:	12 82       	std	Z+2, r1	; 0x02
    2f76:	13 82       	std	Z+3, r1	; 0x03
					gyroOffsets[2] = 0;
    2f78:	f1 01       	movw	r30, r2
    2f7a:	ec 5a       	subi	r30, 0xAC	; 172
    2f7c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f7e:	10 82       	st	Z, r1
    2f80:	11 82       	std	Z+1, r1	; 0x01
    2f82:	12 82       	std	Z+2, r1	; 0x02
    2f84:	13 82       	std	Z+3, r1	; 0x03
	imuSensor->init();
    2f86:	c1 01       	movw	r24, r2
    2f88:	0e 94 c0 4d 	call	0x9b80	; 0x9b80 <_ZN10helicopter7sensors9IMUSensor4initEv>

	GPSSensor *gpsSensor = new GPSSensor(gpsSerialDriver);
    2f8c:	8b e2       	ldi	r24, 0x2B	; 43
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    2f94:	2c 01       	movw	r4, r24
					positionAccuracyEstimateEcefCm (0),
					xVEcefCms(0),
					yVEcefCms(0),
					zVEcefCms(0),
					velocityAccuracyEstimateEcefCms (0),
					positionFixStatus(INVALID)
    2f96:	29 85       	ldd	r18, Y+9	; 0x09
    2f98:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f9a:	fc 01       	movw	r30, r24
    2f9c:	31 83       	std	Z+1, r19	; 0x01
    2f9e:	20 83       	st	Z, r18
    2fa0:	12 82       	std	Z+2, r1	; 0x02
    2fa2:	13 82       	std	Z+3, r1	; 0x03
    2fa4:	14 82       	std	Z+4, r1	; 0x04
    2fa6:	15 82       	std	Z+5, r1	; 0x05
    2fa8:	16 82       	std	Z+6, r1	; 0x06
    2faa:	17 82       	std	Z+7, r1	; 0x07
    2fac:	10 86       	std	Z+8, r1	; 0x08
    2fae:	11 86       	std	Z+9, r1	; 0x09
    2fb0:	12 86       	std	Z+10, r1	; 0x0a
    2fb2:	13 86       	std	Z+11, r1	; 0x0b
    2fb4:	14 86       	std	Z+12, r1	; 0x0c
    2fb6:	15 86       	std	Z+13, r1	; 0x0d
    2fb8:	16 86       	std	Z+14, r1	; 0x0e
    2fba:	17 86       	std	Z+15, r1	; 0x0f
    2fbc:	10 8a       	std	Z+16, r1	; 0x10
    2fbe:	11 8a       	std	Z+17, r1	; 0x11
    2fc0:	12 8a       	std	Z+18, r1	; 0x12
    2fc2:	13 8a       	std	Z+19, r1	; 0x13
    2fc4:	14 8a       	std	Z+20, r1	; 0x14
    2fc6:	15 8a       	std	Z+21, r1	; 0x15
    2fc8:	16 8a       	std	Z+22, r1	; 0x16
    2fca:	17 8a       	std	Z+23, r1	; 0x17
    2fcc:	10 8e       	std	Z+24, r1	; 0x18
    2fce:	11 8e       	std	Z+25, r1	; 0x19
    2fd0:	12 8e       	std	Z+26, r1	; 0x1a
    2fd2:	13 8e       	std	Z+27, r1	; 0x1b
    2fd4:	14 8e       	std	Z+28, r1	; 0x1c
    2fd6:	15 8e       	std	Z+29, r1	; 0x1d
    2fd8:	16 8e       	std	Z+30, r1	; 0x1e
    2fda:	17 8e       	std	Z+31, r1	; 0x1f
    2fdc:	10 a2       	std	Z+32, r1	; 0x20
    2fde:	11 a2       	std	Z+33, r1	; 0x21
    2fe0:	12 a2       	std	Z+34, r1	; 0x22
    2fe2:	13 a2       	std	Z+35, r1	; 0x23
    2fe4:	14 a2       	std	Z+36, r1	; 0x24
    2fe6:	15 a2       	std	Z+37, r1	; 0x25
    2fe8:	16 a2       	std	Z+38, r1	; 0x26
    2fea:	17 a2       	std	Z+39, r1	; 0x27
    2fec:	10 a6       	std	Z+40, r1	; 0x28
    2fee:	11 a6       	std	Z+41, r1	; 0x29
    2ff0:	21 e0       	ldi	r18, 0x01	; 1
    2ff2:	22 a7       	std	Z+42, r18	; 0x2a
	gpsSensor->init();
    2ff4:	0e 94 71 4b 	call	0x96e2	; 0x96e2 <_ZN10helicopter7sensors9GPSSensor4initEv>

	BarometerSensor *baroSensor = new BarometerSensor(baroSpiDriver);
    2ff8:	82 e4       	ldi	r24, 0x42	; 66
    2ffa:	90 e0       	ldi	r25, 0x00	; 0
    2ffc:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    3000:	7c 01       	movw	r14, r24
					pressureSensitivity_SENSt1_C1(0),
					pressureSensitivityOffset_OFFt1_C2(0),
					temperatureCoefficientOfPressureSensitivity_TCS_C3(0),
					temperatureCoefficientOfPressureOffset_TCO_C4(0),
					referenceTemperature_Tref_C5(0),
					temperatureCoefficientOfTheTemperature_TEMPSENS_C6(0)
    3002:	eb 85       	ldd	r30, Y+11	; 0x0b
    3004:	fc 85       	ldd	r31, Y+12	; 0x0c
    3006:	dc 01       	movw	r26, r24
    3008:	11 96       	adiw	r26, 0x01	; 1
    300a:	fc 93       	st	X, r31
    300c:	ee 93       	st	-X, r30
    300e:	12 96       	adiw	r26, 0x02	; 2
    3010:	1d 92       	st	X+, r1
    3012:	1d 92       	st	X+, r1
    3014:	1d 92       	st	X+, r1
    3016:	1c 92       	st	X, r1
    3018:	15 97       	sbiw	r26, 0x05	; 5
    301a:	fc 01       	movw	r30, r24
    301c:	16 82       	std	Z+6, r1	; 0x06
    301e:	17 82       	std	Z+7, r1	; 0x07
    3020:	10 86       	std	Z+8, r1	; 0x08
    3022:	11 86       	std	Z+9, r1	; 0x09
    3024:	1a 96       	adiw	r26, 0x0a	; 10
    3026:	1d 92       	st	X+, r1
    3028:	1d 92       	st	X+, r1
    302a:	1d 92       	st	X+, r1
    302c:	1c 92       	st	X, r1
    302e:	1d 97       	sbiw	r26, 0x0d	; 13
    3030:	16 86       	std	Z+14, r1	; 0x0e
    3032:	17 86       	std	Z+15, r1	; 0x0f
    3034:	10 8a       	std	Z+16, r1	; 0x10
    3036:	11 8a       	std	Z+17, r1	; 0x11
    3038:	12 8a       	std	Z+18, r1	; 0x12
    303a:	13 8a       	std	Z+19, r1	; 0x13
    303c:	14 8a       	std	Z+20, r1	; 0x14
    303e:	15 8a       	std	Z+21, r1	; 0x15
    3040:	16 8a       	std	Z+22, r1	; 0x16
    3042:	17 8a       	std	Z+23, r1	; 0x17
    3044:	10 8e       	std	Z+24, r1	; 0x18
    3046:	11 8e       	std	Z+25, r1	; 0x19
    3048:	12 8e       	std	Z+26, r1	; 0x1a
    304a:	13 8e       	std	Z+27, r1	; 0x1b
    304c:	14 8e       	std	Z+28, r1	; 0x1c
    304e:	15 8e       	std	Z+29, r1	; 0x1d
    3050:	16 8e       	std	Z+30, r1	; 0x1e
    3052:	17 8e       	std	Z+31, r1	; 0x1f
    3054:	10 a2       	std	Z+32, r1	; 0x20
    3056:	11 a2       	std	Z+33, r1	; 0x21
    3058:	12 a2       	std	Z+34, r1	; 0x22
    305a:	13 a2       	std	Z+35, r1	; 0x23
    305c:	14 a2       	std	Z+36, r1	; 0x24
    305e:	15 a2       	std	Z+37, r1	; 0x25
    3060:	16 a2       	std	Z+38, r1	; 0x26
    3062:	17 a2       	std	Z+39, r1	; 0x27
    3064:	10 a6       	std	Z+40, r1	; 0x28
    3066:	11 a6       	std	Z+41, r1	; 0x29
    3068:	12 a6       	std	Z+42, r1	; 0x2a
    306a:	13 a6       	std	Z+43, r1	; 0x2b
    306c:	14 a6       	std	Z+44, r1	; 0x2c
    306e:	15 a6       	std	Z+45, r1	; 0x2d
    3070:	16 a6       	std	Z+46, r1	; 0x2e
    3072:	17 a6       	std	Z+47, r1	; 0x2f
    3074:	10 aa       	std	Z+48, r1	; 0x30
    3076:	11 aa       	std	Z+49, r1	; 0x31
    3078:	12 aa       	std	Z+50, r1	; 0x32
    307a:	13 aa       	std	Z+51, r1	; 0x33
    307c:	14 aa       	std	Z+52, r1	; 0x34
    307e:	15 aa       	std	Z+53, r1	; 0x35
    3080:	16 aa       	std	Z+54, r1	; 0x36
    3082:	17 aa       	std	Z+55, r1	; 0x37
    3084:	10 ae       	std	Z+56, r1	; 0x38
    3086:	11 ae       	std	Z+57, r1	; 0x39
    3088:	fa 96       	adiw	r30, 0x3a	; 58
    308a:	da 96       	adiw	r26, 0x3a	; 58
    308c:	1c 92       	st	X, r1
    308e:	11 82       	std	Z+1, r1	; 0x01
    3090:	12 82       	std	Z+2, r1	; 0x02
    3092:	13 82       	std	Z+3, r1	; 0x03
    3094:	14 82       	std	Z+4, r1	; 0x04
    3096:	15 82       	std	Z+5, r1	; 0x05
    3098:	16 82       	std	Z+6, r1	; 0x06
    309a:	17 82       	std	Z+7, r1	; 0x07
	baroSensor->init();
    309c:	0e 94 9d 43 	call	0x873a	; 0x873a <_ZN10helicopter7sensors15BarometerSensor4initEv>
	
	MagnetometerSensor *magSensor = new MagnetometerSensor(twiDriver);
    30a0:	88 e3       	ldi	r24, 0x38	; 56
    30a2:	90 e0       	ldi	r25, 0x00	; 0
    30a4:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    30a8:	9a 8b       	std	Y+18, r25	; 0x12
    30aa:	89 8b       	std	Y+17, r24	; 0x11
    30ac:	69 a1       	ldd	r22, Y+33	; 0x21
    30ae:	7a a1       	ldd	r23, Y+34	; 0x22
    30b0:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>
	magSensor->init();
    30b4:	89 89       	ldd	r24, Y+17	; 0x11
    30b6:	9a 89       	ldd	r25, Y+18	; 0x12
    30b8:	0e 94 20 52 	call	0xa440	; 0xa440 <_ZN10helicopter7sensors18MagnetometerSensor4initEv>
	_delay_ms(200);
	*/

	
	//ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .25); //run at 4 hz
	ReadGPSSensorTask *gpsSensorTask = new ReadGPSSensorTask(model, gpsSensor, 7, SCHEDULER_TICK_FREQUENCY_HZ * .1); //run at 10 hz
    30bc:	8c e0       	ldi	r24, 0x0C	; 12
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    30c4:	9a 87       	std	Y+10, r25	; 0x0a
    30c6:	89 87       	std	Y+9, r24	; 0x09
    30c8:	04 e1       	ldi	r16, 0x14	; 20
    30ca:	10 e0       	ldi	r17, 0x00	; 0
    30cc:	27 e0       	ldi	r18, 0x07	; 7
    30ce:	30 e0       	ldi	r19, 0x00	; 0
    30d0:	a2 01       	movw	r20, r4
    30d2:	b4 01       	movw	r22, r8
    30d4:	0e 94 d4 59 	call	0xb3a8	; 0xb3a8 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
	ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz.
    30d8:	8b e0       	ldi	r24, 0x0B	; 11
    30da:	90 e0       	ldi	r25, 0x00	; 0
    30dc:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    30e0:	9c 87       	std	Y+12, r25	; 0x0c
    30e2:	8b 87       	std	Y+11, r24	; 0x0b
    30e4:	02 e0       	ldi	r16, 0x02	; 2
    30e6:	10 e0       	ldi	r17, 0x00	; 0
    30e8:	28 e0       	ldi	r18, 0x08	; 8
    30ea:	30 e0       	ldi	r19, 0x00	; 0
    30ec:	a1 01       	movw	r20, r2
    30ee:	b4 01       	movw	r22, r8
    30f0:	0e 94 6d 5a 	call	0xb4da	; 0xb4da <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>
	//ReadIMUSensorTask *imuSensorTask = new ReadIMUSensorTask(model, imuSensor, 8,  2); //run at 100 hz.
	ReadBarometerSensorTask *barometerSensorTask = new ReadBarometerSensorTask(model, baroSensor, 9, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz. needs to run so that at least 10 ms is between each operation. since it's a 3 step process, this is really only executes hz/3 for a complete cycle (*** this will probably cause huge timeouts since it takes like 8ms to complete.)
    30f4:	8d e0       	ldi	r24, 0x0D	; 13
    30f6:	90 e0       	ldi	r25, 0x00	; 0
    30f8:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    30fc:	6c 01       	movw	r12, r24
    30fe:	04 e0       	ldi	r16, 0x04	; 4
    3100:	10 e0       	ldi	r17, 0x00	; 0
    3102:	29 e0       	ldi	r18, 0x09	; 9
    3104:	30 e0       	ldi	r19, 0x00	; 0
    3106:	a7 01       	movw	r20, r14
    3108:	b4 01       	movw	r22, r8
    310a:	0e 94 2f 59 	call	0xb25e	; 0xb25e <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>
	//ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz, although the sensor is reading at 75 hz.
	ReadMagnetometerSensorTask *magSensorTask = new ReadMagnetometerSensorTask(model, magSensor, 10, (SCHEDULER_TICK_FREQUENCY_HZ * .01)); //run at 100 hz, although the sensor is reading at 75 hz.
    310e:	8b e0       	ldi	r24, 0x0B	; 11
    3110:	90 e0       	ldi	r25, 0x00	; 0
    3112:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    3116:	7c 01       	movw	r14, r24
    3118:	02 e0       	ldi	r16, 0x02	; 2
    311a:	10 e0       	ldi	r17, 0x00	; 0
    311c:	2a e0       	ldi	r18, 0x0A	; 10
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	49 89       	ldd	r20, Y+17	; 0x11
    3122:	5a 89       	ldd	r21, Y+18	; 0x12
    3124:	b4 01       	movw	r22, r8
    3126:	0e 94 e6 5a 	call	0xb5cc	; 0xb5cc <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>
	

	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    312a:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    312e:	1c 01       	movw	r2, r24
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
				void SetSystemModel(SystemModel *val) { systemModel = val; }
    3130:	fc 01       	movw	r30, r24
    3132:	e9 5a       	subi	r30, 0xA9	; 169
    3134:	ff 4f       	sbci	r31, 0xFF	; 255
    3136:	91 82       	std	Z+1, r9	; 0x01
    3138:	80 82       	st	Z, r8
	
	rcInterface->SetSystemModel(model);

	ServoControlTask *servoControlTask = new ServoControlTask(model, rcInterface, 11,  (SCHEDULER_TICK_FREQUENCY_HZ * .02)); //run at 50 hz.
    313a:	8b e0       	ldi	r24, 0x0B	; 11
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    3142:	04 e0       	ldi	r16, 0x04	; 4
    3144:	10 e0       	ldi	r17, 0x00	; 0
    3146:	2b e0       	ldi	r18, 0x0B	; 11
    3148:	30 e0       	ldi	r19, 0x00	; 0
    314a:	a1 01       	movw	r20, r2
    314c:	b4 01       	movw	r22, r8
    314e:	0e 94 57 5b 	call	0xb6ae	; 0xb6ae <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>
	
	
	scheduler->addTask(flashTask);
    3152:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3154:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3156:	8f a1       	ldd	r24, Y+39	; 0x27
    3158:	98 a5       	ldd	r25, Y+40	; 0x28
    315a:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(gpsSensorTask);
    315e:	69 85       	ldd	r22, Y+9	; 0x09
    3160:	7a 85       	ldd	r23, Y+10	; 0x0a
    3162:	8f a1       	ldd	r24, Y+39	; 0x27
    3164:	98 a5       	ldd	r25, Y+40	; 0x28
    3166:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(imuSensorTask);
    316a:	6b 85       	ldd	r22, Y+11	; 0x0b
    316c:	7c 85       	ldd	r23, Y+12	; 0x0c
    316e:	8f a1       	ldd	r24, Y+39	; 0x27
    3170:	98 a5       	ldd	r25, Y+40	; 0x28
    3172:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(barometerSensorTask);
    3176:	b6 01       	movw	r22, r12
    3178:	8f a1       	ldd	r24, Y+39	; 0x27
    317a:	98 a5       	ldd	r25, Y+40	; 0x28
    317c:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(magSensorTask);
    3180:	b7 01       	movw	r22, r14
    3182:	8f a1       	ldd	r24, Y+39	; 0x27
    3184:	98 a5       	ldd	r25, Y+40	; 0x28
    3186:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>

	if (model->SensorInput() == SystemModel::SimulatedSensors || receiveGains == true)
	//if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		//Add a task to read simulator data if setup to receive sensor data from the simulator.
		scheduler->addTask(simTelemTask);
    318a:	69 81       	ldd	r22, Y+1	; 0x01
    318c:	7a 81       	ldd	r23, Y+2	; 0x02
    318e:	8f a1       	ldd	r24, Y+39	; 0x27
    3190:	98 a5       	ldd	r25, Y+40	; 0x28
    3192:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	}
	*/
	
	
	
	scheduler->addTask(transTelemTask);
    3196:	6d 81       	ldd	r22, Y+5	; 0x05
    3198:	7e 81       	ldd	r23, Y+6	; 0x06
    319a:	8f a1       	ldd	r24, Y+39	; 0x27
    319c:	98 a5       	ldd	r25, Y+40	; 0x28
    319e:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidOuterLoop);
    31a2:	6b a1       	ldd	r22, Y+35	; 0x23
    31a4:	7c a1       	ldd	r23, Y+36	; 0x24
    31a6:	8f a1       	ldd	r24, Y+39	; 0x27
    31a8:	98 a5       	ldd	r25, Y+40	; 0x28
    31aa:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	scheduler->addTask(pidInnerLoop);
    31ae:	6d a1       	ldd	r22, Y+37	; 0x25
    31b0:	7e a1       	ldd	r23, Y+38	; 0x26
    31b2:	8f a1       	ldd	r24, Y+39	; 0x27
    31b4:	98 a5       	ldd	r25, Y+40	; 0x28
    31b6:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	
	
	scheduler->addTask(navTask);
    31ba:	6d 8d       	ldd	r22, Y+29	; 0x1d
    31bc:	7e 8d       	ldd	r23, Y+30	; 0x1e
    31be:	8f a1       	ldd	r24, Y+39	; 0x27
    31c0:	98 a5       	ldd	r25, Y+40	; 0x28
    31c2:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
	scheduler->addTask(pvNavTask);
    31c6:	6f 8d       	ldd	r22, Y+31	; 0x1f
    31c8:	78 a1       	ldd	r23, Y+32	; 0x20
    31ca:	8f a1       	ldd	r24, Y+39	; 0x27
    31cc:	98 a5       	ldd	r25, Y+40	; 0x28
    31ce:	0e 94 6a 42 	call	0x84d4	; 0x84d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    31d2:	21 e0       	ldi	r18, 0x01	; 1
    31d4:	f4 01       	movw	r30, r8
    31d6:	22 83       	std	Z+2, r18	; 0x02
		model->OperationalState(SystemModel::AutoPilot);
	}
	
	

	PORTA |= (1<<PA4);
    31d8:	14 9a       	sbi	0x02, 4	; 2
	
	//Set the red led to 'on' to indicate the system is initializing. I have this down here because there is a bug which might lock up the system when the GPS initializes, so
	//we turn on the red led after that bug can take place so we know we past that point in the init sequence. 
	DDRA |= (1<<PA5);
    31da:	0d 9a       	sbi	0x01, 5	; 1
	PORTA &= ~(1<<PA5);
    31dc:	15 98       	cbi	0x02, 5	; 2
	
	
	/**
	 * Set initial position.
	 */
	if (model->SensorInput() == SystemModel::RealSensors)
    31de:	84 81       	ldd	r24, Z+4	; 0x04
    31e0:	81 30       	cpi	r24, 0x01	; 1
    31e2:	09 f0       	breq	.+2      	; 0x31e6 <main+0x970>
    31e4:	45 c2       	rjmp	.+1162   	; 0x3670 <main+0xdfa>
    31e6:	0f a1       	ldd	r16, Y+39	; 0x27
    31e8:	18 a5       	ldd	r17, Y+40	; 0x28
    31ea:	15 01       	movw	r2, r10
    31ec:	80 c0       	rjmp	.+256    	; 0x32ee <main+0xa78>
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
    31ee:	c2 01       	movw	r24, r4
    31f0:	0e 94 1c 4b 	call	0x9638	; 0x9638 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
			gpsSensor->readSensorNavStatus();
    31f4:	c2 01       	movw	r24, r4
    31f6:	0e 94 e2 4a 	call	0x95c4	; 0x95c4 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>
			long status = gpsSensor->readSensorSolution();
    31fa:	c2 01       	movw	r24, r4
    31fc:	0e 94 1f 4a 	call	0x943e	; 0x943e <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>
    3200:	5c 01       	movw	r10, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3202:	3f ef       	ldi	r19, 0xFF	; 255
    3204:	44 e3       	ldi	r20, 0x34	; 52
    3206:	5c e0       	ldi	r21, 0x0C	; 12
    3208:	31 50       	subi	r19, 0x01	; 1
    320a:	40 40       	sbci	r20, 0x00	; 0
    320c:	50 40       	sbci	r21, 0x00	; 0
    320e:	e1 f7       	brne	.-8      	; 0x3208 <main+0x992>
    3210:	00 c0       	rjmp	.+0      	; 0x3212 <main+0x99c>
    3212:	00 00       	nop
					//long status = gpsSensor->readSensorNavStatus();
					long status = gpsSensor->readSensorSolution();*/
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
    3214:	d1 01       	movw	r26, r2
    3216:	ed 91       	ld	r30, X+
    3218:	fc 91       	ld	r31, X
    321a:	06 80       	ldd	r0, Z+6	; 0x06
    321c:	f7 81       	ldd	r31, Z+7	; 0x07
    321e:	e0 2d       	mov	r30, r0
    3220:	64 e5       	ldi	r22, 0x54	; 84
    3222:	c1 01       	movw	r24, r2
    3224:	19 95       	eicall
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    3226:	d1 01       	movw	r26, r2
    3228:	ed 91       	ld	r30, X+
    322a:	fc 91       	ld	r31, X
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
		{
			//gpsSensor->processSensorSolution();
			gpsSensor->readSensorLLH();
			gpsSensor->readSensorNavStatus();
			long status = gpsSensor->readSensorSolution();
    322c:	a5 01       	movw	r20, r10
    322e:	66 27       	eor	r22, r22
    3230:	57 fd       	sbrc	r21, 7
    3232:	60 95       	com	r22
    3234:	76 2f       	mov	r23, r22
			
			//Wait until new data is received from the GPS
			_delay_ms(250);
			serialDriver->transmit((byte) 'T');
					//serialDriver->transmit(gpsSensor->getLatitudeDegE7());
					serialDriver->transmit(status);
    3236:	04 84       	ldd	r0, Z+12	; 0x0c
    3238:	f5 85       	ldd	r31, Z+13	; 0x0d
    323a:	e0 2d       	mov	r30, r0
    323c:	c1 01       	movw	r24, r2
    323e:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getLongitudeDegE7());
    3240:	d1 01       	movw	r26, r2
    3242:	ed 91       	ld	r30, X+
    3244:	fc 91       	ld	r31, X
    3246:	d2 01       	movw	r26, r4
    3248:	16 96       	adiw	r26, 0x06	; 6
    324a:	4d 91       	ld	r20, X+
    324c:	5d 91       	ld	r21, X+
    324e:	6d 91       	ld	r22, X+
    3250:	7c 91       	ld	r23, X
    3252:	19 97       	sbiw	r26, 0x09	; 9
    3254:	04 84       	ldd	r0, Z+12	; 0x0c
    3256:	f5 85       	ldd	r31, Z+13	; 0x0d
    3258:	e0 2d       	mov	r30, r0
    325a:	c1 01       	movw	r24, r2
    325c:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionAccuracyEstimateEcefCm());
    325e:	d1 01       	movw	r26, r2
    3260:	ed 91       	ld	r30, X+
    3262:	fc 91       	ld	r31, X
    3264:	d2 01       	movw	r26, r4
    3266:	56 96       	adiw	r26, 0x16	; 22
    3268:	4d 91       	ld	r20, X+
    326a:	5d 91       	ld	r21, X+
    326c:	6d 91       	ld	r22, X+
    326e:	7c 91       	ld	r23, X
    3270:	59 97       	sbiw	r26, 0x19	; 25
    3272:	02 84       	ldd	r0, Z+10	; 0x0a
    3274:	f3 85       	ldd	r31, Z+11	; 0x0b
    3276:	e0 2d       	mov	r30, r0
    3278:	c1 01       	movw	r24, r2
    327a:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getPositionFixStatus());
    327c:	d1 01       	movw	r26, r2
    327e:	ed 91       	ld	r30, X+
    3280:	fc 91       	ld	r31, X
    3282:	d2 01       	movw	r26, r4
    3284:	9a 96       	adiw	r26, 0x2a	; 42
    3286:	6c 91       	ld	r22, X
    3288:	00 84       	ldd	r0, Z+8	; 0x08
    328a:	f1 85       	ldd	r31, Z+9	; 0x09
    328c:	e0 2d       	mov	r30, r0
    328e:	70 e0       	ldi	r23, 0x00	; 0
    3290:	c1 01       	movw	r24, r2
    3292:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getXEcefCm());
    3294:	d1 01       	movw	r26, r2
    3296:	ed 91       	ld	r30, X+
    3298:	fc 91       	ld	r31, X
    329a:	d2 01       	movw	r26, r4
    329c:	1a 96       	adiw	r26, 0x0a	; 10
    329e:	4d 91       	ld	r20, X+
    32a0:	5d 91       	ld	r21, X+
    32a2:	6d 91       	ld	r22, X+
    32a4:	7c 91       	ld	r23, X
    32a6:	1d 97       	sbiw	r26, 0x0d	; 13
    32a8:	04 84       	ldd	r0, Z+12	; 0x0c
    32aa:	f5 85       	ldd	r31, Z+13	; 0x0d
    32ac:	e0 2d       	mov	r30, r0
    32ae:	c1 01       	movw	r24, r2
    32b0:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getYEcefCm());
    32b2:	d1 01       	movw	r26, r2
    32b4:	ed 91       	ld	r30, X+
    32b6:	fc 91       	ld	r31, X
    32b8:	d2 01       	movw	r26, r4
    32ba:	1e 96       	adiw	r26, 0x0e	; 14
    32bc:	4d 91       	ld	r20, X+
    32be:	5d 91       	ld	r21, X+
    32c0:	6d 91       	ld	r22, X+
    32c2:	7c 91       	ld	r23, X
    32c4:	51 97       	sbiw	r26, 0x11	; 17
    32c6:	04 84       	ldd	r0, Z+12	; 0x0c
    32c8:	f5 85       	ldd	r31, Z+13	; 0x0d
    32ca:	e0 2d       	mov	r30, r0
    32cc:	c1 01       	movw	r24, r2
    32ce:	19 95       	eicall
					serialDriver->transmit(gpsSensor->getZEcefCm());
    32d0:	d1 01       	movw	r26, r2
    32d2:	ed 91       	ld	r30, X+
    32d4:	fc 91       	ld	r31, X
    32d6:	d2 01       	movw	r26, r4
    32d8:	52 96       	adiw	r26, 0x12	; 18
    32da:	4d 91       	ld	r20, X+
    32dc:	5d 91       	ld	r21, X+
    32de:	6d 91       	ld	r22, X+
    32e0:	7c 91       	ld	r23, X
    32e2:	55 97       	sbiw	r26, 0x15	; 21
    32e4:	04 84       	ldd	r0, Z+12	; 0x0c
    32e6:	f5 85       	ldd	r31, Z+13	; 0x0d
    32e8:	e0 2d       	mov	r30, r0
    32ea:	c1 01       	movw	r24, r2
    32ec:	19 95       	eicall
	if (model->SensorInput() == SystemModel::RealSensors)
	{		
	
		//Initialize GPS readings and position
		//while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > 400)
while (!gpsSensor->isGpsReady() || gpsSensor->getPositionAccuracyEstimateEcefCm() > gpsAcceptanceThreshold)		
    32ee:	c2 01       	movw	r24, r4
    32f0:	0e 94 0b 4c 	call	0x9816	; 0x9816 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>
    32f4:	88 23       	and	r24, r24
    32f6:	09 f4       	brne	.+2      	; 0x32fa <main+0xa84>
    32f8:	7a cf       	rjmp	.-268    	; 0x31ee <main+0x978>
    32fa:	f2 01       	movw	r30, r4
    32fc:	86 89       	ldd	r24, Z+22	; 0x16
    32fe:	97 89       	ldd	r25, Z+23	; 0x17
    3300:	a0 8d       	ldd	r26, Z+24	; 0x18
    3302:	b1 8d       	ldd	r27, Z+25	; 0x19
    3304:	2d 89       	ldd	r18, Y+21	; 0x15
    3306:	3e 89       	ldd	r19, Y+22	; 0x16
    3308:	4f 89       	ldd	r20, Y+23	; 0x17
    330a:	58 8d       	ldd	r21, Y+24	; 0x18
    330c:	28 17       	cp	r18, r24
    330e:	39 07       	cpc	r19, r25
    3310:	4a 07       	cpc	r20, r26
    3312:	5b 07       	cpc	r21, r27
    3314:	68 f4       	brcc	.+26     	; 0x3330 <main+0xaba>
    3316:	6b cf       	rjmp	.-298    	; 0x31ee <main+0x978>
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
		{
			gpsSensor->readSensorLLH();
    3318:	c2 01       	movw	r24, r4
    331a:	0e 94 1c 4b 	call	0x9638	; 0x9638 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>
    331e:	3f ef       	ldi	r19, 0xFF	; 255
    3320:	44 e3       	ldi	r20, 0x34	; 52
    3322:	5c e0       	ldi	r21, 0x0C	; 12
    3324:	31 50       	subi	r19, 0x01	; 1
    3326:	40 40       	sbci	r20, 0x00	; 0
    3328:	50 40       	sbci	r21, 0x00	; 0
    332a:	e1 f7       	brne	.-8      	; 0x3324 <main+0xaae>
    332c:	00 c0       	rjmp	.+0      	; 0x332e <main+0xab8>
    332e:	00 00       	nop
		
		//Turn off interrupts so that the gps sensor doesn't auto receive gps data which would
		//mess up the manual read.
		//cli();
		
		while(gpsSensor->getLatitudeDegE7() == 0 || gpsSensor->getLongitudeDegE7() == 0)
    3330:	f2 01       	movw	r30, r4
    3332:	82 81       	ldd	r24, Z+2	; 0x02
    3334:	93 81       	ldd	r25, Z+3	; 0x03
    3336:	a4 81       	ldd	r26, Z+4	; 0x04
    3338:	b5 81       	ldd	r27, Z+5	; 0x05
    333a:	89 2b       	or	r24, r25
    333c:	8a 2b       	or	r24, r26
    333e:	8b 2b       	or	r24, r27
    3340:	59 f3       	breq	.-42     	; 0x3318 <main+0xaa2>
    3342:	86 81       	ldd	r24, Z+6	; 0x06
    3344:	97 81       	ldd	r25, Z+7	; 0x07
    3346:	a0 85       	ldd	r26, Z+8	; 0x08
    3348:	b1 85       	ldd	r27, Z+9	; 0x09
    334a:	89 2b       	or	r24, r25
    334c:	8a 2b       	or	r24, r26
    334e:	8b 2b       	or	r24, r27
    3350:	19 f3       	breq	.-58     	; 0x3318 <main+0xaa2>
    3352:	18 a7       	std	Y+40, r17	; 0x28
    3354:	0f a3       	std	Y+39, r16	; 0x27
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    3356:	84 01       	movw	r16, r8
    3358:	02 54       	subi	r16, 0x42	; 66
    335a:	1f 4f       	sbci	r17, 0xFF	; 255
    335c:	62 85       	ldd	r22, Z+10	; 0x0a
    335e:	73 85       	ldd	r23, Z+11	; 0x0b
    3360:	84 85       	ldd	r24, Z+12	; 0x0c
    3362:	95 85       	ldd	r25, Z+13	; 0x0d
    3364:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    3368:	f8 01       	movw	r30, r16
    336a:	60 83       	st	Z, r22
    336c:	71 83       	std	Z+1, r23	; 0x01
    336e:	82 83       	std	Z+2, r24	; 0x02
    3370:	93 83       	std	Z+3, r25	; 0x03

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    3372:	84 01       	movw	r16, r8
    3374:	0e 53       	subi	r16, 0x3E	; 62
    3376:	1f 4f       	sbci	r17, 0xFF	; 255
    3378:	d2 01       	movw	r26, r4
    337a:	1e 96       	adiw	r26, 0x0e	; 14
    337c:	6d 91       	ld	r22, X+
    337e:	7d 91       	ld	r23, X+
    3380:	8d 91       	ld	r24, X+
    3382:	9c 91       	ld	r25, X
    3384:	51 97       	sbiw	r26, 0x11	; 17
    3386:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    338a:	f8 01       	movw	r30, r16
    338c:	60 83       	st	Z, r22
    338e:	71 83       	std	Z+1, r23	; 0x01
    3390:	82 83       	std	Z+2, r24	; 0x02
    3392:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    3394:	84 01       	movw	r16, r8
    3396:	0a 53       	subi	r16, 0x3A	; 58
    3398:	1f 4f       	sbci	r17, 0xFF	; 255
    339a:	d2 01       	movw	r26, r4
    339c:	52 96       	adiw	r26, 0x12	; 18
    339e:	6d 91       	ld	r22, X+
    33a0:	7d 91       	ld	r23, X+
    33a2:	8d 91       	ld	r24, X+
    33a4:	9c 91       	ld	r25, X
    33a6:	55 97       	sbiw	r26, 0x15	; 21
    33a8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    33ac:	f8 01       	movw	r30, r16
    33ae:	60 83       	st	Z, r22
    33b0:	71 83       	std	Z+1, r23	; 0x01
    33b2:	82 83       	std	Z+2, r24	; 0x02
    33b4:	93 83       	std	Z+3, r25	; 0x03
		model->InitialXPositionEcef(gpsSensor->getXEcefCm());
		model->InitialYPositionEcef(gpsSensor->getYEcefCm());
		model->InitialZPositionEcef(gpsSensor->getZEcefCm());
		
		//generate ecef to ned rotation matrix based on current lat/long			
		CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    33b6:	84 01       	movw	r16, r8
    33b8:	02 5e       	subi	r16, 0xE2	; 226
    33ba:	1e 4f       	sbci	r17, 0xFE	; 254
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    33bc:	f4 01       	movw	r30, r8
    33be:	ea 55       	subi	r30, 0x5A	; 90
    33c0:	ff 4f       	sbci	r31, 0xFF	; 255
    33c2:	20 81       	ld	r18, Z
    33c4:	31 81       	ldd	r19, Z+1	; 0x01
    33c6:	42 81       	ldd	r20, Z+2	; 0x02
    33c8:	53 81       	ldd	r21, Z+3	; 0x03

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    33ca:	f4 01       	movw	r30, r8
    33cc:	ee 55       	subi	r30, 0x5E	; 94
    33ce:	ff 4f       	sbci	r31, 0xFF	; 255
    33d0:	60 81       	ld	r22, Z
    33d2:	71 81       	ldd	r23, Z+1	; 0x01
    33d4:	82 81       	ldd	r24, Z+2	; 0x02
    33d6:	93 81       	ldd	r25, Z+3	; 0x03
    33d8:	0e 94 8c 64 	call	0xc918	; 0xc918 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
    33dc:	ff ef       	ldi	r31, 0xFF	; 255
    33de:	29 e6       	ldi	r18, 0x69	; 105
    33e0:	38 e1       	ldi	r19, 0x18	; 24
    33e2:	f1 50       	subi	r31, 0x01	; 1
    33e4:	20 40       	sbci	r18, 0x00	; 0
    33e6:	30 40       	sbci	r19, 0x00	; 0
    33e8:	e1 f7       	brne	.-8      	; 0x33e2 <main+0xb6c>
    33ea:	00 c0       	rjmp	.+0      	; 0x33ec <main+0xb76>
    33ec:	00 00       	nop
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    33ee:	4f 85       	ldd	r20, Y+15	; 0x0f
    33f0:	58 89       	ldd	r21, Y+16	; 0x10
    33f2:	14 16       	cp	r1, r20
    33f4:	15 06       	cpc	r1, r21
    33f6:	14 f1       	brlt	.+68     	; 0x343c <main+0xbc6>
    33f8:	a7 c1       	rjmp	.+846    	; 0x3748 <main+0xed2>
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    33fa:	d6 01       	movw	r26, r12
    33fc:	ed 91       	ld	r30, X+
    33fe:	fc 91       	ld	r31, X
    3400:	01 90       	ld	r0, Z+
    3402:	f0 81       	ld	r31, Z
    3404:	e0 2d       	mov	r30, r0
    3406:	c6 01       	movw	r24, r12
    3408:	19 95       	eicall
    340a:	ef e3       	ldi	r30, 0x3F	; 63
    340c:	fc e9       	ldi	r31, 0x9C	; 156
    340e:	31 97       	sbiw	r30, 0x01	; 1
    3410:	f1 f7       	brne	.-4      	; 0x340e <main+0xb98>
    3412:	00 c0       	rjmp	.+0      	; 0x3414 <main+0xb9e>
    3414:	00 00       	nop
    3416:	29 81       	ldd	r18, Y+1	; 0x01
    3418:	3a 81       	ldd	r19, Y+2	; 0x02
    341a:	21 50       	subi	r18, 0x01	; 1
    341c:	31 09       	sbc	r19, r1
    341e:	3a 83       	std	Y+2, r19	; 0x02
    3420:	29 83       	std	Y+1, r18	; 0x01
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    3422:	23 2b       	or	r18, r19
    3424:	51 f7       	brne	.-44     	; 0x33fa <main+0xb84>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3426:	3f ef       	ldi	r19, 0xFF	; 255
    3428:	a3 1a       	sub	r10, r19
    342a:	b3 0a       	sbc	r11, r19
    342c:	4f 85       	ldd	r20, Y+15	; 0x0f
    342e:	58 89       	ldd	r21, Y+16	; 0x10
    3430:	a4 16       	cp	r10, r20
    3432:	b5 06       	cpc	r11, r21
    3434:	49 f4       	brne	.+18     	; 0x3448 <main+0xbd2>
    3436:	38 a6       	std	Y+40, r3	; 0x28
    3438:	2f a2       	std	Y+39, r2	; 0x27
    343a:	86 c1       	rjmp	.+780    	; 0x3748 <main+0xed2>
    343c:	a1 2c       	mov	r10, r1
    343e:	b1 2c       	mov	r11, r1
	if (model->SensorInput() == SystemModel::SimulatedSensors)
	{
		sensorReadPeriod = simulatorSensorReadPeriod;
	}else
	{
		barometerSensorReadPeriod = 1/50.0f;
    3440:	03 e0       	ldi	r16, 0x03	; 3
    3442:	10 e0       	ldi	r17, 0x00	; 0
    3444:	2f a0       	ldd	r2, Y+39	; 0x27
    3446:	38 a4       	ldd	r3, Y+40	; 0x28
    3448:	1a 83       	std	Y+2, r17	; 0x02
    344a:	09 83       	std	Y+1, r16	; 0x01
    344c:	d6 cf       	rjmp	.-84     	; 0x33fa <main+0xb84>
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    344e:	d6 01       	movw	r26, r12
    3450:	ed 91       	ld	r30, X+
    3452:	fc 91       	ld	r31, X
    3454:	01 90       	ld	r0, Z+
    3456:	f0 81       	ld	r31, Z
    3458:	e0 2d       	mov	r30, r0
    345a:	c6 01       	movw	r24, r12
    345c:	19 95       	eicall
    345e:	ef e3       	ldi	r30, 0x3F	; 63
    3460:	fc e9       	ldi	r31, 0x9C	; 156
    3462:	31 97       	sbiw	r30, 0x01	; 1
    3464:	f1 f7       	brne	.-4      	; 0x3462 <main+0xbec>
    3466:	00 c0       	rjmp	.+0      	; 0x3468 <main+0xbf2>
    3468:	00 00       	nop
    346a:	29 89       	ldd	r18, Y+17	; 0x11
    346c:	3a 89       	ldd	r19, Y+18	; 0x12
    346e:	21 50       	subi	r18, 0x01	; 1
    3470:	31 09       	sbc	r19, r1
    3472:	3a 8b       	std	Y+18, r19	; 0x12
    3474:	29 8b       	std	Y+17, r18	; 0x11
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
		{
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    3476:	23 2b       	or	r18, r19
    3478:	51 f7       	brne	.-44     	; 0x344e <main+0xbd8>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			average +=model->PressureMillibars();
    347a:	af 85       	ldd	r26, Y+15	; 0x0f
    347c:	b8 89       	ldd	r27, Y+16	; 0x10
    347e:	2d 91       	ld	r18, X+
    3480:	3d 91       	ld	r19, X+
    3482:	4d 91       	ld	r20, X+
    3484:	5c 91       	ld	r21, X
    3486:	e9 81       	ldd	r30, Y+1	; 0x01
    3488:	fd 81       	ldd	r31, Y+5	; 0x05
    348a:	61 2f       	mov	r22, r17
    348c:	70 2f       	mov	r23, r16
    348e:	8e 2f       	mov	r24, r30
    3490:	9f 2f       	mov	r25, r31
    3492:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    3496:	16 2f       	mov	r17, r22
    3498:	07 2f       	mov	r16, r23
    349a:	89 83       	std	Y+1, r24	; 0x01
    349c:	9d 83       	std	Y+5, r25	; 0x05
    349e:	b1 e0       	ldi	r27, 0x01	; 1
    34a0:	ab 1a       	sub	r10, r27
    34a2:	b1 08       	sbc	r11, r1
		}
		
		
		float average = 0;
		int iterations = 10;
		for (int i = 0; i < iterations; i++)
    34a4:	29 f0       	breq	.+10     	; 0x34b0 <main+0xc3a>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    34a6:	e3 e0       	ldi	r30, 0x03	; 3
    34a8:	f0 e0       	ldi	r31, 0x00	; 0
    34aa:	fa 8b       	std	Y+18, r31	; 0x12
    34ac:	e9 8b       	std	Y+17, r30	; 0x11
    34ae:	cf cf       	rjmp	.-98     	; 0x344e <main+0xbd8>
    34b0:	38 a6       	std	Y+40, r3	; 0x28
    34b2:	2f a2       	std	Y+39, r2	; 0x27
			}
			average +=model->PressureMillibars();
			
		}
		
		model->PressureMillibars((float)average/((float)iterations));
    34b4:	20 e0       	ldi	r18, 0x00	; 0
    34b6:	30 e0       	ldi	r19, 0x00	; 0
    34b8:	40 e2       	ldi	r20, 0x20	; 32
    34ba:	51 e4       	ldi	r21, 0x41	; 65
    34bc:	a9 81       	ldd	r26, Y+1	; 0x01
    34be:	ad 80       	ldd	r10, Y+5	; 0x05
    34c0:	8a 2f       	mov	r24, r26
    34c2:	9a 2d       	mov	r25, r10
    34c4:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    34c8:	f4 01       	movw	r30, r8
    34ca:	ea 5e       	subi	r30, 0xEA	; 234
    34cc:	fe 4f       	sbci	r31, 0xFE	; 254
    34ce:	06 2f       	mov	r16, r22
    34d0:	17 2f       	mov	r17, r23
    34d2:	28 2f       	mov	r18, r24
    34d4:	39 2f       	mov	r19, r25
    34d6:	00 83       	st	Z, r16
    34d8:	11 83       	std	Z+1, r17	; 0x01
    34da:	22 83       	std	Z+2, r18	; 0x02
    34dc:	33 83       	std	Z+3, r19	; 0x03
		
		//set the initial altitude based on sensor readings.
		//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
		model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    34de:	20 e0       	ldi	r18, 0x00	; 0
    34e0:	30 e5       	ldi	r19, 0x50	; 80
    34e2:	4d e7       	ldi	r20, 0x7D	; 125
    34e4:	54 e4       	ldi	r21, 0x44	; 68
    34e6:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    34ea:	0e 94 82 6d 	call	0xdb04	; 0xdb04 <log10>
    34ee:	2b e2       	ldi	r18, 0x2B	; 43
    34f0:	30 e3       	ldi	r19, 0x30	; 48
    34f2:	48 ea       	ldi	r20, 0xA8	; 168
    34f4:	50 e4       	ldi	r21, 0x40	; 64
    34f6:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    34fa:	9b 01       	movw	r18, r22
    34fc:	ac 01       	movw	r20, r24
    34fe:	60 e0       	ldi	r22, 0x00	; 0
    3500:	70 e0       	ldi	r23, 0x00	; 0
    3502:	80 e2       	ldi	r24, 0x20	; 32
    3504:	91 e4       	ldi	r25, 0x41	; 65
    3506:	0e 94 30 6e 	call	0xdc60	; 0xdc60 <pow>
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    350a:	84 01       	movw	r16, r8
    350c:	06 53       	subi	r16, 0x36	; 54
    350e:	1f 4f       	sbci	r17, 0xFF	; 255
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	40 e8       	ldi	r20, 0x80	; 128
    3516:	5f e3       	ldi	r21, 0x3F	; 63
    3518:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    351c:	29 e9       	ldi	r18, 0x99	; 153
    351e:	3a e4       	ldi	r19, 0x4A	; 74
    3520:	47 e8       	ldi	r20, 0x87	; 135
    3522:	5a e4       	ldi	r21, 0x4A	; 74
    3524:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    3528:	d8 01       	movw	r26, r16
    352a:	6d 93       	st	X+, r22
    352c:	7d 93       	st	X+, r23
    352e:	8d 93       	st	X+, r24
    3530:	9c 93       	st	X, r25
    3532:	13 97       	sbiw	r26, 0x03	; 3
		
		
		float accelGain = ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT;
    3534:	20 91 0a 02 	lds	r18, 0x020A
    3538:	30 91 0b 02 	lds	r19, 0x020B
    353c:	40 91 0c 02 	lds	r20, 0x020C
    3540:	50 91 0d 02 	lds	r21, 0x020D
    3544:	29 83       	std	Y+1, r18	; 0x01
    3546:	3a 83       	std	Y+2, r19	; 0x02
    3548:	4b 83       	std	Y+3, r20	; 0x03
    354a:	5c 83       	std	Y+4, r21	; 0x04
		float magGain = ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT;
    354c:	80 91 06 02 	lds	r24, 0x0206
    3550:	90 91 07 02 	lds	r25, 0x0207
    3554:	a0 91 08 02 	lds	r26, 0x0208
    3558:	b0 91 09 02 	lds	r27, 0x0209
    355c:	8d 83       	std	Y+5, r24	; 0x05
    355e:	9e 83       	std	Y+6, r25	; 0x06
    3560:	af 83       	std	Y+7, r26	; 0x07
    3562:	b8 87       	std	Y+8, r27	; 0x08
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    3564:	8d ec       	ldi	r24, 0xCD	; 205
    3566:	9c ec       	ldi	r25, 0xCC	; 204
    3568:	ac ec       	ldi	r26, 0xCC	; 204
    356a:	bd e3       	ldi	r27, 0x3D	; 61
    356c:	80 93 0a 02 	sts	0x020A, r24
    3570:	90 93 0b 02 	sts	0x020B, r25
    3574:	a0 93 0c 02 	sts	0x020C, r26
    3578:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
    357c:	80 93 06 02 	sts	0x0206, r24
    3580:	90 93 07 02 	sts	0x0207, r25
    3584:	a0 93 08 02 	sts	0x0208, r26
    3588:	b0 93 09 02 	sts	0x0209, r27
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    358c:	a1 2c       	mov	r10, r1
    358e:	b1 2c       	mov	r11, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
    3590:	03 e0       	ldi	r16, 0x03	; 3
    3592:	10 e0       	ldi	r17, 0x00	; 0
    3594:	41 01       	movw	r8, r2
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
		{
			magSensorTask->runTaskImpl();
    3596:	d7 01       	movw	r26, r14
    3598:	ed 91       	ld	r30, X+
    359a:	fc 91       	ld	r31, X
    359c:	01 90       	ld	r0, Z+
    359e:	f0 81       	ld	r31, Z
    35a0:	e0 2d       	mov	r30, r0
    35a2:	c7 01       	movw	r24, r14
    35a4:	19 95       	eicall
			gpsSensorTask->runTaskImpl();
    35a6:	a9 85       	ldd	r26, Y+9	; 0x09
    35a8:	ba 85       	ldd	r27, Y+10	; 0x0a
    35aa:	ed 91       	ld	r30, X+
    35ac:	fc 91       	ld	r31, X
    35ae:	11 97       	sbiw	r26, 0x01	; 1
    35b0:	01 90       	ld	r0, Z+
    35b2:	f0 81       	ld	r31, Z
    35b4:	e0 2d       	mov	r30, r0
    35b6:	cd 01       	movw	r24, r26
    35b8:	19 95       	eicall
    35ba:	18 01       	movw	r2, r16
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
			{
				barometerSensorTask->runTaskImpl();
    35bc:	d6 01       	movw	r26, r12
    35be:	ed 91       	ld	r30, X+
    35c0:	fc 91       	ld	r31, X
    35c2:	01 90       	ld	r0, Z+
    35c4:	f0 81       	ld	r31, Z
    35c6:	e0 2d       	mov	r30, r0
    35c8:	c6 01       	movw	r24, r12
    35ca:	19 95       	eicall
    35cc:	ef e3       	ldi	r30, 0x3F	; 63
    35ce:	fc e9       	ldi	r31, 0x9C	; 156
    35d0:	31 97       	sbiw	r30, 0x01	; 1
    35d2:	f1 f7       	brne	.-4      	; 0x35d0 <main+0xd5a>
    35d4:	00 c0       	rjmp	.+0      	; 0x35d6 <main+0xd60>
    35d6:	00 00       	nop
    35d8:	f1 e0       	ldi	r31, 0x01	; 1
    35da:	2f 1a       	sub	r2, r31
    35dc:	31 08       	sbc	r3, r1
		{
			magSensorTask->runTaskImpl();
			gpsSensorTask->runTaskImpl();
			
			//baro task is a 3 step process, so run 3 times.
			for (int i = 0; i < 3; i++)
    35de:	71 f7       	brne	.-36     	; 0x35bc <main+0xd46>
			{
				barometerSensorTask->runTaskImpl();
				_delay_ms(BarometerSensor::ADC_PROCESSING_TIME_MS);
			}
			
			imuSensorTask->runTaskImpl();
    35e0:	ab 85       	ldd	r26, Y+11	; 0x0b
    35e2:	bc 85       	ldd	r27, Y+12	; 0x0c
    35e4:	ed 91       	ld	r30, X+
    35e6:	fc 91       	ld	r31, X
    35e8:	11 97       	sbiw	r26, 0x01	; 1
    35ea:	01 90       	ld	r0, Z+
    35ec:	f0 81       	ld	r31, Z
    35ee:	e0 2d       	mov	r30, r0
    35f0:	cd 01       	movw	r24, r26
    35f2:	19 95       	eicall
			
			navTask->runTaskImpl();
    35f4:	ad 8d       	ldd	r26, Y+29	; 0x1d
    35f6:	be 8d       	ldd	r27, Y+30	; 0x1e
    35f8:	ed 91       	ld	r30, X+
    35fa:	fc 91       	ld	r31, X
    35fc:	11 97       	sbiw	r26, 0x01	; 1
    35fe:	01 90       	ld	r0, Z+
    3600:	f0 81       	ld	r31, Z
    3602:	e0 2d       	mov	r30, r0
    3604:	cd 01       	movw	r24, r26
    3606:	19 95       	eicall
			pvNavTask->runTaskImpl();
    3608:	af 8d       	ldd	r26, Y+31	; 0x1f
    360a:	b8 a1       	ldd	r27, Y+32	; 0x20
    360c:	ed 91       	ld	r30, X+
    360e:	fc 91       	ld	r31, X
    3610:	11 97       	sbiw	r26, 0x01	; 1
    3612:	01 90       	ld	r0, Z+
    3614:	f0 81       	ld	r31, Z
    3616:	e0 2d       	mov	r30, r0
    3618:	cd 01       	movw	r24, r26
    361a:	19 95       	eicall
    361c:	ef e3       	ldi	r30, 0x3F	; 63
    361e:	fc e9       	ldi	r31, 0x9C	; 156
    3620:	31 97       	sbiw	r30, 0x01	; 1
    3622:	f1 f7       	brne	.-4      	; 0x3620 <main+0xdaa>
    3624:	00 c0       	rjmp	.+0      	; 0x3626 <main+0xdb0>
    3626:	00 00       	nop
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .1f;
		
		
		//execute all the senor tasks a bunch of times to initialize the ahrs and nav systems.
		//for (int i = 0; i < 500; i++)
for (int i = 0; i < sensorInitReadings; i++)		
    3628:	ff ef       	ldi	r31, 0xFF	; 255
    362a:	af 1a       	sub	r10, r31
    362c:	bf 0a       	sbc	r11, r31
    362e:	29 8d       	ldd	r18, Y+25	; 0x19
    3630:	3a 8d       	ldd	r19, Y+26	; 0x1a
    3632:	a2 16       	cp	r10, r18
    3634:	b3 06       	cpc	r11, r19
    3636:	0c f4       	brge	.+2      	; 0x363a <main+0xdc4>
    3638:	ae cf       	rjmp	.-164    	; 0x3596 <main+0xd20>
    363a:	98 a6       	std	Y+40, r9	; 0x28
    363c:	8f a2       	std	Y+39, r8	; 0x27
			pvNavTask->runTaskImpl();
			
			_delay_ms(10);
		}
		
		ahrs->ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = accelGain;
    363e:	89 81       	ldd	r24, Y+1	; 0x01
    3640:	9a 81       	ldd	r25, Y+2	; 0x02
    3642:	ab 81       	ldd	r26, Y+3	; 0x03
    3644:	bc 81       	ldd	r27, Y+4	; 0x04
    3646:	80 93 0a 02 	sts	0x020A, r24
    364a:	90 93 0b 02 	sts	0x020B, r25
    364e:	a0 93 0c 02 	sts	0x020C, r26
    3652:	b0 93 0d 02 	sts	0x020D, r27
		ahrs->MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = magGain;
    3656:	2d 81       	ldd	r18, Y+5	; 0x05
    3658:	3e 81       	ldd	r19, Y+6	; 0x06
    365a:	4f 81       	ldd	r20, Y+7	; 0x07
    365c:	58 85       	ldd	r21, Y+8	; 0x08
    365e:	20 93 06 02 	sts	0x0206, r18
    3662:	30 93 07 02 	sts	0x0207, r19
    3666:	40 93 08 02 	sts	0x0208, r20
    366a:	50 93 09 02 	sts	0x0209, r21
    366e:	ff c0       	rjmp	.+510    	; 0x386e <main+0xff8>
	}else
	{

		//SerialDriver *initSerialDriver = new SerialDriver(serialDriverBaudRate, SerialDriver::Zero, true, true, NULL);
		//GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(initSerialDriver);
		GroundControlStationInterface *initGcsInterface = new GroundControlStationInterface(serialDriver);
    3670:	82 e0       	ldi	r24, 0x02	; 2
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    3678:	9a 83       	std	Y+2, r25	; 0x02
    367a:	89 83       	std	Y+1, r24	; 0x01
    367c:	dc 01       	movw	r26, r24
    367e:	ad 92       	st	X+, r10
    3680:	bc 92       	st	X, r11
		SimTelemetryTask *initSimTelemTask = new SimTelemetryTask(initGcsInterface, model, pidController,SimTelemetryTask::ALLDATA, 0, (SCHEDULER_TICK_FREQUENCY_HZ  * .05));//execute 20 hz
    3682:	8e e0       	ldi	r24, 0x0E	; 14
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    368a:	5c 01       	movw	r10, r24
    368c:	0f 2e       	mov	r0, r31
    368e:	fa e0       	ldi	r31, 0x0A	; 10
    3690:	cf 2e       	mov	r12, r31
    3692:	d1 2c       	mov	r13, r1
    3694:	f0 2d       	mov	r31, r0
    3696:	e1 2c       	mov	r14, r1
    3698:	f1 2c       	mov	r15, r1
    369a:	00 e0       	ldi	r16, 0x00	; 0
    369c:	93 01       	movw	r18, r6
    369e:	a4 01       	movw	r20, r8
    36a0:	69 81       	ldd	r22, Y+1	; 0x01
    36a2:	7a 81       	ldd	r23, Y+2	; 0x02
    36a4:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    36a8:	14 01       	movw	r2, r8
    36aa:	b2 ea       	ldi	r27, 0xA2	; 162
    36ac:	2b 0e       	add	r2, r27
    36ae:	31 1c       	adc	r3, r1
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    36b0:	84 01       	movw	r16, r8
    36b2:	0a 55       	subi	r16, 0x5A	; 90
    36b4:	1f 4f       	sbci	r17, 0xFF	; 255
	
		while (!isInitialized)
		{
			initSimTelemTask->runTaskImpl();
    36b6:	d5 01       	movw	r26, r10
    36b8:	ed 91       	ld	r30, X+
    36ba:	fc 91       	ld	r31, X
    36bc:	01 90       	ld	r0, Z+
    36be:	f0 81       	ld	r31, Z
    36c0:	e0 2d       	mov	r30, r0
    36c2:	c5 01       	movw	r24, r10
    36c4:	19 95       	eicall

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    36c6:	f1 01       	movw	r30, r2
    36c8:	c0 80       	ld	r12, Z
    36ca:	d1 80       	ldd	r13, Z+1	; 0x01
    36cc:	e2 80       	ldd	r14, Z+2	; 0x02
    36ce:	f3 80       	ldd	r15, Z+3	; 0x03
		
			if (model->LatitudeDegrees() != 0 && model->LongitudeDegrees() != 0)
    36d0:	20 e0       	ldi	r18, 0x00	; 0
    36d2:	30 e0       	ldi	r19, 0x00	; 0
    36d4:	a9 01       	movw	r20, r18
    36d6:	c7 01       	movw	r24, r14
    36d8:	b6 01       	movw	r22, r12
    36da:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    36de:	88 23       	and	r24, r24
    36e0:	61 f0       	breq	.+24     	; 0x36fa <main+0xe84>
    36e2:	20 e0       	ldi	r18, 0x00	; 0
    36e4:	30 e0       	ldi	r19, 0x00	; 0
    36e6:	a9 01       	movw	r20, r18
    36e8:	d8 01       	movw	r26, r16
    36ea:	6d 91       	ld	r22, X+
    36ec:	7d 91       	ld	r23, X+
    36ee:	8d 91       	ld	r24, X+
    36f0:	9c 91       	ld	r25, X
    36f2:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    36f6:	81 11       	cpse	r24, r1
    36f8:	38 c0       	rjmp	.+112    	; 0x376a <main+0xef4>
    36fa:	bf ef       	ldi	r27, 0xFF	; 255
    36fc:	e1 ee       	ldi	r30, 0xE1	; 225
    36fe:	f4 e0       	ldi	r31, 0x04	; 4
    3700:	b1 50       	subi	r27, 0x01	; 1
    3702:	e0 40       	sbci	r30, 0x00	; 0
    3704:	f0 40       	sbci	r31, 0x00	; 0
    3706:	e1 f7       	brne	.-8      	; 0x3700 <main+0xe8a>
    3708:	00 c0       	rjmp	.+0      	; 0x370a <main+0xe94>
    370a:	00 00       	nop
    370c:	d4 cf       	rjmp	.-88     	; 0x36b6 <main+0xe40>
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    370e:	d5 01       	movw	r26, r10
    3710:	ed 91       	ld	r30, X+
    3712:	fc 91       	ld	r31, X
    3714:	04 80       	ldd	r0, Z+4	; 0x04
    3716:	f5 81       	ldd	r31, Z+5	; 0x05
    3718:	e0 2d       	mov	r30, r0
    371a:	c5 01       	movw	r24, r10
    371c:	19 95       	eicall
		delete initGcsInterface;
    371e:	e9 81       	ldd	r30, Y+1	; 0x01
    3720:	fa 81       	ldd	r31, Y+2	; 0x02
    3722:	30 97       	sbiw	r30, 0x00	; 0
    3724:	09 f4       	brne	.+2      	; 0x3728 <main+0xeb2>
    3726:	a3 c0       	rjmp	.+326    	; 0x386e <main+0xff8>
    3728:	cf 01       	movw	r24, r30
    372a:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    372e:	9f c0       	rjmp	.+318    	; 0x386e <main+0xff8>
	{

	
		//Checks to see if any tasks are ready to run an executes them.
		//goes to sleep (until the next timer tick) after processing all available tasks.
		scheduler->dispatch();
    3730:	c8 01       	movw	r24, r16
    3732:	0e 94 c0 42 	call	0x8580	; 0x8580 <_ZN10helicopter9scheduler9Scheduler8dispatchEv>
		
		/**
		 * Determine if the last processing frame was blown.
		 */
		if (scheduler->hasBlownFrame())
    3736:	d8 01       	movw	r26, r16
    3738:	d8 96       	adiw	r26, 0x38	; 56
    373a:	8c 91       	ld	r24, X
    373c:	88 23       	and	r24, r24
    373e:	c1 f3       	breq	.-16     	; 0x3730 <main+0xeba>
		{
			pidController->addBlownFrame();
    3740:	c3 01       	movw	r24, r6
    3742:	0e 94 4c 04 	call	0x898	; 0x898 <_ZN10helicopter10controller13PIDController13addBlownFrameEv>
    3746:	f4 cf       	rjmp	.-24     	; 0x3730 <main+0xeba>
		//messed up the gps data. This gives it time to clear back up.
		_delay_ms(500);
		
		//Initialize barometer readings. The barometer needs lots of time to stabilize. 
		//for (int i = 0; i < 1000; i++)
		for (int i = 0; i < barometerInitReadings; i++)		
    3748:	0f 2e       	mov	r0, r31
    374a:	fa e0       	ldi	r31, 0x0A	; 10
    374c:	af 2e       	mov	r10, r31
    374e:	b1 2c       	mov	r11, r1
    3750:	f0 2d       	mov	r31, r0
    3752:	10 e0       	ldi	r17, 0x00	; 0
    3754:	00 e0       	ldi	r16, 0x00	; 0
    3756:	19 82       	std	Y+1, r1	; 0x01
    3758:	1d 82       	std	Y+5, r1	; 0x05
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    375a:	f4 01       	movw	r30, r8
    375c:	ea 5e       	subi	r30, 0xEA	; 234
    375e:	fe 4f       	sbci	r31, 0xFE	; 254
    3760:	f8 8b       	std	Y+16, r31	; 0x10
    3762:	ef 87       	std	Y+15, r30	; 0x0f
    3764:	2f a0       	ldd	r2, Y+39	; 0x27
    3766:	38 a4       	ldd	r3, Y+40	; 0x28
    3768:	9e ce       	rjmp	.-708    	; 0x34a6 <main+0xc30>
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    376a:	84 01       	movw	r16, r8
    376c:	02 54       	subi	r16, 0x42	; 66
    376e:	1f 4f       	sbci	r17, 0xFF	; 255
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    3770:	f4 01       	movw	r30, r8
    3772:	e2 50       	subi	r30, 0x02	; 2
    3774:	ff 4f       	sbci	r31, 0xFF	; 255
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			
    3776:	60 81       	ld	r22, Z
    3778:	71 81       	ldd	r23, Z+1	; 0x01
    377a:	82 81       	ldd	r24, Z+2	; 0x02
    377c:	93 81       	ldd	r25, Z+3	; 0x03
    377e:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    3782:	d8 01       	movw	r26, r16
    3784:	6d 93       	st	X+, r22
    3786:	7d 93       	st	X+, r23
    3788:	8d 93       	st	X+, r24
    378a:	9c 93       	st	X, r25
    378c:	13 97       	sbiw	r26, 0x03	; 3

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    378e:	84 01       	movw	r16, r8
    3790:	0e 53       	subi	r16, 0x3E	; 62
    3792:	1f 4f       	sbci	r17, 0xFF	; 255
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    3794:	f4 01       	movw	r30, r8
    3796:	ee 5f       	subi	r30, 0xFE	; 254
    3798:	fe 4f       	sbci	r31, 0xFE	; 254

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}
    379a:	60 81       	ld	r22, Z
    379c:	71 81       	ldd	r23, Z+1	; 0x01
    379e:	82 81       	ldd	r24, Z+2	; 0x02
    37a0:	93 81       	ldd	r25, Z+3	; 0x03
    37a2:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    37a6:	f8 01       	movw	r30, r16
    37a8:	60 83       	st	Z, r22
    37aa:	71 83       	std	Z+1, r23	; 0x01
    37ac:	82 83       	std	Z+2, r24	; 0x02
    37ae:	93 83       	std	Z+3, r25	; 0x03

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    37b0:	84 01       	movw	r16, r8
    37b2:	0a 53       	subi	r16, 0x3A	; 58
    37b4:	1f 4f       	sbci	r17, 0xFF	; 255
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    37b6:	f4 01       	movw	r30, r8
    37b8:	ea 5f       	subi	r30, 0xFA	; 250
    37ba:	fe 4f       	sbci	r31, 0xFE	; 254

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
    37bc:	60 81       	ld	r22, Z
    37be:	71 81       	ldd	r23, Z+1	; 0x01
    37c0:	82 81       	ldd	r24, Z+2	; 0x02
    37c2:	93 81       	ldd	r25, Z+3	; 0x03
    37c4:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    37c8:	d8 01       	movw	r26, r16
    37ca:	6d 93       	st	X+, r22
    37cc:	7d 93       	st	X+, r23
    37ce:	8d 93       	st	X+, r24
    37d0:	9c 93       	st	X, r25
    37d2:	13 97       	sbiw	r26, 0x03	; 3
				model->InitialYPositionEcef(model->YEcefCm());
				model->InitialZPositionEcef(model->ZEcefCm());
			
			
				////ecefReferenceX, ecefReferenceY, ecefReferenceZ,ecefToLocalNEDRotationMatrix,
				CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(model->LatitudeDegrees(), model->LongitudeDegrees(), model->EcefToLocalNEDRotationMatrix);
    37d4:	84 01       	movw	r16, r8
    37d6:	02 5e       	subi	r16, 0xE2	; 226
    37d8:	1e 4f       	sbci	r17, 0xFE	; 254
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    37da:	f4 01       	movw	r30, r8
    37dc:	ea 55       	subi	r30, 0x5A	; 90
    37de:	ff 4f       	sbci	r31, 0xFF	; 255
    37e0:	20 81       	ld	r18, Z
    37e2:	31 81       	ldd	r19, Z+1	; 0x01
    37e4:	42 81       	ldd	r20, Z+2	; 0x02
    37e6:	53 81       	ldd	r21, Z+3	; 0x03
    37e8:	c7 01       	movw	r24, r14
    37ea:	b6 01       	movw	r22, r12
    37ec:	0e 94 8c 64 	call	0xc918	; 0xc918 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    37f0:	f4 01       	movw	r30, r8
    37f2:	ea 5e       	subi	r30, 0xEA	; 234
    37f4:	fe 4f       	sbci	r31, 0xFE	; 254
				//multiply by -1 because in NED/FRD frame, down is positive. 
				//model->InitialAltitudeMeters(((288.15/(6.5/1000.0))*(1-(pow((model->PressureMillibars()/101325.0),(6.5/1000.0)*(287.052/9.78))))) * -1);
			
				//https://www.brisbanehotairballooning.com.au/faqs/education/113-pressure-altitude-conversion.html
				//model->InitialAltitudeCm((((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-6.8755856 * 0.000001)) / 3.28084) * -100);
				model->InitialAltitudeCm((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712);
    37f6:	20 e0       	ldi	r18, 0x00	; 0
    37f8:	30 e5       	ldi	r19, 0x50	; 80
    37fa:	4d e7       	ldi	r20, 0x7D	; 125
    37fc:	54 e4       	ldi	r21, 0x44	; 68
    37fe:	60 81       	ld	r22, Z
    3800:	71 81       	ldd	r23, Z+1	; 0x01
    3802:	82 81       	ldd	r24, Z+2	; 0x02
    3804:	93 81       	ldd	r25, Z+3	; 0x03
    3806:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    380a:	0e 94 82 6d 	call	0xdb04	; 0xdb04 <log10>
    380e:	2b e2       	ldi	r18, 0x2B	; 43
    3810:	30 e3       	ldi	r19, 0x30	; 48
    3812:	48 ea       	ldi	r20, 0xA8	; 168
    3814:	50 e4       	ldi	r21, 0x40	; 64
    3816:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    381a:	9b 01       	movw	r18, r22
    381c:	ac 01       	movw	r20, r24
    381e:	60 e0       	ldi	r22, 0x00	; 0
    3820:	70 e0       	ldi	r23, 0x00	; 0
    3822:	80 e2       	ldi	r24, 0x20	; 32
    3824:	91 e4       	ldi	r25, 0x41	; 65
    3826:	0e 94 30 6e 	call	0xdc60	; 0xdc60 <pow>
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
    382a:	84 01       	movw	r16, r8
    382c:	06 53       	subi	r16, 0x36	; 54
    382e:	1f 4f       	sbci	r17, 0xFF	; 255
    3830:	20 e0       	ldi	r18, 0x00	; 0
    3832:	30 e0       	ldi	r19, 0x00	; 0
    3834:	40 e8       	ldi	r20, 0x80	; 128
    3836:	5f e3       	ldi	r21, 0x3F	; 63
    3838:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    383c:	29 e9       	ldi	r18, 0x99	; 153
    383e:	3a e4       	ldi	r19, 0x4A	; 74
    3840:	47 e8       	ldi	r20, 0x87	; 135
    3842:	5a e4       	ldi	r21, 0x4A	; 74
    3844:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    3848:	f8 01       	movw	r30, r16
    384a:	60 83       	st	Z, r22
    384c:	71 83       	std	Z+1, r23	; 0x01
    384e:	82 83       	std	Z+2, r24	; 0x02
    3850:	93 83       	std	Z+3, r25	; 0x03
    3852:	ff ef       	ldi	r31, 0xFF	; 255
    3854:	21 ee       	ldi	r18, 0xE1	; 225
    3856:	34 e0       	ldi	r19, 0x04	; 4
    3858:	f1 50       	subi	r31, 0x01	; 1
    385a:	20 40       	sbci	r18, 0x00	; 0
    385c:	30 40       	sbci	r19, 0x00	; 0
    385e:	e1 f7       	brne	.-8      	; 0x3858 <main+0xfe2>
    3860:	00 c0       	rjmp	.+0      	; 0x3862 <main+0xfec>
    3862:	00 00       	nop
			}
			_delay_ms(100);
		}
		
		delete initSimTelemTask;
    3864:	a1 14       	cp	r10, r1
    3866:	b1 04       	cpc	r11, r1
    3868:	09 f0       	breq	.+2      	; 0x386c <main+0xff6>
    386a:	51 cf       	rjmp	.-350    	; 0x370e <main+0xe98>
    386c:	58 cf       	rjmp	.-336    	; 0x371e <main+0xea8>
	
	
	if (isInitialized)
	{
		//turn red LED off to indicate initialized.
		PORTA |= (1<<PA5);
    386e:	15 9a       	sbi	0x02, 5	; 2
	}
	
	gpsSensor->start();
    3870:	c2 01       	movw	r24, r4
    3872:	0e 94 dd 4b 	call	0x97ba	; 0x97ba <_ZN10helicopter7sensors9GPSSensor5startEv>

	scheduler->init(); //Sets up the timer registers, inits all tasks,
    3876:	8f a1       	ldd	r24, Y+39	; 0x27
    3878:	98 a5       	ldd	r25, Y+40	; 0x28
    387a:	0e 94 84 42 	call	0x8508	; 0x8508 <_ZN10helicopter9scheduler9Scheduler4initEv>
	
	scheduler->start();
    387e:	8f a1       	ldd	r24, Y+39	; 0x27
    3880:	98 a5       	ldd	r25, Y+40	; 0x28
    3882:	0e 94 01 43 	call	0x8602	; 0x8602 <_ZN10helicopter9scheduler9Scheduler5startEv>
    3886:	0f a1       	ldd	r16, Y+39	; 0x27
    3888:	18 a5       	ldd	r17, Y+40	; 0x28
    388a:	52 cf       	rjmp	.-348    	; 0x3730 <main+0xeba>

0000388c <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>:

using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
    388c:	0f 93       	push	r16
    388e:	1f 93       	push	r17
    3890:	cf 93       	push	r28
    3892:	df 93       	push	r29
    3894:	d9 01       	movw	r26, r18
    3896:	e8 01       	movw	r28, r16
	for (int i = 0; i < payloadSize; i++)
    3898:	14 16       	cp	r1, r20
    389a:	15 06       	cpc	r1, r21
    389c:	74 f4       	brge	.+28     	; 0x38ba <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x2e>
    389e:	e6 2f       	mov	r30, r22
    38a0:	f7 2f       	mov	r31, r23
#include "GainsMessage.h"

using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
    38a2:	4e 0f       	add	r20, r30
    38a4:	5f 1f       	adc	r21, r31
{
	for (int i = 0; i < payloadSize; i++)
	{
		byte b = msgPayload[i];
    38a6:	91 91       	ld	r25, Z+
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
    38a8:	8c 91       	ld	r24, X
    38aa:	89 0f       	add	r24, r25
    38ac:	8c 93       	st	X, r24
		checksumB = (byte) (checksumB + checksumA);
    38ae:	98 81       	ld	r25, Y
    38b0:	89 0f       	add	r24, r25
    38b2:	88 83       	st	Y, r24
using namespace helicopter::util;
using namespace helicopter::interfaces;

void GroundControlStationInterface::calculateChecksum (byte *msgPayload, int payloadSize, byte &checksumA, byte &checksumB)
{
	for (int i = 0; i < payloadSize; i++)
    38b4:	e4 17       	cp	r30, r20
    38b6:	f5 07       	cpc	r31, r21
    38b8:	b1 f7       	brne	.-20     	; 0x38a6 <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_+0x1a>
		
		//These fields can overflow, but that is intentional.
		checksumA = (byte) (checksumA + b);
		checksumB = (byte) (checksumB + checksumA);
	}
}
    38ba:	df 91       	pop	r29
    38bc:	cf 91       	pop	r28
    38be:	1f 91       	pop	r17
    38c0:	0f 91       	pop	r16
    38c2:	08 95       	ret

000038c4 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>:

int GroundControlStationInterface::transmit(Message *msgToSend)
{
    38c4:	2f 92       	push	r2
    38c6:	3f 92       	push	r3
    38c8:	4f 92       	push	r4
    38ca:	5f 92       	push	r5
    38cc:	6f 92       	push	r6
    38ce:	7f 92       	push	r7
    38d0:	8f 92       	push	r8
    38d2:	9f 92       	push	r9
    38d4:	af 92       	push	r10
    38d6:	bf 92       	push	r11
    38d8:	cf 92       	push	r12
    38da:	df 92       	push	r13
    38dc:	ef 92       	push	r14
    38de:	ff 92       	push	r15
    38e0:	0f 93       	push	r16
    38e2:	1f 93       	push	r17
    38e4:	cf 93       	push	r28
    38e6:	df 93       	push	r29
    38e8:	00 d0       	rcall	.+0      	; 0x38ea <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x26>
    38ea:	1f 92       	push	r1
    38ec:	cd b7       	in	r28, 0x3d	; 61
    38ee:	de b7       	in	r29, 0x3e	; 62
    38f0:	7c 01       	movw	r14, r24
    38f2:	8b 01       	movw	r16, r22
		}
	
	}
	
	return status;
}
    38f4:	4d b6       	in	r4, 0x3d	; 61
    38f6:	5e b6       	in	r5, 0x3e	; 62

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
	
	if (msgToSend != NULL)
    38f8:	61 15       	cp	r22, r1
    38fa:	71 05       	cpc	r23, r1
    38fc:	09 f4       	brne	.+2      	; 0x3900 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x3c>
    38fe:	89 c0       	rjmp	.+274    	; 0x3a12 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x14e>
	{
		byte *msgPayload = msgToSend->getBytes();
    3900:	db 01       	movw	r26, r22
    3902:	ed 91       	ld	r30, X+
    3904:	fc 91       	ld	r31, X
    3906:	04 80       	ldd	r0, Z+4	; 0x04
    3908:	f5 81       	ldd	r31, Z+5	; 0x05
    390a:	e0 2d       	mov	r30, r0
    390c:	cb 01       	movw	r24, r22
    390e:	19 95       	eicall
    3910:	5c 01       	movw	r10, r24
    3912:	bd b7       	in	r27, 0x3d	; 61
    3914:	bb 83       	std	Y+3, r27	; 0x03
    3916:	ee b7       	in	r30, 0x3e	; 62
    3918:	ec 83       	std	Y+4, r30	; 0x04
		//check for out of memory. (shouldn't be necessary).
		//if (msgPayload != NULL)
		{
			
		
			int payloadSize = msgToSend->getMessageSize();
    391a:	c8 01       	movw	r24, r16
    391c:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <_ZN10helicopter8messages7Message14getMessageSizeEv>
    3920:	4c 01       	movw	r8, r24
		
			int completeMsgSize = payloadSize + MsgHeaderFooterSize;;
    3922:	6c 01       	movw	r12, r24
    3924:	f5 e0       	ldi	r31, 0x05	; 5
    3926:	cf 0e       	add	r12, r31
    3928:	d1 1c       	adc	r13, r1

			byte completeMsg[completeMsgSize];
    392a:	1c 01       	movw	r2, r24
    392c:	84 e0       	ldi	r24, 0x04	; 4
    392e:	28 0e       	add	r2, r24
    3930:	31 1c       	adc	r3, r1
    3932:	ad b7       	in	r26, 0x3d	; 61
    3934:	be b7       	in	r27, 0x3e	; 62
    3936:	ac 19       	sub	r26, r12
    3938:	bd 09       	sbc	r27, r13
    393a:	0f b6       	in	r0, 0x3f	; 63
    393c:	f8 94       	cli
    393e:	be bf       	out	0x3e, r27	; 62
    3940:	0f be       	out	0x3f, r0	; 63
    3942:	ad bf       	out	0x3d, r26	; 61
    3944:	6d b6       	in	r6, 0x3d	; 61
    3946:	7e b6       	in	r7, 0x3e	; 62
    3948:	e1 e0       	ldi	r30, 0x01	; 1
    394a:	f0 e0       	ldi	r31, 0x00	; 0
    394c:	6e 0e       	add	r6, r30
    394e:	7f 1e       	adc	r7, r31
		
			completeMsg[0] = GroundControlStationInterface::SyncByte1;
    3950:	85 eb       	ldi	r24, 0xB5	; 181
    3952:	11 96       	adiw	r26, 0x01	; 1
    3954:	8c 93       	st	X, r24
			completeMsg[1] = GroundControlStationInterface::SyncByte2;
    3956:	82 e6       	ldi	r24, 0x62	; 98
    3958:	d3 01       	movw	r26, r6
    395a:	11 96       	adiw	r26, 0x01	; 1
    395c:	8c 93       	st	X, r24
    395e:	11 97       	sbiw	r26, 0x01	; 1
			completeMsg[2] = GroundControlStationInterface::SyncByte3;
    3960:	87 ed       	ldi	r24, 0xD7	; 215
    3962:	12 96       	adiw	r26, 0x02	; 2
    3964:	8c 93       	st	X, r24
		
			memcpy(&completeMsg[3], msgPayload, payloadSize);
    3966:	2d b7       	in	r18, 0x3d	; 61
    3968:	3e b7       	in	r19, 0x3e	; 62
    396a:	2c 5f       	subi	r18, 0xFC	; 252
    396c:	3f 4f       	sbci	r19, 0xFF	; 255
    396e:	48 2d       	mov	r20, r8
    3970:	59 2d       	mov	r21, r9
    3972:	6a 2d       	mov	r22, r10
    3974:	7b 2d       	mov	r23, r11
    3976:	82 2f       	mov	r24, r18
    3978:	93 2f       	mov	r25, r19
    397a:	0e 94 5f 71 	call	0xe2be	; 0xe2be <memcpy>
		
			byte checksumA = 0;
    397e:	1a 82       	std	Y+2, r1	; 0x02
			byte checksumB = 0;
    3980:	19 82       	std	Y+1, r1	; 0x01
		
			calculateChecksum(msgPayload, payloadSize, checksumA, checksumB);
    3982:	8e 01       	movw	r16, r28
    3984:	0f 5f       	subi	r16, 0xFF	; 255
    3986:	1f 4f       	sbci	r17, 0xFF	; 255
    3988:	9e 01       	movw	r18, r28
    398a:	2e 5f       	subi	r18, 0xFE	; 254
    398c:	3f 4f       	sbci	r19, 0xFF	; 255
    398e:	a4 01       	movw	r20, r8
    3990:	b5 01       	movw	r22, r10
    3992:	c7 01       	movw	r24, r14
    3994:	0e 94 46 1c 	call	0x388c	; 0x388c <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
		
			completeMsg[completeMsgSize - 2] = checksumA;
    3998:	f3 01       	movw	r30, r6
    399a:	e8 0d       	add	r30, r8
    399c:	f9 1d       	adc	r31, r9
    399e:	8a 81       	ldd	r24, Y+2	; 0x02
    39a0:	83 83       	std	Z+3, r24	; 0x03
			completeMsg[completeMsgSize - 1] = checksumB;
    39a2:	f3 01       	movw	r30, r6
    39a4:	e2 0d       	add	r30, r2
    39a6:	f3 1d       	adc	r31, r3
    39a8:	89 81       	ldd	r24, Y+1	; 0x01
    39aa:	80 83       	st	Z, r24
		
			serialDriver->startTimer();
    39ac:	f7 01       	movw	r30, r14
    39ae:	80 81       	ld	r24, Z
    39b0:	91 81       	ldd	r25, Z+1	; 0x01
    39b2:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    39b6:	00 e0       	ldi	r16, 0x00	; 0
    39b8:	10 e0       	ldi	r17, 0x00	; 0
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    39ba:	81 2c       	mov	r8, r1
    39bc:	91 2c       	mov	r9, r1
			completeMsg[completeMsgSize - 1] = checksumB;
		
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    39be:	0c 15       	cp	r16, r12
    39c0:	1d 05       	cpc	r17, r13
    39c2:	54 f5       	brge	.+84     	; 0x3a18 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x154>
    39c4:	81 14       	cp	r8, r1
    39c6:	91 04       	cpc	r9, r1
    39c8:	81 f1       	breq	.+96     	; 0x3a2a <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x166>
    39ca:	26 c0       	rjmp	.+76     	; 0x3a18 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x154>
				status = serialDriver->transmit(completeMsg[i]);
			}
		
			serialDriver->stopTimer();
		
			delete [] msgPayload;
    39cc:	c5 01       	movw	r24, r10
    39ce:	0e 94 87 64 	call	0xc90e	; 0xc90e <_ZdaPv>
			msgPayload = NULL;
		
			
			if (serialDriver->asyncReceiveTransmitData)
    39d2:	d7 01       	movw	r26, r14
    39d4:	ed 91       	ld	r30, X+
    39d6:	fc 91       	ld	r31, X
    39d8:	80 85       	ldd	r24, Z+8	; 0x08
    39da:	88 23       	and	r24, r24
    39dc:	81 f0       	breq	.+32     	; 0x39fe <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
			{
				//Enable data register empty interrupt so the next byte will be transmitted.
				//I added this code here because enabling interrupts after every byte caused it to not transmit all the data. the system didn't like rapidly enabling interrupts.
				if (serialDriver->uartPort == SerialDriver::Zero)
    39de:	86 81       	ldd	r24, Z+6	; 0x06
    39e0:	81 11       	cpse	r24, r1
    39e2:	06 c0       	rjmp	.+12     	; 0x39f0 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x12c>
				{
					UCSR0B |= (1<<UDRIE0);
    39e4:	e1 ec       	ldi	r30, 0xC1	; 193
    39e6:	f0 e0       	ldi	r31, 0x00	; 0
    39e8:	80 81       	ld	r24, Z
    39ea:	80 62       	ori	r24, 0x20	; 32
    39ec:	80 83       	st	Z, r24
    39ee:	07 c0       	rjmp	.+14     	; 0x39fe <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
				}else if (serialDriver->uartPort == SerialDriver::One)
    39f0:	81 30       	cpi	r24, 0x01	; 1
    39f2:	29 f4       	brne	.+10     	; 0x39fe <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x13a>
				{
					UCSR1B |= (1<<UDRIE1);
    39f4:	e9 ec       	ldi	r30, 0xC9	; 201
    39f6:	f0 e0       	ldi	r31, 0x00	; 0
    39f8:	80 81       	ld	r24, Z
    39fa:	80 62       	ori	r24, 0x20	; 32
    39fc:	80 83       	st	Z, r24
    39fe:	3b 81       	ldd	r19, Y+3	; 0x03
    3a00:	2c 81       	ldd	r18, Y+4	; 0x04
    3a02:	83 2f       	mov	r24, r19
    3a04:	92 2f       	mov	r25, r18
    3a06:	0f b6       	in	r0, 0x3f	; 63
    3a08:	f8 94       	cli
    3a0a:	9e bf       	out	0x3e, r25	; 62
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	8d bf       	out	0x3d, r24	; 61
    3a10:	1d c0       	rjmp	.+58     	; 0x3a4c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x188>
	}
}

int GroundControlStationInterface::transmit(Message *msgToSend)
{
	int status = 0;
    3a12:	81 2c       	mov	r8, r1
    3a14:	91 2c       	mov	r9, r1
    3a16:	1a c0       	rjmp	.+52     	; 0x3a4c <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x188>
			for (int i = 0; i < completeMsgSize && status == 0; i++)
			{
				status = serialDriver->transmit(completeMsg[i]);
			}
		
			serialDriver->stopTimer();
    3a18:	f7 01       	movw	r30, r14
    3a1a:	80 81       	ld	r24, Z
    3a1c:	91 81       	ldd	r25, Z+1	; 0x01
    3a1e:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
		
			delete [] msgPayload;
    3a22:	a1 14       	cp	r10, r1
    3a24:	b1 04       	cpc	r11, r1
    3a26:	91 f6       	brne	.-92     	; 0x39cc <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x108>
    3a28:	d4 cf       	rjmp	.-88     	; 0x39d2 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0x10e>
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
			{
				status = serialDriver->transmit(completeMsg[i]);
    3a2a:	d7 01       	movw	r26, r14
    3a2c:	8d 91       	ld	r24, X+
    3a2e:	9c 91       	ld	r25, X
    3a30:	f3 01       	movw	r30, r6
    3a32:	61 91       	ld	r22, Z+
    3a34:	3f 01       	movw	r6, r30
    3a36:	dc 01       	movw	r26, r24
    3a38:	ed 91       	ld	r30, X+
    3a3a:	fc 91       	ld	r31, X
    3a3c:	06 80       	ldd	r0, Z+6	; 0x06
    3a3e:	f7 81       	ldd	r31, Z+7	; 0x07
    3a40:	e0 2d       	mov	r30, r0
    3a42:	19 95       	eicall
    3a44:	4c 01       	movw	r8, r24
			completeMsg[completeMsgSize - 1] = checksumB;
		
			serialDriver->startTimer();
		
			//iterate over the bytes and transmit them, unless there was an error.
			for (int i = 0; i < completeMsgSize && status == 0; i++)
    3a46:	0f 5f       	subi	r16, 0xFF	; 255
    3a48:	1f 4f       	sbci	r17, 0xFF	; 255
    3a4a:	b9 cf       	rjmp	.-142    	; 0x39be <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE+0xfa>
		
		}
	
	}
	
	return status;
    3a4c:	88 2d       	mov	r24, r8
    3a4e:	99 2d       	mov	r25, r9
}
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	f8 94       	cli
    3a54:	5e be       	out	0x3e, r5	; 62
    3a56:	0f be       	out	0x3f, r0	; 63
    3a58:	4d be       	out	0x3d, r4	; 61
    3a5a:	0f 90       	pop	r0
    3a5c:	0f 90       	pop	r0
    3a5e:	0f 90       	pop	r0
    3a60:	0f 90       	pop	r0
    3a62:	df 91       	pop	r29
    3a64:	cf 91       	pop	r28
    3a66:	1f 91       	pop	r17
    3a68:	0f 91       	pop	r16
    3a6a:	ff 90       	pop	r15
    3a6c:	ef 90       	pop	r14
    3a6e:	df 90       	pop	r13
    3a70:	cf 90       	pop	r12
    3a72:	bf 90       	pop	r11
    3a74:	af 90       	pop	r10
    3a76:	9f 90       	pop	r9
    3a78:	8f 90       	pop	r8
    3a7a:	7f 90       	pop	r7
    3a7c:	6f 90       	pop	r6
    3a7e:	5f 90       	pop	r5
    3a80:	4f 90       	pop	r4
    3a82:	3f 90       	pop	r3
    3a84:	2f 90       	pop	r2
    3a86:	08 95       	ret

00003a88 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>:
 * a lot of data is constantly received before that timeout, and none of the data
 * is a sync byte, then this method will never stop receiving bytes and will
 * lock up the rest of the system. So the helicopter would crash waiting for data.
 */
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
    3a88:	2f 92       	push	r2
    3a8a:	3f 92       	push	r3
    3a8c:	4f 92       	push	r4
    3a8e:	5f 92       	push	r5
    3a90:	6f 92       	push	r6
    3a92:	7f 92       	push	r7
    3a94:	8f 92       	push	r8
    3a96:	9f 92       	push	r9
    3a98:	af 92       	push	r10
    3a9a:	bf 92       	push	r11
    3a9c:	cf 92       	push	r12
    3a9e:	df 92       	push	r13
    3aa0:	ef 92       	push	r14
    3aa2:	ff 92       	push	r15
    3aa4:	0f 93       	push	r16
    3aa6:	1f 93       	push	r17
    3aa8:	cf 93       	push	r28
    3aaa:	df 93       	push	r29
    3aac:	cd b7       	in	r28, 0x3d	; 61
    3aae:	de b7       	in	r29, 0x3e	; 62
    3ab0:	28 97       	sbiw	r28, 0x08	; 8
    3ab2:	0f b6       	in	r0, 0x3f	; 63
    3ab4:	f8 94       	cli
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	6c 01       	movw	r12, r24
    3abe:	4b 01       	movw	r8, r22
	}
	
	serialDriver->stopTimer();
	
	return status;
    3ac0:	ad b6       	in	r10, 0x3d	; 61
    3ac2:	be b6       	in	r11, 0x3e	; 62
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    byte thirdSyncByte = 0;
    3ac4:	1e 82       	std	Y+6, r1	; 0x06
	
	/**
	 * Start the timer to prevent the system from waiting indefinitely
	 * while it receives data (thus causing the helicopter to crash)
	 */
	serialDriver->startTimer();
    3ac6:	dc 01       	movw	r26, r24
    3ac8:	8d 91       	ld	r24, X+
    3aca:	9c 91       	ld	r25, X
    3acc:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
int GroundControlStationInterface::receive(Message * &receivedMessage)
{
	int status = 0;
	
    byte firstSyncByte = 0;
    byte secondSyncByte = 0;
    3ad0:	00 e0       	ldi	r16, 0x00	; 0
    3ad2:	ed c0       	rjmp	.+474    	; 0x3cae <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x226>
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3ad4:	12 36       	cpi	r17, 0x62	; 98
    3ad6:	21 f4       	brne	.+8      	; 0x3ae0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3ad8:	8e 81       	ldd	r24, Y+6	; 0x06
    3ada:	87 3d       	cpi	r24, 0xD7	; 215
    3adc:	09 f4       	brne	.+2      	; 0x3ae0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3ade:	fa c0       	rjmp	.+500    	; 0x3cd4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24c>
    3ae0:	bf ef       	ldi	r27, 0xFF	; 255
    3ae2:	eb 16       	cp	r14, r27
    3ae4:	fb 06       	cpc	r15, r27
    3ae6:	09 f0       	breq	.+2      	; 0x3aea <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x62>
    3ae8:	e1 c0       	rjmp	.+450    	; 0x3cac <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x224>
    3aea:	dc c0       	rjmp	.+440    	; 0x3ca4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
	}
	
	if (status == 0)
	{
		//once we have found a valid message, get the message ID
		byte msgType = 0;
    3aec:	1d 82       	std	Y+5, r1	; 0x05
		
		status = serialDriver->receive(msgType);
    3aee:	f6 01       	movw	r30, r12
    3af0:	80 81       	ld	r24, Z
    3af2:	91 81       	ldd	r25, Z+1	; 0x01
    3af4:	dc 01       	movw	r26, r24
    3af6:	ed 91       	ld	r30, X+
    3af8:	fc 91       	ld	r31, X
    3afa:	02 88       	ldd	r0, Z+18	; 0x12
    3afc:	f3 89       	ldd	r31, Z+19	; 0x13
    3afe:	e0 2d       	mov	r30, r0
    3b00:	be 01       	movw	r22, r28
    3b02:	6b 5f       	subi	r22, 0xFB	; 251
    3b04:	7f 4f       	sbci	r23, 0xFF	; 255
    3b06:	19 95       	eicall
    3b08:	7c 01       	movw	r14, r24
		
		if (status == 0)
    3b0a:	00 97       	sbiw	r24, 0x00	; 0
    3b0c:	09 f0       	breq	.+2      	; 0x3b10 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x88>
    3b0e:	ca c0       	rjmp	.+404    	; 0x3ca4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
		{
			int msgSize = 0;
			
			switch(msgType)
    3b10:	8d 81       	ldd	r24, Y+5	; 0x05
    3b12:	84 30       	cpi	r24, 0x04	; 4
    3b14:	09 f4       	brne	.+2      	; 0x3b18 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x90>
    3b16:	e3 c0       	rjmp	.+454    	; 0x3cde <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x256>
    3b18:	20 f4       	brcc	.+8      	; 0x3b22 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x9a>
    3b1a:	82 30       	cpi	r24, 0x02	; 2
    3b1c:	09 f0       	breq	.+2      	; 0x3b20 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x98>
    3b1e:	b9 c0       	rjmp	.+370    	; 0x3c92 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x20a>
    3b20:	0c c0       	rjmp	.+24     	; 0x3b3a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xb2>
    3b22:	86 30       	cpi	r24, 0x06	; 6
    3b24:	09 f4       	brne	.+2      	; 0x3b28 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xa0>
    3b26:	e1 c0       	rjmp	.+450    	; 0x3cea <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x262>
    3b28:	87 30       	cpi	r24, 0x07	; 7
    3b2a:	09 f0       	breq	.+2      	; 0x3b2e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xa6>
    3b2c:	b2 c0       	rjmp	.+356    	; 0x3c92 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x20a>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
					break;
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
    3b2e:	0f 2e       	mov	r0, r31
    3b30:	f1 e6       	ldi	r31, 0x61	; 97
    3b32:	6f 2e       	mov	r6, r31
    3b34:	71 2c       	mov	r7, r1
    3b36:	f0 2d       	mov	r31, r0
					break;					
    3b38:	06 c0       	rjmp	.+12     	; 0x3b46 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
			int msgSize = 0;
			
			switch(msgType)
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
    3b3a:	0f 2e       	mov	r0, r31
    3b3c:	fd e2       	ldi	r31, 0x2D	; 45
    3b3e:	6f 2e       	mov	r6, r31
    3b40:	77 24       	eor	r7, r7
    3b42:	73 94       	inc	r7
    3b44:	f0 2d       	mov	r31, r0
    3b46:	bd b7       	in	r27, 0x3d	; 61
    3b48:	bf 83       	std	Y+7, r27	; 0x07
    3b4a:	ee b7       	in	r30, 0x3e	; 62
    3b4c:	e8 87       	std	Y+8, r30	; 0x08
					break;
			}
			
			if (status == 0)
			{
				byte messagePayload[msgSize];
    3b4e:	2d b7       	in	r18, 0x3d	; 61
    3b50:	3e b7       	in	r19, 0x3e	; 62
    3b52:	26 19       	sub	r18, r6
    3b54:	37 09       	sbc	r19, r7
    3b56:	0f b6       	in	r0, 0x3f	; 63
    3b58:	f8 94       	cli
    3b5a:	3e bf       	out	0x3e, r19	; 62
    3b5c:	0f be       	out	0x3f, r0	; 63
    3b5e:	2d bf       	out	0x3d, r18	; 61
    3b60:	2d b6       	in	r2, 0x3d	; 61
    3b62:	3e b6       	in	r3, 0x3e	; 62
    3b64:	a1 e0       	ldi	r26, 0x01	; 1
    3b66:	b0 e0       	ldi	r27, 0x00	; 0
    3b68:	2a 0e       	add	r2, r26
    3b6a:	3b 1e       	adc	r3, r27
    3b6c:	21 01       	movw	r4, r2
							
				messagePayload[0] = msgType;
    3b6e:	ed b7       	in	r30, 0x3d	; 61
    3b70:	fe b7       	in	r31, 0x3e	; 62
    3b72:	81 83       	std	Z+1, r24	; 0x01
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    3b74:	01 e0       	ldi	r16, 0x01	; 1
    3b76:	10 e0       	ldi	r17, 0x00	; 0
    3b78:	06 15       	cp	r16, r6
    3b7a:	17 05       	cpc	r17, r7
    3b7c:	0c f0       	brlt	.+2      	; 0x3b80 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xf8>
    3b7e:	bb c0       	rjmp	.+374    	; 0x3cf6 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x26e>
    3b80:	e1 14       	cp	r14, r1
    3b82:	f1 04       	cpc	r15, r1
    3b84:	09 f4       	brne	.+2      	; 0x3b88 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x100>
    3b86:	bb c0       	rjmp	.+374    	; 0x3cfe <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x276>
    3b88:	7a c0       	rjmp	.+244    	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
				}
							
				if (status == 0)
				{
					//Read the two checksum bytes
					byte messageChecksumA = 0;
    3b8a:	1c 82       	std	Y+4, r1	; 0x04
					byte messageChecksumB = 0;
    3b8c:	1b 82       	std	Y+3, r1	; 0x03
					byte calculatedChecksumA = 0;
    3b8e:	1a 82       	std	Y+2, r1	; 0x02
					byte calculatedChecksumB = 0;
    3b90:	19 82       	std	Y+1, r1	; 0x01
								
					status = serialDriver->receive(messageChecksumA);
    3b92:	d6 01       	movw	r26, r12
    3b94:	8d 91       	ld	r24, X+
    3b96:	9c 91       	ld	r25, X
    3b98:	dc 01       	movw	r26, r24
    3b9a:	ed 91       	ld	r30, X+
    3b9c:	fc 91       	ld	r31, X
    3b9e:	02 88       	ldd	r0, Z+18	; 0x12
    3ba0:	f3 89       	ldd	r31, Z+19	; 0x13
    3ba2:	e0 2d       	mov	r30, r0
    3ba4:	be 01       	movw	r22, r28
    3ba6:	6c 5f       	subi	r22, 0xFC	; 252
    3ba8:	7f 4f       	sbci	r23, 0xFF	; 255
    3baa:	19 95       	eicall
    3bac:	7c 01       	movw	r14, r24
					
					if (status == 0)
    3bae:	00 97       	sbiw	r24, 0x00	; 0
    3bb0:	09 f0       	breq	.+2      	; 0x3bb4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x12c>
    3bb2:	65 c0       	rjmp	.+202    	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
					{
						status = serialDriver->receive(messageChecksumB);
    3bb4:	f6 01       	movw	r30, r12
    3bb6:	80 81       	ld	r24, Z
    3bb8:	91 81       	ldd	r25, Z+1	; 0x01
    3bba:	dc 01       	movw	r26, r24
    3bbc:	ed 91       	ld	r30, X+
    3bbe:	fc 91       	ld	r31, X
    3bc0:	02 88       	ldd	r0, Z+18	; 0x12
    3bc2:	f3 89       	ldd	r31, Z+19	; 0x13
    3bc4:	e0 2d       	mov	r30, r0
    3bc6:	be 01       	movw	r22, r28
    3bc8:	6d 5f       	subi	r22, 0xFD	; 253
    3bca:	7f 4f       	sbci	r23, 0xFF	; 255
    3bcc:	19 95       	eicall
    3bce:	7c 01       	movw	r14, r24
						
						if (status == 0)
    3bd0:	00 97       	sbiw	r24, 0x00	; 0
    3bd2:	09 f0       	breq	.+2      	; 0x3bd6 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x14e>
    3bd4:	54 c0       	rjmp	.+168    	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
						{
							//Generate checksum for the message
							calculateChecksum(messagePayload, msgSize, calculatedChecksumA, calculatedChecksumB);
    3bd6:	8e 01       	movw	r16, r28
    3bd8:	0f 5f       	subi	r16, 0xFF	; 255
    3bda:	1f 4f       	sbci	r17, 0xFF	; 255
    3bdc:	9e 01       	movw	r18, r28
    3bde:	2e 5f       	subi	r18, 0xFE	; 254
    3be0:	3f 4f       	sbci	r19, 0xFF	; 255
    3be2:	a3 01       	movw	r20, r6
    3be4:	62 2d       	mov	r22, r2
    3be6:	73 2d       	mov	r23, r3
    3be8:	c6 01       	movw	r24, r12
    3bea:	0e 94 46 1c 	call	0x388c	; 0x388c <_ZN10helicopter10interfaces29GroundControlStationInterface17calculateChecksumEPhiRhS3_>
						
							//verify that the checksum is correct
							if (calculatedChecksumA == messageChecksumA && calculatedChecksumB == messageChecksumB)
    3bee:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    3bf2:	98 13       	cpse	r25, r24
    3bf4:	30 c0       	rjmp	.+96     	; 0x3c56 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ce>
    3bf6:	99 81       	ldd	r25, Y+1	; 0x01
    3bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfa:	98 13       	cpse	r25, r24
    3bfc:	33 c0       	rjmp	.+102    	; 0x3c64 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1dc>
							{
								//build the message
								switch(msgType)
    3bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    3c00:	84 30       	cpi	r24, 0x04	; 4
    3c02:	89 f0       	breq	.+34     	; 0x3c26 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x19e>
    3c04:	18 f4       	brcc	.+6      	; 0x3c0c <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x184>
    3c06:	82 30       	cpi	r24, 0x02	; 2
    3c08:	a1 f5       	brne	.+104    	; 0x3c72 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ea>
    3c0a:	05 c0       	rjmp	.+10     	; 0x3c16 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x18e>
    3c0c:	86 30       	cpi	r24, 0x06	; 6
    3c0e:	99 f0       	breq	.+38     	; 0x3c36 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ae>
    3c10:	87 30       	cpi	r24, 0x07	; 7
    3c12:	79 f5       	brne	.+94     	; 0x3c72 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1ea>
    3c14:	18 c0       	rjmp	.+48     	; 0x3c46 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1be>
								{
									case SystemTelemetryMessage::MessageType:
									receivedMessage = SystemTelemetryMessage::buildMessageSt(messagePayload);
    3c16:	82 2d       	mov	r24, r2
    3c18:	93 2d       	mov	r25, r3
    3c1a:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>
    3c1e:	f4 01       	movw	r30, r8
    3c20:	91 83       	std	Z+1, r25	; 0x01
    3c22:	80 83       	st	Z, r24
									break;
    3c24:	2c c0       	rjmp	.+88     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case SensorDataMessage::MessageType:
									receivedMessage = SensorDataMessage::buildMessageSt(messagePayload);
    3c26:	82 2d       	mov	r24, r2
    3c28:	93 2d       	mov	r25, r3
    3c2a:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>
    3c2e:	d4 01       	movw	r26, r8
    3c30:	8d 93       	st	X+, r24
    3c32:	9c 93       	st	X, r25
									break;
    3c34:	24 c0       	rjmp	.+72     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case SimpleTelemetryMessage::MessageType:
									receivedMessage = SimpleTelemetryMessage::buildMessageSt(messagePayload);
    3c36:	82 2d       	mov	r24, r2
    3c38:	93 2d       	mov	r25, r3
    3c3a:	0e 94 73 2b 	call	0x56e6	; 0x56e6 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>
    3c3e:	f4 01       	movw	r30, r8
    3c40:	91 83       	std	Z+1, r25	; 0x01
    3c42:	80 83       	st	Z, r24
									break;
    3c44:	1c c0       	rjmp	.+56     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
    3c46:	82 2d       	mov	r24, r2
    3c48:	93 2d       	mov	r25, r3
    3c4a:	0e 94 f3 25 	call	0x4be6	; 0x4be6 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>
    3c4e:	d4 01       	movw	r26, r8
    3c50:	8d 93       	st	X+, r24
    3c52:	9c 93       	st	X, r25
									break;
    3c54:	14 c0       	rjmp	.+40     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									break;
								}
							}else
							{
								//checksum mismatch
								status = -4;
    3c56:	0f 2e       	mov	r0, r31
    3c58:	fc ef       	ldi	r31, 0xFC	; 252
    3c5a:	ef 2e       	mov	r14, r31
    3c5c:	ff 24       	eor	r15, r15
    3c5e:	fa 94       	dec	r15
    3c60:	f0 2d       	mov	r31, r0
    3c62:	0d c0       	rjmp	.+26     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
    3c64:	0f 2e       	mov	r0, r31
    3c66:	fc ef       	ldi	r31, 0xFC	; 252
    3c68:	ef 2e       	mov	r14, r31
    3c6a:	ff 24       	eor	r15, r15
    3c6c:	fa 94       	dec	r15
    3c6e:	f0 2d       	mov	r31, r0
    3c70:	06 c0       	rjmp	.+12     	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
									case GainsMessage::MessageType:
									receivedMessage = GainsMessage::buildMessageSt(messagePayload);
									break;
									default:
									//unrecognized message type.
									status = -3;
    3c72:	0f 2e       	mov	r0, r31
    3c74:	fd ef       	ldi	r31, 0xFD	; 253
    3c76:	ef 2e       	mov	r14, r31
    3c78:	ff 24       	eor	r15, r15
    3c7a:	fa 94       	dec	r15
    3c7c:	f0 2d       	mov	r31, r0
    3c7e:	3f 81       	ldd	r19, Y+7	; 0x07
    3c80:	28 85       	ldd	r18, Y+8	; 0x08
    3c82:	83 2f       	mov	r24, r19
    3c84:	92 2f       	mov	r25, r18
    3c86:	0f b6       	in	r0, 0x3f	; 63
    3c88:	f8 94       	cli
    3c8a:	9e bf       	out	0x3e, r25	; 62
    3c8c:	0f be       	out	0x3f, r0	; 63
    3c8e:	8d bf       	out	0x3d, r24	; 61
    3c90:	06 c0       	rjmp	.+12     	; 0x3c9e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x216>
				case GainsMessage::MessageType:
					msgSize = GainsMessage::MessageSize;
					break;					
				default:
					//unrecognized message type.
					status = -3;
    3c92:	0f 2e       	mov	r0, r31
    3c94:	fd ef       	ldi	r31, 0xFD	; 253
    3c96:	ef 2e       	mov	r14, r31
    3c98:	ff 24       	eor	r15, r15
    3c9a:	fa 94       	dec	r15
    3c9c:	f0 2d       	mov	r31, r0
				}
			}
		}
	}
	
	if (status != 0)
    3c9e:	e1 14       	cp	r14, r1
    3ca0:	f1 04       	cpc	r15, r1
    3ca2:	f1 f1       	breq	.+124    	; 0x3d20 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x298>
	{
		receivedMessage = NULL;
    3ca4:	f4 01       	movw	r30, r8
    3ca6:	11 82       	std	Z+1, r1	; 0x01
    3ca8:	10 82       	st	Z, r1
    3caa:	3a c0       	rjmp	.+116    	; 0x3d20 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x298>
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3cac:	01 2f       	mov	r16, r17
	{
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
    3cae:	1e 81       	ldd	r17, Y+6	; 0x06
		status = serialDriver->receive(thirdSyncByte);
    3cb0:	f6 01       	movw	r30, r12
    3cb2:	80 81       	ld	r24, Z
    3cb4:	91 81       	ldd	r25, Z+1	; 0x01
    3cb6:	dc 01       	movw	r26, r24
    3cb8:	ed 91       	ld	r30, X+
    3cba:	fc 91       	ld	r31, X
    3cbc:	02 88       	ldd	r0, Z+18	; 0x12
    3cbe:	f3 89       	ldd	r31, Z+19	; 0x13
    3cc0:	e0 2d       	mov	r30, r0
    3cc2:	be 01       	movw	r22, r28
    3cc4:	6a 5f       	subi	r22, 0xFA	; 250
    3cc6:	7f 4f       	sbci	r23, 0xFF	; 255
    3cc8:	19 95       	eicall
    3cca:	7c 01       	movw	r14, r24
	serialDriver->startTimer();

	//Read until the sync bytes are received or we time out.
	//Throw away any 'garbage' bytes.
	//while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status == 0)
	while(!(firstSyncByte == SyncByte1 && secondSyncByte == SyncByte2 && thirdSyncByte == SyncByte3) && status != -1) //!= -1 because for -2, we want to ignore buffer overruns.
    3ccc:	05 3b       	cpi	r16, 0xB5	; 181
    3cce:	09 f0       	breq	.+2      	; 0x3cd2 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x24a>
    3cd0:	07 cf       	rjmp	.-498    	; 0x3ae0 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x58>
    3cd2:	00 cf       	rjmp	.-512    	; 0x3ad4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x4c>
		firstSyncByte = secondSyncByte;
		secondSyncByte = thirdSyncByte;
		status = serialDriver->receive(thirdSyncByte);
	}
	
	if (status == 0)
    3cd4:	e1 14       	cp	r14, r1
    3cd6:	f1 04       	cpc	r15, r1
    3cd8:	09 f4       	brne	.+2      	; 0x3cdc <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x254>
    3cda:	08 cf       	rjmp	.-496    	; 0x3aec <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x64>
    3cdc:	e3 cf       	rjmp	.-58     	; 0x3ca4 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x21c>
			{
				case SystemTelemetryMessage::MessageType:
					msgSize = SystemTelemetryMessage::MessageSize;
					break;
				case SensorDataMessage::MessageType:
					msgSize = SensorDataMessage::MessageSize;
    3cde:	0f 2e       	mov	r0, r31
    3ce0:	f1 e4       	ldi	r31, 0x41	; 65
    3ce2:	6f 2e       	mov	r6, r31
    3ce4:	71 2c       	mov	r7, r1
    3ce6:	f0 2d       	mov	r31, r0
    3ce8:	2e cf       	rjmp	.-420    	; 0x3b46 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
					break;
				case SimpleTelemetryMessage::MessageType:
					msgSize = SimpleTelemetryMessage::MessageSize;
    3cea:	0f 2e       	mov	r0, r31
    3cec:	f9 e7       	ldi	r31, 0x79	; 121
    3cee:	6f 2e       	mov	r6, r31
    3cf0:	71 2c       	mov	r7, r1
    3cf2:	f0 2d       	mov	r31, r0
    3cf4:	28 cf       	rjmp	.-432    	; 0x3b46 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xbe>
				for (int i = 1; i < msgSize && status == 0; i++)
				{
					status = serialDriver->receive(messagePayload[i]);
				}
							
				if (status == 0)
    3cf6:	e1 14       	cp	r14, r1
    3cf8:	f1 04       	cpc	r15, r1
    3cfa:	09 f6       	brne	.-126    	; 0x3c7e <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x1f6>
    3cfc:	46 cf       	rjmp	.-372    	; 0x3b8a <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0x102>
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
				{
					status = serialDriver->receive(messagePayload[i]);
    3cfe:	f6 01       	movw	r30, r12
    3d00:	80 81       	ld	r24, Z
    3d02:	91 81       	ldd	r25, Z+1	; 0x01
    3d04:	dc 01       	movw	r26, r24
    3d06:	ed 91       	ld	r30, X+
    3d08:	fc 91       	ld	r31, X
    3d0a:	b2 01       	movw	r22, r4
    3d0c:	60 0f       	add	r22, r16
    3d0e:	71 1f       	adc	r23, r17
    3d10:	02 88       	ldd	r0, Z+18	; 0x12
    3d12:	f3 89       	ldd	r31, Z+19	; 0x13
    3d14:	e0 2d       	mov	r30, r0
    3d16:	19 95       	eicall
    3d18:	7c 01       	movw	r14, r24
							
				messagePayload[0] = msgType;
							
				//Read the bytes in the payload of the message.
				//skip the first position since thats where the message type is located.
				for (int i = 1; i < msgSize && status == 0; i++)
    3d1a:	0f 5f       	subi	r16, 0xFF	; 255
    3d1c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d1e:	2c cf       	rjmp	.-424    	; 0x3b78 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE+0xf0>
	if (status != 0)
	{
		receivedMessage = NULL;
	}
	
	serialDriver->stopTimer();
    3d20:	d6 01       	movw	r26, r12
    3d22:	8d 91       	ld	r24, X+
    3d24:	9c 91       	ld	r25, X
    3d26:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
    3d2a:	8e 2d       	mov	r24, r14
    3d2c:	9f 2d       	mov	r25, r15
    3d2e:	0f b6       	in	r0, 0x3f	; 63
    3d30:	f8 94       	cli
    3d32:	be be       	out	0x3e, r11	; 62
    3d34:	0f be       	out	0x3f, r0	; 63
    3d36:	ad be       	out	0x3d, r10	; 61
    3d38:	28 96       	adiw	r28, 0x08	; 8
    3d3a:	0f b6       	in	r0, 0x3f	; 63
    3d3c:	f8 94       	cli
    3d3e:	de bf       	out	0x3e, r29	; 62
    3d40:	0f be       	out	0x3f, r0	; 63
    3d42:	cd bf       	out	0x3d, r28	; 61
    3d44:	df 91       	pop	r29
    3d46:	cf 91       	pop	r28
    3d48:	1f 91       	pop	r17
    3d4a:	0f 91       	pop	r16
    3d4c:	ff 90       	pop	r15
    3d4e:	ef 90       	pop	r14
    3d50:	df 90       	pop	r13
    3d52:	cf 90       	pop	r12
    3d54:	bf 90       	pop	r11
    3d56:	af 90       	pop	r10
    3d58:	9f 90       	pop	r9
    3d5a:	8f 90       	pop	r8
    3d5c:	7f 90       	pop	r7
    3d5e:	6f 90       	pop	r6
    3d60:	5f 90       	pop	r5
    3d62:	4f 90       	pop	r4
    3d64:	3f 90       	pop	r3
    3d66:	2f 90       	pop	r2
    3d68:	08 95       	ret

00003d6a <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>:
const float RadioControllerInterface::SWASHOFFSETELEVATORMULTIPLYER = 2.0f;
const float RadioControllerInterface::SWASHOFFSETELEVATORELEVATORMULTIPLYER = 4.0f;
const float RadioControllerInterface::SWASHOFFSETSAILERONMULTIPLIER = 3.37209302325581;

float RadioControllerInterface::calculatePWMCompareMatchFromControlValue(float controlValue)
{
    3d6a:	cf 92       	push	r12
    3d6c:	df 92       	push	r13
    3d6e:	ef 92       	push	r14
    3d70:	ff 92       	push	r15
    3d72:	0f 93       	push	r16
    3d74:	1f 93       	push	r17
    3d76:	cf 93       	push	r28
    3d78:	df 93       	push	r29
    3d7a:	cb 01       	movw	r24, r22
    3d7c:	ba 01       	movw	r22, r20
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
    3d7e:	20 e0       	ldi	r18, 0x00	; 0
    3d80:	30 e0       	ldi	r19, 0x00	; 0
    3d82:	40 e8       	ldi	r20, 0x80	; 128
    3d84:	5f e3       	ldi	r21, 0x3F	; 63
    3d86:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    3d8a:	20 e0       	ldi	r18, 0x00	; 0
    3d8c:	30 e0       	ldi	r19, 0x00	; 0
    3d8e:	4a ef       	ldi	r20, 0xFA	; 250
    3d90:	53 ec       	ldi	r21, 0xC3	; 195
    3d92:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    3d96:	20 e0       	ldi	r18, 0x00	; 0
    3d98:	30 e7       	ldi	r19, 0x70	; 112
    3d9a:	44 e9       	ldi	r20, 0x94	; 148
    3d9c:	56 e4       	ldi	r21, 0x46	; 70
    3d9e:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    3da2:	06 2f       	mov	r16, r22
    3da4:	17 2f       	mov	r17, r23
    3da6:	d8 2f       	mov	r29, r24
    3da8:	c9 2f       	mov	r28, r25
    3daa:	c6 2e       	mov	r12, r22
    3dac:	d7 2e       	mov	r13, r23
    3dae:	e8 2e       	mov	r14, r24
    3db0:	f9 2e       	mov	r15, r25
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
    3db2:	20 e0       	ldi	r18, 0x00	; 0
    3db4:	30 e7       	ldi	r19, 0x70	; 112
    3db6:	44 e9       	ldi	r20, 0x94	; 148
    3db8:	56 e4       	ldi	r21, 0x46	; 70
    3dba:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    3dbe:	18 16       	cp	r1, r24
    3dc0:	6c f0       	brlt	.+26     	; 0x3ddc <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0x72>
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
    3dc2:	20 e0       	ldi	r18, 0x00	; 0
    3dc4:	30 ea       	ldi	r19, 0xA0	; 160
    3dc6:	4c e8       	ldi	r20, 0x8C	; 140
    3dc8:	56 e4       	ldi	r21, 0x46	; 70
    3dca:	60 2f       	mov	r22, r16
    3dcc:	71 2f       	mov	r23, r17
    3dce:	8d 2f       	mov	r24, r29
    3dd0:	9c 2f       	mov	r25, r28
    3dd2:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    3dd6:	88 23       	and	r24, r24
    3dd8:	7c f0       	brlt	.+30     	; 0x3df8 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0x8e>
    3dda:	1b c0       	rjmp	.+54     	; 0x3e12 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0xa8>
	//Equation for scaling a value: new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
	float scaledValue = (PWM_COMPAREMATCH_MAX_TICKS - PWM_COMPAREMATCH_MIN_TICKS) / (1.0f - -1.0f) * (controlValue - -1.0f) + PWM_COMPAREMATCH_MIN_TICKS;
	
	if (scaledValue > PWM_COMPAREMATCH_MIN_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MIN_TICKS;
    3ddc:	c1 2c       	mov	r12, r1
    3dde:	0f 2e       	mov	r0, r31
    3de0:	f0 e7       	ldi	r31, 0x70	; 112
    3de2:	df 2e       	mov	r13, r31
    3de4:	f0 2d       	mov	r31, r0
    3de6:	0f 2e       	mov	r0, r31
    3de8:	f4 e9       	ldi	r31, 0x94	; 148
    3dea:	ef 2e       	mov	r14, r31
    3dec:	f0 2d       	mov	r31, r0
    3dee:	0f 2e       	mov	r0, r31
    3df0:	f6 e4       	ldi	r31, 0x46	; 70
    3df2:	ff 2e       	mov	r15, r31
    3df4:	f0 2d       	mov	r31, r0
    3df6:	0d c0       	rjmp	.+26     	; 0x3e12 <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf+0xa8>
	}else if (scaledValue < PWM_COMPAREMATCH_MAX_TICKS)
	{
		scaledValue = PWM_COMPAREMATCH_MAX_TICKS;
    3df8:	c1 2c       	mov	r12, r1
    3dfa:	0f 2e       	mov	r0, r31
    3dfc:	f0 ea       	ldi	r31, 0xA0	; 160
    3dfe:	df 2e       	mov	r13, r31
    3e00:	f0 2d       	mov	r31, r0
    3e02:	0f 2e       	mov	r0, r31
    3e04:	fc e8       	ldi	r31, 0x8C	; 140
    3e06:	ef 2e       	mov	r14, r31
    3e08:	f0 2d       	mov	r31, r0
    3e0a:	0f 2e       	mov	r0, r31
    3e0c:	f6 e4       	ldi	r31, 0x46	; 70
    3e0e:	ff 2e       	mov	r15, r31
    3e10:	f0 2d       	mov	r31, r0
	}
	
	return scaledValue;	
	
}
    3e12:	6c 2d       	mov	r22, r12
    3e14:	7d 2d       	mov	r23, r13
    3e16:	8e 2d       	mov	r24, r14
    3e18:	9f 2d       	mov	r25, r15
    3e1a:	df 91       	pop	r29
    3e1c:	cf 91       	pop	r28
    3e1e:	1f 91       	pop	r17
    3e20:	0f 91       	pop	r16
    3e22:	ff 90       	pop	r15
    3e24:	ef 90       	pop	r14
    3e26:	df 90       	pop	r13
    3e28:	cf 90       	pop	r12
    3e2a:	08 95       	ret

00003e2c <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>:

/**
 * Equation for scaling values new_v = (new_max - new_min) / (old_max - old_min) * (v - old_min) + new_min
 */
float RadioControllerInterface::ScaleValue(long servoChannelPulseWidth) 
{
    3e2c:	cf 92       	push	r12
    3e2e:	df 92       	push	r13
    3e30:	ef 92       	push	r14
    3e32:	ff 92       	push	r15
    3e34:	0f 93       	push	r16
    3e36:	1f 93       	push	r17
    3e38:	cf 93       	push	r28
    3e3a:	df 93       	push	r29
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
    3e3c:	cb 01       	movw	r24, r22
    3e3e:	ba 01       	movw	r22, r20
    3e40:	60 5d       	subi	r22, 0xD0	; 208
    3e42:	77 40       	sbci	r23, 0x07	; 7
    3e44:	81 09       	sbc	r24, r1
    3e46:	91 09       	sbc	r25, r1
    3e48:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    3e4c:	2f e6       	ldi	r18, 0x6F	; 111
    3e4e:	32 e1       	ldi	r19, 0x12	; 18
    3e50:	43 e8       	ldi	r20, 0x83	; 131
    3e52:	5a e3       	ldi	r21, 0x3A	; 58
    3e54:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    3e58:	20 e0       	ldi	r18, 0x00	; 0
    3e5a:	30 e0       	ldi	r19, 0x00	; 0
    3e5c:	40 e8       	ldi	r20, 0x80	; 128
    3e5e:	5f e3       	ldi	r21, 0x3F	; 63
    3e60:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    3e64:	06 2f       	mov	r16, r22
    3e66:	17 2f       	mov	r17, r23
    3e68:	d8 2f       	mov	r29, r24
    3e6a:	c9 2f       	mov	r28, r25
    3e6c:	c6 2e       	mov	r12, r22
    3e6e:	d7 2e       	mov	r13, r23
    3e70:	e8 2e       	mov	r14, r24
    3e72:	f9 2e       	mov	r15, r25
			
	if (scaledValue > 1.0f)
    3e74:	20 e0       	ldi	r18, 0x00	; 0
    3e76:	30 e0       	ldi	r19, 0x00	; 0
    3e78:	40 e8       	ldi	r20, 0x80	; 128
    3e7a:	5f e3       	ldi	r21, 0x3F	; 63
    3e7c:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    3e80:	18 16       	cp	r1, r24
    3e82:	6c f0       	brlt	.+26     	; 0x3e9e <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x72>
	{
		scaledValue = 1.0f;
	}else if (scaledValue < -1.0f)
    3e84:	20 e0       	ldi	r18, 0x00	; 0
    3e86:	30 e0       	ldi	r19, 0x00	; 0
    3e88:	40 e8       	ldi	r20, 0x80	; 128
    3e8a:	5f eb       	ldi	r21, 0xBF	; 191
    3e8c:	60 2f       	mov	r22, r16
    3e8e:	71 2f       	mov	r23, r17
    3e90:	8d 2f       	mov	r24, r29
    3e92:	9c 2f       	mov	r25, r28
    3e94:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    3e98:	88 23       	and	r24, r24
    3e9a:	a4 f4       	brge	.+40     	; 0x3ec4 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x98>
    3e9c:	0a c0       	rjmp	.+20     	; 0x3eb2 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x86>
	//float scaledValue = (1.0f - -1.0f) / (4000.0f - 2000.0f) * (servoChannelPulseWidth - 2000.0f) + -1.0f;
	float scaledValue = (1.0f - -1.0f) / (MAX_PULSE_WIDTH - MIN_PULSE_WIDTH) * (servoChannelPulseWidth - MIN_PULSE_WIDTH) + -1.0f;
			
	if (scaledValue > 1.0f)
	{
		scaledValue = 1.0f;
    3e9e:	c1 2c       	mov	r12, r1
    3ea0:	d1 2c       	mov	r13, r1
    3ea2:	68 94       	set
    3ea4:	ee 24       	eor	r14, r14
    3ea6:	e7 f8       	bld	r14, 7
    3ea8:	0f 2e       	mov	r0, r31
    3eaa:	ff e3       	ldi	r31, 0x3F	; 63
    3eac:	ff 2e       	mov	r15, r31
    3eae:	f0 2d       	mov	r31, r0
    3eb0:	09 c0       	rjmp	.+18     	; 0x3ec4 <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl+0x98>
	}else if (scaledValue < -1.0f)
	{
		scaledValue = -1.0f;
    3eb2:	c1 2c       	mov	r12, r1
    3eb4:	d1 2c       	mov	r13, r1
    3eb6:	68 94       	set
    3eb8:	ee 24       	eor	r14, r14
    3eba:	e7 f8       	bld	r14, 7
    3ebc:	0f 2e       	mov	r0, r31
    3ebe:	ff eb       	ldi	r31, 0xBF	; 191
    3ec0:	ff 2e       	mov	r15, r31
    3ec2:	f0 2d       	mov	r31, r0
	}
	
	return scaledValue;
}
    3ec4:	6c 2d       	mov	r22, r12
    3ec6:	7d 2d       	mov	r23, r13
    3ec8:	8e 2d       	mov	r24, r14
    3eca:	9f 2d       	mov	r25, r15
    3ecc:	df 91       	pop	r29
    3ece:	cf 91       	pop	r28
    3ed0:	1f 91       	pop	r17
    3ed2:	0f 91       	pop	r16
    3ed4:	ff 90       	pop	r15
    3ed6:	ef 90       	pop	r14
    3ed8:	df 90       	pop	r13
    3eda:	cf 90       	pop	r12
    3edc:	08 95       	ret

00003ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>:

float RadioControllerInterface::convertPulseWidthToCompareMatch(long pulseWidth)
{
    3ede:	0f 93       	push	r16
    3ee0:	1f 93       	push	r17
	return (MAX_PPM_TIMER_VALUE - pulseWidth) / 2.0;
    3ee2:	80 e4       	ldi	r24, 0x40	; 64
    3ee4:	9c e9       	ldi	r25, 0x9C	; 156
    3ee6:	a0 e0       	ldi	r26, 0x00	; 0
    3ee8:	b0 e0       	ldi	r27, 0x00	; 0
    3eea:	8c 01       	movw	r16, r24
    3eec:	9d 01       	movw	r18, r26
    3eee:	04 1b       	sub	r16, r20
    3ef0:	15 0b       	sbc	r17, r21
    3ef2:	26 0b       	sbc	r18, r22
    3ef4:	37 0b       	sbc	r19, r23
    3ef6:	c9 01       	movw	r24, r18
    3ef8:	b8 01       	movw	r22, r16
    3efa:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    3efe:	20 e0       	ldi	r18, 0x00	; 0
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	40 e0       	ldi	r20, 0x00	; 0
    3f04:	5f e3       	ldi	r21, 0x3F	; 63
    3f06:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
}
    3f0a:	1f 91       	pop	r17
    3f0c:	0f 91       	pop	r16
    3f0e:	08 95       	ret

00003f10 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>:



RadioControllerInterface* RadioControllerInterface::getRadioControllerInterface()
{
	if (radioControllerInterface == NULL)
    3f10:	80 91 a2 03 	lds	r24, 0x03A2
    3f14:	90 91 a3 03 	lds	r25, 0x03A3
    3f18:	89 2b       	or	r24, r25
    3f1a:	09 f0       	breq	.+2      	; 0x3f1e <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0xe>
    3f1c:	57 c0       	rjmp	.+174    	; 0x3fcc <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0xbc>
	{
		radioControllerInterface = new RadioControllerInterface();
    3f1e:	89 e5       	ldi	r24, 0x59	; 89
    3f20:	90 e0       	ldi	r25, 0x00	; 0
    3f22:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>


				static RadioControllerInterface *radioControllerInterface;
			
				RadioControllerInterface():
				systemModel (NULL)
    3f26:	fc 01       	movw	r30, r24
    3f28:	e9 5a       	subi	r30, 0xA9	; 169
    3f2a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f2c:	11 82       	std	Z+1, r1	; 0x01
    3f2e:	10 82       	st	Z, r1
				{
					memset(workingServoChannelPulseWidths, 0, sizeof(workingServoChannelPulseWidths));
    3f30:	9c 01       	movw	r18, r24
    3f32:	2f 5f       	subi	r18, 0xFF	; 255
    3f34:	3f 4f       	sbci	r19, 0xFF	; 255
    3f36:	40 e2       	ldi	r20, 0x20	; 32
    3f38:	e2 2f       	mov	r30, r18
    3f3a:	f3 2f       	mov	r31, r19
    3f3c:	df 01       	movw	r26, r30
    3f3e:	24 2f       	mov	r18, r20
    3f40:	1d 92       	st	X+, r1
    3f42:	2a 95       	dec	r18
    3f44:	e9 f7       	brne	.-6      	; 0x3f40 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x30>
					memset(servoChannelPulseWidths, 0, sizeof(servoChannelPulseWidths));
    3f46:	9c 01       	movw	r18, r24
    3f48:	2f 5d       	subi	r18, 0xDF	; 223
    3f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f4c:	e2 2f       	mov	r30, r18
    3f4e:	f3 2f       	mov	r31, r19
    3f50:	df 01       	movw	r26, r30
    3f52:	1d 92       	st	X+, r1
    3f54:	4a 95       	dec	r20
    3f56:	e9 f7       	brne	.-6      	; 0x3f52 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv+0x42>
					
					previousInputCaptureRegisterValue = 0;
    3f58:	fc 01       	movw	r30, r24
    3f5a:	ef 5b       	subi	r30, 0xBF	; 191
    3f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f5e:	10 82       	st	Z, r1
    3f60:	11 82       	std	Z+1, r1	; 0x01
    3f62:	12 82       	std	Z+2, r1	; 0x02
    3f64:	13 82       	std	Z+3, r1	; 0x03
					
					servoChannelIndex = 0;
    3f66:	fc 01       	movw	r30, r24
    3f68:	eb 5b       	subi	r30, 0xBB	; 187
    3f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f6c:	11 82       	std	Z+1, r1	; 0x01
    3f6e:	10 82       	st	Z, r1
					
					channel1Offset = 0;
    3f70:	fc 01       	movw	r30, r24
    3f72:	e9 5b       	subi	r30, 0xB9	; 185
    3f74:	ff 4f       	sbci	r31, 0xFF	; 255
    3f76:	11 82       	std	Z+1, r1	; 0x01
    3f78:	10 82       	st	Z, r1
					channel2Offset = 0;
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	e7 5b       	subi	r30, 0xB7	; 183
    3f7e:	ff 4f       	sbci	r31, 0xFF	; 255
    3f80:	11 82       	std	Z+1, r1	; 0x01
    3f82:	10 82       	st	Z, r1
					channel3Offset = 0;
    3f84:	fc 01       	movw	r30, r24
    3f86:	e5 5b       	subi	r30, 0xB5	; 181
    3f88:	ff 4f       	sbci	r31, 0xFF	; 255
    3f8a:	11 82       	std	Z+1, r1	; 0x01
    3f8c:	10 82       	st	Z, r1
					channel4Offset = 0;
    3f8e:	fc 01       	movw	r30, r24
    3f90:	e3 5b       	subi	r30, 0xB3	; 179
    3f92:	ff 4f       	sbci	r31, 0xFF	; 255
    3f94:	11 82       	std	Z+1, r1	; 0x01
    3f96:	10 82       	st	Z, r1
					channel5Offset = 0;
    3f98:	fc 01       	movw	r30, r24
    3f9a:	e1 5b       	subi	r30, 0xB1	; 177
    3f9c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f9e:	11 82       	std	Z+1, r1	; 0x01
    3fa0:	10 82       	st	Z, r1
					channel6Offset = 0;
    3fa2:	fc 01       	movw	r30, r24
    3fa4:	ef 5a       	subi	r30, 0xAF	; 175
    3fa6:	ff 4f       	sbci	r31, 0xFF	; 255
    3fa8:	11 82       	std	Z+1, r1	; 0x01
    3faa:	10 82       	st	Z, r1
					channel7Offset = 0;
    3fac:	fc 01       	movw	r30, r24
    3fae:	ed 5a       	subi	r30, 0xAD	; 173
    3fb0:	ff 4f       	sbci	r31, 0xFF	; 255
    3fb2:	11 82       	std	Z+1, r1	; 0x01
    3fb4:	10 82       	st	Z, r1
					channel8Offset = 0;		
    3fb6:	fc 01       	movw	r30, r24
    3fb8:	eb 5a       	subi	r30, 0xAB	; 171
    3fba:	ff 4f       	sbci	r31, 0xFF	; 255
    3fbc:	11 82       	std	Z+1, r1	; 0x01
    3fbe:	10 82       	st	Z, r1
					
					ARRAYLOCK = false;		
    3fc0:	fc 01       	movw	r30, r24
    3fc2:	10 82       	st	Z, r1
    3fc4:	90 93 a3 03 	sts	0x03A3, r25
    3fc8:	80 93 a2 03 	sts	0x03A2, r24
	}

	return radioControllerInterface;
}
    3fcc:	80 91 a2 03 	lds	r24, 0x03A2
    3fd0:	90 91 a3 03 	lds	r25, 0x03A3
    3fd4:	08 95       	ret

00003fd6 <__vector_46>:
/**
 * Interrupt service routine which is called when a PPM signal's rising edge is detected
 * on the PL1 pin.
 */
ISR(TIMER5_CAPT_vect)
{
    3fd6:	1f 92       	push	r1
    3fd8:	0f 92       	push	r0
    3fda:	0f b6       	in	r0, 0x3f	; 63
    3fdc:	0f 92       	push	r0
    3fde:	11 24       	eor	r1, r1
    3fe0:	0b b6       	in	r0, 0x3b	; 59
    3fe2:	0f 92       	push	r0
    3fe4:	cf 92       	push	r12
    3fe6:	df 92       	push	r13
    3fe8:	ef 92       	push	r14
    3fea:	ff 92       	push	r15
    3fec:	0f 93       	push	r16
    3fee:	1f 93       	push	r17
    3ff0:	2f 93       	push	r18
    3ff2:	3f 93       	push	r19
    3ff4:	4f 93       	push	r20
    3ff6:	5f 93       	push	r21
    3ff8:	6f 93       	push	r22
    3ffa:	7f 93       	push	r23
    3ffc:	8f 93       	push	r24
    3ffe:	9f 93       	push	r25
    4000:	af 93       	push	r26
    4002:	bf 93       	push	r27
    4004:	cf 93       	push	r28
    4006:	df 93       	push	r29
    4008:	ef 93       	push	r30
    400a:	ff 93       	push	r31
	RadioControllerInterface *rcInterface = RadioControllerInterface::getRadioControllerInterface();
    400c:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <_ZN10helicopter10interfaces24RadioControllerInterface27getRadioControllerInterfaceEv>
    4010:	ec 01       	movw	r28, r24
	//an interrupt happening inbetween reading the two bytes. 
	//cli(); //not necessary because intterupts are already disabled within an ISR.
	
	//The Input Capture Register is set to the value of the timer when the
	//input signal was received.
	long currentInputCaptureRegisterValue = ICR5;
    4012:	40 91 26 01 	lds	r20, 0x0126
    4016:	50 91 27 01 	lds	r21, 0x0127
    401a:	60 e0       	ldi	r22, 0x00	; 0
    401c:	70 e0       	ldi	r23, 0x00	; 0
				 * the scope of this class, so the handlers need a static reference to
				 * this class.
				 */
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
    401e:	fc 01       	movw	r30, r24
    4020:	ef 5b       	subi	r30, 0xBF	; 191
    4022:	ff 4f       	sbci	r31, 0xFF	; 255
    4024:	00 81       	ld	r16, Z
    4026:	11 81       	ldd	r17, Z+1	; 0x01
    4028:	22 81       	ldd	r18, Z+2	; 0x02
    402a:	33 81       	ldd	r19, Z+3	; 0x03
	
	long previousInputCaptureRegisterValue = rcInterface->PreviousInputCaptureRegisterValue();
	
	//If the current value was less, then the timer has overflowed since the last
	//time we received a pulse
	if (currentInputCaptureRegisterValue < previousInputCaptureRegisterValue)
    402c:	40 17       	cp	r20, r16
    402e:	51 07       	cpc	r21, r17
    4030:	62 07       	cpc	r22, r18
    4032:	73 07       	cpc	r23, r19
    4034:	5c f4       	brge	.+22     	; 0x404c <__vector_46+0x76>
	{
		servoChannelPulseWidth = (currentInputCaptureRegisterValue + RadioControllerInterface::MAX_PPM_TIMER_VALUE) - previousInputCaptureRegisterValue;
    4036:	db 01       	movw	r26, r22
    4038:	ca 01       	movw	r24, r20
    403a:	80 5c       	subi	r24, 0xC0	; 192
    403c:	93 46       	sbci	r25, 0x63	; 99
    403e:	af 4f       	sbci	r26, 0xFF	; 255
    4040:	bf 4f       	sbci	r27, 0xFF	; 255
    4042:	80 1b       	sub	r24, r16
    4044:	91 0b       	sbc	r25, r17
    4046:	a2 0b       	sbc	r26, r18
    4048:	b3 0b       	sbc	r27, r19
    404a:	06 c0       	rjmp	.+12     	; 0x4058 <__vector_46+0x82>
	}else
	{
		//Calculate the width of the pulse.
		servoChannelPulseWidth = currentInputCaptureRegisterValue - previousInputCaptureRegisterValue;
    404c:	db 01       	movw	r26, r22
    404e:	ca 01       	movw	r24, r20
    4050:	80 1b       	sub	r24, r16
    4052:	91 0b       	sbc	r25, r17
    4054:	a2 0b       	sbc	r26, r18
    4056:	b3 0b       	sbc	r27, r19
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
    4058:	fe 01       	movw	r30, r28
    405a:	ef 5b       	subi	r30, 0xBF	; 191
    405c:	ff 4f       	sbci	r31, 0xFF	; 255
    405e:	40 83       	st	Z, r20
    4060:	51 83       	std	Z+1, r21	; 0x01
    4062:	62 83       	std	Z+2, r22	; 0x02
    4064:	73 83       	std	Z+3, r23	; 0x03
	rcInterface->PreviousInputCaptureRegisterValue(currentInputCaptureRegisterValue);
	
	//Once all the servo channels values have been sent, a sync pulse is sent indicating
	//a restart back to the first channel.
	//Detect if it's a sync pulse and rest as appropriate
	if (servoChannelPulseWidth > RadioControllerInterface::SYNCH_PULSE_WIDTH)
    4066:	81 34       	cpi	r24, 0x41	; 65
    4068:	2f e1       	ldi	r18, 0x1F	; 31
    406a:	92 07       	cpc	r25, r18
    406c:	a1 05       	cpc	r26, r1
    406e:	b1 05       	cpc	r27, r1
    4070:	2c f0       	brlt	.+10     	; 0x407c <__vector_46+0xa6>
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    4072:	cb 5b       	subi	r28, 0xBB	; 187
    4074:	df 4f       	sbci	r29, 0xFF	; 255
    4076:	19 82       	std	Y+1, r1	; 0x01
    4078:	18 82       	st	Y, r1
    407a:	68 c0       	rjmp	.+208    	; 0x414c <__vector_46+0x176>
	{
		rcInterface->ServoChannelIndex(0);
	}else
	{
		if (servoChannelPulseWidth < RadioControllerInterface::MAX_USEABLE_PULSE_WIDTH && 
    407c:	ac 01       	movw	r20, r24
    407e:	bd 01       	movw	r22, r26
    4080:	47 5c       	subi	r20, 0xC7	; 199
    4082:	57 40       	sbci	r21, 0x07	; 7
    4084:	61 09       	sbc	r22, r1
    4086:	71 09       	sbc	r23, r1
    4088:	43 3e       	cpi	r20, 0xE3	; 227
    408a:	57 40       	sbci	r21, 0x07	; 7
    408c:	61 05       	cpc	r22, r1
    408e:	71 05       	cpc	r23, r1
    4090:	08 f0       	brcs	.+2      	; 0x4094 <__vector_46+0xbe>
    4092:	55 c0       	rjmp	.+170    	; 0x413e <__vector_46+0x168>
				static RadioControllerInterface  *getRadioControllerInterface();
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
    4094:	fe 01       	movw	r30, r28
    4096:	eb 5b       	subi	r30, 0xBB	; 187
    4098:	ff 4f       	sbci	r31, 0xFF	; 255
    409a:	20 81       	ld	r18, Z
    409c:	31 81       	ldd	r19, Z+1	; 0x01
			
			
			
			//since throttle is mechanically bypassed, set throttle to -1 (no throttle) in the array of control values, and 
			//then continue processing the received signal for the next channel (channel 1)
			if (servoChannelIndex == 0)
    409e:	21 15       	cp	r18, r1
    40a0:	31 05       	cpc	r19, r1
    40a2:	69 f4       	brne	.+26     	; 0x40be <__vector_46+0xe8>
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    40a4:	40 ed       	ldi	r20, 0xD0	; 208
    40a6:	57 e0       	ldi	r21, 0x07	; 7
    40a8:	60 e0       	ldi	r22, 0x00	; 0
    40aa:	70 e0       	ldi	r23, 0x00	; 0
    40ac:	49 83       	std	Y+1, r20	; 0x01
    40ae:	5a 83       	std	Y+2, r21	; 0x02
    40b0:	6b 83       	std	Y+3, r22	; 0x03
    40b2:	7c 83       	std	Y+4, r23	; 0x04
    40b4:	8d 83       	std	Y+5, r24	; 0x05
    40b6:	9e 83       	std	Y+6, r25	; 0x06
    40b8:	af 83       	std	Y+7, r26	; 0x07
    40ba:	b8 87       	std	Y+8, r27	; 0x08
    40bc:	40 c0       	rjmp	.+128    	; 0x413e <__vector_46+0x168>
		
		
		
		
		
			if (servoChannelIndex < RadioControllerInterface::MAX_CHANNELS)
    40be:	28 30       	cpi	r18, 0x08	; 8
    40c0:	31 05       	cpc	r19, r1
    40c2:	ec f5       	brge	.+122    	; 0x413e <__vector_46+0x168>
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
					
				SystemModel * GetSystemModel() const { return systemModel; }
    40c4:	fe 01       	movw	r30, r28
    40c6:	e9 5a       	subi	r30, 0xA9	; 169
    40c8:	ff 4f       	sbci	r31, 0xFF	; 255
    40ca:	00 81       	ld	r16, Z
    40cc:	11 81       	ldd	r17, Z+1	; 0x01
					
				void SetServoChannelPulseWidth(int index, long value) 
				{ 
					if (index < MAX_CHANNELS)
					{
						workingServoChannelPulseWidths[index] = value;
    40ce:	f9 01       	movw	r30, r18
    40d0:	ee 0f       	add	r30, r30
    40d2:	ff 1f       	adc	r31, r31
    40d4:	ee 0f       	add	r30, r30
    40d6:	ff 1f       	adc	r31, r31
    40d8:	ec 0f       	add	r30, r28
    40da:	fd 1f       	adc	r31, r29
    40dc:	81 83       	std	Z+1, r24	; 0x01
    40de:	92 83       	std	Z+2, r25	; 0x02
    40e0:	a3 83       	std	Z+3, r26	; 0x03
    40e2:	b4 83       	std	Z+4, r27	; 0x04
				 * servo channel index to reset back to 0, and re-write the
				 * existing servo value. This could cause a servo control value
				 * to get sent to the wrong servo. 
				 */
				//if (servoChannelIndex >= RadioControllerInterface::MIN_RECEIVED_CHANNELS)
				if (servoChannelIndex == RadioControllerInterface::MIN_RECEIVED_CHANNELS)
    40e4:	27 30       	cpi	r18, 0x07	; 7
    40e6:	31 05       	cpc	r19, r1
    40e8:	51 f5       	brne	.+84     	; 0x413e <__vector_46+0x168>
				{
					//Manual mode
					float auxChannelValue = rcInterface->ScaleValue(rcInterface->GetServoChannelPulseWidth(RadioControllerInterface::FLIGHT_MODE_AUX_CHANNEL));
    40ea:	49 8d       	ldd	r20, Y+25	; 0x19
    40ec:	5a 8d       	ldd	r21, Y+26	; 0x1a
    40ee:	6b 8d       	ldd	r22, Y+27	; 0x1b
    40f0:	7c 8d       	ldd	r23, Y+28	; 0x1c
    40f2:	ce 01       	movw	r24, r28
    40f4:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <_ZN10helicopter10interfaces24RadioControllerInterface10ScaleValueEl>
    40f8:	6b 01       	movw	r12, r22
    40fa:	7c 01       	movw	r14, r24
					
					if (auxChannelValue
    40fc:	23 e3       	ldi	r18, 0x33	; 51
    40fe:	33 e3       	ldi	r19, 0x33	; 51
    4100:	43 e3       	ldi	r20, 0x33	; 51
    4102:	5f e3       	ldi	r21, 0x3F	; 63
    4104:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    4108:	18 16       	cp	r1, r24
    410a:	1c f0       	brlt	.+6      	; 0x4112 <__vector_46+0x13c>
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
			void OperationalState( OperatingStates val ) { operationalState = val;}
    410c:	f8 01       	movw	r30, r16
    410e:	12 82       	std	Z+2, r1	; 0x02
    4110:	03 c0       	rjmp	.+6      	; 0x4118 <__vector_46+0x142>
    4112:	81 e0       	ldi	r24, 0x01	; 1
    4114:	f8 01       	movw	r30, r16
    4116:	82 83       	std	Z+2, r24	; 0x02
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}
    4118:	f8 01       	movw	r30, r16
    411a:	e6 5e       	subi	r30, 0xE6	; 230
    411c:	fe 4f       	sbci	r31, 0xFE	; 254
    411e:	c0 82       	st	Z, r12
    4120:	d1 82       	std	Z+1, r13	; 0x01
    4122:	e2 82       	std	Z+2, r14	; 0x02
    4124:	f3 82       	std	Z+3, r15	; 0x03
						model->OperationalState(SystemModel::AutoPilot);
					}
					
					model->AuxChannelValue(auxChannelValue);
					
					if (!rcInterface->ARRAYLOCK)
    4126:	88 81       	ld	r24, Y
    4128:	81 11       	cpse	r24, r1
    412a:	09 c0       	rjmp	.+18     	; 0x413e <__vector_46+0x168>
					
				void controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue );
				
				void copyPulseWidthArrays()
				{
					memcpy(servoChannelPulseWidths, workingServoChannelPulseWidths, sizeof(servoChannelPulseWidths));
    412c:	de 01       	movw	r26, r28
    412e:	91 96       	adiw	r26, 0x21	; 33
    4130:	fe 01       	movw	r30, r28
    4132:	31 96       	adiw	r30, 0x01	; 1
    4134:	80 e2       	ldi	r24, 0x20	; 32
    4136:	01 90       	ld	r0, Z+
    4138:	0d 92       	st	X+, r0
    413a:	8a 95       	dec	r24
    413c:	e1 f7       	brne	.-8      	; 0x4136 <__vector_46+0x160>
				
				long PreviousInputCaptureRegisterValue() const { return previousInputCaptureRegisterValue; }
				void PreviousInputCaptureRegisterValue(long val) { previousInputCaptureRegisterValue = val; }
					
				int ServoChannelIndex() const { return servoChannelIndex; }
				void ServoChannelIndex(int val) { servoChannelIndex = val; }
    413e:	cb 5b       	subi	r28, 0xBB	; 187
    4140:	df 4f       	sbci	r29, 0xFF	; 255
					//rcInterface->ServoChannelIndex(0);
				}			
			}
		} 

		rcInterface->ServoChannelIndex(rcInterface->ServoChannelIndex() + 1);
    4142:	88 81       	ld	r24, Y
    4144:	99 81       	ldd	r25, Y+1	; 0x01
    4146:	01 96       	adiw	r24, 0x01	; 1
    4148:	99 83       	std	Y+1, r25	; 0x01
    414a:	88 83       	st	Y, r24
	}

}
    414c:	ff 91       	pop	r31
    414e:	ef 91       	pop	r30
    4150:	df 91       	pop	r29
    4152:	cf 91       	pop	r28
    4154:	bf 91       	pop	r27
    4156:	af 91       	pop	r26
    4158:	9f 91       	pop	r25
    415a:	8f 91       	pop	r24
    415c:	7f 91       	pop	r23
    415e:	6f 91       	pop	r22
    4160:	5f 91       	pop	r21
    4162:	4f 91       	pop	r20
    4164:	3f 91       	pop	r19
    4166:	2f 91       	pop	r18
    4168:	1f 91       	pop	r17
    416a:	0f 91       	pop	r16
    416c:	ff 90       	pop	r15
    416e:	ef 90       	pop	r14
    4170:	df 90       	pop	r13
    4172:	cf 90       	pop	r12
    4174:	0f 90       	pop	r0
    4176:	0b be       	out	0x3b, r0	; 59
    4178:	0f 90       	pop	r0
    417a:	0f be       	out	0x3f, r0	; 63
    417c:	0f 90       	pop	r0
    417e:	1f 90       	pop	r1
    4180:	18 95       	reti

00004182 <_ZN10helicopter10interfaces24RadioControllerInterface4CCPMEfffRfS2_S2_>:

}


void RadioControllerInterface::CCPM(float inAileron, float inElevator, float inCollective, float &outAileron, float &outElevator, float &outPitch)
{
    4182:	2f 92       	push	r2
    4184:	3f 92       	push	r3
    4186:	4f 92       	push	r4
    4188:	5f 92       	push	r5
    418a:	6f 92       	push	r6
    418c:	7f 92       	push	r7
    418e:	8f 92       	push	r8
    4190:	9f 92       	push	r9
    4192:	af 92       	push	r10
    4194:	bf 92       	push	r11
    4196:	cf 92       	push	r12
    4198:	df 92       	push	r13
    419a:	ef 92       	push	r14
    419c:	ff 92       	push	r15
    419e:	0f 93       	push	r16
    41a0:	1f 93       	push	r17
    41a2:	cf 93       	push	r28
    41a4:	df 93       	push	r29
    41a6:	cd b7       	in	r28, 0x3d	; 61
    41a8:	de b7       	in	r29, 0x3e	; 62
    41aa:	2c 97       	sbiw	r28, 0x0c	; 12
    41ac:	0f b6       	in	r0, 0x3f	; 63
    41ae:	f8 94       	cli
    41b0:	de bf       	out	0x3e, r29	; 62
    41b2:	0f be       	out	0x3f, r0	; 63
    41b4:	cd bf       	out	0x3d, r28	; 61
    41b6:	4d 83       	std	Y+5, r20	; 0x05
    41b8:	5e 83       	std	Y+6, r21	; 0x06
    41ba:	6f 83       	std	Y+7, r22	; 0x07
    41bc:	78 87       	std	Y+8, r23	; 0x08
    41be:	28 01       	movw	r4, r16
    41c0:	39 01       	movw	r6, r18
    41c2:	ba 86       	std	Y+10, r11	; 0x0a
    41c4:	a9 86       	std	Y+9, r10	; 0x09
    41c6:	9c 86       	std	Y+12, r9	; 0x0c
    41c8:	8b 86       	std	Y+11, r8	; 0x0b
	outAileron = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective+ELEVATOR_SCALER*SWASHOFFSETELEVATORMULTIPLYER*inElevator*-1+AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
	outElevator = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective*-1 + ELEVATOR_SCALER*SWASHOFFSETELEVATORELEVATORMULTIPLYER*inElevator*-1;
	*/	
	
	
	float scaledCollectiveWithOffsets = PWM_NEUTRAL_POSITION+PITCH_COLLECTIVE_SCALER*SWASHOFFSETPITCHMULTIPLYER*inCollective;
    41ca:	20 e0       	ldi	r18, 0x00	; 0
    41cc:	30 e0       	ldi	r19, 0x00	; 0
    41ce:	44 e1       	ldi	r20, 0x14	; 20
    41d0:	53 e4       	ldi	r21, 0x43	; 67
    41d2:	c7 01       	movw	r24, r14
    41d4:	b6 01       	movw	r22, r12
    41d6:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    41da:	20 e0       	ldi	r18, 0x00	; 0
    41dc:	38 e8       	ldi	r19, 0x88	; 136
    41de:	40 e9       	ldi	r20, 0x90	; 144
    41e0:	56 e4       	ldi	r21, 0x46	; 70
    41e2:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    41e6:	e6 2e       	mov	r14, r22
    41e8:	f7 2e       	mov	r15, r23
    41ea:	08 2f       	mov	r16, r24
    41ec:	19 2f       	mov	r17, r25
    41ee:	86 2f       	mov	r24, r22
    41f0:	9f 2d       	mov	r25, r15
    41f2:	a0 2f       	mov	r26, r16
    41f4:	b1 2f       	mov	r27, r17
    41f6:	89 83       	std	Y+1, r24	; 0x01
    41f8:	9a 83       	std	Y+2, r25	; 0x02
    41fa:	ab 83       	std	Y+3, r26	; 0x03
    41fc:	bc 83       	std	Y+4, r27	; 0x04
	float scaledElevator = ELEVATOR_SCALER*inElevator;
    41fe:	20 e0       	ldi	r18, 0x00	; 0
    4200:	30 e0       	ldi	r19, 0x00	; 0
    4202:	4c e2       	ldi	r20, 0x2C	; 44
    4204:	52 e4       	ldi	r21, 0x42	; 66
    4206:	c3 01       	movw	r24, r6
    4208:	b2 01       	movw	r22, r4
    420a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    420e:	46 2e       	mov	r4, r22
    4210:	57 2e       	mov	r5, r23
    4212:	68 2e       	mov	r6, r24
    4214:	79 2e       	mov	r7, r25
	float scaledElevatorWithOffsets = scaledElevator*SWASHOFFSETELEVATORMULTIPLYER;
    4216:	76 2f       	mov	r23, r22
    4218:	27 2f       	mov	r18, r23
    421a:	35 2d       	mov	r19, r5
    421c:	46 2d       	mov	r20, r6
    421e:	57 2d       	mov	r21, r7
    4220:	64 2d       	mov	r22, r4
    4222:	75 2d       	mov	r23, r5
    4224:	86 2d       	mov	r24, r6
    4226:	97 2d       	mov	r25, r7
    4228:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    422c:	a6 2e       	mov	r10, r22
    422e:	b7 2e       	mov	r11, r23
    4230:	c8 2e       	mov	r12, r24
    4232:	d9 2e       	mov	r13, r25
	float negativeScaledAileronWithOffsets = AILERON_SCALER*SWASHOFFSETSAILERONMULTIPLIER*inAileron*-1;
    4234:	20 e0       	ldi	r18, 0x00	; 0
    4236:	30 e0       	ldi	r19, 0x00	; 0
    4238:	41 e1       	ldi	r20, 0x11	; 17
    423a:	53 e4       	ldi	r21, 0x43	; 67
    423c:	6d 81       	ldd	r22, Y+5	; 0x05
    423e:	7e 81       	ldd	r23, Y+6	; 0x06
    4240:	8f 81       	ldd	r24, Y+7	; 0x07
    4242:	98 85       	ldd	r25, Y+8	; 0x08
    4244:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    4248:	26 2e       	mov	r2, r22
    424a:	37 2e       	mov	r3, r23
    424c:	88 2e       	mov	r8, r24
    424e:	99 2e       	mov	r9, r25
	
	outPitch = scaledCollectiveWithOffsets*-1 + scaledElevatorWithOffsets+negativeScaledAileronWithOffsets;
    4250:	2e 2d       	mov	r18, r14
    4252:	3f 2d       	mov	r19, r15
    4254:	40 2f       	mov	r20, r16
    4256:	51 2f       	mov	r21, r17
    4258:	6a 2d       	mov	r22, r10
    425a:	7b 2d       	mov	r23, r11
    425c:	8c 2d       	mov	r24, r12
    425e:	9d 2d       	mov	r25, r13
    4260:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4264:	22 2d       	mov	r18, r2
    4266:	33 2d       	mov	r19, r3
    4268:	48 2d       	mov	r20, r8
    426a:	59 2d       	mov	r21, r9
    426c:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4270:	ea a1       	ldd	r30, Y+34	; 0x22
    4272:	fb a1       	ldd	r31, Y+35	; 0x23
    4274:	60 83       	st	Z, r22
    4276:	71 83       	std	Z+1, r23	; 0x01
    4278:	82 83       	std	Z+2, r24	; 0x02
    427a:	93 83       	std	Z+3, r25	; 0x03
	outAileron = scaledCollectiveWithOffsets+scaledElevatorWithOffsets*-1+negativeScaledAileronWithOffsets;
    427c:	2a 2d       	mov	r18, r10
    427e:	3b 2d       	mov	r19, r11
    4280:	4c 2d       	mov	r20, r12
    4282:	5d 2d       	mov	r21, r13
    4284:	6e 2d       	mov	r22, r14
    4286:	7f 2d       	mov	r23, r15
    4288:	80 2f       	mov	r24, r16
    428a:	91 2f       	mov	r25, r17
    428c:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4290:	22 2d       	mov	r18, r2
    4292:	33 2d       	mov	r19, r3
    4294:	48 2d       	mov	r20, r8
    4296:	59 2d       	mov	r21, r9
    4298:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    429c:	e9 85       	ldd	r30, Y+9	; 0x09
    429e:	fa 85       	ldd	r31, Y+10	; 0x0a
    42a0:	60 83       	st	Z, r22
    42a2:	71 83       	std	Z+1, r23	; 0x01
    42a4:	82 83       	std	Z+2, r24	; 0x02
    42a6:	93 83       	std	Z+3, r25	; 0x03
	outElevator = scaledCollectiveWithOffsets*-1 + scaledElevator*SWASHOFFSETELEVATORELEVATORMULTIPLYER*-1;
    42a8:	c9 80       	ldd	r12, Y+1	; 0x01
    42aa:	da 80       	ldd	r13, Y+2	; 0x02
    42ac:	eb 80       	ldd	r14, Y+3	; 0x03
    42ae:	fc 80       	ldd	r15, Y+4	; 0x04
    42b0:	f7 fa       	bst	r15, 7
    42b2:	f0 94       	com	r15
    42b4:	f7 f8       	bld	r15, 7
    42b6:	f0 94       	com	r15
    42b8:	20 e0       	ldi	r18, 0x00	; 0
    42ba:	30 e0       	ldi	r19, 0x00	; 0
    42bc:	40 e8       	ldi	r20, 0x80	; 128
    42be:	50 e4       	ldi	r21, 0x40	; 64
    42c0:	64 2d       	mov	r22, r4
    42c2:	75 2d       	mov	r23, r5
    42c4:	86 2d       	mov	r24, r6
    42c6:	97 2d       	mov	r25, r7
    42c8:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    42cc:	9b 01       	movw	r18, r22
    42ce:	ac 01       	movw	r20, r24
    42d0:	c7 01       	movw	r24, r14
    42d2:	b6 01       	movw	r22, r12
    42d4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    42d8:	eb 85       	ldd	r30, Y+11	; 0x0b
    42da:	fc 85       	ldd	r31, Y+12	; 0x0c
    42dc:	60 83       	st	Z, r22
    42de:	71 83       	std	Z+1, r23	; 0x01
    42e0:	82 83       	std	Z+2, r24	; 0x02
    42e2:	93 83       	std	Z+3, r25	; 0x03
	outPitch = outPitch + PITCH_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	outAileron = outAileron + AILERON_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	outElevator =  outElevator + ELEVATOR_SUBTRIM * SUBTRIM_POINT_PER_TENTH_MS;
	*/
	
}
    42e4:	2c 96       	adiw	r28, 0x0c	; 12
    42e6:	0f b6       	in	r0, 0x3f	; 63
    42e8:	f8 94       	cli
    42ea:	de bf       	out	0x3e, r29	; 62
    42ec:	0f be       	out	0x3f, r0	; 63
    42ee:	cd bf       	out	0x3d, r28	; 61
    42f0:	df 91       	pop	r29
    42f2:	cf 91       	pop	r28
    42f4:	1f 91       	pop	r17
    42f6:	0f 91       	pop	r16
    42f8:	ff 90       	pop	r15
    42fa:	ef 90       	pop	r14
    42fc:	df 90       	pop	r13
    42fe:	cf 90       	pop	r12
    4300:	bf 90       	pop	r11
    4302:	af 90       	pop	r10
    4304:	9f 90       	pop	r9
    4306:	8f 90       	pop	r8
    4308:	7f 90       	pop	r7
    430a:	6f 90       	pop	r6
    430c:	5f 90       	pop	r5
    430e:	4f 90       	pop	r4
    4310:	3f 90       	pop	r3
    4312:	2f 90       	pop	r2
    4314:	08 95       	ret

00004316 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>:

void RadioControllerInterface::controlServos( float lateralControl, float longitudeControl, float mainRotorControl, float yawControl, float auxChannelValue )
{
    4316:	2f 92       	push	r2
    4318:	3f 92       	push	r3
    431a:	4f 92       	push	r4
    431c:	5f 92       	push	r5
    431e:	6f 92       	push	r6
    4320:	7f 92       	push	r7
    4322:	8f 92       	push	r8
    4324:	9f 92       	push	r9
    4326:	af 92       	push	r10
    4328:	bf 92       	push	r11
    432a:	cf 92       	push	r12
    432c:	df 92       	push	r13
    432e:	ef 92       	push	r14
    4330:	ff 92       	push	r15
    4332:	0f 93       	push	r16
    4334:	1f 93       	push	r17
    4336:	cf 93       	push	r28
    4338:	df 93       	push	r29
    433a:	cd b7       	in	r28, 0x3d	; 61
    433c:	de b7       	in	r29, 0x3e	; 62
    433e:	2c 97       	sbiw	r28, 0x0c	; 12
    4340:	0f b6       	in	r0, 0x3f	; 63
    4342:	f8 94       	cli
    4344:	de bf       	out	0x3e, r29	; 62
    4346:	0f be       	out	0x3f, r0	; 63
    4348:	cd bf       	out	0x3d, r28	; 61
    434a:	3c 01       	movw	r6, r24
    434c:	14 01       	movw	r2, r8
    434e:	25 01       	movw	r4, r10
			void InitialZPositionEcef( long val ) { initialZPositionEcef = val;}			
			/*
			float **  EcefToLocalNEDRotationMatrix() const {return ecefToLocalNEDRotationMatrix;}
			void EcefToLocalNEDRotationMatrix( long val ) { ecefToLocalNEDRotationMatrix = val;}*/
				
			OperatingStates  OperationalState() const {return operationalState;}
    4350:	fc 01       	movw	r30, r24
    4352:	e9 5a       	subi	r30, 0xA9	; 169
    4354:	ff 4f       	sbci	r31, 0xFF	; 255
    4356:	01 90       	ld	r0, Z+
    4358:	f0 81       	ld	r31, Z
    435a:	e0 2d       	mov	r30, r0
    435c:	82 81       	ldd	r24, Z+2	; 0x02

	
	//If in manual control, just forward the pulse width values from the input pins to the output pins.
	if (systemModel->OperationalState() == SystemModel::ManualControl)
    435e:	81 11       	cpse	r24, r1
    4360:	76 c0       	rjmp	.+236    	; 0x444e <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x138>
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
		*/
		
		ARRAYLOCK = true;
    4362:	81 e0       	ldi	r24, 0x01	; 1
    4364:	f3 01       	movw	r30, r6
    4366:	80 83       	st	Z, r24
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    4368:	41 a1       	ldd	r20, Z+33	; 0x21
    436a:	52 a1       	ldd	r21, Z+34	; 0x22
    436c:	63 a1       	ldd	r22, Z+35	; 0x23
    436e:	74 a1       	ldd	r23, Z+36	; 0x24
    4370:	c3 01       	movw	r24, r6
    4372:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    4376:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    437a:	70 93 8b 00 	sts	0x008B, r23
    437e:	60 93 8a 00 	sts	0x008A, r22
		OCR1A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[1]);
    4382:	f3 01       	movw	r30, r6
    4384:	45 a1       	ldd	r20, Z+37	; 0x25
    4386:	56 a1       	ldd	r21, Z+38	; 0x26
    4388:	67 a1       	ldd	r22, Z+39	; 0x27
    438a:	70 a5       	ldd	r23, Z+40	; 0x28
    438c:	c3 01       	movw	r24, r6
    438e:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    4392:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    4396:	70 93 89 00 	sts	0x0089, r23
    439a:	60 93 88 00 	sts	0x0088, r22
		OCR4C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[2]);
    439e:	f3 01       	movw	r30, r6
    43a0:	41 a5       	ldd	r20, Z+41	; 0x29
    43a2:	52 a5       	ldd	r21, Z+42	; 0x2a
    43a4:	63 a5       	ldd	r22, Z+43	; 0x2b
    43a6:	74 a5       	ldd	r23, Z+44	; 0x2c
    43a8:	c3 01       	movw	r24, r6
    43aa:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43ae:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    43b2:	70 93 ad 00 	sts	0x00AD, r23
    43b6:	60 93 ac 00 	sts	0x00AC, r22
		OCR4B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[3]);
    43ba:	f3 01       	movw	r30, r6
    43bc:	45 a5       	ldd	r20, Z+45	; 0x2d
    43be:	56 a5       	ldd	r21, Z+46	; 0x2e
    43c0:	67 a5       	ldd	r22, Z+47	; 0x2f
    43c2:	70 a9       	ldd	r23, Z+48	; 0x30
    43c4:	c3 01       	movw	r24, r6
    43c6:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43ca:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    43ce:	70 93 ab 00 	sts	0x00AB, r23
    43d2:	60 93 aa 00 	sts	0x00AA, r22
		OCR4A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[4]);
    43d6:	f3 01       	movw	r30, r6
    43d8:	41 a9       	ldd	r20, Z+49	; 0x31
    43da:	52 a9       	ldd	r21, Z+50	; 0x32
    43dc:	63 a9       	ldd	r22, Z+51	; 0x33
    43de:	74 a9       	ldd	r23, Z+52	; 0x34
    43e0:	c3 01       	movw	r24, r6
    43e2:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    43e6:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    43ea:	70 93 a9 00 	sts	0x00A9, r23
    43ee:	60 93 a8 00 	sts	0x00A8, r22
		OCR3C = convertPulseWidthToCompareMatch(servoChannelPulseWidths[5]);
    43f2:	f3 01       	movw	r30, r6
    43f4:	45 a9       	ldd	r20, Z+53	; 0x35
    43f6:	56 a9       	ldd	r21, Z+54	; 0x36
    43f8:	67 a9       	ldd	r22, Z+55	; 0x37
    43fa:	70 ad       	ldd	r23, Z+56	; 0x38
    43fc:	c3 01       	movw	r24, r6
    43fe:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    4402:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    4406:	70 93 9d 00 	sts	0x009D, r23
    440a:	60 93 9c 00 	sts	0x009C, r22
		OCR3B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[6]);
    440e:	f3 01       	movw	r30, r6
    4410:	41 ad       	ldd	r20, Z+57	; 0x39
    4412:	52 ad       	ldd	r21, Z+58	; 0x3a
    4414:	63 ad       	ldd	r22, Z+59	; 0x3b
    4416:	74 ad       	ldd	r23, Z+60	; 0x3c
    4418:	c3 01       	movw	r24, r6
    441a:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    441e:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    4422:	70 93 9b 00 	sts	0x009B, r23
    4426:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = convertPulseWidthToCompareMatch(servoChannelPulseWidths[7]);
    442a:	f3 01       	movw	r30, r6
    442c:	fd 96       	adiw	r30, 0x3d	; 61
    442e:	40 81       	ld	r20, Z
    4430:	51 81       	ldd	r21, Z+1	; 0x01
    4432:	62 81       	ldd	r22, Z+2	; 0x02
    4434:	73 81       	ldd	r23, Z+3	; 0x03
    4436:	c3 01       	movw	r24, r6
    4438:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    443c:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    4440:	70 93 99 00 	sts	0x0099, r23
    4444:	60 93 98 00 	sts	0x0098, r22
		ARRAYLOCK = false;
    4448:	f3 01       	movw	r30, r6
    444a:	10 82       	st	Z, r1
    444c:	f4 c0       	rjmp	.+488    	; 0x4636 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x320>
		OCR4B = (servoChannelPulseWidths[3]);
		OCR4A = (servoChannelPulseWidths[4]);
		OCR3C = (servoChannelPulseWidths[5]);
		OCR3B = (servoChannelPulseWidths[6]);
		OCR3A = (servoChannelPulseWidths[7]);*/
	} else if (systemModel->OperationalState() == SystemModel::AutoPilot)
    444e:	81 30       	cpi	r24, 0x01	; 1
    4450:	09 f0       	breq	.+2      	; 0x4454 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x13e>
    4452:	f1 c0       	rjmp	.+482    	; 0x4636 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff+0x320>
	{
		//TODO - nonccpm-ccpm this stuff. 

		float outPitch = 0;
    4454:	19 86       	std	Y+9, r1	; 0x09
    4456:	1a 86       	std	Y+10, r1	; 0x0a
    4458:	1b 86       	std	Y+11, r1	; 0x0b
    445a:	1c 86       	std	Y+12, r1	; 0x0c
		float outAileron = 0;
    445c:	1d 82       	std	Y+5, r1	; 0x05
    445e:	1e 82       	std	Y+6, r1	; 0x06
    4460:	1f 82       	std	Y+7, r1	; 0x07
    4462:	18 86       	std	Y+8, r1	; 0x08
		float outElevator = 0;
    4464:	19 82       	std	Y+1, r1	; 0x01
    4466:	1a 82       	std	Y+2, r1	; 0x02
    4468:	1b 82       	std	Y+3, r1	; 0x03
    446a:	1c 82       	std	Y+4, r1	; 0x04
			* PE3      | OC3A               | Aux 3						| 8
			*/			
		
		
		
		CCPM(lateralControl, longitudeControl, mainRotorControl, outAileron, outElevator, outPitch);
    446c:	ce 01       	movw	r24, r28
    446e:	09 96       	adiw	r24, 0x09	; 9
    4470:	9f 93       	push	r25
    4472:	8f 93       	push	r24
    4474:	88 24       	eor	r8, r8
    4476:	83 94       	inc	r8
    4478:	91 2c       	mov	r9, r1
    447a:	8c 0e       	add	r8, r28
    447c:	9d 1e       	adc	r9, r29
    447e:	0f 2e       	mov	r0, r31
    4480:	f5 e0       	ldi	r31, 0x05	; 5
    4482:	af 2e       	mov	r10, r31
    4484:	b1 2c       	mov	r11, r1
    4486:	f0 2d       	mov	r31, r0
    4488:	ac 0e       	add	r10, r28
    448a:	bd 1e       	adc	r11, r29
    448c:	c3 01       	movw	r24, r6
    448e:	0e 94 c1 20 	call	0x4182	; 0x4182 <_ZN10helicopter10interfaces24RadioControllerInterface4CCPMEfffRfS2_S2_>
		
		
		//OCR1B = calculatePWMCompareMatchFromControlValue(THROTTLE_VALUE) - channel1Offset;
		
		ARRAYLOCK = true;
    4492:	81 e0       	ldi	r24, 0x01	; 1
    4494:	f3 01       	movw	r30, r6
    4496:	80 83       	st	Z, r24
		OCR1B = convertPulseWidthToCompareMatch(servoChannelPulseWidths[0]);
    4498:	41 a1       	ldd	r20, Z+33	; 0x21
    449a:	52 a1       	ldd	r21, Z+34	; 0x22
    449c:	63 a1       	ldd	r22, Z+35	; 0x23
    449e:	74 a1       	ldd	r23, Z+36	; 0x24
    44a0:	c3 01       	movw	r24, r6
    44a2:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <_ZN10helicopter10interfaces24RadioControllerInterface31convertPulseWidthToCompareMatchEl>
    44a6:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    44aa:	70 93 8b 00 	sts	0x008B, r23
    44ae:	60 93 8a 00 	sts	0x008A, r22
		ARRAYLOCK = false;
    44b2:	f3 01       	movw	r30, r6
    44b4:	10 82       	st	Z, r1
		
		OCR1A = outAileron - channel2Offset;
    44b6:	e7 5b       	subi	r30, 0xB7	; 183
    44b8:	ff 4f       	sbci	r31, 0xFF	; 255
    44ba:	60 81       	ld	r22, Z
    44bc:	71 81       	ldd	r23, Z+1	; 0x01
    44be:	88 27       	eor	r24, r24
    44c0:	77 fd       	sbrc	r23, 7
    44c2:	80 95       	com	r24
    44c4:	98 2f       	mov	r25, r24
    44c6:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    44ca:	9b 01       	movw	r18, r22
    44cc:	ac 01       	movw	r20, r24
    44ce:	6d 81       	ldd	r22, Y+5	; 0x05
    44d0:	7e 81       	ldd	r23, Y+6	; 0x06
    44d2:	8f 81       	ldd	r24, Y+7	; 0x07
    44d4:	98 85       	ldd	r25, Y+8	; 0x08
    44d6:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    44da:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    44de:	70 93 89 00 	sts	0x0089, r23
    44e2:	60 93 88 00 	sts	0x0088, r22
		OCR4C = outElevator - channel3Offset;
    44e6:	f3 01       	movw	r30, r6
    44e8:	e5 5b       	subi	r30, 0xB5	; 181
    44ea:	ff 4f       	sbci	r31, 0xFF	; 255
    44ec:	60 81       	ld	r22, Z
    44ee:	71 81       	ldd	r23, Z+1	; 0x01
    44f0:	88 27       	eor	r24, r24
    44f2:	77 fd       	sbrc	r23, 7
    44f4:	80 95       	com	r24
    44f6:	98 2f       	mov	r25, r24
    44f8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    44fc:	9b 01       	movw	r18, r22
    44fe:	ac 01       	movw	r20, r24
    4500:	69 81       	ldd	r22, Y+1	; 0x01
    4502:	7a 81       	ldd	r23, Y+2	; 0x02
    4504:	8b 81       	ldd	r24, Y+3	; 0x03
    4506:	9c 81       	ldd	r25, Y+4	; 0x04
    4508:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    450c:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    4510:	70 93 ad 00 	sts	0x00AD, r23
    4514:	60 93 ac 00 	sts	0x00AC, r22
		OCR4B = calculatePWMCompareMatchFromControlValue(yawControl) - channel4Offset;
    4518:	b2 01       	movw	r22, r4
    451a:	a1 01       	movw	r20, r2
    451c:	c3 01       	movw	r24, r6
    451e:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    4522:	6b 01       	movw	r12, r22
    4524:	7c 01       	movw	r14, r24
    4526:	f3 01       	movw	r30, r6
    4528:	e3 5b       	subi	r30, 0xB3	; 179
    452a:	ff 4f       	sbci	r31, 0xFF	; 255
    452c:	60 81       	ld	r22, Z
    452e:	71 81       	ldd	r23, Z+1	; 0x01
    4530:	88 27       	eor	r24, r24
    4532:	77 fd       	sbrc	r23, 7
    4534:	80 95       	com	r24
    4536:	98 2f       	mov	r25, r24
    4538:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    453c:	9b 01       	movw	r18, r22
    453e:	ac 01       	movw	r20, r24
    4540:	c7 01       	movw	r24, r14
    4542:	b6 01       	movw	r22, r12
    4544:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4548:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    454c:	70 93 ab 00 	sts	0x00AB, r23
    4550:	60 93 aa 00 	sts	0x00AA, r22
		OCR4A = calculatePWMCompareMatchFromControlValue(GEAR_VALUE) - channel5Offset;
    4554:	40 e0       	ldi	r20, 0x00	; 0
    4556:	50 e0       	ldi	r21, 0x00	; 0
    4558:	ba 01       	movw	r22, r20
    455a:	c3 01       	movw	r24, r6
    455c:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    4560:	6b 01       	movw	r12, r22
    4562:	7c 01       	movw	r14, r24
    4564:	f3 01       	movw	r30, r6
    4566:	e1 5b       	subi	r30, 0xB1	; 177
    4568:	ff 4f       	sbci	r31, 0xFF	; 255
    456a:	60 81       	ld	r22, Z
    456c:	71 81       	ldd	r23, Z+1	; 0x01
    456e:	88 27       	eor	r24, r24
    4570:	77 fd       	sbrc	r23, 7
    4572:	80 95       	com	r24
    4574:	98 2f       	mov	r25, r24
    4576:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    457a:	9b 01       	movw	r18, r22
    457c:	ac 01       	movw	r20, r24
    457e:	c7 01       	movw	r24, r14
    4580:	b6 01       	movw	r22, r12
    4582:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4586:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    458a:	70 93 a9 00 	sts	0x00A9, r23
    458e:	60 93 a8 00 	sts	0x00A8, r22
		OCR3C = outPitch - channel6Offset;
    4592:	f3 01       	movw	r30, r6
    4594:	ef 5a       	subi	r30, 0xAF	; 175
    4596:	ff 4f       	sbci	r31, 0xFF	; 255
    4598:	60 81       	ld	r22, Z
    459a:	71 81       	ldd	r23, Z+1	; 0x01
    459c:	88 27       	eor	r24, r24
    459e:	77 fd       	sbrc	r23, 7
    45a0:	80 95       	com	r24
    45a2:	98 2f       	mov	r25, r24
    45a4:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    45a8:	9b 01       	movw	r18, r22
    45aa:	ac 01       	movw	r20, r24
    45ac:	69 85       	ldd	r22, Y+9	; 0x09
    45ae:	7a 85       	ldd	r23, Y+10	; 0x0a
    45b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    45b2:	9c 85       	ldd	r25, Y+12	; 0x0c
    45b4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    45b8:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    45bc:	70 93 9d 00 	sts	0x009D, r23
    45c0:	60 93 9c 00 	sts	0x009C, r22
		OCR3B = calculatePWMCompareMatchFromControlValue(auxChannelValue) - channel7Offset;
    45c4:	4a a1       	ldd	r20, Y+34	; 0x22
    45c6:	5b a1       	ldd	r21, Y+35	; 0x23
    45c8:	6c a1       	ldd	r22, Y+36	; 0x24
    45ca:	7d a1       	ldd	r23, Y+37	; 0x25
    45cc:	c3 01       	movw	r24, r6
    45ce:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <_ZN10helicopter10interfaces24RadioControllerInterface40calculatePWMCompareMatchFromControlValueEf>
    45d2:	4b 01       	movw	r8, r22
    45d4:	5c 01       	movw	r10, r24
    45d6:	f3 01       	movw	r30, r6
    45d8:	ed 5a       	subi	r30, 0xAD	; 173
    45da:	ff 4f       	sbci	r31, 0xFF	; 255
    45dc:	60 81       	ld	r22, Z
    45de:	71 81       	ldd	r23, Z+1	; 0x01
    45e0:	88 27       	eor	r24, r24
    45e2:	77 fd       	sbrc	r23, 7
    45e4:	80 95       	com	r24
    45e6:	98 2f       	mov	r25, r24
    45e8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    45ec:	9b 01       	movw	r18, r22
    45ee:	ac 01       	movw	r20, r24
    45f0:	c5 01       	movw	r24, r10
    45f2:	b4 01       	movw	r22, r8
    45f4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    45f8:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    45fc:	70 93 9b 00 	sts	0x009B, r23
    4600:	60 93 9a 00 	sts	0x009A, r22
		OCR3A = calculatePWMCompareMatchFromControlValue(AUX3_VALUE) - channel8Offset;
    4604:	f3 01       	movw	r30, r6
    4606:	eb 5a       	subi	r30, 0xAB	; 171
    4608:	ff 4f       	sbci	r31, 0xFF	; 255
    460a:	60 81       	ld	r22, Z
    460c:	71 81       	ldd	r23, Z+1	; 0x01
    460e:	88 27       	eor	r24, r24
    4610:	77 fd       	sbrc	r23, 7
    4612:	80 95       	com	r24
    4614:	98 2f       	mov	r25, r24
    4616:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    461a:	9b 01       	movw	r18, r22
    461c:	ac 01       	movw	r20, r24
    461e:	c7 01       	movw	r24, r14
    4620:	b6 01       	movw	r22, r12
    4622:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    4626:	0e 94 bc 6b 	call	0xd778	; 0xd778 <__fixunssfsi>
    462a:	70 93 99 00 	sts	0x0099, r23
    462e:	60 93 98 00 	sts	0x0098, r22
    4632:	0f 90       	pop	r0
    4634:	0f 90       	pop	r0
		OCR3B = calculatePWMCompareMatchFromControlValue(-.8f);
		OCR3A = calculatePWMCompareMatchFromControlValue(-.8f);*/

	}

}
    4636:	2c 96       	adiw	r28, 0x0c	; 12
    4638:	0f b6       	in	r0, 0x3f	; 63
    463a:	f8 94       	cli
    463c:	de bf       	out	0x3e, r29	; 62
    463e:	0f be       	out	0x3f, r0	; 63
    4640:	cd bf       	out	0x3d, r28	; 61
    4642:	df 91       	pop	r29
    4644:	cf 91       	pop	r28
    4646:	1f 91       	pop	r17
    4648:	0f 91       	pop	r16
    464a:	ff 90       	pop	r15
    464c:	ef 90       	pop	r14
    464e:	df 90       	pop	r13
    4650:	cf 90       	pop	r12
    4652:	bf 90       	pop	r11
    4654:	af 90       	pop	r10
    4656:	9f 90       	pop	r9
    4658:	8f 90       	pop	r8
    465a:	7f 90       	pop	r7
    465c:	6f 90       	pop	r6
    465e:	5f 90       	pop	r5
    4660:	4f 90       	pop	r4
    4662:	3f 90       	pop	r3
    4664:	2f 90       	pop	r2
    4666:	08 95       	ret

00004668 <_ZN10helicopter8messages14ControlMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4668:	20 e5       	ldi	r18, 0x50	; 80
    466a:	32 e0       	ldi	r19, 0x02	; 2
    466c:	fc 01       	movw	r30, r24
    466e:	31 83       	std	Z+1, r19	; 0x01
    4670:	20 83       	st	Z, r18
    4672:	08 95       	ret

00004674 <_ZN10helicopter8messages14ControlMessageD0Ev>:
    4674:	20 e5       	ldi	r18, 0x50	; 80
    4676:	32 e0       	ldi	r19, 0x02	; 2
    4678:	fc 01       	movw	r30, r24
    467a:	31 83       	std	Z+1, r19	; 0x01
    467c:	20 83       	st	Z, r18
					LateralControl(0)
				{
					
				}
				
				~ControlMessage() {}
    467e:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    4682:	08 95       	ret

00004684 <_ZN10helicopter8messages14ControlMessage8getBytesEv>:
#include "ControlMessage.h"

using namespace helicopter::messages;

byte *ControlMessage::getBytes()
{
    4684:	cf 93       	push	r28
    4686:	df 93       	push	r29
    4688:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    468a:	81 e1       	ldi	r24, 0x11	; 17
    468c:	90 e0       	ldi	r25, 0x00	; 0
    468e:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    4692:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4694:	8a 81       	ldd	r24, Y+2	; 0x02
    4696:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4698:	8d 81       	ldd	r24, Y+5	; 0x05
    469a:	9e 81       	ldd	r25, Y+6	; 0x06
    469c:	af 81       	ldd	r26, Y+7	; 0x07
    469e:	b8 85       	ldd	r27, Y+8	; 0x08
    46a0:	81 83       	std	Z+1, r24	; 0x01
    46a2:	92 83       	std	Z+2, r25	; 0x02
    46a4:	a3 83       	std	Z+3, r26	; 0x03
    46a6:	b4 83       	std	Z+4, r27	; 0x04
    46a8:	49 85       	ldd	r20, Y+9	; 0x09
    46aa:	5a 85       	ldd	r21, Y+10	; 0x0a
    46ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    46ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    46b0:	45 83       	std	Z+5, r20	; 0x05
    46b2:	56 83       	std	Z+6, r21	; 0x06
    46b4:	67 83       	std	Z+7, r22	; 0x07
    46b6:	70 87       	std	Z+8, r23	; 0x08
    46b8:	4d 85       	ldd	r20, Y+13	; 0x0d
    46ba:	5e 85       	ldd	r21, Y+14	; 0x0e
    46bc:	6f 85       	ldd	r22, Y+15	; 0x0f
    46be:	78 89       	ldd	r23, Y+16	; 0x10
    46c0:	41 87       	std	Z+9, r20	; 0x09
    46c2:	52 87       	std	Z+10, r21	; 0x0a
    46c4:	63 87       	std	Z+11, r22	; 0x0b
    46c6:	74 87       	std	Z+12, r23	; 0x0c
    46c8:	49 89       	ldd	r20, Y+17	; 0x11
    46ca:	5a 89       	ldd	r21, Y+18	; 0x12
    46cc:	6b 89       	ldd	r22, Y+19	; 0x13
    46ce:	7c 89       	ldd	r23, Y+20	; 0x14
    46d0:	45 87       	std	Z+13, r20	; 0x0d
    46d2:	56 87       	std	Z+14, r21	; 0x0e
    46d4:	67 87       	std	Z+15, r22	; 0x0f
    46d6:	70 8b       	std	Z+16, r23	; 0x10
	encode (msgPtr, LongitudeControl);
	encode (msgPtr, LateralControl);
	
	
	return msg;
}
    46d8:	8e 2f       	mov	r24, r30
    46da:	9f 2f       	mov	r25, r31
    46dc:	df 91       	pop	r29
    46de:	cf 91       	pop	r28
    46e0:	08 95       	ret

000046e2 <_ZN10helicopter8messages14ControlMessage12buildMessageEPh>:

void ControlMessage::buildMessage(byte *message)
{
    46e2:	cf 93       	push	r28
    46e4:	df 93       	push	r29
    46e6:	fc 01       	movw	r30, r24
    46e8:	eb 01       	movw	r28, r22
	if (message != NULL)
    46ea:	20 97       	sbiw	r28, 0x00	; 0
    46ec:	11 f1       	breq	.+68     	; 0x4732 <_ZN10helicopter8messages14ControlMessage12buildMessageEPh+0x50>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    46ee:	88 81       	ld	r24, Y
    46f0:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    46f2:	89 81       	ldd	r24, Y+1	; 0x01
    46f4:	9a 81       	ldd	r25, Y+2	; 0x02
    46f6:	ab 81       	ldd	r26, Y+3	; 0x03
    46f8:	bc 81       	ldd	r27, Y+4	; 0x04
    46fa:	85 83       	std	Z+5, r24	; 0x05
    46fc:	96 83       	std	Z+6, r25	; 0x06
    46fe:	a7 83       	std	Z+7, r26	; 0x07
    4700:	b0 87       	std	Z+8, r27	; 0x08
    4702:	4d 81       	ldd	r20, Y+5	; 0x05
    4704:	5e 81       	ldd	r21, Y+6	; 0x06
    4706:	6f 81       	ldd	r22, Y+7	; 0x07
    4708:	78 85       	ldd	r23, Y+8	; 0x08
    470a:	41 87       	std	Z+9, r20	; 0x09
    470c:	52 87       	std	Z+10, r21	; 0x0a
    470e:	63 87       	std	Z+11, r22	; 0x0b
    4710:	74 87       	std	Z+12, r23	; 0x0c
    4712:	49 85       	ldd	r20, Y+9	; 0x09
    4714:	5a 85       	ldd	r21, Y+10	; 0x0a
    4716:	6b 85       	ldd	r22, Y+11	; 0x0b
    4718:	7c 85       	ldd	r23, Y+12	; 0x0c
    471a:	45 87       	std	Z+13, r20	; 0x0d
    471c:	56 87       	std	Z+14, r21	; 0x0e
    471e:	67 87       	std	Z+15, r22	; 0x0f
    4720:	70 8b       	std	Z+16, r23	; 0x10
    4722:	4d 85       	ldd	r20, Y+13	; 0x0d
    4724:	5e 85       	ldd	r21, Y+14	; 0x0e
    4726:	6f 85       	ldd	r22, Y+15	; 0x0f
    4728:	78 89       	ldd	r23, Y+16	; 0x10
    472a:	41 8b       	std	Z+17, r20	; 0x11
    472c:	52 8b       	std	Z+18, r21	; 0x12
    472e:	63 8b       	std	Z+19, r22	; 0x13
    4730:	74 8b       	std	Z+20, r23	; 0x14
		decode (message, MainRotorCollectiveControl);
		decode (message, YawControl);
		decode (message, LongitudeControl);
		decode (message, LateralControl);
	}
}
    4732:	df 91       	pop	r29
    4734:	cf 91       	pop	r28
    4736:	08 95       	ret

00004738 <_ZN10helicopter8messages12GainsMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4738:	20 e5       	ldi	r18, 0x50	; 80
    473a:	32 e0       	ldi	r19, 0x02	; 2
    473c:	fc 01       	movw	r30, r24
    473e:	31 83       	std	Z+1, r19	; 0x01
    4740:	20 83       	st	Z, r18
    4742:	08 95       	ret

00004744 <_ZN10helicopter8messages12GainsMessageD0Ev>:
    4744:	20 e5       	ldi	r18, 0x50	; 80
    4746:	32 e0       	ldi	r19, 0x02	; 2
    4748:	fc 01       	movw	r30, r24
    474a:	31 83       	std	Z+1, r19	; 0x01
    474c:	20 83       	st	Z, r18
					YawRefSetpoint(0)
				{
				
				}
			
				~GainsMessage() {}
    474e:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    4752:	08 95       	ret

00004754 <_ZN10helicopter8messages12GainsMessage8getBytesEv>:

using namespace helicopter::messages;


byte *GainsMessage::getBytes()
{
    4754:	cf 93       	push	r28
    4756:	df 93       	push	r29
    4758:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    475a:	81 e6       	ldi	r24, 0x61	; 97
    475c:	90 e0       	ldi	r25, 0x00	; 0
    475e:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    4762:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4764:	8a 81       	ldd	r24, Y+2	; 0x02
    4766:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4768:	8d 81       	ldd	r24, Y+5	; 0x05
    476a:	9e 81       	ldd	r25, Y+6	; 0x06
    476c:	af 81       	ldd	r26, Y+7	; 0x07
    476e:	b8 85       	ldd	r27, Y+8	; 0x08
    4770:	81 83       	std	Z+1, r24	; 0x01
    4772:	92 83       	std	Z+2, r25	; 0x02
    4774:	a3 83       	std	Z+3, r26	; 0x03
    4776:	b4 83       	std	Z+4, r27	; 0x04
    4778:	89 85       	ldd	r24, Y+9	; 0x09
    477a:	9a 85       	ldd	r25, Y+10	; 0x0a
    477c:	ab 85       	ldd	r26, Y+11	; 0x0b
    477e:	bc 85       	ldd	r27, Y+12	; 0x0c
    4780:	85 83       	std	Z+5, r24	; 0x05
    4782:	96 83       	std	Z+6, r25	; 0x06
    4784:	a7 83       	std	Z+7, r26	; 0x07
    4786:	b0 87       	std	Z+8, r27	; 0x08
    4788:	8d 85       	ldd	r24, Y+13	; 0x0d
    478a:	9e 85       	ldd	r25, Y+14	; 0x0e
    478c:	af 85       	ldd	r26, Y+15	; 0x0f
    478e:	b8 89       	ldd	r27, Y+16	; 0x10
    4790:	81 87       	std	Z+9, r24	; 0x09
    4792:	92 87       	std	Z+10, r25	; 0x0a
    4794:	a3 87       	std	Z+11, r26	; 0x0b
    4796:	b4 87       	std	Z+12, r27	; 0x0c
    4798:	89 89       	ldd	r24, Y+17	; 0x11
    479a:	9a 89       	ldd	r25, Y+18	; 0x12
    479c:	ab 89       	ldd	r26, Y+19	; 0x13
    479e:	bc 89       	ldd	r27, Y+20	; 0x14
    47a0:	85 87       	std	Z+13, r24	; 0x0d
    47a2:	96 87       	std	Z+14, r25	; 0x0e
    47a4:	a7 87       	std	Z+15, r26	; 0x0f
    47a6:	b0 8b       	std	Z+16, r27	; 0x10
    47a8:	8d 89       	ldd	r24, Y+21	; 0x15
    47aa:	9e 89       	ldd	r25, Y+22	; 0x16
    47ac:	af 89       	ldd	r26, Y+23	; 0x17
    47ae:	b8 8d       	ldd	r27, Y+24	; 0x18
    47b0:	81 8b       	std	Z+17, r24	; 0x11
    47b2:	92 8b       	std	Z+18, r25	; 0x12
    47b4:	a3 8b       	std	Z+19, r26	; 0x13
    47b6:	b4 8b       	std	Z+20, r27	; 0x14
    47b8:	89 8d       	ldd	r24, Y+25	; 0x19
    47ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    47bc:	ab 8d       	ldd	r26, Y+27	; 0x1b
    47be:	bc 8d       	ldd	r27, Y+28	; 0x1c
    47c0:	85 8b       	std	Z+21, r24	; 0x15
    47c2:	96 8b       	std	Z+22, r25	; 0x16
    47c4:	a7 8b       	std	Z+23, r26	; 0x17
    47c6:	b0 8f       	std	Z+24, r27	; 0x18
    47c8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    47ca:	9e 8d       	ldd	r25, Y+30	; 0x1e
    47cc:	af 8d       	ldd	r26, Y+31	; 0x1f
    47ce:	b8 a1       	ldd	r27, Y+32	; 0x20
    47d0:	81 8f       	std	Z+25, r24	; 0x19
    47d2:	92 8f       	std	Z+26, r25	; 0x1a
    47d4:	a3 8f       	std	Z+27, r26	; 0x1b
    47d6:	b4 8f       	std	Z+28, r27	; 0x1c
    47d8:	89 a1       	ldd	r24, Y+33	; 0x21
    47da:	9a a1       	ldd	r25, Y+34	; 0x22
    47dc:	ab a1       	ldd	r26, Y+35	; 0x23
    47de:	bc a1       	ldd	r27, Y+36	; 0x24
    47e0:	85 8f       	std	Z+29, r24	; 0x1d
    47e2:	96 8f       	std	Z+30, r25	; 0x1e
    47e4:	a7 8f       	std	Z+31, r26	; 0x1f
    47e6:	b0 a3       	std	Z+32, r27	; 0x20
    47e8:	8d a1       	ldd	r24, Y+37	; 0x25
    47ea:	9e a1       	ldd	r25, Y+38	; 0x26
    47ec:	af a1       	ldd	r26, Y+39	; 0x27
    47ee:	b8 a5       	ldd	r27, Y+40	; 0x28
    47f0:	81 a3       	std	Z+33, r24	; 0x21
    47f2:	92 a3       	std	Z+34, r25	; 0x22
    47f4:	a3 a3       	std	Z+35, r26	; 0x23
    47f6:	b4 a3       	std	Z+36, r27	; 0x24
    47f8:	89 a5       	ldd	r24, Y+41	; 0x29
    47fa:	9a a5       	ldd	r25, Y+42	; 0x2a
    47fc:	ab a5       	ldd	r26, Y+43	; 0x2b
    47fe:	bc a5       	ldd	r27, Y+44	; 0x2c
    4800:	85 a3       	std	Z+37, r24	; 0x25
    4802:	96 a3       	std	Z+38, r25	; 0x26
    4804:	a7 a3       	std	Z+39, r26	; 0x27
    4806:	b0 a7       	std	Z+40, r27	; 0x28
    4808:	8d a5       	ldd	r24, Y+45	; 0x2d
    480a:	9e a5       	ldd	r25, Y+46	; 0x2e
    480c:	af a5       	ldd	r26, Y+47	; 0x2f
    480e:	b8 a9       	ldd	r27, Y+48	; 0x30
    4810:	81 a7       	std	Z+41, r24	; 0x29
    4812:	92 a7       	std	Z+42, r25	; 0x2a
    4814:	a3 a7       	std	Z+43, r26	; 0x2b
    4816:	b4 a7       	std	Z+44, r27	; 0x2c
    4818:	89 a9       	ldd	r24, Y+49	; 0x31
    481a:	9a a9       	ldd	r25, Y+50	; 0x32
    481c:	ab a9       	ldd	r26, Y+51	; 0x33
    481e:	bc a9       	ldd	r27, Y+52	; 0x34
    4820:	85 a7       	std	Z+45, r24	; 0x2d
    4822:	96 a7       	std	Z+46, r25	; 0x2e
    4824:	a7 a7       	std	Z+47, r26	; 0x2f
    4826:	b0 ab       	std	Z+48, r27	; 0x30
    4828:	8d a9       	ldd	r24, Y+53	; 0x35
    482a:	9e a9       	ldd	r25, Y+54	; 0x36
    482c:	af a9       	ldd	r26, Y+55	; 0x37
    482e:	b8 ad       	ldd	r27, Y+56	; 0x38
    4830:	81 ab       	std	Z+49, r24	; 0x31
    4832:	92 ab       	std	Z+50, r25	; 0x32
    4834:	a3 ab       	std	Z+51, r26	; 0x33
    4836:	b4 ab       	std	Z+52, r27	; 0x34
    4838:	89 ad       	ldd	r24, Y+57	; 0x39
    483a:	9a ad       	ldd	r25, Y+58	; 0x3a
    483c:	ab ad       	ldd	r26, Y+59	; 0x3b
    483e:	bc ad       	ldd	r27, Y+60	; 0x3c
    4840:	85 ab       	std	Z+53, r24	; 0x35
    4842:	96 ab       	std	Z+54, r25	; 0x36
    4844:	a7 ab       	std	Z+55, r26	; 0x37
    4846:	b0 af       	std	Z+56, r27	; 0x38
    4848:	de 01       	movw	r26, r28
    484a:	dd 96       	adiw	r26, 0x3d	; 61
    484c:	8d 91       	ld	r24, X+
    484e:	9d 91       	ld	r25, X+
    4850:	0d 90       	ld	r0, X+
    4852:	bc 91       	ld	r27, X
    4854:	a0 2d       	mov	r26, r0
    4856:	81 af       	std	Z+57, r24	; 0x39
    4858:	92 af       	std	Z+58, r25	; 0x3a
    485a:	a3 af       	std	Z+59, r26	; 0x3b
    485c:	b4 af       	std	Z+60, r27	; 0x3c
    485e:	9f 01       	movw	r18, r30
    4860:	23 5c       	subi	r18, 0xC3	; 195
    4862:	3f 4f       	sbci	r19, 0xFF	; 255
    4864:	de 01       	movw	r26, r28
    4866:	af 5b       	subi	r26, 0xBF	; 191
    4868:	bf 4f       	sbci	r27, 0xFF	; 255
    486a:	4d 91       	ld	r20, X+
    486c:	5d 91       	ld	r21, X+
    486e:	6d 91       	ld	r22, X+
    4870:	7c 91       	ld	r23, X
    4872:	d9 01       	movw	r26, r18
    4874:	4d 93       	st	X+, r20
    4876:	5d 93       	st	X+, r21
    4878:	6d 93       	st	X+, r22
    487a:	7c 93       	st	X, r23
    487c:	13 97       	sbiw	r26, 0x03	; 3
    487e:	9f 01       	movw	r18, r30
    4880:	2f 5b       	subi	r18, 0xBF	; 191
    4882:	3f 4f       	sbci	r19, 0xFF	; 255
    4884:	de 01       	movw	r26, r28
    4886:	ab 5b       	subi	r26, 0xBB	; 187
    4888:	bf 4f       	sbci	r27, 0xFF	; 255
    488a:	4d 91       	ld	r20, X+
    488c:	5d 91       	ld	r21, X+
    488e:	6d 91       	ld	r22, X+
    4890:	7c 91       	ld	r23, X
    4892:	d9 01       	movw	r26, r18
    4894:	4d 93       	st	X+, r20
    4896:	5d 93       	st	X+, r21
    4898:	6d 93       	st	X+, r22
    489a:	7c 93       	st	X, r23
    489c:	13 97       	sbiw	r26, 0x03	; 3
    489e:	9f 01       	movw	r18, r30
    48a0:	2b 5b       	subi	r18, 0xBB	; 187
    48a2:	3f 4f       	sbci	r19, 0xFF	; 255
    48a4:	de 01       	movw	r26, r28
    48a6:	a7 5b       	subi	r26, 0xB7	; 183
    48a8:	bf 4f       	sbci	r27, 0xFF	; 255
    48aa:	4d 91       	ld	r20, X+
    48ac:	5d 91       	ld	r21, X+
    48ae:	6d 91       	ld	r22, X+
    48b0:	7c 91       	ld	r23, X
    48b2:	d9 01       	movw	r26, r18
    48b4:	4d 93       	st	X+, r20
    48b6:	5d 93       	st	X+, r21
    48b8:	6d 93       	st	X+, r22
    48ba:	7c 93       	st	X, r23
    48bc:	13 97       	sbiw	r26, 0x03	; 3
    48be:	9f 01       	movw	r18, r30
    48c0:	27 5b       	subi	r18, 0xB7	; 183
    48c2:	3f 4f       	sbci	r19, 0xFF	; 255
    48c4:	de 01       	movw	r26, r28
    48c6:	a3 5b       	subi	r26, 0xB3	; 179
    48c8:	bf 4f       	sbci	r27, 0xFF	; 255
    48ca:	4d 91       	ld	r20, X+
    48cc:	5d 91       	ld	r21, X+
    48ce:	6d 91       	ld	r22, X+
    48d0:	7c 91       	ld	r23, X
    48d2:	d9 01       	movw	r26, r18
    48d4:	4d 93       	st	X+, r20
    48d6:	5d 93       	st	X+, r21
    48d8:	6d 93       	st	X+, r22
    48da:	7c 93       	st	X, r23
    48dc:	13 97       	sbiw	r26, 0x03	; 3
    48de:	9f 01       	movw	r18, r30
    48e0:	23 5b       	subi	r18, 0xB3	; 179
    48e2:	3f 4f       	sbci	r19, 0xFF	; 255
    48e4:	de 01       	movw	r26, r28
    48e6:	af 5a       	subi	r26, 0xAF	; 175
    48e8:	bf 4f       	sbci	r27, 0xFF	; 255
    48ea:	4d 91       	ld	r20, X+
    48ec:	5d 91       	ld	r21, X+
    48ee:	6d 91       	ld	r22, X+
    48f0:	7c 91       	ld	r23, X
    48f2:	d9 01       	movw	r26, r18
    48f4:	4d 93       	st	X+, r20
    48f6:	5d 93       	st	X+, r21
    48f8:	6d 93       	st	X+, r22
    48fa:	7c 93       	st	X, r23
    48fc:	13 97       	sbiw	r26, 0x03	; 3
    48fe:	9f 01       	movw	r18, r30
    4900:	2f 5a       	subi	r18, 0xAF	; 175
    4902:	3f 4f       	sbci	r19, 0xFF	; 255
    4904:	de 01       	movw	r26, r28
    4906:	ab 5a       	subi	r26, 0xAB	; 171
    4908:	bf 4f       	sbci	r27, 0xFF	; 255
    490a:	4d 91       	ld	r20, X+
    490c:	5d 91       	ld	r21, X+
    490e:	6d 91       	ld	r22, X+
    4910:	7c 91       	ld	r23, X
    4912:	d9 01       	movw	r26, r18
    4914:	4d 93       	st	X+, r20
    4916:	5d 93       	st	X+, r21
    4918:	6d 93       	st	X+, r22
    491a:	7c 93       	st	X, r23
    491c:	13 97       	sbiw	r26, 0x03	; 3
    491e:	9f 01       	movw	r18, r30
    4920:	2b 5a       	subi	r18, 0xAB	; 171
    4922:	3f 4f       	sbci	r19, 0xFF	; 255
    4924:	ce 01       	movw	r24, r28
    4926:	87 5a       	subi	r24, 0xA7	; 167
    4928:	9f 4f       	sbci	r25, 0xFF	; 255
    492a:	dc 01       	movw	r26, r24
    492c:	4d 91       	ld	r20, X+
    492e:	5d 91       	ld	r21, X+
    4930:	6d 91       	ld	r22, X+
    4932:	7c 91       	ld	r23, X
    4934:	d9 01       	movw	r26, r18
    4936:	4d 93       	st	X+, r20
    4938:	5d 93       	st	X+, r21
    493a:	6d 93       	st	X+, r22
    493c:	7c 93       	st	X, r23
    493e:	13 97       	sbiw	r26, 0x03	; 3
    4940:	9f 01       	movw	r18, r30
    4942:	27 5a       	subi	r18, 0xA7	; 167
    4944:	3f 4f       	sbci	r19, 0xFF	; 255
    4946:	ce 01       	movw	r24, r28
    4948:	83 5a       	subi	r24, 0xA3	; 163
    494a:	9f 4f       	sbci	r25, 0xFF	; 255
    494c:	dc 01       	movw	r26, r24
    494e:	4d 91       	ld	r20, X+
    4950:	5d 91       	ld	r21, X+
    4952:	6d 91       	ld	r22, X+
    4954:	7c 91       	ld	r23, X
    4956:	d9 01       	movw	r26, r18
    4958:	4d 93       	st	X+, r20
    495a:	5d 93       	st	X+, r21
    495c:	6d 93       	st	X+, r22
    495e:	7c 93       	st	X, r23
    4960:	13 97       	sbiw	r26, 0x03	; 3
    4962:	df 01       	movw	r26, r30
    4964:	a3 5a       	subi	r26, 0xA3	; 163
    4966:	bf 4f       	sbci	r27, 0xFF	; 255
    4968:	cf 59       	subi	r28, 0x9F	; 159
    496a:	df 4f       	sbci	r29, 0xFF	; 255
    496c:	48 81       	ld	r20, Y
    496e:	59 81       	ldd	r21, Y+1	; 0x01
    4970:	6a 81       	ldd	r22, Y+2	; 0x02
    4972:	7b 81       	ldd	r23, Y+3	; 0x03
    4974:	4d 93       	st	X+, r20
    4976:	5d 93       	st	X+, r21
    4978:	6d 93       	st	X+, r22
    497a:	7c 93       	st	X, r23
    497c:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, YRefSetpoint);
	encode (msgPtr, ZRefSetpoint);	
	encode (msgPtr, YawRefSetpoint);
	
	return msg;
}
    497e:	8e 2f       	mov	r24, r30
    4980:	9f 2f       	mov	r25, r31
    4982:	df 91       	pop	r29
    4984:	cf 91       	pop	r28
    4986:	08 95       	ret

00004988 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>:

void GainsMessage::buildMessage(byte *message)
{
    4988:	cf 93       	push	r28
    498a:	df 93       	push	r29
    498c:	fc 01       	movw	r30, r24
    498e:	db 01       	movw	r26, r22
	if (message != NULL)
    4990:	10 97       	sbiw	r26, 0x00	; 0
    4992:	09 f4       	brne	.+2      	; 0x4996 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0xe>
    4994:	25 c1       	rjmp	.+586    	; 0x4be0 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh+0x258>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    4996:	8c 91       	ld	r24, X
    4998:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    499a:	11 96       	adiw	r26, 0x01	; 1
    499c:	4d 91       	ld	r20, X+
    499e:	5d 91       	ld	r21, X+
    49a0:	6d 91       	ld	r22, X+
    49a2:	7c 91       	ld	r23, X
    49a4:	14 97       	sbiw	r26, 0x04	; 4
    49a6:	45 83       	std	Z+5, r20	; 0x05
    49a8:	56 83       	std	Z+6, r21	; 0x06
    49aa:	67 83       	std	Z+7, r22	; 0x07
    49ac:	70 87       	std	Z+8, r23	; 0x08
    49ae:	15 96       	adiw	r26, 0x05	; 5
    49b0:	4d 91       	ld	r20, X+
    49b2:	5d 91       	ld	r21, X+
    49b4:	6d 91       	ld	r22, X+
    49b6:	7c 91       	ld	r23, X
    49b8:	18 97       	sbiw	r26, 0x08	; 8
    49ba:	41 87       	std	Z+9, r20	; 0x09
    49bc:	52 87       	std	Z+10, r21	; 0x0a
    49be:	63 87       	std	Z+11, r22	; 0x0b
    49c0:	74 87       	std	Z+12, r23	; 0x0c
    49c2:	19 96       	adiw	r26, 0x09	; 9
    49c4:	4d 91       	ld	r20, X+
    49c6:	5d 91       	ld	r21, X+
    49c8:	6d 91       	ld	r22, X+
    49ca:	7c 91       	ld	r23, X
    49cc:	1c 97       	sbiw	r26, 0x0c	; 12
    49ce:	45 87       	std	Z+13, r20	; 0x0d
    49d0:	56 87       	std	Z+14, r21	; 0x0e
    49d2:	67 87       	std	Z+15, r22	; 0x0f
    49d4:	70 8b       	std	Z+16, r23	; 0x10
    49d6:	1d 96       	adiw	r26, 0x0d	; 13
    49d8:	4d 91       	ld	r20, X+
    49da:	5d 91       	ld	r21, X+
    49dc:	6d 91       	ld	r22, X+
    49de:	7c 91       	ld	r23, X
    49e0:	50 97       	sbiw	r26, 0x10	; 16
    49e2:	41 8b       	std	Z+17, r20	; 0x11
    49e4:	52 8b       	std	Z+18, r21	; 0x12
    49e6:	63 8b       	std	Z+19, r22	; 0x13
    49e8:	74 8b       	std	Z+20, r23	; 0x14
    49ea:	51 96       	adiw	r26, 0x11	; 17
    49ec:	4d 91       	ld	r20, X+
    49ee:	5d 91       	ld	r21, X+
    49f0:	6d 91       	ld	r22, X+
    49f2:	7c 91       	ld	r23, X
    49f4:	54 97       	sbiw	r26, 0x14	; 20
    49f6:	45 8b       	std	Z+21, r20	; 0x15
    49f8:	56 8b       	std	Z+22, r21	; 0x16
    49fa:	67 8b       	std	Z+23, r22	; 0x17
    49fc:	70 8f       	std	Z+24, r23	; 0x18
    49fe:	55 96       	adiw	r26, 0x15	; 21
    4a00:	4d 91       	ld	r20, X+
    4a02:	5d 91       	ld	r21, X+
    4a04:	6d 91       	ld	r22, X+
    4a06:	7c 91       	ld	r23, X
    4a08:	58 97       	sbiw	r26, 0x18	; 24
    4a0a:	41 8f       	std	Z+25, r20	; 0x19
    4a0c:	52 8f       	std	Z+26, r21	; 0x1a
    4a0e:	63 8f       	std	Z+27, r22	; 0x1b
    4a10:	74 8f       	std	Z+28, r23	; 0x1c
    4a12:	59 96       	adiw	r26, 0x19	; 25
    4a14:	4d 91       	ld	r20, X+
    4a16:	5d 91       	ld	r21, X+
    4a18:	6d 91       	ld	r22, X+
    4a1a:	7c 91       	ld	r23, X
    4a1c:	5c 97       	sbiw	r26, 0x1c	; 28
    4a1e:	45 8f       	std	Z+29, r20	; 0x1d
    4a20:	56 8f       	std	Z+30, r21	; 0x1e
    4a22:	67 8f       	std	Z+31, r22	; 0x1f
    4a24:	70 a3       	std	Z+32, r23	; 0x20
    4a26:	5d 96       	adiw	r26, 0x1d	; 29
    4a28:	4d 91       	ld	r20, X+
    4a2a:	5d 91       	ld	r21, X+
    4a2c:	6d 91       	ld	r22, X+
    4a2e:	7c 91       	ld	r23, X
    4a30:	90 97       	sbiw	r26, 0x20	; 32
    4a32:	41 a3       	std	Z+33, r20	; 0x21
    4a34:	52 a3       	std	Z+34, r21	; 0x22
    4a36:	63 a3       	std	Z+35, r22	; 0x23
    4a38:	74 a3       	std	Z+36, r23	; 0x24
    4a3a:	91 96       	adiw	r26, 0x21	; 33
    4a3c:	4d 91       	ld	r20, X+
    4a3e:	5d 91       	ld	r21, X+
    4a40:	6d 91       	ld	r22, X+
    4a42:	7c 91       	ld	r23, X
    4a44:	94 97       	sbiw	r26, 0x24	; 36
    4a46:	45 a3       	std	Z+37, r20	; 0x25
    4a48:	56 a3       	std	Z+38, r21	; 0x26
    4a4a:	67 a3       	std	Z+39, r22	; 0x27
    4a4c:	70 a7       	std	Z+40, r23	; 0x28
    4a4e:	95 96       	adiw	r26, 0x25	; 37
    4a50:	4d 91       	ld	r20, X+
    4a52:	5d 91       	ld	r21, X+
    4a54:	6d 91       	ld	r22, X+
    4a56:	7c 91       	ld	r23, X
    4a58:	98 97       	sbiw	r26, 0x28	; 40
    4a5a:	41 a7       	std	Z+41, r20	; 0x29
    4a5c:	52 a7       	std	Z+42, r21	; 0x2a
    4a5e:	63 a7       	std	Z+43, r22	; 0x2b
    4a60:	74 a7       	std	Z+44, r23	; 0x2c
    4a62:	99 96       	adiw	r26, 0x29	; 41
    4a64:	4d 91       	ld	r20, X+
    4a66:	5d 91       	ld	r21, X+
    4a68:	6d 91       	ld	r22, X+
    4a6a:	7c 91       	ld	r23, X
    4a6c:	9c 97       	sbiw	r26, 0x2c	; 44
    4a6e:	45 a7       	std	Z+45, r20	; 0x2d
    4a70:	56 a7       	std	Z+46, r21	; 0x2e
    4a72:	67 a7       	std	Z+47, r22	; 0x2f
    4a74:	70 ab       	std	Z+48, r23	; 0x30
    4a76:	9d 96       	adiw	r26, 0x2d	; 45
    4a78:	4d 91       	ld	r20, X+
    4a7a:	5d 91       	ld	r21, X+
    4a7c:	6d 91       	ld	r22, X+
    4a7e:	7c 91       	ld	r23, X
    4a80:	d0 97       	sbiw	r26, 0x30	; 48
    4a82:	41 ab       	std	Z+49, r20	; 0x31
    4a84:	52 ab       	std	Z+50, r21	; 0x32
    4a86:	63 ab       	std	Z+51, r22	; 0x33
    4a88:	74 ab       	std	Z+52, r23	; 0x34
    4a8a:	d1 96       	adiw	r26, 0x31	; 49
    4a8c:	4d 91       	ld	r20, X+
    4a8e:	5d 91       	ld	r21, X+
    4a90:	6d 91       	ld	r22, X+
    4a92:	7c 91       	ld	r23, X
    4a94:	d4 97       	sbiw	r26, 0x34	; 52
    4a96:	45 ab       	std	Z+53, r20	; 0x35
    4a98:	56 ab       	std	Z+54, r21	; 0x36
    4a9a:	67 ab       	std	Z+55, r22	; 0x37
    4a9c:	70 af       	std	Z+56, r23	; 0x38
    4a9e:	d5 96       	adiw	r26, 0x35	; 53
    4aa0:	4d 91       	ld	r20, X+
    4aa2:	5d 91       	ld	r21, X+
    4aa4:	6d 91       	ld	r22, X+
    4aa6:	7c 91       	ld	r23, X
    4aa8:	d8 97       	sbiw	r26, 0x38	; 56
    4aaa:	41 af       	std	Z+57, r20	; 0x39
    4aac:	52 af       	std	Z+58, r21	; 0x3a
    4aae:	63 af       	std	Z+59, r22	; 0x3b
    4ab0:	74 af       	std	Z+60, r23	; 0x3c
    4ab2:	ef 01       	movw	r28, r30
    4ab4:	ed 96       	adiw	r28, 0x3d	; 61
    4ab6:	d9 96       	adiw	r26, 0x39	; 57
    4ab8:	4d 91       	ld	r20, X+
    4aba:	5d 91       	ld	r21, X+
    4abc:	6d 91       	ld	r22, X+
    4abe:	7c 91       	ld	r23, X
    4ac0:	dc 97       	sbiw	r26, 0x3c	; 60
    4ac2:	48 83       	st	Y, r20
    4ac4:	59 83       	std	Y+1, r21	; 0x01
    4ac6:	6a 83       	std	Y+2, r22	; 0x02
    4ac8:	7b 83       	std	Y+3, r23	; 0x03
    4aca:	9f 01       	movw	r18, r30
    4acc:	2f 5b       	subi	r18, 0xBF	; 191
    4ace:	3f 4f       	sbci	r19, 0xFF	; 255
    4ad0:	cd 01       	movw	r24, r26
    4ad2:	cd 96       	adiw	r24, 0x3d	; 61
    4ad4:	ec 01       	movw	r28, r24
    4ad6:	48 81       	ld	r20, Y
    4ad8:	59 81       	ldd	r21, Y+1	; 0x01
    4ada:	6a 81       	ldd	r22, Y+2	; 0x02
    4adc:	7b 81       	ldd	r23, Y+3	; 0x03
    4ade:	e9 01       	movw	r28, r18
    4ae0:	48 83       	st	Y, r20
    4ae2:	59 83       	std	Y+1, r21	; 0x01
    4ae4:	6a 83       	std	Y+2, r22	; 0x02
    4ae6:	7b 83       	std	Y+3, r23	; 0x03
    4ae8:	9f 01       	movw	r18, r30
    4aea:	2b 5b       	subi	r18, 0xBB	; 187
    4aec:	3f 4f       	sbci	r19, 0xFF	; 255
    4aee:	cd 01       	movw	r24, r26
    4af0:	8f 5b       	subi	r24, 0xBF	; 191
    4af2:	9f 4f       	sbci	r25, 0xFF	; 255
    4af4:	ec 01       	movw	r28, r24
    4af6:	48 81       	ld	r20, Y
    4af8:	59 81       	ldd	r21, Y+1	; 0x01
    4afa:	6a 81       	ldd	r22, Y+2	; 0x02
    4afc:	7b 81       	ldd	r23, Y+3	; 0x03
    4afe:	e9 01       	movw	r28, r18
    4b00:	48 83       	st	Y, r20
    4b02:	59 83       	std	Y+1, r21	; 0x01
    4b04:	6a 83       	std	Y+2, r22	; 0x02
    4b06:	7b 83       	std	Y+3, r23	; 0x03
    4b08:	9f 01       	movw	r18, r30
    4b0a:	27 5b       	subi	r18, 0xB7	; 183
    4b0c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b0e:	cd 01       	movw	r24, r26
    4b10:	8b 5b       	subi	r24, 0xBB	; 187
    4b12:	9f 4f       	sbci	r25, 0xFF	; 255
    4b14:	ec 01       	movw	r28, r24
    4b16:	48 81       	ld	r20, Y
    4b18:	59 81       	ldd	r21, Y+1	; 0x01
    4b1a:	6a 81       	ldd	r22, Y+2	; 0x02
    4b1c:	7b 81       	ldd	r23, Y+3	; 0x03
    4b1e:	e9 01       	movw	r28, r18
    4b20:	48 83       	st	Y, r20
    4b22:	59 83       	std	Y+1, r21	; 0x01
    4b24:	6a 83       	std	Y+2, r22	; 0x02
    4b26:	7b 83       	std	Y+3, r23	; 0x03
    4b28:	9f 01       	movw	r18, r30
    4b2a:	23 5b       	subi	r18, 0xB3	; 179
    4b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b2e:	cd 01       	movw	r24, r26
    4b30:	87 5b       	subi	r24, 0xB7	; 183
    4b32:	9f 4f       	sbci	r25, 0xFF	; 255
    4b34:	ec 01       	movw	r28, r24
    4b36:	48 81       	ld	r20, Y
    4b38:	59 81       	ldd	r21, Y+1	; 0x01
    4b3a:	6a 81       	ldd	r22, Y+2	; 0x02
    4b3c:	7b 81       	ldd	r23, Y+3	; 0x03
    4b3e:	e9 01       	movw	r28, r18
    4b40:	48 83       	st	Y, r20
    4b42:	59 83       	std	Y+1, r21	; 0x01
    4b44:	6a 83       	std	Y+2, r22	; 0x02
    4b46:	7b 83       	std	Y+3, r23	; 0x03
    4b48:	9f 01       	movw	r18, r30
    4b4a:	2f 5a       	subi	r18, 0xAF	; 175
    4b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b4e:	cd 01       	movw	r24, r26
    4b50:	83 5b       	subi	r24, 0xB3	; 179
    4b52:	9f 4f       	sbci	r25, 0xFF	; 255
    4b54:	ec 01       	movw	r28, r24
    4b56:	48 81       	ld	r20, Y
    4b58:	59 81       	ldd	r21, Y+1	; 0x01
    4b5a:	6a 81       	ldd	r22, Y+2	; 0x02
    4b5c:	7b 81       	ldd	r23, Y+3	; 0x03
    4b5e:	e9 01       	movw	r28, r18
    4b60:	48 83       	st	Y, r20
    4b62:	59 83       	std	Y+1, r21	; 0x01
    4b64:	6a 83       	std	Y+2, r22	; 0x02
    4b66:	7b 83       	std	Y+3, r23	; 0x03
    4b68:	9f 01       	movw	r18, r30
    4b6a:	2b 5a       	subi	r18, 0xAB	; 171
    4b6c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b6e:	cd 01       	movw	r24, r26
    4b70:	8f 5a       	subi	r24, 0xAF	; 175
    4b72:	9f 4f       	sbci	r25, 0xFF	; 255
    4b74:	ec 01       	movw	r28, r24
    4b76:	48 81       	ld	r20, Y
    4b78:	59 81       	ldd	r21, Y+1	; 0x01
    4b7a:	6a 81       	ldd	r22, Y+2	; 0x02
    4b7c:	7b 81       	ldd	r23, Y+3	; 0x03
    4b7e:	e9 01       	movw	r28, r18
    4b80:	48 83       	st	Y, r20
    4b82:	59 83       	std	Y+1, r21	; 0x01
    4b84:	6a 83       	std	Y+2, r22	; 0x02
    4b86:	7b 83       	std	Y+3, r23	; 0x03
    4b88:	9f 01       	movw	r18, r30
    4b8a:	27 5a       	subi	r18, 0xA7	; 167
    4b8c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b8e:	cd 01       	movw	r24, r26
    4b90:	8b 5a       	subi	r24, 0xAB	; 171
    4b92:	9f 4f       	sbci	r25, 0xFF	; 255
    4b94:	ec 01       	movw	r28, r24
    4b96:	48 81       	ld	r20, Y
    4b98:	59 81       	ldd	r21, Y+1	; 0x01
    4b9a:	6a 81       	ldd	r22, Y+2	; 0x02
    4b9c:	7b 81       	ldd	r23, Y+3	; 0x03
    4b9e:	e9 01       	movw	r28, r18
    4ba0:	48 83       	st	Y, r20
    4ba2:	59 83       	std	Y+1, r21	; 0x01
    4ba4:	6a 83       	std	Y+2, r22	; 0x02
    4ba6:	7b 83       	std	Y+3, r23	; 0x03
    4ba8:	9f 01       	movw	r18, r30
    4baa:	23 5a       	subi	r18, 0xA3	; 163
    4bac:	3f 4f       	sbci	r19, 0xFF	; 255
    4bae:	cd 01       	movw	r24, r26
    4bb0:	87 5a       	subi	r24, 0xA7	; 167
    4bb2:	9f 4f       	sbci	r25, 0xFF	; 255
    4bb4:	ec 01       	movw	r28, r24
    4bb6:	48 81       	ld	r20, Y
    4bb8:	59 81       	ldd	r21, Y+1	; 0x01
    4bba:	6a 81       	ldd	r22, Y+2	; 0x02
    4bbc:	7b 81       	ldd	r23, Y+3	; 0x03
    4bbe:	e9 01       	movw	r28, r18
    4bc0:	48 83       	st	Y, r20
    4bc2:	59 83       	std	Y+1, r21	; 0x01
    4bc4:	6a 83       	std	Y+2, r22	; 0x02
    4bc6:	7b 83       	std	Y+3, r23	; 0x03
    4bc8:	ef 59       	subi	r30, 0x9F	; 159
    4bca:	ff 4f       	sbci	r31, 0xFF	; 255
    4bcc:	a3 5a       	subi	r26, 0xA3	; 163
    4bce:	bf 4f       	sbci	r27, 0xFF	; 255
    4bd0:	4d 91       	ld	r20, X+
    4bd2:	5d 91       	ld	r21, X+
    4bd4:	6d 91       	ld	r22, X+
    4bd6:	7c 91       	ld	r23, X
    4bd8:	40 83       	st	Z, r20
    4bda:	51 83       	std	Z+1, r21	; 0x01
    4bdc:	62 83       	std	Z+2, r22	; 0x02
    4bde:	73 83       	std	Z+3, r23	; 0x03
		decode (message, YRefSetpoint);
		decode (message, ZRefSetpoint);
		decode (message, YawRefSetpoint);
			
	}
}
    4be0:	df 91       	pop	r29
    4be2:	cf 91       	pop	r28
    4be4:	08 95       	ret

00004be6 <_ZN10helicopter8messages12GainsMessage14buildMessageStEPh>:

GainsMessage* GainsMessage::buildMessageSt(byte *message)
{
    4be6:	0f 93       	push	r16
    4be8:	1f 93       	push	r17
    4bea:	cf 93       	push	r28
    4bec:	df 93       	push	r29
    4bee:	8c 01       	movw	r16, r24
	GainsMessage *msg = new GainsMessage();
    4bf0:	85 e6       	ldi	r24, 0x65	; 101
    4bf2:	90 e0       	ldi	r25, 0x00	; 0
    4bf4:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    4bf8:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    4bfa:	87 e0       	ldi	r24, 0x07	; 7
    4bfc:	8a 83       	std	Y+2, r24	; 0x02
    4bfe:	81 e6       	ldi	r24, 0x61	; 97
    4c00:	90 e0       	ldi	r25, 0x00	; 0
    4c02:	9c 83       	std	Y+4, r25	; 0x04
    4c04:	8b 83       	std	Y+3, r24	; 0x03
					ZAntiWindupGain(0),
					
					XRefSetpoint(0),
					YRefSetpoint(0),
					ZRefSetpoint(0),
					YawRefSetpoint(0)
    4c06:	84 e4       	ldi	r24, 0x44	; 68
    4c08:	92 e0       	ldi	r25, 0x02	; 2
    4c0a:	99 83       	std	Y+1, r25	; 0x01
    4c0c:	88 83       	st	Y, r24
    4c0e:	1d 82       	std	Y+5, r1	; 0x05
    4c10:	1e 82       	std	Y+6, r1	; 0x06
    4c12:	1f 82       	std	Y+7, r1	; 0x07
    4c14:	18 86       	std	Y+8, r1	; 0x08
    4c16:	19 86       	std	Y+9, r1	; 0x09
    4c18:	1a 86       	std	Y+10, r1	; 0x0a
    4c1a:	1b 86       	std	Y+11, r1	; 0x0b
    4c1c:	1c 86       	std	Y+12, r1	; 0x0c
    4c1e:	1d 86       	std	Y+13, r1	; 0x0d
    4c20:	1e 86       	std	Y+14, r1	; 0x0e
    4c22:	1f 86       	std	Y+15, r1	; 0x0f
    4c24:	18 8a       	std	Y+16, r1	; 0x10
    4c26:	19 8a       	std	Y+17, r1	; 0x11
    4c28:	1a 8a       	std	Y+18, r1	; 0x12
    4c2a:	1b 8a       	std	Y+19, r1	; 0x13
    4c2c:	1c 8a       	std	Y+20, r1	; 0x14
    4c2e:	1d 8a       	std	Y+21, r1	; 0x15
    4c30:	1e 8a       	std	Y+22, r1	; 0x16
    4c32:	1f 8a       	std	Y+23, r1	; 0x17
    4c34:	18 8e       	std	Y+24, r1	; 0x18
    4c36:	19 8e       	std	Y+25, r1	; 0x19
    4c38:	1a 8e       	std	Y+26, r1	; 0x1a
    4c3a:	1b 8e       	std	Y+27, r1	; 0x1b
    4c3c:	1c 8e       	std	Y+28, r1	; 0x1c
    4c3e:	1d 8e       	std	Y+29, r1	; 0x1d
    4c40:	1e 8e       	std	Y+30, r1	; 0x1e
    4c42:	1f 8e       	std	Y+31, r1	; 0x1f
    4c44:	18 a2       	std	Y+32, r1	; 0x20
    4c46:	19 a2       	std	Y+33, r1	; 0x21
    4c48:	1a a2       	std	Y+34, r1	; 0x22
    4c4a:	1b a2       	std	Y+35, r1	; 0x23
    4c4c:	1c a2       	std	Y+36, r1	; 0x24
    4c4e:	1d a2       	std	Y+37, r1	; 0x25
    4c50:	1e a2       	std	Y+38, r1	; 0x26
    4c52:	1f a2       	std	Y+39, r1	; 0x27
    4c54:	18 a6       	std	Y+40, r1	; 0x28
    4c56:	19 a6       	std	Y+41, r1	; 0x29
    4c58:	1a a6       	std	Y+42, r1	; 0x2a
    4c5a:	1b a6       	std	Y+43, r1	; 0x2b
    4c5c:	1c a6       	std	Y+44, r1	; 0x2c
    4c5e:	1d a6       	std	Y+45, r1	; 0x2d
    4c60:	1e a6       	std	Y+46, r1	; 0x2e
    4c62:	1f a6       	std	Y+47, r1	; 0x2f
    4c64:	18 aa       	std	Y+48, r1	; 0x30
    4c66:	19 aa       	std	Y+49, r1	; 0x31
    4c68:	1a aa       	std	Y+50, r1	; 0x32
    4c6a:	1b aa       	std	Y+51, r1	; 0x33
    4c6c:	1c aa       	std	Y+52, r1	; 0x34
    4c6e:	1d aa       	std	Y+53, r1	; 0x35
    4c70:	1e aa       	std	Y+54, r1	; 0x36
    4c72:	1f aa       	std	Y+55, r1	; 0x37
    4c74:	18 ae       	std	Y+56, r1	; 0x38
    4c76:	19 ae       	std	Y+57, r1	; 0x39
    4c78:	1a ae       	std	Y+58, r1	; 0x3a
    4c7a:	1b ae       	std	Y+59, r1	; 0x3b
    4c7c:	1c ae       	std	Y+60, r1	; 0x3c
    4c7e:	fe 01       	movw	r30, r28
    4c80:	fd 96       	adiw	r30, 0x3d	; 61
    4c82:	10 82       	st	Z, r1
    4c84:	11 82       	std	Z+1, r1	; 0x01
    4c86:	12 82       	std	Z+2, r1	; 0x02
    4c88:	13 82       	std	Z+3, r1	; 0x03
    4c8a:	fe 01       	movw	r30, r28
    4c8c:	ef 5b       	subi	r30, 0xBF	; 191
    4c8e:	ff 4f       	sbci	r31, 0xFF	; 255
    4c90:	10 82       	st	Z, r1
    4c92:	11 82       	std	Z+1, r1	; 0x01
    4c94:	12 82       	std	Z+2, r1	; 0x02
    4c96:	13 82       	std	Z+3, r1	; 0x03
    4c98:	fe 01       	movw	r30, r28
    4c9a:	eb 5b       	subi	r30, 0xBB	; 187
    4c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    4c9e:	10 82       	st	Z, r1
    4ca0:	11 82       	std	Z+1, r1	; 0x01
    4ca2:	12 82       	std	Z+2, r1	; 0x02
    4ca4:	13 82       	std	Z+3, r1	; 0x03
    4ca6:	fe 01       	movw	r30, r28
    4ca8:	e7 5b       	subi	r30, 0xB7	; 183
    4caa:	ff 4f       	sbci	r31, 0xFF	; 255
    4cac:	10 82       	st	Z, r1
    4cae:	11 82       	std	Z+1, r1	; 0x01
    4cb0:	12 82       	std	Z+2, r1	; 0x02
    4cb2:	13 82       	std	Z+3, r1	; 0x03
    4cb4:	fe 01       	movw	r30, r28
    4cb6:	e3 5b       	subi	r30, 0xB3	; 179
    4cb8:	ff 4f       	sbci	r31, 0xFF	; 255
    4cba:	10 82       	st	Z, r1
    4cbc:	11 82       	std	Z+1, r1	; 0x01
    4cbe:	12 82       	std	Z+2, r1	; 0x02
    4cc0:	13 82       	std	Z+3, r1	; 0x03
    4cc2:	fe 01       	movw	r30, r28
    4cc4:	ef 5a       	subi	r30, 0xAF	; 175
    4cc6:	ff 4f       	sbci	r31, 0xFF	; 255
    4cc8:	10 82       	st	Z, r1
    4cca:	11 82       	std	Z+1, r1	; 0x01
    4ccc:	12 82       	std	Z+2, r1	; 0x02
    4cce:	13 82       	std	Z+3, r1	; 0x03
    4cd0:	fe 01       	movw	r30, r28
    4cd2:	eb 5a       	subi	r30, 0xAB	; 171
    4cd4:	ff 4f       	sbci	r31, 0xFF	; 255
    4cd6:	10 82       	st	Z, r1
    4cd8:	11 82       	std	Z+1, r1	; 0x01
    4cda:	12 82       	std	Z+2, r1	; 0x02
    4cdc:	13 82       	std	Z+3, r1	; 0x03
    4cde:	fe 01       	movw	r30, r28
    4ce0:	e7 5a       	subi	r30, 0xA7	; 167
    4ce2:	ff 4f       	sbci	r31, 0xFF	; 255
    4ce4:	10 82       	st	Z, r1
    4ce6:	11 82       	std	Z+1, r1	; 0x01
    4ce8:	12 82       	std	Z+2, r1	; 0x02
    4cea:	13 82       	std	Z+3, r1	; 0x03
    4cec:	fe 01       	movw	r30, r28
    4cee:	e3 5a       	subi	r30, 0xA3	; 163
    4cf0:	ff 4f       	sbci	r31, 0xFF	; 255
    4cf2:	10 82       	st	Z, r1
    4cf4:	11 82       	std	Z+1, r1	; 0x01
    4cf6:	12 82       	std	Z+2, r1	; 0x02
    4cf8:	13 82       	std	Z+3, r1	; 0x03
    4cfa:	fe 01       	movw	r30, r28
    4cfc:	ef 59       	subi	r30, 0x9F	; 159
    4cfe:	ff 4f       	sbci	r31, 0xFF	; 255
    4d00:	10 82       	st	Z, r1
    4d02:	11 82       	std	Z+1, r1	; 0x01
    4d04:	12 82       	std	Z+2, r1	; 0x02
    4d06:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    4d08:	b8 01       	movw	r22, r16
    4d0a:	ce 01       	movw	r24, r28
    4d0c:	0e 94 c4 24 	call	0x4988	; 0x4988 <_ZN10helicopter8messages12GainsMessage12buildMessageEPh>
	
	return msg;
}
    4d10:	8c 2f       	mov	r24, r28
    4d12:	9d 2f       	mov	r25, r29
    4d14:	df 91       	pop	r29
    4d16:	cf 91       	pop	r28
    4d18:	1f 91       	pop	r17
    4d1a:	0f 91       	pop	r16
    4d1c:	08 95       	ret

00004d1e <_ZN10helicopter8messages7MessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4d1e:	20 e5       	ldi	r18, 0x50	; 80
    4d20:	32 e0       	ldi	r19, 0x02	; 2
    4d22:	fc 01       	movw	r30, r24
    4d24:	31 83       	std	Z+1, r19	; 0x01
    4d26:	20 83       	st	Z, r18
    4d28:	08 95       	ret

00004d2a <_ZN10helicopter8messages7Message8getBytesEv>:
	* Returns the data in this message in raw byte format for transmission.
	*/
byte *Message::getBytes()
{
	return NULL;
}
    4d2a:	80 e0       	ldi	r24, 0x00	; 0
    4d2c:	90 e0       	ldi	r25, 0x00	; 0
    4d2e:	08 95       	ret

00004d30 <_ZN10helicopter8messages7Message12buildMessageEPh>:
	* for creating a message object given a stream of bytes.
	* @param message The bytes in the payload of the message which should be used
	* to construct a message object.
	*/
void Message::buildMessage(byte *message)
{
    4d30:	08 95       	ret

00004d32 <_ZN10helicopter8messages7MessageD0Ev>:
    4d32:	20 e5       	ldi	r18, 0x50	; 80
    4d34:	32 e0       	ldi	r19, 0x02	; 2
    4d36:	fc 01       	movw	r30, r24
    4d38:	31 83       	std	Z+1, r19	; 0x01
    4d3a:	20 83       	st	Z, r18
					
				}
    4d3c:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    4d40:	08 95       	ret

00004d42 <_ZN10helicopter8messages7Message14getMessageSizeEv>:
	* Returns the number of bytes in this message. This should
	* be the payload of the message, and not underlying protocol
	* information (sync bytes and checksum bytes)
	*/
int Message::getMessageSize()
{
    4d42:	fc 01       	movw	r30, r24
	return msgSize;
}
    4d44:	83 81       	ldd	r24, Z+3	; 0x03
    4d46:	94 81       	ldd	r25, Z+4	; 0x04
    4d48:	08 95       	ret

00004d4a <_ZN10helicopter8messages17SensorDataMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    4d4a:	20 e5       	ldi	r18, 0x50	; 80
    4d4c:	32 e0       	ldi	r19, 0x02	; 2
    4d4e:	fc 01       	movw	r30, r24
    4d50:	31 83       	std	Z+1, r19	; 0x01
    4d52:	20 83       	st	Z, r18
    4d54:	08 95       	ret

00004d56 <_ZN10helicopter8messages17SensorDataMessageD0Ev>:
    4d56:	20 e5       	ldi	r18, 0x50	; 80
    4d58:	32 e0       	ldi	r19, 0x02	; 2
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	31 83       	std	Z+1, r19	; 0x01
    4d5e:	20 83       	st	Z, r18
					PressureMillibars(0)
				{
					
				}
				
				~SensorDataMessage() {}
    4d60:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    4d64:	08 95       	ret

00004d66 <_ZN10helicopter8messages17SensorDataMessage8getBytesEv>:
#include "SensorDataMessage.h"

using namespace helicopter::messages;

byte *SensorDataMessage::getBytes()
{
    4d66:	cf 93       	push	r28
    4d68:	df 93       	push	r29
    4d6a:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    4d6c:	81 e4       	ldi	r24, 0x41	; 65
    4d6e:	90 e0       	ldi	r25, 0x00	; 0
    4d70:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    4d74:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    4d76:	8a 81       	ldd	r24, Y+2	; 0x02
    4d78:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4d7a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d7c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d7e:	af 81       	ldd	r26, Y+7	; 0x07
    4d80:	b8 85       	ldd	r27, Y+8	; 0x08
    4d82:	81 83       	std	Z+1, r24	; 0x01
    4d84:	92 83       	std	Z+2, r25	; 0x02
    4d86:	a3 83       	std	Z+3, r26	; 0x03
    4d88:	b4 83       	std	Z+4, r27	; 0x04
    4d8a:	89 85       	ldd	r24, Y+9	; 0x09
    4d8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d8e:	ab 85       	ldd	r26, Y+11	; 0x0b
    4d90:	bc 85       	ldd	r27, Y+12	; 0x0c
    4d92:	85 83       	std	Z+5, r24	; 0x05
    4d94:	96 83       	std	Z+6, r25	; 0x06
    4d96:	a7 83       	std	Z+7, r26	; 0x07
    4d98:	b0 87       	std	Z+8, r27	; 0x08
    4d9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d9e:	af 85       	ldd	r26, Y+15	; 0x0f
    4da0:	b8 89       	ldd	r27, Y+16	; 0x10
    4da2:	81 87       	std	Z+9, r24	; 0x09
    4da4:	92 87       	std	Z+10, r25	; 0x0a
    4da6:	a3 87       	std	Z+11, r26	; 0x0b
    4da8:	b4 87       	std	Z+12, r27	; 0x0c
    4daa:	89 89       	ldd	r24, Y+17	; 0x11
    4dac:	9a 89       	ldd	r25, Y+18	; 0x12
    4dae:	ab 89       	ldd	r26, Y+19	; 0x13
    4db0:	bc 89       	ldd	r27, Y+20	; 0x14
    4db2:	85 87       	std	Z+13, r24	; 0x0d
    4db4:	96 87       	std	Z+14, r25	; 0x0e
    4db6:	a7 87       	std	Z+15, r26	; 0x0f
    4db8:	b0 8b       	std	Z+16, r27	; 0x10
    4dba:	8d 89       	ldd	r24, Y+21	; 0x15
    4dbc:	9e 89       	ldd	r25, Y+22	; 0x16
    4dbe:	af 89       	ldd	r26, Y+23	; 0x17
    4dc0:	b8 8d       	ldd	r27, Y+24	; 0x18
    4dc2:	81 8b       	std	Z+17, r24	; 0x11
    4dc4:	92 8b       	std	Z+18, r25	; 0x12
    4dc6:	a3 8b       	std	Z+19, r26	; 0x13
    4dc8:	b4 8b       	std	Z+20, r27	; 0x14
    4dca:	89 8d       	ldd	r24, Y+25	; 0x19
    4dcc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4dce:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4dd0:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4dd2:	85 8b       	std	Z+21, r24	; 0x15
    4dd4:	96 8b       	std	Z+22, r25	; 0x16
    4dd6:	a7 8b       	std	Z+23, r26	; 0x17
    4dd8:	b0 8f       	std	Z+24, r27	; 0x18
    4dda:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4ddc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4dde:	af 8d       	ldd	r26, Y+31	; 0x1f
    4de0:	b8 a1       	ldd	r27, Y+32	; 0x20
    4de2:	81 8f       	std	Z+25, r24	; 0x19
    4de4:	92 8f       	std	Z+26, r25	; 0x1a
    4de6:	a3 8f       	std	Z+27, r26	; 0x1b
    4de8:	b4 8f       	std	Z+28, r27	; 0x1c
    4dea:	89 a1       	ldd	r24, Y+33	; 0x21
    4dec:	9a a1       	ldd	r25, Y+34	; 0x22
    4dee:	ab a1       	ldd	r26, Y+35	; 0x23
    4df0:	bc a1       	ldd	r27, Y+36	; 0x24
    4df2:	85 8f       	std	Z+29, r24	; 0x1d
    4df4:	96 8f       	std	Z+30, r25	; 0x1e
    4df6:	a7 8f       	std	Z+31, r26	; 0x1f
    4df8:	b0 a3       	std	Z+32, r27	; 0x20
    4dfa:	8d a1       	ldd	r24, Y+37	; 0x25
    4dfc:	9e a1       	ldd	r25, Y+38	; 0x26
    4dfe:	af a1       	ldd	r26, Y+39	; 0x27
    4e00:	b8 a5       	ldd	r27, Y+40	; 0x28
    4e02:	81 a3       	std	Z+33, r24	; 0x21
    4e04:	92 a3       	std	Z+34, r25	; 0x22
    4e06:	a3 a3       	std	Z+35, r26	; 0x23
    4e08:	b4 a3       	std	Z+36, r27	; 0x24
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4e0a:	89 a5       	ldd	r24, Y+41	; 0x29
    4e0c:	9a a5       	ldd	r25, Y+42	; 0x2a
    4e0e:	ab a5       	ldd	r26, Y+43	; 0x2b
    4e10:	bc a5       	ldd	r27, Y+44	; 0x2c
    4e12:	85 a3       	std	Z+37, r24	; 0x25
    4e14:	96 a3       	std	Z+38, r25	; 0x26
    4e16:	a7 a3       	std	Z+39, r26	; 0x27
    4e18:	b0 a7       	std	Z+40, r27	; 0x28
    4e1a:	8d a5       	ldd	r24, Y+45	; 0x2d
    4e1c:	9e a5       	ldd	r25, Y+46	; 0x2e
    4e1e:	af a5       	ldd	r26, Y+47	; 0x2f
    4e20:	b8 a9       	ldd	r27, Y+48	; 0x30
    4e22:	81 a7       	std	Z+41, r24	; 0x29
    4e24:	92 a7       	std	Z+42, r25	; 0x2a
    4e26:	a3 a7       	std	Z+43, r26	; 0x2b
    4e28:	b4 a7       	std	Z+44, r27	; 0x2c
    4e2a:	89 a9       	ldd	r24, Y+49	; 0x31
    4e2c:	9a a9       	ldd	r25, Y+50	; 0x32
    4e2e:	ab a9       	ldd	r26, Y+51	; 0x33
    4e30:	bc a9       	ldd	r27, Y+52	; 0x34
    4e32:	85 a7       	std	Z+45, r24	; 0x2d
    4e34:	96 a7       	std	Z+46, r25	; 0x2e
    4e36:	a7 a7       	std	Z+47, r26	; 0x2f
    4e38:	b0 ab       	std	Z+48, r27	; 0x30
    4e3a:	8d a9       	ldd	r24, Y+53	; 0x35
    4e3c:	9e a9       	ldd	r25, Y+54	; 0x36
    4e3e:	af a9       	ldd	r26, Y+55	; 0x37
    4e40:	b8 ad       	ldd	r27, Y+56	; 0x38
    4e42:	81 ab       	std	Z+49, r24	; 0x31
    4e44:	92 ab       	std	Z+50, r25	; 0x32
    4e46:	a3 ab       	std	Z+51, r26	; 0x33
    4e48:	b4 ab       	std	Z+52, r27	; 0x34
    4e4a:	49 ad       	ldd	r20, Y+57	; 0x39
    4e4c:	5a ad       	ldd	r21, Y+58	; 0x3a
    4e4e:	6b ad       	ldd	r22, Y+59	; 0x3b
    4e50:	7c ad       	ldd	r23, Y+60	; 0x3c
    4e52:	45 ab       	std	Z+53, r20	; 0x35
    4e54:	56 ab       	std	Z+54, r21	; 0x36
    4e56:	67 ab       	std	Z+55, r22	; 0x37
    4e58:	70 af       	std	Z+56, r23	; 0x38
    4e5a:	de 01       	movw	r26, r28
    4e5c:	dd 96       	adiw	r26, 0x3d	; 61
    4e5e:	4d 91       	ld	r20, X+
    4e60:	5d 91       	ld	r21, X+
    4e62:	6d 91       	ld	r22, X+
    4e64:	7c 91       	ld	r23, X
    4e66:	41 af       	std	Z+57, r20	; 0x39
    4e68:	52 af       	std	Z+58, r21	; 0x3a
    4e6a:	63 af       	std	Z+59, r22	; 0x3b
    4e6c:	74 af       	std	Z+60, r23	; 0x3c
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    4e6e:	df 01       	movw	r26, r30
    4e70:	dd 96       	adiw	r26, 0x3d	; 61
    4e72:	cf 5b       	subi	r28, 0xBF	; 191
    4e74:	df 4f       	sbci	r29, 0xFF	; 255
    4e76:	48 81       	ld	r20, Y
    4e78:	59 81       	ldd	r21, Y+1	; 0x01
    4e7a:	6a 81       	ldd	r22, Y+2	; 0x02
    4e7c:	7b 81       	ldd	r23, Y+3	; 0x03
    4e7e:	4d 93       	st	X+, r20
    4e80:	5d 93       	st	X+, r21
    4e82:	6d 93       	st	X+, r22
    4e84:	7c 93       	st	X, r23
    4e86:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ZVEcefCms);
	encode (msgPtr, PressureMillibars);
	
	
	return msg;
}
    4e88:	8e 2f       	mov	r24, r30
    4e8a:	9f 2f       	mov	r25, r31
    4e8c:	df 91       	pop	r29
    4e8e:	cf 91       	pop	r28
    4e90:	08 95       	ret

00004e92 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>:

void SensorDataMessage::buildMessage(byte *message)
{
    4e92:	cf 93       	push	r28
    4e94:	df 93       	push	r29
    4e96:	fc 01       	movw	r30, r24
    4e98:	db 01       	movw	r26, r22
	if (message != NULL)
    4e9a:	10 97       	sbiw	r26, 0x00	; 0
    4e9c:	09 f4       	brne	.+2      	; 0x4ea0 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0xe>
    4e9e:	a5 c0       	rjmp	.+330    	; 0x4fea <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh+0x158>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    4ea0:	8c 91       	ld	r24, X
    4ea2:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4ea4:	11 96       	adiw	r26, 0x01	; 1
    4ea6:	4d 91       	ld	r20, X+
    4ea8:	5d 91       	ld	r21, X+
    4eaa:	6d 91       	ld	r22, X+
    4eac:	7c 91       	ld	r23, X
    4eae:	14 97       	sbiw	r26, 0x04	; 4
    4eb0:	45 83       	std	Z+5, r20	; 0x05
    4eb2:	56 83       	std	Z+6, r21	; 0x06
    4eb4:	67 83       	std	Z+7, r22	; 0x07
    4eb6:	70 87       	std	Z+8, r23	; 0x08
    4eb8:	15 96       	adiw	r26, 0x05	; 5
    4eba:	4d 91       	ld	r20, X+
    4ebc:	5d 91       	ld	r21, X+
    4ebe:	6d 91       	ld	r22, X+
    4ec0:	7c 91       	ld	r23, X
    4ec2:	18 97       	sbiw	r26, 0x08	; 8
    4ec4:	41 87       	std	Z+9, r20	; 0x09
    4ec6:	52 87       	std	Z+10, r21	; 0x0a
    4ec8:	63 87       	std	Z+11, r22	; 0x0b
    4eca:	74 87       	std	Z+12, r23	; 0x0c
    4ecc:	19 96       	adiw	r26, 0x09	; 9
    4ece:	4d 91       	ld	r20, X+
    4ed0:	5d 91       	ld	r21, X+
    4ed2:	6d 91       	ld	r22, X+
    4ed4:	7c 91       	ld	r23, X
    4ed6:	1c 97       	sbiw	r26, 0x0c	; 12
    4ed8:	45 87       	std	Z+13, r20	; 0x0d
    4eda:	56 87       	std	Z+14, r21	; 0x0e
    4edc:	67 87       	std	Z+15, r22	; 0x0f
    4ede:	70 8b       	std	Z+16, r23	; 0x10
    4ee0:	1d 96       	adiw	r26, 0x0d	; 13
    4ee2:	4d 91       	ld	r20, X+
    4ee4:	5d 91       	ld	r21, X+
    4ee6:	6d 91       	ld	r22, X+
    4ee8:	7c 91       	ld	r23, X
    4eea:	50 97       	sbiw	r26, 0x10	; 16
    4eec:	41 8b       	std	Z+17, r20	; 0x11
    4eee:	52 8b       	std	Z+18, r21	; 0x12
    4ef0:	63 8b       	std	Z+19, r22	; 0x13
    4ef2:	74 8b       	std	Z+20, r23	; 0x14
    4ef4:	51 96       	adiw	r26, 0x11	; 17
    4ef6:	4d 91       	ld	r20, X+
    4ef8:	5d 91       	ld	r21, X+
    4efa:	6d 91       	ld	r22, X+
    4efc:	7c 91       	ld	r23, X
    4efe:	54 97       	sbiw	r26, 0x14	; 20
    4f00:	45 8b       	std	Z+21, r20	; 0x15
    4f02:	56 8b       	std	Z+22, r21	; 0x16
    4f04:	67 8b       	std	Z+23, r22	; 0x17
    4f06:	70 8f       	std	Z+24, r23	; 0x18
    4f08:	55 96       	adiw	r26, 0x15	; 21
    4f0a:	4d 91       	ld	r20, X+
    4f0c:	5d 91       	ld	r21, X+
    4f0e:	6d 91       	ld	r22, X+
    4f10:	7c 91       	ld	r23, X
    4f12:	58 97       	sbiw	r26, 0x18	; 24
    4f14:	41 8f       	std	Z+25, r20	; 0x19
    4f16:	52 8f       	std	Z+26, r21	; 0x1a
    4f18:	63 8f       	std	Z+27, r22	; 0x1b
    4f1a:	74 8f       	std	Z+28, r23	; 0x1c
    4f1c:	59 96       	adiw	r26, 0x19	; 25
    4f1e:	4d 91       	ld	r20, X+
    4f20:	5d 91       	ld	r21, X+
    4f22:	6d 91       	ld	r22, X+
    4f24:	7c 91       	ld	r23, X
    4f26:	5c 97       	sbiw	r26, 0x1c	; 28
    4f28:	45 8f       	std	Z+29, r20	; 0x1d
    4f2a:	56 8f       	std	Z+30, r21	; 0x1e
    4f2c:	67 8f       	std	Z+31, r22	; 0x1f
    4f2e:	70 a3       	std	Z+32, r23	; 0x20
    4f30:	5d 96       	adiw	r26, 0x1d	; 29
    4f32:	4d 91       	ld	r20, X+
    4f34:	5d 91       	ld	r21, X+
    4f36:	6d 91       	ld	r22, X+
    4f38:	7c 91       	ld	r23, X
    4f3a:	90 97       	sbiw	r26, 0x20	; 32
    4f3c:	41 a3       	std	Z+33, r20	; 0x21
    4f3e:	52 a3       	std	Z+34, r21	; 0x22
    4f40:	63 a3       	std	Z+35, r22	; 0x23
    4f42:	74 a3       	std	Z+36, r23	; 0x24
    4f44:	91 96       	adiw	r26, 0x21	; 33
    4f46:	4d 91       	ld	r20, X+
    4f48:	5d 91       	ld	r21, X+
    4f4a:	6d 91       	ld	r22, X+
    4f4c:	7c 91       	ld	r23, X
    4f4e:	94 97       	sbiw	r26, 0x24	; 36
    4f50:	45 a3       	std	Z+37, r20	; 0x25
    4f52:	56 a3       	std	Z+38, r21	; 0x26
    4f54:	67 a3       	std	Z+39, r22	; 0x27
    4f56:	70 a7       	std	Z+40, r23	; 0x28
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4f58:	95 96       	adiw	r26, 0x25	; 37
    4f5a:	4d 91       	ld	r20, X+
    4f5c:	5d 91       	ld	r21, X+
    4f5e:	6d 91       	ld	r22, X+
    4f60:	7c 91       	ld	r23, X
    4f62:	98 97       	sbiw	r26, 0x28	; 40
    4f64:	41 a7       	std	Z+41, r20	; 0x29
    4f66:	52 a7       	std	Z+42, r21	; 0x2a
    4f68:	63 a7       	std	Z+43, r22	; 0x2b
    4f6a:	74 a7       	std	Z+44, r23	; 0x2c
    4f6c:	99 96       	adiw	r26, 0x29	; 41
    4f6e:	4d 91       	ld	r20, X+
    4f70:	5d 91       	ld	r21, X+
    4f72:	6d 91       	ld	r22, X+
    4f74:	7c 91       	ld	r23, X
    4f76:	9c 97       	sbiw	r26, 0x2c	; 44
    4f78:	45 a7       	std	Z+45, r20	; 0x2d
    4f7a:	56 a7       	std	Z+46, r21	; 0x2e
    4f7c:	67 a7       	std	Z+47, r22	; 0x2f
    4f7e:	70 ab       	std	Z+48, r23	; 0x30
    4f80:	9d 96       	adiw	r26, 0x2d	; 45
    4f82:	4d 91       	ld	r20, X+
    4f84:	5d 91       	ld	r21, X+
    4f86:	6d 91       	ld	r22, X+
    4f88:	7c 91       	ld	r23, X
    4f8a:	d0 97       	sbiw	r26, 0x30	; 48
    4f8c:	41 ab       	std	Z+49, r20	; 0x31
    4f8e:	52 ab       	std	Z+50, r21	; 0x32
    4f90:	63 ab       	std	Z+51, r22	; 0x33
    4f92:	74 ab       	std	Z+52, r23	; 0x34
    4f94:	d1 96       	adiw	r26, 0x31	; 49
    4f96:	4d 91       	ld	r20, X+
    4f98:	5d 91       	ld	r21, X+
    4f9a:	6d 91       	ld	r22, X+
    4f9c:	7c 91       	ld	r23, X
    4f9e:	d4 97       	sbiw	r26, 0x34	; 52
    4fa0:	45 ab       	std	Z+53, r20	; 0x35
    4fa2:	56 ab       	std	Z+54, r21	; 0x36
    4fa4:	67 ab       	std	Z+55, r22	; 0x37
    4fa6:	70 af       	std	Z+56, r23	; 0x38
    4fa8:	d5 96       	adiw	r26, 0x35	; 53
    4faa:	4d 91       	ld	r20, X+
    4fac:	5d 91       	ld	r21, X+
    4fae:	6d 91       	ld	r22, X+
    4fb0:	7c 91       	ld	r23, X
    4fb2:	d8 97       	sbiw	r26, 0x38	; 56
    4fb4:	41 af       	std	Z+57, r20	; 0x39
    4fb6:	52 af       	std	Z+58, r21	; 0x3a
    4fb8:	63 af       	std	Z+59, r22	; 0x3b
    4fba:	74 af       	std	Z+60, r23	; 0x3c
    4fbc:	ef 01       	movw	r28, r30
    4fbe:	ed 96       	adiw	r28, 0x3d	; 61
    4fc0:	d9 96       	adiw	r26, 0x39	; 57
    4fc2:	4d 91       	ld	r20, X+
    4fc4:	5d 91       	ld	r21, X+
    4fc6:	6d 91       	ld	r22, X+
    4fc8:	7c 91       	ld	r23, X
    4fca:	dc 97       	sbiw	r26, 0x3c	; 60
    4fcc:	48 83       	st	Y, r20
    4fce:	59 83       	std	Y+1, r21	; 0x01
    4fd0:	6a 83       	std	Y+2, r22	; 0x02
    4fd2:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    4fd4:	ef 5b       	subi	r30, 0xBF	; 191
    4fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    4fd8:	dd 96       	adiw	r26, 0x3d	; 61
    4fda:	4d 91       	ld	r20, X+
    4fdc:	5d 91       	ld	r21, X+
    4fde:	6d 91       	ld	r22, X+
    4fe0:	7c 91       	ld	r23, X
    4fe2:	40 83       	st	Z, r20
    4fe4:	51 83       	std	Z+1, r21	; 0x01
    4fe6:	62 83       	std	Z+2, r22	; 0x02
    4fe8:	73 83       	std	Z+3, r23	; 0x03
		decode (message, XVEcefCms);
		decode (message, YVEcefCms);
		decode (message, ZVEcefCms);
		decode (message, PressureMillibars);
	}
}
    4fea:	df 91       	pop	r29
    4fec:	cf 91       	pop	r28
    4fee:	08 95       	ret

00004ff0 <_ZN10helicopter8messages17SensorDataMessage14buildMessageStEPh>:

SensorDataMessage* SensorDataMessage::buildMessageSt(byte *message)
{
    4ff0:	0f 93       	push	r16
    4ff2:	1f 93       	push	r17
    4ff4:	cf 93       	push	r28
    4ff6:	df 93       	push	r29
    4ff8:	8c 01       	movw	r16, r24
	SensorDataMessage *msg = new SensorDataMessage();
    4ffa:	85 e4       	ldi	r24, 0x45	; 69
    4ffc:	90 e0       	ldi	r25, 0x00	; 0
    4ffe:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    5002:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    5004:	84 e0       	ldi	r24, 0x04	; 4
    5006:	8a 83       	std	Y+2, r24	; 0x02
    5008:	81 e4       	ldi	r24, 0x41	; 65
    500a:	90 e0       	ldi	r25, 0x00	; 0
    500c:	9c 83       	std	Y+4, r25	; 0x04
    500e:	8b 83       	std	Y+3, r24	; 0x03
					YEcefCm(0),
					ZEcefCm(0),
					XVEcefCms(0),
					YVEcefCms(0),
					ZVEcefCms(0),
					PressureMillibars(0)
    5010:	8c e5       	ldi	r24, 0x5C	; 92
    5012:	92 e0       	ldi	r25, 0x02	; 2
    5014:	99 83       	std	Y+1, r25	; 0x01
    5016:	88 83       	st	Y, r24
    5018:	1d 82       	std	Y+5, r1	; 0x05
    501a:	1e 82       	std	Y+6, r1	; 0x06
    501c:	1f 82       	std	Y+7, r1	; 0x07
    501e:	18 86       	std	Y+8, r1	; 0x08
    5020:	19 86       	std	Y+9, r1	; 0x09
    5022:	1a 86       	std	Y+10, r1	; 0x0a
    5024:	1b 86       	std	Y+11, r1	; 0x0b
    5026:	1c 86       	std	Y+12, r1	; 0x0c
    5028:	1d 86       	std	Y+13, r1	; 0x0d
    502a:	1e 86       	std	Y+14, r1	; 0x0e
    502c:	1f 86       	std	Y+15, r1	; 0x0f
    502e:	18 8a       	std	Y+16, r1	; 0x10
    5030:	19 8a       	std	Y+17, r1	; 0x11
    5032:	1a 8a       	std	Y+18, r1	; 0x12
    5034:	1b 8a       	std	Y+19, r1	; 0x13
    5036:	1c 8a       	std	Y+20, r1	; 0x14
    5038:	1d 8a       	std	Y+21, r1	; 0x15
    503a:	1e 8a       	std	Y+22, r1	; 0x16
    503c:	1f 8a       	std	Y+23, r1	; 0x17
    503e:	18 8e       	std	Y+24, r1	; 0x18
    5040:	19 8e       	std	Y+25, r1	; 0x19
    5042:	1a 8e       	std	Y+26, r1	; 0x1a
    5044:	1b 8e       	std	Y+27, r1	; 0x1b
    5046:	1c 8e       	std	Y+28, r1	; 0x1c
    5048:	1d 8e       	std	Y+29, r1	; 0x1d
    504a:	1e 8e       	std	Y+30, r1	; 0x1e
    504c:	1f 8e       	std	Y+31, r1	; 0x1f
    504e:	18 a2       	std	Y+32, r1	; 0x20
    5050:	19 a2       	std	Y+33, r1	; 0x21
    5052:	1a a2       	std	Y+34, r1	; 0x22
    5054:	1b a2       	std	Y+35, r1	; 0x23
    5056:	1c a2       	std	Y+36, r1	; 0x24
    5058:	1d a2       	std	Y+37, r1	; 0x25
    505a:	1e a2       	std	Y+38, r1	; 0x26
    505c:	1f a2       	std	Y+39, r1	; 0x27
    505e:	18 a6       	std	Y+40, r1	; 0x28
    5060:	19 a6       	std	Y+41, r1	; 0x29
    5062:	1a a6       	std	Y+42, r1	; 0x2a
    5064:	1b a6       	std	Y+43, r1	; 0x2b
    5066:	1c a6       	std	Y+44, r1	; 0x2c
    5068:	1d a6       	std	Y+45, r1	; 0x2d
    506a:	1e a6       	std	Y+46, r1	; 0x2e
    506c:	1f a6       	std	Y+47, r1	; 0x2f
    506e:	18 aa       	std	Y+48, r1	; 0x30
    5070:	19 aa       	std	Y+49, r1	; 0x31
    5072:	1a aa       	std	Y+50, r1	; 0x32
    5074:	1b aa       	std	Y+51, r1	; 0x33
    5076:	1c aa       	std	Y+52, r1	; 0x34
    5078:	1d aa       	std	Y+53, r1	; 0x35
    507a:	1e aa       	std	Y+54, r1	; 0x36
    507c:	1f aa       	std	Y+55, r1	; 0x37
    507e:	18 ae       	std	Y+56, r1	; 0x38
    5080:	19 ae       	std	Y+57, r1	; 0x39
    5082:	1a ae       	std	Y+58, r1	; 0x3a
    5084:	1b ae       	std	Y+59, r1	; 0x3b
    5086:	1c ae       	std	Y+60, r1	; 0x3c
    5088:	fe 01       	movw	r30, r28
    508a:	fd 96       	adiw	r30, 0x3d	; 61
    508c:	10 82       	st	Z, r1
    508e:	11 82       	std	Z+1, r1	; 0x01
    5090:	12 82       	std	Z+2, r1	; 0x02
    5092:	13 82       	std	Z+3, r1	; 0x03
    5094:	fe 01       	movw	r30, r28
    5096:	ef 5b       	subi	r30, 0xBF	; 191
    5098:	ff 4f       	sbci	r31, 0xFF	; 255
    509a:	10 82       	st	Z, r1
    509c:	11 82       	std	Z+1, r1	; 0x01
    509e:	12 82       	std	Z+2, r1	; 0x02
    50a0:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    50a2:	b8 01       	movw	r22, r16
    50a4:	ce 01       	movw	r24, r28
    50a6:	0e 94 49 27 	call	0x4e92	; 0x4e92 <_ZN10helicopter8messages17SensorDataMessage12buildMessageEPh>
	
	return msg;
    50aa:	8c 2f       	mov	r24, r28
    50ac:	9d 2f       	mov	r25, r29
    50ae:	df 91       	pop	r29
    50b0:	cf 91       	pop	r28
    50b2:	1f 91       	pop	r17
    50b4:	0f 91       	pop	r16
    50b6:	08 95       	ret

000050b8 <_ZN10helicopter8messages22SimpleTelemetryMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    50b8:	20 e5       	ldi	r18, 0x50	; 80
    50ba:	32 e0       	ldi	r19, 0x02	; 2
    50bc:	fc 01       	movw	r30, r24
    50be:	31 83       	std	Z+1, r19	; 0x01
    50c0:	20 83       	st	Z, r18
    50c2:	08 95       	ret

000050c4 <_ZN10helicopter8messages22SimpleTelemetryMessageD0Ev>:
    50c4:	20 e5       	ldi	r18, 0x50	; 80
    50c6:	32 e0       	ldi	r19, 0x02	; 2
    50c8:	fc 01       	movw	r30, r24
    50ca:	31 83       	std	Z+1, r19	; 0x01
    50cc:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SimpleTelemetryMessage() {}
    50ce:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    50d2:	08 95       	ret

000050d4 <_ZN10helicopter8messages22SimpleTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SimpleTelemetryMessage::getBytes()
{
    50d4:	cf 93       	push	r28
    50d6:	df 93       	push	r29
    50d8:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    50da:	89 e7       	ldi	r24, 0x79	; 121
    50dc:	90 e0       	ldi	r25, 0x00	; 0
    50de:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    50e2:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    50e4:	8a 81       	ldd	r24, Y+2	; 0x02
    50e6:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    50e8:	8d 81       	ldd	r24, Y+5	; 0x05
    50ea:	9e 81       	ldd	r25, Y+6	; 0x06
    50ec:	af 81       	ldd	r26, Y+7	; 0x07
    50ee:	b8 85       	ldd	r27, Y+8	; 0x08
    50f0:	81 83       	std	Z+1, r24	; 0x01
    50f2:	92 83       	std	Z+2, r25	; 0x02
    50f4:	a3 83       	std	Z+3, r26	; 0x03
    50f6:	b4 83       	std	Z+4, r27	; 0x04
    50f8:	89 85       	ldd	r24, Y+9	; 0x09
    50fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    50fc:	ab 85       	ldd	r26, Y+11	; 0x0b
    50fe:	bc 85       	ldd	r27, Y+12	; 0x0c
    5100:	85 83       	std	Z+5, r24	; 0x05
    5102:	96 83       	std	Z+6, r25	; 0x06
    5104:	a7 83       	std	Z+7, r26	; 0x07
    5106:	b0 87       	std	Z+8, r27	; 0x08
    5108:	8d 85       	ldd	r24, Y+13	; 0x0d
    510a:	9e 85       	ldd	r25, Y+14	; 0x0e
    510c:	af 85       	ldd	r26, Y+15	; 0x0f
    510e:	b8 89       	ldd	r27, Y+16	; 0x10
    5110:	81 87       	std	Z+9, r24	; 0x09
    5112:	92 87       	std	Z+10, r25	; 0x0a
    5114:	a3 87       	std	Z+11, r26	; 0x0b
    5116:	b4 87       	std	Z+12, r27	; 0x0c
    5118:	89 89       	ldd	r24, Y+17	; 0x11
    511a:	9a 89       	ldd	r25, Y+18	; 0x12
    511c:	ab 89       	ldd	r26, Y+19	; 0x13
    511e:	bc 89       	ldd	r27, Y+20	; 0x14
    5120:	85 87       	std	Z+13, r24	; 0x0d
    5122:	96 87       	std	Z+14, r25	; 0x0e
    5124:	a7 87       	std	Z+15, r26	; 0x0f
    5126:	b0 8b       	std	Z+16, r27	; 0x10
    5128:	8d 89       	ldd	r24, Y+21	; 0x15
    512a:	9e 89       	ldd	r25, Y+22	; 0x16
    512c:	af 89       	ldd	r26, Y+23	; 0x17
    512e:	b8 8d       	ldd	r27, Y+24	; 0x18
    5130:	81 8b       	std	Z+17, r24	; 0x11
    5132:	92 8b       	std	Z+18, r25	; 0x12
    5134:	a3 8b       	std	Z+19, r26	; 0x13
    5136:	b4 8b       	std	Z+20, r27	; 0x14
    5138:	89 8d       	ldd	r24, Y+25	; 0x19
    513a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    513c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    513e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    5140:	85 8b       	std	Z+21, r24	; 0x15
    5142:	96 8b       	std	Z+22, r25	; 0x16
    5144:	a7 8b       	std	Z+23, r26	; 0x17
    5146:	b0 8f       	std	Z+24, r27	; 0x18
    5148:	8d 8d       	ldd	r24, Y+29	; 0x1d
    514a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    514c:	af 8d       	ldd	r26, Y+31	; 0x1f
    514e:	b8 a1       	ldd	r27, Y+32	; 0x20
    5150:	81 8f       	std	Z+25, r24	; 0x19
    5152:	92 8f       	std	Z+26, r25	; 0x1a
    5154:	a3 8f       	std	Z+27, r26	; 0x1b
    5156:	b4 8f       	std	Z+28, r27	; 0x1c
    5158:	89 a1       	ldd	r24, Y+33	; 0x21
    515a:	9a a1       	ldd	r25, Y+34	; 0x22
    515c:	ab a1       	ldd	r26, Y+35	; 0x23
    515e:	bc a1       	ldd	r27, Y+36	; 0x24
    5160:	85 8f       	std	Z+29, r24	; 0x1d
    5162:	96 8f       	std	Z+30, r25	; 0x1e
    5164:	a7 8f       	std	Z+31, r26	; 0x1f
    5166:	b0 a3       	std	Z+32, r27	; 0x20
    5168:	8d a1       	ldd	r24, Y+37	; 0x25
    516a:	9e a1       	ldd	r25, Y+38	; 0x26
    516c:	af a1       	ldd	r26, Y+39	; 0x27
    516e:	b8 a5       	ldd	r27, Y+40	; 0x28
    5170:	81 a3       	std	Z+33, r24	; 0x21
    5172:	92 a3       	std	Z+34, r25	; 0x22
    5174:	a3 a3       	std	Z+35, r26	; 0x23
    5176:	b4 a3       	std	Z+36, r27	; 0x24
    5178:	89 a5       	ldd	r24, Y+41	; 0x29
    517a:	9a a5       	ldd	r25, Y+42	; 0x2a
    517c:	ab a5       	ldd	r26, Y+43	; 0x2b
    517e:	bc a5       	ldd	r27, Y+44	; 0x2c
    5180:	85 a3       	std	Z+37, r24	; 0x25
    5182:	96 a3       	std	Z+38, r25	; 0x26
    5184:	a7 a3       	std	Z+39, r26	; 0x27
    5186:	b0 a7       	std	Z+40, r27	; 0x28
    5188:	8d a5       	ldd	r24, Y+45	; 0x2d
    518a:	9e a5       	ldd	r25, Y+46	; 0x2e
    518c:	af a5       	ldd	r26, Y+47	; 0x2f
    518e:	b8 a9       	ldd	r27, Y+48	; 0x30
    5190:	81 a7       	std	Z+41, r24	; 0x29
    5192:	92 a7       	std	Z+42, r25	; 0x2a
    5194:	a3 a7       	std	Z+43, r26	; 0x2b
    5196:	b4 a7       	std	Z+44, r27	; 0x2c
    5198:	89 a9       	ldd	r24, Y+49	; 0x31
    519a:	9a a9       	ldd	r25, Y+50	; 0x32
    519c:	ab a9       	ldd	r26, Y+51	; 0x33
    519e:	bc a9       	ldd	r27, Y+52	; 0x34
    51a0:	85 a7       	std	Z+45, r24	; 0x2d
    51a2:	96 a7       	std	Z+46, r25	; 0x2e
    51a4:	a7 a7       	std	Z+47, r26	; 0x2f
    51a6:	b0 ab       	std	Z+48, r27	; 0x30
    51a8:	8d a9       	ldd	r24, Y+53	; 0x35
    51aa:	9e a9       	ldd	r25, Y+54	; 0x36
    51ac:	af a9       	ldd	r26, Y+55	; 0x37
    51ae:	b8 ad       	ldd	r27, Y+56	; 0x38
    51b0:	81 ab       	std	Z+49, r24	; 0x31
    51b2:	92 ab       	std	Z+50, r25	; 0x32
    51b4:	a3 ab       	std	Z+51, r26	; 0x33
    51b6:	b4 ab       	std	Z+52, r27	; 0x34
    51b8:	89 ad       	ldd	r24, Y+57	; 0x39
    51ba:	9a ad       	ldd	r25, Y+58	; 0x3a
    51bc:	ab ad       	ldd	r26, Y+59	; 0x3b
    51be:	bc ad       	ldd	r27, Y+60	; 0x3c
    51c0:	85 ab       	std	Z+53, r24	; 0x35
    51c2:	96 ab       	std	Z+54, r25	; 0x36
    51c4:	a7 ab       	std	Z+55, r26	; 0x37
    51c6:	b0 af       	std	Z+56, r27	; 0x38
    51c8:	de 01       	movw	r26, r28
    51ca:	dd 96       	adiw	r26, 0x3d	; 61
    51cc:	8d 91       	ld	r24, X+
    51ce:	9d 91       	ld	r25, X+
    51d0:	0d 90       	ld	r0, X+
    51d2:	bc 91       	ld	r27, X
    51d4:	a0 2d       	mov	r26, r0
    51d6:	81 af       	std	Z+57, r24	; 0x39
    51d8:	92 af       	std	Z+58, r25	; 0x3a
    51da:	a3 af       	std	Z+59, r26	; 0x3b
    51dc:	b4 af       	std	Z+60, r27	; 0x3c
    51de:	9f 01       	movw	r18, r30
    51e0:	23 5c       	subi	r18, 0xC3	; 195
    51e2:	3f 4f       	sbci	r19, 0xFF	; 255
    51e4:	de 01       	movw	r26, r28
    51e6:	af 5b       	subi	r26, 0xBF	; 191
    51e8:	bf 4f       	sbci	r27, 0xFF	; 255
    51ea:	4d 91       	ld	r20, X+
    51ec:	5d 91       	ld	r21, X+
    51ee:	6d 91       	ld	r22, X+
    51f0:	7c 91       	ld	r23, X
    51f2:	d9 01       	movw	r26, r18
    51f4:	4d 93       	st	X+, r20
    51f6:	5d 93       	st	X+, r21
    51f8:	6d 93       	st	X+, r22
    51fa:	7c 93       	st	X, r23
    51fc:	13 97       	sbiw	r26, 0x03	; 3
    51fe:	9f 01       	movw	r18, r30
    5200:	2f 5b       	subi	r18, 0xBF	; 191
    5202:	3f 4f       	sbci	r19, 0xFF	; 255
    5204:	de 01       	movw	r26, r28
    5206:	ab 5b       	subi	r26, 0xBB	; 187
    5208:	bf 4f       	sbci	r27, 0xFF	; 255
    520a:	4d 91       	ld	r20, X+
    520c:	5d 91       	ld	r21, X+
    520e:	6d 91       	ld	r22, X+
    5210:	7c 91       	ld	r23, X
    5212:	d9 01       	movw	r26, r18
    5214:	4d 93       	st	X+, r20
    5216:	5d 93       	st	X+, r21
    5218:	6d 93       	st	X+, r22
    521a:	7c 93       	st	X, r23
    521c:	13 97       	sbiw	r26, 0x03	; 3
    521e:	9f 01       	movw	r18, r30
    5220:	2b 5b       	subi	r18, 0xBB	; 187
    5222:	3f 4f       	sbci	r19, 0xFF	; 255
    5224:	de 01       	movw	r26, r28
    5226:	a7 5b       	subi	r26, 0xB7	; 183
    5228:	bf 4f       	sbci	r27, 0xFF	; 255
    522a:	4d 91       	ld	r20, X+
    522c:	5d 91       	ld	r21, X+
    522e:	6d 91       	ld	r22, X+
    5230:	7c 91       	ld	r23, X
    5232:	d9 01       	movw	r26, r18
    5234:	4d 93       	st	X+, r20
    5236:	5d 93       	st	X+, r21
    5238:	6d 93       	st	X+, r22
    523a:	7c 93       	st	X, r23
    523c:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    523e:	9f 01       	movw	r18, r30
    5240:	27 5b       	subi	r18, 0xB7	; 183
    5242:	3f 4f       	sbci	r19, 0xFF	; 255
    5244:	de 01       	movw	r26, r28
    5246:	a3 5b       	subi	r26, 0xB3	; 179
    5248:	bf 4f       	sbci	r27, 0xFF	; 255
    524a:	4d 91       	ld	r20, X+
    524c:	5d 91       	ld	r21, X+
    524e:	6d 91       	ld	r22, X+
    5250:	7c 91       	ld	r23, X
    5252:	d9 01       	movw	r26, r18
    5254:	4d 93       	st	X+, r20
    5256:	5d 93       	st	X+, r21
    5258:	6d 93       	st	X+, r22
    525a:	7c 93       	st	X, r23
    525c:	13 97       	sbiw	r26, 0x03	; 3
    525e:	9f 01       	movw	r18, r30
    5260:	23 5b       	subi	r18, 0xB3	; 179
    5262:	3f 4f       	sbci	r19, 0xFF	; 255
    5264:	de 01       	movw	r26, r28
    5266:	af 5a       	subi	r26, 0xAF	; 175
    5268:	bf 4f       	sbci	r27, 0xFF	; 255
    526a:	4d 91       	ld	r20, X+
    526c:	5d 91       	ld	r21, X+
    526e:	6d 91       	ld	r22, X+
    5270:	7c 91       	ld	r23, X
    5272:	d9 01       	movw	r26, r18
    5274:	4d 93       	st	X+, r20
    5276:	5d 93       	st	X+, r21
    5278:	6d 93       	st	X+, r22
    527a:	7c 93       	st	X, r23
    527c:	13 97       	sbiw	r26, 0x03	; 3
    527e:	9f 01       	movw	r18, r30
    5280:	2f 5a       	subi	r18, 0xAF	; 175
    5282:	3f 4f       	sbci	r19, 0xFF	; 255
    5284:	de 01       	movw	r26, r28
    5286:	ab 5a       	subi	r26, 0xAB	; 171
    5288:	bf 4f       	sbci	r27, 0xFF	; 255
    528a:	4d 91       	ld	r20, X+
    528c:	5d 91       	ld	r21, X+
    528e:	6d 91       	ld	r22, X+
    5290:	7c 91       	ld	r23, X
    5292:	d9 01       	movw	r26, r18
    5294:	4d 93       	st	X+, r20
    5296:	5d 93       	st	X+, r21
    5298:	6d 93       	st	X+, r22
    529a:	7c 93       	st	X, r23
    529c:	13 97       	sbiw	r26, 0x03	; 3
    529e:	9f 01       	movw	r18, r30
    52a0:	2b 5a       	subi	r18, 0xAB	; 171
    52a2:	3f 4f       	sbci	r19, 0xFF	; 255
    52a4:	de 01       	movw	r26, r28
    52a6:	a7 5a       	subi	r26, 0xA7	; 167
    52a8:	bf 4f       	sbci	r27, 0xFF	; 255
    52aa:	4d 91       	ld	r20, X+
    52ac:	5d 91       	ld	r21, X+
    52ae:	6d 91       	ld	r22, X+
    52b0:	7c 91       	ld	r23, X
    52b2:	d9 01       	movw	r26, r18
    52b4:	4d 93       	st	X+, r20
    52b6:	5d 93       	st	X+, r21
    52b8:	6d 93       	st	X+, r22
    52ba:	7c 93       	st	X, r23
    52bc:	13 97       	sbiw	r26, 0x03	; 3
    52be:	9f 01       	movw	r18, r30
    52c0:	27 5a       	subi	r18, 0xA7	; 167
    52c2:	3f 4f       	sbci	r19, 0xFF	; 255
    52c4:	de 01       	movw	r26, r28
    52c6:	a3 5a       	subi	r26, 0xA3	; 163
    52c8:	bf 4f       	sbci	r27, 0xFF	; 255
    52ca:	4d 91       	ld	r20, X+
    52cc:	5d 91       	ld	r21, X+
    52ce:	6d 91       	ld	r22, X+
    52d0:	7c 91       	ld	r23, X
    52d2:	d9 01       	movw	r26, r18
    52d4:	4d 93       	st	X+, r20
    52d6:	5d 93       	st	X+, r21
    52d8:	6d 93       	st	X+, r22
    52da:	7c 93       	st	X, r23
    52dc:	13 97       	sbiw	r26, 0x03	; 3
    52de:	9f 01       	movw	r18, r30
    52e0:	23 5a       	subi	r18, 0xA3	; 163
    52e2:	3f 4f       	sbci	r19, 0xFF	; 255
    52e4:	de 01       	movw	r26, r28
    52e6:	af 59       	subi	r26, 0x9F	; 159
    52e8:	bf 4f       	sbci	r27, 0xFF	; 255
    52ea:	4d 91       	ld	r20, X+
    52ec:	5d 91       	ld	r21, X+
    52ee:	6d 91       	ld	r22, X+
    52f0:	7c 91       	ld	r23, X
    52f2:	d9 01       	movw	r26, r18
    52f4:	4d 93       	st	X+, r20
    52f6:	5d 93       	st	X+, r21
    52f8:	6d 93       	st	X+, r22
    52fa:	7c 93       	st	X, r23
    52fc:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    52fe:	9f 01       	movw	r18, r30
    5300:	2f 59       	subi	r18, 0x9F	; 159
    5302:	3f 4f       	sbci	r19, 0xFF	; 255
    5304:	de 01       	movw	r26, r28
    5306:	ab 59       	subi	r26, 0x9B	; 155
    5308:	bf 4f       	sbci	r27, 0xFF	; 255
    530a:	4d 91       	ld	r20, X+
    530c:	5d 91       	ld	r21, X+
    530e:	6d 91       	ld	r22, X+
    5310:	7c 91       	ld	r23, X
    5312:	d9 01       	movw	r26, r18
    5314:	4d 93       	st	X+, r20
    5316:	5d 93       	st	X+, r21
    5318:	6d 93       	st	X+, r22
    531a:	7c 93       	st	X, r23
    531c:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    531e:	9f 01       	movw	r18, r30
    5320:	2b 59       	subi	r18, 0x9B	; 155
    5322:	3f 4f       	sbci	r19, 0xFF	; 255
    5324:	de 01       	movw	r26, r28
    5326:	a7 59       	subi	r26, 0x97	; 151
    5328:	bf 4f       	sbci	r27, 0xFF	; 255
    532a:	4d 91       	ld	r20, X+
    532c:	5d 91       	ld	r21, X+
    532e:	6d 91       	ld	r22, X+
    5330:	7c 91       	ld	r23, X
    5332:	d9 01       	movw	r26, r18
    5334:	4d 93       	st	X+, r20
    5336:	5d 93       	st	X+, r21
    5338:	6d 93       	st	X+, r22
    533a:	7c 93       	st	X, r23
    533c:	13 97       	sbiw	r26, 0x03	; 3
    533e:	9f 01       	movw	r18, r30
    5340:	27 59       	subi	r18, 0x97	; 151
    5342:	3f 4f       	sbci	r19, 0xFF	; 255
    5344:	de 01       	movw	r26, r28
    5346:	a3 59       	subi	r26, 0x93	; 147
    5348:	bf 4f       	sbci	r27, 0xFF	; 255
    534a:	4d 91       	ld	r20, X+
    534c:	5d 91       	ld	r21, X+
    534e:	6d 91       	ld	r22, X+
    5350:	7c 91       	ld	r23, X
    5352:	d9 01       	movw	r26, r18
    5354:	4d 93       	st	X+, r20
    5356:	5d 93       	st	X+, r21
    5358:	6d 93       	st	X+, r22
    535a:	7c 93       	st	X, r23
    535c:	13 97       	sbiw	r26, 0x03	; 3
    535e:	9f 01       	movw	r18, r30
    5360:	23 59       	subi	r18, 0x93	; 147
    5362:	3f 4f       	sbci	r19, 0xFF	; 255
    5364:	ce 01       	movw	r24, r28
    5366:	8f 58       	subi	r24, 0x8F	; 143
    5368:	9f 4f       	sbci	r25, 0xFF	; 255
    536a:	dc 01       	movw	r26, r24
    536c:	4d 91       	ld	r20, X+
    536e:	5d 91       	ld	r21, X+
    5370:	6d 91       	ld	r22, X+
    5372:	7c 91       	ld	r23, X
    5374:	d9 01       	movw	r26, r18
    5376:	4d 93       	st	X+, r20
    5378:	5d 93       	st	X+, r21
    537a:	6d 93       	st	X+, r22
    537c:	7c 93       	st	X, r23
    537e:	13 97       	sbiw	r26, 0x03	; 3
    5380:	9f 01       	movw	r18, r30
    5382:	2f 58       	subi	r18, 0x8F	; 143
    5384:	3f 4f       	sbci	r19, 0xFF	; 255
    5386:	ce 01       	movw	r24, r28
    5388:	8b 58       	subi	r24, 0x8B	; 139
    538a:	9f 4f       	sbci	r25, 0xFF	; 255
    538c:	dc 01       	movw	r26, r24
    538e:	4d 91       	ld	r20, X+
    5390:	5d 91       	ld	r21, X+
    5392:	6d 91       	ld	r22, X+
    5394:	7c 91       	ld	r23, X
    5396:	d9 01       	movw	r26, r18
    5398:	4d 93       	st	X+, r20
    539a:	5d 93       	st	X+, r21
    539c:	6d 93       	st	X+, r22
    539e:	7c 93       	st	X, r23
    53a0:	13 97       	sbiw	r26, 0x03	; 3
    53a2:	df 01       	movw	r26, r30
    53a4:	ab 58       	subi	r26, 0x8B	; 139
    53a6:	bf 4f       	sbci	r27, 0xFF	; 255
    53a8:	c7 58       	subi	r28, 0x87	; 135
    53aa:	df 4f       	sbci	r29, 0xFF	; 255
    53ac:	48 81       	ld	r20, Y
    53ae:	59 81       	ldd	r21, Y+1	; 0x01
    53b0:	6a 81       	ldd	r22, Y+2	; 0x02
    53b2:	7b 81       	ldd	r23, Y+3	; 0x03
    53b4:	4d 93       	st	X+, r20
    53b6:	5d 93       	st	X+, r21
    53b8:	6d 93       	st	X+, r22
    53ba:	7c 93       	st	X, r23
    53bc:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
	
	return msg;
}
    53be:	8e 2f       	mov	r24, r30
    53c0:	9f 2f       	mov	r25, r31
    53c2:	df 91       	pop	r29
    53c4:	cf 91       	pop	r28
    53c6:	08 95       	ret

000053c8 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>:

void SimpleTelemetryMessage::buildMessage(byte *message)
{
    53c8:	cf 93       	push	r28
    53ca:	df 93       	push	r29
    53cc:	fc 01       	movw	r30, r24
    53ce:	db 01       	movw	r26, r22
	if (message != NULL)
    53d0:	10 97       	sbiw	r26, 0x00	; 0
    53d2:	09 f4       	brne	.+2      	; 0x53d6 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0xe>
    53d4:	85 c1       	rjmp	.+778    	; 0x56e0 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh+0x318>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    53d6:	8c 91       	ld	r24, X
    53d8:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    53da:	11 96       	adiw	r26, 0x01	; 1
    53dc:	4d 91       	ld	r20, X+
    53de:	5d 91       	ld	r21, X+
    53e0:	6d 91       	ld	r22, X+
    53e2:	7c 91       	ld	r23, X
    53e4:	14 97       	sbiw	r26, 0x04	; 4
    53e6:	45 83       	std	Z+5, r20	; 0x05
    53e8:	56 83       	std	Z+6, r21	; 0x06
    53ea:	67 83       	std	Z+7, r22	; 0x07
    53ec:	70 87       	std	Z+8, r23	; 0x08
    53ee:	15 96       	adiw	r26, 0x05	; 5
    53f0:	4d 91       	ld	r20, X+
    53f2:	5d 91       	ld	r21, X+
    53f4:	6d 91       	ld	r22, X+
    53f6:	7c 91       	ld	r23, X
    53f8:	18 97       	sbiw	r26, 0x08	; 8
    53fa:	41 87       	std	Z+9, r20	; 0x09
    53fc:	52 87       	std	Z+10, r21	; 0x0a
    53fe:	63 87       	std	Z+11, r22	; 0x0b
    5400:	74 87       	std	Z+12, r23	; 0x0c
    5402:	19 96       	adiw	r26, 0x09	; 9
    5404:	4d 91       	ld	r20, X+
    5406:	5d 91       	ld	r21, X+
    5408:	6d 91       	ld	r22, X+
    540a:	7c 91       	ld	r23, X
    540c:	1c 97       	sbiw	r26, 0x0c	; 12
    540e:	45 87       	std	Z+13, r20	; 0x0d
    5410:	56 87       	std	Z+14, r21	; 0x0e
    5412:	67 87       	std	Z+15, r22	; 0x0f
    5414:	70 8b       	std	Z+16, r23	; 0x10
    5416:	1d 96       	adiw	r26, 0x0d	; 13
    5418:	4d 91       	ld	r20, X+
    541a:	5d 91       	ld	r21, X+
    541c:	6d 91       	ld	r22, X+
    541e:	7c 91       	ld	r23, X
    5420:	50 97       	sbiw	r26, 0x10	; 16
    5422:	41 8b       	std	Z+17, r20	; 0x11
    5424:	52 8b       	std	Z+18, r21	; 0x12
    5426:	63 8b       	std	Z+19, r22	; 0x13
    5428:	74 8b       	std	Z+20, r23	; 0x14
    542a:	51 96       	adiw	r26, 0x11	; 17
    542c:	4d 91       	ld	r20, X+
    542e:	5d 91       	ld	r21, X+
    5430:	6d 91       	ld	r22, X+
    5432:	7c 91       	ld	r23, X
    5434:	54 97       	sbiw	r26, 0x14	; 20
    5436:	45 8b       	std	Z+21, r20	; 0x15
    5438:	56 8b       	std	Z+22, r21	; 0x16
    543a:	67 8b       	std	Z+23, r22	; 0x17
    543c:	70 8f       	std	Z+24, r23	; 0x18
    543e:	55 96       	adiw	r26, 0x15	; 21
    5440:	4d 91       	ld	r20, X+
    5442:	5d 91       	ld	r21, X+
    5444:	6d 91       	ld	r22, X+
    5446:	7c 91       	ld	r23, X
    5448:	58 97       	sbiw	r26, 0x18	; 24
    544a:	41 8f       	std	Z+25, r20	; 0x19
    544c:	52 8f       	std	Z+26, r21	; 0x1a
    544e:	63 8f       	std	Z+27, r22	; 0x1b
    5450:	74 8f       	std	Z+28, r23	; 0x1c
    5452:	59 96       	adiw	r26, 0x19	; 25
    5454:	4d 91       	ld	r20, X+
    5456:	5d 91       	ld	r21, X+
    5458:	6d 91       	ld	r22, X+
    545a:	7c 91       	ld	r23, X
    545c:	5c 97       	sbiw	r26, 0x1c	; 28
    545e:	45 8f       	std	Z+29, r20	; 0x1d
    5460:	56 8f       	std	Z+30, r21	; 0x1e
    5462:	67 8f       	std	Z+31, r22	; 0x1f
    5464:	70 a3       	std	Z+32, r23	; 0x20
    5466:	5d 96       	adiw	r26, 0x1d	; 29
    5468:	4d 91       	ld	r20, X+
    546a:	5d 91       	ld	r21, X+
    546c:	6d 91       	ld	r22, X+
    546e:	7c 91       	ld	r23, X
    5470:	90 97       	sbiw	r26, 0x20	; 32
    5472:	41 a3       	std	Z+33, r20	; 0x21
    5474:	52 a3       	std	Z+34, r21	; 0x22
    5476:	63 a3       	std	Z+35, r22	; 0x23
    5478:	74 a3       	std	Z+36, r23	; 0x24
    547a:	91 96       	adiw	r26, 0x21	; 33
    547c:	4d 91       	ld	r20, X+
    547e:	5d 91       	ld	r21, X+
    5480:	6d 91       	ld	r22, X+
    5482:	7c 91       	ld	r23, X
    5484:	94 97       	sbiw	r26, 0x24	; 36
    5486:	45 a3       	std	Z+37, r20	; 0x25
    5488:	56 a3       	std	Z+38, r21	; 0x26
    548a:	67 a3       	std	Z+39, r22	; 0x27
    548c:	70 a7       	std	Z+40, r23	; 0x28
    548e:	95 96       	adiw	r26, 0x25	; 37
    5490:	4d 91       	ld	r20, X+
    5492:	5d 91       	ld	r21, X+
    5494:	6d 91       	ld	r22, X+
    5496:	7c 91       	ld	r23, X
    5498:	98 97       	sbiw	r26, 0x28	; 40
    549a:	41 a7       	std	Z+41, r20	; 0x29
    549c:	52 a7       	std	Z+42, r21	; 0x2a
    549e:	63 a7       	std	Z+43, r22	; 0x2b
    54a0:	74 a7       	std	Z+44, r23	; 0x2c
    54a2:	99 96       	adiw	r26, 0x29	; 41
    54a4:	4d 91       	ld	r20, X+
    54a6:	5d 91       	ld	r21, X+
    54a8:	6d 91       	ld	r22, X+
    54aa:	7c 91       	ld	r23, X
    54ac:	9c 97       	sbiw	r26, 0x2c	; 44
    54ae:	45 a7       	std	Z+45, r20	; 0x2d
    54b0:	56 a7       	std	Z+46, r21	; 0x2e
    54b2:	67 a7       	std	Z+47, r22	; 0x2f
    54b4:	70 ab       	std	Z+48, r23	; 0x30
    54b6:	9d 96       	adiw	r26, 0x2d	; 45
    54b8:	4d 91       	ld	r20, X+
    54ba:	5d 91       	ld	r21, X+
    54bc:	6d 91       	ld	r22, X+
    54be:	7c 91       	ld	r23, X
    54c0:	d0 97       	sbiw	r26, 0x30	; 48
    54c2:	41 ab       	std	Z+49, r20	; 0x31
    54c4:	52 ab       	std	Z+50, r21	; 0x32
    54c6:	63 ab       	std	Z+51, r22	; 0x33
    54c8:	74 ab       	std	Z+52, r23	; 0x34
    54ca:	d1 96       	adiw	r26, 0x31	; 49
    54cc:	4d 91       	ld	r20, X+
    54ce:	5d 91       	ld	r21, X+
    54d0:	6d 91       	ld	r22, X+
    54d2:	7c 91       	ld	r23, X
    54d4:	d4 97       	sbiw	r26, 0x34	; 52
    54d6:	45 ab       	std	Z+53, r20	; 0x35
    54d8:	56 ab       	std	Z+54, r21	; 0x36
    54da:	67 ab       	std	Z+55, r22	; 0x37
    54dc:	70 af       	std	Z+56, r23	; 0x38
    54de:	d5 96       	adiw	r26, 0x35	; 53
    54e0:	4d 91       	ld	r20, X+
    54e2:	5d 91       	ld	r21, X+
    54e4:	6d 91       	ld	r22, X+
    54e6:	7c 91       	ld	r23, X
    54e8:	d8 97       	sbiw	r26, 0x38	; 56
    54ea:	41 af       	std	Z+57, r20	; 0x39
    54ec:	52 af       	std	Z+58, r21	; 0x3a
    54ee:	63 af       	std	Z+59, r22	; 0x3b
    54f0:	74 af       	std	Z+60, r23	; 0x3c
    54f2:	ef 01       	movw	r28, r30
    54f4:	ed 96       	adiw	r28, 0x3d	; 61
    54f6:	d9 96       	adiw	r26, 0x39	; 57
    54f8:	4d 91       	ld	r20, X+
    54fa:	5d 91       	ld	r21, X+
    54fc:	6d 91       	ld	r22, X+
    54fe:	7c 91       	ld	r23, X
    5500:	dc 97       	sbiw	r26, 0x3c	; 60
    5502:	48 83       	st	Y, r20
    5504:	59 83       	std	Y+1, r21	; 0x01
    5506:	6a 83       	std	Y+2, r22	; 0x02
    5508:	7b 83       	std	Y+3, r23	; 0x03
    550a:	9f 01       	movw	r18, r30
    550c:	2f 5b       	subi	r18, 0xBF	; 191
    550e:	3f 4f       	sbci	r19, 0xFF	; 255
    5510:	cd 01       	movw	r24, r26
    5512:	cd 96       	adiw	r24, 0x3d	; 61
    5514:	ec 01       	movw	r28, r24
    5516:	48 81       	ld	r20, Y
    5518:	59 81       	ldd	r21, Y+1	; 0x01
    551a:	6a 81       	ldd	r22, Y+2	; 0x02
    551c:	7b 81       	ldd	r23, Y+3	; 0x03
    551e:	e9 01       	movw	r28, r18
    5520:	48 83       	st	Y, r20
    5522:	59 83       	std	Y+1, r21	; 0x01
    5524:	6a 83       	std	Y+2, r22	; 0x02
    5526:	7b 83       	std	Y+3, r23	; 0x03
    5528:	9f 01       	movw	r18, r30
    552a:	2b 5b       	subi	r18, 0xBB	; 187
    552c:	3f 4f       	sbci	r19, 0xFF	; 255
    552e:	cd 01       	movw	r24, r26
    5530:	8f 5b       	subi	r24, 0xBF	; 191
    5532:	9f 4f       	sbci	r25, 0xFF	; 255
    5534:	ec 01       	movw	r28, r24
    5536:	48 81       	ld	r20, Y
    5538:	59 81       	ldd	r21, Y+1	; 0x01
    553a:	6a 81       	ldd	r22, Y+2	; 0x02
    553c:	7b 81       	ldd	r23, Y+3	; 0x03
    553e:	e9 01       	movw	r28, r18
    5540:	48 83       	st	Y, r20
    5542:	59 83       	std	Y+1, r21	; 0x01
    5544:	6a 83       	std	Y+2, r22	; 0x02
    5546:	7b 83       	std	Y+3, r23	; 0x03
    5548:	9f 01       	movw	r18, r30
    554a:	27 5b       	subi	r18, 0xB7	; 183
    554c:	3f 4f       	sbci	r19, 0xFF	; 255
    554e:	cd 01       	movw	r24, r26
    5550:	8b 5b       	subi	r24, 0xBB	; 187
    5552:	9f 4f       	sbci	r25, 0xFF	; 255
    5554:	ec 01       	movw	r28, r24
    5556:	48 81       	ld	r20, Y
    5558:	59 81       	ldd	r21, Y+1	; 0x01
    555a:	6a 81       	ldd	r22, Y+2	; 0x02
    555c:	7b 81       	ldd	r23, Y+3	; 0x03
    555e:	e9 01       	movw	r28, r18
    5560:	48 83       	st	Y, r20
    5562:	59 83       	std	Y+1, r21	; 0x01
    5564:	6a 83       	std	Y+2, r22	; 0x02
    5566:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5568:	9f 01       	movw	r18, r30
    556a:	23 5b       	subi	r18, 0xB3	; 179
    556c:	3f 4f       	sbci	r19, 0xFF	; 255
    556e:	cd 01       	movw	r24, r26
    5570:	87 5b       	subi	r24, 0xB7	; 183
    5572:	9f 4f       	sbci	r25, 0xFF	; 255
    5574:	ec 01       	movw	r28, r24
    5576:	48 81       	ld	r20, Y
    5578:	59 81       	ldd	r21, Y+1	; 0x01
    557a:	6a 81       	ldd	r22, Y+2	; 0x02
    557c:	7b 81       	ldd	r23, Y+3	; 0x03
    557e:	e9 01       	movw	r28, r18
    5580:	48 83       	st	Y, r20
    5582:	59 83       	std	Y+1, r21	; 0x01
    5584:	6a 83       	std	Y+2, r22	; 0x02
    5586:	7b 83       	std	Y+3, r23	; 0x03
    5588:	9f 01       	movw	r18, r30
    558a:	2f 5a       	subi	r18, 0xAF	; 175
    558c:	3f 4f       	sbci	r19, 0xFF	; 255
    558e:	cd 01       	movw	r24, r26
    5590:	83 5b       	subi	r24, 0xB3	; 179
    5592:	9f 4f       	sbci	r25, 0xFF	; 255
    5594:	ec 01       	movw	r28, r24
    5596:	48 81       	ld	r20, Y
    5598:	59 81       	ldd	r21, Y+1	; 0x01
    559a:	6a 81       	ldd	r22, Y+2	; 0x02
    559c:	7b 81       	ldd	r23, Y+3	; 0x03
    559e:	e9 01       	movw	r28, r18
    55a0:	48 83       	st	Y, r20
    55a2:	59 83       	std	Y+1, r21	; 0x01
    55a4:	6a 83       	std	Y+2, r22	; 0x02
    55a6:	7b 83       	std	Y+3, r23	; 0x03
    55a8:	9f 01       	movw	r18, r30
    55aa:	2b 5a       	subi	r18, 0xAB	; 171
    55ac:	3f 4f       	sbci	r19, 0xFF	; 255
    55ae:	cd 01       	movw	r24, r26
    55b0:	8f 5a       	subi	r24, 0xAF	; 175
    55b2:	9f 4f       	sbci	r25, 0xFF	; 255
    55b4:	ec 01       	movw	r28, r24
    55b6:	48 81       	ld	r20, Y
    55b8:	59 81       	ldd	r21, Y+1	; 0x01
    55ba:	6a 81       	ldd	r22, Y+2	; 0x02
    55bc:	7b 81       	ldd	r23, Y+3	; 0x03
    55be:	e9 01       	movw	r28, r18
    55c0:	48 83       	st	Y, r20
    55c2:	59 83       	std	Y+1, r21	; 0x01
    55c4:	6a 83       	std	Y+2, r22	; 0x02
    55c6:	7b 83       	std	Y+3, r23	; 0x03
    55c8:	9f 01       	movw	r18, r30
    55ca:	27 5a       	subi	r18, 0xA7	; 167
    55cc:	3f 4f       	sbci	r19, 0xFF	; 255
    55ce:	cd 01       	movw	r24, r26
    55d0:	8b 5a       	subi	r24, 0xAB	; 171
    55d2:	9f 4f       	sbci	r25, 0xFF	; 255
    55d4:	ec 01       	movw	r28, r24
    55d6:	48 81       	ld	r20, Y
    55d8:	59 81       	ldd	r21, Y+1	; 0x01
    55da:	6a 81       	ldd	r22, Y+2	; 0x02
    55dc:	7b 81       	ldd	r23, Y+3	; 0x03
    55de:	e9 01       	movw	r28, r18
    55e0:	48 83       	st	Y, r20
    55e2:	59 83       	std	Y+1, r21	; 0x01
    55e4:	6a 83       	std	Y+2, r22	; 0x02
    55e6:	7b 83       	std	Y+3, r23	; 0x03
    55e8:	9f 01       	movw	r18, r30
    55ea:	23 5a       	subi	r18, 0xA3	; 163
    55ec:	3f 4f       	sbci	r19, 0xFF	; 255
    55ee:	cd 01       	movw	r24, r26
    55f0:	87 5a       	subi	r24, 0xA7	; 167
    55f2:	9f 4f       	sbci	r25, 0xFF	; 255
    55f4:	ec 01       	movw	r28, r24
    55f6:	48 81       	ld	r20, Y
    55f8:	59 81       	ldd	r21, Y+1	; 0x01
    55fa:	6a 81       	ldd	r22, Y+2	; 0x02
    55fc:	7b 81       	ldd	r23, Y+3	; 0x03
    55fe:	e9 01       	movw	r28, r18
    5600:	48 83       	st	Y, r20
    5602:	59 83       	std	Y+1, r21	; 0x01
    5604:	6a 83       	std	Y+2, r22	; 0x02
    5606:	7b 83       	std	Y+3, r23	; 0x03
    5608:	9f 01       	movw	r18, r30
    560a:	2f 59       	subi	r18, 0x9F	; 159
    560c:	3f 4f       	sbci	r19, 0xFF	; 255
    560e:	cd 01       	movw	r24, r26
    5610:	83 5a       	subi	r24, 0xA3	; 163
    5612:	9f 4f       	sbci	r25, 0xFF	; 255
    5614:	ec 01       	movw	r28, r24
    5616:	48 81       	ld	r20, Y
    5618:	59 81       	ldd	r21, Y+1	; 0x01
    561a:	6a 81       	ldd	r22, Y+2	; 0x02
    561c:	7b 81       	ldd	r23, Y+3	; 0x03
    561e:	e9 01       	movw	r28, r18
    5620:	48 83       	st	Y, r20
    5622:	59 83       	std	Y+1, r21	; 0x01
    5624:	6a 83       	std	Y+2, r22	; 0x02
    5626:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5628:	9f 01       	movw	r18, r30
    562a:	2b 59       	subi	r18, 0x9B	; 155
    562c:	3f 4f       	sbci	r19, 0xFF	; 255
    562e:	cd 01       	movw	r24, r26
    5630:	8f 59       	subi	r24, 0x9F	; 159
    5632:	9f 4f       	sbci	r25, 0xFF	; 255
    5634:	ec 01       	movw	r28, r24
    5636:	48 81       	ld	r20, Y
    5638:	59 81       	ldd	r21, Y+1	; 0x01
    563a:	6a 81       	ldd	r22, Y+2	; 0x02
    563c:	7b 81       	ldd	r23, Y+3	; 0x03
    563e:	e9 01       	movw	r28, r18
    5640:	48 83       	st	Y, r20
    5642:	59 83       	std	Y+1, r21	; 0x01
    5644:	6a 83       	std	Y+2, r22	; 0x02
    5646:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    5648:	9f 01       	movw	r18, r30
    564a:	27 59       	subi	r18, 0x97	; 151
    564c:	3f 4f       	sbci	r19, 0xFF	; 255
    564e:	cd 01       	movw	r24, r26
    5650:	8b 59       	subi	r24, 0x9B	; 155
    5652:	9f 4f       	sbci	r25, 0xFF	; 255
    5654:	ec 01       	movw	r28, r24
    5656:	48 81       	ld	r20, Y
    5658:	59 81       	ldd	r21, Y+1	; 0x01
    565a:	6a 81       	ldd	r22, Y+2	; 0x02
    565c:	7b 81       	ldd	r23, Y+3	; 0x03
    565e:	e9 01       	movw	r28, r18
    5660:	48 83       	st	Y, r20
    5662:	59 83       	std	Y+1, r21	; 0x01
    5664:	6a 83       	std	Y+2, r22	; 0x02
    5666:	7b 83       	std	Y+3, r23	; 0x03
    5668:	9f 01       	movw	r18, r30
    566a:	23 59       	subi	r18, 0x93	; 147
    566c:	3f 4f       	sbci	r19, 0xFF	; 255
    566e:	cd 01       	movw	r24, r26
    5670:	87 59       	subi	r24, 0x97	; 151
    5672:	9f 4f       	sbci	r25, 0xFF	; 255
    5674:	ec 01       	movw	r28, r24
    5676:	48 81       	ld	r20, Y
    5678:	59 81       	ldd	r21, Y+1	; 0x01
    567a:	6a 81       	ldd	r22, Y+2	; 0x02
    567c:	7b 81       	ldd	r23, Y+3	; 0x03
    567e:	e9 01       	movw	r28, r18
    5680:	48 83       	st	Y, r20
    5682:	59 83       	std	Y+1, r21	; 0x01
    5684:	6a 83       	std	Y+2, r22	; 0x02
    5686:	7b 83       	std	Y+3, r23	; 0x03
    5688:	9f 01       	movw	r18, r30
    568a:	2f 58       	subi	r18, 0x8F	; 143
    568c:	3f 4f       	sbci	r19, 0xFF	; 255
    568e:	cd 01       	movw	r24, r26
    5690:	83 59       	subi	r24, 0x93	; 147
    5692:	9f 4f       	sbci	r25, 0xFF	; 255
    5694:	ec 01       	movw	r28, r24
    5696:	48 81       	ld	r20, Y
    5698:	59 81       	ldd	r21, Y+1	; 0x01
    569a:	6a 81       	ldd	r22, Y+2	; 0x02
    569c:	7b 81       	ldd	r23, Y+3	; 0x03
    569e:	e9 01       	movw	r28, r18
    56a0:	48 83       	st	Y, r20
    56a2:	59 83       	std	Y+1, r21	; 0x01
    56a4:	6a 83       	std	Y+2, r22	; 0x02
    56a6:	7b 83       	std	Y+3, r23	; 0x03
    56a8:	9f 01       	movw	r18, r30
    56aa:	2b 58       	subi	r18, 0x8B	; 139
    56ac:	3f 4f       	sbci	r19, 0xFF	; 255
    56ae:	cd 01       	movw	r24, r26
    56b0:	8f 58       	subi	r24, 0x8F	; 143
    56b2:	9f 4f       	sbci	r25, 0xFF	; 255
    56b4:	ec 01       	movw	r28, r24
    56b6:	48 81       	ld	r20, Y
    56b8:	59 81       	ldd	r21, Y+1	; 0x01
    56ba:	6a 81       	ldd	r22, Y+2	; 0x02
    56bc:	7b 81       	ldd	r23, Y+3	; 0x03
    56be:	e9 01       	movw	r28, r18
    56c0:	48 83       	st	Y, r20
    56c2:	59 83       	std	Y+1, r21	; 0x01
    56c4:	6a 83       	std	Y+2, r22	; 0x02
    56c6:	7b 83       	std	Y+3, r23	; 0x03
    56c8:	e7 58       	subi	r30, 0x87	; 135
    56ca:	ff 4f       	sbci	r31, 0xFF	; 255
    56cc:	ab 58       	subi	r26, 0x8B	; 139
    56ce:	bf 4f       	sbci	r27, 0xFF	; 255
    56d0:	4d 91       	ld	r20, X+
    56d2:	5d 91       	ld	r21, X+
    56d4:	6d 91       	ld	r22, X+
    56d6:	7c 91       	ld	r23, X
    56d8:	40 83       	st	Z, r20
    56da:	51 83       	std	Z+1, r21	; 0x01
    56dc:	62 83       	std	Z+2, r22	; 0x02
    56de:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    56e0:	df 91       	pop	r29
    56e2:	cf 91       	pop	r28
    56e4:	08 95       	ret

000056e6 <_ZN10helicopter8messages22SimpleTelemetryMessage14buildMessageStEPh>:

SimpleTelemetryMessage* SimpleTelemetryMessage::buildMessageSt(byte *message)
{
    56e6:	0f 93       	push	r16
    56e8:	1f 93       	push	r17
    56ea:	cf 93       	push	r28
    56ec:	df 93       	push	r29
    56ee:	8c 01       	movw	r16, r24
	SimpleTelemetryMessage *msg = new SimpleTelemetryMessage();
    56f0:	8d e7       	ldi	r24, 0x7D	; 125
    56f2:	90 e0       	ldi	r25, 0x00	; 0
    56f4:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    56f8:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    56fa:	86 e0       	ldi	r24, 0x06	; 6
    56fc:	8a 83       	std	Y+2, r24	; 0x02
    56fe:	89 e7       	ldi	r24, 0x79	; 121
    5700:	90 e0       	ldi	r25, 0x00	; 0
    5702:	9c 83       	std	Y+4, r25	; 0x04
    5704:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    5706:	88 e6       	ldi	r24, 0x68	; 104
    5708:	92 e0       	ldi	r25, 0x02	; 2
    570a:	99 83       	std	Y+1, r25	; 0x01
    570c:	88 83       	st	Y, r24
    570e:	1d 82       	std	Y+5, r1	; 0x05
    5710:	1e 82       	std	Y+6, r1	; 0x06
    5712:	1f 82       	std	Y+7, r1	; 0x07
    5714:	18 86       	std	Y+8, r1	; 0x08
    5716:	19 86       	std	Y+9, r1	; 0x09
    5718:	1a 86       	std	Y+10, r1	; 0x0a
    571a:	1b 86       	std	Y+11, r1	; 0x0b
    571c:	1c 86       	std	Y+12, r1	; 0x0c
    571e:	1d 86       	std	Y+13, r1	; 0x0d
    5720:	1e 86       	std	Y+14, r1	; 0x0e
    5722:	1f 86       	std	Y+15, r1	; 0x0f
    5724:	18 8a       	std	Y+16, r1	; 0x10
    5726:	19 8a       	std	Y+17, r1	; 0x11
    5728:	1a 8a       	std	Y+18, r1	; 0x12
    572a:	1b 8a       	std	Y+19, r1	; 0x13
    572c:	1c 8a       	std	Y+20, r1	; 0x14
    572e:	1d 8a       	std	Y+21, r1	; 0x15
    5730:	1e 8a       	std	Y+22, r1	; 0x16
    5732:	1f 8a       	std	Y+23, r1	; 0x17
    5734:	18 8e       	std	Y+24, r1	; 0x18
    5736:	19 8e       	std	Y+25, r1	; 0x19
    5738:	1a 8e       	std	Y+26, r1	; 0x1a
    573a:	1b 8e       	std	Y+27, r1	; 0x1b
    573c:	1c 8e       	std	Y+28, r1	; 0x1c
    573e:	1d 8e       	std	Y+29, r1	; 0x1d
    5740:	1e 8e       	std	Y+30, r1	; 0x1e
    5742:	1f 8e       	std	Y+31, r1	; 0x1f
    5744:	18 a2       	std	Y+32, r1	; 0x20
    5746:	19 a2       	std	Y+33, r1	; 0x21
    5748:	1a a2       	std	Y+34, r1	; 0x22
    574a:	1b a2       	std	Y+35, r1	; 0x23
    574c:	1c a2       	std	Y+36, r1	; 0x24
    574e:	1d a2       	std	Y+37, r1	; 0x25
    5750:	1e a2       	std	Y+38, r1	; 0x26
    5752:	1f a2       	std	Y+39, r1	; 0x27
    5754:	18 a6       	std	Y+40, r1	; 0x28
    5756:	19 a6       	std	Y+41, r1	; 0x29
    5758:	1a a6       	std	Y+42, r1	; 0x2a
    575a:	1b a6       	std	Y+43, r1	; 0x2b
    575c:	1c a6       	std	Y+44, r1	; 0x2c
    575e:	1d a6       	std	Y+45, r1	; 0x2d
    5760:	1e a6       	std	Y+46, r1	; 0x2e
    5762:	1f a6       	std	Y+47, r1	; 0x2f
    5764:	18 aa       	std	Y+48, r1	; 0x30
    5766:	19 aa       	std	Y+49, r1	; 0x31
    5768:	1a aa       	std	Y+50, r1	; 0x32
    576a:	1b aa       	std	Y+51, r1	; 0x33
    576c:	1c aa       	std	Y+52, r1	; 0x34
    576e:	1d aa       	std	Y+53, r1	; 0x35
    5770:	1e aa       	std	Y+54, r1	; 0x36
    5772:	1f aa       	std	Y+55, r1	; 0x37
    5774:	18 ae       	std	Y+56, r1	; 0x38
    5776:	19 ae       	std	Y+57, r1	; 0x39
    5778:	1a ae       	std	Y+58, r1	; 0x3a
    577a:	1b ae       	std	Y+59, r1	; 0x3b
    577c:	1c ae       	std	Y+60, r1	; 0x3c
    577e:	fe 01       	movw	r30, r28
    5780:	fd 96       	adiw	r30, 0x3d	; 61
    5782:	10 82       	st	Z, r1
    5784:	11 82       	std	Z+1, r1	; 0x01
    5786:	12 82       	std	Z+2, r1	; 0x02
    5788:	13 82       	std	Z+3, r1	; 0x03
    578a:	fe 01       	movw	r30, r28
    578c:	ef 5b       	subi	r30, 0xBF	; 191
    578e:	ff 4f       	sbci	r31, 0xFF	; 255
    5790:	10 82       	st	Z, r1
    5792:	11 82       	std	Z+1, r1	; 0x01
    5794:	12 82       	std	Z+2, r1	; 0x02
    5796:	13 82       	std	Z+3, r1	; 0x03
    5798:	fe 01       	movw	r30, r28
    579a:	eb 5b       	subi	r30, 0xBB	; 187
    579c:	ff 4f       	sbci	r31, 0xFF	; 255
    579e:	10 82       	st	Z, r1
    57a0:	11 82       	std	Z+1, r1	; 0x01
    57a2:	12 82       	std	Z+2, r1	; 0x02
    57a4:	13 82       	std	Z+3, r1	; 0x03
    57a6:	fe 01       	movw	r30, r28
    57a8:	e7 5b       	subi	r30, 0xB7	; 183
    57aa:	ff 4f       	sbci	r31, 0xFF	; 255
    57ac:	10 82       	st	Z, r1
    57ae:	11 82       	std	Z+1, r1	; 0x01
    57b0:	12 82       	std	Z+2, r1	; 0x02
    57b2:	13 82       	std	Z+3, r1	; 0x03
    57b4:	fe 01       	movw	r30, r28
    57b6:	e3 5b       	subi	r30, 0xB3	; 179
    57b8:	ff 4f       	sbci	r31, 0xFF	; 255
    57ba:	10 82       	st	Z, r1
    57bc:	11 82       	std	Z+1, r1	; 0x01
    57be:	12 82       	std	Z+2, r1	; 0x02
    57c0:	13 82       	std	Z+3, r1	; 0x03
    57c2:	fe 01       	movw	r30, r28
    57c4:	ef 5a       	subi	r30, 0xAF	; 175
    57c6:	ff 4f       	sbci	r31, 0xFF	; 255
    57c8:	10 82       	st	Z, r1
    57ca:	11 82       	std	Z+1, r1	; 0x01
    57cc:	12 82       	std	Z+2, r1	; 0x02
    57ce:	13 82       	std	Z+3, r1	; 0x03
    57d0:	fe 01       	movw	r30, r28
    57d2:	eb 5a       	subi	r30, 0xAB	; 171
    57d4:	ff 4f       	sbci	r31, 0xFF	; 255
    57d6:	10 82       	st	Z, r1
    57d8:	11 82       	std	Z+1, r1	; 0x01
    57da:	12 82       	std	Z+2, r1	; 0x02
    57dc:	13 82       	std	Z+3, r1	; 0x03
    57de:	fe 01       	movw	r30, r28
    57e0:	e7 5a       	subi	r30, 0xA7	; 167
    57e2:	ff 4f       	sbci	r31, 0xFF	; 255
    57e4:	10 82       	st	Z, r1
    57e6:	11 82       	std	Z+1, r1	; 0x01
    57e8:	12 82       	std	Z+2, r1	; 0x02
    57ea:	13 82       	std	Z+3, r1	; 0x03
    57ec:	fe 01       	movw	r30, r28
    57ee:	e3 5a       	subi	r30, 0xA3	; 163
    57f0:	ff 4f       	sbci	r31, 0xFF	; 255
    57f2:	10 82       	st	Z, r1
    57f4:	11 82       	std	Z+1, r1	; 0x01
    57f6:	12 82       	std	Z+2, r1	; 0x02
    57f8:	13 82       	std	Z+3, r1	; 0x03
    57fa:	fe 01       	movw	r30, r28
    57fc:	ef 59       	subi	r30, 0x9F	; 159
    57fe:	ff 4f       	sbci	r31, 0xFF	; 255
    5800:	10 82       	st	Z, r1
    5802:	11 82       	std	Z+1, r1	; 0x01
    5804:	12 82       	std	Z+2, r1	; 0x02
    5806:	13 82       	std	Z+3, r1	; 0x03
    5808:	fe 01       	movw	r30, r28
    580a:	eb 59       	subi	r30, 0x9B	; 155
    580c:	ff 4f       	sbci	r31, 0xFF	; 255
    580e:	10 82       	st	Z, r1
    5810:	11 82       	std	Z+1, r1	; 0x01
    5812:	12 82       	std	Z+2, r1	; 0x02
    5814:	13 82       	std	Z+3, r1	; 0x03
    5816:	fe 01       	movw	r30, r28
    5818:	e7 59       	subi	r30, 0x97	; 151
    581a:	ff 4f       	sbci	r31, 0xFF	; 255
    581c:	10 82       	st	Z, r1
    581e:	11 82       	std	Z+1, r1	; 0x01
    5820:	12 82       	std	Z+2, r1	; 0x02
    5822:	13 82       	std	Z+3, r1	; 0x03
    5824:	fe 01       	movw	r30, r28
    5826:	e3 59       	subi	r30, 0x93	; 147
    5828:	ff 4f       	sbci	r31, 0xFF	; 255
    582a:	10 82       	st	Z, r1
    582c:	11 82       	std	Z+1, r1	; 0x01
    582e:	12 82       	std	Z+2, r1	; 0x02
    5830:	13 82       	std	Z+3, r1	; 0x03
    5832:	fe 01       	movw	r30, r28
    5834:	ef 58       	subi	r30, 0x8F	; 143
    5836:	ff 4f       	sbci	r31, 0xFF	; 255
    5838:	10 82       	st	Z, r1
    583a:	11 82       	std	Z+1, r1	; 0x01
    583c:	12 82       	std	Z+2, r1	; 0x02
    583e:	13 82       	std	Z+3, r1	; 0x03
    5840:	fe 01       	movw	r30, r28
    5842:	eb 58       	subi	r30, 0x8B	; 139
    5844:	ff 4f       	sbci	r31, 0xFF	; 255
    5846:	10 82       	st	Z, r1
    5848:	11 82       	std	Z+1, r1	; 0x01
    584a:	12 82       	std	Z+2, r1	; 0x02
    584c:	13 82       	std	Z+3, r1	; 0x03
    584e:	fe 01       	movw	r30, r28
    5850:	e7 58       	subi	r30, 0x87	; 135
    5852:	ff 4f       	sbci	r31, 0xFF	; 255
    5854:	10 82       	st	Z, r1
    5856:	11 82       	std	Z+1, r1	; 0x01
    5858:	12 82       	std	Z+2, r1	; 0x02
    585a:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    585c:	b8 01       	movw	r22, r16
    585e:	ce 01       	movw	r24, r28
    5860:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <_ZN10helicopter8messages22SimpleTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    5864:	8c 2f       	mov	r24, r28
    5866:	9d 2f       	mov	r25, r29
    5868:	df 91       	pop	r29
    586a:	cf 91       	pop	r28
    586c:	1f 91       	pop	r17
    586e:	0f 91       	pop	r16
    5870:	08 95       	ret

00005872 <_ZN10helicopter8messages11SyncMessageD1Ev>:
				{
					
				}
				
				virtual ~Message()
				{
    5872:	20 e5       	ldi	r18, 0x50	; 80
    5874:	32 e0       	ldi	r19, 0x02	; 2
    5876:	fc 01       	movw	r30, r24
    5878:	31 83       	std	Z+1, r19	; 0x01
    587a:	20 83       	st	Z, r18
    587c:	08 95       	ret

0000587e <_ZN10helicopter8messages11SyncMessage12buildMessageEPh>:
	return msg;
}

void SyncMessage::buildMessage(byte *message)
{
	if (message != NULL)
    587e:	61 15       	cp	r22, r1
    5880:	71 05       	cpc	r23, r1
    5882:	41 f0       	breq	.+16     	; 0x5894 <_ZN10helicopter8messages11SyncMessage12buildMessageEPh+0x16>
	{
		msgType = message[0];
    5884:	fb 01       	movw	r30, r22
    5886:	20 81       	ld	r18, Z
    5888:	fc 01       	movw	r30, r24
    588a:	22 83       	std	Z+2, r18	; 0x02
		RequestedMessage = message[1];
    588c:	fb 01       	movw	r30, r22
    588e:	21 81       	ldd	r18, Z+1	; 0x01
    5890:	fc 01       	movw	r30, r24
    5892:	25 83       	std	Z+5, r18	; 0x05
    5894:	08 95       	ret

00005896 <_ZN10helicopter8messages11SyncMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SyncMessage::getBytes()
{
    5896:	cf 93       	push	r28
    5898:	df 93       	push	r29
    589a:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    589c:	82 e0       	ldi	r24, 0x02	; 2
    589e:	90 e0       	ldi	r25, 0x00	; 0
    58a0:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    58a4:	fc 01       	movw	r30, r24
	byte *msgPtr = msg;
	msgPtr[0] = this->msgType;
    58a6:	8a 81       	ldd	r24, Y+2	; 0x02
    58a8:	80 83       	st	Z, r24
	msgPtr[1] = this->RequestedMessage;
    58aa:	8d 81       	ldd	r24, Y+5	; 0x05
    58ac:	81 83       	std	Z+1, r24	; 0x01
	
	return msg;
}
    58ae:	8e 2f       	mov	r24, r30
    58b0:	9f 2f       	mov	r25, r31
    58b2:	df 91       	pop	r29
    58b4:	cf 91       	pop	r28
    58b6:	08 95       	ret

000058b8 <_ZN10helicopter8messages11SyncMessageD0Ev>:
    58b8:	20 e5       	ldi	r18, 0x50	; 80
    58ba:	32 e0       	ldi	r19, 0x02	; 2
    58bc:	fc 01       	movw	r30, r24
    58be:	31 83       	std	Z+1, r19	; 0x01
    58c0:	20 83       	st	Z, r18
				}
				
				~SyncMessage()
				{
					
				}
    58c2:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    58c6:	08 95       	ret

000058c8 <_ZN10helicopter8messages22SystemTelemetryMessageD1Ev>:
    58c8:	20 e5       	ldi	r18, 0x50	; 80
    58ca:	32 e0       	ldi	r19, 0x02	; 2
    58cc:	fc 01       	movw	r30, r24
    58ce:	31 83       	std	Z+1, r19	; 0x01
    58d0:	20 83       	st	Z, r18
    58d2:	08 95       	ret

000058d4 <_ZN10helicopter8messages22SystemTelemetryMessageD0Ev>:
    58d4:	20 e5       	ldi	r18, 0x50	; 80
    58d6:	32 e0       	ldi	r19, 0x02	; 2
    58d8:	fc 01       	movw	r30, r24
    58da:	31 83       	std	Z+1, r19	; 0x01
    58dc:	20 83       	st	Z, r18
					SerialCommunicationBufferOverruns(0)
				{
				
				}
			
				~SystemTelemetryMessage() {}
    58de:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    58e2:	08 95       	ret

000058e4 <_ZN10helicopter8messages22SystemTelemetryMessage8getBytesEv>:

using namespace helicopter::messages;


byte *SystemTelemetryMessage::getBytes()
{
    58e4:	cf 93       	push	r28
    58e6:	df 93       	push	r29
    58e8:	ec 01       	movw	r28, r24
	byte *msg = new byte[MessageSize];
    58ea:	8d e2       	ldi	r24, 0x2D	; 45
    58ec:	91 e0       	ldi	r25, 0x01	; 1
    58ee:	0e 94 84 64 	call	0xc908	; 0xc908 <_Znaj>
    58f2:	fc 01       	movw	r30, r24
					buffPtr += sizeof(val);
				}		
				
				void encode (byte *&buffPtr, byte &val)
				{
					*buffPtr = val;
    58f4:	8a 81       	ldd	r24, Y+2	; 0x02
    58f6:	80 83       	st	Z, r24
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    58f8:	8d 81       	ldd	r24, Y+5	; 0x05
    58fa:	9e 81       	ldd	r25, Y+6	; 0x06
    58fc:	af 81       	ldd	r26, Y+7	; 0x07
    58fe:	b8 85       	ldd	r27, Y+8	; 0x08
    5900:	81 83       	std	Z+1, r24	; 0x01
    5902:	92 83       	std	Z+2, r25	; 0x02
    5904:	a3 83       	std	Z+3, r26	; 0x03
    5906:	b4 83       	std	Z+4, r27	; 0x04
    5908:	89 85       	ldd	r24, Y+9	; 0x09
    590a:	9a 85       	ldd	r25, Y+10	; 0x0a
    590c:	ab 85       	ldd	r26, Y+11	; 0x0b
    590e:	bc 85       	ldd	r27, Y+12	; 0x0c
    5910:	85 83       	std	Z+5, r24	; 0x05
    5912:	96 83       	std	Z+6, r25	; 0x06
    5914:	a7 83       	std	Z+7, r26	; 0x07
    5916:	b0 87       	std	Z+8, r27	; 0x08
    5918:	8d 85       	ldd	r24, Y+13	; 0x0d
    591a:	9e 85       	ldd	r25, Y+14	; 0x0e
    591c:	af 85       	ldd	r26, Y+15	; 0x0f
    591e:	b8 89       	ldd	r27, Y+16	; 0x10
    5920:	81 87       	std	Z+9, r24	; 0x09
    5922:	92 87       	std	Z+10, r25	; 0x0a
    5924:	a3 87       	std	Z+11, r26	; 0x0b
    5926:	b4 87       	std	Z+12, r27	; 0x0c
    5928:	89 89       	ldd	r24, Y+17	; 0x11
    592a:	9a 89       	ldd	r25, Y+18	; 0x12
    592c:	ab 89       	ldd	r26, Y+19	; 0x13
    592e:	bc 89       	ldd	r27, Y+20	; 0x14
    5930:	85 87       	std	Z+13, r24	; 0x0d
    5932:	96 87       	std	Z+14, r25	; 0x0e
    5934:	a7 87       	std	Z+15, r26	; 0x0f
    5936:	b0 8b       	std	Z+16, r27	; 0x10
    5938:	8d 89       	ldd	r24, Y+21	; 0x15
    593a:	9e 89       	ldd	r25, Y+22	; 0x16
    593c:	af 89       	ldd	r26, Y+23	; 0x17
    593e:	b8 8d       	ldd	r27, Y+24	; 0x18
    5940:	81 8b       	std	Z+17, r24	; 0x11
    5942:	92 8b       	std	Z+18, r25	; 0x12
    5944:	a3 8b       	std	Z+19, r26	; 0x13
    5946:	b4 8b       	std	Z+20, r27	; 0x14
    5948:	89 8d       	ldd	r24, Y+25	; 0x19
    594a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    594c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    594e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    5950:	85 8b       	std	Z+21, r24	; 0x15
    5952:	96 8b       	std	Z+22, r25	; 0x16
    5954:	a7 8b       	std	Z+23, r26	; 0x17
    5956:	b0 8f       	std	Z+24, r27	; 0x18
    5958:	8d 8d       	ldd	r24, Y+29	; 0x1d
    595a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    595c:	af 8d       	ldd	r26, Y+31	; 0x1f
    595e:	b8 a1       	ldd	r27, Y+32	; 0x20
    5960:	81 8f       	std	Z+25, r24	; 0x19
    5962:	92 8f       	std	Z+26, r25	; 0x1a
    5964:	a3 8f       	std	Z+27, r26	; 0x1b
    5966:	b4 8f       	std	Z+28, r27	; 0x1c
    5968:	89 a1       	ldd	r24, Y+33	; 0x21
    596a:	9a a1       	ldd	r25, Y+34	; 0x22
    596c:	ab a1       	ldd	r26, Y+35	; 0x23
    596e:	bc a1       	ldd	r27, Y+36	; 0x24
    5970:	85 8f       	std	Z+29, r24	; 0x1d
    5972:	96 8f       	std	Z+30, r25	; 0x1e
    5974:	a7 8f       	std	Z+31, r26	; 0x1f
    5976:	b0 a3       	std	Z+32, r27	; 0x20
    5978:	8d a1       	ldd	r24, Y+37	; 0x25
    597a:	9e a1       	ldd	r25, Y+38	; 0x26
    597c:	af a1       	ldd	r26, Y+39	; 0x27
    597e:	b8 a5       	ldd	r27, Y+40	; 0x28
    5980:	81 a3       	std	Z+33, r24	; 0x21
    5982:	92 a3       	std	Z+34, r25	; 0x22
    5984:	a3 a3       	std	Z+35, r26	; 0x23
    5986:	b4 a3       	std	Z+36, r27	; 0x24
    5988:	89 a5       	ldd	r24, Y+41	; 0x29
    598a:	9a a5       	ldd	r25, Y+42	; 0x2a
    598c:	ab a5       	ldd	r26, Y+43	; 0x2b
    598e:	bc a5       	ldd	r27, Y+44	; 0x2c
    5990:	85 a3       	std	Z+37, r24	; 0x25
    5992:	96 a3       	std	Z+38, r25	; 0x26
    5994:	a7 a3       	std	Z+39, r26	; 0x27
    5996:	b0 a7       	std	Z+40, r27	; 0x28
    5998:	8d a5       	ldd	r24, Y+45	; 0x2d
    599a:	9e a5       	ldd	r25, Y+46	; 0x2e
    599c:	af a5       	ldd	r26, Y+47	; 0x2f
    599e:	b8 a9       	ldd	r27, Y+48	; 0x30
    59a0:	81 a7       	std	Z+41, r24	; 0x29
    59a2:	92 a7       	std	Z+42, r25	; 0x2a
    59a4:	a3 a7       	std	Z+43, r26	; 0x2b
    59a6:	b4 a7       	std	Z+44, r27	; 0x2c
    59a8:	89 a9       	ldd	r24, Y+49	; 0x31
    59aa:	9a a9       	ldd	r25, Y+50	; 0x32
    59ac:	ab a9       	ldd	r26, Y+51	; 0x33
    59ae:	bc a9       	ldd	r27, Y+52	; 0x34
    59b0:	85 a7       	std	Z+45, r24	; 0x2d
    59b2:	96 a7       	std	Z+46, r25	; 0x2e
    59b4:	a7 a7       	std	Z+47, r26	; 0x2f
    59b6:	b0 ab       	std	Z+48, r27	; 0x30
    59b8:	8d a9       	ldd	r24, Y+53	; 0x35
    59ba:	9e a9       	ldd	r25, Y+54	; 0x36
    59bc:	af a9       	ldd	r26, Y+55	; 0x37
    59be:	b8 ad       	ldd	r27, Y+56	; 0x38
    59c0:	81 ab       	std	Z+49, r24	; 0x31
    59c2:	92 ab       	std	Z+50, r25	; 0x32
    59c4:	a3 ab       	std	Z+51, r26	; 0x33
    59c6:	b4 ab       	std	Z+52, r27	; 0x34
    59c8:	89 ad       	ldd	r24, Y+57	; 0x39
    59ca:	9a ad       	ldd	r25, Y+58	; 0x3a
    59cc:	ab ad       	ldd	r26, Y+59	; 0x3b
    59ce:	bc ad       	ldd	r27, Y+60	; 0x3c
    59d0:	85 ab       	std	Z+53, r24	; 0x35
    59d2:	96 ab       	std	Z+54, r25	; 0x36
    59d4:	a7 ab       	std	Z+55, r26	; 0x37
    59d6:	b0 af       	std	Z+56, r27	; 0x38
    59d8:	de 01       	movw	r26, r28
    59da:	dd 96       	adiw	r26, 0x3d	; 61
    59dc:	8d 91       	ld	r24, X+
    59de:	9d 91       	ld	r25, X+
    59e0:	0d 90       	ld	r0, X+
    59e2:	bc 91       	ld	r27, X
    59e4:	a0 2d       	mov	r26, r0
    59e6:	81 af       	std	Z+57, r24	; 0x39
    59e8:	92 af       	std	Z+58, r25	; 0x3a
    59ea:	a3 af       	std	Z+59, r26	; 0x3b
    59ec:	b4 af       	std	Z+60, r27	; 0x3c
    59ee:	9f 01       	movw	r18, r30
    59f0:	23 5c       	subi	r18, 0xC3	; 195
    59f2:	3f 4f       	sbci	r19, 0xFF	; 255
    59f4:	de 01       	movw	r26, r28
    59f6:	af 5b       	subi	r26, 0xBF	; 191
    59f8:	bf 4f       	sbci	r27, 0xFF	; 255
    59fa:	4d 91       	ld	r20, X+
    59fc:	5d 91       	ld	r21, X+
    59fe:	6d 91       	ld	r22, X+
    5a00:	7c 91       	ld	r23, X
    5a02:	d9 01       	movw	r26, r18
    5a04:	4d 93       	st	X+, r20
    5a06:	5d 93       	st	X+, r21
    5a08:	6d 93       	st	X+, r22
    5a0a:	7c 93       	st	X, r23
    5a0c:	13 97       	sbiw	r26, 0x03	; 3
    5a0e:	9f 01       	movw	r18, r30
    5a10:	2f 5b       	subi	r18, 0xBF	; 191
    5a12:	3f 4f       	sbci	r19, 0xFF	; 255
    5a14:	de 01       	movw	r26, r28
    5a16:	ab 5b       	subi	r26, 0xBB	; 187
    5a18:	bf 4f       	sbci	r27, 0xFF	; 255
    5a1a:	4d 91       	ld	r20, X+
    5a1c:	5d 91       	ld	r21, X+
    5a1e:	6d 91       	ld	r22, X+
    5a20:	7c 91       	ld	r23, X
    5a22:	d9 01       	movw	r26, r18
    5a24:	4d 93       	st	X+, r20
    5a26:	5d 93       	st	X+, r21
    5a28:	6d 93       	st	X+, r22
    5a2a:	7c 93       	st	X, r23
    5a2c:	13 97       	sbiw	r26, 0x03	; 3
    5a2e:	9f 01       	movw	r18, r30
    5a30:	2b 5b       	subi	r18, 0xBB	; 187
    5a32:	3f 4f       	sbci	r19, 0xFF	; 255
    5a34:	de 01       	movw	r26, r28
    5a36:	a7 5b       	subi	r26, 0xB7	; 183
    5a38:	bf 4f       	sbci	r27, 0xFF	; 255
    5a3a:	4d 91       	ld	r20, X+
    5a3c:	5d 91       	ld	r21, X+
    5a3e:	6d 91       	ld	r22, X+
    5a40:	7c 91       	ld	r23, X
    5a42:	d9 01       	movw	r26, r18
    5a44:	4d 93       	st	X+, r20
    5a46:	5d 93       	st	X+, r21
    5a48:	6d 93       	st	X+, r22
    5a4a:	7c 93       	st	X, r23
    5a4c:	13 97       	sbiw	r26, 0x03	; 3
    5a4e:	9f 01       	movw	r18, r30
    5a50:	27 5b       	subi	r18, 0xB7	; 183
    5a52:	3f 4f       	sbci	r19, 0xFF	; 255
    5a54:	de 01       	movw	r26, r28
    5a56:	a3 5b       	subi	r26, 0xB3	; 179
    5a58:	bf 4f       	sbci	r27, 0xFF	; 255
    5a5a:	4d 91       	ld	r20, X+
    5a5c:	5d 91       	ld	r21, X+
    5a5e:	6d 91       	ld	r22, X+
    5a60:	7c 91       	ld	r23, X
    5a62:	d9 01       	movw	r26, r18
    5a64:	4d 93       	st	X+, r20
    5a66:	5d 93       	st	X+, r21
    5a68:	6d 93       	st	X+, r22
    5a6a:	7c 93       	st	X, r23
    5a6c:	13 97       	sbiw	r26, 0x03	; 3
    5a6e:	9f 01       	movw	r18, r30
    5a70:	23 5b       	subi	r18, 0xB3	; 179
    5a72:	3f 4f       	sbci	r19, 0xFF	; 255
    5a74:	de 01       	movw	r26, r28
    5a76:	af 5a       	subi	r26, 0xAF	; 175
    5a78:	bf 4f       	sbci	r27, 0xFF	; 255
    5a7a:	4d 91       	ld	r20, X+
    5a7c:	5d 91       	ld	r21, X+
    5a7e:	6d 91       	ld	r22, X+
    5a80:	7c 91       	ld	r23, X
    5a82:	d9 01       	movw	r26, r18
    5a84:	4d 93       	st	X+, r20
    5a86:	5d 93       	st	X+, r21
    5a88:	6d 93       	st	X+, r22
    5a8a:	7c 93       	st	X, r23
    5a8c:	13 97       	sbiw	r26, 0x03	; 3
    5a8e:	9f 01       	movw	r18, r30
    5a90:	2f 5a       	subi	r18, 0xAF	; 175
    5a92:	3f 4f       	sbci	r19, 0xFF	; 255
    5a94:	de 01       	movw	r26, r28
    5a96:	ab 5a       	subi	r26, 0xAB	; 171
    5a98:	bf 4f       	sbci	r27, 0xFF	; 255
    5a9a:	4d 91       	ld	r20, X+
    5a9c:	5d 91       	ld	r21, X+
    5a9e:	6d 91       	ld	r22, X+
    5aa0:	7c 91       	ld	r23, X
    5aa2:	d9 01       	movw	r26, r18
    5aa4:	4d 93       	st	X+, r20
    5aa6:	5d 93       	st	X+, r21
    5aa8:	6d 93       	st	X+, r22
    5aaa:	7c 93       	st	X, r23
    5aac:	13 97       	sbiw	r26, 0x03	; 3
    5aae:	9f 01       	movw	r18, r30
    5ab0:	2b 5a       	subi	r18, 0xAB	; 171
    5ab2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ab4:	de 01       	movw	r26, r28
    5ab6:	a7 5a       	subi	r26, 0xA7	; 167
    5ab8:	bf 4f       	sbci	r27, 0xFF	; 255
    5aba:	4d 91       	ld	r20, X+
    5abc:	5d 91       	ld	r21, X+
    5abe:	6d 91       	ld	r22, X+
    5ac0:	7c 91       	ld	r23, X
    5ac2:	d9 01       	movw	r26, r18
    5ac4:	4d 93       	st	X+, r20
    5ac6:	5d 93       	st	X+, r21
    5ac8:	6d 93       	st	X+, r22
    5aca:	7c 93       	st	X, r23
    5acc:	13 97       	sbiw	r26, 0x03	; 3
    5ace:	9f 01       	movw	r18, r30
    5ad0:	27 5a       	subi	r18, 0xA7	; 167
    5ad2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ad4:	de 01       	movw	r26, r28
    5ad6:	a3 5a       	subi	r26, 0xA3	; 163
    5ad8:	bf 4f       	sbci	r27, 0xFF	; 255
    5ada:	4d 91       	ld	r20, X+
    5adc:	5d 91       	ld	r21, X+
    5ade:	6d 91       	ld	r22, X+
    5ae0:	7c 91       	ld	r23, X
    5ae2:	d9 01       	movw	r26, r18
    5ae4:	4d 93       	st	X+, r20
    5ae6:	5d 93       	st	X+, r21
    5ae8:	6d 93       	st	X+, r22
    5aea:	7c 93       	st	X, r23
    5aec:	13 97       	sbiw	r26, 0x03	; 3
    5aee:	9f 01       	movw	r18, r30
    5af0:	23 5a       	subi	r18, 0xA3	; 163
    5af2:	3f 4f       	sbci	r19, 0xFF	; 255
    5af4:	de 01       	movw	r26, r28
    5af6:	af 59       	subi	r26, 0x9F	; 159
    5af8:	bf 4f       	sbci	r27, 0xFF	; 255
    5afa:	4d 91       	ld	r20, X+
    5afc:	5d 91       	ld	r21, X+
    5afe:	6d 91       	ld	r22, X+
    5b00:	7c 91       	ld	r23, X
    5b02:	d9 01       	movw	r26, r18
    5b04:	4d 93       	st	X+, r20
    5b06:	5d 93       	st	X+, r21
    5b08:	6d 93       	st	X+, r22
    5b0a:	7c 93       	st	X, r23
    5b0c:	13 97       	sbiw	r26, 0x03	; 3
    5b0e:	9f 01       	movw	r18, r30
    5b10:	2f 59       	subi	r18, 0x9F	; 159
    5b12:	3f 4f       	sbci	r19, 0xFF	; 255
    5b14:	de 01       	movw	r26, r28
    5b16:	ab 59       	subi	r26, 0x9B	; 155
    5b18:	bf 4f       	sbci	r27, 0xFF	; 255
    5b1a:	4d 91       	ld	r20, X+
    5b1c:	5d 91       	ld	r21, X+
    5b1e:	6d 91       	ld	r22, X+
    5b20:	7c 91       	ld	r23, X
    5b22:	d9 01       	movw	r26, r18
    5b24:	4d 93       	st	X+, r20
    5b26:	5d 93       	st	X+, r21
    5b28:	6d 93       	st	X+, r22
    5b2a:	7c 93       	st	X, r23
    5b2c:	13 97       	sbiw	r26, 0x03	; 3
    5b2e:	9f 01       	movw	r18, r30
    5b30:	2b 59       	subi	r18, 0x9B	; 155
    5b32:	3f 4f       	sbci	r19, 0xFF	; 255
    5b34:	de 01       	movw	r26, r28
    5b36:	a7 59       	subi	r26, 0x97	; 151
    5b38:	bf 4f       	sbci	r27, 0xFF	; 255
    5b3a:	4d 91       	ld	r20, X+
    5b3c:	5d 91       	ld	r21, X+
    5b3e:	6d 91       	ld	r22, X+
    5b40:	7c 91       	ld	r23, X
    5b42:	d9 01       	movw	r26, r18
    5b44:	4d 93       	st	X+, r20
    5b46:	5d 93       	st	X+, r21
    5b48:	6d 93       	st	X+, r22
    5b4a:	7c 93       	st	X, r23
    5b4c:	13 97       	sbiw	r26, 0x03	; 3
    5b4e:	9f 01       	movw	r18, r30
    5b50:	27 59       	subi	r18, 0x97	; 151
    5b52:	3f 4f       	sbci	r19, 0xFF	; 255
    5b54:	de 01       	movw	r26, r28
    5b56:	a3 59       	subi	r26, 0x93	; 147
    5b58:	bf 4f       	sbci	r27, 0xFF	; 255
    5b5a:	4d 91       	ld	r20, X+
    5b5c:	5d 91       	ld	r21, X+
    5b5e:	6d 91       	ld	r22, X+
    5b60:	7c 91       	ld	r23, X
    5b62:	d9 01       	movw	r26, r18
    5b64:	4d 93       	st	X+, r20
    5b66:	5d 93       	st	X+, r21
    5b68:	6d 93       	st	X+, r22
    5b6a:	7c 93       	st	X, r23
    5b6c:	13 97       	sbiw	r26, 0x03	; 3
    5b6e:	9f 01       	movw	r18, r30
    5b70:	23 59       	subi	r18, 0x93	; 147
    5b72:	3f 4f       	sbci	r19, 0xFF	; 255
    5b74:	de 01       	movw	r26, r28
    5b76:	af 58       	subi	r26, 0x8F	; 143
    5b78:	bf 4f       	sbci	r27, 0xFF	; 255
    5b7a:	4d 91       	ld	r20, X+
    5b7c:	5d 91       	ld	r21, X+
    5b7e:	6d 91       	ld	r22, X+
    5b80:	7c 91       	ld	r23, X
    5b82:	d9 01       	movw	r26, r18
    5b84:	4d 93       	st	X+, r20
    5b86:	5d 93       	st	X+, r21
    5b88:	6d 93       	st	X+, r22
    5b8a:	7c 93       	st	X, r23
    5b8c:	13 97       	sbiw	r26, 0x03	; 3
    5b8e:	9f 01       	movw	r18, r30
    5b90:	2f 58       	subi	r18, 0x8F	; 143
    5b92:	3f 4f       	sbci	r19, 0xFF	; 255
    5b94:	de 01       	movw	r26, r28
    5b96:	ab 58       	subi	r26, 0x8B	; 139
    5b98:	bf 4f       	sbci	r27, 0xFF	; 255
    5b9a:	4d 91       	ld	r20, X+
    5b9c:	5d 91       	ld	r21, X+
    5b9e:	6d 91       	ld	r22, X+
    5ba0:	7c 91       	ld	r23, X
    5ba2:	d9 01       	movw	r26, r18
    5ba4:	4d 93       	st	X+, r20
    5ba6:	5d 93       	st	X+, r21
    5ba8:	6d 93       	st	X+, r22
    5baa:	7c 93       	st	X, r23
    5bac:	13 97       	sbiw	r26, 0x03	; 3
    5bae:	9f 01       	movw	r18, r30
    5bb0:	2b 58       	subi	r18, 0x8B	; 139
    5bb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5bb4:	de 01       	movw	r26, r28
    5bb6:	a7 58       	subi	r26, 0x87	; 135
    5bb8:	bf 4f       	sbci	r27, 0xFF	; 255
    5bba:	4d 91       	ld	r20, X+
    5bbc:	5d 91       	ld	r21, X+
    5bbe:	6d 91       	ld	r22, X+
    5bc0:	7c 91       	ld	r23, X
    5bc2:	d9 01       	movw	r26, r18
    5bc4:	4d 93       	st	X+, r20
    5bc6:	5d 93       	st	X+, r21
    5bc8:	6d 93       	st	X+, r22
    5bca:	7c 93       	st	X, r23
    5bcc:	13 97       	sbiw	r26, 0x03	; 3
    5bce:	9f 01       	movw	r18, r30
    5bd0:	27 58       	subi	r18, 0x87	; 135
    5bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5bd4:	de 01       	movw	r26, r28
    5bd6:	a3 58       	subi	r26, 0x83	; 131
    5bd8:	bf 4f       	sbci	r27, 0xFF	; 255
    5bda:	4d 91       	ld	r20, X+
    5bdc:	5d 91       	ld	r21, X+
    5bde:	6d 91       	ld	r22, X+
    5be0:	7c 91       	ld	r23, X
    5be2:	d9 01       	movw	r26, r18
    5be4:	4d 93       	st	X+, r20
    5be6:	5d 93       	st	X+, r21
    5be8:	6d 93       	st	X+, r22
    5bea:	7c 93       	st	X, r23
    5bec:	13 97       	sbiw	r26, 0x03	; 3
    5bee:	9f 01       	movw	r18, r30
    5bf0:	23 58       	subi	r18, 0x83	; 131
    5bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    5bf4:	de 01       	movw	r26, r28
    5bf6:	af 57       	subi	r26, 0x7F	; 127
    5bf8:	bf 4f       	sbci	r27, 0xFF	; 255
    5bfa:	4d 91       	ld	r20, X+
    5bfc:	5d 91       	ld	r21, X+
    5bfe:	6d 91       	ld	r22, X+
    5c00:	7c 91       	ld	r23, X
    5c02:	d9 01       	movw	r26, r18
    5c04:	4d 93       	st	X+, r20
    5c06:	5d 93       	st	X+, r21
    5c08:	6d 93       	st	X+, r22
    5c0a:	7c 93       	st	X, r23
    5c0c:	13 97       	sbiw	r26, 0x03	; 3
    5c0e:	9f 01       	movw	r18, r30
    5c10:	2f 57       	subi	r18, 0x7F	; 127
    5c12:	3f 4f       	sbci	r19, 0xFF	; 255
    5c14:	de 01       	movw	r26, r28
    5c16:	ab 57       	subi	r26, 0x7B	; 123
    5c18:	bf 4f       	sbci	r27, 0xFF	; 255
    5c1a:	4d 91       	ld	r20, X+
    5c1c:	5d 91       	ld	r21, X+
    5c1e:	6d 91       	ld	r22, X+
    5c20:	7c 91       	ld	r23, X
    5c22:	d9 01       	movw	r26, r18
    5c24:	4d 93       	st	X+, r20
    5c26:	5d 93       	st	X+, r21
    5c28:	6d 93       	st	X+, r22
    5c2a:	7c 93       	st	X, r23
    5c2c:	13 97       	sbiw	r26, 0x03	; 3
    5c2e:	9f 01       	movw	r18, r30
    5c30:	2b 57       	subi	r18, 0x7B	; 123
    5c32:	3f 4f       	sbci	r19, 0xFF	; 255
    5c34:	de 01       	movw	r26, r28
    5c36:	a7 57       	subi	r26, 0x77	; 119
    5c38:	bf 4f       	sbci	r27, 0xFF	; 255
    5c3a:	4d 91       	ld	r20, X+
    5c3c:	5d 91       	ld	r21, X+
    5c3e:	6d 91       	ld	r22, X+
    5c40:	7c 91       	ld	r23, X
    5c42:	d9 01       	movw	r26, r18
    5c44:	4d 93       	st	X+, r20
    5c46:	5d 93       	st	X+, r21
    5c48:	6d 93       	st	X+, r22
    5c4a:	7c 93       	st	X, r23
    5c4c:	13 97       	sbiw	r26, 0x03	; 3
    5c4e:	9f 01       	movw	r18, r30
    5c50:	27 57       	subi	r18, 0x77	; 119
    5c52:	3f 4f       	sbci	r19, 0xFF	; 255
    5c54:	de 01       	movw	r26, r28
    5c56:	a3 57       	subi	r26, 0x73	; 115
    5c58:	bf 4f       	sbci	r27, 0xFF	; 255
    5c5a:	4d 91       	ld	r20, X+
    5c5c:	5d 91       	ld	r21, X+
    5c5e:	6d 91       	ld	r22, X+
    5c60:	7c 91       	ld	r23, X
    5c62:	d9 01       	movw	r26, r18
    5c64:	4d 93       	st	X+, r20
    5c66:	5d 93       	st	X+, r21
    5c68:	6d 93       	st	X+, r22
    5c6a:	7c 93       	st	X, r23
    5c6c:	13 97       	sbiw	r26, 0x03	; 3
    5c6e:	9f 01       	movw	r18, r30
    5c70:	23 57       	subi	r18, 0x73	; 115
    5c72:	3f 4f       	sbci	r19, 0xFF	; 255
    5c74:	de 01       	movw	r26, r28
    5c76:	af 56       	subi	r26, 0x6F	; 111
    5c78:	bf 4f       	sbci	r27, 0xFF	; 255
    5c7a:	4d 91       	ld	r20, X+
    5c7c:	5d 91       	ld	r21, X+
    5c7e:	6d 91       	ld	r22, X+
    5c80:	7c 91       	ld	r23, X
    5c82:	d9 01       	movw	r26, r18
    5c84:	4d 93       	st	X+, r20
    5c86:	5d 93       	st	X+, r21
    5c88:	6d 93       	st	X+, r22
    5c8a:	7c 93       	st	X, r23
    5c8c:	13 97       	sbiw	r26, 0x03	; 3
    5c8e:	9f 01       	movw	r18, r30
    5c90:	2f 56       	subi	r18, 0x6F	; 111
    5c92:	3f 4f       	sbci	r19, 0xFF	; 255
    5c94:	de 01       	movw	r26, r28
    5c96:	ab 56       	subi	r26, 0x6B	; 107
    5c98:	bf 4f       	sbci	r27, 0xFF	; 255
    5c9a:	4d 91       	ld	r20, X+
    5c9c:	5d 91       	ld	r21, X+
    5c9e:	6d 91       	ld	r22, X+
    5ca0:	7c 91       	ld	r23, X
    5ca2:	d9 01       	movw	r26, r18
    5ca4:	4d 93       	st	X+, r20
    5ca6:	5d 93       	st	X+, r21
    5ca8:	6d 93       	st	X+, r22
    5caa:	7c 93       	st	X, r23
    5cac:	13 97       	sbiw	r26, 0x03	; 3
    5cae:	9f 01       	movw	r18, r30
    5cb0:	2b 56       	subi	r18, 0x6B	; 107
    5cb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5cb4:	de 01       	movw	r26, r28
    5cb6:	a7 56       	subi	r26, 0x67	; 103
    5cb8:	bf 4f       	sbci	r27, 0xFF	; 255
    5cba:	4d 91       	ld	r20, X+
    5cbc:	5d 91       	ld	r21, X+
    5cbe:	6d 91       	ld	r22, X+
    5cc0:	7c 91       	ld	r23, X
    5cc2:	d9 01       	movw	r26, r18
    5cc4:	4d 93       	st	X+, r20
    5cc6:	5d 93       	st	X+, r21
    5cc8:	6d 93       	st	X+, r22
    5cca:	7c 93       	st	X, r23
    5ccc:	13 97       	sbiw	r26, 0x03	; 3
    5cce:	9f 01       	movw	r18, r30
    5cd0:	27 56       	subi	r18, 0x67	; 103
    5cd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd4:	de 01       	movw	r26, r28
    5cd6:	a3 56       	subi	r26, 0x63	; 99
    5cd8:	bf 4f       	sbci	r27, 0xFF	; 255
    5cda:	4d 91       	ld	r20, X+
    5cdc:	5d 91       	ld	r21, X+
    5cde:	6d 91       	ld	r22, X+
    5ce0:	7c 91       	ld	r23, X
    5ce2:	d9 01       	movw	r26, r18
    5ce4:	4d 93       	st	X+, r20
    5ce6:	5d 93       	st	X+, r21
    5ce8:	6d 93       	st	X+, r22
    5cea:	7c 93       	st	X, r23
    5cec:	13 97       	sbiw	r26, 0x03	; 3
    5cee:	9f 01       	movw	r18, r30
    5cf0:	23 56       	subi	r18, 0x63	; 99
    5cf2:	3f 4f       	sbci	r19, 0xFF	; 255
    5cf4:	de 01       	movw	r26, r28
    5cf6:	af 55       	subi	r26, 0x5F	; 95
    5cf8:	bf 4f       	sbci	r27, 0xFF	; 255
    5cfa:	4d 91       	ld	r20, X+
    5cfc:	5d 91       	ld	r21, X+
    5cfe:	6d 91       	ld	r22, X+
    5d00:	7c 91       	ld	r23, X
    5d02:	d9 01       	movw	r26, r18
    5d04:	4d 93       	st	X+, r20
    5d06:	5d 93       	st	X+, r21
    5d08:	6d 93       	st	X+, r22
    5d0a:	7c 93       	st	X, r23
    5d0c:	13 97       	sbiw	r26, 0x03	; 3
    5d0e:	9f 01       	movw	r18, r30
    5d10:	2f 55       	subi	r18, 0x5F	; 95
    5d12:	3f 4f       	sbci	r19, 0xFF	; 255
    5d14:	de 01       	movw	r26, r28
    5d16:	ab 55       	subi	r26, 0x5B	; 91
    5d18:	bf 4f       	sbci	r27, 0xFF	; 255
    5d1a:	4d 91       	ld	r20, X+
    5d1c:	5d 91       	ld	r21, X+
    5d1e:	6d 91       	ld	r22, X+
    5d20:	7c 91       	ld	r23, X
    5d22:	d9 01       	movw	r26, r18
    5d24:	4d 93       	st	X+, r20
    5d26:	5d 93       	st	X+, r21
    5d28:	6d 93       	st	X+, r22
    5d2a:	7c 93       	st	X, r23
    5d2c:	13 97       	sbiw	r26, 0x03	; 3
    5d2e:	9f 01       	movw	r18, r30
    5d30:	2b 55       	subi	r18, 0x5B	; 91
    5d32:	3f 4f       	sbci	r19, 0xFF	; 255
    5d34:	de 01       	movw	r26, r28
    5d36:	a7 55       	subi	r26, 0x57	; 87
    5d38:	bf 4f       	sbci	r27, 0xFF	; 255
    5d3a:	4d 91       	ld	r20, X+
    5d3c:	5d 91       	ld	r21, X+
    5d3e:	6d 91       	ld	r22, X+
    5d40:	7c 91       	ld	r23, X
    5d42:	d9 01       	movw	r26, r18
    5d44:	4d 93       	st	X+, r20
    5d46:	5d 93       	st	X+, r21
    5d48:	6d 93       	st	X+, r22
    5d4a:	7c 93       	st	X, r23
    5d4c:	13 97       	sbiw	r26, 0x03	; 3
    5d4e:	9f 01       	movw	r18, r30
    5d50:	27 55       	subi	r18, 0x57	; 87
    5d52:	3f 4f       	sbci	r19, 0xFF	; 255
    5d54:	de 01       	movw	r26, r28
    5d56:	a3 55       	subi	r26, 0x53	; 83
    5d58:	bf 4f       	sbci	r27, 0xFF	; 255
    5d5a:	4d 91       	ld	r20, X+
    5d5c:	5d 91       	ld	r21, X+
    5d5e:	6d 91       	ld	r22, X+
    5d60:	7c 91       	ld	r23, X
    5d62:	d9 01       	movw	r26, r18
    5d64:	4d 93       	st	X+, r20
    5d66:	5d 93       	st	X+, r21
    5d68:	6d 93       	st	X+, r22
    5d6a:	7c 93       	st	X, r23
    5d6c:	13 97       	sbiw	r26, 0x03	; 3
    5d6e:	9f 01       	movw	r18, r30
    5d70:	23 55       	subi	r18, 0x53	; 83
    5d72:	3f 4f       	sbci	r19, 0xFF	; 255
    5d74:	de 01       	movw	r26, r28
    5d76:	af 54       	subi	r26, 0x4F	; 79
    5d78:	bf 4f       	sbci	r27, 0xFF	; 255
    5d7a:	4d 91       	ld	r20, X+
    5d7c:	5d 91       	ld	r21, X+
    5d7e:	6d 91       	ld	r22, X+
    5d80:	7c 91       	ld	r23, X
    5d82:	d9 01       	movw	r26, r18
    5d84:	4d 93       	st	X+, r20
    5d86:	5d 93       	st	X+, r21
    5d88:	6d 93       	st	X+, r22
    5d8a:	7c 93       	st	X, r23
    5d8c:	13 97       	sbiw	r26, 0x03	; 3
    5d8e:	9f 01       	movw	r18, r30
    5d90:	2f 54       	subi	r18, 0x4F	; 79
    5d92:	3f 4f       	sbci	r19, 0xFF	; 255
    5d94:	de 01       	movw	r26, r28
    5d96:	ab 54       	subi	r26, 0x4B	; 75
    5d98:	bf 4f       	sbci	r27, 0xFF	; 255
    5d9a:	4d 91       	ld	r20, X+
    5d9c:	5d 91       	ld	r21, X+
    5d9e:	6d 91       	ld	r22, X+
    5da0:	7c 91       	ld	r23, X
    5da2:	d9 01       	movw	r26, r18
    5da4:	4d 93       	st	X+, r20
    5da6:	5d 93       	st	X+, r21
    5da8:	6d 93       	st	X+, r22
    5daa:	7c 93       	st	X, r23
    5dac:	13 97       	sbiw	r26, 0x03	; 3
    5dae:	9f 01       	movw	r18, r30
    5db0:	2b 54       	subi	r18, 0x4B	; 75
    5db2:	3f 4f       	sbci	r19, 0xFF	; 255
    5db4:	de 01       	movw	r26, r28
    5db6:	a7 54       	subi	r26, 0x47	; 71
    5db8:	bf 4f       	sbci	r27, 0xFF	; 255
    5dba:	4d 91       	ld	r20, X+
    5dbc:	5d 91       	ld	r21, X+
    5dbe:	6d 91       	ld	r22, X+
    5dc0:	7c 91       	ld	r23, X
    5dc2:	d9 01       	movw	r26, r18
    5dc4:	4d 93       	st	X+, r20
    5dc6:	5d 93       	st	X+, r21
    5dc8:	6d 93       	st	X+, r22
    5dca:	7c 93       	st	X, r23
    5dcc:	13 97       	sbiw	r26, 0x03	; 3
    5dce:	9f 01       	movw	r18, r30
    5dd0:	27 54       	subi	r18, 0x47	; 71
    5dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5dd4:	de 01       	movw	r26, r28
    5dd6:	a3 54       	subi	r26, 0x43	; 67
    5dd8:	bf 4f       	sbci	r27, 0xFF	; 255
    5dda:	4d 91       	ld	r20, X+
    5ddc:	5d 91       	ld	r21, X+
    5dde:	6d 91       	ld	r22, X+
    5de0:	7c 91       	ld	r23, X
    5de2:	d9 01       	movw	r26, r18
    5de4:	4d 93       	st	X+, r20
    5de6:	5d 93       	st	X+, r21
    5de8:	6d 93       	st	X+, r22
    5dea:	7c 93       	st	X, r23
    5dec:	13 97       	sbiw	r26, 0x03	; 3
    5dee:	9f 01       	movw	r18, r30
    5df0:	23 54       	subi	r18, 0x43	; 67
    5df2:	3f 4f       	sbci	r19, 0xFF	; 255
    5df4:	de 01       	movw	r26, r28
    5df6:	af 53       	subi	r26, 0x3F	; 63
    5df8:	bf 4f       	sbci	r27, 0xFF	; 255
    5dfa:	4d 91       	ld	r20, X+
    5dfc:	5d 91       	ld	r21, X+
    5dfe:	6d 91       	ld	r22, X+
    5e00:	7c 91       	ld	r23, X
    5e02:	d9 01       	movw	r26, r18
    5e04:	4d 93       	st	X+, r20
    5e06:	5d 93       	st	X+, r21
    5e08:	6d 93       	st	X+, r22
    5e0a:	7c 93       	st	X, r23
    5e0c:	13 97       	sbiw	r26, 0x03	; 3
    5e0e:	9f 01       	movw	r18, r30
    5e10:	2f 53       	subi	r18, 0x3F	; 63
    5e12:	3f 4f       	sbci	r19, 0xFF	; 255
    5e14:	de 01       	movw	r26, r28
    5e16:	ab 53       	subi	r26, 0x3B	; 59
    5e18:	bf 4f       	sbci	r27, 0xFF	; 255
    5e1a:	4d 91       	ld	r20, X+
    5e1c:	5d 91       	ld	r21, X+
    5e1e:	6d 91       	ld	r22, X+
    5e20:	7c 91       	ld	r23, X
    5e22:	d9 01       	movw	r26, r18
    5e24:	4d 93       	st	X+, r20
    5e26:	5d 93       	st	X+, r21
    5e28:	6d 93       	st	X+, r22
    5e2a:	7c 93       	st	X, r23
    5e2c:	13 97       	sbiw	r26, 0x03	; 3
    5e2e:	9f 01       	movw	r18, r30
    5e30:	2b 53       	subi	r18, 0x3B	; 59
    5e32:	3f 4f       	sbci	r19, 0xFF	; 255
    5e34:	de 01       	movw	r26, r28
    5e36:	a7 53       	subi	r26, 0x37	; 55
    5e38:	bf 4f       	sbci	r27, 0xFF	; 255
    5e3a:	4d 91       	ld	r20, X+
    5e3c:	5d 91       	ld	r21, X+
    5e3e:	6d 91       	ld	r22, X+
    5e40:	7c 91       	ld	r23, X
    5e42:	d9 01       	movw	r26, r18
    5e44:	4d 93       	st	X+, r20
    5e46:	5d 93       	st	X+, r21
    5e48:	6d 93       	st	X+, r22
    5e4a:	7c 93       	st	X, r23
    5e4c:	13 97       	sbiw	r26, 0x03	; 3
    5e4e:	9f 01       	movw	r18, r30
    5e50:	27 53       	subi	r18, 0x37	; 55
    5e52:	3f 4f       	sbci	r19, 0xFF	; 255
    5e54:	de 01       	movw	r26, r28
    5e56:	a3 53       	subi	r26, 0x33	; 51
    5e58:	bf 4f       	sbci	r27, 0xFF	; 255
    5e5a:	4d 91       	ld	r20, X+
    5e5c:	5d 91       	ld	r21, X+
    5e5e:	6d 91       	ld	r22, X+
    5e60:	7c 91       	ld	r23, X
    5e62:	d9 01       	movw	r26, r18
    5e64:	4d 93       	st	X+, r20
    5e66:	5d 93       	st	X+, r21
    5e68:	6d 93       	st	X+, r22
    5e6a:	7c 93       	st	X, r23
    5e6c:	13 97       	sbiw	r26, 0x03	; 3
    5e6e:	9f 01       	movw	r18, r30
    5e70:	23 53       	subi	r18, 0x33	; 51
    5e72:	3f 4f       	sbci	r19, 0xFF	; 255
    5e74:	de 01       	movw	r26, r28
    5e76:	af 52       	subi	r26, 0x2F	; 47
    5e78:	bf 4f       	sbci	r27, 0xFF	; 255
    5e7a:	4d 91       	ld	r20, X+
    5e7c:	5d 91       	ld	r21, X+
    5e7e:	6d 91       	ld	r22, X+
    5e80:	7c 91       	ld	r23, X
    5e82:	d9 01       	movw	r26, r18
    5e84:	4d 93       	st	X+, r20
    5e86:	5d 93       	st	X+, r21
    5e88:	6d 93       	st	X+, r22
    5e8a:	7c 93       	st	X, r23
    5e8c:	13 97       	sbiw	r26, 0x03	; 3
    5e8e:	9f 01       	movw	r18, r30
    5e90:	2f 52       	subi	r18, 0x2F	; 47
    5e92:	3f 4f       	sbci	r19, 0xFF	; 255
    5e94:	de 01       	movw	r26, r28
    5e96:	ab 52       	subi	r26, 0x2B	; 43
    5e98:	bf 4f       	sbci	r27, 0xFF	; 255
    5e9a:	4d 91       	ld	r20, X+
    5e9c:	5d 91       	ld	r21, X+
    5e9e:	6d 91       	ld	r22, X+
    5ea0:	7c 91       	ld	r23, X
    5ea2:	d9 01       	movw	r26, r18
    5ea4:	4d 93       	st	X+, r20
    5ea6:	5d 93       	st	X+, r21
    5ea8:	6d 93       	st	X+, r22
    5eaa:	7c 93       	st	X, r23
    5eac:	13 97       	sbiw	r26, 0x03	; 3
    5eae:	9f 01       	movw	r18, r30
    5eb0:	2b 52       	subi	r18, 0x2B	; 43
    5eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5eb4:	de 01       	movw	r26, r28
    5eb6:	a7 52       	subi	r26, 0x27	; 39
    5eb8:	bf 4f       	sbci	r27, 0xFF	; 255
    5eba:	4d 91       	ld	r20, X+
    5ebc:	5d 91       	ld	r21, X+
    5ebe:	6d 91       	ld	r22, X+
    5ec0:	7c 91       	ld	r23, X
    5ec2:	d9 01       	movw	r26, r18
    5ec4:	4d 93       	st	X+, r20
    5ec6:	5d 93       	st	X+, r21
    5ec8:	6d 93       	st	X+, r22
    5eca:	7c 93       	st	X, r23
    5ecc:	13 97       	sbiw	r26, 0x03	; 3
    5ece:	9f 01       	movw	r18, r30
    5ed0:	27 52       	subi	r18, 0x27	; 39
    5ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ed4:	de 01       	movw	r26, r28
    5ed6:	a3 52       	subi	r26, 0x23	; 35
    5ed8:	bf 4f       	sbci	r27, 0xFF	; 255
    5eda:	4d 91       	ld	r20, X+
    5edc:	5d 91       	ld	r21, X+
    5ede:	6d 91       	ld	r22, X+
    5ee0:	7c 91       	ld	r23, X
    5ee2:	d9 01       	movw	r26, r18
    5ee4:	4d 93       	st	X+, r20
    5ee6:	5d 93       	st	X+, r21
    5ee8:	6d 93       	st	X+, r22
    5eea:	7c 93       	st	X, r23
    5eec:	13 97       	sbiw	r26, 0x03	; 3
    5eee:	9f 01       	movw	r18, r30
    5ef0:	23 52       	subi	r18, 0x23	; 35
    5ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ef4:	de 01       	movw	r26, r28
    5ef6:	af 51       	subi	r26, 0x1F	; 31
    5ef8:	bf 4f       	sbci	r27, 0xFF	; 255
    5efa:	4d 91       	ld	r20, X+
    5efc:	5d 91       	ld	r21, X+
    5efe:	6d 91       	ld	r22, X+
    5f00:	7c 91       	ld	r23, X
    5f02:	d9 01       	movw	r26, r18
    5f04:	4d 93       	st	X+, r20
    5f06:	5d 93       	st	X+, r21
    5f08:	6d 93       	st	X+, r22
    5f0a:	7c 93       	st	X, r23
    5f0c:	13 97       	sbiw	r26, 0x03	; 3
    5f0e:	9f 01       	movw	r18, r30
    5f10:	2f 51       	subi	r18, 0x1F	; 31
    5f12:	3f 4f       	sbci	r19, 0xFF	; 255
    5f14:	de 01       	movw	r26, r28
    5f16:	ab 51       	subi	r26, 0x1B	; 27
    5f18:	bf 4f       	sbci	r27, 0xFF	; 255
    5f1a:	4d 91       	ld	r20, X+
    5f1c:	5d 91       	ld	r21, X+
    5f1e:	6d 91       	ld	r22, X+
    5f20:	7c 91       	ld	r23, X
    5f22:	d9 01       	movw	r26, r18
    5f24:	4d 93       	st	X+, r20
    5f26:	5d 93       	st	X+, r21
    5f28:	6d 93       	st	X+, r22
    5f2a:	7c 93       	st	X, r23
    5f2c:	13 97       	sbiw	r26, 0x03	; 3
    5f2e:	9f 01       	movw	r18, r30
    5f30:	2b 51       	subi	r18, 0x1B	; 27
    5f32:	3f 4f       	sbci	r19, 0xFF	; 255
    5f34:	de 01       	movw	r26, r28
    5f36:	a7 51       	subi	r26, 0x17	; 23
    5f38:	bf 4f       	sbci	r27, 0xFF	; 255
    5f3a:	4d 91       	ld	r20, X+
    5f3c:	5d 91       	ld	r21, X+
    5f3e:	6d 91       	ld	r22, X+
    5f40:	7c 91       	ld	r23, X
    5f42:	d9 01       	movw	r26, r18
    5f44:	4d 93       	st	X+, r20
    5f46:	5d 93       	st	X+, r21
    5f48:	6d 93       	st	X+, r22
    5f4a:	7c 93       	st	X, r23
    5f4c:	13 97       	sbiw	r26, 0x03	; 3
    5f4e:	9f 01       	movw	r18, r30
    5f50:	27 51       	subi	r18, 0x17	; 23
    5f52:	3f 4f       	sbci	r19, 0xFF	; 255
    5f54:	de 01       	movw	r26, r28
    5f56:	a3 51       	subi	r26, 0x13	; 19
    5f58:	bf 4f       	sbci	r27, 0xFF	; 255
    5f5a:	4d 91       	ld	r20, X+
    5f5c:	5d 91       	ld	r21, X+
    5f5e:	6d 91       	ld	r22, X+
    5f60:	7c 91       	ld	r23, X
    5f62:	d9 01       	movw	r26, r18
    5f64:	4d 93       	st	X+, r20
    5f66:	5d 93       	st	X+, r21
    5f68:	6d 93       	st	X+, r22
    5f6a:	7c 93       	st	X, r23
    5f6c:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    5f6e:	9f 01       	movw	r18, r30
    5f70:	23 51       	subi	r18, 0x13	; 19
    5f72:	3f 4f       	sbci	r19, 0xFF	; 255
    5f74:	de 01       	movw	r26, r28
    5f76:	af 50       	subi	r26, 0x0F	; 15
    5f78:	bf 4f       	sbci	r27, 0xFF	; 255
    5f7a:	4d 91       	ld	r20, X+
    5f7c:	5d 91       	ld	r21, X+
    5f7e:	6d 91       	ld	r22, X+
    5f80:	7c 91       	ld	r23, X
    5f82:	d9 01       	movw	r26, r18
    5f84:	4d 93       	st	X+, r20
    5f86:	5d 93       	st	X+, r21
    5f88:	6d 93       	st	X+, r22
    5f8a:	7c 93       	st	X, r23
    5f8c:	13 97       	sbiw	r26, 0x03	; 3
    5f8e:	9f 01       	movw	r18, r30
    5f90:	2f 50       	subi	r18, 0x0F	; 15
    5f92:	3f 4f       	sbci	r19, 0xFF	; 255
    5f94:	de 01       	movw	r26, r28
    5f96:	ab 50       	subi	r26, 0x0B	; 11
    5f98:	bf 4f       	sbci	r27, 0xFF	; 255
    5f9a:	4d 91       	ld	r20, X+
    5f9c:	5d 91       	ld	r21, X+
    5f9e:	6d 91       	ld	r22, X+
    5fa0:	7c 91       	ld	r23, X
    5fa2:	d9 01       	movw	r26, r18
    5fa4:	4d 93       	st	X+, r20
    5fa6:	5d 93       	st	X+, r21
    5fa8:	6d 93       	st	X+, r22
    5faa:	7c 93       	st	X, r23
    5fac:	13 97       	sbiw	r26, 0x03	; 3
    5fae:	9f 01       	movw	r18, r30
    5fb0:	2b 50       	subi	r18, 0x0B	; 11
    5fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5fb4:	de 01       	movw	r26, r28
    5fb6:	a7 50       	subi	r26, 0x07	; 7
    5fb8:	bf 4f       	sbci	r27, 0xFF	; 255
    5fba:	4d 91       	ld	r20, X+
    5fbc:	5d 91       	ld	r21, X+
    5fbe:	6d 91       	ld	r22, X+
    5fc0:	7c 91       	ld	r23, X
    5fc2:	d9 01       	movw	r26, r18
    5fc4:	4d 93       	st	X+, r20
    5fc6:	5d 93       	st	X+, r21
    5fc8:	6d 93       	st	X+, r22
    5fca:	7c 93       	st	X, r23
    5fcc:	13 97       	sbiw	r26, 0x03	; 3
    5fce:	9f 01       	movw	r18, r30
    5fd0:	27 50       	subi	r18, 0x07	; 7
    5fd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5fd4:	de 01       	movw	r26, r28
    5fd6:	a3 50       	subi	r26, 0x03	; 3
    5fd8:	bf 4f       	sbci	r27, 0xFF	; 255
    5fda:	4d 91       	ld	r20, X+
    5fdc:	5d 91       	ld	r21, X+
    5fde:	6d 91       	ld	r22, X+
    5fe0:	7c 91       	ld	r23, X
    5fe2:	d9 01       	movw	r26, r18
    5fe4:	4d 93       	st	X+, r20
    5fe6:	5d 93       	st	X+, r21
    5fe8:	6d 93       	st	X+, r22
    5fea:	7c 93       	st	X, r23
    5fec:	13 97       	sbiw	r26, 0x03	; 3
    5fee:	9f 01       	movw	r18, r30
    5ff0:	23 50       	subi	r18, 0x03	; 3
    5ff2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ff4:	de 01       	movw	r26, r28
    5ff6:	af 5f       	subi	r26, 0xFF	; 255
    5ff8:	be 4f       	sbci	r27, 0xFE	; 254
    5ffa:	4d 91       	ld	r20, X+
    5ffc:	5d 91       	ld	r21, X+
    5ffe:	6d 91       	ld	r22, X+
    6000:	7c 91       	ld	r23, X
    6002:	d9 01       	movw	r26, r18
    6004:	4d 93       	st	X+, r20
    6006:	5d 93       	st	X+, r21
    6008:	6d 93       	st	X+, r22
    600a:	7c 93       	st	X, r23
    600c:	13 97       	sbiw	r26, 0x03	; 3
    600e:	9f 01       	movw	r18, r30
    6010:	2f 5f       	subi	r18, 0xFF	; 255
    6012:	3e 4f       	sbci	r19, 0xFE	; 254
    6014:	de 01       	movw	r26, r28
    6016:	ab 5f       	subi	r26, 0xFB	; 251
    6018:	be 4f       	sbci	r27, 0xFE	; 254
    601a:	4d 91       	ld	r20, X+
    601c:	5d 91       	ld	r21, X+
    601e:	6d 91       	ld	r22, X+
    6020:	7c 91       	ld	r23, X
    6022:	d9 01       	movw	r26, r18
    6024:	4d 93       	st	X+, r20
    6026:	5d 93       	st	X+, r21
    6028:	6d 93       	st	X+, r22
    602a:	7c 93       	st	X, r23
    602c:	13 97       	sbiw	r26, 0x03	; 3
					buffPtr += sizeof(val);
				}
				
				void encode (byte *&buffPtr, float &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    602e:	9f 01       	movw	r18, r30
    6030:	2b 5f       	subi	r18, 0xFB	; 251
    6032:	3e 4f       	sbci	r19, 0xFE	; 254
    6034:	de 01       	movw	r26, r28
    6036:	a7 5f       	subi	r26, 0xF7	; 247
    6038:	be 4f       	sbci	r27, 0xFE	; 254
    603a:	4d 91       	ld	r20, X+
    603c:	5d 91       	ld	r21, X+
    603e:	6d 91       	ld	r22, X+
    6040:	7c 91       	ld	r23, X
    6042:	d9 01       	movw	r26, r18
    6044:	4d 93       	st	X+, r20
    6046:	5d 93       	st	X+, r21
    6048:	6d 93       	st	X+, r22
    604a:	7c 93       	st	X, r23
    604c:	13 97       	sbiw	r26, 0x03	; 3
    604e:	9f 01       	movw	r18, r30
    6050:	27 5f       	subi	r18, 0xF7	; 247
    6052:	3e 4f       	sbci	r19, 0xFE	; 254
    6054:	de 01       	movw	r26, r28
    6056:	a3 5f       	subi	r26, 0xF3	; 243
    6058:	be 4f       	sbci	r27, 0xFE	; 254
    605a:	4d 91       	ld	r20, X+
    605c:	5d 91       	ld	r21, X+
    605e:	6d 91       	ld	r22, X+
    6060:	7c 91       	ld	r23, X
    6062:	d9 01       	movw	r26, r18
    6064:	4d 93       	st	X+, r20
    6066:	5d 93       	st	X+, r21
    6068:	6d 93       	st	X+, r22
    606a:	7c 93       	st	X, r23
    606c:	13 97       	sbiw	r26, 0x03	; 3
    606e:	9f 01       	movw	r18, r30
    6070:	23 5f       	subi	r18, 0xF3	; 243
    6072:	3e 4f       	sbci	r19, 0xFE	; 254
    6074:	de 01       	movw	r26, r28
    6076:	af 5e       	subi	r26, 0xEF	; 239
    6078:	be 4f       	sbci	r27, 0xFE	; 254
    607a:	4d 91       	ld	r20, X+
    607c:	5d 91       	ld	r21, X+
    607e:	6d 91       	ld	r22, X+
    6080:	7c 91       	ld	r23, X
    6082:	d9 01       	movw	r26, r18
    6084:	4d 93       	st	X+, r20
    6086:	5d 93       	st	X+, r21
    6088:	6d 93       	st	X+, r22
    608a:	7c 93       	st	X, r23
    608c:	13 97       	sbiw	r26, 0x03	; 3
    608e:	9f 01       	movw	r18, r30
    6090:	2f 5e       	subi	r18, 0xEF	; 239
    6092:	3e 4f       	sbci	r19, 0xFE	; 254
    6094:	de 01       	movw	r26, r28
    6096:	ab 5e       	subi	r26, 0xEB	; 235
    6098:	be 4f       	sbci	r27, 0xFE	; 254
    609a:	4d 91       	ld	r20, X+
    609c:	5d 91       	ld	r21, X+
    609e:	6d 91       	ld	r22, X+
    60a0:	7c 91       	ld	r23, X
    60a2:	d9 01       	movw	r26, r18
    60a4:	4d 93       	st	X+, r20
    60a6:	5d 93       	st	X+, r21
    60a8:	6d 93       	st	X+, r22
    60aa:	7c 93       	st	X, r23
    60ac:	13 97       	sbiw	r26, 0x03	; 3
    60ae:	9f 01       	movw	r18, r30
    60b0:	2b 5e       	subi	r18, 0xEB	; 235
    60b2:	3e 4f       	sbci	r19, 0xFE	; 254
    60b4:	de 01       	movw	r26, r28
    60b6:	a7 5e       	subi	r26, 0xE7	; 231
    60b8:	be 4f       	sbci	r27, 0xFE	; 254
    60ba:	4d 91       	ld	r20, X+
    60bc:	5d 91       	ld	r21, X+
    60be:	6d 91       	ld	r22, X+
    60c0:	7c 91       	ld	r23, X
    60c2:	d9 01       	movw	r26, r18
    60c4:	4d 93       	st	X+, r20
    60c6:	5d 93       	st	X+, r21
    60c8:	6d 93       	st	X+, r22
    60ca:	7c 93       	st	X, r23
    60cc:	13 97       	sbiw	r26, 0x03	; 3
				 * Mem copies the value into the buffer pointer then increments
				 * the pointer location by the size of the value copied.
				 */
				void encode (byte *&buffPtr, long &val)
				{
					memcpy(buffPtr, &val, sizeof(val));
    60ce:	9f 01       	movw	r18, r30
    60d0:	27 5e       	subi	r18, 0xE7	; 231
    60d2:	3e 4f       	sbci	r19, 0xFE	; 254
    60d4:	de 01       	movw	r26, r28
    60d6:	a3 5e       	subi	r26, 0xE3	; 227
    60d8:	be 4f       	sbci	r27, 0xFE	; 254
    60da:	4d 91       	ld	r20, X+
    60dc:	5d 91       	ld	r21, X+
    60de:	6d 91       	ld	r22, X+
    60e0:	7c 91       	ld	r23, X
    60e2:	d9 01       	movw	r26, r18
    60e4:	4d 93       	st	X+, r20
    60e6:	5d 93       	st	X+, r21
    60e8:	6d 93       	st	X+, r22
    60ea:	7c 93       	st	X, r23
    60ec:	13 97       	sbiw	r26, 0x03	; 3
    60ee:	9f 01       	movw	r18, r30
    60f0:	23 5e       	subi	r18, 0xE3	; 227
    60f2:	3e 4f       	sbci	r19, 0xFE	; 254
    60f4:	de 01       	movw	r26, r28
    60f6:	af 5d       	subi	r26, 0xDF	; 223
    60f8:	be 4f       	sbci	r27, 0xFE	; 254
    60fa:	4d 91       	ld	r20, X+
    60fc:	5d 91       	ld	r21, X+
    60fe:	6d 91       	ld	r22, X+
    6100:	7c 91       	ld	r23, X
    6102:	d9 01       	movw	r26, r18
    6104:	4d 93       	st	X+, r20
    6106:	5d 93       	st	X+, r21
    6108:	6d 93       	st	X+, r22
    610a:	7c 93       	st	X, r23
    610c:	13 97       	sbiw	r26, 0x03	; 3
    610e:	9f 01       	movw	r18, r30
    6110:	2f 5d       	subi	r18, 0xDF	; 223
    6112:	3e 4f       	sbci	r19, 0xFE	; 254
    6114:	ce 01       	movw	r24, r28
    6116:	8b 5d       	subi	r24, 0xDB	; 219
    6118:	9e 4f       	sbci	r25, 0xFE	; 254
    611a:	dc 01       	movw	r26, r24
    611c:	4d 91       	ld	r20, X+
    611e:	5d 91       	ld	r21, X+
    6120:	6d 91       	ld	r22, X+
    6122:	7c 91       	ld	r23, X
    6124:	d9 01       	movw	r26, r18
    6126:	4d 93       	st	X+, r20
    6128:	5d 93       	st	X+, r21
    612a:	6d 93       	st	X+, r22
    612c:	7c 93       	st	X, r23
    612e:	13 97       	sbiw	r26, 0x03	; 3
    6130:	9f 01       	movw	r18, r30
    6132:	2b 5d       	subi	r18, 0xDB	; 219
    6134:	3e 4f       	sbci	r19, 0xFE	; 254
    6136:	ce 01       	movw	r24, r28
    6138:	87 5d       	subi	r24, 0xD7	; 215
    613a:	9e 4f       	sbci	r25, 0xFE	; 254
    613c:	dc 01       	movw	r26, r24
    613e:	4d 91       	ld	r20, X+
    6140:	5d 91       	ld	r21, X+
    6142:	6d 91       	ld	r22, X+
    6144:	7c 91       	ld	r23, X
    6146:	d9 01       	movw	r26, r18
    6148:	4d 93       	st	X+, r20
    614a:	5d 93       	st	X+, r21
    614c:	6d 93       	st	X+, r22
    614e:	7c 93       	st	X, r23
    6150:	13 97       	sbiw	r26, 0x03	; 3
    6152:	df 01       	movw	r26, r30
    6154:	a7 5d       	subi	r26, 0xD7	; 215
    6156:	be 4f       	sbci	r27, 0xFE	; 254
    6158:	c3 5d       	subi	r28, 0xD3	; 211
    615a:	de 4f       	sbci	r29, 0xFE	; 254
    615c:	48 81       	ld	r20, Y
    615e:	59 81       	ldd	r21, Y+1	; 0x01
    6160:	6a 81       	ldd	r22, Y+2	; 0x02
    6162:	7b 81       	ldd	r23, Y+3	; 0x03
    6164:	4d 93       	st	X+, r20
    6166:	5d 93       	st	X+, r21
    6168:	6d 93       	st	X+, r22
    616a:	7c 93       	st	X, r23
    616c:	13 97       	sbiw	r26, 0x03	; 3
	encode (msgPtr, ChecksumErrors);
	encode (msgPtr, NumOfBlownFrames);
	encode (msgPtr, SerialCommunicationBufferOverruns);
				
	return msg;
}
    616e:	8e 2f       	mov	r24, r30
    6170:	9f 2f       	mov	r25, r31
    6172:	df 91       	pop	r29
    6174:	cf 91       	pop	r28
    6176:	08 95       	ret

00006178 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>:

void SystemTelemetryMessage::buildMessage(byte *message)
{
    6178:	cf 93       	push	r28
    617a:	df 93       	push	r29
    617c:	fc 01       	movw	r30, r24
    617e:	db 01       	movw	r26, r22
	if (message != NULL)
    6180:	10 97       	sbiw	r26, 0x00	; 0
    6182:	09 f4       	brne	.+2      	; 0x6186 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0xe>
    6184:	55 c4       	rjmp	.+2218   	; 0x6a30 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh+0x8b8>
				 * Copies the the value at the buff pointer location into the given val parameter and
				 * increments the buffer by the sizeof(val)
				 */
				void decode (byte *&buffPtr, byte &val)
				{
					val = *buffPtr;
    6186:	8c 91       	ld	r24, X
    6188:	82 83       	std	Z+2, r24	; 0x02
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    618a:	11 96       	adiw	r26, 0x01	; 1
    618c:	4d 91       	ld	r20, X+
    618e:	5d 91       	ld	r21, X+
    6190:	6d 91       	ld	r22, X+
    6192:	7c 91       	ld	r23, X
    6194:	14 97       	sbiw	r26, 0x04	; 4
    6196:	45 83       	std	Z+5, r20	; 0x05
    6198:	56 83       	std	Z+6, r21	; 0x06
    619a:	67 83       	std	Z+7, r22	; 0x07
    619c:	70 87       	std	Z+8, r23	; 0x08
    619e:	15 96       	adiw	r26, 0x05	; 5
    61a0:	4d 91       	ld	r20, X+
    61a2:	5d 91       	ld	r21, X+
    61a4:	6d 91       	ld	r22, X+
    61a6:	7c 91       	ld	r23, X
    61a8:	18 97       	sbiw	r26, 0x08	; 8
    61aa:	41 87       	std	Z+9, r20	; 0x09
    61ac:	52 87       	std	Z+10, r21	; 0x0a
    61ae:	63 87       	std	Z+11, r22	; 0x0b
    61b0:	74 87       	std	Z+12, r23	; 0x0c
    61b2:	19 96       	adiw	r26, 0x09	; 9
    61b4:	4d 91       	ld	r20, X+
    61b6:	5d 91       	ld	r21, X+
    61b8:	6d 91       	ld	r22, X+
    61ba:	7c 91       	ld	r23, X
    61bc:	1c 97       	sbiw	r26, 0x0c	; 12
    61be:	45 87       	std	Z+13, r20	; 0x0d
    61c0:	56 87       	std	Z+14, r21	; 0x0e
    61c2:	67 87       	std	Z+15, r22	; 0x0f
    61c4:	70 8b       	std	Z+16, r23	; 0x10
    61c6:	1d 96       	adiw	r26, 0x0d	; 13
    61c8:	4d 91       	ld	r20, X+
    61ca:	5d 91       	ld	r21, X+
    61cc:	6d 91       	ld	r22, X+
    61ce:	7c 91       	ld	r23, X
    61d0:	50 97       	sbiw	r26, 0x10	; 16
    61d2:	41 8b       	std	Z+17, r20	; 0x11
    61d4:	52 8b       	std	Z+18, r21	; 0x12
    61d6:	63 8b       	std	Z+19, r22	; 0x13
    61d8:	74 8b       	std	Z+20, r23	; 0x14
    61da:	51 96       	adiw	r26, 0x11	; 17
    61dc:	4d 91       	ld	r20, X+
    61de:	5d 91       	ld	r21, X+
    61e0:	6d 91       	ld	r22, X+
    61e2:	7c 91       	ld	r23, X
    61e4:	54 97       	sbiw	r26, 0x14	; 20
    61e6:	45 8b       	std	Z+21, r20	; 0x15
    61e8:	56 8b       	std	Z+22, r21	; 0x16
    61ea:	67 8b       	std	Z+23, r22	; 0x17
    61ec:	70 8f       	std	Z+24, r23	; 0x18
    61ee:	55 96       	adiw	r26, 0x15	; 21
    61f0:	4d 91       	ld	r20, X+
    61f2:	5d 91       	ld	r21, X+
    61f4:	6d 91       	ld	r22, X+
    61f6:	7c 91       	ld	r23, X
    61f8:	58 97       	sbiw	r26, 0x18	; 24
    61fa:	41 8f       	std	Z+25, r20	; 0x19
    61fc:	52 8f       	std	Z+26, r21	; 0x1a
    61fe:	63 8f       	std	Z+27, r22	; 0x1b
    6200:	74 8f       	std	Z+28, r23	; 0x1c
    6202:	59 96       	adiw	r26, 0x19	; 25
    6204:	4d 91       	ld	r20, X+
    6206:	5d 91       	ld	r21, X+
    6208:	6d 91       	ld	r22, X+
    620a:	7c 91       	ld	r23, X
    620c:	5c 97       	sbiw	r26, 0x1c	; 28
    620e:	45 8f       	std	Z+29, r20	; 0x1d
    6210:	56 8f       	std	Z+30, r21	; 0x1e
    6212:	67 8f       	std	Z+31, r22	; 0x1f
    6214:	70 a3       	std	Z+32, r23	; 0x20
    6216:	5d 96       	adiw	r26, 0x1d	; 29
    6218:	4d 91       	ld	r20, X+
    621a:	5d 91       	ld	r21, X+
    621c:	6d 91       	ld	r22, X+
    621e:	7c 91       	ld	r23, X
    6220:	90 97       	sbiw	r26, 0x20	; 32
    6222:	41 a3       	std	Z+33, r20	; 0x21
    6224:	52 a3       	std	Z+34, r21	; 0x22
    6226:	63 a3       	std	Z+35, r22	; 0x23
    6228:	74 a3       	std	Z+36, r23	; 0x24
    622a:	91 96       	adiw	r26, 0x21	; 33
    622c:	4d 91       	ld	r20, X+
    622e:	5d 91       	ld	r21, X+
    6230:	6d 91       	ld	r22, X+
    6232:	7c 91       	ld	r23, X
    6234:	94 97       	sbiw	r26, 0x24	; 36
    6236:	45 a3       	std	Z+37, r20	; 0x25
    6238:	56 a3       	std	Z+38, r21	; 0x26
    623a:	67 a3       	std	Z+39, r22	; 0x27
    623c:	70 a7       	std	Z+40, r23	; 0x28
    623e:	95 96       	adiw	r26, 0x25	; 37
    6240:	4d 91       	ld	r20, X+
    6242:	5d 91       	ld	r21, X+
    6244:	6d 91       	ld	r22, X+
    6246:	7c 91       	ld	r23, X
    6248:	98 97       	sbiw	r26, 0x28	; 40
    624a:	41 a7       	std	Z+41, r20	; 0x29
    624c:	52 a7       	std	Z+42, r21	; 0x2a
    624e:	63 a7       	std	Z+43, r22	; 0x2b
    6250:	74 a7       	std	Z+44, r23	; 0x2c
    6252:	99 96       	adiw	r26, 0x29	; 41
    6254:	4d 91       	ld	r20, X+
    6256:	5d 91       	ld	r21, X+
    6258:	6d 91       	ld	r22, X+
    625a:	7c 91       	ld	r23, X
    625c:	9c 97       	sbiw	r26, 0x2c	; 44
    625e:	45 a7       	std	Z+45, r20	; 0x2d
    6260:	56 a7       	std	Z+46, r21	; 0x2e
    6262:	67 a7       	std	Z+47, r22	; 0x2f
    6264:	70 ab       	std	Z+48, r23	; 0x30
    6266:	9d 96       	adiw	r26, 0x2d	; 45
    6268:	4d 91       	ld	r20, X+
    626a:	5d 91       	ld	r21, X+
    626c:	6d 91       	ld	r22, X+
    626e:	7c 91       	ld	r23, X
    6270:	d0 97       	sbiw	r26, 0x30	; 48
    6272:	41 ab       	std	Z+49, r20	; 0x31
    6274:	52 ab       	std	Z+50, r21	; 0x32
    6276:	63 ab       	std	Z+51, r22	; 0x33
    6278:	74 ab       	std	Z+52, r23	; 0x34
    627a:	d1 96       	adiw	r26, 0x31	; 49
    627c:	4d 91       	ld	r20, X+
    627e:	5d 91       	ld	r21, X+
    6280:	6d 91       	ld	r22, X+
    6282:	7c 91       	ld	r23, X
    6284:	d4 97       	sbiw	r26, 0x34	; 52
    6286:	45 ab       	std	Z+53, r20	; 0x35
    6288:	56 ab       	std	Z+54, r21	; 0x36
    628a:	67 ab       	std	Z+55, r22	; 0x37
    628c:	70 af       	std	Z+56, r23	; 0x38
    628e:	d5 96       	adiw	r26, 0x35	; 53
    6290:	4d 91       	ld	r20, X+
    6292:	5d 91       	ld	r21, X+
    6294:	6d 91       	ld	r22, X+
    6296:	7c 91       	ld	r23, X
    6298:	d8 97       	sbiw	r26, 0x38	; 56
    629a:	41 af       	std	Z+57, r20	; 0x39
    629c:	52 af       	std	Z+58, r21	; 0x3a
    629e:	63 af       	std	Z+59, r22	; 0x3b
    62a0:	74 af       	std	Z+60, r23	; 0x3c
    62a2:	ef 01       	movw	r28, r30
    62a4:	ed 96       	adiw	r28, 0x3d	; 61
    62a6:	d9 96       	adiw	r26, 0x39	; 57
    62a8:	4d 91       	ld	r20, X+
    62aa:	5d 91       	ld	r21, X+
    62ac:	6d 91       	ld	r22, X+
    62ae:	7c 91       	ld	r23, X
    62b0:	dc 97       	sbiw	r26, 0x3c	; 60
    62b2:	48 83       	st	Y, r20
    62b4:	59 83       	std	Y+1, r21	; 0x01
    62b6:	6a 83       	std	Y+2, r22	; 0x02
    62b8:	7b 83       	std	Y+3, r23	; 0x03
    62ba:	9f 01       	movw	r18, r30
    62bc:	2f 5b       	subi	r18, 0xBF	; 191
    62be:	3f 4f       	sbci	r19, 0xFF	; 255
    62c0:	cd 01       	movw	r24, r26
    62c2:	cd 96       	adiw	r24, 0x3d	; 61
    62c4:	ec 01       	movw	r28, r24
    62c6:	48 81       	ld	r20, Y
    62c8:	59 81       	ldd	r21, Y+1	; 0x01
    62ca:	6a 81       	ldd	r22, Y+2	; 0x02
    62cc:	7b 81       	ldd	r23, Y+3	; 0x03
    62ce:	e9 01       	movw	r28, r18
    62d0:	48 83       	st	Y, r20
    62d2:	59 83       	std	Y+1, r21	; 0x01
    62d4:	6a 83       	std	Y+2, r22	; 0x02
    62d6:	7b 83       	std	Y+3, r23	; 0x03
    62d8:	9f 01       	movw	r18, r30
    62da:	2b 5b       	subi	r18, 0xBB	; 187
    62dc:	3f 4f       	sbci	r19, 0xFF	; 255
    62de:	cd 01       	movw	r24, r26
    62e0:	8f 5b       	subi	r24, 0xBF	; 191
    62e2:	9f 4f       	sbci	r25, 0xFF	; 255
    62e4:	ec 01       	movw	r28, r24
    62e6:	48 81       	ld	r20, Y
    62e8:	59 81       	ldd	r21, Y+1	; 0x01
    62ea:	6a 81       	ldd	r22, Y+2	; 0x02
    62ec:	7b 81       	ldd	r23, Y+3	; 0x03
    62ee:	e9 01       	movw	r28, r18
    62f0:	48 83       	st	Y, r20
    62f2:	59 83       	std	Y+1, r21	; 0x01
    62f4:	6a 83       	std	Y+2, r22	; 0x02
    62f6:	7b 83       	std	Y+3, r23	; 0x03
    62f8:	9f 01       	movw	r18, r30
    62fa:	27 5b       	subi	r18, 0xB7	; 183
    62fc:	3f 4f       	sbci	r19, 0xFF	; 255
    62fe:	cd 01       	movw	r24, r26
    6300:	8b 5b       	subi	r24, 0xBB	; 187
    6302:	9f 4f       	sbci	r25, 0xFF	; 255
    6304:	ec 01       	movw	r28, r24
    6306:	48 81       	ld	r20, Y
    6308:	59 81       	ldd	r21, Y+1	; 0x01
    630a:	6a 81       	ldd	r22, Y+2	; 0x02
    630c:	7b 81       	ldd	r23, Y+3	; 0x03
    630e:	e9 01       	movw	r28, r18
    6310:	48 83       	st	Y, r20
    6312:	59 83       	std	Y+1, r21	; 0x01
    6314:	6a 83       	std	Y+2, r22	; 0x02
    6316:	7b 83       	std	Y+3, r23	; 0x03
    6318:	9f 01       	movw	r18, r30
    631a:	23 5b       	subi	r18, 0xB3	; 179
    631c:	3f 4f       	sbci	r19, 0xFF	; 255
    631e:	cd 01       	movw	r24, r26
    6320:	87 5b       	subi	r24, 0xB7	; 183
    6322:	9f 4f       	sbci	r25, 0xFF	; 255
    6324:	ec 01       	movw	r28, r24
    6326:	48 81       	ld	r20, Y
    6328:	59 81       	ldd	r21, Y+1	; 0x01
    632a:	6a 81       	ldd	r22, Y+2	; 0x02
    632c:	7b 81       	ldd	r23, Y+3	; 0x03
    632e:	e9 01       	movw	r28, r18
    6330:	48 83       	st	Y, r20
    6332:	59 83       	std	Y+1, r21	; 0x01
    6334:	6a 83       	std	Y+2, r22	; 0x02
    6336:	7b 83       	std	Y+3, r23	; 0x03
    6338:	9f 01       	movw	r18, r30
    633a:	2f 5a       	subi	r18, 0xAF	; 175
    633c:	3f 4f       	sbci	r19, 0xFF	; 255
    633e:	cd 01       	movw	r24, r26
    6340:	83 5b       	subi	r24, 0xB3	; 179
    6342:	9f 4f       	sbci	r25, 0xFF	; 255
    6344:	ec 01       	movw	r28, r24
    6346:	48 81       	ld	r20, Y
    6348:	59 81       	ldd	r21, Y+1	; 0x01
    634a:	6a 81       	ldd	r22, Y+2	; 0x02
    634c:	7b 81       	ldd	r23, Y+3	; 0x03
    634e:	e9 01       	movw	r28, r18
    6350:	48 83       	st	Y, r20
    6352:	59 83       	std	Y+1, r21	; 0x01
    6354:	6a 83       	std	Y+2, r22	; 0x02
    6356:	7b 83       	std	Y+3, r23	; 0x03
    6358:	9f 01       	movw	r18, r30
    635a:	2b 5a       	subi	r18, 0xAB	; 171
    635c:	3f 4f       	sbci	r19, 0xFF	; 255
    635e:	cd 01       	movw	r24, r26
    6360:	8f 5a       	subi	r24, 0xAF	; 175
    6362:	9f 4f       	sbci	r25, 0xFF	; 255
    6364:	ec 01       	movw	r28, r24
    6366:	48 81       	ld	r20, Y
    6368:	59 81       	ldd	r21, Y+1	; 0x01
    636a:	6a 81       	ldd	r22, Y+2	; 0x02
    636c:	7b 81       	ldd	r23, Y+3	; 0x03
    636e:	e9 01       	movw	r28, r18
    6370:	48 83       	st	Y, r20
    6372:	59 83       	std	Y+1, r21	; 0x01
    6374:	6a 83       	std	Y+2, r22	; 0x02
    6376:	7b 83       	std	Y+3, r23	; 0x03
    6378:	9f 01       	movw	r18, r30
    637a:	27 5a       	subi	r18, 0xA7	; 167
    637c:	3f 4f       	sbci	r19, 0xFF	; 255
    637e:	cd 01       	movw	r24, r26
    6380:	8b 5a       	subi	r24, 0xAB	; 171
    6382:	9f 4f       	sbci	r25, 0xFF	; 255
    6384:	ec 01       	movw	r28, r24
    6386:	48 81       	ld	r20, Y
    6388:	59 81       	ldd	r21, Y+1	; 0x01
    638a:	6a 81       	ldd	r22, Y+2	; 0x02
    638c:	7b 81       	ldd	r23, Y+3	; 0x03
    638e:	e9 01       	movw	r28, r18
    6390:	48 83       	st	Y, r20
    6392:	59 83       	std	Y+1, r21	; 0x01
    6394:	6a 83       	std	Y+2, r22	; 0x02
    6396:	7b 83       	std	Y+3, r23	; 0x03
    6398:	9f 01       	movw	r18, r30
    639a:	23 5a       	subi	r18, 0xA3	; 163
    639c:	3f 4f       	sbci	r19, 0xFF	; 255
    639e:	cd 01       	movw	r24, r26
    63a0:	87 5a       	subi	r24, 0xA7	; 167
    63a2:	9f 4f       	sbci	r25, 0xFF	; 255
    63a4:	ec 01       	movw	r28, r24
    63a6:	48 81       	ld	r20, Y
    63a8:	59 81       	ldd	r21, Y+1	; 0x01
    63aa:	6a 81       	ldd	r22, Y+2	; 0x02
    63ac:	7b 81       	ldd	r23, Y+3	; 0x03
    63ae:	e9 01       	movw	r28, r18
    63b0:	48 83       	st	Y, r20
    63b2:	59 83       	std	Y+1, r21	; 0x01
    63b4:	6a 83       	std	Y+2, r22	; 0x02
    63b6:	7b 83       	std	Y+3, r23	; 0x03
    63b8:	9f 01       	movw	r18, r30
    63ba:	2f 59       	subi	r18, 0x9F	; 159
    63bc:	3f 4f       	sbci	r19, 0xFF	; 255
    63be:	cd 01       	movw	r24, r26
    63c0:	83 5a       	subi	r24, 0xA3	; 163
    63c2:	9f 4f       	sbci	r25, 0xFF	; 255
    63c4:	ec 01       	movw	r28, r24
    63c6:	48 81       	ld	r20, Y
    63c8:	59 81       	ldd	r21, Y+1	; 0x01
    63ca:	6a 81       	ldd	r22, Y+2	; 0x02
    63cc:	7b 81       	ldd	r23, Y+3	; 0x03
    63ce:	e9 01       	movw	r28, r18
    63d0:	48 83       	st	Y, r20
    63d2:	59 83       	std	Y+1, r21	; 0x01
    63d4:	6a 83       	std	Y+2, r22	; 0x02
    63d6:	7b 83       	std	Y+3, r23	; 0x03
    63d8:	9f 01       	movw	r18, r30
    63da:	2b 59       	subi	r18, 0x9B	; 155
    63dc:	3f 4f       	sbci	r19, 0xFF	; 255
    63de:	cd 01       	movw	r24, r26
    63e0:	8f 59       	subi	r24, 0x9F	; 159
    63e2:	9f 4f       	sbci	r25, 0xFF	; 255
    63e4:	ec 01       	movw	r28, r24
    63e6:	48 81       	ld	r20, Y
    63e8:	59 81       	ldd	r21, Y+1	; 0x01
    63ea:	6a 81       	ldd	r22, Y+2	; 0x02
    63ec:	7b 81       	ldd	r23, Y+3	; 0x03
    63ee:	e9 01       	movw	r28, r18
    63f0:	48 83       	st	Y, r20
    63f2:	59 83       	std	Y+1, r21	; 0x01
    63f4:	6a 83       	std	Y+2, r22	; 0x02
    63f6:	7b 83       	std	Y+3, r23	; 0x03
    63f8:	9f 01       	movw	r18, r30
    63fa:	27 59       	subi	r18, 0x97	; 151
    63fc:	3f 4f       	sbci	r19, 0xFF	; 255
    63fe:	cd 01       	movw	r24, r26
    6400:	8b 59       	subi	r24, 0x9B	; 155
    6402:	9f 4f       	sbci	r25, 0xFF	; 255
    6404:	ec 01       	movw	r28, r24
    6406:	48 81       	ld	r20, Y
    6408:	59 81       	ldd	r21, Y+1	; 0x01
    640a:	6a 81       	ldd	r22, Y+2	; 0x02
    640c:	7b 81       	ldd	r23, Y+3	; 0x03
    640e:	e9 01       	movw	r28, r18
    6410:	48 83       	st	Y, r20
    6412:	59 83       	std	Y+1, r21	; 0x01
    6414:	6a 83       	std	Y+2, r22	; 0x02
    6416:	7b 83       	std	Y+3, r23	; 0x03
    6418:	9f 01       	movw	r18, r30
    641a:	23 59       	subi	r18, 0x93	; 147
    641c:	3f 4f       	sbci	r19, 0xFF	; 255
    641e:	cd 01       	movw	r24, r26
    6420:	87 59       	subi	r24, 0x97	; 151
    6422:	9f 4f       	sbci	r25, 0xFF	; 255
    6424:	ec 01       	movw	r28, r24
    6426:	48 81       	ld	r20, Y
    6428:	59 81       	ldd	r21, Y+1	; 0x01
    642a:	6a 81       	ldd	r22, Y+2	; 0x02
    642c:	7b 81       	ldd	r23, Y+3	; 0x03
    642e:	e9 01       	movw	r28, r18
    6430:	48 83       	st	Y, r20
    6432:	59 83       	std	Y+1, r21	; 0x01
    6434:	6a 83       	std	Y+2, r22	; 0x02
    6436:	7b 83       	std	Y+3, r23	; 0x03
    6438:	9f 01       	movw	r18, r30
    643a:	2f 58       	subi	r18, 0x8F	; 143
    643c:	3f 4f       	sbci	r19, 0xFF	; 255
    643e:	cd 01       	movw	r24, r26
    6440:	83 59       	subi	r24, 0x93	; 147
    6442:	9f 4f       	sbci	r25, 0xFF	; 255
    6444:	ec 01       	movw	r28, r24
    6446:	48 81       	ld	r20, Y
    6448:	59 81       	ldd	r21, Y+1	; 0x01
    644a:	6a 81       	ldd	r22, Y+2	; 0x02
    644c:	7b 81       	ldd	r23, Y+3	; 0x03
    644e:	e9 01       	movw	r28, r18
    6450:	48 83       	st	Y, r20
    6452:	59 83       	std	Y+1, r21	; 0x01
    6454:	6a 83       	std	Y+2, r22	; 0x02
    6456:	7b 83       	std	Y+3, r23	; 0x03
    6458:	9f 01       	movw	r18, r30
    645a:	2b 58       	subi	r18, 0x8B	; 139
    645c:	3f 4f       	sbci	r19, 0xFF	; 255
    645e:	cd 01       	movw	r24, r26
    6460:	8f 58       	subi	r24, 0x8F	; 143
    6462:	9f 4f       	sbci	r25, 0xFF	; 255
    6464:	ec 01       	movw	r28, r24
    6466:	48 81       	ld	r20, Y
    6468:	59 81       	ldd	r21, Y+1	; 0x01
    646a:	6a 81       	ldd	r22, Y+2	; 0x02
    646c:	7b 81       	ldd	r23, Y+3	; 0x03
    646e:	e9 01       	movw	r28, r18
    6470:	48 83       	st	Y, r20
    6472:	59 83       	std	Y+1, r21	; 0x01
    6474:	6a 83       	std	Y+2, r22	; 0x02
    6476:	7b 83       	std	Y+3, r23	; 0x03
    6478:	9f 01       	movw	r18, r30
    647a:	27 58       	subi	r18, 0x87	; 135
    647c:	3f 4f       	sbci	r19, 0xFF	; 255
    647e:	cd 01       	movw	r24, r26
    6480:	8b 58       	subi	r24, 0x8B	; 139
    6482:	9f 4f       	sbci	r25, 0xFF	; 255
    6484:	ec 01       	movw	r28, r24
    6486:	48 81       	ld	r20, Y
    6488:	59 81       	ldd	r21, Y+1	; 0x01
    648a:	6a 81       	ldd	r22, Y+2	; 0x02
    648c:	7b 81       	ldd	r23, Y+3	; 0x03
    648e:	e9 01       	movw	r28, r18
    6490:	48 83       	st	Y, r20
    6492:	59 83       	std	Y+1, r21	; 0x01
    6494:	6a 83       	std	Y+2, r22	; 0x02
    6496:	7b 83       	std	Y+3, r23	; 0x03
    6498:	9f 01       	movw	r18, r30
    649a:	23 58       	subi	r18, 0x83	; 131
    649c:	3f 4f       	sbci	r19, 0xFF	; 255
    649e:	cd 01       	movw	r24, r26
    64a0:	87 58       	subi	r24, 0x87	; 135
    64a2:	9f 4f       	sbci	r25, 0xFF	; 255
    64a4:	ec 01       	movw	r28, r24
    64a6:	48 81       	ld	r20, Y
    64a8:	59 81       	ldd	r21, Y+1	; 0x01
    64aa:	6a 81       	ldd	r22, Y+2	; 0x02
    64ac:	7b 81       	ldd	r23, Y+3	; 0x03
    64ae:	e9 01       	movw	r28, r18
    64b0:	48 83       	st	Y, r20
    64b2:	59 83       	std	Y+1, r21	; 0x01
    64b4:	6a 83       	std	Y+2, r22	; 0x02
    64b6:	7b 83       	std	Y+3, r23	; 0x03
    64b8:	9f 01       	movw	r18, r30
    64ba:	2f 57       	subi	r18, 0x7F	; 127
    64bc:	3f 4f       	sbci	r19, 0xFF	; 255
    64be:	cd 01       	movw	r24, r26
    64c0:	83 58       	subi	r24, 0x83	; 131
    64c2:	9f 4f       	sbci	r25, 0xFF	; 255
    64c4:	ec 01       	movw	r28, r24
    64c6:	48 81       	ld	r20, Y
    64c8:	59 81       	ldd	r21, Y+1	; 0x01
    64ca:	6a 81       	ldd	r22, Y+2	; 0x02
    64cc:	7b 81       	ldd	r23, Y+3	; 0x03
    64ce:	e9 01       	movw	r28, r18
    64d0:	48 83       	st	Y, r20
    64d2:	59 83       	std	Y+1, r21	; 0x01
    64d4:	6a 83       	std	Y+2, r22	; 0x02
    64d6:	7b 83       	std	Y+3, r23	; 0x03
    64d8:	9f 01       	movw	r18, r30
    64da:	2b 57       	subi	r18, 0x7B	; 123
    64dc:	3f 4f       	sbci	r19, 0xFF	; 255
    64de:	cd 01       	movw	r24, r26
    64e0:	8f 57       	subi	r24, 0x7F	; 127
    64e2:	9f 4f       	sbci	r25, 0xFF	; 255
    64e4:	ec 01       	movw	r28, r24
    64e6:	48 81       	ld	r20, Y
    64e8:	59 81       	ldd	r21, Y+1	; 0x01
    64ea:	6a 81       	ldd	r22, Y+2	; 0x02
    64ec:	7b 81       	ldd	r23, Y+3	; 0x03
    64ee:	e9 01       	movw	r28, r18
    64f0:	48 83       	st	Y, r20
    64f2:	59 83       	std	Y+1, r21	; 0x01
    64f4:	6a 83       	std	Y+2, r22	; 0x02
    64f6:	7b 83       	std	Y+3, r23	; 0x03
    64f8:	9f 01       	movw	r18, r30
    64fa:	27 57       	subi	r18, 0x77	; 119
    64fc:	3f 4f       	sbci	r19, 0xFF	; 255
    64fe:	cd 01       	movw	r24, r26
    6500:	8b 57       	subi	r24, 0x7B	; 123
    6502:	9f 4f       	sbci	r25, 0xFF	; 255
    6504:	ec 01       	movw	r28, r24
    6506:	48 81       	ld	r20, Y
    6508:	59 81       	ldd	r21, Y+1	; 0x01
    650a:	6a 81       	ldd	r22, Y+2	; 0x02
    650c:	7b 81       	ldd	r23, Y+3	; 0x03
    650e:	e9 01       	movw	r28, r18
    6510:	48 83       	st	Y, r20
    6512:	59 83       	std	Y+1, r21	; 0x01
    6514:	6a 83       	std	Y+2, r22	; 0x02
    6516:	7b 83       	std	Y+3, r23	; 0x03
    6518:	9f 01       	movw	r18, r30
    651a:	23 57       	subi	r18, 0x73	; 115
    651c:	3f 4f       	sbci	r19, 0xFF	; 255
    651e:	cd 01       	movw	r24, r26
    6520:	87 57       	subi	r24, 0x77	; 119
    6522:	9f 4f       	sbci	r25, 0xFF	; 255
    6524:	ec 01       	movw	r28, r24
    6526:	48 81       	ld	r20, Y
    6528:	59 81       	ldd	r21, Y+1	; 0x01
    652a:	6a 81       	ldd	r22, Y+2	; 0x02
    652c:	7b 81       	ldd	r23, Y+3	; 0x03
    652e:	e9 01       	movw	r28, r18
    6530:	48 83       	st	Y, r20
    6532:	59 83       	std	Y+1, r21	; 0x01
    6534:	6a 83       	std	Y+2, r22	; 0x02
    6536:	7b 83       	std	Y+3, r23	; 0x03
    6538:	9f 01       	movw	r18, r30
    653a:	2f 56       	subi	r18, 0x6F	; 111
    653c:	3f 4f       	sbci	r19, 0xFF	; 255
    653e:	cd 01       	movw	r24, r26
    6540:	83 57       	subi	r24, 0x73	; 115
    6542:	9f 4f       	sbci	r25, 0xFF	; 255
    6544:	ec 01       	movw	r28, r24
    6546:	48 81       	ld	r20, Y
    6548:	59 81       	ldd	r21, Y+1	; 0x01
    654a:	6a 81       	ldd	r22, Y+2	; 0x02
    654c:	7b 81       	ldd	r23, Y+3	; 0x03
    654e:	e9 01       	movw	r28, r18
    6550:	48 83       	st	Y, r20
    6552:	59 83       	std	Y+1, r21	; 0x01
    6554:	6a 83       	std	Y+2, r22	; 0x02
    6556:	7b 83       	std	Y+3, r23	; 0x03
    6558:	9f 01       	movw	r18, r30
    655a:	2b 56       	subi	r18, 0x6B	; 107
    655c:	3f 4f       	sbci	r19, 0xFF	; 255
    655e:	cd 01       	movw	r24, r26
    6560:	8f 56       	subi	r24, 0x6F	; 111
    6562:	9f 4f       	sbci	r25, 0xFF	; 255
    6564:	ec 01       	movw	r28, r24
    6566:	48 81       	ld	r20, Y
    6568:	59 81       	ldd	r21, Y+1	; 0x01
    656a:	6a 81       	ldd	r22, Y+2	; 0x02
    656c:	7b 81       	ldd	r23, Y+3	; 0x03
    656e:	e9 01       	movw	r28, r18
    6570:	48 83       	st	Y, r20
    6572:	59 83       	std	Y+1, r21	; 0x01
    6574:	6a 83       	std	Y+2, r22	; 0x02
    6576:	7b 83       	std	Y+3, r23	; 0x03
    6578:	9f 01       	movw	r18, r30
    657a:	27 56       	subi	r18, 0x67	; 103
    657c:	3f 4f       	sbci	r19, 0xFF	; 255
    657e:	cd 01       	movw	r24, r26
    6580:	8b 56       	subi	r24, 0x6B	; 107
    6582:	9f 4f       	sbci	r25, 0xFF	; 255
    6584:	ec 01       	movw	r28, r24
    6586:	48 81       	ld	r20, Y
    6588:	59 81       	ldd	r21, Y+1	; 0x01
    658a:	6a 81       	ldd	r22, Y+2	; 0x02
    658c:	7b 81       	ldd	r23, Y+3	; 0x03
    658e:	e9 01       	movw	r28, r18
    6590:	48 83       	st	Y, r20
    6592:	59 83       	std	Y+1, r21	; 0x01
    6594:	6a 83       	std	Y+2, r22	; 0x02
    6596:	7b 83       	std	Y+3, r23	; 0x03
    6598:	9f 01       	movw	r18, r30
    659a:	23 56       	subi	r18, 0x63	; 99
    659c:	3f 4f       	sbci	r19, 0xFF	; 255
    659e:	cd 01       	movw	r24, r26
    65a0:	87 56       	subi	r24, 0x67	; 103
    65a2:	9f 4f       	sbci	r25, 0xFF	; 255
    65a4:	ec 01       	movw	r28, r24
    65a6:	48 81       	ld	r20, Y
    65a8:	59 81       	ldd	r21, Y+1	; 0x01
    65aa:	6a 81       	ldd	r22, Y+2	; 0x02
    65ac:	7b 81       	ldd	r23, Y+3	; 0x03
    65ae:	e9 01       	movw	r28, r18
    65b0:	48 83       	st	Y, r20
    65b2:	59 83       	std	Y+1, r21	; 0x01
    65b4:	6a 83       	std	Y+2, r22	; 0x02
    65b6:	7b 83       	std	Y+3, r23	; 0x03
    65b8:	9f 01       	movw	r18, r30
    65ba:	2f 55       	subi	r18, 0x5F	; 95
    65bc:	3f 4f       	sbci	r19, 0xFF	; 255
    65be:	cd 01       	movw	r24, r26
    65c0:	83 56       	subi	r24, 0x63	; 99
    65c2:	9f 4f       	sbci	r25, 0xFF	; 255
    65c4:	ec 01       	movw	r28, r24
    65c6:	48 81       	ld	r20, Y
    65c8:	59 81       	ldd	r21, Y+1	; 0x01
    65ca:	6a 81       	ldd	r22, Y+2	; 0x02
    65cc:	7b 81       	ldd	r23, Y+3	; 0x03
    65ce:	e9 01       	movw	r28, r18
    65d0:	48 83       	st	Y, r20
    65d2:	59 83       	std	Y+1, r21	; 0x01
    65d4:	6a 83       	std	Y+2, r22	; 0x02
    65d6:	7b 83       	std	Y+3, r23	; 0x03
    65d8:	9f 01       	movw	r18, r30
    65da:	2b 55       	subi	r18, 0x5B	; 91
    65dc:	3f 4f       	sbci	r19, 0xFF	; 255
    65de:	cd 01       	movw	r24, r26
    65e0:	8f 55       	subi	r24, 0x5F	; 95
    65e2:	9f 4f       	sbci	r25, 0xFF	; 255
    65e4:	ec 01       	movw	r28, r24
    65e6:	48 81       	ld	r20, Y
    65e8:	59 81       	ldd	r21, Y+1	; 0x01
    65ea:	6a 81       	ldd	r22, Y+2	; 0x02
    65ec:	7b 81       	ldd	r23, Y+3	; 0x03
    65ee:	e9 01       	movw	r28, r18
    65f0:	48 83       	st	Y, r20
    65f2:	59 83       	std	Y+1, r21	; 0x01
    65f4:	6a 83       	std	Y+2, r22	; 0x02
    65f6:	7b 83       	std	Y+3, r23	; 0x03
    65f8:	9f 01       	movw	r18, r30
    65fa:	27 55       	subi	r18, 0x57	; 87
    65fc:	3f 4f       	sbci	r19, 0xFF	; 255
    65fe:	cd 01       	movw	r24, r26
    6600:	8b 55       	subi	r24, 0x5B	; 91
    6602:	9f 4f       	sbci	r25, 0xFF	; 255
    6604:	ec 01       	movw	r28, r24
    6606:	48 81       	ld	r20, Y
    6608:	59 81       	ldd	r21, Y+1	; 0x01
    660a:	6a 81       	ldd	r22, Y+2	; 0x02
    660c:	7b 81       	ldd	r23, Y+3	; 0x03
    660e:	e9 01       	movw	r28, r18
    6610:	48 83       	st	Y, r20
    6612:	59 83       	std	Y+1, r21	; 0x01
    6614:	6a 83       	std	Y+2, r22	; 0x02
    6616:	7b 83       	std	Y+3, r23	; 0x03
    6618:	9f 01       	movw	r18, r30
    661a:	23 55       	subi	r18, 0x53	; 83
    661c:	3f 4f       	sbci	r19, 0xFF	; 255
    661e:	cd 01       	movw	r24, r26
    6620:	87 55       	subi	r24, 0x57	; 87
    6622:	9f 4f       	sbci	r25, 0xFF	; 255
    6624:	ec 01       	movw	r28, r24
    6626:	48 81       	ld	r20, Y
    6628:	59 81       	ldd	r21, Y+1	; 0x01
    662a:	6a 81       	ldd	r22, Y+2	; 0x02
    662c:	7b 81       	ldd	r23, Y+3	; 0x03
    662e:	e9 01       	movw	r28, r18
    6630:	48 83       	st	Y, r20
    6632:	59 83       	std	Y+1, r21	; 0x01
    6634:	6a 83       	std	Y+2, r22	; 0x02
    6636:	7b 83       	std	Y+3, r23	; 0x03
    6638:	9f 01       	movw	r18, r30
    663a:	2f 54       	subi	r18, 0x4F	; 79
    663c:	3f 4f       	sbci	r19, 0xFF	; 255
    663e:	cd 01       	movw	r24, r26
    6640:	83 55       	subi	r24, 0x53	; 83
    6642:	9f 4f       	sbci	r25, 0xFF	; 255
    6644:	ec 01       	movw	r28, r24
    6646:	48 81       	ld	r20, Y
    6648:	59 81       	ldd	r21, Y+1	; 0x01
    664a:	6a 81       	ldd	r22, Y+2	; 0x02
    664c:	7b 81       	ldd	r23, Y+3	; 0x03
    664e:	e9 01       	movw	r28, r18
    6650:	48 83       	st	Y, r20
    6652:	59 83       	std	Y+1, r21	; 0x01
    6654:	6a 83       	std	Y+2, r22	; 0x02
    6656:	7b 83       	std	Y+3, r23	; 0x03
    6658:	9f 01       	movw	r18, r30
    665a:	2b 54       	subi	r18, 0x4B	; 75
    665c:	3f 4f       	sbci	r19, 0xFF	; 255
    665e:	cd 01       	movw	r24, r26
    6660:	8f 54       	subi	r24, 0x4F	; 79
    6662:	9f 4f       	sbci	r25, 0xFF	; 255
    6664:	ec 01       	movw	r28, r24
    6666:	48 81       	ld	r20, Y
    6668:	59 81       	ldd	r21, Y+1	; 0x01
    666a:	6a 81       	ldd	r22, Y+2	; 0x02
    666c:	7b 81       	ldd	r23, Y+3	; 0x03
    666e:	e9 01       	movw	r28, r18
    6670:	48 83       	st	Y, r20
    6672:	59 83       	std	Y+1, r21	; 0x01
    6674:	6a 83       	std	Y+2, r22	; 0x02
    6676:	7b 83       	std	Y+3, r23	; 0x03
    6678:	9f 01       	movw	r18, r30
    667a:	27 54       	subi	r18, 0x47	; 71
    667c:	3f 4f       	sbci	r19, 0xFF	; 255
    667e:	cd 01       	movw	r24, r26
    6680:	8b 54       	subi	r24, 0x4B	; 75
    6682:	9f 4f       	sbci	r25, 0xFF	; 255
    6684:	ec 01       	movw	r28, r24
    6686:	48 81       	ld	r20, Y
    6688:	59 81       	ldd	r21, Y+1	; 0x01
    668a:	6a 81       	ldd	r22, Y+2	; 0x02
    668c:	7b 81       	ldd	r23, Y+3	; 0x03
    668e:	e9 01       	movw	r28, r18
    6690:	48 83       	st	Y, r20
    6692:	59 83       	std	Y+1, r21	; 0x01
    6694:	6a 83       	std	Y+2, r22	; 0x02
    6696:	7b 83       	std	Y+3, r23	; 0x03
    6698:	9f 01       	movw	r18, r30
    669a:	23 54       	subi	r18, 0x43	; 67
    669c:	3f 4f       	sbci	r19, 0xFF	; 255
    669e:	cd 01       	movw	r24, r26
    66a0:	87 54       	subi	r24, 0x47	; 71
    66a2:	9f 4f       	sbci	r25, 0xFF	; 255
    66a4:	ec 01       	movw	r28, r24
    66a6:	48 81       	ld	r20, Y
    66a8:	59 81       	ldd	r21, Y+1	; 0x01
    66aa:	6a 81       	ldd	r22, Y+2	; 0x02
    66ac:	7b 81       	ldd	r23, Y+3	; 0x03
    66ae:	e9 01       	movw	r28, r18
    66b0:	48 83       	st	Y, r20
    66b2:	59 83       	std	Y+1, r21	; 0x01
    66b4:	6a 83       	std	Y+2, r22	; 0x02
    66b6:	7b 83       	std	Y+3, r23	; 0x03
    66b8:	9f 01       	movw	r18, r30
    66ba:	2f 53       	subi	r18, 0x3F	; 63
    66bc:	3f 4f       	sbci	r19, 0xFF	; 255
    66be:	cd 01       	movw	r24, r26
    66c0:	83 54       	subi	r24, 0x43	; 67
    66c2:	9f 4f       	sbci	r25, 0xFF	; 255
    66c4:	ec 01       	movw	r28, r24
    66c6:	48 81       	ld	r20, Y
    66c8:	59 81       	ldd	r21, Y+1	; 0x01
    66ca:	6a 81       	ldd	r22, Y+2	; 0x02
    66cc:	7b 81       	ldd	r23, Y+3	; 0x03
    66ce:	e9 01       	movw	r28, r18
    66d0:	48 83       	st	Y, r20
    66d2:	59 83       	std	Y+1, r21	; 0x01
    66d4:	6a 83       	std	Y+2, r22	; 0x02
    66d6:	7b 83       	std	Y+3, r23	; 0x03
    66d8:	9f 01       	movw	r18, r30
    66da:	2b 53       	subi	r18, 0x3B	; 59
    66dc:	3f 4f       	sbci	r19, 0xFF	; 255
    66de:	cd 01       	movw	r24, r26
    66e0:	8f 53       	subi	r24, 0x3F	; 63
    66e2:	9f 4f       	sbci	r25, 0xFF	; 255
    66e4:	ec 01       	movw	r28, r24
    66e6:	48 81       	ld	r20, Y
    66e8:	59 81       	ldd	r21, Y+1	; 0x01
    66ea:	6a 81       	ldd	r22, Y+2	; 0x02
    66ec:	7b 81       	ldd	r23, Y+3	; 0x03
    66ee:	e9 01       	movw	r28, r18
    66f0:	48 83       	st	Y, r20
    66f2:	59 83       	std	Y+1, r21	; 0x01
    66f4:	6a 83       	std	Y+2, r22	; 0x02
    66f6:	7b 83       	std	Y+3, r23	; 0x03
    66f8:	9f 01       	movw	r18, r30
    66fa:	27 53       	subi	r18, 0x37	; 55
    66fc:	3f 4f       	sbci	r19, 0xFF	; 255
    66fe:	cd 01       	movw	r24, r26
    6700:	8b 53       	subi	r24, 0x3B	; 59
    6702:	9f 4f       	sbci	r25, 0xFF	; 255
    6704:	ec 01       	movw	r28, r24
    6706:	48 81       	ld	r20, Y
    6708:	59 81       	ldd	r21, Y+1	; 0x01
    670a:	6a 81       	ldd	r22, Y+2	; 0x02
    670c:	7b 81       	ldd	r23, Y+3	; 0x03
    670e:	e9 01       	movw	r28, r18
    6710:	48 83       	st	Y, r20
    6712:	59 83       	std	Y+1, r21	; 0x01
    6714:	6a 83       	std	Y+2, r22	; 0x02
    6716:	7b 83       	std	Y+3, r23	; 0x03
    6718:	9f 01       	movw	r18, r30
    671a:	23 53       	subi	r18, 0x33	; 51
    671c:	3f 4f       	sbci	r19, 0xFF	; 255
    671e:	cd 01       	movw	r24, r26
    6720:	87 53       	subi	r24, 0x37	; 55
    6722:	9f 4f       	sbci	r25, 0xFF	; 255
    6724:	ec 01       	movw	r28, r24
    6726:	48 81       	ld	r20, Y
    6728:	59 81       	ldd	r21, Y+1	; 0x01
    672a:	6a 81       	ldd	r22, Y+2	; 0x02
    672c:	7b 81       	ldd	r23, Y+3	; 0x03
    672e:	e9 01       	movw	r28, r18
    6730:	48 83       	st	Y, r20
    6732:	59 83       	std	Y+1, r21	; 0x01
    6734:	6a 83       	std	Y+2, r22	; 0x02
    6736:	7b 83       	std	Y+3, r23	; 0x03
    6738:	9f 01       	movw	r18, r30
    673a:	2f 52       	subi	r18, 0x2F	; 47
    673c:	3f 4f       	sbci	r19, 0xFF	; 255
    673e:	cd 01       	movw	r24, r26
    6740:	83 53       	subi	r24, 0x33	; 51
    6742:	9f 4f       	sbci	r25, 0xFF	; 255
    6744:	ec 01       	movw	r28, r24
    6746:	48 81       	ld	r20, Y
    6748:	59 81       	ldd	r21, Y+1	; 0x01
    674a:	6a 81       	ldd	r22, Y+2	; 0x02
    674c:	7b 81       	ldd	r23, Y+3	; 0x03
    674e:	e9 01       	movw	r28, r18
    6750:	48 83       	st	Y, r20
    6752:	59 83       	std	Y+1, r21	; 0x01
    6754:	6a 83       	std	Y+2, r22	; 0x02
    6756:	7b 83       	std	Y+3, r23	; 0x03
    6758:	9f 01       	movw	r18, r30
    675a:	2b 52       	subi	r18, 0x2B	; 43
    675c:	3f 4f       	sbci	r19, 0xFF	; 255
    675e:	cd 01       	movw	r24, r26
    6760:	8f 52       	subi	r24, 0x2F	; 47
    6762:	9f 4f       	sbci	r25, 0xFF	; 255
    6764:	ec 01       	movw	r28, r24
    6766:	48 81       	ld	r20, Y
    6768:	59 81       	ldd	r21, Y+1	; 0x01
    676a:	6a 81       	ldd	r22, Y+2	; 0x02
    676c:	7b 81       	ldd	r23, Y+3	; 0x03
    676e:	e9 01       	movw	r28, r18
    6770:	48 83       	st	Y, r20
    6772:	59 83       	std	Y+1, r21	; 0x01
    6774:	6a 83       	std	Y+2, r22	; 0x02
    6776:	7b 83       	std	Y+3, r23	; 0x03
    6778:	9f 01       	movw	r18, r30
    677a:	27 52       	subi	r18, 0x27	; 39
    677c:	3f 4f       	sbci	r19, 0xFF	; 255
    677e:	cd 01       	movw	r24, r26
    6780:	8b 52       	subi	r24, 0x2B	; 43
    6782:	9f 4f       	sbci	r25, 0xFF	; 255
    6784:	ec 01       	movw	r28, r24
    6786:	48 81       	ld	r20, Y
    6788:	59 81       	ldd	r21, Y+1	; 0x01
    678a:	6a 81       	ldd	r22, Y+2	; 0x02
    678c:	7b 81       	ldd	r23, Y+3	; 0x03
    678e:	e9 01       	movw	r28, r18
    6790:	48 83       	st	Y, r20
    6792:	59 83       	std	Y+1, r21	; 0x01
    6794:	6a 83       	std	Y+2, r22	; 0x02
    6796:	7b 83       	std	Y+3, r23	; 0x03
    6798:	9f 01       	movw	r18, r30
    679a:	23 52       	subi	r18, 0x23	; 35
    679c:	3f 4f       	sbci	r19, 0xFF	; 255
    679e:	cd 01       	movw	r24, r26
    67a0:	87 52       	subi	r24, 0x27	; 39
    67a2:	9f 4f       	sbci	r25, 0xFF	; 255
    67a4:	ec 01       	movw	r28, r24
    67a6:	48 81       	ld	r20, Y
    67a8:	59 81       	ldd	r21, Y+1	; 0x01
    67aa:	6a 81       	ldd	r22, Y+2	; 0x02
    67ac:	7b 81       	ldd	r23, Y+3	; 0x03
    67ae:	e9 01       	movw	r28, r18
    67b0:	48 83       	st	Y, r20
    67b2:	59 83       	std	Y+1, r21	; 0x01
    67b4:	6a 83       	std	Y+2, r22	; 0x02
    67b6:	7b 83       	std	Y+3, r23	; 0x03
    67b8:	9f 01       	movw	r18, r30
    67ba:	2f 51       	subi	r18, 0x1F	; 31
    67bc:	3f 4f       	sbci	r19, 0xFF	; 255
    67be:	cd 01       	movw	r24, r26
    67c0:	83 52       	subi	r24, 0x23	; 35
    67c2:	9f 4f       	sbci	r25, 0xFF	; 255
    67c4:	ec 01       	movw	r28, r24
    67c6:	48 81       	ld	r20, Y
    67c8:	59 81       	ldd	r21, Y+1	; 0x01
    67ca:	6a 81       	ldd	r22, Y+2	; 0x02
    67cc:	7b 81       	ldd	r23, Y+3	; 0x03
    67ce:	e9 01       	movw	r28, r18
    67d0:	48 83       	st	Y, r20
    67d2:	59 83       	std	Y+1, r21	; 0x01
    67d4:	6a 83       	std	Y+2, r22	; 0x02
    67d6:	7b 83       	std	Y+3, r23	; 0x03
    67d8:	9f 01       	movw	r18, r30
    67da:	2b 51       	subi	r18, 0x1B	; 27
    67dc:	3f 4f       	sbci	r19, 0xFF	; 255
    67de:	cd 01       	movw	r24, r26
    67e0:	8f 51       	subi	r24, 0x1F	; 31
    67e2:	9f 4f       	sbci	r25, 0xFF	; 255
    67e4:	ec 01       	movw	r28, r24
    67e6:	48 81       	ld	r20, Y
    67e8:	59 81       	ldd	r21, Y+1	; 0x01
    67ea:	6a 81       	ldd	r22, Y+2	; 0x02
    67ec:	7b 81       	ldd	r23, Y+3	; 0x03
    67ee:	e9 01       	movw	r28, r18
    67f0:	48 83       	st	Y, r20
    67f2:	59 83       	std	Y+1, r21	; 0x01
    67f4:	6a 83       	std	Y+2, r22	; 0x02
    67f6:	7b 83       	std	Y+3, r23	; 0x03
    67f8:	9f 01       	movw	r18, r30
    67fa:	27 51       	subi	r18, 0x17	; 23
    67fc:	3f 4f       	sbci	r19, 0xFF	; 255
    67fe:	cd 01       	movw	r24, r26
    6800:	8b 51       	subi	r24, 0x1B	; 27
    6802:	9f 4f       	sbci	r25, 0xFF	; 255
    6804:	ec 01       	movw	r28, r24
    6806:	48 81       	ld	r20, Y
    6808:	59 81       	ldd	r21, Y+1	; 0x01
    680a:	6a 81       	ldd	r22, Y+2	; 0x02
    680c:	7b 81       	ldd	r23, Y+3	; 0x03
    680e:	e9 01       	movw	r28, r18
    6810:	48 83       	st	Y, r20
    6812:	59 83       	std	Y+1, r21	; 0x01
    6814:	6a 83       	std	Y+2, r22	; 0x02
    6816:	7b 83       	std	Y+3, r23	; 0x03
    6818:	9f 01       	movw	r18, r30
    681a:	23 51       	subi	r18, 0x13	; 19
    681c:	3f 4f       	sbci	r19, 0xFF	; 255
    681e:	cd 01       	movw	r24, r26
    6820:	87 51       	subi	r24, 0x17	; 23
    6822:	9f 4f       	sbci	r25, 0xFF	; 255
    6824:	ec 01       	movw	r28, r24
    6826:	48 81       	ld	r20, Y
    6828:	59 81       	ldd	r21, Y+1	; 0x01
    682a:	6a 81       	ldd	r22, Y+2	; 0x02
    682c:	7b 81       	ldd	r23, Y+3	; 0x03
    682e:	e9 01       	movw	r28, r18
    6830:	48 83       	st	Y, r20
    6832:	59 83       	std	Y+1, r21	; 0x01
    6834:	6a 83       	std	Y+2, r22	; 0x02
    6836:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6838:	9f 01       	movw	r18, r30
    683a:	2f 50       	subi	r18, 0x0F	; 15
    683c:	3f 4f       	sbci	r19, 0xFF	; 255
    683e:	cd 01       	movw	r24, r26
    6840:	83 51       	subi	r24, 0x13	; 19
    6842:	9f 4f       	sbci	r25, 0xFF	; 255
    6844:	ec 01       	movw	r28, r24
    6846:	48 81       	ld	r20, Y
    6848:	59 81       	ldd	r21, Y+1	; 0x01
    684a:	6a 81       	ldd	r22, Y+2	; 0x02
    684c:	7b 81       	ldd	r23, Y+3	; 0x03
    684e:	e9 01       	movw	r28, r18
    6850:	48 83       	st	Y, r20
    6852:	59 83       	std	Y+1, r21	; 0x01
    6854:	6a 83       	std	Y+2, r22	; 0x02
    6856:	7b 83       	std	Y+3, r23	; 0x03
    6858:	9f 01       	movw	r18, r30
    685a:	2b 50       	subi	r18, 0x0B	; 11
    685c:	3f 4f       	sbci	r19, 0xFF	; 255
    685e:	cd 01       	movw	r24, r26
    6860:	8f 50       	subi	r24, 0x0F	; 15
    6862:	9f 4f       	sbci	r25, 0xFF	; 255
    6864:	ec 01       	movw	r28, r24
    6866:	48 81       	ld	r20, Y
    6868:	59 81       	ldd	r21, Y+1	; 0x01
    686a:	6a 81       	ldd	r22, Y+2	; 0x02
    686c:	7b 81       	ldd	r23, Y+3	; 0x03
    686e:	e9 01       	movw	r28, r18
    6870:	48 83       	st	Y, r20
    6872:	59 83       	std	Y+1, r21	; 0x01
    6874:	6a 83       	std	Y+2, r22	; 0x02
    6876:	7b 83       	std	Y+3, r23	; 0x03
    6878:	9f 01       	movw	r18, r30
    687a:	27 50       	subi	r18, 0x07	; 7
    687c:	3f 4f       	sbci	r19, 0xFF	; 255
    687e:	cd 01       	movw	r24, r26
    6880:	8b 50       	subi	r24, 0x0B	; 11
    6882:	9f 4f       	sbci	r25, 0xFF	; 255
    6884:	ec 01       	movw	r28, r24
    6886:	48 81       	ld	r20, Y
    6888:	59 81       	ldd	r21, Y+1	; 0x01
    688a:	6a 81       	ldd	r22, Y+2	; 0x02
    688c:	7b 81       	ldd	r23, Y+3	; 0x03
    688e:	e9 01       	movw	r28, r18
    6890:	48 83       	st	Y, r20
    6892:	59 83       	std	Y+1, r21	; 0x01
    6894:	6a 83       	std	Y+2, r22	; 0x02
    6896:	7b 83       	std	Y+3, r23	; 0x03
    6898:	9f 01       	movw	r18, r30
    689a:	23 50       	subi	r18, 0x03	; 3
    689c:	3f 4f       	sbci	r19, 0xFF	; 255
    689e:	cd 01       	movw	r24, r26
    68a0:	87 50       	subi	r24, 0x07	; 7
    68a2:	9f 4f       	sbci	r25, 0xFF	; 255
    68a4:	ec 01       	movw	r28, r24
    68a6:	48 81       	ld	r20, Y
    68a8:	59 81       	ldd	r21, Y+1	; 0x01
    68aa:	6a 81       	ldd	r22, Y+2	; 0x02
    68ac:	7b 81       	ldd	r23, Y+3	; 0x03
    68ae:	e9 01       	movw	r28, r18
    68b0:	48 83       	st	Y, r20
    68b2:	59 83       	std	Y+1, r21	; 0x01
    68b4:	6a 83       	std	Y+2, r22	; 0x02
    68b6:	7b 83       	std	Y+3, r23	; 0x03
    68b8:	9f 01       	movw	r18, r30
    68ba:	2f 5f       	subi	r18, 0xFF	; 255
    68bc:	3e 4f       	sbci	r19, 0xFE	; 254
    68be:	cd 01       	movw	r24, r26
    68c0:	83 50       	subi	r24, 0x03	; 3
    68c2:	9f 4f       	sbci	r25, 0xFF	; 255
    68c4:	ec 01       	movw	r28, r24
    68c6:	48 81       	ld	r20, Y
    68c8:	59 81       	ldd	r21, Y+1	; 0x01
    68ca:	6a 81       	ldd	r22, Y+2	; 0x02
    68cc:	7b 81       	ldd	r23, Y+3	; 0x03
    68ce:	e9 01       	movw	r28, r18
    68d0:	48 83       	st	Y, r20
    68d2:	59 83       	std	Y+1, r21	; 0x01
    68d4:	6a 83       	std	Y+2, r22	; 0x02
    68d6:	7b 83       	std	Y+3, r23	; 0x03
    68d8:	9f 01       	movw	r18, r30
    68da:	2b 5f       	subi	r18, 0xFB	; 251
    68dc:	3e 4f       	sbci	r19, 0xFE	; 254
    68de:	cd 01       	movw	r24, r26
    68e0:	8f 5f       	subi	r24, 0xFF	; 255
    68e2:	9e 4f       	sbci	r25, 0xFE	; 254
    68e4:	ec 01       	movw	r28, r24
    68e6:	48 81       	ld	r20, Y
    68e8:	59 81       	ldd	r21, Y+1	; 0x01
    68ea:	6a 81       	ldd	r22, Y+2	; 0x02
    68ec:	7b 81       	ldd	r23, Y+3	; 0x03
    68ee:	e9 01       	movw	r28, r18
    68f0:	48 83       	st	Y, r20
    68f2:	59 83       	std	Y+1, r21	; 0x01
    68f4:	6a 83       	std	Y+2, r22	; 0x02
    68f6:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, float &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    68f8:	9f 01       	movw	r18, r30
    68fa:	27 5f       	subi	r18, 0xF7	; 247
    68fc:	3e 4f       	sbci	r19, 0xFE	; 254
    68fe:	cd 01       	movw	r24, r26
    6900:	8b 5f       	subi	r24, 0xFB	; 251
    6902:	9e 4f       	sbci	r25, 0xFE	; 254
    6904:	ec 01       	movw	r28, r24
    6906:	48 81       	ld	r20, Y
    6908:	59 81       	ldd	r21, Y+1	; 0x01
    690a:	6a 81       	ldd	r22, Y+2	; 0x02
    690c:	7b 81       	ldd	r23, Y+3	; 0x03
    690e:	e9 01       	movw	r28, r18
    6910:	48 83       	st	Y, r20
    6912:	59 83       	std	Y+1, r21	; 0x01
    6914:	6a 83       	std	Y+2, r22	; 0x02
    6916:	7b 83       	std	Y+3, r23	; 0x03
    6918:	9f 01       	movw	r18, r30
    691a:	23 5f       	subi	r18, 0xF3	; 243
    691c:	3e 4f       	sbci	r19, 0xFE	; 254
    691e:	cd 01       	movw	r24, r26
    6920:	87 5f       	subi	r24, 0xF7	; 247
    6922:	9e 4f       	sbci	r25, 0xFE	; 254
    6924:	ec 01       	movw	r28, r24
    6926:	48 81       	ld	r20, Y
    6928:	59 81       	ldd	r21, Y+1	; 0x01
    692a:	6a 81       	ldd	r22, Y+2	; 0x02
    692c:	7b 81       	ldd	r23, Y+3	; 0x03
    692e:	e9 01       	movw	r28, r18
    6930:	48 83       	st	Y, r20
    6932:	59 83       	std	Y+1, r21	; 0x01
    6934:	6a 83       	std	Y+2, r22	; 0x02
    6936:	7b 83       	std	Y+3, r23	; 0x03
    6938:	9f 01       	movw	r18, r30
    693a:	2f 5e       	subi	r18, 0xEF	; 239
    693c:	3e 4f       	sbci	r19, 0xFE	; 254
    693e:	cd 01       	movw	r24, r26
    6940:	83 5f       	subi	r24, 0xF3	; 243
    6942:	9e 4f       	sbci	r25, 0xFE	; 254
    6944:	ec 01       	movw	r28, r24
    6946:	48 81       	ld	r20, Y
    6948:	59 81       	ldd	r21, Y+1	; 0x01
    694a:	6a 81       	ldd	r22, Y+2	; 0x02
    694c:	7b 81       	ldd	r23, Y+3	; 0x03
    694e:	e9 01       	movw	r28, r18
    6950:	48 83       	st	Y, r20
    6952:	59 83       	std	Y+1, r21	; 0x01
    6954:	6a 83       	std	Y+2, r22	; 0x02
    6956:	7b 83       	std	Y+3, r23	; 0x03
    6958:	9f 01       	movw	r18, r30
    695a:	2b 5e       	subi	r18, 0xEB	; 235
    695c:	3e 4f       	sbci	r19, 0xFE	; 254
    695e:	cd 01       	movw	r24, r26
    6960:	8f 5e       	subi	r24, 0xEF	; 239
    6962:	9e 4f       	sbci	r25, 0xFE	; 254
    6964:	ec 01       	movw	r28, r24
    6966:	48 81       	ld	r20, Y
    6968:	59 81       	ldd	r21, Y+1	; 0x01
    696a:	6a 81       	ldd	r22, Y+2	; 0x02
    696c:	7b 81       	ldd	r23, Y+3	; 0x03
    696e:	e9 01       	movw	r28, r18
    6970:	48 83       	st	Y, r20
    6972:	59 83       	std	Y+1, r21	; 0x01
    6974:	6a 83       	std	Y+2, r22	; 0x02
    6976:	7b 83       	std	Y+3, r23	; 0x03
    6978:	9f 01       	movw	r18, r30
    697a:	27 5e       	subi	r18, 0xE7	; 231
    697c:	3e 4f       	sbci	r19, 0xFE	; 254
    697e:	cd 01       	movw	r24, r26
    6980:	8b 5e       	subi	r24, 0xEB	; 235
    6982:	9e 4f       	sbci	r25, 0xFE	; 254
    6984:	ec 01       	movw	r28, r24
    6986:	48 81       	ld	r20, Y
    6988:	59 81       	ldd	r21, Y+1	; 0x01
    698a:	6a 81       	ldd	r22, Y+2	; 0x02
    698c:	7b 81       	ldd	r23, Y+3	; 0x03
    698e:	e9 01       	movw	r28, r18
    6990:	48 83       	st	Y, r20
    6992:	59 83       	std	Y+1, r21	; 0x01
    6994:	6a 83       	std	Y+2, r22	; 0x02
    6996:	7b 83       	std	Y+3, r23	; 0x03
					buffPtr += sizeof(val);
				}
				
				void decode (byte *&buffPtr, long &val)
				{
					memcpy(&val, buffPtr, sizeof(val));
    6998:	9f 01       	movw	r18, r30
    699a:	23 5e       	subi	r18, 0xE3	; 227
    699c:	3e 4f       	sbci	r19, 0xFE	; 254
    699e:	cd 01       	movw	r24, r26
    69a0:	87 5e       	subi	r24, 0xE7	; 231
    69a2:	9e 4f       	sbci	r25, 0xFE	; 254
    69a4:	ec 01       	movw	r28, r24
    69a6:	48 81       	ld	r20, Y
    69a8:	59 81       	ldd	r21, Y+1	; 0x01
    69aa:	6a 81       	ldd	r22, Y+2	; 0x02
    69ac:	7b 81       	ldd	r23, Y+3	; 0x03
    69ae:	e9 01       	movw	r28, r18
    69b0:	48 83       	st	Y, r20
    69b2:	59 83       	std	Y+1, r21	; 0x01
    69b4:	6a 83       	std	Y+2, r22	; 0x02
    69b6:	7b 83       	std	Y+3, r23	; 0x03
    69b8:	9f 01       	movw	r18, r30
    69ba:	2f 5d       	subi	r18, 0xDF	; 223
    69bc:	3e 4f       	sbci	r19, 0xFE	; 254
    69be:	cd 01       	movw	r24, r26
    69c0:	83 5e       	subi	r24, 0xE3	; 227
    69c2:	9e 4f       	sbci	r25, 0xFE	; 254
    69c4:	ec 01       	movw	r28, r24
    69c6:	48 81       	ld	r20, Y
    69c8:	59 81       	ldd	r21, Y+1	; 0x01
    69ca:	6a 81       	ldd	r22, Y+2	; 0x02
    69cc:	7b 81       	ldd	r23, Y+3	; 0x03
    69ce:	e9 01       	movw	r28, r18
    69d0:	48 83       	st	Y, r20
    69d2:	59 83       	std	Y+1, r21	; 0x01
    69d4:	6a 83       	std	Y+2, r22	; 0x02
    69d6:	7b 83       	std	Y+3, r23	; 0x03
    69d8:	9f 01       	movw	r18, r30
    69da:	2b 5d       	subi	r18, 0xDB	; 219
    69dc:	3e 4f       	sbci	r19, 0xFE	; 254
    69de:	cd 01       	movw	r24, r26
    69e0:	8f 5d       	subi	r24, 0xDF	; 223
    69e2:	9e 4f       	sbci	r25, 0xFE	; 254
    69e4:	ec 01       	movw	r28, r24
    69e6:	48 81       	ld	r20, Y
    69e8:	59 81       	ldd	r21, Y+1	; 0x01
    69ea:	6a 81       	ldd	r22, Y+2	; 0x02
    69ec:	7b 81       	ldd	r23, Y+3	; 0x03
    69ee:	e9 01       	movw	r28, r18
    69f0:	48 83       	st	Y, r20
    69f2:	59 83       	std	Y+1, r21	; 0x01
    69f4:	6a 83       	std	Y+2, r22	; 0x02
    69f6:	7b 83       	std	Y+3, r23	; 0x03
    69f8:	9f 01       	movw	r18, r30
    69fa:	27 5d       	subi	r18, 0xD7	; 215
    69fc:	3e 4f       	sbci	r19, 0xFE	; 254
    69fe:	cd 01       	movw	r24, r26
    6a00:	8b 5d       	subi	r24, 0xDB	; 219
    6a02:	9e 4f       	sbci	r25, 0xFE	; 254
    6a04:	ec 01       	movw	r28, r24
    6a06:	48 81       	ld	r20, Y
    6a08:	59 81       	ldd	r21, Y+1	; 0x01
    6a0a:	6a 81       	ldd	r22, Y+2	; 0x02
    6a0c:	7b 81       	ldd	r23, Y+3	; 0x03
    6a0e:	e9 01       	movw	r28, r18
    6a10:	48 83       	st	Y, r20
    6a12:	59 83       	std	Y+1, r21	; 0x01
    6a14:	6a 83       	std	Y+2, r22	; 0x02
    6a16:	7b 83       	std	Y+3, r23	; 0x03
    6a18:	e3 5d       	subi	r30, 0xD3	; 211
    6a1a:	fe 4f       	sbci	r31, 0xFE	; 254
    6a1c:	a7 5d       	subi	r26, 0xD7	; 215
    6a1e:	be 4f       	sbci	r27, 0xFE	; 254
    6a20:	4d 91       	ld	r20, X+
    6a22:	5d 91       	ld	r21, X+
    6a24:	6d 91       	ld	r22, X+
    6a26:	7c 91       	ld	r23, X
    6a28:	40 83       	st	Z, r20
    6a2a:	51 83       	std	Z+1, r21	; 0x01
    6a2c:	62 83       	std	Z+2, r22	; 0x02
    6a2e:	73 83       	std	Z+3, r23	; 0x03
		decode (message, UnrecognizedMsgTypes);
		decode (message, ChecksumErrors);
		decode (message, NumOfBlownFrames);
		decode (message, SerialCommunicationBufferOverruns);
	}
}
    6a30:	df 91       	pop	r29
    6a32:	cf 91       	pop	r28
    6a34:	08 95       	ret

00006a36 <_ZN10helicopter8messages22SystemTelemetryMessage14buildMessageStEPh>:

SystemTelemetryMessage* SystemTelemetryMessage::buildMessageSt(byte *message)
{
    6a36:	0f 93       	push	r16
    6a38:	1f 93       	push	r17
    6a3a:	cf 93       	push	r28
    6a3c:	df 93       	push	r29
    6a3e:	8c 01       	movw	r16, r24
	SystemTelemetryMessage *msg = new SystemTelemetryMessage();
    6a40:	81 e3       	ldi	r24, 0x31	; 49
    6a42:	91 e0       	ldi	r25, 0x01	; 1
    6a44:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    6a48:	ec 01       	movw	r28, r24
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    6a4a:	82 e0       	ldi	r24, 0x02	; 2
    6a4c:	8a 83       	std	Y+2, r24	; 0x02
    6a4e:	8d e2       	ldi	r24, 0x2D	; 45
    6a50:	91 e0       	ldi	r25, 0x01	; 1
    6a52:	9c 83       	std	Y+4, r25	; 0x04
    6a54:	8b 83       	std	Y+3, r24	; 0x03
														
					Timeouts(0),
					UnrecognizedMsgTypes(0),
					ChecksumErrors(0),
					NumOfBlownFrames(0), 
					SerialCommunicationBufferOverruns(0)
    6a56:	80 e8       	ldi	r24, 0x80	; 128
    6a58:	92 e0       	ldi	r25, 0x02	; 2
    6a5a:	99 83       	std	Y+1, r25	; 0x01
    6a5c:	88 83       	st	Y, r24
    6a5e:	1d 82       	std	Y+5, r1	; 0x05
    6a60:	1e 82       	std	Y+6, r1	; 0x06
    6a62:	1f 82       	std	Y+7, r1	; 0x07
    6a64:	18 86       	std	Y+8, r1	; 0x08
    6a66:	19 86       	std	Y+9, r1	; 0x09
    6a68:	1a 86       	std	Y+10, r1	; 0x0a
    6a6a:	1b 86       	std	Y+11, r1	; 0x0b
    6a6c:	1c 86       	std	Y+12, r1	; 0x0c
    6a6e:	1d 86       	std	Y+13, r1	; 0x0d
    6a70:	1e 86       	std	Y+14, r1	; 0x0e
    6a72:	1f 86       	std	Y+15, r1	; 0x0f
    6a74:	18 8a       	std	Y+16, r1	; 0x10
    6a76:	19 8a       	std	Y+17, r1	; 0x11
    6a78:	1a 8a       	std	Y+18, r1	; 0x12
    6a7a:	1b 8a       	std	Y+19, r1	; 0x13
    6a7c:	1c 8a       	std	Y+20, r1	; 0x14
    6a7e:	1d 8a       	std	Y+21, r1	; 0x15
    6a80:	1e 8a       	std	Y+22, r1	; 0x16
    6a82:	1f 8a       	std	Y+23, r1	; 0x17
    6a84:	18 8e       	std	Y+24, r1	; 0x18
    6a86:	19 8e       	std	Y+25, r1	; 0x19
    6a88:	1a 8e       	std	Y+26, r1	; 0x1a
    6a8a:	1b 8e       	std	Y+27, r1	; 0x1b
    6a8c:	1c 8e       	std	Y+28, r1	; 0x1c
    6a8e:	1d 8e       	std	Y+29, r1	; 0x1d
    6a90:	1e 8e       	std	Y+30, r1	; 0x1e
    6a92:	1f 8e       	std	Y+31, r1	; 0x1f
    6a94:	18 a2       	std	Y+32, r1	; 0x20
    6a96:	19 a2       	std	Y+33, r1	; 0x21
    6a98:	1a a2       	std	Y+34, r1	; 0x22
    6a9a:	1b a2       	std	Y+35, r1	; 0x23
    6a9c:	1c a2       	std	Y+36, r1	; 0x24
    6a9e:	1d a2       	std	Y+37, r1	; 0x25
    6aa0:	1e a2       	std	Y+38, r1	; 0x26
    6aa2:	1f a2       	std	Y+39, r1	; 0x27
    6aa4:	18 a6       	std	Y+40, r1	; 0x28
    6aa6:	19 a6       	std	Y+41, r1	; 0x29
    6aa8:	1a a6       	std	Y+42, r1	; 0x2a
    6aaa:	1b a6       	std	Y+43, r1	; 0x2b
    6aac:	1c a6       	std	Y+44, r1	; 0x2c
    6aae:	1d a6       	std	Y+45, r1	; 0x2d
    6ab0:	1e a6       	std	Y+46, r1	; 0x2e
    6ab2:	1f a6       	std	Y+47, r1	; 0x2f
    6ab4:	18 aa       	std	Y+48, r1	; 0x30
    6ab6:	19 aa       	std	Y+49, r1	; 0x31
    6ab8:	1a aa       	std	Y+50, r1	; 0x32
    6aba:	1b aa       	std	Y+51, r1	; 0x33
    6abc:	1c aa       	std	Y+52, r1	; 0x34
    6abe:	1d aa       	std	Y+53, r1	; 0x35
    6ac0:	1e aa       	std	Y+54, r1	; 0x36
    6ac2:	1f aa       	std	Y+55, r1	; 0x37
    6ac4:	18 ae       	std	Y+56, r1	; 0x38
    6ac6:	19 ae       	std	Y+57, r1	; 0x39
    6ac8:	1a ae       	std	Y+58, r1	; 0x3a
    6aca:	1b ae       	std	Y+59, r1	; 0x3b
    6acc:	1c ae       	std	Y+60, r1	; 0x3c
    6ace:	fe 01       	movw	r30, r28
    6ad0:	fd 96       	adiw	r30, 0x3d	; 61
    6ad2:	10 82       	st	Z, r1
    6ad4:	11 82       	std	Z+1, r1	; 0x01
    6ad6:	12 82       	std	Z+2, r1	; 0x02
    6ad8:	13 82       	std	Z+3, r1	; 0x03
    6ada:	fe 01       	movw	r30, r28
    6adc:	ef 5b       	subi	r30, 0xBF	; 191
    6ade:	ff 4f       	sbci	r31, 0xFF	; 255
    6ae0:	10 82       	st	Z, r1
    6ae2:	11 82       	std	Z+1, r1	; 0x01
    6ae4:	12 82       	std	Z+2, r1	; 0x02
    6ae6:	13 82       	std	Z+3, r1	; 0x03
    6ae8:	fe 01       	movw	r30, r28
    6aea:	eb 5b       	subi	r30, 0xBB	; 187
    6aec:	ff 4f       	sbci	r31, 0xFF	; 255
    6aee:	10 82       	st	Z, r1
    6af0:	11 82       	std	Z+1, r1	; 0x01
    6af2:	12 82       	std	Z+2, r1	; 0x02
    6af4:	13 82       	std	Z+3, r1	; 0x03
    6af6:	fe 01       	movw	r30, r28
    6af8:	e7 5b       	subi	r30, 0xB7	; 183
    6afa:	ff 4f       	sbci	r31, 0xFF	; 255
    6afc:	10 82       	st	Z, r1
    6afe:	11 82       	std	Z+1, r1	; 0x01
    6b00:	12 82       	std	Z+2, r1	; 0x02
    6b02:	13 82       	std	Z+3, r1	; 0x03
    6b04:	fe 01       	movw	r30, r28
    6b06:	e3 5b       	subi	r30, 0xB3	; 179
    6b08:	ff 4f       	sbci	r31, 0xFF	; 255
    6b0a:	10 82       	st	Z, r1
    6b0c:	11 82       	std	Z+1, r1	; 0x01
    6b0e:	12 82       	std	Z+2, r1	; 0x02
    6b10:	13 82       	std	Z+3, r1	; 0x03
    6b12:	fe 01       	movw	r30, r28
    6b14:	ef 5a       	subi	r30, 0xAF	; 175
    6b16:	ff 4f       	sbci	r31, 0xFF	; 255
    6b18:	10 82       	st	Z, r1
    6b1a:	11 82       	std	Z+1, r1	; 0x01
    6b1c:	12 82       	std	Z+2, r1	; 0x02
    6b1e:	13 82       	std	Z+3, r1	; 0x03
    6b20:	fe 01       	movw	r30, r28
    6b22:	eb 5a       	subi	r30, 0xAB	; 171
    6b24:	ff 4f       	sbci	r31, 0xFF	; 255
    6b26:	10 82       	st	Z, r1
    6b28:	11 82       	std	Z+1, r1	; 0x01
    6b2a:	12 82       	std	Z+2, r1	; 0x02
    6b2c:	13 82       	std	Z+3, r1	; 0x03
    6b2e:	fe 01       	movw	r30, r28
    6b30:	e7 5a       	subi	r30, 0xA7	; 167
    6b32:	ff 4f       	sbci	r31, 0xFF	; 255
    6b34:	10 82       	st	Z, r1
    6b36:	11 82       	std	Z+1, r1	; 0x01
    6b38:	12 82       	std	Z+2, r1	; 0x02
    6b3a:	13 82       	std	Z+3, r1	; 0x03
    6b3c:	fe 01       	movw	r30, r28
    6b3e:	e3 5a       	subi	r30, 0xA3	; 163
    6b40:	ff 4f       	sbci	r31, 0xFF	; 255
    6b42:	10 82       	st	Z, r1
    6b44:	11 82       	std	Z+1, r1	; 0x01
    6b46:	12 82       	std	Z+2, r1	; 0x02
    6b48:	13 82       	std	Z+3, r1	; 0x03
    6b4a:	fe 01       	movw	r30, r28
    6b4c:	ef 59       	subi	r30, 0x9F	; 159
    6b4e:	ff 4f       	sbci	r31, 0xFF	; 255
    6b50:	10 82       	st	Z, r1
    6b52:	11 82       	std	Z+1, r1	; 0x01
    6b54:	12 82       	std	Z+2, r1	; 0x02
    6b56:	13 82       	std	Z+3, r1	; 0x03
    6b58:	fe 01       	movw	r30, r28
    6b5a:	eb 59       	subi	r30, 0x9B	; 155
    6b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    6b5e:	10 82       	st	Z, r1
    6b60:	11 82       	std	Z+1, r1	; 0x01
    6b62:	12 82       	std	Z+2, r1	; 0x02
    6b64:	13 82       	std	Z+3, r1	; 0x03
    6b66:	fe 01       	movw	r30, r28
    6b68:	e7 59       	subi	r30, 0x97	; 151
    6b6a:	ff 4f       	sbci	r31, 0xFF	; 255
    6b6c:	10 82       	st	Z, r1
    6b6e:	11 82       	std	Z+1, r1	; 0x01
    6b70:	12 82       	std	Z+2, r1	; 0x02
    6b72:	13 82       	std	Z+3, r1	; 0x03
    6b74:	fe 01       	movw	r30, r28
    6b76:	e3 59       	subi	r30, 0x93	; 147
    6b78:	ff 4f       	sbci	r31, 0xFF	; 255
    6b7a:	10 82       	st	Z, r1
    6b7c:	11 82       	std	Z+1, r1	; 0x01
    6b7e:	12 82       	std	Z+2, r1	; 0x02
    6b80:	13 82       	std	Z+3, r1	; 0x03
    6b82:	fe 01       	movw	r30, r28
    6b84:	ef 58       	subi	r30, 0x8F	; 143
    6b86:	ff 4f       	sbci	r31, 0xFF	; 255
    6b88:	10 82       	st	Z, r1
    6b8a:	11 82       	std	Z+1, r1	; 0x01
    6b8c:	12 82       	std	Z+2, r1	; 0x02
    6b8e:	13 82       	std	Z+3, r1	; 0x03
    6b90:	fe 01       	movw	r30, r28
    6b92:	eb 58       	subi	r30, 0x8B	; 139
    6b94:	ff 4f       	sbci	r31, 0xFF	; 255
    6b96:	10 82       	st	Z, r1
    6b98:	11 82       	std	Z+1, r1	; 0x01
    6b9a:	12 82       	std	Z+2, r1	; 0x02
    6b9c:	13 82       	std	Z+3, r1	; 0x03
    6b9e:	fe 01       	movw	r30, r28
    6ba0:	e7 58       	subi	r30, 0x87	; 135
    6ba2:	ff 4f       	sbci	r31, 0xFF	; 255
    6ba4:	10 82       	st	Z, r1
    6ba6:	11 82       	std	Z+1, r1	; 0x01
    6ba8:	12 82       	std	Z+2, r1	; 0x02
    6baa:	13 82       	std	Z+3, r1	; 0x03
    6bac:	fe 01       	movw	r30, r28
    6bae:	e3 58       	subi	r30, 0x83	; 131
    6bb0:	ff 4f       	sbci	r31, 0xFF	; 255
    6bb2:	10 82       	st	Z, r1
    6bb4:	11 82       	std	Z+1, r1	; 0x01
    6bb6:	12 82       	std	Z+2, r1	; 0x02
    6bb8:	13 82       	std	Z+3, r1	; 0x03
    6bba:	fe 01       	movw	r30, r28
    6bbc:	ef 57       	subi	r30, 0x7F	; 127
    6bbe:	ff 4f       	sbci	r31, 0xFF	; 255
    6bc0:	10 82       	st	Z, r1
    6bc2:	11 82       	std	Z+1, r1	; 0x01
    6bc4:	12 82       	std	Z+2, r1	; 0x02
    6bc6:	13 82       	std	Z+3, r1	; 0x03
    6bc8:	fe 01       	movw	r30, r28
    6bca:	eb 57       	subi	r30, 0x7B	; 123
    6bcc:	ff 4f       	sbci	r31, 0xFF	; 255
    6bce:	10 82       	st	Z, r1
    6bd0:	11 82       	std	Z+1, r1	; 0x01
    6bd2:	12 82       	std	Z+2, r1	; 0x02
    6bd4:	13 82       	std	Z+3, r1	; 0x03
    6bd6:	fe 01       	movw	r30, r28
    6bd8:	e7 57       	subi	r30, 0x77	; 119
    6bda:	ff 4f       	sbci	r31, 0xFF	; 255
    6bdc:	10 82       	st	Z, r1
    6bde:	11 82       	std	Z+1, r1	; 0x01
    6be0:	12 82       	std	Z+2, r1	; 0x02
    6be2:	13 82       	std	Z+3, r1	; 0x03
    6be4:	fe 01       	movw	r30, r28
    6be6:	e3 57       	subi	r30, 0x73	; 115
    6be8:	ff 4f       	sbci	r31, 0xFF	; 255
    6bea:	10 82       	st	Z, r1
    6bec:	11 82       	std	Z+1, r1	; 0x01
    6bee:	12 82       	std	Z+2, r1	; 0x02
    6bf0:	13 82       	std	Z+3, r1	; 0x03
    6bf2:	fe 01       	movw	r30, r28
    6bf4:	ef 56       	subi	r30, 0x6F	; 111
    6bf6:	ff 4f       	sbci	r31, 0xFF	; 255
    6bf8:	10 82       	st	Z, r1
    6bfa:	11 82       	std	Z+1, r1	; 0x01
    6bfc:	12 82       	std	Z+2, r1	; 0x02
    6bfe:	13 82       	std	Z+3, r1	; 0x03
    6c00:	fe 01       	movw	r30, r28
    6c02:	eb 56       	subi	r30, 0x6B	; 107
    6c04:	ff 4f       	sbci	r31, 0xFF	; 255
    6c06:	10 82       	st	Z, r1
    6c08:	11 82       	std	Z+1, r1	; 0x01
    6c0a:	12 82       	std	Z+2, r1	; 0x02
    6c0c:	13 82       	std	Z+3, r1	; 0x03
    6c0e:	fe 01       	movw	r30, r28
    6c10:	e7 56       	subi	r30, 0x67	; 103
    6c12:	ff 4f       	sbci	r31, 0xFF	; 255
    6c14:	10 82       	st	Z, r1
    6c16:	11 82       	std	Z+1, r1	; 0x01
    6c18:	12 82       	std	Z+2, r1	; 0x02
    6c1a:	13 82       	std	Z+3, r1	; 0x03
    6c1c:	fe 01       	movw	r30, r28
    6c1e:	e3 56       	subi	r30, 0x63	; 99
    6c20:	ff 4f       	sbci	r31, 0xFF	; 255
    6c22:	10 82       	st	Z, r1
    6c24:	11 82       	std	Z+1, r1	; 0x01
    6c26:	12 82       	std	Z+2, r1	; 0x02
    6c28:	13 82       	std	Z+3, r1	; 0x03
    6c2a:	fe 01       	movw	r30, r28
    6c2c:	ef 55       	subi	r30, 0x5F	; 95
    6c2e:	ff 4f       	sbci	r31, 0xFF	; 255
    6c30:	10 82       	st	Z, r1
    6c32:	11 82       	std	Z+1, r1	; 0x01
    6c34:	12 82       	std	Z+2, r1	; 0x02
    6c36:	13 82       	std	Z+3, r1	; 0x03
    6c38:	fe 01       	movw	r30, r28
    6c3a:	eb 55       	subi	r30, 0x5B	; 91
    6c3c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c3e:	10 82       	st	Z, r1
    6c40:	11 82       	std	Z+1, r1	; 0x01
    6c42:	12 82       	std	Z+2, r1	; 0x02
    6c44:	13 82       	std	Z+3, r1	; 0x03
    6c46:	fe 01       	movw	r30, r28
    6c48:	e7 55       	subi	r30, 0x57	; 87
    6c4a:	ff 4f       	sbci	r31, 0xFF	; 255
    6c4c:	10 82       	st	Z, r1
    6c4e:	11 82       	std	Z+1, r1	; 0x01
    6c50:	12 82       	std	Z+2, r1	; 0x02
    6c52:	13 82       	std	Z+3, r1	; 0x03
    6c54:	fe 01       	movw	r30, r28
    6c56:	e3 55       	subi	r30, 0x53	; 83
    6c58:	ff 4f       	sbci	r31, 0xFF	; 255
    6c5a:	10 82       	st	Z, r1
    6c5c:	11 82       	std	Z+1, r1	; 0x01
    6c5e:	12 82       	std	Z+2, r1	; 0x02
    6c60:	13 82       	std	Z+3, r1	; 0x03
    6c62:	fe 01       	movw	r30, r28
    6c64:	ef 54       	subi	r30, 0x4F	; 79
    6c66:	ff 4f       	sbci	r31, 0xFF	; 255
    6c68:	10 82       	st	Z, r1
    6c6a:	11 82       	std	Z+1, r1	; 0x01
    6c6c:	12 82       	std	Z+2, r1	; 0x02
    6c6e:	13 82       	std	Z+3, r1	; 0x03
    6c70:	fe 01       	movw	r30, r28
    6c72:	eb 54       	subi	r30, 0x4B	; 75
    6c74:	ff 4f       	sbci	r31, 0xFF	; 255
    6c76:	10 82       	st	Z, r1
    6c78:	11 82       	std	Z+1, r1	; 0x01
    6c7a:	12 82       	std	Z+2, r1	; 0x02
    6c7c:	13 82       	std	Z+3, r1	; 0x03
    6c7e:	fe 01       	movw	r30, r28
    6c80:	e7 54       	subi	r30, 0x47	; 71
    6c82:	ff 4f       	sbci	r31, 0xFF	; 255
    6c84:	10 82       	st	Z, r1
    6c86:	11 82       	std	Z+1, r1	; 0x01
    6c88:	12 82       	std	Z+2, r1	; 0x02
    6c8a:	13 82       	std	Z+3, r1	; 0x03
    6c8c:	fe 01       	movw	r30, r28
    6c8e:	e3 54       	subi	r30, 0x43	; 67
    6c90:	ff 4f       	sbci	r31, 0xFF	; 255
    6c92:	10 82       	st	Z, r1
    6c94:	11 82       	std	Z+1, r1	; 0x01
    6c96:	12 82       	std	Z+2, r1	; 0x02
    6c98:	13 82       	std	Z+3, r1	; 0x03
    6c9a:	fe 01       	movw	r30, r28
    6c9c:	ef 53       	subi	r30, 0x3F	; 63
    6c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    6ca0:	10 82       	st	Z, r1
    6ca2:	11 82       	std	Z+1, r1	; 0x01
    6ca4:	12 82       	std	Z+2, r1	; 0x02
    6ca6:	13 82       	std	Z+3, r1	; 0x03
    6ca8:	fe 01       	movw	r30, r28
    6caa:	eb 53       	subi	r30, 0x3B	; 59
    6cac:	ff 4f       	sbci	r31, 0xFF	; 255
    6cae:	10 82       	st	Z, r1
    6cb0:	11 82       	std	Z+1, r1	; 0x01
    6cb2:	12 82       	std	Z+2, r1	; 0x02
    6cb4:	13 82       	std	Z+3, r1	; 0x03
    6cb6:	fe 01       	movw	r30, r28
    6cb8:	e7 53       	subi	r30, 0x37	; 55
    6cba:	ff 4f       	sbci	r31, 0xFF	; 255
    6cbc:	10 82       	st	Z, r1
    6cbe:	11 82       	std	Z+1, r1	; 0x01
    6cc0:	12 82       	std	Z+2, r1	; 0x02
    6cc2:	13 82       	std	Z+3, r1	; 0x03
    6cc4:	fe 01       	movw	r30, r28
    6cc6:	e3 53       	subi	r30, 0x33	; 51
    6cc8:	ff 4f       	sbci	r31, 0xFF	; 255
    6cca:	10 82       	st	Z, r1
    6ccc:	11 82       	std	Z+1, r1	; 0x01
    6cce:	12 82       	std	Z+2, r1	; 0x02
    6cd0:	13 82       	std	Z+3, r1	; 0x03
    6cd2:	fe 01       	movw	r30, r28
    6cd4:	ef 52       	subi	r30, 0x2F	; 47
    6cd6:	ff 4f       	sbci	r31, 0xFF	; 255
    6cd8:	10 82       	st	Z, r1
    6cda:	11 82       	std	Z+1, r1	; 0x01
    6cdc:	12 82       	std	Z+2, r1	; 0x02
    6cde:	13 82       	std	Z+3, r1	; 0x03
    6ce0:	fe 01       	movw	r30, r28
    6ce2:	eb 52       	subi	r30, 0x2B	; 43
    6ce4:	ff 4f       	sbci	r31, 0xFF	; 255
    6ce6:	10 82       	st	Z, r1
    6ce8:	11 82       	std	Z+1, r1	; 0x01
    6cea:	12 82       	std	Z+2, r1	; 0x02
    6cec:	13 82       	std	Z+3, r1	; 0x03
    6cee:	fe 01       	movw	r30, r28
    6cf0:	e7 52       	subi	r30, 0x27	; 39
    6cf2:	ff 4f       	sbci	r31, 0xFF	; 255
    6cf4:	10 82       	st	Z, r1
    6cf6:	11 82       	std	Z+1, r1	; 0x01
    6cf8:	12 82       	std	Z+2, r1	; 0x02
    6cfa:	13 82       	std	Z+3, r1	; 0x03
    6cfc:	fe 01       	movw	r30, r28
    6cfe:	e3 52       	subi	r30, 0x23	; 35
    6d00:	ff 4f       	sbci	r31, 0xFF	; 255
    6d02:	10 82       	st	Z, r1
    6d04:	11 82       	std	Z+1, r1	; 0x01
    6d06:	12 82       	std	Z+2, r1	; 0x02
    6d08:	13 82       	std	Z+3, r1	; 0x03
    6d0a:	fe 01       	movw	r30, r28
    6d0c:	ef 51       	subi	r30, 0x1F	; 31
    6d0e:	ff 4f       	sbci	r31, 0xFF	; 255
    6d10:	10 82       	st	Z, r1
    6d12:	11 82       	std	Z+1, r1	; 0x01
    6d14:	12 82       	std	Z+2, r1	; 0x02
    6d16:	13 82       	std	Z+3, r1	; 0x03
    6d18:	fe 01       	movw	r30, r28
    6d1a:	eb 51       	subi	r30, 0x1B	; 27
    6d1c:	ff 4f       	sbci	r31, 0xFF	; 255
    6d1e:	10 82       	st	Z, r1
    6d20:	11 82       	std	Z+1, r1	; 0x01
    6d22:	12 82       	std	Z+2, r1	; 0x02
    6d24:	13 82       	std	Z+3, r1	; 0x03
    6d26:	fe 01       	movw	r30, r28
    6d28:	e7 51       	subi	r30, 0x17	; 23
    6d2a:	ff 4f       	sbci	r31, 0xFF	; 255
    6d2c:	10 82       	st	Z, r1
    6d2e:	11 82       	std	Z+1, r1	; 0x01
    6d30:	12 82       	std	Z+2, r1	; 0x02
    6d32:	13 82       	std	Z+3, r1	; 0x03
    6d34:	fe 01       	movw	r30, r28
    6d36:	e3 51       	subi	r30, 0x13	; 19
    6d38:	ff 4f       	sbci	r31, 0xFF	; 255
    6d3a:	10 82       	st	Z, r1
    6d3c:	11 82       	std	Z+1, r1	; 0x01
    6d3e:	12 82       	std	Z+2, r1	; 0x02
    6d40:	13 82       	std	Z+3, r1	; 0x03
    6d42:	fe 01       	movw	r30, r28
    6d44:	ef 50       	subi	r30, 0x0F	; 15
    6d46:	ff 4f       	sbci	r31, 0xFF	; 255
    6d48:	10 82       	st	Z, r1
    6d4a:	11 82       	std	Z+1, r1	; 0x01
    6d4c:	12 82       	std	Z+2, r1	; 0x02
    6d4e:	13 82       	std	Z+3, r1	; 0x03
    6d50:	fe 01       	movw	r30, r28
    6d52:	eb 50       	subi	r30, 0x0B	; 11
    6d54:	ff 4f       	sbci	r31, 0xFF	; 255
    6d56:	10 82       	st	Z, r1
    6d58:	11 82       	std	Z+1, r1	; 0x01
    6d5a:	12 82       	std	Z+2, r1	; 0x02
    6d5c:	13 82       	std	Z+3, r1	; 0x03
    6d5e:	fe 01       	movw	r30, r28
    6d60:	e7 50       	subi	r30, 0x07	; 7
    6d62:	ff 4f       	sbci	r31, 0xFF	; 255
    6d64:	10 82       	st	Z, r1
    6d66:	11 82       	std	Z+1, r1	; 0x01
    6d68:	12 82       	std	Z+2, r1	; 0x02
    6d6a:	13 82       	std	Z+3, r1	; 0x03
    6d6c:	fe 01       	movw	r30, r28
    6d6e:	e3 50       	subi	r30, 0x03	; 3
    6d70:	ff 4f       	sbci	r31, 0xFF	; 255
    6d72:	10 82       	st	Z, r1
    6d74:	11 82       	std	Z+1, r1	; 0x01
    6d76:	12 82       	std	Z+2, r1	; 0x02
    6d78:	13 82       	std	Z+3, r1	; 0x03
    6d7a:	fe 01       	movw	r30, r28
    6d7c:	ef 5f       	subi	r30, 0xFF	; 255
    6d7e:	fe 4f       	sbci	r31, 0xFE	; 254
    6d80:	10 82       	st	Z, r1
    6d82:	11 82       	std	Z+1, r1	; 0x01
    6d84:	12 82       	std	Z+2, r1	; 0x02
    6d86:	13 82       	std	Z+3, r1	; 0x03
    6d88:	fe 01       	movw	r30, r28
    6d8a:	eb 5f       	subi	r30, 0xFB	; 251
    6d8c:	fe 4f       	sbci	r31, 0xFE	; 254
    6d8e:	10 82       	st	Z, r1
    6d90:	11 82       	std	Z+1, r1	; 0x01
    6d92:	12 82       	std	Z+2, r1	; 0x02
    6d94:	13 82       	std	Z+3, r1	; 0x03
    6d96:	fe 01       	movw	r30, r28
    6d98:	e7 5f       	subi	r30, 0xF7	; 247
    6d9a:	fe 4f       	sbci	r31, 0xFE	; 254
    6d9c:	10 82       	st	Z, r1
    6d9e:	11 82       	std	Z+1, r1	; 0x01
    6da0:	12 82       	std	Z+2, r1	; 0x02
    6da2:	13 82       	std	Z+3, r1	; 0x03
    6da4:	fe 01       	movw	r30, r28
    6da6:	e3 5f       	subi	r30, 0xF3	; 243
    6da8:	fe 4f       	sbci	r31, 0xFE	; 254
    6daa:	10 82       	st	Z, r1
    6dac:	11 82       	std	Z+1, r1	; 0x01
    6dae:	12 82       	std	Z+2, r1	; 0x02
    6db0:	13 82       	std	Z+3, r1	; 0x03
    6db2:	fe 01       	movw	r30, r28
    6db4:	ef 5e       	subi	r30, 0xEF	; 239
    6db6:	fe 4f       	sbci	r31, 0xFE	; 254
    6db8:	10 82       	st	Z, r1
    6dba:	11 82       	std	Z+1, r1	; 0x01
    6dbc:	12 82       	std	Z+2, r1	; 0x02
    6dbe:	13 82       	std	Z+3, r1	; 0x03
    6dc0:	fe 01       	movw	r30, r28
    6dc2:	eb 5e       	subi	r30, 0xEB	; 235
    6dc4:	fe 4f       	sbci	r31, 0xFE	; 254
    6dc6:	10 82       	st	Z, r1
    6dc8:	11 82       	std	Z+1, r1	; 0x01
    6dca:	12 82       	std	Z+2, r1	; 0x02
    6dcc:	13 82       	std	Z+3, r1	; 0x03
    6dce:	fe 01       	movw	r30, r28
    6dd0:	e7 5e       	subi	r30, 0xE7	; 231
    6dd2:	fe 4f       	sbci	r31, 0xFE	; 254
    6dd4:	10 82       	st	Z, r1
    6dd6:	11 82       	std	Z+1, r1	; 0x01
    6dd8:	12 82       	std	Z+2, r1	; 0x02
    6dda:	13 82       	std	Z+3, r1	; 0x03
    6ddc:	fe 01       	movw	r30, r28
    6dde:	e3 5e       	subi	r30, 0xE3	; 227
    6de0:	fe 4f       	sbci	r31, 0xFE	; 254
    6de2:	10 82       	st	Z, r1
    6de4:	11 82       	std	Z+1, r1	; 0x01
    6de6:	12 82       	std	Z+2, r1	; 0x02
    6de8:	13 82       	std	Z+3, r1	; 0x03
    6dea:	fe 01       	movw	r30, r28
    6dec:	ef 5d       	subi	r30, 0xDF	; 223
    6dee:	fe 4f       	sbci	r31, 0xFE	; 254
    6df0:	10 82       	st	Z, r1
    6df2:	11 82       	std	Z+1, r1	; 0x01
    6df4:	12 82       	std	Z+2, r1	; 0x02
    6df6:	13 82       	std	Z+3, r1	; 0x03
    6df8:	fe 01       	movw	r30, r28
    6dfa:	eb 5d       	subi	r30, 0xDB	; 219
    6dfc:	fe 4f       	sbci	r31, 0xFE	; 254
    6dfe:	10 82       	st	Z, r1
    6e00:	11 82       	std	Z+1, r1	; 0x01
    6e02:	12 82       	std	Z+2, r1	; 0x02
    6e04:	13 82       	std	Z+3, r1	; 0x03
    6e06:	fe 01       	movw	r30, r28
    6e08:	e7 5d       	subi	r30, 0xD7	; 215
    6e0a:	fe 4f       	sbci	r31, 0xFE	; 254
    6e0c:	10 82       	st	Z, r1
    6e0e:	11 82       	std	Z+1, r1	; 0x01
    6e10:	12 82       	std	Z+2, r1	; 0x02
    6e12:	13 82       	std	Z+3, r1	; 0x03
    6e14:	fe 01       	movw	r30, r28
    6e16:	e3 5d       	subi	r30, 0xD3	; 211
    6e18:	fe 4f       	sbci	r31, 0xFE	; 254
    6e1a:	10 82       	st	Z, r1
    6e1c:	11 82       	std	Z+1, r1	; 0x01
    6e1e:	12 82       	std	Z+2, r1	; 0x02
    6e20:	13 82       	std	Z+3, r1	; 0x03
	msg->buildMessage(message);
    6e22:	b8 01       	movw	r22, r16
    6e24:	ce 01       	movw	r24, r28
    6e26:	0e 94 bc 30 	call	0x6178	; 0x6178 <_ZN10helicopter8messages22SystemTelemetryMessage12buildMessageEPh>
	
	return msg;
}
    6e2a:	8c 2f       	mov	r24, r28
    6e2c:	9d 2f       	mov	r25, r29
    6e2e:	df 91       	pop	r29
    6e30:	cf 91       	pop	r28
    6e32:	1f 91       	pop	r17
    6e34:	0f 91       	pop	r16
    6e36:	08 95       	ret

00006e38 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>:

SystemTelemetryMessage * SystemTelemetryMessage::buildMessageFromModel(SystemModel *model)
{
    6e38:	2f 92       	push	r2
    6e3a:	3f 92       	push	r3
    6e3c:	4f 92       	push	r4
    6e3e:	5f 92       	push	r5
    6e40:	6f 92       	push	r6
    6e42:	7f 92       	push	r7
    6e44:	8f 92       	push	r8
    6e46:	9f 92       	push	r9
    6e48:	af 92       	push	r10
    6e4a:	bf 92       	push	r11
    6e4c:	cf 92       	push	r12
    6e4e:	df 92       	push	r13
    6e50:	ef 92       	push	r14
    6e52:	ff 92       	push	r15
    6e54:	0f 93       	push	r16
    6e56:	1f 93       	push	r17
    6e58:	cf 93       	push	r28
    6e5a:	df 93       	push	r29
    6e5c:	cd b7       	in	r28, 0x3d	; 61
    6e5e:	de b7       	in	r29, 0x3e	; 62
    6e60:	c8 54       	subi	r28, 0x48	; 72
    6e62:	d1 09       	sbc	r29, r1
    6e64:	0f b6       	in	r0, 0x3f	; 63
    6e66:	f8 94       	cli
    6e68:	de bf       	out	0x3e, r29	; 62
    6e6a:	0f be       	out	0x3f, r0	; 63
    6e6c:	cd bf       	out	0x3d, r28	; 61
    6e6e:	25 96       	adiw	r28, 0x05	; 5
    6e70:	9f af       	std	Y+63, r25	; 0x3f
    6e72:	8e af       	std	Y+62, r24	; 0x3e
    6e74:	25 97       	sbiw	r28, 0x05	; 5
	SystemTelemetryMessage *message = new SystemTelemetryMessage();
    6e76:	81 e3       	ldi	r24, 0x31	; 49
    6e78:	91 e0       	ldi	r25, 0x01	; 1
    6e7a:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    6e7e:	fc 01       	movw	r30, r24
    6e80:	82 e0       	ldi	r24, 0x02	; 2
    6e82:	82 83       	std	Z+2, r24	; 0x02
    6e84:	8d e2       	ldi	r24, 0x2D	; 45
    6e86:	91 e0       	ldi	r25, 0x01	; 1
    6e88:	94 83       	std	Z+4, r25	; 0x04
    6e8a:	83 83       	std	Z+3, r24	; 0x03
    6e8c:	80 e8       	ldi	r24, 0x80	; 128
    6e8e:	92 e0       	ldi	r25, 0x02	; 2
    6e90:	91 83       	std	Z+1, r25	; 0x01
    6e92:	80 83       	st	Z, r24
    6e94:	15 82       	std	Z+5, r1	; 0x05
    6e96:	16 82       	std	Z+6, r1	; 0x06
    6e98:	17 82       	std	Z+7, r1	; 0x07
    6e9a:	10 86       	std	Z+8, r1	; 0x08
    6e9c:	11 86       	std	Z+9, r1	; 0x09
    6e9e:	12 86       	std	Z+10, r1	; 0x0a
    6ea0:	13 86       	std	Z+11, r1	; 0x0b
    6ea2:	14 86       	std	Z+12, r1	; 0x0c
    6ea4:	15 86       	std	Z+13, r1	; 0x0d
    6ea6:	16 86       	std	Z+14, r1	; 0x0e
    6ea8:	17 86       	std	Z+15, r1	; 0x0f
    6eaa:	10 8a       	std	Z+16, r1	; 0x10
    6eac:	11 8a       	std	Z+17, r1	; 0x11
    6eae:	12 8a       	std	Z+18, r1	; 0x12
    6eb0:	13 8a       	std	Z+19, r1	; 0x13
    6eb2:	14 8a       	std	Z+20, r1	; 0x14
    6eb4:	15 8a       	std	Z+21, r1	; 0x15
    6eb6:	16 8a       	std	Z+22, r1	; 0x16
    6eb8:	17 8a       	std	Z+23, r1	; 0x17
    6eba:	10 8e       	std	Z+24, r1	; 0x18
    6ebc:	11 8e       	std	Z+25, r1	; 0x19
    6ebe:	12 8e       	std	Z+26, r1	; 0x1a
    6ec0:	13 8e       	std	Z+27, r1	; 0x1b
    6ec2:	14 8e       	std	Z+28, r1	; 0x1c
    6ec4:	15 8e       	std	Z+29, r1	; 0x1d
    6ec6:	16 8e       	std	Z+30, r1	; 0x1e
    6ec8:	17 8e       	std	Z+31, r1	; 0x1f
    6eca:	10 a2       	std	Z+32, r1	; 0x20
    6ecc:	11 a2       	std	Z+33, r1	; 0x21
    6ece:	12 a2       	std	Z+34, r1	; 0x22
    6ed0:	13 a2       	std	Z+35, r1	; 0x23
    6ed2:	14 a2       	std	Z+36, r1	; 0x24
    6ed4:	15 a2       	std	Z+37, r1	; 0x25
    6ed6:	16 a2       	std	Z+38, r1	; 0x26
    6ed8:	17 a2       	std	Z+39, r1	; 0x27
    6eda:	10 a6       	std	Z+40, r1	; 0x28
    6edc:	11 a6       	std	Z+41, r1	; 0x29
    6ede:	12 a6       	std	Z+42, r1	; 0x2a
    6ee0:	13 a6       	std	Z+43, r1	; 0x2b
    6ee2:	14 a6       	std	Z+44, r1	; 0x2c
    6ee4:	15 a6       	std	Z+45, r1	; 0x2d
    6ee6:	16 a6       	std	Z+46, r1	; 0x2e
    6ee8:	17 a6       	std	Z+47, r1	; 0x2f
    6eea:	10 aa       	std	Z+48, r1	; 0x30
    6eec:	11 aa       	std	Z+49, r1	; 0x31
    6eee:	12 aa       	std	Z+50, r1	; 0x32
    6ef0:	13 aa       	std	Z+51, r1	; 0x33
    6ef2:	14 aa       	std	Z+52, r1	; 0x34
    6ef4:	15 aa       	std	Z+53, r1	; 0x35
    6ef6:	16 aa       	std	Z+54, r1	; 0x36
    6ef8:	17 aa       	std	Z+55, r1	; 0x37
    6efa:	10 ae       	std	Z+56, r1	; 0x38
    6efc:	11 ae       	std	Z+57, r1	; 0x39
    6efe:	12 ae       	std	Z+58, r1	; 0x3a
    6f00:	13 ae       	std	Z+59, r1	; 0x3b
    6f02:	14 ae       	std	Z+60, r1	; 0x3c
    6f04:	9f 01       	movw	r18, r30
    6f06:	23 5c       	subi	r18, 0xC3	; 195
    6f08:	3f 4f       	sbci	r19, 0xFF	; 255
    6f0a:	3a 83       	std	Y+2, r19	; 0x02
    6f0c:	29 83       	std	Y+1, r18	; 0x01
    6f0e:	d9 01       	movw	r26, r18
    6f10:	1d 92       	st	X+, r1
    6f12:	1d 92       	st	X+, r1
    6f14:	1d 92       	st	X+, r1
    6f16:	1c 92       	st	X, r1
    6f18:	13 97       	sbiw	r26, 0x03	; 3
    6f1a:	df 01       	movw	r26, r30
    6f1c:	af 5b       	subi	r26, 0xBF	; 191
    6f1e:	bf 4f       	sbci	r27, 0xFF	; 255
    6f20:	1d 92       	st	X+, r1
    6f22:	1d 92       	st	X+, r1
    6f24:	1d 92       	st	X+, r1
    6f26:	1c 92       	st	X, r1
    6f28:	13 97       	sbiw	r26, 0x03	; 3
    6f2a:	df 01       	movw	r26, r30
    6f2c:	ab 5b       	subi	r26, 0xBB	; 187
    6f2e:	bf 4f       	sbci	r27, 0xFF	; 255
    6f30:	1d 92       	st	X+, r1
    6f32:	1d 92       	st	X+, r1
    6f34:	1d 92       	st	X+, r1
    6f36:	1c 92       	st	X, r1
    6f38:	13 97       	sbiw	r26, 0x03	; 3
    6f3a:	df 01       	movw	r26, r30
    6f3c:	a7 5b       	subi	r26, 0xB7	; 183
    6f3e:	bf 4f       	sbci	r27, 0xFF	; 255
    6f40:	1d 92       	st	X+, r1
    6f42:	1d 92       	st	X+, r1
    6f44:	1d 92       	st	X+, r1
    6f46:	1c 92       	st	X, r1
    6f48:	13 97       	sbiw	r26, 0x03	; 3
    6f4a:	df 01       	movw	r26, r30
    6f4c:	a3 5b       	subi	r26, 0xB3	; 179
    6f4e:	bf 4f       	sbci	r27, 0xFF	; 255
    6f50:	1d 92       	st	X+, r1
    6f52:	1d 92       	st	X+, r1
    6f54:	1d 92       	st	X+, r1
    6f56:	1c 92       	st	X, r1
    6f58:	13 97       	sbiw	r26, 0x03	; 3
    6f5a:	df 01       	movw	r26, r30
    6f5c:	af 5a       	subi	r26, 0xAF	; 175
    6f5e:	bf 4f       	sbci	r27, 0xFF	; 255
    6f60:	1d 92       	st	X+, r1
    6f62:	1d 92       	st	X+, r1
    6f64:	1d 92       	st	X+, r1
    6f66:	1c 92       	st	X, r1
    6f68:	13 97       	sbiw	r26, 0x03	; 3
    6f6a:	8f 01       	movw	r16, r30
    6f6c:	0b 5a       	subi	r16, 0xAB	; 171
    6f6e:	1f 4f       	sbci	r17, 0xFF	; 255
    6f70:	d8 01       	movw	r26, r16
    6f72:	1d 92       	st	X+, r1
    6f74:	1d 92       	st	X+, r1
    6f76:	1d 92       	st	X+, r1
    6f78:	1c 92       	st	X, r1
    6f7a:	13 97       	sbiw	r26, 0x03	; 3
    6f7c:	df 01       	movw	r26, r30
    6f7e:	a7 5a       	subi	r26, 0xA7	; 167
    6f80:	bf 4f       	sbci	r27, 0xFF	; 255
    6f82:	1d 92       	st	X+, r1
    6f84:	1d 92       	st	X+, r1
    6f86:	1d 92       	st	X+, r1
    6f88:	1c 92       	st	X, r1
    6f8a:	13 97       	sbiw	r26, 0x03	; 3
    6f8c:	af 01       	movw	r20, r30
    6f8e:	43 5a       	subi	r20, 0xA3	; 163
    6f90:	5f 4f       	sbci	r21, 0xFF	; 255
    6f92:	da 01       	movw	r26, r20
    6f94:	1d 92       	st	X+, r1
    6f96:	1d 92       	st	X+, r1
    6f98:	1d 92       	st	X+, r1
    6f9a:	1c 92       	st	X, r1
    6f9c:	13 97       	sbiw	r26, 0x03	; 3
    6f9e:	3f 01       	movw	r6, r30
    6fa0:	b1 e6       	ldi	r27, 0x61	; 97
    6fa2:	6b 0e       	add	r6, r27
    6fa4:	71 1c       	adc	r7, r1
    6fa6:	d3 01       	movw	r26, r6
    6fa8:	1d 92       	st	X+, r1
    6faa:	1d 92       	st	X+, r1
    6fac:	1d 92       	st	X+, r1
    6fae:	1c 92       	st	X, r1
    6fb0:	13 97       	sbiw	r26, 0x03	; 3
    6fb2:	bf 01       	movw	r22, r30
    6fb4:	6b 59       	subi	r22, 0x9B	; 155
    6fb6:	7f 4f       	sbci	r23, 0xFF	; 255
    6fb8:	db 01       	movw	r26, r22
    6fba:	1d 92       	st	X+, r1
    6fbc:	1d 92       	st	X+, r1
    6fbe:	1d 92       	st	X+, r1
    6fc0:	1c 92       	st	X, r1
    6fc2:	13 97       	sbiw	r26, 0x03	; 3
    6fc4:	5f 01       	movw	r10, r30
    6fc6:	b9 e6       	ldi	r27, 0x69	; 105
    6fc8:	ab 0e       	add	r10, r27
    6fca:	b1 1c       	adc	r11, r1
    6fcc:	d5 01       	movw	r26, r10
    6fce:	1d 92       	st	X+, r1
    6fd0:	1d 92       	st	X+, r1
    6fd2:	1d 92       	st	X+, r1
    6fd4:	1c 92       	st	X, r1
    6fd6:	13 97       	sbiw	r26, 0x03	; 3
    6fd8:	4f 01       	movw	r8, r30
    6fda:	bd e6       	ldi	r27, 0x6D	; 109
    6fdc:	8b 0e       	add	r8, r27
    6fde:	91 1c       	adc	r9, r1
    6fe0:	d4 01       	movw	r26, r8
    6fe2:	1d 92       	st	X+, r1
    6fe4:	1d 92       	st	X+, r1
    6fe6:	1d 92       	st	X+, r1
    6fe8:	1c 92       	st	X, r1
    6fea:	13 97       	sbiw	r26, 0x03	; 3
    6fec:	9f 01       	movw	r18, r30
    6fee:	2f 58       	subi	r18, 0x8F	; 143
    6ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    6ff2:	27 96       	adiw	r28, 0x07	; 7
    6ff4:	3f af       	std	Y+63, r19	; 0x3f
    6ff6:	2e af       	std	Y+62, r18	; 0x3e
    6ff8:	27 97       	sbiw	r28, 0x07	; 7
    6ffa:	d9 01       	movw	r26, r18
    6ffc:	1d 92       	st	X+, r1
    6ffe:	1d 92       	st	X+, r1
    7000:	1d 92       	st	X+, r1
    7002:	1c 92       	st	X, r1
    7004:	13 97       	sbiw	r26, 0x03	; 3
    7006:	2f 01       	movw	r4, r30
    7008:	b5 e7       	ldi	r27, 0x75	; 117
    700a:	4b 0e       	add	r4, r27
    700c:	51 1c       	adc	r5, r1
    700e:	d2 01       	movw	r26, r4
    7010:	1d 92       	st	X+, r1
    7012:	1d 92       	st	X+, r1
    7014:	1d 92       	st	X+, r1
    7016:	1c 92       	st	X, r1
    7018:	13 97       	sbiw	r26, 0x03	; 3
    701a:	df 01       	movw	r26, r30
    701c:	a7 58       	subi	r26, 0x87	; 135
    701e:	bf 4f       	sbci	r27, 0xFF	; 255
    7020:	1d 92       	st	X+, r1
    7022:	1d 92       	st	X+, r1
    7024:	1d 92       	st	X+, r1
    7026:	1c 92       	st	X, r1
    7028:	13 97       	sbiw	r26, 0x03	; 3
    702a:	df 01       	movw	r26, r30
    702c:	a3 58       	subi	r26, 0x83	; 131
    702e:	bf 4f       	sbci	r27, 0xFF	; 255
    7030:	1d 92       	st	X+, r1
    7032:	1d 92       	st	X+, r1
    7034:	1d 92       	st	X+, r1
    7036:	1c 92       	st	X, r1
    7038:	13 97       	sbiw	r26, 0x03	; 3
    703a:	df 01       	movw	r26, r30
    703c:	af 57       	subi	r26, 0x7F	; 127
    703e:	bf 4f       	sbci	r27, 0xFF	; 255
    7040:	1d 92       	st	X+, r1
    7042:	1d 92       	st	X+, r1
    7044:	1d 92       	st	X+, r1
    7046:	1c 92       	st	X, r1
    7048:	13 97       	sbiw	r26, 0x03	; 3
    704a:	df 01       	movw	r26, r30
    704c:	ab 57       	subi	r26, 0x7B	; 123
    704e:	bf 4f       	sbci	r27, 0xFF	; 255
    7050:	1d 92       	st	X+, r1
    7052:	1d 92       	st	X+, r1
    7054:	1d 92       	st	X+, r1
    7056:	1c 92       	st	X, r1
    7058:	13 97       	sbiw	r26, 0x03	; 3
    705a:	df 01       	movw	r26, r30
    705c:	a7 57       	subi	r26, 0x77	; 119
    705e:	bf 4f       	sbci	r27, 0xFF	; 255
    7060:	1d 92       	st	X+, r1
    7062:	1d 92       	st	X+, r1
    7064:	1d 92       	st	X+, r1
    7066:	1c 92       	st	X, r1
    7068:	13 97       	sbiw	r26, 0x03	; 3
    706a:	1f 01       	movw	r2, r30
    706c:	bd e8       	ldi	r27, 0x8D	; 141
    706e:	2b 0e       	add	r2, r27
    7070:	31 1c       	adc	r3, r1
    7072:	d1 01       	movw	r26, r2
    7074:	1d 92       	st	X+, r1
    7076:	1d 92       	st	X+, r1
    7078:	1d 92       	st	X+, r1
    707a:	1c 92       	st	X, r1
    707c:	13 97       	sbiw	r26, 0x03	; 3
    707e:	df 01       	movw	r26, r30
    7080:	af 56       	subi	r26, 0x6F	; 111
    7082:	bf 4f       	sbci	r27, 0xFF	; 255
    7084:	1d 92       	st	X+, r1
    7086:	1d 92       	st	X+, r1
    7088:	1d 92       	st	X+, r1
    708a:	1c 92       	st	X, r1
    708c:	13 97       	sbiw	r26, 0x03	; 3
    708e:	df 01       	movw	r26, r30
    7090:	ab 56       	subi	r26, 0x6B	; 107
    7092:	bf 4f       	sbci	r27, 0xFF	; 255
    7094:	1d 92       	st	X+, r1
    7096:	1d 92       	st	X+, r1
    7098:	1d 92       	st	X+, r1
    709a:	1c 92       	st	X, r1
    709c:	13 97       	sbiw	r26, 0x03	; 3
    709e:	9f 01       	movw	r18, r30
    70a0:	27 56       	subi	r18, 0x67	; 103
    70a2:	3f 4f       	sbci	r19, 0xFF	; 255
    70a4:	3c 83       	std	Y+4, r19	; 0x04
    70a6:	2b 83       	std	Y+3, r18	; 0x03
    70a8:	d9 01       	movw	r26, r18
    70aa:	1d 92       	st	X+, r1
    70ac:	1d 92       	st	X+, r1
    70ae:	1d 92       	st	X+, r1
    70b0:	1c 92       	st	X, r1
    70b2:	13 97       	sbiw	r26, 0x03	; 3
    70b4:	9f 01       	movw	r18, r30
    70b6:	23 56       	subi	r18, 0x63	; 99
    70b8:	3f 4f       	sbci	r19, 0xFF	; 255
    70ba:	3e 83       	std	Y+6, r19	; 0x06
    70bc:	2d 83       	std	Y+5, r18	; 0x05
    70be:	d9 01       	movw	r26, r18
    70c0:	1d 92       	st	X+, r1
    70c2:	1d 92       	st	X+, r1
    70c4:	1d 92       	st	X+, r1
    70c6:	1c 92       	st	X, r1
    70c8:	13 97       	sbiw	r26, 0x03	; 3
    70ca:	9f 01       	movw	r18, r30
    70cc:	2f 55       	subi	r18, 0x5F	; 95
    70ce:	3f 4f       	sbci	r19, 0xFF	; 255
    70d0:	38 87       	std	Y+8, r19	; 0x08
    70d2:	2f 83       	std	Y+7, r18	; 0x07
    70d4:	d9 01       	movw	r26, r18
    70d6:	1d 92       	st	X+, r1
    70d8:	1d 92       	st	X+, r1
    70da:	1d 92       	st	X+, r1
    70dc:	1c 92       	st	X, r1
    70de:	13 97       	sbiw	r26, 0x03	; 3
    70e0:	9f 01       	movw	r18, r30
    70e2:	2b 55       	subi	r18, 0x5B	; 91
    70e4:	3f 4f       	sbci	r19, 0xFF	; 255
    70e6:	3a 87       	std	Y+10, r19	; 0x0a
    70e8:	29 87       	std	Y+9, r18	; 0x09
    70ea:	d9 01       	movw	r26, r18
    70ec:	1d 92       	st	X+, r1
    70ee:	1d 92       	st	X+, r1
    70f0:	1d 92       	st	X+, r1
    70f2:	1c 92       	st	X, r1
    70f4:	13 97       	sbiw	r26, 0x03	; 3
    70f6:	9f 01       	movw	r18, r30
    70f8:	27 55       	subi	r18, 0x57	; 87
    70fa:	3f 4f       	sbci	r19, 0xFF	; 255
    70fc:	3c 87       	std	Y+12, r19	; 0x0c
    70fe:	2b 87       	std	Y+11, r18	; 0x0b
    7100:	d9 01       	movw	r26, r18
    7102:	1d 92       	st	X+, r1
    7104:	1d 92       	st	X+, r1
    7106:	1d 92       	st	X+, r1
    7108:	1c 92       	st	X, r1
    710a:	13 97       	sbiw	r26, 0x03	; 3
    710c:	9f 01       	movw	r18, r30
    710e:	23 55       	subi	r18, 0x53	; 83
    7110:	3f 4f       	sbci	r19, 0xFF	; 255
    7112:	3e 87       	std	Y+14, r19	; 0x0e
    7114:	2d 87       	std	Y+13, r18	; 0x0d
    7116:	d9 01       	movw	r26, r18
    7118:	1d 92       	st	X+, r1
    711a:	1d 92       	st	X+, r1
    711c:	1d 92       	st	X+, r1
    711e:	1c 92       	st	X, r1
    7120:	13 97       	sbiw	r26, 0x03	; 3
    7122:	df 01       	movw	r26, r30
    7124:	af 54       	subi	r26, 0x4F	; 79
    7126:	bf 4f       	sbci	r27, 0xFF	; 255
    7128:	1d 92       	st	X+, r1
    712a:	1d 92       	st	X+, r1
    712c:	1d 92       	st	X+, r1
    712e:	1c 92       	st	X, r1
    7130:	13 97       	sbiw	r26, 0x03	; 3
    7132:	df 01       	movw	r26, r30
    7134:	ab 54       	subi	r26, 0x4B	; 75
    7136:	bf 4f       	sbci	r27, 0xFF	; 255
    7138:	1d 92       	st	X+, r1
    713a:	1d 92       	st	X+, r1
    713c:	1d 92       	st	X+, r1
    713e:	1c 92       	st	X, r1
    7140:	13 97       	sbiw	r26, 0x03	; 3
    7142:	df 01       	movw	r26, r30
    7144:	a7 54       	subi	r26, 0x47	; 71
    7146:	bf 4f       	sbci	r27, 0xFF	; 255
    7148:	1d 92       	st	X+, r1
    714a:	1d 92       	st	X+, r1
    714c:	1d 92       	st	X+, r1
    714e:	1c 92       	st	X, r1
    7150:	13 97       	sbiw	r26, 0x03	; 3
    7152:	df 01       	movw	r26, r30
    7154:	a3 54       	subi	r26, 0x43	; 67
    7156:	bf 4f       	sbci	r27, 0xFF	; 255
    7158:	1d 92       	st	X+, r1
    715a:	1d 92       	st	X+, r1
    715c:	1d 92       	st	X+, r1
    715e:	1c 92       	st	X, r1
    7160:	13 97       	sbiw	r26, 0x03	; 3
    7162:	9f 01       	movw	r18, r30
    7164:	2f 53       	subi	r18, 0x3F	; 63
    7166:	3f 4f       	sbci	r19, 0xFF	; 255
    7168:	38 8b       	std	Y+16, r19	; 0x10
    716a:	2f 87       	std	Y+15, r18	; 0x0f
    716c:	d9 01       	movw	r26, r18
    716e:	1d 92       	st	X+, r1
    7170:	1d 92       	st	X+, r1
    7172:	1d 92       	st	X+, r1
    7174:	1c 92       	st	X, r1
    7176:	13 97       	sbiw	r26, 0x03	; 3
    7178:	9f 01       	movw	r18, r30
    717a:	2b 53       	subi	r18, 0x3B	; 59
    717c:	3f 4f       	sbci	r19, 0xFF	; 255
    717e:	3a 8b       	std	Y+18, r19	; 0x12
    7180:	29 8b       	std	Y+17, r18	; 0x11
    7182:	d9 01       	movw	r26, r18
    7184:	1d 92       	st	X+, r1
    7186:	1d 92       	st	X+, r1
    7188:	1d 92       	st	X+, r1
    718a:	1c 92       	st	X, r1
    718c:	13 97       	sbiw	r26, 0x03	; 3
    718e:	9f 01       	movw	r18, r30
    7190:	27 53       	subi	r18, 0x37	; 55
    7192:	3f 4f       	sbci	r19, 0xFF	; 255
    7194:	3c 8b       	std	Y+20, r19	; 0x14
    7196:	2b 8b       	std	Y+19, r18	; 0x13
    7198:	d9 01       	movw	r26, r18
    719a:	1d 92       	st	X+, r1
    719c:	1d 92       	st	X+, r1
    719e:	1d 92       	st	X+, r1
    71a0:	1c 92       	st	X, r1
    71a2:	13 97       	sbiw	r26, 0x03	; 3
    71a4:	9f 01       	movw	r18, r30
    71a6:	23 53       	subi	r18, 0x33	; 51
    71a8:	3f 4f       	sbci	r19, 0xFF	; 255
    71aa:	3e 8b       	std	Y+22, r19	; 0x16
    71ac:	2d 8b       	std	Y+21, r18	; 0x15
    71ae:	d9 01       	movw	r26, r18
    71b0:	1d 92       	st	X+, r1
    71b2:	1d 92       	st	X+, r1
    71b4:	1d 92       	st	X+, r1
    71b6:	1c 92       	st	X, r1
    71b8:	13 97       	sbiw	r26, 0x03	; 3
    71ba:	9f 01       	movw	r18, r30
    71bc:	2f 52       	subi	r18, 0x2F	; 47
    71be:	3f 4f       	sbci	r19, 0xFF	; 255
    71c0:	38 8f       	std	Y+24, r19	; 0x18
    71c2:	2f 8b       	std	Y+23, r18	; 0x17
    71c4:	d9 01       	movw	r26, r18
    71c6:	1d 92       	st	X+, r1
    71c8:	1d 92       	st	X+, r1
    71ca:	1d 92       	st	X+, r1
    71cc:	1c 92       	st	X, r1
    71ce:	13 97       	sbiw	r26, 0x03	; 3
    71d0:	9f 01       	movw	r18, r30
    71d2:	2b 52       	subi	r18, 0x2B	; 43
    71d4:	3f 4f       	sbci	r19, 0xFF	; 255
    71d6:	3a 8f       	std	Y+26, r19	; 0x1a
    71d8:	29 8f       	std	Y+25, r18	; 0x19
    71da:	d9 01       	movw	r26, r18
    71dc:	1d 92       	st	X+, r1
    71de:	1d 92       	st	X+, r1
    71e0:	1d 92       	st	X+, r1
    71e2:	1c 92       	st	X, r1
    71e4:	13 97       	sbiw	r26, 0x03	; 3
    71e6:	9f 01       	movw	r18, r30
    71e8:	27 52       	subi	r18, 0x27	; 39
    71ea:	3f 4f       	sbci	r19, 0xFF	; 255
    71ec:	3c 8f       	std	Y+28, r19	; 0x1c
    71ee:	2b 8f       	std	Y+27, r18	; 0x1b
    71f0:	d9 01       	movw	r26, r18
    71f2:	1d 92       	st	X+, r1
    71f4:	1d 92       	st	X+, r1
    71f6:	1d 92       	st	X+, r1
    71f8:	1c 92       	st	X, r1
    71fa:	13 97       	sbiw	r26, 0x03	; 3
    71fc:	cf 01       	movw	r24, r30
    71fe:	83 52       	subi	r24, 0x23	; 35
    7200:	9f 4f       	sbci	r25, 0xFF	; 255
    7202:	dc 01       	movw	r26, r24
    7204:	1d 92       	st	X+, r1
    7206:	1d 92       	st	X+, r1
    7208:	1d 92       	st	X+, r1
    720a:	1c 92       	st	X, r1
    720c:	13 97       	sbiw	r26, 0x03	; 3
    720e:	9f 01       	movw	r18, r30
    7210:	2f 51       	subi	r18, 0x1F	; 31
    7212:	3f 4f       	sbci	r19, 0xFF	; 255
    7214:	29 96       	adiw	r28, 0x09	; 9
    7216:	3f af       	std	Y+63, r19	; 0x3f
    7218:	2e af       	std	Y+62, r18	; 0x3e
    721a:	29 97       	sbiw	r28, 0x09	; 9
    721c:	d9 01       	movw	r26, r18
    721e:	1d 92       	st	X+, r1
    7220:	1d 92       	st	X+, r1
    7222:	1d 92       	st	X+, r1
    7224:	1c 92       	st	X, r1
    7226:	13 97       	sbiw	r26, 0x03	; 3
    7228:	9f 01       	movw	r18, r30
    722a:	2b 51       	subi	r18, 0x1B	; 27
    722c:	3f 4f       	sbci	r19, 0xFF	; 255
    722e:	3e 8f       	std	Y+30, r19	; 0x1e
    7230:	2d 8f       	std	Y+29, r18	; 0x1d
    7232:	d9 01       	movw	r26, r18
    7234:	1d 92       	st	X+, r1
    7236:	1d 92       	st	X+, r1
    7238:	1d 92       	st	X+, r1
    723a:	1c 92       	st	X, r1
    723c:	13 97       	sbiw	r26, 0x03	; 3
    723e:	9f 01       	movw	r18, r30
    7240:	27 51       	subi	r18, 0x17	; 23
    7242:	3f 4f       	sbci	r19, 0xFF	; 255
    7244:	38 a3       	std	Y+32, r19	; 0x20
    7246:	2f 8f       	std	Y+31, r18	; 0x1f
    7248:	d9 01       	movw	r26, r18
    724a:	1d 92       	st	X+, r1
    724c:	1d 92       	st	X+, r1
    724e:	1d 92       	st	X+, r1
    7250:	1c 92       	st	X, r1
    7252:	13 97       	sbiw	r26, 0x03	; 3
    7254:	9f 01       	movw	r18, r30
    7256:	23 51       	subi	r18, 0x13	; 19
    7258:	3f 4f       	sbci	r19, 0xFF	; 255
    725a:	3a a3       	std	Y+34, r19	; 0x22
    725c:	29 a3       	std	Y+33, r18	; 0x21
    725e:	d9 01       	movw	r26, r18
    7260:	1d 92       	st	X+, r1
    7262:	1d 92       	st	X+, r1
    7264:	1d 92       	st	X+, r1
    7266:	1c 92       	st	X, r1
    7268:	13 97       	sbiw	r26, 0x03	; 3
    726a:	9f 01       	movw	r18, r30
    726c:	2f 50       	subi	r18, 0x0F	; 15
    726e:	3f 4f       	sbci	r19, 0xFF	; 255
    7270:	3c a3       	std	Y+36, r19	; 0x24
    7272:	2b a3       	std	Y+35, r18	; 0x23
    7274:	d9 01       	movw	r26, r18
    7276:	1d 92       	st	X+, r1
    7278:	1d 92       	st	X+, r1
    727a:	1d 92       	st	X+, r1
    727c:	1c 92       	st	X, r1
    727e:	13 97       	sbiw	r26, 0x03	; 3
    7280:	9f 01       	movw	r18, r30
    7282:	2b 50       	subi	r18, 0x0B	; 11
    7284:	3f 4f       	sbci	r19, 0xFF	; 255
    7286:	3e a3       	std	Y+38, r19	; 0x26
    7288:	2d a3       	std	Y+37, r18	; 0x25
    728a:	d9 01       	movw	r26, r18
    728c:	1d 92       	st	X+, r1
    728e:	1d 92       	st	X+, r1
    7290:	1d 92       	st	X+, r1
    7292:	1c 92       	st	X, r1
    7294:	13 97       	sbiw	r26, 0x03	; 3
    7296:	9f 01       	movw	r18, r30
    7298:	27 50       	subi	r18, 0x07	; 7
    729a:	3f 4f       	sbci	r19, 0xFF	; 255
    729c:	38 a7       	std	Y+40, r19	; 0x28
    729e:	2f a3       	std	Y+39, r18	; 0x27
    72a0:	d9 01       	movw	r26, r18
    72a2:	1d 92       	st	X+, r1
    72a4:	1d 92       	st	X+, r1
    72a6:	1d 92       	st	X+, r1
    72a8:	1c 92       	st	X, r1
    72aa:	13 97       	sbiw	r26, 0x03	; 3
    72ac:	9f 01       	movw	r18, r30
    72ae:	23 50       	subi	r18, 0x03	; 3
    72b0:	3f 4f       	sbci	r19, 0xFF	; 255
    72b2:	3a a7       	std	Y+42, r19	; 0x2a
    72b4:	29 a7       	std	Y+41, r18	; 0x29
    72b6:	d9 01       	movw	r26, r18
    72b8:	1d 92       	st	X+, r1
    72ba:	1d 92       	st	X+, r1
    72bc:	1d 92       	st	X+, r1
    72be:	1c 92       	st	X, r1
    72c0:	13 97       	sbiw	r26, 0x03	; 3
    72c2:	9f 01       	movw	r18, r30
    72c4:	2f 5f       	subi	r18, 0xFF	; 255
    72c6:	3e 4f       	sbci	r19, 0xFE	; 254
    72c8:	3c a7       	std	Y+44, r19	; 0x2c
    72ca:	2b a7       	std	Y+43, r18	; 0x2b
    72cc:	d9 01       	movw	r26, r18
    72ce:	1d 92       	st	X+, r1
    72d0:	1d 92       	st	X+, r1
    72d2:	1d 92       	st	X+, r1
    72d4:	1c 92       	st	X, r1
    72d6:	13 97       	sbiw	r26, 0x03	; 3
    72d8:	9f 01       	movw	r18, r30
    72da:	2b 5f       	subi	r18, 0xFB	; 251
    72dc:	3e 4f       	sbci	r19, 0xFE	; 254
    72de:	3e a7       	std	Y+46, r19	; 0x2e
    72e0:	2d a7       	std	Y+45, r18	; 0x2d
    72e2:	d9 01       	movw	r26, r18
    72e4:	1d 92       	st	X+, r1
    72e6:	1d 92       	st	X+, r1
    72e8:	1d 92       	st	X+, r1
    72ea:	1c 92       	st	X, r1
    72ec:	13 97       	sbiw	r26, 0x03	; 3
    72ee:	9f 01       	movw	r18, r30
    72f0:	27 5f       	subi	r18, 0xF7	; 247
    72f2:	3e 4f       	sbci	r19, 0xFE	; 254
    72f4:	38 ab       	std	Y+48, r19	; 0x30
    72f6:	2f a7       	std	Y+47, r18	; 0x2f
    72f8:	d9 01       	movw	r26, r18
    72fa:	1d 92       	st	X+, r1
    72fc:	1d 92       	st	X+, r1
    72fe:	1d 92       	st	X+, r1
    7300:	1c 92       	st	X, r1
    7302:	13 97       	sbiw	r26, 0x03	; 3
    7304:	9f 01       	movw	r18, r30
    7306:	23 5f       	subi	r18, 0xF3	; 243
    7308:	3e 4f       	sbci	r19, 0xFE	; 254
    730a:	3a ab       	std	Y+50, r19	; 0x32
    730c:	29 ab       	std	Y+49, r18	; 0x31
    730e:	d9 01       	movw	r26, r18
    7310:	1d 92       	st	X+, r1
    7312:	1d 92       	st	X+, r1
    7314:	1d 92       	st	X+, r1
    7316:	1c 92       	st	X, r1
    7318:	13 97       	sbiw	r26, 0x03	; 3
    731a:	9f 01       	movw	r18, r30
    731c:	2f 5e       	subi	r18, 0xEF	; 239
    731e:	3e 4f       	sbci	r19, 0xFE	; 254
    7320:	3c ab       	std	Y+52, r19	; 0x34
    7322:	2b ab       	std	Y+51, r18	; 0x33
    7324:	d9 01       	movw	r26, r18
    7326:	1d 92       	st	X+, r1
    7328:	1d 92       	st	X+, r1
    732a:	1d 92       	st	X+, r1
    732c:	1c 92       	st	X, r1
    732e:	13 97       	sbiw	r26, 0x03	; 3
    7330:	9f 01       	movw	r18, r30
    7332:	2b 5e       	subi	r18, 0xEB	; 235
    7334:	3e 4f       	sbci	r19, 0xFE	; 254
    7336:	3e ab       	std	Y+54, r19	; 0x36
    7338:	2d ab       	std	Y+53, r18	; 0x35
    733a:	d9 01       	movw	r26, r18
    733c:	1d 92       	st	X+, r1
    733e:	1d 92       	st	X+, r1
    7340:	1d 92       	st	X+, r1
    7342:	1c 92       	st	X, r1
    7344:	13 97       	sbiw	r26, 0x03	; 3
    7346:	9f 01       	movw	r18, r30
    7348:	27 5e       	subi	r18, 0xE7	; 231
    734a:	3e 4f       	sbci	r19, 0xFE	; 254
    734c:	38 af       	std	Y+56, r19	; 0x38
    734e:	2f ab       	std	Y+55, r18	; 0x37
    7350:	d9 01       	movw	r26, r18
    7352:	1d 92       	st	X+, r1
    7354:	1d 92       	st	X+, r1
    7356:	1d 92       	st	X+, r1
    7358:	1c 92       	st	X, r1
    735a:	13 97       	sbiw	r26, 0x03	; 3
    735c:	9f 01       	movw	r18, r30
    735e:	23 5e       	subi	r18, 0xE3	; 227
    7360:	3e 4f       	sbci	r19, 0xFE	; 254
    7362:	3a af       	std	Y+58, r19	; 0x3a
    7364:	29 af       	std	Y+57, r18	; 0x39
    7366:	d9 01       	movw	r26, r18
    7368:	1d 92       	st	X+, r1
    736a:	1d 92       	st	X+, r1
    736c:	1d 92       	st	X+, r1
    736e:	1c 92       	st	X, r1
    7370:	13 97       	sbiw	r26, 0x03	; 3
    7372:	9f 01       	movw	r18, r30
    7374:	2f 5d       	subi	r18, 0xDF	; 223
    7376:	3e 4f       	sbci	r19, 0xFE	; 254
    7378:	3c af       	std	Y+60, r19	; 0x3c
    737a:	2b af       	std	Y+59, r18	; 0x3b
    737c:	d9 01       	movw	r26, r18
    737e:	1d 92       	st	X+, r1
    7380:	1d 92       	st	X+, r1
    7382:	1d 92       	st	X+, r1
    7384:	1c 92       	st	X, r1
    7386:	13 97       	sbiw	r26, 0x03	; 3
    7388:	9f 01       	movw	r18, r30
    738a:	2b 5d       	subi	r18, 0xDB	; 219
    738c:	3e 4f       	sbci	r19, 0xFE	; 254
    738e:	3e af       	std	Y+62, r19	; 0x3e
    7390:	2d af       	std	Y+61, r18	; 0x3d
    7392:	d9 01       	movw	r26, r18
    7394:	1d 92       	st	X+, r1
    7396:	1d 92       	st	X+, r1
    7398:	1d 92       	st	X+, r1
    739a:	1c 92       	st	X, r1
    739c:	13 97       	sbiw	r26, 0x03	; 3
    739e:	9f 01       	movw	r18, r30
    73a0:	27 5d       	subi	r18, 0xD7	; 215
    73a2:	3e 4f       	sbci	r19, 0xFE	; 254
    73a4:	21 96       	adiw	r28, 0x01	; 1
    73a6:	3f af       	std	Y+63, r19	; 0x3f
    73a8:	2e af       	std	Y+62, r18	; 0x3e
    73aa:	21 97       	sbiw	r28, 0x01	; 1
    73ac:	d9 01       	movw	r26, r18
    73ae:	1d 92       	st	X+, r1
    73b0:	1d 92       	st	X+, r1
    73b2:	1d 92       	st	X+, r1
    73b4:	1c 92       	st	X, r1
    73b6:	13 97       	sbiw	r26, 0x03	; 3
    73b8:	9f 01       	movw	r18, r30
    73ba:	23 5d       	subi	r18, 0xD3	; 211
    73bc:	3e 4f       	sbci	r19, 0xFE	; 254
    73be:	23 96       	adiw	r28, 0x03	; 3
    73c0:	3f af       	std	Y+63, r19	; 0x3f
    73c2:	2e af       	std	Y+62, r18	; 0x3e
    73c4:	23 97       	sbiw	r28, 0x03	; 3
    73c6:	d9 01       	movw	r26, r18
    73c8:	1d 92       	st	X+, r1
    73ca:	1d 92       	st	X+, r1
    73cc:	1d 92       	st	X+, r1
    73ce:	1c 92       	st	X, r1
    73d0:	13 97       	sbiw	r26, 0x03	; 3
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
			void YawProportional(float val) { yawProportional = val;}

			float YawDerivativeError() const {return yawDerivativeError;}
    73d2:	25 96       	adiw	r28, 0x05	; 5
    73d4:	ae ad       	ldd	r26, Y+62	; 0x3e
    73d6:	bf ad       	ldd	r27, Y+63	; 0x3f
    73d8:	25 97       	sbiw	r28, 0x05	; 5
    73da:	5e 96       	adiw	r26, 0x1e	; 30
    73dc:	cd 90       	ld	r12, X+
    73de:	dd 90       	ld	r13, X+
    73e0:	ed 90       	ld	r14, X+
    73e2:	fc 90       	ld	r15, X
    73e4:	91 97       	sbiw	r26, 0x21	; 33
	
	message->YawDerivativeError = model->YawDerivativeError();
    73e6:	c5 86       	std	Z+13, r12	; 0x0d
    73e8:	d6 86       	std	Z+14, r13	; 0x0e
    73ea:	e7 86       	std	Z+15, r14	; 0x0f
    73ec:	f0 8a       	std	Z+16, r15	; 0x10
			void YawControlBeforeServoLimitsAdjustment(float val) { yawControlBeforeServoLimitsAdjustment = val;}
				
			float ReferenceYawVelocityRadsPerSecond() const {return referenceYawVelocityRadsPerSecond;}
			void ReferenceYawVelocityRadsPerSecond(float val) { referenceYawVelocityRadsPerSecond = val;}
				
			float YawIntegral() const {return yawIntegral;}
    73ee:	56 96       	adiw	r26, 0x16	; 22
    73f0:	cd 90       	ld	r12, X+
    73f2:	dd 90       	ld	r13, X+
    73f4:	ed 90       	ld	r14, X+
    73f6:	fc 90       	ld	r15, X
    73f8:	59 97       	sbiw	r26, 0x19	; 25
	message->YawIntegral = model->YawIntegral();
    73fa:	c5 82       	std	Z+5, r12	; 0x05
    73fc:	d6 82       	std	Z+6, r13	; 0x06
    73fe:	e7 82       	std	Z+7, r14	; 0x07
    7400:	f0 86       	std	Z+8, r15	; 0x08
			void YawIntegral(float val) { yawIntegral = val;}

			float YawProportional() const {return yawProportional;}
    7402:	5a 96       	adiw	r26, 0x1a	; 26
    7404:	cd 90       	ld	r12, X+
    7406:	dd 90       	ld	r13, X+
    7408:	ed 90       	ld	r14, X+
    740a:	fc 90       	ld	r15, X
    740c:	5d 97       	sbiw	r26, 0x1d	; 29
	message->YawProportional = model->YawProportional();
    740e:	c1 86       	std	Z+9, r12	; 0x09
    7410:	d2 86       	std	Z+10, r13	; 0x0a
    7412:	e3 86       	std	Z+11, r14	; 0x0b
    7414:	f4 86       	std	Z+12, r15	; 0x0c
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    7416:	1a 96       	adiw	r26, 0x0a	; 10
    7418:	cd 90       	ld	r12, X+
    741a:	dd 90       	ld	r13, X+
    741c:	ed 90       	ld	r14, X+
    741e:	fc 90       	ld	r15, X
    7420:	1d 97       	sbiw	r26, 0x0d	; 13
	message->YawControl = model->YawControl();
    7422:	c1 8a       	std	Z+17, r12	; 0x11
    7424:	d2 8a       	std	Z+18, r13	; 0x12
    7426:	e3 8a       	std	Z+19, r14	; 0x13
    7428:	f4 8a       	std	Z+20, r15	; 0x14
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    742a:	6d 01       	movw	r12, r26
    742c:	b2 ed       	ldi	r27, 0xD2	; 210
    742e:	cb 0e       	add	r12, r27
    7430:	d1 1c       	adc	r13, r1
    7432:	d6 01       	movw	r26, r12
    7434:	cd 90       	ld	r12, X+
    7436:	dd 90       	ld	r13, X+
    7438:	ed 90       	ld	r14, X+
    743a:	fc 90       	ld	r15, X
	

	message->PitchRads = model->PitchRads();
    743c:	c5 a6       	std	Z+45, r12	; 0x2d
    743e:	d6 a6       	std	Z+46, r13	; 0x2e
    7440:	e7 a6       	std	Z+47, r14	; 0x2f
    7442:	f0 aa       	std	Z+48, r15	; 0x30
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    7444:	25 96       	adiw	r28, 0x05	; 5
    7446:	ae ad       	ldd	r26, Y+62	; 0x3e
    7448:	bf ad       	ldd	r27, Y+63	; 0x3f
    744a:	25 97       	sbiw	r28, 0x05	; 5
    744c:	92 96       	adiw	r26, 0x22	; 34
    744e:	cd 90       	ld	r12, X+
    7450:	dd 90       	ld	r13, X+
    7452:	ed 90       	ld	r14, X+
    7454:	fc 90       	ld	r15, X
    7456:	95 97       	sbiw	r26, 0x25	; 37
	message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    7458:	c5 a2       	std	Z+37, r12	; 0x25
    745a:	d6 a2       	std	Z+38, r13	; 0x26
    745c:	e7 a2       	std	Z+39, r14	; 0x27
    745e:	f0 a6       	std	Z+40, r15	; 0x28
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
			void XIntegral(float val) { xIntegral = val;}
				
			float XDerivativeError() const {return xDerivativeError;}
    7460:	6d 01       	movw	r12, r26
    7462:	b6 e4       	ldi	r27, 0x46	; 70
    7464:	cb 0e       	add	r12, r27
    7466:	d1 1c       	adc	r13, r1
    7468:	d6 01       	movw	r26, r12
    746a:	cd 90       	ld	r12, X+
    746c:	dd 90       	ld	r13, X+
    746e:	ed 90       	ld	r14, X+
    7470:	fc 90       	ld	r15, X
	message->XDerivativeError = model->XDerivativeError();
    7472:	c1 ae       	std	Z+57, r12	; 0x39
    7474:	d2 ae       	std	Z+58, r13	; 0x3a
    7476:	e3 ae       	std	Z+59, r14	; 0x3b
    7478:	f4 ae       	std	Z+60, r15	; 0x3c
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
			void XProportional(float val) { xProportional = val;}
				
			float XIntegral() const {return xIntegral;}
    747a:	25 96       	adiw	r28, 0x05	; 5
    747c:	ce ac       	ldd	r12, Y+62	; 0x3e
    747e:	df ac       	ldd	r13, Y+63	; 0x3f
    7480:	25 97       	sbiw	r28, 0x05	; 5
    7482:	b2 e4       	ldi	r27, 0x42	; 66
    7484:	cb 0e       	add	r12, r27
    7486:	d1 1c       	adc	r13, r1
    7488:	d6 01       	movw	r26, r12
    748a:	cd 90       	ld	r12, X+
    748c:	dd 90       	ld	r13, X+
    748e:	ed 90       	ld	r14, X+
    7490:	fc 90       	ld	r15, X
	message->XIntegral = model->XIntegral();
    7492:	c1 aa       	std	Z+49, r12	; 0x31
    7494:	d2 aa       	std	Z+50, r13	; 0x32
    7496:	e3 aa       	std	Z+51, r14	; 0x33
    7498:	f4 aa       	std	Z+52, r15	; 0x34
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
			void XLongitudeOuterLoopSetpoint(float val) { xLongitudeOuterLoopSetpoint = val;}
				
			float XProportional() const {return xProportional;}
    749a:	25 96       	adiw	r28, 0x05	; 5
    749c:	ce ac       	ldd	r12, Y+62	; 0x3e
    749e:	df ac       	ldd	r13, Y+63	; 0x3f
    74a0:	25 97       	sbiw	r28, 0x05	; 5
    74a2:	be e3       	ldi	r27, 0x3E	; 62
    74a4:	cb 0e       	add	r12, r27
    74a6:	d1 1c       	adc	r13, r1
    74a8:	d6 01       	movw	r26, r12
    74aa:	cd 90       	ld	r12, X+
    74ac:	dd 90       	ld	r13, X+
    74ae:	ed 90       	ld	r14, X+
    74b0:	fc 90       	ld	r15, X
	message->XProportional = model->XProportional();
    74b2:	c5 aa       	std	Z+53, r12	; 0x35
    74b4:	d6 aa       	std	Z+54, r13	; 0x36
    74b6:	e7 aa       	std	Z+55, r14	; 0x37
    74b8:	f0 ae       	std	Z+56, r15	; 0x38
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    74ba:	25 96       	adiw	r28, 0x05	; 5
    74bc:	ae ad       	ldd	r26, Y+62	; 0x3e
    74be:	bf ad       	ldd	r27, Y+63	; 0x3f
    74c0:	25 97       	sbiw	r28, 0x05	; 5
    74c2:	d2 96       	adiw	r26, 0x32	; 50
    74c4:	cd 90       	ld	r12, X+
    74c6:	dd 90       	ld	r13, X+
    74c8:	ed 90       	ld	r14, X+
    74ca:	fc 90       	ld	r15, X
    74cc:	d5 97       	sbiw	r26, 0x35	; 53
	message->XVelocityFRDCms = model->XVelocityFRDCms();
    74ce:	c1 a6       	std	Z+41, r12	; 0x29
    74d0:	d2 a6       	std	Z+42, r13	; 0x2a
    74d2:	e3 a6       	std	Z+43, r14	; 0x2b
    74d4:	f4 a6       	std	Z+44, r15	; 0x2c
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    74d6:	9e 96       	adiw	r26, 0x2e	; 46
    74d8:	cd 90       	ld	r12, X+
    74da:	dd 90       	ld	r13, X+
    74dc:	ed 90       	ld	r14, X+
    74de:	fc 90       	ld	r15, X
    74e0:	d1 97       	sbiw	r26, 0x31	; 49
	message->LongitudeControl = model->LongitudeControl();
    74e2:	a9 81       	ldd	r26, Y+1	; 0x01
    74e4:	ba 81       	ldd	r27, Y+2	; 0x02
    74e6:	cd 92       	st	X+, r12
    74e8:	dd 92       	st	X+, r13
    74ea:	ed 92       	st	X+, r14
    74ec:	fc 92       	st	X, r15
    74ee:	13 97       	sbiw	r26, 0x03	; 3
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
				
			float ReferenceXVelocityCms() const {return referenceXVelocityMetersPerSecond;}
			void ReferenceXVelocityCms(float val) { referenceXVelocityMetersPerSecond = val;}
				
			float XLongitudeOuterLoopSetpoint() const {return xLongitudeOuterLoopSetpoint;}
    74f0:	25 96       	adiw	r28, 0x05	; 5
    74f2:	ae ad       	ldd	r26, Y+62	; 0x3e
    74f4:	bf ad       	ldd	r27, Y+63	; 0x3f
    74f6:	25 97       	sbiw	r28, 0x05	; 5
    74f8:	da 96       	adiw	r26, 0x3a	; 58
    74fa:	cd 90       	ld	r12, X+
    74fc:	dd 90       	ld	r13, X+
    74fe:	ed 90       	ld	r14, X+
    7500:	fc 90       	ld	r15, X
    7502:	dd 97       	sbiw	r26, 0x3d	; 61
	message->XLongitudeOuterLoopSetpoint = model->XLongitudeOuterLoopSetpoint();
    7504:	d8 01       	movw	r26, r16
    7506:	cd 92       	st	X+, r12
    7508:	dd 92       	st	X+, r13
    750a:	ed 92       	st	X+, r14
    750c:	fc 92       	st	X, r15
    750e:	13 97       	sbiw	r26, 0x03	; 3
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    7510:	25 96       	adiw	r28, 0x05	; 5
    7512:	0e ad       	ldd	r16, Y+62	; 0x3e
    7514:	1f ad       	ldd	r17, Y+63	; 0x3f
    7516:	25 97       	sbiw	r28, 0x05	; 5
    7518:	06 52       	subi	r16, 0x26	; 38
    751a:	1f 4f       	sbci	r17, 0xFF	; 255
    751c:	d8 01       	movw	r26, r16
    751e:	cd 90       	ld	r12, X+
    7520:	dd 90       	ld	r13, X+
    7522:	ed 90       	ld	r14, X+
    7524:	fc 90       	ld	r15, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    7526:	dc 01       	movw	r26, r24
    7528:	cd 92       	st	X+, r12
    752a:	dd 92       	st	X+, r13
    752c:	ed 92       	st	X+, r14
    752e:	fc 92       	st	X, r15
    7530:	13 97       	sbiw	r26, 0x03	; 3
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    7532:	25 96       	adiw	r28, 0x05	; 5
    7534:	ee ac       	ldd	r14, Y+62	; 0x3e
    7536:	ff ac       	ldd	r15, Y+63	; 0x3f
    7538:	25 97       	sbiw	r28, 0x05	; 5
    753a:	be ec       	ldi	r27, 0xCE	; 206
    753c:	eb 0e       	add	r14, r27
    753e:	f1 1c       	adc	r15, r1
    7540:	d7 01       	movw	r26, r14
    7542:	cd 90       	ld	r12, X+
    7544:	dd 90       	ld	r13, X+
    7546:	ed 90       	ld	r14, X+
    7548:	fc 90       	ld	r15, X

	
	message->RollRads = model->RollRads();
    754a:	db 01       	movw	r26, r22
    754c:	cd 92       	st	X+, r12
    754e:	dd 92       	st	X+, r13
    7550:	ed 92       	st	X+, r14
    7552:	fc 92       	st	X, r15
    7554:	13 97       	sbiw	r26, 0x03	; 3
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    7556:	25 96       	adiw	r28, 0x05	; 5
    7558:	6e ad       	ldd	r22, Y+62	; 0x3e
    755a:	7f ad       	ldd	r23, Y+63	; 0x3f
    755c:	25 97       	sbiw	r28, 0x05	; 5
    755e:	62 5b       	subi	r22, 0xB2	; 178
    7560:	7f 4f       	sbci	r23, 0xFF	; 255
    7562:	db 01       	movw	r26, r22
    7564:	cd 90       	ld	r12, X+
    7566:	dd 90       	ld	r13, X+
    7568:	ed 90       	ld	r14, X+
    756a:	fc 90       	ld	r15, X
	message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    756c:	da 01       	movw	r26, r20
    756e:	cd 92       	st	X+, r12
    7570:	dd 92       	st	X+, r13
    7572:	ed 92       	st	X+, r14
    7574:	fc 92       	st	X, r15
    7576:	13 97       	sbiw	r26, 0x03	; 3
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
			void YIntegral(float val) { yIntegral = val;}

			float YDerivativeError() const {return yDerivativeError;}
    7578:	25 96       	adiw	r28, 0x05	; 5
    757a:	4e ad       	ldd	r20, Y+62	; 0x3e
    757c:	5f ad       	ldd	r21, Y+63	; 0x3f
    757e:	25 97       	sbiw	r28, 0x05	; 5
    7580:	4e 58       	subi	r20, 0x8E	; 142
    7582:	5f 4f       	sbci	r21, 0xFF	; 255
    7584:	da 01       	movw	r26, r20
    7586:	4d 91       	ld	r20, X+
    7588:	5d 91       	ld	r21, X+
    758a:	6d 91       	ld	r22, X+
    758c:	7c 91       	ld	r23, X
	message->YDerivativeError = model->YDerivativeError();
    758e:	27 96       	adiw	r28, 0x07	; 7
    7590:	ae ad       	ldd	r26, Y+62	; 0x3e
    7592:	bf ad       	ldd	r27, Y+63	; 0x3f
    7594:	27 97       	sbiw	r28, 0x07	; 7
    7596:	4d 93       	st	X+, r20
    7598:	5d 93       	st	X+, r21
    759a:	6d 93       	st	X+, r22
    759c:	7c 93       	st	X, r23
    759e:	13 97       	sbiw	r26, 0x03	; 3
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
			void YProportional(float val) { yProportional = val;}

			float YIntegral() const {return yIntegral;}
    75a0:	25 96       	adiw	r28, 0x05	; 5
    75a2:	2e ad       	ldd	r18, Y+62	; 0x3e
    75a4:	3f ad       	ldd	r19, Y+63	; 0x3f
    75a6:	25 97       	sbiw	r28, 0x05	; 5
    75a8:	22 59       	subi	r18, 0x92	; 146
    75aa:	3f 4f       	sbci	r19, 0xFF	; 255
    75ac:	d9 01       	movw	r26, r18
    75ae:	4d 91       	ld	r20, X+
    75b0:	5d 91       	ld	r21, X+
    75b2:	6d 91       	ld	r22, X+
    75b4:	7c 91       	ld	r23, X
	message->YIntegral = model->YIntegral();
    75b6:	d5 01       	movw	r26, r10
    75b8:	4d 93       	st	X+, r20
    75ba:	5d 93       	st	X+, r21
    75bc:	6d 93       	st	X+, r22
    75be:	7c 93       	st	X, r23
    75c0:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
			void YLateralOuterLoopSetpoint(float val) { yLateralOuterLoopSetpoint = val;}

			float YProportional() const {return yProportional;}
    75c2:	25 96       	adiw	r28, 0x05	; 5
    75c4:	2e ad       	ldd	r18, Y+62	; 0x3e
    75c6:	3f ad       	ldd	r19, Y+63	; 0x3f
    75c8:	25 97       	sbiw	r28, 0x05	; 5
    75ca:	26 59       	subi	r18, 0x96	; 150
    75cc:	3f 4f       	sbci	r19, 0xFF	; 255
    75ce:	d9 01       	movw	r26, r18
    75d0:	4d 91       	ld	r20, X+
    75d2:	5d 91       	ld	r21, X+
    75d4:	6d 91       	ld	r22, X+
    75d6:	7c 91       	ld	r23, X
	message->YProportional = model->YProportional();
    75d8:	d4 01       	movw	r26, r8
    75da:	4d 93       	st	X+, r20
    75dc:	5d 93       	st	X+, r21
    75de:	6d 93       	st	X+, r22
    75e0:	7c 93       	st	X, r23
    75e2:	13 97       	sbiw	r26, 0x03	; 3
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    75e4:	25 96       	adiw	r28, 0x05	; 5
    75e6:	2e ad       	ldd	r18, Y+62	; 0x3e
    75e8:	3f ad       	ldd	r19, Y+63	; 0x3f
    75ea:	25 97       	sbiw	r28, 0x05	; 5
    75ec:	22 5a       	subi	r18, 0xA2	; 162
    75ee:	3f 4f       	sbci	r19, 0xFF	; 255
    75f0:	d9 01       	movw	r26, r18
    75f2:	4d 91       	ld	r20, X+
    75f4:	5d 91       	ld	r21, X+
    75f6:	6d 91       	ld	r22, X+
    75f8:	7c 91       	ld	r23, X
	message->YVelocityFRDCms = model->YVelocityFRDCms();
    75fa:	d3 01       	movw	r26, r6
    75fc:	4d 93       	st	X+, r20
    75fe:	5d 93       	st	X+, r21
    7600:	6d 93       	st	X+, r22
    7602:	7c 93       	st	X, r23
    7604:	13 97       	sbiw	r26, 0x03	; 3
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    7606:	25 96       	adiw	r28, 0x05	; 5
    7608:	2e ad       	ldd	r18, Y+62	; 0x3e
    760a:	3f ad       	ldd	r19, Y+63	; 0x3f
    760c:	25 97       	sbiw	r28, 0x05	; 5
    760e:	26 5a       	subi	r18, 0xA6	; 166
    7610:	3f 4f       	sbci	r19, 0xFF	; 255
    7612:	d9 01       	movw	r26, r18
    7614:	4d 91       	ld	r20, X+
    7616:	5d 91       	ld	r21, X+
    7618:	6d 91       	ld	r22, X+
    761a:	7c 91       	ld	r23, X
	message->LateralControl = model->LateralControl();
    761c:	d2 01       	movw	r26, r4
    761e:	4d 93       	st	X+, r20
    7620:	5d 93       	st	X+, r21
    7622:	6d 93       	st	X+, r22
    7624:	7c 93       	st	X, r23
    7626:	13 97       	sbiw	r26, 0x03	; 3
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}

			float ReferenceYVelocityCms() const {return referenceYVelocityMetersPerSecondBodyFrame;}
			void ReferenceYVelocityCms(float val) { referenceYVelocityMetersPerSecondBodyFrame = val;}

			float YLateralOuterLoopSetpoint() const {return yLateralOuterLoopSetpoint;}
    7628:	25 96       	adiw	r28, 0x05	; 5
    762a:	2e ad       	ldd	r18, Y+62	; 0x3e
    762c:	3f ad       	ldd	r19, Y+63	; 0x3f
    762e:	25 97       	sbiw	r28, 0x05	; 5
    7630:	2a 59       	subi	r18, 0x9A	; 154
    7632:	3f 4f       	sbci	r19, 0xFF	; 255
    7634:	d9 01       	movw	r26, r18
    7636:	4d 91       	ld	r20, X+
    7638:	5d 91       	ld	r21, X+
    763a:	6d 91       	ld	r22, X+
    763c:	7c 91       	ld	r23, X
	message->YLateralOuterLoopSetpoint = model->YLateralOuterLoopSetpoint();
    763e:	d1 01       	movw	r26, r2
    7640:	4d 93       	st	X+, r20
    7642:	5d 93       	st	X+, r21
    7644:	6d 93       	st	X+, r22
    7646:	7c 93       	st	X, r23
    7648:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    764a:	25 96       	adiw	r28, 0x05	; 5
    764c:	2e ad       	ldd	r18, Y+62	; 0x3e
    764e:	3f ad       	ldd	r19, Y+63	; 0x3f
    7650:	25 97       	sbiw	r28, 0x05	; 5
    7652:	22 52       	subi	r18, 0x22	; 34
    7654:	3f 4f       	sbci	r19, 0xFF	; 255
    7656:	d9 01       	movw	r26, r18
    7658:	4d 91       	ld	r20, X+
    765a:	5d 91       	ld	r21, X+
    765c:	6d 91       	ld	r22, X+
    765e:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();	
    7660:	29 96       	adiw	r28, 0x09	; 9
    7662:	ae ad       	ldd	r26, Y+62	; 0x3e
    7664:	bf ad       	ldd	r27, Y+63	; 0x3f
    7666:	29 97       	sbiw	r28, 0x09	; 9
    7668:	4d 93       	st	X+, r20
    766a:	5d 93       	st	X+, r21
    766c:	6d 93       	st	X+, r22
    766e:	7c 93       	st	X, r23
    7670:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
			void ZProportional(float val) { zProportional = val;}

			float ZDerivativeError() const {return zDerivativeError;}
    7672:	25 96       	adiw	r28, 0x05	; 5
    7674:	4e ad       	ldd	r20, Y+62	; 0x3e
    7676:	5f ad       	ldd	r21, Y+63	; 0x3f
    7678:	25 97       	sbiw	r28, 0x05	; 5
    767a:	42 56       	subi	r20, 0x62	; 98
    767c:	5f 4f       	sbci	r21, 0xFF	; 255
    767e:	da 01       	movw	r26, r20
    7680:	4d 91       	ld	r20, X+
    7682:	5d 91       	ld	r21, X+
    7684:	6d 91       	ld	r22, X+
    7686:	7c 91       	ld	r23, X
	
	
	//message->AltitudeMetersAgl = model->AltitudeMetersAgl();
	message->ZDerivativeError = model->ZDerivativeError();
    7688:	ab 85       	ldd	r26, Y+11	; 0x0b
    768a:	bc 85       	ldd	r27, Y+12	; 0x0c
    768c:	4d 93       	st	X+, r20
    768e:	5d 93       	st	X+, r21
    7690:	6d 93       	st	X+, r22
    7692:	7c 93       	st	X, r23
    7694:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    7696:	25 96       	adiw	r28, 0x05	; 5
    7698:	4e ad       	ldd	r20, Y+62	; 0x3e
    769a:	5f ad       	ldd	r21, Y+63	; 0x3f
    769c:	25 97       	sbiw	r28, 0x05	; 5
    769e:	4a 52       	subi	r20, 0x2A	; 42
    76a0:	5f 4f       	sbci	r21, 0xFF	; 255
    76a2:	da 01       	movw	r26, r20
    76a4:	4d 91       	ld	r20, X+
    76a6:	5d 91       	ld	r21, X+
    76a8:	6d 91       	ld	r22, X+
    76aa:	7c 91       	ld	r23, X
	message->YawRads = model->YawRads();
    76ac:	ad 81       	ldd	r26, Y+5	; 0x05
    76ae:	be 81       	ldd	r27, Y+6	; 0x06
    76b0:	4d 93       	st	X+, r20
    76b2:	5d 93       	st	X+, r21
    76b4:	6d 93       	st	X+, r22
    76b6:	7c 93       	st	X, r23
    76b8:	13 97       	sbiw	r26, 0x03	; 3
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}

			float ReferenceZVelocityCms() const {return referenceZVelocityCms;}
			void ReferenceZVelocityCms(float val) { referenceZVelocityCms = val;}

			float ZIntegral() const {return zIntegral;}
    76ba:	25 96       	adiw	r28, 0x05	; 5
    76bc:	4e ad       	ldd	r20, Y+62	; 0x3e
    76be:	5f ad       	ldd	r21, Y+63	; 0x3f
    76c0:	25 97       	sbiw	r28, 0x05	; 5
    76c2:	4a 56       	subi	r20, 0x6A	; 106
    76c4:	5f 4f       	sbci	r21, 0xFF	; 255
    76c6:	da 01       	movw	r26, r20
    76c8:	4d 91       	ld	r20, X+
    76ca:	5d 91       	ld	r21, X+
    76cc:	6d 91       	ld	r22, X+
    76ce:	7c 91       	ld	r23, X
	message->ZIntegral = model->ZIntegral();
    76d0:	af 81       	ldd	r26, Y+7	; 0x07
    76d2:	b8 85       	ldd	r27, Y+8	; 0x08
    76d4:	4d 93       	st	X+, r20
    76d6:	5d 93       	st	X+, r21
    76d8:	6d 93       	st	X+, r22
    76da:	7c 93       	st	X, r23
    76dc:	13 97       	sbiw	r26, 0x03	; 3
			void ZIntegral(float val) { zIntegral = val;}

			float ZProportional() const {return zProportional;}
    76de:	25 96       	adiw	r28, 0x05	; 5
    76e0:	4e ad       	ldd	r20, Y+62	; 0x3e
    76e2:	5f ad       	ldd	r21, Y+63	; 0x3f
    76e4:	25 97       	sbiw	r28, 0x05	; 5
    76e6:	46 56       	subi	r20, 0x66	; 102
    76e8:	5f 4f       	sbci	r21, 0xFF	; 255
    76ea:	da 01       	movw	r26, r20
    76ec:	4d 91       	ld	r20, X+
    76ee:	5d 91       	ld	r21, X+
    76f0:	6d 91       	ld	r22, X+
    76f2:	7c 91       	ld	r23, X
	message->ZProportional = model->ZProportional();
    76f4:	a9 85       	ldd	r26, Y+9	; 0x09
    76f6:	ba 85       	ldd	r27, Y+10	; 0x0a
    76f8:	4d 93       	st	X+, r20
    76fa:	5d 93       	st	X+, r21
    76fc:	6d 93       	st	X+, r22
    76fe:	7c 93       	st	X, r23
    7700:	13 97       	sbiw	r26, 0x03	; 3
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    7702:	25 96       	adiw	r28, 0x05	; 5
    7704:	4e ad       	ldd	r20, Y+62	; 0x3e
    7706:	5f ad       	ldd	r21, Y+63	; 0x3f
    7708:	25 97       	sbiw	r28, 0x05	; 5
    770a:	42 57       	subi	r20, 0x72	; 114
    770c:	5f 4f       	sbci	r21, 0xFF	; 255
    770e:	da 01       	movw	r26, r20
    7710:	4d 91       	ld	r20, X+
    7712:	5d 91       	ld	r21, X+
    7714:	6d 91       	ld	r22, X+
    7716:	7c 91       	ld	r23, X
	message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    7718:	ab 81       	ldd	r26, Y+3	; 0x03
    771a:	bc 81       	ldd	r27, Y+4	; 0x04
    771c:	4d 93       	st	X+, r20
    771e:	5d 93       	st	X+, r21
    7720:	6d 93       	st	X+, r22
    7722:	7c 93       	st	X, r23
    7724:	13 97       	sbiw	r26, 0x03	; 3

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    7726:	25 96       	adiw	r28, 0x05	; 5
    7728:	4e ad       	ldd	r20, Y+62	; 0x3e
    772a:	5f ad       	ldd	r21, Y+63	; 0x3f
    772c:	25 97       	sbiw	r28, 0x05	; 5
    772e:	4a 57       	subi	r20, 0x7A	; 122
    7730:	5f 4f       	sbci	r21, 0xFF	; 255
    7732:	da 01       	movw	r26, r20
    7734:	4d 91       	ld	r20, X+
    7736:	5d 91       	ld	r21, X+
    7738:	6d 91       	ld	r22, X+
    773a:	7c 91       	ld	r23, X
	message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    773c:	ad 85       	ldd	r26, Y+13	; 0x0d
    773e:	be 85       	ldd	r27, Y+14	; 0x0e
    7740:	4d 93       	st	X+, r20
    7742:	5d 93       	st	X+, r21
    7744:	6d 93       	st	X+, r22
    7746:	7c 93       	st	X, r23
    7748:	13 97       	sbiw	r26, 0x03	; 3
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    774a:	25 96       	adiw	r28, 0x05	; 5
    774c:	4e ad       	ldd	r20, Y+62	; 0x3e
    774e:	5f ad       	ldd	r21, Y+63	; 0x3f
    7750:	25 97       	sbiw	r28, 0x05	; 5
    7752:	42 58       	subi	r20, 0x82	; 130
    7754:	5f 4f       	sbci	r21, 0xFF	; 255
    7756:	da 01       	movw	r26, r20
    7758:	4d 91       	ld	r20, X+
    775a:	5d 91       	ld	r21, X+
    775c:	6d 91       	ld	r22, X+
    775e:	7c 91       	ld	r23, X
	message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    7760:	af 85       	ldd	r26, Y+15	; 0x0f
    7762:	b8 89       	ldd	r27, Y+16	; 0x10
    7764:	4d 93       	st	X+, r20
    7766:	5d 93       	st	X+, r21
    7768:	6d 93       	st	X+, r22
    776a:	7c 93       	st	X, r23
    776c:	13 97       	sbiw	r26, 0x03	; 3

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    776e:	25 96       	adiw	r28, 0x05	; 5
    7770:	4e ad       	ldd	r20, Y+62	; 0x3e
    7772:	5f ad       	ldd	r21, Y+63	; 0x3f
    7774:	25 97       	sbiw	r28, 0x05	; 5
    7776:	4a 51       	subi	r20, 0x1A	; 26
    7778:	5f 4f       	sbci	r21, 0xFF	; 255
    777a:	da 01       	movw	r26, r20
    777c:	4d 91       	ld	r20, X+
    777e:	5d 91       	ld	r21, X+
    7780:	6d 91       	ld	r22, X+
    7782:	7c 91       	ld	r23, X
	
	
	
	message->XAccelFrdMss = model->XAccelFrdMss();
    7784:	ad 89       	ldd	r26, Y+21	; 0x15
    7786:	be 89       	ldd	r27, Y+22	; 0x16
    7788:	4d 93       	st	X+, r20
    778a:	5d 93       	st	X+, r21
    778c:	6d 93       	st	X+, r22
    778e:	7c 93       	st	X, r23
    7790:	13 97       	sbiw	r26, 0x03	; 3
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    7792:	25 96       	adiw	r28, 0x05	; 5
    7794:	4e ad       	ldd	r20, Y+62	; 0x3e
    7796:	5f ad       	ldd	r21, Y+63	; 0x3f
    7798:	25 97       	sbiw	r28, 0x05	; 5
    779a:	46 51       	subi	r20, 0x16	; 22
    779c:	5f 4f       	sbci	r21, 0xFF	; 255
    779e:	da 01       	movw	r26, r20
    77a0:	4d 91       	ld	r20, X+
    77a2:	5d 91       	ld	r21, X+
    77a4:	6d 91       	ld	r22, X+
    77a6:	7c 91       	ld	r23, X
	message->YAccelFrdMss = model->YAccelFrdMss();
    77a8:	af 89       	ldd	r26, Y+23	; 0x17
    77aa:	b8 8d       	ldd	r27, Y+24	; 0x18
    77ac:	4d 93       	st	X+, r20
    77ae:	5d 93       	st	X+, r21
    77b0:	6d 93       	st	X+, r22
    77b2:	7c 93       	st	X, r23
    77b4:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    77b6:	25 96       	adiw	r28, 0x05	; 5
    77b8:	4e ad       	ldd	r20, Y+62	; 0x3e
    77ba:	5f ad       	ldd	r21, Y+63	; 0x3f
    77bc:	25 97       	sbiw	r28, 0x05	; 5
    77be:	42 51       	subi	r20, 0x12	; 18
    77c0:	5f 4f       	sbci	r21, 0xFF	; 255
    77c2:	da 01       	movw	r26, r20
    77c4:	4d 91       	ld	r20, X+
    77c6:	5d 91       	ld	r21, X+
    77c8:	6d 91       	ld	r22, X+
    77ca:	7c 91       	ld	r23, X
	message->ZAccelFrdMss = model->ZAccelFrdMss();
    77cc:	a9 8d       	ldd	r26, Y+25	; 0x19
    77ce:	ba 8d       	ldd	r27, Y+26	; 0x1a
    77d0:	4d 93       	st	X+, r20
    77d2:	5d 93       	st	X+, r21
    77d4:	6d 93       	st	X+, r22
    77d6:	7c 93       	st	X, r23
    77d8:	13 97       	sbiw	r26, 0x03	; 3
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    77da:	25 96       	adiw	r28, 0x05	; 5
    77dc:	4e ad       	ldd	r20, Y+62	; 0x3e
    77de:	5f ad       	ldd	r21, Y+63	; 0x3f
    77e0:	25 97       	sbiw	r28, 0x05	; 5
    77e2:	4e 51       	subi	r20, 0x1E	; 30
    77e4:	5f 4f       	sbci	r21, 0xFF	; 255
    77e6:	da 01       	movw	r26, r20
    77e8:	4d 91       	ld	r20, X+
    77ea:	5d 91       	ld	r21, X+
    77ec:	6d 91       	ld	r22, X+
    77ee:	7c 91       	ld	r23, X
	message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    77f0:	ab 8d       	ldd	r26, Y+27	; 0x1b
    77f2:	bc 8d       	ldd	r27, Y+28	; 0x1c
    77f4:	4d 93       	st	X+, r20
    77f6:	5d 93       	st	X+, r21
    77f8:	6d 93       	st	X+, r22
    77fa:	7c 93       	st	X, r23
    77fc:	13 97       	sbiw	r26, 0x03	; 3
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    77fe:	d8 01       	movw	r26, r16
    7800:	4d 91       	ld	r20, X+
    7802:	5d 91       	ld	r21, X+
    7804:	6d 91       	ld	r22, X+
    7806:	7c 91       	ld	r23, X
	message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    7808:	dc 01       	movw	r26, r24
    780a:	4d 93       	st	X+, r20
    780c:	5d 93       	st	X+, r21
    780e:	6d 93       	st	X+, r22
    7810:	7c 93       	st	X, r23
    7812:	13 97       	sbiw	r26, 0x03	; 3
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    7814:	d9 01       	movw	r26, r18
    7816:	4d 91       	ld	r20, X+
    7818:	5d 91       	ld	r21, X+
    781a:	6d 91       	ld	r22, X+
    781c:	7c 91       	ld	r23, X
	message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    781e:	29 96       	adiw	r28, 0x09	; 9
    7820:	ae ad       	ldd	r26, Y+62	; 0x3e
    7822:	bf ad       	ldd	r27, Y+63	; 0x3f
    7824:	29 97       	sbiw	r28, 0x09	; 9
    7826:	4d 93       	st	X+, r20
    7828:	5d 93       	st	X+, r21
    782a:	6d 93       	st	X+, r22
    782c:	7c 93       	st	X, r23
    782e:	13 97       	sbiw	r26, 0x03	; 3
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    7830:	25 96       	adiw	r28, 0x05	; 5
    7832:	ae ad       	ldd	r26, Y+62	; 0x3e
    7834:	bf ad       	ldd	r27, Y+63	; 0x3f
    7836:	25 97       	sbiw	r28, 0x05	; 5
    7838:	ae 50       	subi	r26, 0x0E	; 14
    783a:	bf 4f       	sbci	r27, 0xFF	; 255
    783c:	4d 91       	ld	r20, X+
    783e:	5d 91       	ld	r21, X+
    7840:	6d 91       	ld	r22, X+
    7842:	7c 91       	ld	r23, X
	message->XMagFrd = model->XMagFrd();
    7844:	ad 8d       	ldd	r26, Y+29	; 0x1d
    7846:	be 8d       	ldd	r27, Y+30	; 0x1e
    7848:	4d 93       	st	X+, r20
    784a:	5d 93       	st	X+, r21
    784c:	6d 93       	st	X+, r22
    784e:	7c 93       	st	X, r23
    7850:	13 97       	sbiw	r26, 0x03	; 3
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    7852:	25 96       	adiw	r28, 0x05	; 5
    7854:	ae ad       	ldd	r26, Y+62	; 0x3e
    7856:	bf ad       	ldd	r27, Y+63	; 0x3f
    7858:	25 97       	sbiw	r28, 0x05	; 5
    785a:	aa 50       	subi	r26, 0x0A	; 10
    785c:	bf 4f       	sbci	r27, 0xFF	; 255
    785e:	4d 91       	ld	r20, X+
    7860:	5d 91       	ld	r21, X+
    7862:	6d 91       	ld	r22, X+
    7864:	7c 91       	ld	r23, X
	message->YMagFrd = model->YMagFrd();
    7866:	af 8d       	ldd	r26, Y+31	; 0x1f
    7868:	b8 a1       	ldd	r27, Y+32	; 0x20
    786a:	4d 93       	st	X+, r20
    786c:	5d 93       	st	X+, r21
    786e:	6d 93       	st	X+, r22
    7870:	7c 93       	st	X, r23
    7872:	13 97       	sbiw	r26, 0x03	; 3
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    7874:	25 96       	adiw	r28, 0x05	; 5
    7876:	ae ad       	ldd	r26, Y+62	; 0x3e
    7878:	bf ad       	ldd	r27, Y+63	; 0x3f
    787a:	25 97       	sbiw	r28, 0x05	; 5
    787c:	a6 50       	subi	r26, 0x06	; 6
    787e:	bf 4f       	sbci	r27, 0xFF	; 255
    7880:	4d 91       	ld	r20, X+
    7882:	5d 91       	ld	r21, X+
    7884:	6d 91       	ld	r22, X+
    7886:	7c 91       	ld	r23, X
	message->ZMagFrd = model->ZMagFrd();
    7888:	a9 a1       	ldd	r26, Y+33	; 0x21
    788a:	ba a1       	ldd	r27, Y+34	; 0x22
    788c:	4d 93       	st	X+, r20
    788e:	5d 93       	st	X+, r21
    7890:	6d 93       	st	X+, r22
    7892:	7c 93       	st	X, r23
    7894:	13 97       	sbiw	r26, 0x03	; 3
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    7896:	25 96       	adiw	r28, 0x05	; 5
    7898:	ae ad       	ldd	r26, Y+62	; 0x3e
    789a:	bf ad       	ldd	r27, Y+63	; 0x3f
    789c:	25 97       	sbiw	r28, 0x05	; 5
    789e:	a2 50       	subi	r26, 0x02	; 2
    78a0:	bf 4f       	sbci	r27, 0xFF	; 255
    78a2:	4d 91       	ld	r20, X+
    78a4:	5d 91       	ld	r21, X+
    78a6:	6d 91       	ld	r22, X+
    78a8:	7c 91       	ld	r23, X

	message->XEcefCm = model->XEcefCm();
    78aa:	ab a1       	ldd	r26, Y+35	; 0x23
    78ac:	bc a1       	ldd	r27, Y+36	; 0x24
    78ae:	4d 93       	st	X+, r20
    78b0:	5d 93       	st	X+, r21
    78b2:	6d 93       	st	X+, r22
    78b4:	7c 93       	st	X, r23
    78b6:	13 97       	sbiw	r26, 0x03	; 3
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    78b8:	25 96       	adiw	r28, 0x05	; 5
    78ba:	ae ad       	ldd	r26, Y+62	; 0x3e
    78bc:	bf ad       	ldd	r27, Y+63	; 0x3f
    78be:	25 97       	sbiw	r28, 0x05	; 5
    78c0:	ae 5f       	subi	r26, 0xFE	; 254
    78c2:	be 4f       	sbci	r27, 0xFE	; 254
    78c4:	4d 91       	ld	r20, X+
    78c6:	5d 91       	ld	r21, X+
    78c8:	6d 91       	ld	r22, X+
    78ca:	7c 91       	ld	r23, X
	message->YEcefCm = model->YEcefCm();
    78cc:	ad a1       	ldd	r26, Y+37	; 0x25
    78ce:	be a1       	ldd	r27, Y+38	; 0x26
    78d0:	4d 93       	st	X+, r20
    78d2:	5d 93       	st	X+, r21
    78d4:	6d 93       	st	X+, r22
    78d6:	7c 93       	st	X, r23
    78d8:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    78da:	25 96       	adiw	r28, 0x05	; 5
    78dc:	ae ad       	ldd	r26, Y+62	; 0x3e
    78de:	bf ad       	ldd	r27, Y+63	; 0x3f
    78e0:	25 97       	sbiw	r28, 0x05	; 5
    78e2:	aa 5f       	subi	r26, 0xFA	; 250
    78e4:	be 4f       	sbci	r27, 0xFE	; 254
    78e6:	4d 91       	ld	r20, X+
    78e8:	5d 91       	ld	r21, X+
    78ea:	6d 91       	ld	r22, X+
    78ec:	7c 91       	ld	r23, X
	message->ZEcefCm = model->ZEcefCm();	
    78ee:	af a1       	ldd	r26, Y+39	; 0x27
    78f0:	b8 a5       	ldd	r27, Y+40	; 0x28
    78f2:	4d 93       	st	X+, r20
    78f4:	5d 93       	st	X+, r21
    78f6:	6d 93       	st	X+, r22
    78f8:	7c 93       	st	X, r23
    78fa:	13 97       	sbiw	r26, 0x03	; 3
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    78fc:	25 96       	adiw	r28, 0x05	; 5
    78fe:	ae ad       	ldd	r26, Y+62	; 0x3e
    7900:	bf ad       	ldd	r27, Y+63	; 0x3f
    7902:	25 97       	sbiw	r28, 0x05	; 5
    7904:	a6 5f       	subi	r26, 0xF6	; 246
    7906:	be 4f       	sbci	r27, 0xFE	; 254
    7908:	4d 91       	ld	r20, X+
    790a:	5d 91       	ld	r21, X+
    790c:	6d 91       	ld	r22, X+
    790e:	7c 91       	ld	r23, X
	message->XVEcefCms = model->XVEcefCms();
    7910:	a9 a5       	ldd	r26, Y+41	; 0x29
    7912:	ba a5       	ldd	r27, Y+42	; 0x2a
    7914:	4d 93       	st	X+, r20
    7916:	5d 93       	st	X+, r21
    7918:	6d 93       	st	X+, r22
    791a:	7c 93       	st	X, r23
    791c:	13 97       	sbiw	r26, 0x03	; 3
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    791e:	25 96       	adiw	r28, 0x05	; 5
    7920:	ae ad       	ldd	r26, Y+62	; 0x3e
    7922:	bf ad       	ldd	r27, Y+63	; 0x3f
    7924:	25 97       	sbiw	r28, 0x05	; 5
    7926:	a2 5f       	subi	r26, 0xF2	; 242
    7928:	be 4f       	sbci	r27, 0xFE	; 254
    792a:	4d 91       	ld	r20, X+
    792c:	5d 91       	ld	r21, X+
    792e:	6d 91       	ld	r22, X+
    7930:	7c 91       	ld	r23, X
	message->YVEcefCms = model->YVEcefCms();
    7932:	ab a5       	ldd	r26, Y+43	; 0x2b
    7934:	bc a5       	ldd	r27, Y+44	; 0x2c
    7936:	4d 93       	st	X+, r20
    7938:	5d 93       	st	X+, r21
    793a:	6d 93       	st	X+, r22
    793c:	7c 93       	st	X, r23
    793e:	13 97       	sbiw	r26, 0x03	; 3
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    7940:	25 96       	adiw	r28, 0x05	; 5
    7942:	ae ad       	ldd	r26, Y+62	; 0x3e
    7944:	bf ad       	ldd	r27, Y+63	; 0x3f
    7946:	25 97       	sbiw	r28, 0x05	; 5
    7948:	ae 5e       	subi	r26, 0xEE	; 238
    794a:	be 4f       	sbci	r27, 0xFE	; 254
    794c:	4d 91       	ld	r20, X+
    794e:	5d 91       	ld	r21, X+
    7950:	6d 91       	ld	r22, X+
    7952:	7c 91       	ld	r23, X
	message->ZVEcefCms = model->ZVEcefCms();
    7954:	ad a5       	ldd	r26, Y+45	; 0x2d
    7956:	be a5       	ldd	r27, Y+46	; 0x2e
    7958:	4d 93       	st	X+, r20
    795a:	5d 93       	st	X+, r21
    795c:	6d 93       	st	X+, r22
    795e:	7c 93       	st	X, r23
    7960:	13 97       	sbiw	r26, 0x03	; 3
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    7962:	25 96       	adiw	r28, 0x05	; 5
    7964:	ae ad       	ldd	r26, Y+62	; 0x3e
    7966:	bf ad       	ldd	r27, Y+63	; 0x3f
    7968:	25 97       	sbiw	r28, 0x05	; 5
    796a:	aa 5e       	subi	r26, 0xEA	; 234
    796c:	be 4f       	sbci	r27, 0xFE	; 254
    796e:	4d 91       	ld	r20, X+
    7970:	5d 91       	ld	r21, X+
    7972:	6d 91       	ld	r22, X+
    7974:	7c 91       	ld	r23, X
	message->PressureMillibars = model->PressureMillibars();
    7976:	af a5       	ldd	r26, Y+47	; 0x2f
    7978:	b8 a9       	ldd	r27, Y+48	; 0x30
    797a:	4d 93       	st	X+, r20
    797c:	5d 93       	st	X+, r21
    797e:	6d 93       	st	X+, r22
    7980:	7c 93       	st	X, r23
    7982:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    7984:	25 96       	adiw	r28, 0x05	; 5
    7986:	ae ad       	ldd	r26, Y+62	; 0x3e
    7988:	bf ad       	ldd	r27, Y+63	; 0x3f
    798a:	25 97       	sbiw	r28, 0x05	; 5
    798c:	ae 54       	subi	r26, 0x4E	; 78
    798e:	bf 4f       	sbci	r27, 0xFF	; 255
    7990:	4d 91       	ld	r20, X+
    7992:	5d 91       	ld	r21, X+
    7994:	6d 91       	ld	r22, X+
    7996:	7c 91       	ld	r23, X
	
	
	
	message->ChecksumErrors = model->ChecksumErrors();
    7998:	ad ad       	ldd	r26, Y+61	; 0x3d
    799a:	be ad       	ldd	r27, Y+62	; 0x3e
    799c:	4d 93       	st	X+, r20
    799e:	5d 93       	st	X+, r21
    79a0:	6d 93       	st	X+, r22
    79a2:	7c 93       	st	X, r23
    79a4:	13 97       	sbiw	r26, 0x03	; 3

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    79a6:	25 96       	adiw	r28, 0x05	; 5
    79a8:	ae ad       	ldd	r26, Y+62	; 0x3e
    79aa:	bf ad       	ldd	r27, Y+63	; 0x3f
    79ac:	25 97       	sbiw	r28, 0x05	; 5
    79ae:	a6 55       	subi	r26, 0x56	; 86
    79b0:	bf 4f       	sbci	r27, 0xFF	; 255
    79b2:	4d 91       	ld	r20, X+
    79b4:	5d 91       	ld	r21, X+
    79b6:	6d 91       	ld	r22, X+
    79b8:	7c 91       	ld	r23, X
	message->Timeouts = model->Timeouts();
    79ba:	a9 ad       	ldd	r26, Y+57	; 0x39
    79bc:	ba ad       	ldd	r27, Y+58	; 0x3a
    79be:	4d 93       	st	X+, r20
    79c0:	5d 93       	st	X+, r21
    79c2:	6d 93       	st	X+, r22
    79c4:	7c 93       	st	X, r23
    79c6:	13 97       	sbiw	r26, 0x03	; 3
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    79c8:	25 96       	adiw	r28, 0x05	; 5
    79ca:	ae ad       	ldd	r26, Y+62	; 0x3e
    79cc:	bf ad       	ldd	r27, Y+63	; 0x3f
    79ce:	25 97       	sbiw	r28, 0x05	; 5
    79d0:	a2 55       	subi	r26, 0x52	; 82
    79d2:	bf 4f       	sbci	r27, 0xFF	; 255
    79d4:	4d 91       	ld	r20, X+
    79d6:	5d 91       	ld	r21, X+
    79d8:	6d 91       	ld	r22, X+
    79da:	7c 91       	ld	r23, X
	message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    79dc:	ab ad       	ldd	r26, Y+59	; 0x3b
    79de:	bc ad       	ldd	r27, Y+60	; 0x3c
    79e0:	4d 93       	st	X+, r20
    79e2:	5d 93       	st	X+, r21
    79e4:	6d 93       	st	X+, r22
    79e6:	7c 93       	st	X, r23
    79e8:	13 97       	sbiw	r26, 0x03	; 3
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    79ea:	25 96       	adiw	r28, 0x05	; 5
    79ec:	ae ad       	ldd	r26, Y+62	; 0x3e
    79ee:	bf ad       	ldd	r27, Y+63	; 0x3f
    79f0:	25 97       	sbiw	r28, 0x05	; 5
    79f2:	aa 54       	subi	r26, 0x4A	; 74
    79f4:	bf 4f       	sbci	r27, 0xFF	; 255
    79f6:	4d 91       	ld	r20, X+
    79f8:	5d 91       	ld	r21, X+
    79fa:	6d 91       	ld	r22, X+
    79fc:	7c 91       	ld	r23, X
	message->NumOfBlownFrames = model->BlownFrames();
    79fe:	21 96       	adiw	r28, 0x01	; 1
    7a00:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a02:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a04:	21 97       	sbiw	r28, 0x01	; 1
    7a06:	4d 93       	st	X+, r20
    7a08:	5d 93       	st	X+, r21
    7a0a:	6d 93       	st	X+, r22
    7a0c:	7c 93       	st	X, r23
    7a0e:	13 97       	sbiw	r26, 0x03	; 3
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    7a10:	25 96       	adiw	r28, 0x05	; 5
    7a12:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a14:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a16:	25 97       	sbiw	r28, 0x05	; 5
    7a18:	a6 54       	subi	r26, 0x46	; 70
    7a1a:	bf 4f       	sbci	r27, 0xFF	; 255
    7a1c:	4d 91       	ld	r20, X+
    7a1e:	5d 91       	ld	r21, X+
    7a20:	6d 91       	ld	r22, X+
    7a22:	7c 91       	ld	r23, X
	message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    7a24:	23 96       	adiw	r28, 0x03	; 3
    7a26:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a28:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a2a:	23 97       	sbiw	r28, 0x03	; 3
    7a2c:	4d 93       	st	X+, r20
    7a2e:	5d 93       	st	X+, r21
    7a30:	6d 93       	st	X+, r22
    7a32:	7c 93       	st	X, r23
    7a34:	13 97       	sbiw	r26, 0x03	; 3
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
    7a36:	25 96       	adiw	r28, 0x05	; 5
    7a38:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a3a:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a3c:	25 97       	sbiw	r28, 0x05	; 5
    7a3e:	96 96       	adiw	r26, 0x26	; 38
    7a40:	4d 91       	ld	r20, X+
    7a42:	5d 91       	ld	r21, X+
    7a44:	6d 91       	ld	r22, X+
    7a46:	7c 91       	ld	r23, X
    7a48:	99 97       	sbiw	r26, 0x29	; 41
	
	
	
	message->XRefSetpoint = model->ReferenceXNEDLocalFrameCm();
    7a4a:	a9 a9       	ldd	r26, Y+49	; 0x31
    7a4c:	ba a9       	ldd	r27, Y+50	; 0x32
    7a4e:	4d 93       	st	X+, r20
    7a50:	5d 93       	st	X+, r21
    7a52:	6d 93       	st	X+, r22
    7a54:	7c 93       	st	X, r23
    7a56:	13 97       	sbiw	r26, 0x03	; 3


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
    7a58:	25 96       	adiw	r28, 0x05	; 5
    7a5a:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a5c:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a5e:	25 97       	sbiw	r28, 0x05	; 5
    7a60:	ae 5a       	subi	r26, 0xAE	; 174
    7a62:	bf 4f       	sbci	r27, 0xFF	; 255
    7a64:	4d 91       	ld	r20, X+
    7a66:	5d 91       	ld	r21, X+
    7a68:	6d 91       	ld	r22, X+
    7a6a:	7c 91       	ld	r23, X
	message->YRefSetpoint = model->ReferenceYNEDLocalFrameCm();
    7a6c:	ab a9       	ldd	r26, Y+51	; 0x33
    7a6e:	bc a9       	ldd	r27, Y+52	; 0x34
    7a70:	4d 93       	st	X+, r20
    7a72:	5d 93       	st	X+, r21
    7a74:	6d 93       	st	X+, r22
    7a76:	7c 93       	st	X, r23
    7a78:	13 97       	sbiw	r26, 0x03	; 3

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
    7a7a:	25 96       	adiw	r28, 0x05	; 5
    7a7c:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a7e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a80:	25 97       	sbiw	r28, 0x05	; 5
    7a82:	ae 57       	subi	r26, 0x7E	; 126
    7a84:	bf 4f       	sbci	r27, 0xFF	; 255
    7a86:	4d 91       	ld	r20, X+
    7a88:	5d 91       	ld	r21, X+
    7a8a:	6d 91       	ld	r22, X+
    7a8c:	7c 91       	ld	r23, X
	message->ZRefSetpoint = model->ReferenceZNEDLocalFrameCm();	
    7a8e:	ad a9       	ldd	r26, Y+53	; 0x35
    7a90:	be a9       	ldd	r27, Y+54	; 0x36
    7a92:	4d 93       	st	X+, r20
    7a94:	5d 93       	st	X+, r21
    7a96:	6d 93       	st	X+, r22
    7a98:	7c 93       	st	X, r23
    7a9a:	13 97       	sbiw	r26, 0x03	; 3
				EcefToLocalNEDRotationMatrix[2][0] = 0;
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
    7a9c:	25 96       	adiw	r28, 0x05	; 5
    7a9e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7aa0:	bf ad       	ldd	r27, Y+63	; 0x3f
    7aa2:	25 97       	sbiw	r28, 0x05	; 5
    7aa4:	16 96       	adiw	r26, 0x06	; 6
    7aa6:	4d 91       	ld	r20, X+
    7aa8:	5d 91       	ld	r21, X+
    7aaa:	6d 91       	ld	r22, X+
    7aac:	7c 91       	ld	r23, X
    7aae:	19 97       	sbiw	r26, 0x09	; 9
	message->YawRefSetpoint = model->ReferenceMagYawRads();
    7ab0:	af a9       	ldd	r26, Y+55	; 0x37
    7ab2:	b8 ad       	ldd	r27, Y+56	; 0x38
    7ab4:	4d 93       	st	X+, r20
    7ab6:	5d 93       	st	X+, r21
    7ab8:	6d 93       	st	X+, r22
    7aba:	7c 93       	st	X, r23
    7abc:	13 97       	sbiw	r26, 0x03	; 3

			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
    7abe:	25 96       	adiw	r28, 0x05	; 5
    7ac0:	ae ad       	ldd	r26, Y+62	; 0x3e
    7ac2:	bf ad       	ldd	r27, Y+63	; 0x3f
    7ac4:	25 97       	sbiw	r28, 0x05	; 5
    7ac6:	ae 55       	subi	r26, 0x5E	; 94
    7ac8:	bf 4f       	sbci	r27, 0xFF	; 255
    7aca:	4d 91       	ld	r20, X+
    7acc:	5d 91       	ld	r21, X+
    7ace:	6d 91       	ld	r22, X+
    7ad0:	7c 91       	ld	r23, X
	
	
	message->LatitudeDegrees = model->LatitudeDegrees();
    7ad2:	a9 89       	ldd	r26, Y+17	; 0x11
    7ad4:	ba 89       	ldd	r27, Y+18	; 0x12
    7ad6:	4d 93       	st	X+, r20
    7ad8:	5d 93       	st	X+, r21
    7ada:	6d 93       	st	X+, r22
    7adc:	7c 93       	st	X, r23
    7ade:	13 97       	sbiw	r26, 0x03	; 3
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						

			float LongitudeDegrees() const {return longitudeDegrees;}
    7ae0:	25 96       	adiw	r28, 0x05	; 5
    7ae2:	ae ad       	ldd	r26, Y+62	; 0x3e
    7ae4:	bf ad       	ldd	r27, Y+63	; 0x3f
    7ae6:	25 97       	sbiw	r28, 0x05	; 5
    7ae8:	aa 55       	subi	r26, 0x5A	; 90
    7aea:	bf 4f       	sbci	r27, 0xFF	; 255
    7aec:	4d 91       	ld	r20, X+
    7aee:	5d 91       	ld	r21, X+
    7af0:	6d 91       	ld	r22, X+
    7af2:	7c 91       	ld	r23, X
	message->LongitudeDegrees = model->LongitudeDegrees();
    7af4:	ab 89       	ldd	r26, Y+19	; 0x13
    7af6:	bc 89       	ldd	r27, Y+20	; 0x14
    7af8:	4d 93       	st	X+, r20
    7afa:	5d 93       	st	X+, r21
    7afc:	6d 93       	st	X+, r22
    7afe:	7c 93       	st	X, r23
    7b00:	13 97       	sbiw	r26, 0x03	; 3
	
	return message;
}
    7b02:	8e 2f       	mov	r24, r30
    7b04:	9f 2f       	mov	r25, r31
    7b06:	c8 5b       	subi	r28, 0xB8	; 184
    7b08:	df 4f       	sbci	r29, 0xFF	; 255
    7b0a:	0f b6       	in	r0, 0x3f	; 63
    7b0c:	f8 94       	cli
    7b0e:	de bf       	out	0x3e, r29	; 62
    7b10:	0f be       	out	0x3f, r0	; 63
    7b12:	cd bf       	out	0x3d, r28	; 61
    7b14:	df 91       	pop	r29
    7b16:	cf 91       	pop	r28
    7b18:	1f 91       	pop	r17
    7b1a:	0f 91       	pop	r16
    7b1c:	ff 90       	pop	r15
    7b1e:	ef 90       	pop	r14
    7b20:	df 90       	pop	r13
    7b22:	cf 90       	pop	r12
    7b24:	bf 90       	pop	r11
    7b26:	af 90       	pop	r10
    7b28:	9f 90       	pop	r9
    7b2a:	8f 90       	pop	r8
    7b2c:	7f 90       	pop	r7
    7b2e:	6f 90       	pop	r6
    7b30:	5f 90       	pop	r5
    7b32:	4f 90       	pop	r4
    7b34:	3f 90       	pop	r3
    7b36:	2f 90       	pop	r2
    7b38:	08 95       	ret

00007b3a <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>:
	model->YVEcefCms(this->YVEcefCms);
	model->ZVEcefCms(this->ZVEcefCms);
}

void SystemTelemetryMessage::updateModelFromMessageFromSimulator (SystemModel *model)
{
    7b3a:	fb 01       	movw	r30, r22
	//Convert from meters per sec, to foot per sec.
	
	
	
	//Copy fake gyroscope data
	model->PitchAngularVelocityRadsPerSecond(this->PitchAngularVelocityRadsPerSecond);
    7b3c:	dc 01       	movw	r26, r24
    7b3e:	a3 52       	subi	r26, 0x23	; 35
    7b40:	bf 4f       	sbci	r27, 0xFF	; 255
    7b42:	4d 91       	ld	r20, X+
    7b44:	5d 91       	ld	r21, X+
    7b46:	6d 91       	ld	r22, X+
    7b48:	7c 91       	ld	r23, X
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    7b4a:	df 01       	movw	r26, r30
    7b4c:	a6 52       	subi	r26, 0x26	; 38
    7b4e:	bf 4f       	sbci	r27, 0xFF	; 255
    7b50:	4d 93       	st	X+, r20
    7b52:	5d 93       	st	X+, r21
    7b54:	6d 93       	st	X+, r22
    7b56:	7c 93       	st	X, r23
    7b58:	13 97       	sbiw	r26, 0x03	; 3
	model->YawAngularVelocityRadsPerSecond(this->YawAngularVelocityRadsPerSecond);
    7b5a:	dc 01       	movw	r26, r24
    7b5c:	a7 52       	subi	r26, 0x27	; 39
    7b5e:	bf 4f       	sbci	r27, 0xFF	; 255
    7b60:	4d 91       	ld	r20, X+
    7b62:	5d 91       	ld	r21, X+
    7b64:	6d 91       	ld	r22, X+
    7b66:	7c 91       	ld	r23, X
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    7b68:	df 01       	movw	r26, r30
    7b6a:	ae 51       	subi	r26, 0x1E	; 30
    7b6c:	bf 4f       	sbci	r27, 0xFF	; 255
    7b6e:	4d 93       	st	X+, r20
    7b70:	5d 93       	st	X+, r21
    7b72:	6d 93       	st	X+, r22
    7b74:	7c 93       	st	X, r23
    7b76:	13 97       	sbiw	r26, 0x03	; 3
	model->RollAngularVelocityRadsPerSecond(this->RollAngularVelocityRadsPerSecond);
    7b78:	dc 01       	movw	r26, r24
    7b7a:	af 51       	subi	r26, 0x1F	; 31
    7b7c:	bf 4f       	sbci	r27, 0xFF	; 255
    7b7e:	4d 91       	ld	r20, X+
    7b80:	5d 91       	ld	r21, X+
    7b82:	6d 91       	ld	r22, X+
    7b84:	7c 91       	ld	r23, X
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    7b86:	df 01       	movw	r26, r30
    7b88:	a2 52       	subi	r26, 0x22	; 34
    7b8a:	bf 4f       	sbci	r27, 0xFF	; 255
    7b8c:	4d 93       	st	X+, r20
    7b8e:	5d 93       	st	X+, r21
    7b90:	6d 93       	st	X+, r22
    7b92:	7c 93       	st	X, r23
    7b94:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake GPS data
//	model->XVelocityMetersPerSecond(this->XVelocityMetersPerSecond); //this is supposed to be 'output' data, not input.
//	model->YVelocityMetersPerSecond(this->YVelocityMetersPerSecond);
	//ZVelocity is derived from pressure changes. //model->ZVelocityMetersPerSecond(this->ZVelocityMetersPerSecond); 
	model->LatitudeDegrees(this->LatitudeDegrees);
    7b96:	dc 01       	movw	r26, r24
    7b98:	ab 53       	subi	r26, 0x3B	; 59
    7b9a:	bf 4f       	sbci	r27, 0xFF	; 255
    7b9c:	4d 91       	ld	r20, X+
    7b9e:	5d 91       	ld	r21, X+
    7ba0:	6d 91       	ld	r22, X+
    7ba2:	7c 91       	ld	r23, X
			float ZDerivativeError() const {return zDerivativeError;}
			void ZDerivativeError(float val) { zDerivativeError = val;}						
						
						
			float LatitudeDegrees() const {return latitudeDegrees;}
			void LatitudeDegrees(float val) { latitudeDegrees = val;}						
    7ba4:	df 01       	movw	r26, r30
    7ba6:	ae 55       	subi	r26, 0x5E	; 94
    7ba8:	bf 4f       	sbci	r27, 0xFF	; 255
    7baa:	4d 93       	st	X+, r20
    7bac:	5d 93       	st	X+, r21
    7bae:	6d 93       	st	X+, r22
    7bb0:	7c 93       	st	X, r23
    7bb2:	13 97       	sbiw	r26, 0x03	; 3
	model->LongitudeDegrees(this->LongitudeDegrees);
    7bb4:	dc 01       	movw	r26, r24
    7bb6:	a7 53       	subi	r26, 0x37	; 55
    7bb8:	bf 4f       	sbci	r27, 0xFF	; 255
    7bba:	4d 91       	ld	r20, X+
    7bbc:	5d 91       	ld	r21, X+
    7bbe:	6d 91       	ld	r22, X+
    7bc0:	7c 91       	ld	r23, X

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
    7bc2:	df 01       	movw	r26, r30
    7bc4:	aa 55       	subi	r26, 0x5A	; 90
    7bc6:	bf 4f       	sbci	r27, 0xFF	; 255
    7bc8:	4d 93       	st	X+, r20
    7bca:	5d 93       	st	X+, r21
    7bcc:	6d 93       	st	X+, r22
    7bce:	7c 93       	st	X, r23
    7bd0:	13 97       	sbiw	r26, 0x03	; 3
	model->XEcefCm(this->XEcefCm);
    7bd2:	dc 01       	movw	r26, r24
    7bd4:	af 50       	subi	r26, 0x0F	; 15
    7bd6:	bf 4f       	sbci	r27, 0xFF	; 255
    7bd8:	4d 91       	ld	r20, X+
    7bda:	5d 91       	ld	r21, X+
    7bdc:	6d 91       	ld	r22, X+
    7bde:	7c 91       	ld	r23, X
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    7be0:	df 01       	movw	r26, r30
    7be2:	a2 50       	subi	r26, 0x02	; 2
    7be4:	bf 4f       	sbci	r27, 0xFF	; 255
    7be6:	4d 93       	st	X+, r20
    7be8:	5d 93       	st	X+, r21
    7bea:	6d 93       	st	X+, r22
    7bec:	7c 93       	st	X, r23
    7bee:	13 97       	sbiw	r26, 0x03	; 3
	model->YEcefCm(this->YEcefCm);
    7bf0:	dc 01       	movw	r26, r24
    7bf2:	ab 50       	subi	r26, 0x0B	; 11
    7bf4:	bf 4f       	sbci	r27, 0xFF	; 255
    7bf6:	4d 91       	ld	r20, X+
    7bf8:	5d 91       	ld	r21, X+
    7bfa:	6d 91       	ld	r22, X+
    7bfc:	7c 91       	ld	r23, X
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    7bfe:	df 01       	movw	r26, r30
    7c00:	ae 5f       	subi	r26, 0xFE	; 254
    7c02:	be 4f       	sbci	r27, 0xFE	; 254
    7c04:	4d 93       	st	X+, r20
    7c06:	5d 93       	st	X+, r21
    7c08:	6d 93       	st	X+, r22
    7c0a:	7c 93       	st	X, r23
    7c0c:	13 97       	sbiw	r26, 0x03	; 3
	model->ZEcefCm(this->ZEcefCm);
    7c0e:	dc 01       	movw	r26, r24
    7c10:	a7 50       	subi	r26, 0x07	; 7
    7c12:	bf 4f       	sbci	r27, 0xFF	; 255
    7c14:	4d 91       	ld	r20, X+
    7c16:	5d 91       	ld	r21, X+
    7c18:	6d 91       	ld	r22, X+
    7c1a:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    7c1c:	df 01       	movw	r26, r30
    7c1e:	aa 5f       	subi	r26, 0xFA	; 250
    7c20:	be 4f       	sbci	r27, 0xFE	; 254
    7c22:	4d 93       	st	X+, r20
    7c24:	5d 93       	st	X+, r21
    7c26:	6d 93       	st	X+, r22
    7c28:	7c 93       	st	X, r23
    7c2a:	13 97       	sbiw	r26, 0x03	; 3
		
	//Copy fake accelerometer data
	model->XAccelFrdMss(this->XAccelFrdMss);
    7c2c:	dc 01       	movw	r26, r24
    7c2e:	a3 53       	subi	r26, 0x33	; 51
    7c30:	bf 4f       	sbci	r27, 0xFF	; 255
    7c32:	4d 91       	ld	r20, X+
    7c34:	5d 91       	ld	r21, X+
    7c36:	6d 91       	ld	r22, X+
    7c38:	7c 91       	ld	r23, X
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    7c3a:	df 01       	movw	r26, r30
    7c3c:	aa 51       	subi	r26, 0x1A	; 26
    7c3e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c40:	4d 93       	st	X+, r20
    7c42:	5d 93       	st	X+, r21
    7c44:	6d 93       	st	X+, r22
    7c46:	7c 93       	st	X, r23
    7c48:	13 97       	sbiw	r26, 0x03	; 3
	model->YAccelFrdMss(this->YAccelFrdMss);
    7c4a:	dc 01       	movw	r26, r24
    7c4c:	af 52       	subi	r26, 0x2F	; 47
    7c4e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c50:	4d 91       	ld	r20, X+
    7c52:	5d 91       	ld	r21, X+
    7c54:	6d 91       	ld	r22, X+
    7c56:	7c 91       	ld	r23, X

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    7c58:	df 01       	movw	r26, r30
    7c5a:	a6 51       	subi	r26, 0x16	; 22
    7c5c:	bf 4f       	sbci	r27, 0xFF	; 255
    7c5e:	4d 93       	st	X+, r20
    7c60:	5d 93       	st	X+, r21
    7c62:	6d 93       	st	X+, r22
    7c64:	7c 93       	st	X, r23
    7c66:	13 97       	sbiw	r26, 0x03	; 3
	model->ZAccelFrdMss(this->ZAccelFrdMss);
    7c68:	dc 01       	movw	r26, r24
    7c6a:	ab 52       	subi	r26, 0x2B	; 43
    7c6c:	bf 4f       	sbci	r27, 0xFF	; 255
    7c6e:	4d 91       	ld	r20, X+
    7c70:	5d 91       	ld	r21, X+
    7c72:	6d 91       	ld	r22, X+
    7c74:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    7c76:	df 01       	movw	r26, r30
    7c78:	a2 51       	subi	r26, 0x12	; 18
    7c7a:	bf 4f       	sbci	r27, 0xFF	; 255
    7c7c:	4d 93       	st	X+, r20
    7c7e:	5d 93       	st	X+, r21
    7c80:	6d 93       	st	X+, r22
    7c82:	7c 93       	st	X, r23
    7c84:	13 97       	sbiw	r26, 0x03	; 3
	model->XVEcefCms(this->XVEcefCms);
    7c86:	dc 01       	movw	r26, r24
    7c88:	a3 50       	subi	r26, 0x03	; 3
    7c8a:	bf 4f       	sbci	r27, 0xFF	; 255
    7c8c:	4d 91       	ld	r20, X+
    7c8e:	5d 91       	ld	r21, X+
    7c90:	6d 91       	ld	r22, X+
    7c92:	7c 91       	ld	r23, X
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    7c94:	df 01       	movw	r26, r30
    7c96:	a6 5f       	subi	r26, 0xF6	; 246
    7c98:	be 4f       	sbci	r27, 0xFE	; 254
    7c9a:	4d 93       	st	X+, r20
    7c9c:	5d 93       	st	X+, r21
    7c9e:	6d 93       	st	X+, r22
    7ca0:	7c 93       	st	X, r23
    7ca2:	13 97       	sbiw	r26, 0x03	; 3
	model->YVEcefCms(this->YVEcefCms);
    7ca4:	dc 01       	movw	r26, r24
    7ca6:	af 5f       	subi	r26, 0xFF	; 255
    7ca8:	be 4f       	sbci	r27, 0xFE	; 254
    7caa:	4d 91       	ld	r20, X+
    7cac:	5d 91       	ld	r21, X+
    7cae:	6d 91       	ld	r22, X+
    7cb0:	7c 91       	ld	r23, X
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    7cb2:	df 01       	movw	r26, r30
    7cb4:	a2 5f       	subi	r26, 0xF2	; 242
    7cb6:	be 4f       	sbci	r27, 0xFE	; 254
    7cb8:	4d 93       	st	X+, r20
    7cba:	5d 93       	st	X+, r21
    7cbc:	6d 93       	st	X+, r22
    7cbe:	7c 93       	st	X, r23
    7cc0:	13 97       	sbiw	r26, 0x03	; 3
	model->ZVEcefCms(this->ZVEcefCms);
    7cc2:	dc 01       	movw	r26, r24
    7cc4:	ab 5f       	subi	r26, 0xFB	; 251
    7cc6:	be 4f       	sbci	r27, 0xFE	; 254
    7cc8:	4d 91       	ld	r20, X+
    7cca:	5d 91       	ld	r21, X+
    7ccc:	6d 91       	ld	r22, X+
    7cce:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    7cd0:	df 01       	movw	r26, r30
    7cd2:	ae 5e       	subi	r26, 0xEE	; 238
    7cd4:	be 4f       	sbci	r27, 0xFE	; 254
    7cd6:	4d 93       	st	X+, r20
    7cd8:	5d 93       	st	X+, r21
    7cda:	6d 93       	st	X+, r22
    7cdc:	7c 93       	st	X, r23
    7cde:	13 97       	sbiw	r26, 0x03	; 3

	//copy fake mag data
	model->XMagFrd(this->XMagFrd);
    7ce0:	dc 01       	movw	r26, r24
    7ce2:	ab 51       	subi	r26, 0x1B	; 27
    7ce4:	bf 4f       	sbci	r27, 0xFF	; 255
    7ce6:	4d 91       	ld	r20, X+
    7ce8:	5d 91       	ld	r21, X+
    7cea:	6d 91       	ld	r22, X+
    7cec:	7c 91       	ld	r23, X
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    7cee:	df 01       	movw	r26, r30
    7cf0:	ae 50       	subi	r26, 0x0E	; 14
    7cf2:	bf 4f       	sbci	r27, 0xFF	; 255
    7cf4:	4d 93       	st	X+, r20
    7cf6:	5d 93       	st	X+, r21
    7cf8:	6d 93       	st	X+, r22
    7cfa:	7c 93       	st	X, r23
    7cfc:	13 97       	sbiw	r26, 0x03	; 3
	model->YMagFrd(this->YMagFrd);
    7cfe:	dc 01       	movw	r26, r24
    7d00:	a7 51       	subi	r26, 0x17	; 23
    7d02:	bf 4f       	sbci	r27, 0xFF	; 255
    7d04:	4d 91       	ld	r20, X+
    7d06:	5d 91       	ld	r21, X+
    7d08:	6d 91       	ld	r22, X+
    7d0a:	7c 91       	ld	r23, X

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    7d0c:	df 01       	movw	r26, r30
    7d0e:	aa 50       	subi	r26, 0x0A	; 10
    7d10:	bf 4f       	sbci	r27, 0xFF	; 255
    7d12:	4d 93       	st	X+, r20
    7d14:	5d 93       	st	X+, r21
    7d16:	6d 93       	st	X+, r22
    7d18:	7c 93       	st	X, r23
    7d1a:	13 97       	sbiw	r26, 0x03	; 3
	model->ZMagFrd(this->ZMagFrd);
    7d1c:	dc 01       	movw	r26, r24
    7d1e:	a3 51       	subi	r26, 0x13	; 19
    7d20:	bf 4f       	sbci	r27, 0xFF	; 255
    7d22:	4d 91       	ld	r20, X+
    7d24:	5d 91       	ld	r21, X+
    7d26:	6d 91       	ld	r22, X+
    7d28:	7c 91       	ld	r23, X

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    7d2a:	df 01       	movw	r26, r30
    7d2c:	a6 50       	subi	r26, 0x06	; 6
    7d2e:	bf 4f       	sbci	r27, 0xFF	; 255
    7d30:	4d 93       	st	X+, r20
    7d32:	5d 93       	st	X+, r21
    7d34:	6d 93       	st	X+, r22
    7d36:	7c 93       	st	X, r23
    7d38:	13 97       	sbiw	r26, 0x03	; 3
	
	//Copy fake barometer data.
	model->PressureMillibars(this->PressureMillibars);	
    7d3a:	dc 01       	movw	r26, r24
    7d3c:	a7 5f       	subi	r26, 0xF7	; 247
    7d3e:	be 4f       	sbci	r27, 0xFE	; 254
    7d40:	4d 91       	ld	r20, X+
    7d42:	5d 91       	ld	r21, X+
    7d44:	6d 91       	ld	r22, X+
    7d46:	7c 91       	ld	r23, X
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    7d48:	df 01       	movw	r26, r30
    7d4a:	aa 5e       	subi	r26, 0xEA	; 234
    7d4c:	be 4f       	sbci	r27, 0xFE	; 254
    7d4e:	4d 93       	st	X+, r20
    7d50:	5d 93       	st	X+, r21
    7d52:	6d 93       	st	X+, r22
    7d54:	7c 93       	st	X, r23
    7d56:	13 97       	sbiw	r26, 0x03	; 3


	model->ReferenceXNEDLocalFrameCm(this->XRefSetpoint);
    7d58:	dc 01       	movw	r26, r24
    7d5a:	a3 5f       	subi	r26, 0xF3	; 243
    7d5c:	be 4f       	sbci	r27, 0xFE	; 254
    7d5e:	4d 91       	ld	r20, X+
    7d60:	5d 91       	ld	r21, X+
    7d62:	6d 91       	ld	r22, X+
    7d64:	7c 91       	ld	r23, X
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    7d66:	46 a3       	std	Z+38, r20	; 0x26
    7d68:	57 a3       	std	Z+39, r21	; 0x27
    7d6a:	60 a7       	std	Z+40, r22	; 0x28
    7d6c:	71 a7       	std	Z+41, r23	; 0x29
	model->ReferenceYNEDLocalFrameCm(this->YRefSetpoint);
    7d6e:	dc 01       	movw	r26, r24
    7d70:	af 5e       	subi	r26, 0xEF	; 239
    7d72:	be 4f       	sbci	r27, 0xFE	; 254
    7d74:	4d 91       	ld	r20, X+
    7d76:	5d 91       	ld	r21, X+
    7d78:	6d 91       	ld	r22, X+
    7d7a:	7c 91       	ld	r23, X

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    7d7c:	df 01       	movw	r26, r30
    7d7e:	ae 5a       	subi	r26, 0xAE	; 174
    7d80:	bf 4f       	sbci	r27, 0xFF	; 255
    7d82:	4d 93       	st	X+, r20
    7d84:	5d 93       	st	X+, r21
    7d86:	6d 93       	st	X+, r22
    7d88:	7c 93       	st	X, r23
    7d8a:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceZNEDLocalFrameCm(this->ZRefSetpoint);
    7d8c:	dc 01       	movw	r26, r24
    7d8e:	ab 5e       	subi	r26, 0xEB	; 235
    7d90:	be 4f       	sbci	r27, 0xFE	; 254
    7d92:	4d 91       	ld	r20, X+
    7d94:	5d 91       	ld	r21, X+
    7d96:	6d 91       	ld	r22, X+
    7d98:	7c 91       	ld	r23, X
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    7d9a:	df 01       	movw	r26, r30
    7d9c:	ae 57       	subi	r26, 0x7E	; 126
    7d9e:	bf 4f       	sbci	r27, 0xFF	; 255
    7da0:	4d 93       	st	X+, r20
    7da2:	5d 93       	st	X+, r21
    7da4:	6d 93       	st	X+, r22
    7da6:	7c 93       	st	X, r23
    7da8:	13 97       	sbiw	r26, 0x03	; 3
	model->ReferenceMagYawRads(this->YawRefSetpoint);
    7daa:	dc 01       	movw	r26, r24
    7dac:	a7 5e       	subi	r26, 0xE7	; 231
    7dae:	be 4f       	sbci	r27, 0xFE	; 254
    7db0:	8d 91       	ld	r24, X+
    7db2:	9d 91       	ld	r25, X+
    7db4:	0d 90       	ld	r0, X+
    7db6:	bc 91       	ld	r27, X
    7db8:	a0 2d       	mov	r26, r0
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    7dba:	86 83       	std	Z+6, r24	; 0x06
    7dbc:	97 83       	std	Z+7, r25	; 0x07
    7dbe:	a0 87       	std	Z+8, r26	; 0x08
    7dc0:	b1 87       	std	Z+9, r27	; 0x09
    7dc2:	08 95       	ret

00007dc4 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>:
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;//.08f;//.05f;//.15;//.14f;//.08;//.08;*/
float AHRS::ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT = .001f;
float AHRS::MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT = .01f;

void AHRS::scaleAndAdjust(float vectorToAdjust[3], float vectorToScale[3], float scalerValue, float (&outputVector)[3])
{
    7dc4:	8f 92       	push	r8
    7dc6:	9f 92       	push	r9
    7dc8:	af 92       	push	r10
    7dca:	bf 92       	push	r11
    7dcc:	cf 92       	push	r12
    7dce:	df 92       	push	r13
    7dd0:	ef 92       	push	r14
    7dd2:	ff 92       	push	r15
    7dd4:	0f 93       	push	r16
    7dd6:	1f 93       	push	r17
    7dd8:	cf 93       	push	r28
    7dda:	df 93       	push	r29
    7ddc:	eb 01       	movw	r28, r22
    7dde:	6a 01       	movw	r12, r20
    7de0:	48 01       	movw	r8, r16
    7de2:	59 01       	movw	r10, r18
	outputVector[0] = vectorToAdjust[0] - scalerValue * vectorToScale[0];
    7de4:	fa 01       	movw	r30, r20
    7de6:	20 81       	ld	r18, Z
    7de8:	31 81       	ldd	r19, Z+1	; 0x01
    7dea:	42 81       	ldd	r20, Z+2	; 0x02
    7dec:	53 81       	ldd	r21, Z+3	; 0x03
    7dee:	c5 01       	movw	r24, r10
    7df0:	b4 01       	movw	r22, r8
    7df2:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    7df6:	9b 01       	movw	r18, r22
    7df8:	ac 01       	movw	r20, r24
    7dfa:	68 81       	ld	r22, Y
    7dfc:	79 81       	ldd	r23, Y+1	; 0x01
    7dfe:	8a 81       	ldd	r24, Y+2	; 0x02
    7e00:	9b 81       	ldd	r25, Y+3	; 0x03
    7e02:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    7e06:	f7 01       	movw	r30, r14
    7e08:	60 83       	st	Z, r22
    7e0a:	71 83       	std	Z+1, r23	; 0x01
    7e0c:	82 83       	std	Z+2, r24	; 0x02
    7e0e:	93 83       	std	Z+3, r25	; 0x03
	outputVector[1] = vectorToAdjust[1] - scalerValue * vectorToScale[1];
    7e10:	f6 01       	movw	r30, r12
    7e12:	24 81       	ldd	r18, Z+4	; 0x04
    7e14:	35 81       	ldd	r19, Z+5	; 0x05
    7e16:	46 81       	ldd	r20, Z+6	; 0x06
    7e18:	57 81       	ldd	r21, Z+7	; 0x07
    7e1a:	c5 01       	movw	r24, r10
    7e1c:	b4 01       	movw	r22, r8
    7e1e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    7e22:	9b 01       	movw	r18, r22
    7e24:	ac 01       	movw	r20, r24
    7e26:	6c 81       	ldd	r22, Y+4	; 0x04
    7e28:	7d 81       	ldd	r23, Y+5	; 0x05
    7e2a:	8e 81       	ldd	r24, Y+6	; 0x06
    7e2c:	9f 81       	ldd	r25, Y+7	; 0x07
    7e2e:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    7e32:	f7 01       	movw	r30, r14
    7e34:	64 83       	std	Z+4, r22	; 0x04
    7e36:	75 83       	std	Z+5, r23	; 0x05
    7e38:	86 83       	std	Z+6, r24	; 0x06
    7e3a:	97 83       	std	Z+7, r25	; 0x07
	outputVector[2] = vectorToAdjust[2] - scalerValue * vectorToScale[2];	
    7e3c:	f6 01       	movw	r30, r12
    7e3e:	20 85       	ldd	r18, Z+8	; 0x08
    7e40:	31 85       	ldd	r19, Z+9	; 0x09
    7e42:	42 85       	ldd	r20, Z+10	; 0x0a
    7e44:	53 85       	ldd	r21, Z+11	; 0x0b
    7e46:	c5 01       	movw	r24, r10
    7e48:	b4 01       	movw	r22, r8
    7e4a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    7e4e:	9b 01       	movw	r18, r22
    7e50:	ac 01       	movw	r20, r24
    7e52:	68 85       	ldd	r22, Y+8	; 0x08
    7e54:	79 85       	ldd	r23, Y+9	; 0x09
    7e56:	8a 85       	ldd	r24, Y+10	; 0x0a
    7e58:	9b 85       	ldd	r25, Y+11	; 0x0b
    7e5a:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    7e5e:	f7 01       	movw	r30, r14
    7e60:	60 87       	std	Z+8, r22	; 0x08
    7e62:	71 87       	std	Z+9, r23	; 0x09
    7e64:	82 87       	std	Z+10, r24	; 0x0a
    7e66:	93 87       	std	Z+11, r25	; 0x0b
}
    7e68:	df 91       	pop	r29
    7e6a:	cf 91       	pop	r28
    7e6c:	1f 91       	pop	r17
    7e6e:	0f 91       	pop	r16
    7e70:	ff 90       	pop	r15
    7e72:	ef 90       	pop	r14
    7e74:	df 90       	pop	r13
    7e76:	cf 90       	pop	r12
    7e78:	bf 90       	pop	r11
    7e7a:	af 90       	pop	r10
    7e7c:	9f 90       	pop	r9
    7e7e:	8f 90       	pop	r8
    7e80:	08 95       	ret

00007e82 <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>:


void AHRS::orthonormalizeDcm() 
{
    7e82:	6f 92       	push	r6
    7e84:	7f 92       	push	r7
    7e86:	8f 92       	push	r8
    7e88:	9f 92       	push	r9
    7e8a:	af 92       	push	r10
    7e8c:	bf 92       	push	r11
    7e8e:	cf 92       	push	r12
    7e90:	df 92       	push	r13
    7e92:	ef 92       	push	r14
    7e94:	ff 92       	push	r15
    7e96:	0f 93       	push	r16
    7e98:	1f 93       	push	r17
    7e9a:	cf 93       	push	r28
    7e9c:	df 93       	push	r29
    7e9e:	5c 01       	movw	r10, r24
	/**
	 * The dot product of two orthonormal vectors should be 0 (because cos(90) = 0). So this
	 * gives us an error of how far from orthonormal the vectors are. It's a measure
	 * of how much X and Y are rotated towards each other. 
	 */
	float error = MatrixUtil::DotProduct(dcm[0], dcm[1]);
    7ea0:	ec 01       	movw	r28, r24
    7ea2:	c4 5b       	subi	r28, 0xB4	; 180
    7ea4:	df 4f       	sbci	r29, 0xFF	; 255
    7ea6:	6c 01       	movw	r12, r24
    7ea8:	80 e4       	ldi	r24, 0x40	; 64
    7eaa:	c8 0e       	add	r12, r24
    7eac:	d1 1c       	adc	r13, r1
    7eae:	be 01       	movw	r22, r28
    7eb0:	c6 01       	movw	r24, r12
    7eb2:	0e 94 9f 69 	call	0xd33e	; 0xd33e <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>
	
	/**
	 * Scale and adjust the two vectors involved in calculating the error to bring them 
	 * 'closer' to each other (more orthonormal)
	 */
	scaleAndAdjust(dcm[0], dcm[1], (error/2), dcm[0]);
    7eb6:	20 e0       	ldi	r18, 0x00	; 0
    7eb8:	30 e0       	ldi	r19, 0x00	; 0
    7eba:	40 e0       	ldi	r20, 0x00	; 0
    7ebc:	5f e3       	ldi	r21, 0x3F	; 63
    7ebe:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    7ec2:	66 2e       	mov	r6, r22
    7ec4:	77 2e       	mov	r7, r23
    7ec6:	88 2e       	mov	r8, r24
    7ec8:	99 2e       	mov	r9, r25
    7eca:	76 01       	movw	r14, r12
    7ecc:	98 2f       	mov	r25, r24
    7ece:	06 2d       	mov	r16, r6
    7ed0:	17 2d       	mov	r17, r7
    7ed2:	29 2f       	mov	r18, r25
    7ed4:	39 2d       	mov	r19, r9
    7ed6:	ae 01       	movw	r20, r28
    7ed8:	b6 01       	movw	r22, r12
    7eda:	c5 01       	movw	r24, r10
    7edc:	0e 94 e2 3e 	call	0x7dc4	; 0x7dc4 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	scaleAndAdjust(dcm[1], dcm[0], (error/2), dcm[1]);
    7ee0:	7e 01       	movw	r14, r28
    7ee2:	28 2d       	mov	r18, r8
    7ee4:	39 2d       	mov	r19, r9
    7ee6:	a6 01       	movw	r20, r12
    7ee8:	be 01       	movw	r22, r28
    7eea:	c5 01       	movw	r24, r10
    7eec:	0e 94 e2 3e 	call	0x7dc4	; 0x7dc4 <_ZN10helicopter10navigation4AHRS14scaleAndAdjustEPfS2_fRA3_f>
	
	//The remaining vector will become the cross product of the other two vectors
	MatrixUtil::CrossProduct(dcm[0], dcm[1], dcm[2]);
    7ef0:	88 e5       	ldi	r24, 0x58	; 88
    7ef2:	a8 0e       	add	r10, r24
    7ef4:	b1 1c       	adc	r11, r1
    7ef6:	a5 01       	movw	r20, r10
    7ef8:	be 01       	movw	r22, r28
    7efa:	c6 01       	movw	r24, r12
    7efc:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	
	//Normalize the matrix to ensure that the vector's magnitudes = 1
	MatrixUtil::Normalize(dcm[0]);
    7f00:	c6 01       	movw	r24, r12
    7f02:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[1]);
    7f06:	ce 01       	movw	r24, r28
    7f08:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(dcm[2]);
    7f0c:	c5 01       	movw	r24, r10
    7f0e:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
}
    7f12:	df 91       	pop	r29
    7f14:	cf 91       	pop	r28
    7f16:	1f 91       	pop	r17
    7f18:	0f 91       	pop	r16
    7f1a:	ff 90       	pop	r15
    7f1c:	ef 90       	pop	r14
    7f1e:	df 90       	pop	r13
    7f20:	cf 90       	pop	r12
    7f22:	bf 90       	pop	r11
    7f24:	af 90       	pop	r10
    7f26:	9f 90       	pop	r9
    7f28:	8f 90       	pop	r8
    7f2a:	7f 90       	pop	r7
    7f2c:	6f 90       	pop	r6
    7f2e:	08 95       	ret

00007f30 <_ZN10helicopter10navigation4AHRS6updateEfffffffff>:


void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
	float frdGyroXRs, float frdGyroYRs, float frdGyroZRs,
	float frdMagX, float frdMagY, float frdMagZ)
{
    7f30:	2f 92       	push	r2
    7f32:	3f 92       	push	r3
    7f34:	4f 92       	push	r4
    7f36:	5f 92       	push	r5
    7f38:	6f 92       	push	r6
    7f3a:	7f 92       	push	r7
    7f3c:	8f 92       	push	r8
    7f3e:	9f 92       	push	r9
    7f40:	af 92       	push	r10
    7f42:	bf 92       	push	r11
    7f44:	cf 92       	push	r12
    7f46:	df 92       	push	r13
    7f48:	ef 92       	push	r14
    7f4a:	ff 92       	push	r15
    7f4c:	0f 93       	push	r16
    7f4e:	1f 93       	push	r17
    7f50:	cf 93       	push	r28
    7f52:	df 93       	push	r29
    7f54:	cd b7       	in	r28, 0x3d	; 61
    7f56:	de b7       	in	r29, 0x3e	; 62
    7f58:	ce 57       	subi	r28, 0x7E	; 126
    7f5a:	d1 09       	sbc	r29, r1
    7f5c:	0f b6       	in	r0, 0x3f	; 63
    7f5e:	f8 94       	cli
    7f60:	de bf       	out	0x3e, r29	; 62
    7f62:	0f be       	out	0x3f, r0	; 63
    7f64:	cd bf       	out	0x3d, r28	; 61
    7f66:	2c 01       	movw	r4, r24
    7f68:	e1 96       	adiw	r28, 0x31	; 49
    7f6a:	8c ae       	std	Y+60, r8	; 0x3c
    7f6c:	9d ae       	std	Y+61, r9	; 0x3d
    7f6e:	ae ae       	std	Y+62, r10	; 0x3e
    7f70:	bf ae       	std	Y+63, r11	; 0x3f
    7f72:	e1 97       	sbiw	r28, 0x31	; 49
	float accelerometerVector[3] = {frdAccXMss, frdAccYMss, frdAccZMss};
    7f74:	a5 96       	adiw	r28, 0x25	; 37
    7f76:	4c af       	std	Y+60, r20	; 0x3c
    7f78:	5d af       	std	Y+61, r21	; 0x3d
    7f7a:	6e af       	std	Y+62, r22	; 0x3e
    7f7c:	7f af       	std	Y+63, r23	; 0x3f
    7f7e:	a5 97       	sbiw	r28, 0x25	; 37
    7f80:	a9 96       	adiw	r28, 0x29	; 41
    7f82:	0c af       	std	Y+60, r16	; 0x3c
    7f84:	1d af       	std	Y+61, r17	; 0x3d
    7f86:	2e af       	std	Y+62, r18	; 0x3e
    7f88:	3f af       	std	Y+63, r19	; 0x3f
    7f8a:	a9 97       	sbiw	r28, 0x29	; 41
    7f8c:	ad 96       	adiw	r28, 0x2d	; 45
    7f8e:	cc ae       	std	Y+60, r12	; 0x3c
    7f90:	dd ae       	std	Y+61, r13	; 0x3d
    7f92:	ee ae       	std	Y+62, r14	; 0x3e
    7f94:	ff ae       	std	Y+63, r15	; 0x3f
    7f96:	ad 97       	sbiw	r28, 0x2d	; 45
	float magnetometerVector[3] = {frdMagX, frdMagY, frdMagZ};
    7f98:	c4 56       	subi	r28, 0x64	; 100
    7f9a:	df 4f       	sbci	r29, 0xFF	; 255
    7f9c:	88 81       	ld	r24, Y
    7f9e:	99 81       	ldd	r25, Y+1	; 0x01
    7fa0:	aa 81       	ldd	r26, Y+2	; 0x02
    7fa2:	bb 81       	ldd	r27, Y+3	; 0x03
    7fa4:	cc 59       	subi	r28, 0x9C	; 156
    7fa6:	d0 40       	sbci	r29, 0x00	; 0
    7fa8:	69 96       	adiw	r28, 0x19	; 25
    7faa:	8c af       	std	Y+60, r24	; 0x3c
    7fac:	9d af       	std	Y+61, r25	; 0x3d
    7fae:	ae af       	std	Y+62, r26	; 0x3e
    7fb0:	bf af       	std	Y+63, r27	; 0x3f
    7fb2:	69 97       	sbiw	r28, 0x19	; 25
    7fb4:	c0 56       	subi	r28, 0x60	; 96
    7fb6:	df 4f       	sbci	r29, 0xFF	; 255
    7fb8:	88 81       	ld	r24, Y
    7fba:	99 81       	ldd	r25, Y+1	; 0x01
    7fbc:	aa 81       	ldd	r26, Y+2	; 0x02
    7fbe:	bb 81       	ldd	r27, Y+3	; 0x03
    7fc0:	c0 5a       	subi	r28, 0xA0	; 160
    7fc2:	d0 40       	sbci	r29, 0x00	; 0
    7fc4:	6d 96       	adiw	r28, 0x1d	; 29
    7fc6:	8c af       	std	Y+60, r24	; 0x3c
    7fc8:	9d af       	std	Y+61, r25	; 0x3d
    7fca:	ae af       	std	Y+62, r26	; 0x3e
    7fcc:	bf af       	std	Y+63, r27	; 0x3f
    7fce:	6d 97       	sbiw	r28, 0x1d	; 29
    7fd0:	cc 55       	subi	r28, 0x5C	; 92
    7fd2:	df 4f       	sbci	r29, 0xFF	; 255
    7fd4:	88 81       	ld	r24, Y
    7fd6:	99 81       	ldd	r25, Y+1	; 0x01
    7fd8:	aa 81       	ldd	r26, Y+2	; 0x02
    7fda:	bb 81       	ldd	r27, Y+3	; 0x03
    7fdc:	c4 5a       	subi	r28, 0xA4	; 164
    7fde:	d0 40       	sbci	r29, 0x00	; 0
    7fe0:	a1 96       	adiw	r28, 0x21	; 33
    7fe2:	8c af       	std	Y+60, r24	; 0x3c
    7fe4:	9d af       	std	Y+61, r25	; 0x3d
    7fe6:	ae af       	std	Y+62, r26	; 0x3e
    7fe8:	bf af       	std	Y+63, r27	; 0x3f
    7fea:	a1 97       	sbiw	r28, 0x21	; 33
		
	float accelerometerAngularDisplacement[3] = {0};
    7fec:	7e 01       	movw	r14, r28
    7fee:	89 e4       	ldi	r24, 0x49	; 73
    7ff0:	e8 0e       	add	r14, r24
    7ff2:	f1 1c       	adc	r15, r1
    7ff4:	0f 2e       	mov	r0, r31
    7ff6:	fc e0       	ldi	r31, 0x0C	; 12
    7ff8:	df 2e       	mov	r13, r31
    7ffa:	f0 2d       	mov	r31, r0
    7ffc:	d7 01       	movw	r26, r14
    7ffe:	ed 2d       	mov	r30, r13
    8000:	1d 92       	st	X+, r1
    8002:	ea 95       	dec	r30
    8004:	e9 f7       	brne	.-6      	; 0x8000 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xd0>
	float magnetometerAngularDisplacement[3] = {0};
    8006:	5e 01       	movw	r10, r28
    8008:	fd e3       	ldi	r31, 0x3D	; 61
    800a:	af 0e       	add	r10, r31
    800c:	b1 1c       	adc	r11, r1
    800e:	d5 01       	movw	r26, r10
    8010:	ed 2d       	mov	r30, r13
    8012:	1d 92       	st	X+, r1
    8014:	ea 95       	dec	r30
    8016:	e9 f7       	brne	.-6      	; 0x8012 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0xe2>
		
	//Scale the gyro value by the time interval to get the angle in rads.
	float gyroscopeAngularDisplacement[3] = { frdGyroXRs * gyroTimeInterval, 
												frdGyroYRs * gyroTimeInterval, 
												frdGyroZRs * gyroTimeInterval};	
    8018:	d2 01       	movw	r26, r4
    801a:	6d 90       	ld	r6, X+
    801c:	7d 90       	ld	r7, X+
    801e:	8d 90       	ld	r8, X+
    8020:	9c 90       	ld	r9, X
    8022:	e1 96       	adiw	r28, 0x31	; 49
    8024:	2c ad       	ldd	r18, Y+60	; 0x3c
    8026:	3d ad       	ldd	r19, Y+61	; 0x3d
    8028:	4e ad       	ldd	r20, Y+62	; 0x3e
    802a:	5f ad       	ldd	r21, Y+63	; 0x3f
    802c:	e1 97       	sbiw	r28, 0x31	; 49
    802e:	c4 01       	movw	r24, r8
    8030:	b3 01       	movw	r22, r6
    8032:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    8036:	69 ab       	std	Y+49, r22	; 0x31
    8038:	7a ab       	std	Y+50, r23	; 0x32
    803a:	8b ab       	std	Y+51, r24	; 0x33
    803c:	9c ab       	std	Y+52, r25	; 0x34
    803e:	cc 56       	subi	r28, 0x6C	; 108
    8040:	df 4f       	sbci	r29, 0xFF	; 255
    8042:	28 81       	ld	r18, Y
    8044:	39 81       	ldd	r19, Y+1	; 0x01
    8046:	4a 81       	ldd	r20, Y+2	; 0x02
    8048:	5b 81       	ldd	r21, Y+3	; 0x03
    804a:	c4 59       	subi	r28, 0x94	; 148
    804c:	d0 40       	sbci	r29, 0x00	; 0
    804e:	c4 01       	movw	r24, r8
    8050:	b3 01       	movw	r22, r6
    8052:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    8056:	6d ab       	std	Y+53, r22	; 0x35
    8058:	7e ab       	std	Y+54, r23	; 0x36
    805a:	8f ab       	std	Y+55, r24	; 0x37
    805c:	98 af       	std	Y+56, r25	; 0x38
    805e:	c8 56       	subi	r28, 0x68	; 104
    8060:	df 4f       	sbci	r29, 0xFF	; 255
    8062:	28 81       	ld	r18, Y
    8064:	39 81       	ldd	r19, Y+1	; 0x01
    8066:	4a 81       	ldd	r20, Y+2	; 0x02
    8068:	5b 81       	ldd	r21, Y+3	; 0x03
    806a:	c8 59       	subi	r28, 0x98	; 152
    806c:	d0 40       	sbci	r29, 0x00	; 0
    806e:	c4 01       	movw	r24, r8
    8070:	b3 01       	movw	r22, r6
    8072:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    8076:	69 af       	std	Y+57, r22	; 0x39
    8078:	7a af       	std	Y+58, r23	; 0x3a
    807a:	8b af       	std	Y+59, r24	; 0x3b
    807c:	9c af       	std	Y+60, r25	; 0x3c
												
	float angularDisplacementWeightedAverage [3] = {0};	
    807e:	3e 01       	movw	r6, r28
    8080:	b5 e2       	ldi	r27, 0x25	; 37
    8082:	6b 0e       	add	r6, r27
    8084:	71 1c       	adc	r7, r1
    8086:	f3 01       	movw	r30, r6
    8088:	8d 2d       	mov	r24, r13
    808a:	11 92       	st	Z+, r1
    808c:	8a 95       	dec	r24
    808e:	e9 f7       	brne	.-6      	; 0x808a <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x15a>
		
	float changeInVector [3] = {0};
    8090:	fe 01       	movw	r30, r28
    8092:	79 96       	adiw	r30, 0x19	; 25
    8094:	df 01       	movw	r26, r30
    8096:	8d 2d       	mov	r24, r13
    8098:	1d 92       	st	X+, r1
    809a:	8a 95       	dec	r24
    809c:	e9 f7       	brne	.-6      	; 0x8098 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x168>
		 
	//Normalize the accelerometer and magnetometer data so that their magnitudes = 1. The DCM matrix
	//is based on unit vectors (vectors with a magnitude of one)
	MatrixUtil::Normalize(accelerometerVector);
    809e:	ce 01       	movw	r24, r28
    80a0:	8f 59       	subi	r24, 0x9F	; 159
    80a2:	9f 4f       	sbci	r25, 0xFF	; 255
    80a4:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	MatrixUtil::Normalize(magnetometerVector);
    80a8:	ce 01       	movw	r24, r28
    80aa:	8b 5a       	subi	r24, 0xAB	; 171
    80ac:	9f 4f       	sbci	r25, 0xFF	; 255
    80ae:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	 * west vector, and the accelerometer vector to get a 'north facing' vector which is the corrected
	 * magnetometer vector.
	 *
	 * Taken from Starlino's January 20, 2012 post at http://www.starlino.com/dcm_tutorial.html 
	 */
	float westFacingVector[3] = {0};//since the acceleration vector is pointing down, this is actually an east facing vector in our case. it's actually facing out the right side of the ship. 
    80b2:	4e 01       	movw	r8, r28
    80b4:	9d e0       	ldi	r25, 0x0D	; 13
    80b6:	89 0e       	add	r8, r25
    80b8:	91 1c       	adc	r9, r1
    80ba:	d4 01       	movw	r26, r8
    80bc:	ed 2d       	mov	r30, r13
    80be:	1d 92       	st	X+, r1
    80c0:	ea 95       	dec	r30
    80c2:	e9 f7       	brne	.-6      	; 0x80be <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x18e>
	float correctedMagnetometerVector[3] = {0};
    80c4:	8e 01       	movw	r16, r28
    80c6:	0f 5f       	subi	r16, 0xFF	; 255
    80c8:	1f 4f       	sbci	r17, 0xFF	; 255
    80ca:	d8 01       	movw	r26, r16
    80cc:	1d 92       	st	X+, r1
    80ce:	da 94       	dec	r13
    80d0:	e9 f7       	brne	.-6      	; 0x80cc <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x19c>
	* I also ran into the issue where the accel was vibrating so heavily that the y and z values were maxed out
	* this caused a gravity vector that pointed 45* down and west, this caused the heading value to
	* slowly start rotating. But if I had used the mag and accel values, it would have immediately given
	* erroneous results and would have started to rotate immediately.
	*/
	MatrixUtil::CrossProduct(dcm[2], magnetometerVector, westFacingVector);	
    80d2:	62 01       	movw	r12, r4
    80d4:	b8 e5       	ldi	r27, 0x58	; 88
    80d6:	cb 0e       	add	r12, r27
    80d8:	d1 1c       	adc	r13, r1
    80da:	a4 01       	movw	r20, r8
    80dc:	be 01       	movw	r22, r28
    80de:	6b 5a       	subi	r22, 0xAB	; 171
    80e0:	7f 4f       	sbci	r23, 0xFF	; 255
    80e2:	c6 01       	movw	r24, r12
    80e4:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(westFacingVector, dcm[2], correctedMagnetometerVector);
    80e8:	a8 01       	movw	r20, r16
    80ea:	b6 01       	movw	r22, r12
    80ec:	c4 01       	movw	r24, r8
    80ee:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	//Doing it this way prevents a 'gyro' effect where if you pitch up, it causes the gyro to affect the yaw, and then it 'stabilizes' back to normal value
	//This way prevents that. if you took the DCM value and cross proded that with the mag value, you would get the gyro affect. 
	/*MatrixUtil::CrossProduct(accelerometerVector, magnetometerVector, westFacingVector);
	MatrixUtil::CrossProduct(westFacingVector, accelerometerVector, correctedMagnetometerVector);	*/
	
	MatrixUtil::Normalize(correctedMagnetometerVector);
    80f2:	c8 01       	movw	r24, r16
    80f4:	0e 94 81 66 	call	0xcd02	; 0xcd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>
	//This gives the angular displacement that the helicopter has moved since the last
	//iteration.
	//d?a = dt wa = KB0 x (KB1A - KB0) - see http://www.starlino.com/dcm_tutorial.html for proof		
	/*MatrixUtil::CrossProduct(accelerometerVector, dcm[2], accelerometerAngularDisplacement);
	MatrixUtil::CrossProduct(correctedMagnetometerVector, dcm[0], magnetometerAngularDisplacement);*/
	MatrixUtil::CrossProduct(dcm[2], accelerometerVector, accelerometerAngularDisplacement);
    80f8:	a7 01       	movw	r20, r14
    80fa:	be 01       	movw	r22, r28
    80fc:	6f 59       	subi	r22, 0x9F	; 159
    80fe:	7f 4f       	sbci	r23, 0xFF	; 255
    8100:	c6 01       	movw	r24, r12
    8102:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
	MatrixUtil::CrossProduct(dcm[0], correctedMagnetometerVector, magnetometerAngularDisplacement);
    8106:	a5 01       	movw	r20, r10
    8108:	b8 01       	movw	r22, r16
    810a:	c2 01       	movw	r24, r4
    810c:	80 5c       	subi	r24, 0xC0	; 192
    810e:	9f 4f       	sbci	r25, 0xFF	; 255
    8110:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    8114:	80 91 0a 02 	lds	r24, 0x020A
    8118:	90 91 0b 02 	lds	r25, 0x020B
    811c:	a0 91 0c 02 	lds	r26, 0x020C
    8120:	b0 91 0d 02 	lds	r27, 0x020D
    8124:	e5 96       	adiw	r28, 0x35	; 53
    8126:	8c af       	std	Y+60, r24	; 0x3c
    8128:	9d af       	std	Y+61, r25	; 0x3d
    812a:	ae af       	std	Y+62, r26	; 0x3e
    812c:	bf af       	std	Y+63, r27	; 0x3f
    812e:	e5 97       	sbiw	r28, 0x35	; 53
    8130:	80 91 06 02 	lds	r24, 0x0206
    8134:	90 91 07 02 	lds	r25, 0x0207
    8138:	a0 91 08 02 	lds	r26, 0x0208
    813c:	b0 91 09 02 	lds	r27, 0x0209
    8140:	e9 96       	adiw	r28, 0x39	; 57
    8142:	8c af       	std	Y+60, r24	; 0x3c
    8144:	9d af       	std	Y+61, r25	; 0x3d
    8146:	ae af       	std	Y+62, r26	; 0x3e
    8148:	bf af       	std	Y+63, r27	; 0x3f
    814a:	e9 97       	sbiw	r28, 0x39	; 57
    814c:	20 e0       	ldi	r18, 0x00	; 0
    814e:	30 e0       	ldi	r19, 0x00	; 0
    8150:	40 e8       	ldi	r20, 0x80	; 128
    8152:	5f e3       	ldi	r21, 0x3F	; 63
    8154:	e5 96       	adiw	r28, 0x35	; 53
    8156:	6c ad       	ldd	r22, Y+60	; 0x3c
    8158:	7d ad       	ldd	r23, Y+61	; 0x3d
    815a:	8e ad       	ldd	r24, Y+62	; 0x3e
    815c:	9f ad       	ldd	r25, Y+63	; 0x3f
    815e:	e5 97       	sbiw	r28, 0x35	; 53
    8160:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    8164:	9b 01       	movw	r18, r22
    8166:	ac 01       	movw	r20, r24
    8168:	e9 96       	adiw	r28, 0x39	; 57
    816a:	6c ad       	ldd	r22, Y+60	; 0x3c
    816c:	7d ad       	ldd	r23, Y+61	; 0x3d
    816e:	8e ad       	ldd	r24, Y+62	; 0x3e
    8170:	9f ad       	ldd	r25, Y+63	; 0x3f
    8172:	e9 97       	sbiw	r28, 0x39	; 57
    8174:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    8178:	ec 96       	adiw	r28, 0x3c	; 60
    817a:	6f af       	std	Y+63, r22	; 0x3f
    817c:	ec 97       	sbiw	r28, 0x3c	; 60
    817e:	ed 96       	adiw	r28, 0x3d	; 61
    8180:	7f af       	std	Y+63, r23	; 0x3f
    8182:	ed 97       	sbiw	r28, 0x3d	; 61
    8184:	38 2e       	mov	r3, r24
    8186:	29 2e       	mov	r2, r25
    8188:	87 01       	movw	r16, r14
    818a:	6e 01       	movw	r12, r28
    818c:	91 e3       	ldi	r25, 0x31	; 49
    818e:	c9 0e       	add	r12, r25
    8190:	d1 1c       	adc	r13, r1
    8192:	af 96       	adiw	r28, 0x2f	; 47
    8194:	bf ae       	std	Y+63, r11	; 0x3f
    8196:	ae ae       	std	Y+62, r10	; 0x3e
    8198:	af 97       	sbiw	r28, 0x2f	; 47
	return angle;
}



void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
    819a:	d7 01       	movw	r26, r14
    819c:	1c 96       	adiw	r26, 0x0c	; 12
    819e:	eb 96       	adiw	r28, 0x3b	; 59
    81a0:	bf af       	std	Y+63, r27	; 0x3f
    81a2:	ae af       	std	Y+62, r26	; 0x3e
    81a4:	eb 97       	sbiw	r28, 0x3b	; 59
    81a6:	ef 96       	adiw	r28, 0x3f	; 63
    81a8:	5f ae       	std	Y+63, r5	; 0x3f
    81aa:	4e ae       	std	Y+62, r4	; 0x3e
    81ac:	ef 97       	sbiw	r28, 0x3f	; 63
    81ae:	26 01       	movw	r4, r12
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
    81b0:	f8 01       	movw	r30, r16
    81b2:	61 91       	ld	r22, Z+
    81b4:	71 91       	ld	r23, Z+
    81b6:	81 91       	ld	r24, Z+
    81b8:	91 91       	ld	r25, Z+
    81ba:	8f 01       	movw	r16, r30
		/**
		 * Note: The gyroscope angular measurement is * -1 because a clockwise rotation about X is a positive change for the gyroscope
		 * but for the accelerometer, a clockwise rotation about X results in a negative change, so we gyroData*-1 to bring the motions
		 * into alignment
		 */
		angularDisplacementWeightedAverage[i] = (-gyroscopeAngularDisplacement[i] + 
    81bc:	d2 01       	movw	r26, r4
    81be:	cd 90       	ld	r12, X+
    81c0:	dd 90       	ld	r13, X+
    81c2:	ed 90       	ld	r14, X+
    81c4:	fd 90       	ld	r15, X+
    81c6:	2d 01       	movw	r4, r26
												accelerometerAngularDisplacement[i] * ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + 
												magnetometerAngularDisplacement[i] * MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT) /
    81c8:	af 96       	adiw	r28, 0x2f	; 47
    81ca:	ee ad       	ldd	r30, Y+62	; 0x3e
    81cc:	ff ad       	ldd	r31, Y+63	; 0x3f
    81ce:	af 97       	sbiw	r28, 0x2f	; 47
    81d0:	81 90       	ld	r8, Z+
    81d2:	91 90       	ld	r9, Z+
    81d4:	a1 90       	ld	r10, Z+
    81d6:	b1 90       	ld	r11, Z+
    81d8:	af 96       	adiw	r28, 0x2f	; 47
    81da:	ff af       	std	Y+63, r31	; 0x3f
    81dc:	ee af       	std	Y+62, r30	; 0x3e
    81de:	af 97       	sbiw	r28, 0x2f	; 47
												(1.0f + ACCELEROMETER_ANGULARDISPLACEMENT_WEIGHT + MAGNETOMETER_ANGULARDISPLACEMENT_WEIGHT);
    81e0:	e5 96       	adiw	r28, 0x35	; 53
    81e2:	2c ad       	ldd	r18, Y+60	; 0x3c
    81e4:	3d ad       	ldd	r19, Y+61	; 0x3d
    81e6:	4e ad       	ldd	r20, Y+62	; 0x3e
    81e8:	5f ad       	ldd	r21, Y+63	; 0x3f
    81ea:	e5 97       	sbiw	r28, 0x35	; 53
    81ec:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    81f0:	a7 01       	movw	r20, r14
    81f2:	96 01       	movw	r18, r12
    81f4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    81f8:	6b 01       	movw	r12, r22
    81fa:	7c 01       	movw	r14, r24
    81fc:	e9 96       	adiw	r28, 0x39	; 57
    81fe:	2c ad       	ldd	r18, Y+60	; 0x3c
    8200:	3d ad       	ldd	r19, Y+61	; 0x3d
    8202:	4e ad       	ldd	r20, Y+62	; 0x3e
    8204:	5f ad       	ldd	r21, Y+63	; 0x3f
    8206:	e9 97       	sbiw	r28, 0x39	; 57
    8208:	c5 01       	movw	r24, r10
    820a:	b4 01       	movw	r22, r8
    820c:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    8210:	9b 01       	movw	r18, r22
    8212:	ac 01       	movw	r20, r24
    8214:	c7 01       	movw	r24, r14
    8216:	b6 01       	movw	r22, r12
    8218:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    821c:	ec 96       	adiw	r28, 0x3c	; 60
    821e:	bf ad       	ldd	r27, Y+63	; 0x3f
    8220:	ec 97       	sbiw	r28, 0x3c	; 60
    8222:	ed 96       	adiw	r28, 0x3d	; 61
    8224:	af ad       	ldd	r26, Y+63	; 0x3f
    8226:	ed 97       	sbiw	r28, 0x3d	; 61
    8228:	2b 2f       	mov	r18, r27
    822a:	3a 2f       	mov	r19, r26
    822c:	43 2d       	mov	r20, r3
    822e:	52 2d       	mov	r21, r2
    8230:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    8234:	d3 01       	movw	r26, r6
    8236:	6d 93       	st	X+, r22
    8238:	7d 93       	st	X+, r23
    823a:	8d 93       	st	X+, r24
    823c:	9d 93       	st	X+, r25
    823e:	3d 01       	movw	r6, r26
	debug2 = accelerometerVector[1];
	debug3 = accelerometerVector[2];
	*/
	//Calculate the weighted average of the angular displacements to obtain the correction vector
	//to adjust the DCM.
	for (int i = 0; i < 3; i++)
    8240:	eb 96       	adiw	r28, 0x3b	; 59
    8242:	ee ad       	ldd	r30, Y+62	; 0x3e
    8244:	ff ad       	ldd	r31, Y+63	; 0x3f
    8246:	eb 97       	sbiw	r28, 0x3b	; 59
    8248:	0e 17       	cp	r16, r30
    824a:	1f 07       	cpc	r17, r31
    824c:	09 f0       	breq	.+2      	; 0x8250 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x320>
    824e:	b0 cf       	rjmp	.-160    	; 0x81b0 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x280>
    8250:	ef 96       	adiw	r28, 0x3f	; 63
    8252:	4e ac       	ldd	r4, Y+62	; 0x3e
    8254:	5f ac       	ldd	r5, Y+63	; 0x3f
    8256:	ef 97       	sbiw	r28, 0x3f	; 63
	return angle;
}



void AHRS::update(float frdAccXMss, float frdAccYMss, float frdAccZMss,
    8258:	82 01       	movw	r16, r4
    825a:	00 5c       	subi	r16, 0xC0	; 192
    825c:	1f 4f       	sbci	r17, 0xFF	; 255
    825e:	e1 2c       	mov	r14, r1
    8260:	f1 2c       	mov	r15, r1
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
	{
		MatrixUtil::CrossProduct(angularDisplacementWeightedAverage, dcm[i], changeInVector);
    8262:	b7 01       	movw	r22, r14
    8264:	66 0f       	add	r22, r22
    8266:	77 1f       	adc	r23, r23
    8268:	6e 0d       	add	r22, r14
    826a:	7f 1d       	adc	r23, r15
    826c:	66 0f       	add	r22, r22
    826e:	77 1f       	adc	r23, r23
    8270:	66 0f       	add	r22, r22
    8272:	77 1f       	adc	r23, r23
    8274:	60 5c       	subi	r22, 0xC0	; 192
    8276:	7f 4f       	sbci	r23, 0xFF	; 255
    8278:	64 0d       	add	r22, r4
    827a:	75 1d       	adc	r23, r5
    827c:	ae 01       	movw	r20, r28
    827e:	47 5e       	subi	r20, 0xE7	; 231
    8280:	5f 4f       	sbci	r21, 0xFF	; 255
    8282:	ce 01       	movw	r24, r28
    8284:	85 96       	adiw	r24, 0x25	; 37
    8286:	0e 94 00 66 	call	0xcc00	; 0xcc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>
		
		dcm[i][0] += changeInVector[0];
    828a:	29 8d       	ldd	r18, Y+25	; 0x19
    828c:	3a 8d       	ldd	r19, Y+26	; 0x1a
    828e:	4b 8d       	ldd	r20, Y+27	; 0x1b
    8290:	5c 8d       	ldd	r21, Y+28	; 0x1c
    8292:	d8 01       	movw	r26, r16
    8294:	6d 91       	ld	r22, X+
    8296:	7d 91       	ld	r23, X+
    8298:	8d 91       	ld	r24, X+
    829a:	9c 91       	ld	r25, X
    829c:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    82a0:	f8 01       	movw	r30, r16
    82a2:	60 83       	st	Z, r22
    82a4:	71 83       	std	Z+1, r23	; 0x01
    82a6:	82 83       	std	Z+2, r24	; 0x02
    82a8:	93 83       	std	Z+3, r25	; 0x03
		dcm[i][1] += changeInVector[1];
    82aa:	2d 8d       	ldd	r18, Y+29	; 0x1d
    82ac:	3e 8d       	ldd	r19, Y+30	; 0x1e
    82ae:	4f 8d       	ldd	r20, Y+31	; 0x1f
    82b0:	58 a1       	ldd	r21, Y+32	; 0x20
    82b2:	64 81       	ldd	r22, Z+4	; 0x04
    82b4:	75 81       	ldd	r23, Z+5	; 0x05
    82b6:	86 81       	ldd	r24, Z+6	; 0x06
    82b8:	97 81       	ldd	r25, Z+7	; 0x07
    82ba:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    82be:	d8 01       	movw	r26, r16
    82c0:	14 96       	adiw	r26, 0x04	; 4
    82c2:	6d 93       	st	X+, r22
    82c4:	7d 93       	st	X+, r23
    82c6:	8d 93       	st	X+, r24
    82c8:	9c 93       	st	X, r25
    82ca:	17 97       	sbiw	r26, 0x07	; 7
		dcm[i][2] += changeInVector[2];
    82cc:	29 a1       	ldd	r18, Y+33	; 0x21
    82ce:	3a a1       	ldd	r19, Y+34	; 0x22
    82d0:	4b a1       	ldd	r20, Y+35	; 0x23
    82d2:	5c a1       	ldd	r21, Y+36	; 0x24
    82d4:	18 96       	adiw	r26, 0x08	; 8
    82d6:	6d 91       	ld	r22, X+
    82d8:	7d 91       	ld	r23, X+
    82da:	8d 91       	ld	r24, X+
    82dc:	9c 91       	ld	r25, X
    82de:	1b 97       	sbiw	r26, 0x0b	; 11
    82e0:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    82e4:	f8 01       	movw	r30, r16
    82e6:	60 87       	std	Z+8, r22	; 0x08
    82e8:	71 87       	std	Z+9, r23	; 0x09
    82ea:	82 87       	std	Z+10, r24	; 0x0a
    82ec:	93 87       	std	Z+11, r25	; 0x0b
	/**
	 * Adjust the dcm matrix by the calculated angular displacement. We adjust the DCM matrix by the averaged
	 * angle displacement of the three sensors because this reduces noise caused by any one sensor, and 
	 * reduces the effect of non-gravitational acceleration (linear acceleration) from the accelerometer.
	 */
	for (int i = 0; i < 3; i++)
    82ee:	ff ef       	ldi	r31, 0xFF	; 255
    82f0:	ef 1a       	sub	r14, r31
    82f2:	ff 0a       	sbc	r15, r31
    82f4:	04 5f       	subi	r16, 0xF4	; 244
    82f6:	1f 4f       	sbci	r17, 0xFF	; 255
    82f8:	83 e0       	ldi	r24, 0x03	; 3
    82fa:	e8 16       	cp	r14, r24
    82fc:	f1 04       	cpc	r15, r1
    82fe:	09 f0       	breq	.+2      	; 0x8302 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x3d2>
    8300:	b0 cf       	rjmp	.-160    	; 0x8262 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x332>
	}
	
	
	
	//Adjust the matrix to make it closer to orthonormal.
	orthonormalizeDcm();
    8302:	c2 01       	movw	r24, r4
    8304:	0e 94 41 3f 	call	0x7e82	; 0x7e82 <_ZN10helicopter10navigation4AHRS17orthonormalizeDcmEv>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    8308:	f2 01       	movw	r30, r4
    830a:	e0 5c       	subi	r30, 0xC0	; 192
    830c:	ff 4f       	sbci	r31, 0xFF	; 255
    830e:	20 81       	ld	r18, Z
    8310:	31 81       	ldd	r19, Z+1	; 0x01
    8312:	42 81       	ldd	r20, Z+2	; 0x02
    8314:	53 81       	ldd	r21, Z+3	; 0x03
    8316:	f2 01       	movw	r30, r4
    8318:	e4 5b       	subi	r30, 0xB4	; 180
    831a:	ff 4f       	sbci	r31, 0xFF	; 255
    831c:	60 81       	ld	r22, Z
    831e:	71 81       	ldd	r23, Z+1	; 0x01
    8320:	82 81       	ldd	r24, Z+2	; 0x02
    8322:	93 81       	ldd	r25, Z+3	; 0x03
    8324:	0e 94 f5 6a 	call	0xd5ea	; 0xd5ea <atan2>
    8328:	6b 01       	movw	r12, r22
    832a:	7c 01       	movw	r14, r24
	if (yawRads < 0)
    832c:	20 e0       	ldi	r18, 0x00	; 0
    832e:	30 e0       	ldi	r19, 0x00	; 0
    8330:	a9 01       	movw	r20, r18
    8332:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    8336:	88 23       	and	r24, r24
    8338:	44 f0       	brlt	.+16     	; 0x834a <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x41a>
	
	
	
	//commented out due to speed. 
	
	yawRads = atan2(dcm[1][0], dcm[0][0]);
    833a:	d2 01       	movw	r26, r4
    833c:	98 96       	adiw	r26, 0x28	; 40
    833e:	cd 92       	st	X+, r12
    8340:	dd 92       	st	X+, r13
    8342:	ed 92       	st	X+, r14
    8344:	fc 92       	st	X, r15
    8346:	9b 97       	sbiw	r26, 0x2b	; 43
    8348:	0d c0       	rjmp	.+26     	; 0x8364 <_ZN10helicopter10navigation4AHRS6updateEfffffffff+0x434>
	if (yawRads < 0)
	{
		yawRads = 2.0f * M_PI + yawRads;
    834a:	2b ed       	ldi	r18, 0xDB	; 219
    834c:	3f e0       	ldi	r19, 0x0F	; 15
    834e:	49 ec       	ldi	r20, 0xC9	; 201
    8350:	50 e4       	ldi	r21, 0x40	; 64
    8352:	c7 01       	movw	r24, r14
    8354:	b6 01       	movw	r22, r12
    8356:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    835a:	f2 01       	movw	r30, r4
    835c:	60 a7       	std	Z+40, r22	; 0x28
    835e:	71 a7       	std	Z+41, r23	; 0x29
    8360:	82 a7       	std	Z+42, r24	; 0x2a
    8362:	93 a7       	std	Z+43, r25	; 0x2b
	}
	
	pitchRads = -asin(dcm[2][0]);
    8364:	f2 01       	movw	r30, r4
    8366:	e8 5a       	subi	r30, 0xA8	; 168
    8368:	ff 4f       	sbci	r31, 0xFF	; 255
    836a:	60 81       	ld	r22, Z
    836c:	71 81       	ldd	r23, Z+1	; 0x01
    836e:	82 81       	ldd	r24, Z+2	; 0x02
    8370:	93 81       	ldd	r25, Z+3	; 0x03
    8372:	0e 94 cf 6a 	call	0xd59e	; 0xd59e <asin>
    8376:	dc 01       	movw	r26, r24
    8378:	cb 01       	movw	r24, r22
    837a:	b0 58       	subi	r27, 0x80	; 128
    837c:	f2 01       	movw	r30, r4
    837e:	84 a7       	std	Z+44, r24	; 0x2c
    8380:	95 a7       	std	Z+45, r25	; 0x2d
    8382:	a6 a7       	std	Z+46, r26	; 0x2e
    8384:	b7 a7       	std	Z+47, r27	; 0x2f
	rollRads = atan2(dcm[2][1], dcm[2][2]);
    8386:	e0 5a       	subi	r30, 0xA0	; 160
    8388:	ff 4f       	sbci	r31, 0xFF	; 255
    838a:	20 81       	ld	r18, Z
    838c:	31 81       	ldd	r19, Z+1	; 0x01
    838e:	42 81       	ldd	r20, Z+2	; 0x02
    8390:	53 81       	ldd	r21, Z+3	; 0x03
    8392:	f2 01       	movw	r30, r4
    8394:	e4 5a       	subi	r30, 0xA4	; 164
    8396:	ff 4f       	sbci	r31, 0xFF	; 255
    8398:	60 81       	ld	r22, Z
    839a:	71 81       	ldd	r23, Z+1	; 0x01
    839c:	82 81       	ldd	r24, Z+2	; 0x02
    839e:	93 81       	ldd	r25, Z+3	; 0x03
    83a0:	0e 94 f5 6a 	call	0xd5ea	; 0xd5ea <atan2>
    83a4:	d2 01       	movw	r26, r4
    83a6:	d0 96       	adiw	r26, 0x30	; 48
    83a8:	6d 93       	st	X+, r22
    83aa:	7d 93       	st	X+, r23
    83ac:	8d 93       	st	X+, r24
    83ae:	9c 93       	st	X, r25
    83b0:	d3 97       	sbiw	r26, 0x33	; 51
yawRads = heading;	*/
	
	
	

}
    83b2:	c2 58       	subi	r28, 0x82	; 130
    83b4:	df 4f       	sbci	r29, 0xFF	; 255
    83b6:	0f b6       	in	r0, 0x3f	; 63
    83b8:	f8 94       	cli
    83ba:	de bf       	out	0x3e, r29	; 62
    83bc:	0f be       	out	0x3f, r0	; 63
    83be:	cd bf       	out	0x3d, r28	; 61
    83c0:	df 91       	pop	r29
    83c2:	cf 91       	pop	r28
    83c4:	1f 91       	pop	r17
    83c6:	0f 91       	pop	r16
    83c8:	ff 90       	pop	r15
    83ca:	ef 90       	pop	r14
    83cc:	df 90       	pop	r13
    83ce:	cf 90       	pop	r12
    83d0:	bf 90       	pop	r11
    83d2:	af 90       	pop	r10
    83d4:	9f 90       	pop	r9
    83d6:	8f 90       	pop	r8
    83d8:	7f 90       	pop	r7
    83da:	6f 90       	pop	r6
    83dc:	5f 90       	pop	r5
    83de:	4f 90       	pop	r4
    83e0:	3f 90       	pop	r3
    83e2:	2f 90       	pop	r2
    83e4:	08 95       	ret

000083e6 <_ZN10helicopter10navigation4AHRS10getYawRadsEv>:

float AHRS::getYawRads()
{
    83e6:	fc 01       	movw	r30, r24
	return yawRads;
}
    83e8:	50 a5       	ldd	r21, Z+40	; 0x28
    83ea:	41 a5       	ldd	r20, Z+41	; 0x29
    83ec:	32 a5       	ldd	r19, Z+42	; 0x2a
    83ee:	23 a5       	ldd	r18, Z+43	; 0x2b
    83f0:	65 2f       	mov	r22, r21
    83f2:	74 2f       	mov	r23, r20
    83f4:	83 2f       	mov	r24, r19
    83f6:	92 2f       	mov	r25, r18
    83f8:	08 95       	ret

000083fa <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>:

float AHRS::getPitchRads()
{
    83fa:	fc 01       	movw	r30, r24
	return pitchRads;
}
    83fc:	54 a5       	ldd	r21, Z+44	; 0x2c
    83fe:	45 a5       	ldd	r20, Z+45	; 0x2d
    8400:	36 a5       	ldd	r19, Z+46	; 0x2e
    8402:	27 a5       	ldd	r18, Z+47	; 0x2f
    8404:	65 2f       	mov	r22, r21
    8406:	74 2f       	mov	r23, r20
    8408:	83 2f       	mov	r24, r19
    840a:	92 2f       	mov	r25, r18
    840c:	08 95       	ret

0000840e <_ZN10helicopter10navigation4AHRS11getRollRadsEv>:

float AHRS::getRollRads()
{
    840e:	fc 01       	movw	r30, r24
	return rollRads;
}
    8410:	50 a9       	ldd	r21, Z+48	; 0x30
    8412:	41 a9       	ldd	r20, Z+49	; 0x31
    8414:	32 a9       	ldd	r19, Z+50	; 0x32
    8416:	23 a9       	ldd	r18, Z+51	; 0x33
    8418:	65 2f       	mov	r22, r21
    841a:	74 2f       	mov	r23, r20
    841c:	83 2f       	mov	r24, r19
    841e:	92 2f       	mov	r25, r18
    8420:	08 95       	ret

00008422 <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>:
	}

	return scheduler;
}

Scheduler::Scheduler(unsigned long cpuSpeed, PRESCALER prescaler, int schedulerTickFrequencyHz)
    8422:	8f 92       	push	r8
    8424:	9f 92       	push	r9
    8426:	af 92       	push	r10
    8428:	bf 92       	push	r11
    842a:	ef 92       	push	r14
    842c:	ff 92       	push	r15
    842e:	0f 93       	push	r16
    8430:	1f 93       	push	r17
    8432:	cf 93       	push	r28
    8434:	df 93       	push	r29
    8436:	ec 01       	movw	r28, r24
    8438:	cb 01       	movw	r24, r22
    843a:	ba 01       	movw	r22, r20
    843c:	79 01       	movw	r14, r18
{
	//Calculate the timer value to achieve the desired frequency.
	targetTimerCount =  ((cpuSpeed / prescaler) / schedulerTickFrequencyHz);
    843e:	44 27       	eor	r20, r20
    8440:	37 fd       	sbrc	r19, 7
    8442:	40 95       	com	r20
    8444:	54 2f       	mov	r21, r20
    8446:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    844a:	49 01       	movw	r8, r18
    844c:	5a 01       	movw	r10, r20
    844e:	98 01       	movw	r18, r16
    8450:	44 27       	eor	r20, r20
    8452:	37 fd       	sbrc	r19, 7
    8454:	40 95       	com	r20
    8456:	54 2f       	mov	r21, r20
    8458:	c5 01       	movw	r24, r10
    845a:	b4 01       	movw	r22, r8
    845c:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    8460:	3d ab       	std	Y+53, r19	; 0x35
    8462:	2c ab       	std	Y+52, r18	; 0x34

	this->targetTimerCount = targetTimerCount;

	this->prescaler = prescaler;
    8464:	ff aa       	std	Y+55, r15	; 0x37
    8466:	ee aa       	std	Y+54, r14	; 0x36
	
	numOfTasks = 0;
    8468:	1b aa       	std	Y+51, r1	; 0x33
    846a:	1a aa       	std	Y+50, r1	; 0x32
	
	blowFrameDetected = false;
    846c:	18 ae       	std	Y+56, r1	; 0x38
	
	completedDispatch = true;
    846e:	81 e0       	ldi	r24, 0x01	; 1
    8470:	89 af       	std	Y+57, r24	; 0x39
}
    8472:	df 91       	pop	r29
    8474:	cf 91       	pop	r28
    8476:	1f 91       	pop	r17
    8478:	0f 91       	pop	r16
    847a:	ff 90       	pop	r15
    847c:	ef 90       	pop	r14
    847e:	bf 90       	pop	r11
    8480:	af 90       	pop	r10
    8482:	9f 90       	pop	r9
    8484:	8f 90       	pop	r8
    8486:	08 95       	ret

00008488 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>:
using namespace helicopter::model;

Scheduler* Scheduler::scheduler = NULL;

Scheduler* Scheduler::getScheduler()
{
    8488:	0f 93       	push	r16
    848a:	1f 93       	push	r17
    848c:	cf 93       	push	r28
    848e:	df 93       	push	r29
	if (scheduler == NULL)
    8490:	80 91 a6 03 	lds	r24, 0x03A6
    8494:	90 91 a7 03 	lds	r25, 0x03A7
    8498:	89 2b       	or	r24, r25
    849a:	99 f4       	brne	.+38     	; 0x84c2 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv+0x3a>
	{
		scheduler = new Scheduler(F_CPU, PRESCALE_BY_TENTWENTYFOUR, SCHEDULER_TICK_FREQUENCY_HZ);
    849c:	8a e3       	ldi	r24, 0x3A	; 58
    849e:	90 e0       	ldi	r25, 0x00	; 0
    84a0:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    84a4:	ec 01       	movw	r28, r24
    84a6:	08 ec       	ldi	r16, 0xC8	; 200
    84a8:	10 e0       	ldi	r17, 0x00	; 0
    84aa:	20 e0       	ldi	r18, 0x00	; 0
    84ac:	34 e0       	ldi	r19, 0x04	; 4
    84ae:	40 e0       	ldi	r20, 0x00	; 0
    84b0:	54 e2       	ldi	r21, 0x24	; 36
    84b2:	64 ef       	ldi	r22, 0xF4	; 244
    84b4:	70 e0       	ldi	r23, 0x00	; 0
    84b6:	0e 94 11 42 	call	0x8422	; 0x8422 <_ZN10helicopter9scheduler9SchedulerC1Em9PRESCALERi>
    84ba:	d0 93 a7 03 	sts	0x03A7, r29
    84be:	c0 93 a6 03 	sts	0x03A6, r28
	}

	return scheduler;
}
    84c2:	80 91 a6 03 	lds	r24, 0x03A6
    84c6:	90 91 a7 03 	lds	r25, 0x03A7
    84ca:	df 91       	pop	r29
    84cc:	cf 91       	pop	r28
    84ce:	1f 91       	pop	r17
    84d0:	0f 91       	pop	r16
    84d2:	08 95       	ret

000084d4 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE>:
	}
}

int Scheduler::addTask(Task *task)
{
	if (numOfTasks < MAXNUMOFTASKS)
    84d4:	fc 01       	movw	r30, r24
    84d6:	22 a9       	ldd	r18, Z+50	; 0x32
    84d8:	33 a9       	ldd	r19, Z+51	; 0x33
    84da:	29 31       	cpi	r18, 0x19	; 25
    84dc:	31 05       	cpc	r19, r1
    84de:	7c f4       	brge	.+30     	; 0x84fe <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE+0x2a>
	{
		tasks[numOfTasks] = task;
    84e0:	f9 01       	movw	r30, r18
    84e2:	ee 0f       	add	r30, r30
    84e4:	ff 1f       	adc	r31, r31
    84e6:	e8 0f       	add	r30, r24
    84e8:	f9 1f       	adc	r31, r25
    84ea:	71 83       	std	Z+1, r23	; 0x01
    84ec:	60 83       	st	Z, r22
		numOfTasks++;
    84ee:	2f 5f       	subi	r18, 0xFF	; 255
    84f0:	3f 4f       	sbci	r19, 0xFF	; 255
    84f2:	fc 01       	movw	r30, r24
    84f4:	33 ab       	std	Z+51, r19	; 0x33
    84f6:	22 ab       	std	Z+50, r18	; 0x32
		
		return 0;
    84f8:	20 e0       	ldi	r18, 0x00	; 0
    84fa:	30 e0       	ldi	r19, 0x00	; 0
    84fc:	02 c0       	rjmp	.+4      	; 0x8502 <_ZN10helicopter9scheduler9Scheduler7addTaskEPNS_5tasks4TaskE+0x2e>
	}

	return -1;
    84fe:	2f ef       	ldi	r18, 0xFF	; 255
    8500:	3f ef       	ldi	r19, 0xFF	; 255
}
    8502:	82 2f       	mov	r24, r18
    8504:	93 2f       	mov	r25, r19
    8506:	08 95       	ret

00008508 <_ZN10helicopter9scheduler9Scheduler4initEv>:

void Scheduler::init()
{
    8508:	ef 92       	push	r14
    850a:	ff 92       	push	r15
    850c:	0f 93       	push	r16
    850e:	1f 93       	push	r17
    8510:	cf 93       	push	r28
    8512:	df 93       	push	r29
    8514:	7c 01       	movw	r14, r24
	cli();
    8516:	f8 94       	cli
	
	for (int i = 0; i < numOfTasks; i++)
    8518:	dc 01       	movw	r26, r24
    851a:	d2 96       	adiw	r26, 0x32	; 50
    851c:	8d 91       	ld	r24, X+
    851e:	9c 91       	ld	r25, X
    8520:	d3 97       	sbiw	r26, 0x33	; 51
    8522:	18 16       	cp	r1, r24
    8524:	19 06       	cpc	r1, r25
    8526:	ac f4       	brge	.+42     	; 0x8552 <_ZN10helicopter9scheduler9Scheduler4initEv+0x4a>
    8528:	87 01       	movw	r16, r14
    852a:	c0 e0       	ldi	r28, 0x00	; 0
    852c:	d0 e0       	ldi	r29, 0x00	; 0
	{
		tasks[i]->init();
    852e:	f8 01       	movw	r30, r16
    8530:	81 91       	ld	r24, Z+
    8532:	91 91       	ld	r25, Z+
    8534:	8f 01       	movw	r16, r30
    8536:	dc 01       	movw	r26, r24
    8538:	ed 91       	ld	r30, X+
    853a:	fc 91       	ld	r31, X
    853c:	06 80       	ldd	r0, Z+6	; 0x06
    853e:	f7 81       	ldd	r31, Z+7	; 0x07
    8540:	e0 2d       	mov	r30, r0
    8542:	19 95       	eicall

void Scheduler::init()
{
	cli();
	
	for (int i = 0; i < numOfTasks; i++)
    8544:	21 96       	adiw	r28, 0x01	; 1
    8546:	f7 01       	movw	r30, r14
    8548:	22 a9       	ldd	r18, Z+50	; 0x32
    854a:	33 a9       	ldd	r19, Z+51	; 0x33
    854c:	c2 17       	cp	r28, r18
    854e:	d3 07       	cpc	r29, r19
    8550:	74 f3       	brlt	.-36     	; 0x852e <_ZN10helicopter9scheduler9Scheduler4initEv+0x26>
	{
		tasks[i]->init();
	}
	
	//setup timer
	OCR2A = targetTimerCount; //Set Clear Timer on Compare (auto reset) (CTC)
    8552:	d7 01       	movw	r26, r14
    8554:	d4 96       	adiw	r26, 0x34	; 52
    8556:	8c 91       	ld	r24, X
    8558:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2A |= (1 << WGM21); //Configure timer 2 for ctc mode
    855c:	e0 eb       	ldi	r30, 0xB0	; 176
    855e:	f0 e0       	ldi	r31, 0x00	; 0
    8560:	80 81       	ld	r24, Z
    8562:	82 60       	ori	r24, 0x02	; 2
    8564:	80 83       	st	Z, r24
	TIMSK2 |= (1 << OCIE2A); //enable ctc interrupt for OCR0A
    8566:	e0 e7       	ldi	r30, 0x70	; 112
    8568:	f0 e0       	ldi	r31, 0x00	; 0
    856a:	80 81       	ld	r24, Z
    856c:	82 60       	ori	r24, 0x02	; 2
    856e:	80 83       	st	Z, r24
		
	sei(); //Enable global interrupts
    8570:	78 94       	sei
}
    8572:	df 91       	pop	r29
    8574:	cf 91       	pop	r28
    8576:	1f 91       	pop	r17
    8578:	0f 91       	pop	r16
    857a:	ff 90       	pop	r15
    857c:	ef 90       	pop	r14
    857e:	08 95       	ret

00008580 <_ZN10helicopter9scheduler9Scheduler8dispatchEv>:

void Scheduler::dispatch()
{
    8580:	ef 92       	push	r14
    8582:	ff 92       	push	r15
    8584:	0f 93       	push	r16
    8586:	1f 93       	push	r17
    8588:	cf 93       	push	r28
    858a:	df 93       	push	r29
    858c:	7c 01       	movw	r14, r24
	completedDispatch = false;
    858e:	fc 01       	movw	r30, r24
    8590:	11 ae       	std	Z+57, r1	; 0x39
	blowFrameDetected = false;
    8592:	10 ae       	std	Z+56, r1	; 0x38
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    8594:	82 a9       	ldd	r24, Z+50	; 0x32
    8596:	93 a9       	ldd	r25, Z+51	; 0x33
    8598:	18 16       	cp	r1, r24
    859a:	19 06       	cpc	r1, r25
    859c:	f4 f4       	brge	.+60     	; 0x85da <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x5a>
    859e:	87 01       	movw	r16, r14
    85a0:	c0 e0       	ldi	r28, 0x00	; 0
    85a2:	d0 e0       	ldi	r29, 0x00	; 0
	{
		task = tasks[i];
    85a4:	f8 01       	movw	r30, r16
    85a6:	a1 91       	ld	r26, Z+
    85a8:	b1 91       	ld	r27, Z+
    85aa:	8f 01       	movw	r16, r30
		
		if (task->getIsReadyToRun())
    85ac:	16 96       	adiw	r26, 0x06	; 6
    85ae:	8c 91       	ld	r24, X
    85b0:	16 97       	sbiw	r26, 0x06	; 6
    85b2:	88 23       	and	r24, r24
    85b4:	59 f0       	breq	.+22     	; 0x85cc <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x4c>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    85b6:	16 96       	adiw	r26, 0x06	; 6
    85b8:	1c 92       	st	X, r1
    85ba:	16 97       	sbiw	r26, 0x06	; 6
		{
			task->setIsReadyToRun(false);
			task->runTask();
    85bc:	ed 91       	ld	r30, X+
    85be:	fc 91       	ld	r31, X
    85c0:	11 97       	sbiw	r26, 0x01	; 1
    85c2:	00 84       	ldd	r0, Z+8	; 0x08
    85c4:	f1 85       	ldd	r31, Z+9	; 0x09
    85c6:	e0 2d       	mov	r30, r0
    85c8:	cd 01       	movw	r24, r26
    85ca:	19 95       	eicall
	
	Task *task = NULL;
		

	//Iterate through the tasks and if it's ready to run, execute the task. 
	for (int i = 0; i < numOfTasks; i++)
    85cc:	21 96       	adiw	r28, 0x01	; 1
    85ce:	f7 01       	movw	r30, r14
    85d0:	22 a9       	ldd	r18, Z+50	; 0x32
    85d2:	33 a9       	ldd	r19, Z+51	; 0x33
    85d4:	c2 17       	cp	r28, r18
    85d6:	d3 07       	cpc	r29, r19
    85d8:	2c f3       	brlt	.-54     	; 0x85a4 <_ZN10helicopter9scheduler9Scheduler8dispatchEv+0x24>
			task->setIsReadyToRun(false);
			task->runTask();
		}
	}

	completedDispatch = true;
    85da:	81 e0       	ldi	r24, 0x01	; 1
    85dc:	f7 01       	movw	r30, r14
    85de:	81 af       	std	Z+57, r24	; 0x39
	
	//tells the processor to goto sleep to conserve power since no more
	//tasks are scheduled to be run until after the next scheduler interrupt(tick)
	//which will then wake the processor back up.
	set_sleep_mode(SLEEP_MODE_IDLE);
    85e0:	83 b7       	in	r24, 0x33	; 51
    85e2:	81 7f       	andi	r24, 0xF1	; 241
    85e4:	83 bf       	out	0x33, r24	; 51
	sleep_mode();
    85e6:	83 b7       	in	r24, 0x33	; 51
    85e8:	81 60       	ori	r24, 0x01	; 1
    85ea:	83 bf       	out	0x33, r24	; 51
    85ec:	88 95       	sleep
    85ee:	83 b7       	in	r24, 0x33	; 51
    85f0:	8e 7f       	andi	r24, 0xFE	; 254
    85f2:	83 bf       	out	0x33, r24	; 51
}
    85f4:	df 91       	pop	r29
    85f6:	cf 91       	pop	r28
    85f8:	1f 91       	pop	r17
    85fa:	0f 91       	pop	r16
    85fc:	ff 90       	pop	r15
    85fe:	ef 90       	pop	r14
    8600:	08 95       	ret

00008602 <_ZN10helicopter9scheduler9Scheduler5startEv>:

void Scheduler::start()
{
	//Setting TCCR to a prescaler will start the timer.
	switch(this->prescaler)
    8602:	fc 01       	movw	r30, r24
    8604:	86 a9       	ldd	r24, Z+54	; 0x36
    8606:	97 a9       	ldd	r25, Z+55	; 0x37
    8608:	80 34       	cpi	r24, 0x40	; 64
    860a:	91 05       	cpc	r25, r1
    860c:	d9 f0       	breq	.+54     	; 0x8644 <_ZN10helicopter9scheduler9Scheduler5startEv+0x42>
    860e:	34 f4       	brge	.+12     	; 0x861c <_ZN10helicopter9scheduler9Scheduler5startEv+0x1a>
    8610:	81 30       	cpi	r24, 0x01	; 1
    8612:	91 05       	cpc	r25, r1
    8614:	59 f0       	breq	.+22     	; 0x862c <_ZN10helicopter9scheduler9Scheduler5startEv+0x2a>
    8616:	08 97       	sbiw	r24, 0x08	; 8
    8618:	39 f5       	brne	.+78     	; 0x8668 <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
    861a:	0e c0       	rjmp	.+28     	; 0x8638 <_ZN10helicopter9scheduler9Scheduler5startEv+0x36>
    861c:	81 15       	cp	r24, r1
    861e:	f1 e0       	ldi	r31, 0x01	; 1
    8620:	9f 07       	cpc	r25, r31
    8622:	b1 f0       	breq	.+44     	; 0x8650 <_ZN10helicopter9scheduler9Scheduler5startEv+0x4e>
    8624:	81 15       	cp	r24, r1
    8626:	94 40       	sbci	r25, 0x04	; 4
    8628:	f9 f4       	brne	.+62     	; 0x8668 <_ZN10helicopter9scheduler9Scheduler5startEv+0x66>
    862a:	18 c0       	rjmp	.+48     	; 0x865c <_ZN10helicopter9scheduler9Scheduler5startEv+0x5a>
	{
		case 1:
			TCCR2B |= NoPrescaling;
    862c:	e1 eb       	ldi	r30, 0xB1	; 177
    862e:	f0 e0       	ldi	r31, 0x00	; 0
    8630:	80 81       	ld	r24, Z
    8632:	81 60       	ori	r24, 0x01	; 1
    8634:	80 83       	st	Z, r24
			break;
    8636:	08 95       	ret
		case 8:
			TCCR2B |= PrescaleByEight;
    8638:	e1 eb       	ldi	r30, 0xB1	; 177
    863a:	f0 e0       	ldi	r31, 0x00	; 0
    863c:	80 81       	ld	r24, Z
    863e:	82 60       	ori	r24, 0x02	; 2
    8640:	80 83       	st	Z, r24
			break;
    8642:	08 95       	ret
		case 64:
			TCCR2B |= PrescaleBySixtyFour;
    8644:	e1 eb       	ldi	r30, 0xB1	; 177
    8646:	f0 e0       	ldi	r31, 0x00	; 0
    8648:	80 81       	ld	r24, Z
    864a:	84 60       	ori	r24, 0x04	; 4
    864c:	80 83       	st	Z, r24
			break;
    864e:	08 95       	ret
		case 256:
			TCCR2B |= PrescaleByTwofiftysix;
    8650:	e1 eb       	ldi	r30, 0xB1	; 177
    8652:	f0 e0       	ldi	r31, 0x00	; 0
    8654:	80 81       	ld	r24, Z
    8656:	86 60       	ori	r24, 0x06	; 6
    8658:	80 83       	st	Z, r24
			break;
    865a:	08 95       	ret
		case 1024:
			TCCR2B |= PrescaleByTentwentyfour;
    865c:	e1 eb       	ldi	r30, 0xB1	; 177
    865e:	f0 e0       	ldi	r31, 0x00	; 0
    8660:	80 81       	ld	r24, Z
    8662:	87 60       	ori	r24, 0x07	; 7
    8664:	80 83       	st	Z, r24
			break;
    8666:	08 95       	ret
		default:
			TCCR2B |= NoPrescaling;	
    8668:	e1 eb       	ldi	r30, 0xB1	; 177
    866a:	f0 e0       	ldi	r31, 0x00	; 0
    866c:	80 81       	ld	r24, Z
    866e:	81 60       	ori	r24, 0x01	; 1
    8670:	80 83       	st	Z, r24
    8672:	08 95       	ret

00008674 <__vector_13>:

/**
 * Interrupt service routine for determining when tasks are ready to execute.
 */
ISR(TIMER2_COMPA_vect)
{
    8674:	1f 92       	push	r1
    8676:	0f 92       	push	r0
    8678:	0f b6       	in	r0, 0x3f	; 63
    867a:	0f 92       	push	r0
    867c:	11 24       	eor	r1, r1
    867e:	0b b6       	in	r0, 0x3b	; 59
    8680:	0f 92       	push	r0
    8682:	2f 93       	push	r18
    8684:	3f 93       	push	r19
    8686:	4f 93       	push	r20
    8688:	5f 93       	push	r21
    868a:	6f 93       	push	r22
    868c:	7f 93       	push	r23
    868e:	8f 93       	push	r24
    8690:	9f 93       	push	r25
    8692:	af 93       	push	r26
    8694:	bf 93       	push	r27
    8696:	cf 93       	push	r28
    8698:	df 93       	push	r29
    869a:	ef 93       	push	r30
    869c:	ff 93       	push	r31
publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);	
}
	*/
	
	
	Scheduler *scheduler = Scheduler::getScheduler();
    869e:	0e 94 44 42 	call	0x8488	; 0x8488 <_ZN10helicopter9scheduler9Scheduler12getSchedulerEv>
    86a2:	ec 01       	movw	r28, r24
	
	//Detect if the scheduler blew a frame
	if (!scheduler->hasCompletedDispatch())
    86a4:	89 ad       	ldd	r24, Y+57	; 0x39
    86a6:	81 11       	cpse	r24, r1
    86a8:	12 c0       	rjmp	.+36     	; 0x86ce <__vector_13+0x5a>
	{
//		scheduler->hasBlownFrame(true);
//publicModel->SerialCommunicationBufferOverruns(publicModel->SerialCommunicationBufferOverruns() + 1);		
//SystemModel::publicModel->SerialCommunicationBufferOverruns(SystemModel::publicModel->SerialCommunicationBufferOverruns() + 1);		
SystemModel::publicModel->BlownFrames(SystemModel::publicModel->BlownFrames() + 1);		
    86aa:	e0 91 a4 03 	lds	r30, 0x03A4
    86ae:	f0 91 a5 03 	lds	r31, 0x03A5
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
    86b2:	ea 54       	subi	r30, 0x4A	; 74
    86b4:	ff 4f       	sbci	r31, 0xFF	; 255
    86b6:	40 81       	ld	r20, Z
    86b8:	51 81       	ldd	r21, Z+1	; 0x01
    86ba:	62 81       	ldd	r22, Z+2	; 0x02
    86bc:	73 81       	ldd	r23, Z+3	; 0x03
    86be:	4f 5f       	subi	r20, 0xFF	; 255
    86c0:	5f 4f       	sbci	r21, 0xFF	; 255
    86c2:	6f 4f       	sbci	r22, 0xFF	; 255
    86c4:	7f 4f       	sbci	r23, 0xFF	; 255
    86c6:	40 83       	st	Z, r20
    86c8:	51 83       	std	Z+1, r21	; 0x01
    86ca:	62 83       	std	Z+2, r22	; 0x02
    86cc:	73 83       	std	Z+3, r23	; 0x03
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    86ce:	8a a9       	ldd	r24, Y+50	; 0x32
    86d0:	9b a9       	ldd	r25, Y+51	; 0x33
    86d2:	18 16       	cp	r1, r24
    86d4:	19 06       	cpc	r1, r25
    86d6:	e4 f4       	brge	.+56     	; 0x8710 <__vector_13+0x9c>
    86d8:	de 01       	movw	r26, r28
    86da:	20 e0       	ldi	r18, 0x00	; 0
    86dc:	30 e0       	ldi	r19, 0x00	; 0
    86de:	61 e0       	ldi	r22, 0x01	; 1
	{
		task = scheduler->getTasks()[i];
    86e0:	ed 91       	ld	r30, X+
    86e2:	fd 91       	ld	r31, X+
				virtual void runTask();
				
					
				int getDelay()
				{
					return delay;
    86e4:	42 81       	ldd	r20, Z+2	; 0x02
    86e6:	53 81       	ldd	r21, Z+3	; 0x03
		
		if (task->getDelay() <= 1)
    86e8:	42 30       	cpi	r20, 0x02	; 2
    86ea:	51 05       	cpc	r21, r1
    86ec:	34 f4       	brge	.+12     	; 0x86fa <__vector_13+0x86>
					return isReadyToRun;
				}
				
				void setIsReadyToRun(bool isReadyToRun)
				{
					this->isReadyToRun = isReadyToRun;
    86ee:	66 83       	std	Z+6, r22	; 0x06
					return period;
				}
				
				void setDelay(int delay)
				{
					this->delay = delay;
    86f0:	84 81       	ldd	r24, Z+4	; 0x04
    86f2:	95 81       	ldd	r25, Z+5	; 0x05
    86f4:	93 83       	std	Z+3, r25	; 0x03
    86f6:	82 83       	std	Z+2, r24	; 0x02
    86f8:	04 c0       	rjmp	.+8      	; 0x8702 <__vector_13+0x8e>
				/**
				 * Reduces the delay by one tick.
				 */
				void reduceDelay()
				{
					delay--;
    86fa:	41 50       	subi	r20, 0x01	; 1
    86fc:	51 09       	sbc	r21, r1
    86fe:	53 83       	std	Z+3, r21	; 0x03
    8700:	42 83       	std	Z+2, r20	; 0x02
	
	Task *task = NULL;
	
	//iterate through all the tasks and decrement how many
	//'ticks' are left before the task is ready to execute.
	for (int i = 0; i < scheduler->getNumOfTasks(); i++)
    8702:	2f 5f       	subi	r18, 0xFF	; 255
    8704:	3f 4f       	sbci	r19, 0xFF	; 255
    8706:	8a a9       	ldd	r24, Y+50	; 0x32
    8708:	9b a9       	ldd	r25, Y+51	; 0x33
    870a:	28 17       	cp	r18, r24
    870c:	39 07       	cpc	r19, r25
    870e:	44 f3       	brlt	.-48     	; 0x86e0 <__vector_13+0x6c>
		}else
		{
			task->reduceDelay();
		}
	}
}
    8710:	ff 91       	pop	r31
    8712:	ef 91       	pop	r30
    8714:	df 91       	pop	r29
    8716:	cf 91       	pop	r28
    8718:	bf 91       	pop	r27
    871a:	af 91       	pop	r26
    871c:	9f 91       	pop	r25
    871e:	8f 91       	pop	r24
    8720:	7f 91       	pop	r23
    8722:	6f 91       	pop	r22
    8724:	5f 91       	pop	r21
    8726:	4f 91       	pop	r20
    8728:	3f 91       	pop	r19
    872a:	2f 91       	pop	r18
    872c:	0f 90       	pop	r0
    872e:	0b be       	out	0x3b, r0	; 59
    8730:	0f 90       	pop	r0
    8732:	0f be       	out	0x3f, r0	; 63
    8734:	0f 90       	pop	r0
    8736:	1f 90       	pop	r1
    8738:	18 95       	reti

0000873a <_ZN10helicopter7sensors15BarometerSensor4initEv>:


using namespace helicopter::sensors;

void BarometerSensor::init()
{
    873a:	0f 93       	push	r16
    873c:	1f 93       	push	r17
    873e:	cf 93       	push	r28
    8740:	df 93       	push	r29
    8742:	ec 01       	movw	r28, r24
	//Per page 9 of MS5611-01Ba03.PDF Reset the barometer to ensure calibration PROM gets loaded.
	spiDriver->transactionWrite(RESET_COMMAND);
    8744:	6e e1       	ldi	r22, 0x1E	; 30
    8746:	88 81       	ld	r24, Y
    8748:	99 81       	ldd	r25, Y+1	; 0x01
    874a:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    874e:	8f e1       	ldi	r24, 0x1F	; 31
    8750:	9e e4       	ldi	r25, 0x4E	; 78
    8752:	01 97       	sbiw	r24, 0x01	; 1
    8754:	f1 f7       	brne	.-4      	; 0x8752 <_ZN10helicopter7sensors15BarometerSensor4initEv+0x18>
    8756:	00 c0       	rjmp	.+0      	; 0x8758 <_ZN10helicopter7sensors15BarometerSensor4initEv+0x1e>
    8758:	00 00       	nop
	/**
	 * Each barometer is individually calibrated at the factory. This reads those calibration
	 * values for our calculations to compensate temperature and pressure values. 
	 * Those values are stored in the programmable read only memory (PROM) of the barometer
	 */
	spiDriver->beginTransaction();
    875a:	88 81       	ld	r24, Y
    875c:	99 81       	ldd	r25, Y+1	; 0x01
    875e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C1_COMMAND);
    8762:	62 ea       	ldi	r22, 0xA2	; 162
    8764:	88 81       	ld	r24, Y
    8766:	99 81       	ldd	r25, Y+1	; 0x01
    8768:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivity_SENSt1_C1 = spiDriver->readUInt();
    876c:	88 81       	ld	r24, Y
    876e:	99 81       	ldd	r25, Y+1	; 0x01
    8770:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8774:	8c 01       	movw	r16, r24
    8776:	8a 8b       	std	Y+18, r24	; 0x12
    8778:	1b 8b       	std	Y+19, r17	; 0x13
    877a:	1c 8a       	std	Y+20, r1	; 0x14
    877c:	1d 8a       	std	Y+21, r1	; 0x15
    877e:	1e 8a       	std	Y+22, r1	; 0x16
    8780:	1f 8a       	std	Y+23, r1	; 0x17
    8782:	18 8e       	std	Y+24, r1	; 0x18
    8784:	19 8e       	std	Y+25, r1	; 0x19
	spiDriver->endTransaction();
    8786:	88 81       	ld	r24, Y
    8788:	99 81       	ldd	r25, Y+1	; 0x01
    878a:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    878e:	88 81       	ld	r24, Y
    8790:	99 81       	ldd	r25, Y+1	; 0x01
    8792:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C2_COMMAND);
    8796:	64 ea       	ldi	r22, 0xA4	; 164
    8798:	88 81       	ld	r24, Y
    879a:	99 81       	ldd	r25, Y+1	; 0x01
    879c:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	pressureSensitivityOffset_OFFt1_C2 = spiDriver->readUInt();
    87a0:	88 81       	ld	r24, Y
    87a2:	99 81       	ldd	r25, Y+1	; 0x01
    87a4:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    87a8:	8c 01       	movw	r16, r24
    87aa:	8a 8f       	std	Y+26, r24	; 0x1a
    87ac:	1b 8f       	std	Y+27, r17	; 0x1b
    87ae:	1c 8e       	std	Y+28, r1	; 0x1c
    87b0:	1d 8e       	std	Y+29, r1	; 0x1d
    87b2:	1e 8e       	std	Y+30, r1	; 0x1e
    87b4:	1f 8e       	std	Y+31, r1	; 0x1f
    87b6:	18 a2       	std	Y+32, r1	; 0x20
    87b8:	19 a2       	std	Y+33, r1	; 0x21
	spiDriver->endTransaction();
    87ba:	88 81       	ld	r24, Y
    87bc:	99 81       	ldd	r25, Y+1	; 0x01
    87be:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>

	spiDriver->beginTransaction();
    87c2:	88 81       	ld	r24, Y
    87c4:	99 81       	ldd	r25, Y+1	; 0x01
    87c6:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C3_COMMAND);
    87ca:	66 ea       	ldi	r22, 0xA6	; 166
    87cc:	88 81       	ld	r24, Y
    87ce:	99 81       	ldd	r25, Y+1	; 0x01
    87d0:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureSensitivity_TCS_C3 = spiDriver->readUInt();
    87d4:	88 81       	ld	r24, Y
    87d6:	99 81       	ldd	r25, Y+1	; 0x01
    87d8:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    87dc:	8c 01       	movw	r16, r24
    87de:	8a a3       	std	Y+34, r24	; 0x22
    87e0:	1b a3       	std	Y+35, r17	; 0x23
    87e2:	1c a2       	std	Y+36, r1	; 0x24
    87e4:	1d a2       	std	Y+37, r1	; 0x25
    87e6:	1e a2       	std	Y+38, r1	; 0x26
    87e8:	1f a2       	std	Y+39, r1	; 0x27
    87ea:	18 a6       	std	Y+40, r1	; 0x28
    87ec:	19 a6       	std	Y+41, r1	; 0x29
	spiDriver->endTransaction();
    87ee:	88 81       	ld	r24, Y
    87f0:	99 81       	ldd	r25, Y+1	; 0x01
    87f2:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    87f6:	88 81       	ld	r24, Y
    87f8:	99 81       	ldd	r25, Y+1	; 0x01
    87fa:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C4_COMMAND);
    87fe:	68 ea       	ldi	r22, 0xA8	; 168
    8800:	88 81       	ld	r24, Y
    8802:	99 81       	ldd	r25, Y+1	; 0x01
    8804:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfPressureOffset_TCO_C4 = spiDriver->readUInt();
    8808:	88 81       	ld	r24, Y
    880a:	99 81       	ldd	r25, Y+1	; 0x01
    880c:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8810:	8c 01       	movw	r16, r24
    8812:	8a a7       	std	Y+42, r24	; 0x2a
    8814:	1b a7       	std	Y+43, r17	; 0x2b
    8816:	1c a6       	std	Y+44, r1	; 0x2c
    8818:	1d a6       	std	Y+45, r1	; 0x2d
    881a:	1e a6       	std	Y+46, r1	; 0x2e
    881c:	1f a6       	std	Y+47, r1	; 0x2f
    881e:	18 aa       	std	Y+48, r1	; 0x30
    8820:	19 aa       	std	Y+49, r1	; 0x31
	spiDriver->endTransaction();
    8822:	88 81       	ld	r24, Y
    8824:	99 81       	ldd	r25, Y+1	; 0x01
    8826:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    882a:	88 81       	ld	r24, Y
    882c:	99 81       	ldd	r25, Y+1	; 0x01
    882e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C5_COMMAND);
    8832:	6a ea       	ldi	r22, 0xAA	; 170
    8834:	88 81       	ld	r24, Y
    8836:	99 81       	ldd	r25, Y+1	; 0x01
    8838:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	referenceTemperature_Tref_C5 = spiDriver->readUInt();
    883c:	88 81       	ld	r24, Y
    883e:	99 81       	ldd	r25, Y+1	; 0x01
    8840:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8844:	8c 01       	movw	r16, r24
    8846:	8a ab       	std	Y+50, r24	; 0x32
    8848:	1b ab       	std	Y+51, r17	; 0x33
    884a:	1c aa       	std	Y+52, r1	; 0x34
    884c:	1d aa       	std	Y+53, r1	; 0x35
    884e:	1e aa       	std	Y+54, r1	; 0x36
    8850:	1f aa       	std	Y+55, r1	; 0x37
    8852:	18 ae       	std	Y+56, r1	; 0x38
    8854:	19 ae       	std	Y+57, r1	; 0x39
	spiDriver->endTransaction();
    8856:	88 81       	ld	r24, Y
    8858:	99 81       	ldd	r25, Y+1	; 0x01
    885a:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	
	spiDriver->beginTransaction();
    885e:	88 81       	ld	r24, Y
    8860:	99 81       	ldd	r25, Y+1	; 0x01
    8862:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	spiDriver->write(READ_PROM_C6_COMMAND);
    8866:	6c ea       	ldi	r22, 0xAC	; 172
    8868:	88 81       	ld	r24, Y
    886a:	99 81       	ldd	r25, Y+1	; 0x01
    886c:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	temperatureCoefficientOfTheTemperature_TEMPSENS_C6 = spiDriver->readUInt();
    8870:	88 81       	ld	r24, Y
    8872:	99 81       	ldd	r25, Y+1	; 0x01
    8874:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <_ZN10helicopter7drivers9SPIDriver8readUIntEv>
    8878:	8c 01       	movw	r16, r24
    887a:	fe 01       	movw	r30, r28
    887c:	fa 96       	adiw	r30, 0x3a	; 58
    887e:	8a af       	std	Y+58, r24	; 0x3a
    8880:	11 83       	std	Z+1, r17	; 0x01
    8882:	12 82       	std	Z+2, r1	; 0x02
    8884:	13 82       	std	Z+3, r1	; 0x03
    8886:	14 82       	std	Z+4, r1	; 0x04
    8888:	15 82       	std	Z+5, r1	; 0x05
    888a:	16 82       	std	Z+6, r1	; 0x06
    888c:	17 82       	std	Z+7, r1	; 0x07
	spiDriver->endTransaction();
    888e:	88 81       	ld	r24, Y
    8890:	99 81       	ldd	r25, Y+1	; 0x01
    8892:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    8896:	df 91       	pop	r29
    8898:	cf 91       	pop	r28
    889a:	1f 91       	pop	r17
    889c:	0f 91       	pop	r16
    889e:	08 95       	ret

000088a0 <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>:
	 * Initiate conversion for pressure.
	 * According to page 5 in MS5611-01Ba03.PDF, the best noise performance is obtained
	 * when the SPI bus is idle during ADC conversion. So we keep the ADC initiation command
	 * in it's own transaction to reduce noise. 
	 */
	spiDriver->transactionWrite(CONVERT_D1_PRESSURE_OSR_4096);
    88a0:	68 e4       	ldi	r22, 0x48	; 72
    88a2:	fc 01       	movw	r30, r24
    88a4:	80 81       	ld	r24, Z
    88a6:	91 81       	ldd	r25, Z+1	; 0x01
    88a8:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    88ac:	08 95       	ret

000088ae <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>:
}

void BarometerSensor::readD1Data()
{	
    88ae:	cf 92       	push	r12
    88b0:	df 92       	push	r13
    88b2:	ef 92       	push	r14
    88b4:	ff 92       	push	r15
    88b6:	cf 93       	push	r28
    88b8:	df 93       	push	r29
    88ba:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    88bc:	88 81       	ld	r24, Y
    88be:	99 81       	ldd	r25, Y+1	; 0x01
    88c0:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    88c4:	60 e0       	ldi	r22, 0x00	; 0
    88c6:	88 81       	ld	r24, Y
    88c8:	99 81       	ldd	r25, Y+1	; 0x01
    88ca:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	
	/**
	 * The pressure is 3 bytes. So read the hight byte, shift it by eight, read the mid byte, shift by 8, then read the low byte
	 * to form a 3 byte 'long'
	 */
	rawPressure = spiDriver->readByte();
    88ce:	88 81       	ld	r24, Y
    88d0:	99 81       	ldd	r25, Y+1	; 0x01
    88d2:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    88d6:	c8 2e       	mov	r12, r24
    88d8:	d1 2c       	mov	r13, r1
    88da:	e1 2c       	mov	r14, r1
    88dc:	f1 2c       	mov	r15, r1
    88de:	ce 82       	std	Y+6, r12	; 0x06
    88e0:	df 82       	std	Y+7, r13	; 0x07
    88e2:	e8 86       	std	Y+8, r14	; 0x08
    88e4:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    88e6:	88 81       	ld	r24, Y
    88e8:	99 81       	ldd	r25, Y+1	; 0x01
    88ea:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    88ee:	fe 2c       	mov	r15, r14
    88f0:	ed 2c       	mov	r14, r13
    88f2:	dc 2c       	mov	r13, r12
    88f4:	cc 24       	eor	r12, r12
    88f6:	c8 2a       	or	r12, r24
    88f8:	ce 82       	std	Y+6, r12	; 0x06
    88fa:	df 82       	std	Y+7, r13	; 0x07
    88fc:	e8 86       	std	Y+8, r14	; 0x08
    88fe:	f9 86       	std	Y+9, r15	; 0x09
	rawPressure = rawPressure << 8 | spiDriver->readByte();
    8900:	88 81       	ld	r24, Y
    8902:	99 81       	ldd	r25, Y+1	; 0x01
    8904:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8908:	fe 2c       	mov	r15, r14
    890a:	ed 2c       	mov	r14, r13
    890c:	dc 2c       	mov	r13, r12
    890e:	cc 24       	eor	r12, r12
    8910:	c8 2a       	or	r12, r24
    8912:	ce 82       	std	Y+6, r12	; 0x06
    8914:	df 82       	std	Y+7, r13	; 0x07
    8916:	e8 86       	std	Y+8, r14	; 0x08
    8918:	f9 86       	std	Y+9, r15	; 0x09
	
	spiDriver->endTransaction();	
    891a:	88 81       	ld	r24, Y
    891c:	99 81       	ldd	r25, Y+1	; 0x01
    891e:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    8922:	df 91       	pop	r29
    8924:	cf 91       	pop	r28
    8926:	ff 90       	pop	r15
    8928:	ef 90       	pop	r14
    892a:	df 90       	pop	r13
    892c:	cf 90       	pop	r12
    892e:	08 95       	ret

00008930 <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>:

void BarometerSensor::sendD2Command()
{
	//Initiate conversion for temperature.
	spiDriver->transactionWrite(CONVERT_D2_TEMPERATURE_OSR_4096);	
    8930:	68 e5       	ldi	r22, 0x58	; 88
    8932:	fc 01       	movw	r30, r24
    8934:	80 81       	ld	r24, Z
    8936:	91 81       	ldd	r25, Z+1	; 0x01
    8938:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <_ZN10helicopter7drivers9SPIDriver16transactionWriteEh>
    893c:	08 95       	ret

0000893e <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>:
}

void BarometerSensor::readD2Data()
{
    893e:	cf 92       	push	r12
    8940:	df 92       	push	r13
    8942:	ef 92       	push	r14
    8944:	ff 92       	push	r15
    8946:	cf 93       	push	r28
    8948:	df 93       	push	r29
    894a:	ec 01       	movw	r28, r24
	spiDriver->beginTransaction();
    894c:	88 81       	ld	r24, Y
    894e:	99 81       	ldd	r25, Y+1	; 0x01
    8950:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	
	/**
	 * Read the ADC results
	 */
	spiDriver->write(ADC_READ_COMMAND);
    8954:	60 e0       	ldi	r22, 0x00	; 0
    8956:	88 81       	ld	r24, Y
    8958:	99 81       	ldd	r25, Y+1	; 0x01
    895a:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>
	rawTemperature = spiDriver->readByte();
    895e:	88 81       	ld	r24, Y
    8960:	99 81       	ldd	r25, Y+1	; 0x01
    8962:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8966:	c8 2e       	mov	r12, r24
    8968:	d1 2c       	mov	r13, r1
    896a:	e1 2c       	mov	r14, r1
    896c:	f1 2c       	mov	r15, r1
    896e:	ca 82       	std	Y+2, r12	; 0x02
    8970:	db 82       	std	Y+3, r13	; 0x03
    8972:	ec 82       	std	Y+4, r14	; 0x04
    8974:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();
    8976:	88 81       	ld	r24, Y
    8978:	99 81       	ldd	r25, Y+1	; 0x01
    897a:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    897e:	fe 2c       	mov	r15, r14
    8980:	ed 2c       	mov	r14, r13
    8982:	dc 2c       	mov	r13, r12
    8984:	cc 24       	eor	r12, r12
    8986:	c8 2a       	or	r12, r24
    8988:	ca 82       	std	Y+2, r12	; 0x02
    898a:	db 82       	std	Y+3, r13	; 0x03
    898c:	ec 82       	std	Y+4, r14	; 0x04
    898e:	fd 82       	std	Y+5, r15	; 0x05
	rawTemperature = rawTemperature << 8 | spiDriver->readByte();	
    8990:	88 81       	ld	r24, Y
    8992:	99 81       	ldd	r25, Y+1	; 0x01
    8994:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_ZN10helicopter7drivers9SPIDriver8readByteEv>
    8998:	fe 2c       	mov	r15, r14
    899a:	ed 2c       	mov	r14, r13
    899c:	dc 2c       	mov	r13, r12
    899e:	cc 24       	eor	r12, r12
    89a0:	c8 2a       	or	r12, r24
    89a2:	ca 82       	std	Y+2, r12	; 0x02
    89a4:	db 82       	std	Y+3, r13	; 0x03
    89a6:	ec 82       	std	Y+4, r14	; 0x04
    89a8:	fd 82       	std	Y+5, r15	; 0x05

	spiDriver->endTransaction();	
    89aa:	88 81       	ld	r24, Y
    89ac:	99 81       	ldd	r25, Y+1	; 0x01
    89ae:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
}
    89b2:	df 91       	pop	r29
    89b4:	cf 91       	pop	r28
    89b6:	ff 90       	pop	r15
    89b8:	ef 90       	pop	r14
    89ba:	df 90       	pop	r13
    89bc:	cf 90       	pop	r12
    89be:	08 95       	ret

000089c0 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>:


void BarometerSensor::processBaroData()
{
    89c0:	2f 92       	push	r2
    89c2:	3f 92       	push	r3
    89c4:	4f 92       	push	r4
    89c6:	5f 92       	push	r5
    89c8:	6f 92       	push	r6
    89ca:	7f 92       	push	r7
    89cc:	8f 92       	push	r8
    89ce:	9f 92       	push	r9
    89d0:	af 92       	push	r10
    89d2:	bf 92       	push	r11
    89d4:	cf 92       	push	r12
    89d6:	df 92       	push	r13
    89d8:	ef 92       	push	r14
    89da:	ff 92       	push	r15
    89dc:	0f 93       	push	r16
    89de:	1f 93       	push	r17
    89e0:	cf 93       	push	r28
    89e2:	df 93       	push	r29
    89e4:	cd b7       	in	r28, 0x3d	; 61
    89e6:	de b7       	in	r29, 0x3e	; 62
    89e8:	c8 54       	subi	r28, 0x48	; 72
    89ea:	d1 09       	sbc	r29, r1
    89ec:	0f b6       	in	r0, 0x3f	; 63
    89ee:	f8 94       	cli
    89f0:	de bf       	out	0x3e, r29	; 62
    89f2:	0f be       	out	0x3f, r0	; 63
    89f4:	cd bf       	out	0x3d, r28	; 61
    89f6:	27 96       	adiw	r28, 0x07	; 7
    89f8:	9f af       	std	Y+63, r25	; 0x3f
    89fa:	8e af       	std	Y+62, r24	; 0x3e
    89fc:	27 97       	sbiw	r28, 0x07	; 7
	
	/**
	* Formulas from page 7 on MS5611-01BA03.pdf
	*/
	int64_t rawPress = rawPressure;
    89fe:	fc 01       	movw	r30, r24
    8a00:	86 81       	ldd	r24, Z+6	; 0x06
    8a02:	97 81       	ldd	r25, Z+7	; 0x07
    8a04:	a0 85       	ldd	r26, Z+8	; 0x08
    8a06:	b1 85       	ldd	r27, Z+9	; 0x09
    8a08:	8c 01       	movw	r16, r24
    8a0a:	9d 01       	movw	r18, r26
    8a0c:	40 e0       	ldi	r20, 0x00	; 0
    8a0e:	50 e0       	ldi	r21, 0x00	; 0
    8a10:	ba 01       	movw	r22, r20
    8a12:	8d 87       	std	Y+13, r24	; 0x0d
    8a14:	1e 87       	std	Y+14, r17	; 0x0e
    8a16:	2f 87       	std	Y+15, r18	; 0x0f
    8a18:	38 8b       	std	Y+16, r19	; 0x10
    8a1a:	49 8b       	std	Y+17, r20	; 0x11
    8a1c:	5a 8b       	std	Y+18, r21	; 0x12
    8a1e:	6b 8b       	std	Y+19, r22	; 0x13
    8a20:	7c 8b       	std	Y+20, r23	; 0x14
	int64_t rawTemp = rawTemperature;
    8a22:	82 80       	ldd	r8, Z+2	; 0x02
    8a24:	93 80       	ldd	r9, Z+3	; 0x03
    8a26:	a4 80       	ldd	r10, Z+4	; 0x04
    8a28:	b5 80       	ldd	r11, Z+5	; 0x05

	//I use the shift operators instead of division. (I.e. << 8 = dividing by 2^8).
	int64_t tempDifference = rawTemp - (referenceTemperature_Tref_C5 << 8);
    8a2a:	22 a9       	ldd	r18, Z+50	; 0x32
    8a2c:	33 a9       	ldd	r19, Z+51	; 0x33
    8a2e:	44 a9       	ldd	r20, Z+52	; 0x34
    8a30:	55 a9       	ldd	r21, Z+53	; 0x35
    8a32:	66 a9       	ldd	r22, Z+54	; 0x36
    8a34:	77 a9       	ldd	r23, Z+55	; 0x37
    8a36:	80 ad       	ldd	r24, Z+56	; 0x38
    8a38:	91 ad       	ldd	r25, Z+57	; 0x39
    8a3a:	08 e0       	ldi	r16, 0x08	; 8
    8a3c:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8a40:	62 2e       	mov	r6, r18
    8a42:	73 2e       	mov	r7, r19
    8a44:	b4 2f       	mov	r27, r20
    8a46:	a5 2f       	mov	r26, r21
    8a48:	f6 2f       	mov	r31, r22
    8a4a:	e7 2f       	mov	r30, r23
    8a4c:	08 2f       	mov	r16, r24
    8a4e:	19 2f       	mov	r17, r25
    8a50:	28 2d       	mov	r18, r8
    8a52:	39 2d       	mov	r19, r9
    8a54:	4a 2d       	mov	r20, r10
    8a56:	5b 2d       	mov	r21, r11
    8a58:	60 e0       	ldi	r22, 0x00	; 0
    8a5a:	70 e0       	ldi	r23, 0x00	; 0
    8a5c:	80 e0       	ldi	r24, 0x00	; 0
    8a5e:	90 e0       	ldi	r25, 0x00	; 0
    8a60:	a6 2c       	mov	r10, r6
    8a62:	b7 2c       	mov	r11, r7
    8a64:	cb 2e       	mov	r12, r27
    8a66:	da 2e       	mov	r13, r26
    8a68:	ef 2e       	mov	r14, r31
    8a6a:	fe 2e       	mov	r15, r30
    8a6c:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8a70:	32 2e       	mov	r3, r18
    8a72:	23 2e       	mov	r2, r19
    8a74:	49 83       	std	Y+1, r20	; 0x01
    8a76:	5a 83       	std	Y+2, r21	; 0x02
    8a78:	6b 83       	std	Y+3, r22	; 0x03
    8a7a:	7c 83       	std	Y+4, r23	; 0x04
    8a7c:	88 2e       	mov	r8, r24
    8a7e:	99 2e       	mov	r9, r25
	int64_t temp = 2000 + ((tempDifference * temperatureCoefficientOfTheTemperature_TEMPSENS_C6) >> 23);
    8a80:	27 96       	adiw	r28, 0x07	; 7
    8a82:	ee ad       	ldd	r30, Y+62	; 0x3e
    8a84:	ff ad       	ldd	r31, Y+63	; 0x3f
    8a86:	27 97       	sbiw	r28, 0x07	; 7
    8a88:	fa 96       	adiw	r30, 0x3a	; 58
    8a8a:	27 96       	adiw	r28, 0x07	; 7
    8a8c:	ae ad       	ldd	r26, Y+62	; 0x3e
    8a8e:	bf ad       	ldd	r27, Y+63	; 0x3f
    8a90:	27 97       	sbiw	r28, 0x07	; 7
    8a92:	da 96       	adiw	r26, 0x3a	; 58
    8a94:	ac 90       	ld	r10, X
    8a96:	b1 80       	ldd	r11, Z+1	; 0x01
    8a98:	c2 80       	ldd	r12, Z+2	; 0x02
    8a9a:	d3 80       	ldd	r13, Z+3	; 0x03
    8a9c:	e4 80       	ldd	r14, Z+4	; 0x04
    8a9e:	f5 80       	ldd	r15, Z+5	; 0x05
    8aa0:	06 81       	ldd	r16, Z+6	; 0x06
    8aa2:	17 81       	ldd	r17, Z+7	; 0x07
    8aa4:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8aa8:	07 e1       	ldi	r16, 0x17	; 23
    8aaa:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8aae:	29 8f       	std	Y+25, r18	; 0x19
    8ab0:	3a 8f       	std	Y+26, r19	; 0x1a
    8ab2:	4b 8f       	std	Y+27, r20	; 0x1b
    8ab4:	5c 8f       	std	Y+28, r21	; 0x1c
    8ab6:	6d 8f       	std	Y+29, r22	; 0x1d
    8ab8:	7e 8f       	std	Y+30, r23	; 0x1e
    8aba:	8f 8f       	std	Y+31, r24	; 0x1f
    8abc:	98 a3       	std	Y+32, r25	; 0x20
    8abe:	20 53       	subi	r18, 0x30	; 48
    8ac0:	38 4f       	sbci	r19, 0xF8	; 248
    8ac2:	4f 4f       	sbci	r20, 0xFF	; 255
    8ac4:	5f 4f       	sbci	r21, 0xFF	; 255
    8ac6:	6f 4f       	sbci	r22, 0xFF	; 255
    8ac8:	7f 4f       	sbci	r23, 0xFF	; 255
    8aca:	8f 4f       	sbci	r24, 0xFF	; 255
    8acc:	9f 4f       	sbci	r25, 0xFF	; 255
    8ace:	2d 8b       	std	Y+21, r18	; 0x15
    8ad0:	3e 8b       	std	Y+22, r19	; 0x16
    8ad2:	4f 8b       	std	Y+23, r20	; 0x17
    8ad4:	58 8f       	std	Y+24, r21	; 0x18
    8ad6:	69 a3       	std	Y+33, r22	; 0x21
    8ad8:	7a a3       	std	Y+34, r23	; 0x22
    8ada:	8b a3       	std	Y+35, r24	; 0x23
    8adc:	9c a3       	std	Y+36, r25	; 0x24
	int64_t tempOffset = (pressureSensitivityOffset_OFFt1_C2 << 16) + ((temperatureCoefficientOfPressureOffset_TCO_C4 * tempDifference) >> 7);
    8ade:	27 96       	adiw	r28, 0x07	; 7
    8ae0:	ee ad       	ldd	r30, Y+62	; 0x3e
    8ae2:	ff ad       	ldd	r31, Y+63	; 0x3f
    8ae4:	27 97       	sbiw	r28, 0x07	; 7
    8ae6:	22 8d       	ldd	r18, Z+26	; 0x1a
    8ae8:	33 8d       	ldd	r19, Z+27	; 0x1b
    8aea:	44 8d       	ldd	r20, Z+28	; 0x1c
    8aec:	55 8d       	ldd	r21, Z+29	; 0x1d
    8aee:	66 8d       	ldd	r22, Z+30	; 0x1e
    8af0:	77 8d       	ldd	r23, Z+31	; 0x1f
    8af2:	80 a1       	ldd	r24, Z+32	; 0x20
    8af4:	91 a1       	ldd	r25, Z+33	; 0x21
    8af6:	00 e1       	ldi	r16, 0x10	; 16
    8af8:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8afc:	2d 83       	std	Y+5, r18	; 0x05
    8afe:	3e 83       	std	Y+6, r19	; 0x06
    8b00:	4f 83       	std	Y+7, r20	; 0x07
    8b02:	58 87       	std	Y+8, r21	; 0x08
    8b04:	76 2e       	mov	r7, r22
    8b06:	67 2e       	mov	r6, r23
    8b08:	58 2e       	mov	r5, r24
    8b0a:	49 2e       	mov	r4, r25
    8b0c:	a2 a4       	ldd	r10, Z+42	; 0x2a
    8b0e:	b3 a4       	ldd	r11, Z+43	; 0x2b
    8b10:	c4 a4       	ldd	r12, Z+44	; 0x2c
    8b12:	d5 a4       	ldd	r13, Z+45	; 0x2d
    8b14:	e6 a4       	ldd	r14, Z+46	; 0x2e
    8b16:	f7 a4       	ldd	r15, Z+47	; 0x2f
    8b18:	00 a9       	ldd	r16, Z+48	; 0x30
    8b1a:	11 a9       	ldd	r17, Z+49	; 0x31
    8b1c:	23 2d       	mov	r18, r3
    8b1e:	32 2d       	mov	r19, r2
    8b20:	49 81       	ldd	r20, Y+1	; 0x01
    8b22:	5a 81       	ldd	r21, Y+2	; 0x02
    8b24:	6b 81       	ldd	r22, Y+3	; 0x03
    8b26:	7c 81       	ldd	r23, Y+4	; 0x04
    8b28:	88 2d       	mov	r24, r8
    8b2a:	99 2d       	mov	r25, r9
    8b2c:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8b30:	07 e0       	ldi	r16, 0x07	; 7
    8b32:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8b36:	a2 2e       	mov	r10, r18
    8b38:	b3 2e       	mov	r11, r19
    8b3a:	c4 2e       	mov	r12, r20
    8b3c:	d5 2e       	mov	r13, r21
    8b3e:	e6 2e       	mov	r14, r22
    8b40:	f7 2e       	mov	r15, r23
    8b42:	08 2f       	mov	r16, r24
    8b44:	19 2f       	mov	r17, r25
    8b46:	2d 81       	ldd	r18, Y+5	; 0x05
    8b48:	3e 81       	ldd	r19, Y+6	; 0x06
    8b4a:	4f 81       	ldd	r20, Y+7	; 0x07
    8b4c:	58 85       	ldd	r21, Y+8	; 0x08
    8b4e:	67 2d       	mov	r22, r7
    8b50:	76 2d       	mov	r23, r6
    8b52:	85 2d       	mov	r24, r5
    8b54:	94 2d       	mov	r25, r4
    8b56:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8b5a:	2d 83       	std	Y+5, r18	; 0x05
    8b5c:	3e 83       	std	Y+6, r19	; 0x06
    8b5e:	4f 83       	std	Y+7, r20	; 0x07
    8b60:	58 87       	std	Y+8, r21	; 0x08
    8b62:	6d a3       	std	Y+37, r22	; 0x25
    8b64:	7e a3       	std	Y+38, r23	; 0x26
    8b66:	8f a3       	std	Y+39, r24	; 0x27
    8b68:	98 a7       	std	Y+40, r25	; 0x28
	int64_t sensitivityAtTemp = (pressureSensitivity_SENSt1_C1 << 15) + ((temperatureCoefficientOfPressureSensitivity_TCS_C3 * tempDifference) >> 8);
    8b6a:	27 96       	adiw	r28, 0x07	; 7
    8b6c:	ae ad       	ldd	r26, Y+62	; 0x3e
    8b6e:	bf ad       	ldd	r27, Y+63	; 0x3f
    8b70:	27 97       	sbiw	r28, 0x07	; 7
    8b72:	52 96       	adiw	r26, 0x12	; 18
    8b74:	2c 91       	ld	r18, X
    8b76:	52 97       	sbiw	r26, 0x12	; 18
    8b78:	53 96       	adiw	r26, 0x13	; 19
    8b7a:	3c 91       	ld	r19, X
    8b7c:	53 97       	sbiw	r26, 0x13	; 19
    8b7e:	54 96       	adiw	r26, 0x14	; 20
    8b80:	4c 91       	ld	r20, X
    8b82:	54 97       	sbiw	r26, 0x14	; 20
    8b84:	55 96       	adiw	r26, 0x15	; 21
    8b86:	5c 91       	ld	r21, X
    8b88:	55 97       	sbiw	r26, 0x15	; 21
    8b8a:	56 96       	adiw	r26, 0x16	; 22
    8b8c:	6c 91       	ld	r22, X
    8b8e:	56 97       	sbiw	r26, 0x16	; 22
    8b90:	57 96       	adiw	r26, 0x17	; 23
    8b92:	7c 91       	ld	r23, X
    8b94:	57 97       	sbiw	r26, 0x17	; 23
    8b96:	58 96       	adiw	r26, 0x18	; 24
    8b98:	8c 91       	ld	r24, X
    8b9a:	58 97       	sbiw	r26, 0x18	; 24
    8b9c:	59 96       	adiw	r26, 0x19	; 25
    8b9e:	9c 91       	ld	r25, X
    8ba0:	59 97       	sbiw	r26, 0x19	; 25
    8ba2:	0f e0       	ldi	r16, 0x0F	; 15
    8ba4:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8ba8:	29 87       	std	Y+9, r18	; 0x09
    8baa:	3a 87       	std	Y+10, r19	; 0x0a
    8bac:	4b 87       	std	Y+11, r20	; 0x0b
    8bae:	5c 87       	std	Y+12, r21	; 0x0c
    8bb0:	76 2e       	mov	r7, r22
    8bb2:	67 2e       	mov	r6, r23
    8bb4:	58 2e       	mov	r5, r24
    8bb6:	49 2e       	mov	r4, r25
    8bb8:	92 96       	adiw	r26, 0x22	; 34
    8bba:	ac 90       	ld	r10, X
    8bbc:	92 97       	sbiw	r26, 0x22	; 34
    8bbe:	93 96       	adiw	r26, 0x23	; 35
    8bc0:	bc 90       	ld	r11, X
    8bc2:	93 97       	sbiw	r26, 0x23	; 35
    8bc4:	94 96       	adiw	r26, 0x24	; 36
    8bc6:	cc 90       	ld	r12, X
    8bc8:	94 97       	sbiw	r26, 0x24	; 36
    8bca:	95 96       	adiw	r26, 0x25	; 37
    8bcc:	dc 90       	ld	r13, X
    8bce:	95 97       	sbiw	r26, 0x25	; 37
    8bd0:	96 96       	adiw	r26, 0x26	; 38
    8bd2:	ec 90       	ld	r14, X
    8bd4:	96 97       	sbiw	r26, 0x26	; 38
    8bd6:	97 96       	adiw	r26, 0x27	; 39
    8bd8:	fc 90       	ld	r15, X
    8bda:	97 97       	sbiw	r26, 0x27	; 39
    8bdc:	98 96       	adiw	r26, 0x28	; 40
    8bde:	0c 91       	ld	r16, X
    8be0:	98 97       	sbiw	r26, 0x28	; 40
    8be2:	99 96       	adiw	r26, 0x29	; 41
    8be4:	1c 91       	ld	r17, X
    8be6:	23 2d       	mov	r18, r3
    8be8:	32 2d       	mov	r19, r2
    8bea:	49 81       	ldd	r20, Y+1	; 0x01
    8bec:	5a 81       	ldd	r21, Y+2	; 0x02
    8bee:	6b 81       	ldd	r22, Y+3	; 0x03
    8bf0:	7c 81       	ldd	r23, Y+4	; 0x04
    8bf2:	88 2d       	mov	r24, r8
    8bf4:	99 2d       	mov	r25, r9
    8bf6:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8bfa:	08 e0       	ldi	r16, 0x08	; 8
    8bfc:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8c00:	a2 2e       	mov	r10, r18
    8c02:	b3 2e       	mov	r11, r19
    8c04:	c4 2e       	mov	r12, r20
    8c06:	d5 2e       	mov	r13, r21
    8c08:	e6 2e       	mov	r14, r22
    8c0a:	f7 2e       	mov	r15, r23
    8c0c:	08 2f       	mov	r16, r24
    8c0e:	19 2f       	mov	r17, r25
    8c10:	29 85       	ldd	r18, Y+9	; 0x09
    8c12:	3a 85       	ldd	r19, Y+10	; 0x0a
    8c14:	4b 85       	ldd	r20, Y+11	; 0x0b
    8c16:	5c 85       	ldd	r21, Y+12	; 0x0c
    8c18:	67 2d       	mov	r22, r7
    8c1a:	76 2d       	mov	r23, r6
    8c1c:	85 2d       	mov	r24, r5
    8c1e:	94 2d       	mov	r25, r4
    8c20:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8c24:	29 87       	std	Y+9, r18	; 0x09
    8c26:	3a 87       	std	Y+10, r19	; 0x0a
    8c28:	4b 87       	std	Y+11, r20	; 0x0b
    8c2a:	5c 87       	std	Y+12, r21	; 0x0c
    8c2c:	76 2e       	mov	r7, r22
    8c2e:	47 2e       	mov	r4, r23
    8c30:	58 2e       	mov	r5, r24
    8c32:	69 2e       	mov	r6, r25
		
	/**
	 * The sensor's accuracy drops off when the temp is below 20*C. So the following is
	 * code to compensate for temperature below 20*C. 
	 */
	if (temp < 2000)
    8c34:	2d 89       	ldd	r18, Y+21	; 0x15
    8c36:	3e 89       	ldd	r19, Y+22	; 0x16
    8c38:	4f 89       	ldd	r20, Y+23	; 0x17
    8c3a:	58 8d       	ldd	r21, Y+24	; 0x18
    8c3c:	69 a1       	ldd	r22, Y+33	; 0x21
    8c3e:	7a a1       	ldd	r23, Y+34	; 0x22
    8c40:	8b a1       	ldd	r24, Y+35	; 0x23
    8c42:	9c a1       	ldd	r25, Y+36	; 0x24
    8c44:	2f 3c       	cpi	r18, 0xCF	; 207
    8c46:	37 40       	sbci	r19, 0x07	; 7
    8c48:	41 05       	cpc	r20, r1
    8c4a:	51 05       	cpc	r21, r1
    8c4c:	61 05       	cpc	r22, r1
    8c4e:	71 05       	cpc	r23, r1
    8c50:	81 05       	cpc	r24, r1
    8c52:	91 05       	cpc	r25, r1
    8c54:	11 f0       	breq	.+4      	; 0x8c5a <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    8c56:	0c f0       	brlt	.+2      	; 0x8c5a <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x29a>
    8c58:	97 c1       	rjmp	.+814    	; 0x8f88 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x5c8>
	{
		int64_t temp2 = (tempDifference * tempDifference) >> 31;
    8c5a:	a3 2c       	mov	r10, r3
    8c5c:	b2 2c       	mov	r11, r2
    8c5e:	c9 80       	ldd	r12, Y+1	; 0x01
    8c60:	da 80       	ldd	r13, Y+2	; 0x02
    8c62:	eb 80       	ldd	r14, Y+3	; 0x03
    8c64:	fc 80       	ldd	r15, Y+4	; 0x04
    8c66:	08 2d       	mov	r16, r8
    8c68:	19 2d       	mov	r17, r9
    8c6a:	23 2d       	mov	r18, r3
    8c6c:	32 2d       	mov	r19, r2
    8c6e:	4c 2d       	mov	r20, r12
    8c70:	5d 2d       	mov	r21, r13
    8c72:	6e 2d       	mov	r22, r14
    8c74:	7f 2d       	mov	r23, r15
    8c76:	88 2d       	mov	r24, r8
    8c78:	99 2d       	mov	r25, r9
    8c7a:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8c7e:	0f e1       	ldi	r16, 0x1F	; 31
    8c80:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8c84:	2d af       	std	Y+61, r18	; 0x3d
    8c86:	3e af       	std	Y+62, r19	; 0x3e
    8c88:	4f af       	std	Y+63, r20	; 0x3f
    8c8a:	21 96       	adiw	r28, 0x01	; 1
    8c8c:	5f af       	std	Y+63, r21	; 0x3f
    8c8e:	21 97       	sbiw	r28, 0x01	; 1
    8c90:	22 96       	adiw	r28, 0x02	; 2
    8c92:	6f af       	std	Y+63, r22	; 0x3f
    8c94:	22 97       	sbiw	r28, 0x02	; 2
    8c96:	23 96       	adiw	r28, 0x03	; 3
    8c98:	7f af       	std	Y+63, r23	; 0x3f
    8c9a:	23 97       	sbiw	r28, 0x03	; 3
    8c9c:	24 96       	adiw	r28, 0x04	; 4
    8c9e:	8f af       	std	Y+63, r24	; 0x3f
    8ca0:	24 97       	sbiw	r28, 0x04	; 4
    8ca2:	25 96       	adiw	r28, 0x05	; 5
    8ca4:	9f af       	std	Y+63, r25	; 0x3f
    8ca6:	25 97       	sbiw	r28, 0x05	; 5
		
		int64_t temporaryValue = (temp - 2000);
		temporaryValue *= temporaryValue;
    8ca8:	a9 8c       	ldd	r10, Y+25	; 0x19
    8caa:	ba 8c       	ldd	r11, Y+26	; 0x1a
    8cac:	cb 8c       	ldd	r12, Y+27	; 0x1b
    8cae:	dc 8c       	ldd	r13, Y+28	; 0x1c
    8cb0:	ed 8c       	ldd	r14, Y+29	; 0x1d
    8cb2:	fe 8c       	ldd	r15, Y+30	; 0x1e
    8cb4:	0f 8d       	ldd	r16, Y+31	; 0x1f
    8cb6:	18 a1       	ldd	r17, Y+32	; 0x20
    8cb8:	2a 2d       	mov	r18, r10
    8cba:	3b 2d       	mov	r19, r11
    8cbc:	4c 2d       	mov	r20, r12
    8cbe:	5d 2d       	mov	r21, r13
    8cc0:	6e 2d       	mov	r22, r14
    8cc2:	7f 2d       	mov	r23, r15
    8cc4:	80 2f       	mov	r24, r16
    8cc6:	91 2f       	mov	r25, r17
    8cc8:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8ccc:	2e ab       	std	Y+54, r18	; 0x36
    8cce:	a3 2f       	mov	r26, r19
    8cd0:	b4 2f       	mov	r27, r20
    8cd2:	e5 2f       	mov	r30, r21
    8cd4:	26 2e       	mov	r2, r22
    8cd6:	97 2e       	mov	r9, r23
    8cd8:	88 2e       	mov	r8, r24
    8cda:	39 2e       	mov	r3, r25
		
		int64_t tempOffset2 = 5 * (temporaryValue >> 1);
    8cdc:	4b 2f       	mov	r20, r27
    8cde:	5e 2f       	mov	r21, r30
    8ce0:	62 2d       	mov	r22, r2
    8ce2:	79 2d       	mov	r23, r9
    8ce4:	88 2d       	mov	r24, r8
    8ce6:	93 2d       	mov	r25, r3
    8ce8:	01 e0       	ldi	r16, 0x01	; 1
    8cea:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8cee:	a2 2e       	mov	r10, r18
    8cf0:	b3 2e       	mov	r11, r19
    8cf2:	c4 2e       	mov	r12, r20
    8cf4:	d5 2e       	mov	r13, r21
    8cf6:	e6 2e       	mov	r14, r22
    8cf8:	f7 2e       	mov	r15, r23
    8cfa:	f8 2f       	mov	r31, r24
    8cfc:	19 2f       	mov	r17, r25
    8cfe:	02 e0       	ldi	r16, 0x02	; 2
    8d00:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8d04:	0f 2f       	mov	r16, r31
    8d06:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8d0a:	2e a7       	std	Y+46, r18	; 0x2e
    8d0c:	3f a7       	std	Y+47, r19	; 0x2f
    8d0e:	48 ab       	std	Y+48, r20	; 0x30
    8d10:	59 ab       	std	Y+49, r21	; 0x31
    8d12:	6a ab       	std	Y+50, r22	; 0x32
    8d14:	7b ab       	std	Y+51, r23	; 0x33
    8d16:	8c ab       	std	Y+52, r24	; 0x34
    8d18:	9d ab       	std	Y+53, r25	; 0x35
    8d1a:	f2 2f       	mov	r31, r18
    8d1c:	3b 83       	std	Y+3, r19	; 0x03
    8d1e:	4c 83       	std	Y+4, r20	; 0x04
    8d20:	59 a7       	std	Y+41, r21	; 0x29
    8d22:	6a a7       	std	Y+42, r22	; 0x2a
    8d24:	7b a7       	std	Y+43, r23	; 0x2b
    8d26:	8c a7       	std	Y+44, r24	; 0x2c
    8d28:	9d a7       	std	Y+45, r25	; 0x2d
		int64_t sensitivity2 = 5 * (temporaryValue >> 2);	
    8d2a:	2e a9       	ldd	r18, Y+54	; 0x36
    8d2c:	3a 2f       	mov	r19, r26
    8d2e:	4b 2f       	mov	r20, r27
    8d30:	5e 2f       	mov	r21, r30
    8d32:	62 2d       	mov	r22, r2
    8d34:	79 2d       	mov	r23, r9
    8d36:	88 2d       	mov	r24, r8
    8d38:	93 2d       	mov	r25, r3
    8d3a:	02 e0       	ldi	r16, 0x02	; 2
    8d3c:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8d40:	a2 2e       	mov	r10, r18
    8d42:	b3 2e       	mov	r11, r19
    8d44:	c4 2e       	mov	r12, r20
    8d46:	d5 2e       	mov	r13, r21
    8d48:	e6 2e       	mov	r14, r22
    8d4a:	f7 2e       	mov	r15, r23
    8d4c:	e8 2f       	mov	r30, r24
    8d4e:	19 2f       	mov	r17, r25
    8d50:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8d54:	0e 2f       	mov	r16, r30
    8d56:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8d5a:	29 83       	std	Y+1, r18	; 0x01
    8d5c:	3e ab       	std	Y+54, r19	; 0x36
    8d5e:	4f ab       	std	Y+55, r20	; 0x37
    8d60:	58 af       	std	Y+56, r21	; 0x38
    8d62:	69 af       	std	Y+57, r22	; 0x39
    8d64:	7a af       	std	Y+58, r23	; 0x3a
    8d66:	8b af       	std	Y+59, r24	; 0x3b
    8d68:	9c af       	std	Y+60, r25	; 0x3c
    8d6a:	22 2e       	mov	r2, r18
    8d6c:	93 2e       	mov	r9, r19
    8d6e:	84 2e       	mov	r8, r20
    8d70:	b5 2f       	mov	r27, r21
    8d72:	36 2e       	mov	r3, r22
    8d74:	a7 2f       	mov	r26, r23
    8d76:	29 96       	adiw	r28, 0x09	; 9
    8d78:	8f af       	std	Y+63, r24	; 0x3f
    8d7a:	29 97       	sbiw	r28, 0x09	; 9
    8d7c:	28 96       	adiw	r28, 0x08	; 8
    8d7e:	9f af       	std	Y+63, r25	; 0x3f
    8d80:	28 97       	sbiw	r28, 0x08	; 8
							
		//Temperature correction code for below 15*c
		if (temp < -1500)
    8d82:	2d 89       	ldd	r18, Y+21	; 0x15
    8d84:	3e 89       	ldd	r19, Y+22	; 0x16
    8d86:	4f 89       	ldd	r20, Y+23	; 0x17
    8d88:	58 8d       	ldd	r21, Y+24	; 0x18
    8d8a:	69 a1       	ldd	r22, Y+33	; 0x21
    8d8c:	7a a1       	ldd	r23, Y+34	; 0x22
    8d8e:	8b a1       	ldd	r24, Y+35	; 0x23
    8d90:	9c a1       	ldd	r25, Y+36	; 0x24
    8d92:	24 32       	cpi	r18, 0x24	; 36
    8d94:	3a 4f       	sbci	r19, 0xFA	; 250
    8d96:	4f 4f       	sbci	r20, 0xFF	; 255
    8d98:	5f 4f       	sbci	r21, 0xFF	; 255
    8d9a:	6f 4f       	sbci	r22, 0xFF	; 255
    8d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    8d9e:	8f 4f       	sbci	r24, 0xFF	; 255
    8da0:	9f 4f       	sbci	r25, 0xFF	; 255
    8da2:	0c f0       	brlt	.+2      	; 0x8da6 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x3e6>
    8da4:	99 c0       	rjmp	.+306    	; 0x8ed8 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv+0x518>
		{
			int64_t temporaryValue2 = temp + 1500;
    8da6:	29 8d       	ldd	r18, Y+25	; 0x19
    8da8:	3a 8d       	ldd	r19, Y+26	; 0x1a
    8daa:	4b 8d       	ldd	r20, Y+27	; 0x1b
    8dac:	5c 8d       	ldd	r21, Y+28	; 0x1c
    8dae:	6d 8d       	ldd	r22, Y+29	; 0x1d
    8db0:	7e 8d       	ldd	r23, Y+30	; 0x1e
    8db2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8db4:	98 a1       	ldd	r25, Y+32	; 0x20
    8db6:	24 55       	subi	r18, 0x54	; 84
    8db8:	32 4f       	sbci	r19, 0xF2	; 242
    8dba:	4f 4f       	sbci	r20, 0xFF	; 255
    8dbc:	5f 4f       	sbci	r21, 0xFF	; 255
    8dbe:	6f 4f       	sbci	r22, 0xFF	; 255
    8dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    8dc2:	8f 4f       	sbci	r24, 0xFF	; 255
    8dc4:	9f 4f       	sbci	r25, 0xFF	; 255
			temporaryValue2 *= temporaryValue2;
    8dc6:	a2 2e       	mov	r10, r18
    8dc8:	b3 2e       	mov	r11, r19
    8dca:	c4 2e       	mov	r12, r20
    8dcc:	d5 2e       	mov	r13, r21
    8dce:	e6 2e       	mov	r14, r22
    8dd0:	f7 2e       	mov	r15, r23
    8dd2:	08 2f       	mov	r16, r24
    8dd4:	19 2f       	mov	r17, r25
    8dd6:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8dda:	b2 2f       	mov	r27, r18
    8ddc:	a3 2f       	mov	r26, r19
    8dde:	e4 2f       	mov	r30, r20
    8de0:	59 8f       	std	Y+25, r21	; 0x19
    8de2:	26 2e       	mov	r2, r22
    8de4:	37 2e       	mov	r3, r23
    8de6:	98 2e       	mov	r9, r24
    8de8:	89 2e       	mov	r8, r25
			
			tempOffset2 = tempOffset2 + 7 * temporaryValue2;
    8dea:	03 e0       	ldi	r16, 0x03	; 3
    8dec:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8df0:	ab 2e       	mov	r10, r27
    8df2:	ba 2e       	mov	r11, r26
    8df4:	ce 2e       	mov	r12, r30
    8df6:	d9 8c       	ldd	r13, Y+25	; 0x19
    8df8:	e2 2c       	mov	r14, r2
    8dfa:	f3 2c       	mov	r15, r3
    8dfc:	09 2d       	mov	r16, r9
    8dfe:	18 2d       	mov	r17, r8
    8e00:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8e04:	a2 2e       	mov	r10, r18
    8e06:	b3 2e       	mov	r11, r19
    8e08:	c4 2e       	mov	r12, r20
    8e0a:	d5 2e       	mov	r13, r21
    8e0c:	e6 2e       	mov	r14, r22
    8e0e:	f7 2e       	mov	r15, r23
    8e10:	08 2f       	mov	r16, r24
    8e12:	19 2f       	mov	r17, r25
    8e14:	2e a5       	ldd	r18, Y+46	; 0x2e
    8e16:	3f a5       	ldd	r19, Y+47	; 0x2f
    8e18:	48 a9       	ldd	r20, Y+48	; 0x30
    8e1a:	59 a9       	ldd	r21, Y+49	; 0x31
    8e1c:	6a a9       	ldd	r22, Y+50	; 0x32
    8e1e:	7b a9       	ldd	r23, Y+51	; 0x33
    8e20:	8c a9       	ldd	r24, Y+52	; 0x34
    8e22:	9d a9       	ldd	r25, Y+53	; 0x35
    8e24:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8e28:	f2 2f       	mov	r31, r18
    8e2a:	3b 83       	std	Y+3, r19	; 0x03
    8e2c:	4c 83       	std	Y+4, r20	; 0x04
    8e2e:	59 a7       	std	Y+41, r21	; 0x29
    8e30:	6a a7       	std	Y+42, r22	; 0x2a
    8e32:	7b a7       	std	Y+43, r23	; 0x2b
    8e34:	8c a7       	std	Y+44, r24	; 0x2c
    8e36:	9d a7       	std	Y+45, r25	; 0x2d
			sensitivity2 = sensitivity2 + 11 * (temporaryValue2 >> 1);
    8e38:	2b 2f       	mov	r18, r27
    8e3a:	3a 2f       	mov	r19, r26
    8e3c:	4e 2f       	mov	r20, r30
    8e3e:	59 8d       	ldd	r21, Y+25	; 0x19
    8e40:	62 2d       	mov	r22, r2
    8e42:	73 2d       	mov	r23, r3
    8e44:	89 2d       	mov	r24, r9
    8e46:	98 2d       	mov	r25, r8
    8e48:	01 e0       	ldi	r16, 0x01	; 1
    8e4a:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8e4e:	2a 8f       	std	Y+26, r18	; 0x1a
    8e50:	a3 2f       	mov	r26, r19
    8e52:	b4 2f       	mov	r27, r20
    8e54:	59 8f       	std	Y+25, r21	; 0x19
    8e56:	26 2e       	mov	r2, r22
    8e58:	97 2e       	mov	r9, r23
    8e5a:	88 2e       	mov	r8, r24
    8e5c:	39 2e       	mov	r3, r25
    8e5e:	4b 2f       	mov	r20, r27
    8e60:	62 2d       	mov	r22, r2
    8e62:	79 2d       	mov	r23, r9
    8e64:	88 2d       	mov	r24, r8
    8e66:	93 2d       	mov	r25, r3
    8e68:	02 e0       	ldi	r16, 0x02	; 2
    8e6a:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8e6e:	a2 2e       	mov	r10, r18
    8e70:	b3 2e       	mov	r11, r19
    8e72:	c4 2e       	mov	r12, r20
    8e74:	d5 2e       	mov	r13, r21
    8e76:	e6 2e       	mov	r14, r22
    8e78:	f7 2e       	mov	r15, r23
    8e7a:	e8 2f       	mov	r30, r24
    8e7c:	19 2f       	mov	r17, r25
    8e7e:	0e 94 e9 6f 	call	0xdfd2	; 0xdfd2 <__ashldi3>
    8e82:	0e 2f       	mov	r16, r30
    8e84:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8e88:	aa 8c       	ldd	r10, Y+26	; 0x1a
    8e8a:	ba 2e       	mov	r11, r26
    8e8c:	cb 2e       	mov	r12, r27
    8e8e:	d9 8c       	ldd	r13, Y+25	; 0x19
    8e90:	e2 2c       	mov	r14, r2
    8e92:	f9 2c       	mov	r15, r9
    8e94:	08 2d       	mov	r16, r8
    8e96:	13 2d       	mov	r17, r3
    8e98:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8e9c:	a2 2e       	mov	r10, r18
    8e9e:	b3 2e       	mov	r11, r19
    8ea0:	c4 2e       	mov	r12, r20
    8ea2:	d5 2e       	mov	r13, r21
    8ea4:	e6 2e       	mov	r14, r22
    8ea6:	f7 2e       	mov	r15, r23
    8ea8:	08 2f       	mov	r16, r24
    8eaa:	19 2f       	mov	r17, r25
    8eac:	29 81       	ldd	r18, Y+1	; 0x01
    8eae:	3e a9       	ldd	r19, Y+54	; 0x36
    8eb0:	4f a9       	ldd	r20, Y+55	; 0x37
    8eb2:	58 ad       	ldd	r21, Y+56	; 0x38
    8eb4:	69 ad       	ldd	r22, Y+57	; 0x39
    8eb6:	7a ad       	ldd	r23, Y+58	; 0x3a
    8eb8:	8b ad       	ldd	r24, Y+59	; 0x3b
    8eba:	9c ad       	ldd	r25, Y+60	; 0x3c
    8ebc:	0e 94 07 70 	call	0xe00e	; 0xe00e <__adddi3>
    8ec0:	22 2e       	mov	r2, r18
    8ec2:	93 2e       	mov	r9, r19
    8ec4:	84 2e       	mov	r8, r20
    8ec6:	b5 2f       	mov	r27, r21
    8ec8:	36 2e       	mov	r3, r22
    8eca:	a7 2f       	mov	r26, r23
    8ecc:	29 96       	adiw	r28, 0x09	; 9
    8ece:	8f af       	std	Y+63, r24	; 0x3f
    8ed0:	29 97       	sbiw	r28, 0x09	; 9
    8ed2:	28 96       	adiw	r28, 0x08	; 8
    8ed4:	9f af       	std	Y+63, r25	; 0x3f
    8ed6:	28 97       	sbiw	r28, 0x08	; 8
		}
		
				
		temp = temp - temp2;
    8ed8:	2d 89       	ldd	r18, Y+21	; 0x15
    8eda:	3e 89       	ldd	r19, Y+22	; 0x16
    8edc:	4f 89       	ldd	r20, Y+23	; 0x17
    8ede:	58 8d       	ldd	r21, Y+24	; 0x18
    8ee0:	69 a1       	ldd	r22, Y+33	; 0x21
    8ee2:	7a a1       	ldd	r23, Y+34	; 0x22
    8ee4:	8b a1       	ldd	r24, Y+35	; 0x23
    8ee6:	9c a1       	ldd	r25, Y+36	; 0x24
    8ee8:	ad ac       	ldd	r10, Y+61	; 0x3d
    8eea:	be ac       	ldd	r11, Y+62	; 0x3e
    8eec:	cf ac       	ldd	r12, Y+63	; 0x3f
    8eee:	21 96       	adiw	r28, 0x01	; 1
    8ef0:	df ac       	ldd	r13, Y+63	; 0x3f
    8ef2:	21 97       	sbiw	r28, 0x01	; 1
    8ef4:	22 96       	adiw	r28, 0x02	; 2
    8ef6:	ef ac       	ldd	r14, Y+63	; 0x3f
    8ef8:	22 97       	sbiw	r28, 0x02	; 2
    8efa:	23 96       	adiw	r28, 0x03	; 3
    8efc:	ff ac       	ldd	r15, Y+63	; 0x3f
    8efe:	23 97       	sbiw	r28, 0x03	; 3
    8f00:	24 96       	adiw	r28, 0x04	; 4
    8f02:	0f ad       	ldd	r16, Y+63	; 0x3f
    8f04:	24 97       	sbiw	r28, 0x04	; 4
    8f06:	25 96       	adiw	r28, 0x05	; 5
    8f08:	1f ad       	ldd	r17, Y+63	; 0x3f
    8f0a:	25 97       	sbiw	r28, 0x05	; 5
    8f0c:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8f10:	2d 8b       	std	Y+21, r18	; 0x15
    8f12:	3e 8b       	std	Y+22, r19	; 0x16
    8f14:	4f 8b       	std	Y+23, r20	; 0x17
    8f16:	58 8f       	std	Y+24, r21	; 0x18
		tempOffset = tempOffset - tempOffset2;
    8f18:	2d 81       	ldd	r18, Y+5	; 0x05
    8f1a:	3e 81       	ldd	r19, Y+6	; 0x06
    8f1c:	4f 81       	ldd	r20, Y+7	; 0x07
    8f1e:	58 85       	ldd	r21, Y+8	; 0x08
    8f20:	6d a1       	ldd	r22, Y+37	; 0x25
    8f22:	7e a1       	ldd	r23, Y+38	; 0x26
    8f24:	8f a1       	ldd	r24, Y+39	; 0x27
    8f26:	98 a5       	ldd	r25, Y+40	; 0x28
    8f28:	af 2e       	mov	r10, r31
    8f2a:	bb 80       	ldd	r11, Y+3	; 0x03
    8f2c:	cc 80       	ldd	r12, Y+4	; 0x04
    8f2e:	d9 a4       	ldd	r13, Y+41	; 0x29
    8f30:	ea a4       	ldd	r14, Y+42	; 0x2a
    8f32:	fb a4       	ldd	r15, Y+43	; 0x2b
    8f34:	0c a5       	ldd	r16, Y+44	; 0x2c
    8f36:	1d a5       	ldd	r17, Y+45	; 0x2d
    8f38:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8f3c:	2d 83       	std	Y+5, r18	; 0x05
    8f3e:	3e 83       	std	Y+6, r19	; 0x06
    8f40:	4f 83       	std	Y+7, r20	; 0x07
    8f42:	58 87       	std	Y+8, r21	; 0x08
    8f44:	6d a3       	std	Y+37, r22	; 0x25
    8f46:	7e a3       	std	Y+38, r23	; 0x26
    8f48:	8f a3       	std	Y+39, r24	; 0x27
    8f4a:	98 a7       	std	Y+40, r25	; 0x28
		sensitivityAtTemp = sensitivityAtTemp - sensitivity2;
    8f4c:	29 85       	ldd	r18, Y+9	; 0x09
    8f4e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8f50:	4b 85       	ldd	r20, Y+11	; 0x0b
    8f52:	5c 85       	ldd	r21, Y+12	; 0x0c
    8f54:	67 2d       	mov	r22, r7
    8f56:	74 2d       	mov	r23, r4
    8f58:	85 2d       	mov	r24, r5
    8f5a:	96 2d       	mov	r25, r6
    8f5c:	a2 2c       	mov	r10, r2
    8f5e:	b9 2c       	mov	r11, r9
    8f60:	c8 2c       	mov	r12, r8
    8f62:	db 2e       	mov	r13, r27
    8f64:	e3 2c       	mov	r14, r3
    8f66:	fa 2e       	mov	r15, r26
    8f68:	29 96       	adiw	r28, 0x09	; 9
    8f6a:	0f ad       	ldd	r16, Y+63	; 0x3f
    8f6c:	29 97       	sbiw	r28, 0x09	; 9
    8f6e:	28 96       	adiw	r28, 0x08	; 8
    8f70:	1f ad       	ldd	r17, Y+63	; 0x3f
    8f72:	28 97       	sbiw	r28, 0x08	; 8
    8f74:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8f78:	29 87       	std	Y+9, r18	; 0x09
    8f7a:	3a 87       	std	Y+10, r19	; 0x0a
    8f7c:	4b 87       	std	Y+11, r20	; 0x0b
    8f7e:	5c 87       	std	Y+12, r21	; 0x0c
    8f80:	76 2e       	mov	r7, r22
    8f82:	47 2e       	mov	r4, r23
    8f84:	58 2e       	mov	r5, r24
    8f86:	69 2e       	mov	r6, r25
	}
	
	pressureMillibars = (((((rawPress * sensitivityAtTemp) >> 21) - tempOffset)) >> 15);
    8f88:	a9 84       	ldd	r10, Y+9	; 0x09
    8f8a:	ba 84       	ldd	r11, Y+10	; 0x0a
    8f8c:	cb 84       	ldd	r12, Y+11	; 0x0b
    8f8e:	dc 84       	ldd	r13, Y+12	; 0x0c
    8f90:	e7 2c       	mov	r14, r7
    8f92:	f4 2c       	mov	r15, r4
    8f94:	05 2d       	mov	r16, r5
    8f96:	16 2d       	mov	r17, r6
    8f98:	2d 85       	ldd	r18, Y+13	; 0x0d
    8f9a:	3e 85       	ldd	r19, Y+14	; 0x0e
    8f9c:	4f 85       	ldd	r20, Y+15	; 0x0f
    8f9e:	58 89       	ldd	r21, Y+16	; 0x10
    8fa0:	60 e0       	ldi	r22, 0x00	; 0
    8fa2:	70 e0       	ldi	r23, 0x00	; 0
    8fa4:	80 e0       	ldi	r24, 0x00	; 0
    8fa6:	90 e0       	ldi	r25, 0x00	; 0
    8fa8:	0e 94 8e 6f 	call	0xdf1c	; 0xdf1c <__muldi3>
    8fac:	05 e1       	ldi	r16, 0x15	; 21
    8fae:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8fb2:	ad 80       	ldd	r10, Y+5	; 0x05
    8fb4:	be 80       	ldd	r11, Y+6	; 0x06
    8fb6:	cf 80       	ldd	r12, Y+7	; 0x07
    8fb8:	d8 84       	ldd	r13, Y+8	; 0x08
    8fba:	ed a0       	ldd	r14, Y+37	; 0x25
    8fbc:	fe a0       	ldd	r15, Y+38	; 0x26
    8fbe:	0f a1       	ldd	r16, Y+39	; 0x27
    8fc0:	18 a5       	ldd	r17, Y+40	; 0x28
    8fc2:	0e 94 10 70 	call	0xe020	; 0xe020 <__subdi3>
    8fc6:	0f e0       	ldi	r16, 0x0F	; 15
    8fc8:	0e 94 f8 6f 	call	0xdff0	; 0xdff0 <__ashrdi3>
    8fcc:	27 96       	adiw	r28, 0x07	; 7
    8fce:	ae ad       	ldd	r26, Y+62	; 0x3e
    8fd0:	bf ad       	ldd	r27, Y+63	; 0x3f
    8fd2:	27 97       	sbiw	r28, 0x07	; 7
    8fd4:	1e 96       	adiw	r26, 0x0e	; 14
    8fd6:	2c 93       	st	X, r18
    8fd8:	1e 97       	sbiw	r26, 0x0e	; 14
    8fda:	1f 96       	adiw	r26, 0x0f	; 15
    8fdc:	3c 93       	st	X, r19
    8fde:	1f 97       	sbiw	r26, 0x0f	; 15
    8fe0:	50 96       	adiw	r26, 0x10	; 16
    8fe2:	4c 93       	st	X, r20
    8fe4:	50 97       	sbiw	r26, 0x10	; 16
    8fe6:	51 96       	adiw	r26, 0x11	; 17
    8fe8:	5c 93       	st	X, r21
    8fea:	51 97       	sbiw	r26, 0x11	; 17
	temperatureCelcius = temp;
    8fec:	3d 89       	ldd	r19, Y+21	; 0x15
    8fee:	2e 89       	ldd	r18, Y+22	; 0x16
    8ff0:	9f 89       	ldd	r25, Y+23	; 0x17
    8ff2:	88 8d       	ldd	r24, Y+24	; 0x18
    8ff4:	1a 96       	adiw	r26, 0x0a	; 10
    8ff6:	3c 93       	st	X, r19
    8ff8:	1a 97       	sbiw	r26, 0x0a	; 10
    8ffa:	1b 96       	adiw	r26, 0x0b	; 11
    8ffc:	2c 93       	st	X, r18
    8ffe:	1b 97       	sbiw	r26, 0x0b	; 11
    9000:	1c 96       	adiw	r26, 0x0c	; 12
    9002:	9c 93       	st	X, r25
    9004:	1c 97       	sbiw	r26, 0x0c	; 12
    9006:	1d 96       	adiw	r26, 0x0d	; 13
    9008:	8c 93       	st	X, r24
}
    900a:	c8 5b       	subi	r28, 0xB8	; 184
    900c:	df 4f       	sbci	r29, 0xFF	; 255
    900e:	0f b6       	in	r0, 0x3f	; 63
    9010:	f8 94       	cli
    9012:	de bf       	out	0x3e, r29	; 62
    9014:	0f be       	out	0x3f, r0	; 63
    9016:	cd bf       	out	0x3d, r28	; 61
    9018:	df 91       	pop	r29
    901a:	cf 91       	pop	r28
    901c:	1f 91       	pop	r17
    901e:	0f 91       	pop	r16
    9020:	ff 90       	pop	r15
    9022:	ef 90       	pop	r14
    9024:	df 90       	pop	r13
    9026:	cf 90       	pop	r12
    9028:	bf 90       	pop	r11
    902a:	af 90       	pop	r10
    902c:	9f 90       	pop	r9
    902e:	8f 90       	pop	r8
    9030:	7f 90       	pop	r7
    9032:	6f 90       	pop	r6
    9034:	5f 90       	pop	r5
    9036:	4f 90       	pop	r4
    9038:	3f 90       	pop	r3
    903a:	2f 90       	pop	r2
    903c:	08 95       	ret

0000903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>:
	
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
    903e:	af 92       	push	r10
    9040:	bf 92       	push	r11
    9042:	cf 92       	push	r12
    9044:	df 92       	push	r13
    9046:	ef 92       	push	r14
    9048:	ff 92       	push	r15
    904a:	0f 93       	push	r16
    904c:	1f 93       	push	r17
    904e:	cf 93       	push	r28
    9050:	df 93       	push	r29
    9052:	1f 92       	push	r1
    9054:	cd b7       	in	r28, 0x3d	; 61
    9056:	de b7       	in	r29, 0x3e	; 62
    9058:	8c 01       	movw	r16, r24
	int status = 0;
	byte b = 0;
    905a:	19 82       	std	Y+1, r1	; 0x01
	
	unsigned long currentFourBytes = 0;
    905c:	c1 2c       	mov	r12, r1
    905e:	d1 2c       	mov	r13, r1
    9060:	76 01       	movw	r14, r12
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
	int status = 0;
    9062:	80 e0       	ldi	r24, 0x00	; 0
    9064:	90 e0       	ldi	r25, 0x00	; 0
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
    9066:	00 97       	sbiw	r24, 0x00	; 0
    9068:	09 f0       	breq	.+2      	; 0x906c <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x2e>
    906a:	5a c0       	rjmp	.+180    	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    906c:	21 e0       	ldi	r18, 0x01	; 1
    906e:	c2 16       	cp	r12, r18
    9070:	25 e0       	ldi	r18, 0x05	; 5
    9072:	d2 06       	cpc	r13, r18
    9074:	22 e6       	ldi	r18, 0x62	; 98
    9076:	e2 06       	cpc	r14, r18
    9078:	25 eb       	ldi	r18, 0xB5	; 181
    907a:	f2 06       	cpc	r15, r18
    907c:	09 f4       	brne	.+2      	; 0x9080 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x42>
    907e:	4a c0       	rjmp	.+148    	; 0x9114 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xd6>
    9080:	c1 14       	cp	r12, r1
    9082:	a5 e0       	ldi	r26, 0x05	; 5
    9084:	da 06       	cpc	r13, r26
    9086:	a2 e6       	ldi	r26, 0x62	; 98
    9088:	ea 06       	cpc	r14, r26
    908a:	a5 eb       	ldi	r26, 0xB5	; 181
    908c:	fa 06       	cpc	r15, r26
    908e:	01 f5       	brne	.+64     	; 0x90d0 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x92>
    9090:	41 c0       	rjmp	.+130    	; 0x9114 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xd6>
    9092:	b1 e0       	ldi	r27, 0x01	; 1
    9094:	ab 1a       	sub	r10, r27
    9096:	b1 08       	sbc	r11, r1
		ackNackData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
    9098:	19 f0       	breq	.+6      	; 0x90a0 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x62>
    909a:	00 97       	sbiw	r24, 0x00	; 0
    909c:	69 f1       	breq	.+90     	; 0x90f8 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xba>
    909e:	40 c0       	rjmp	.+128    	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
		
			ackNackData[i] = b;
		}
	}	
	
	if (status == 0 && currentFourBytes == ackHeaderID)
    90a0:	00 97       	sbiw	r24, 0x00	; 0
    90a2:	f1 f5       	brne	.+124    	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    90a4:	e1 e0       	ldi	r30, 0x01	; 1
    90a6:	ce 16       	cp	r12, r30
    90a8:	e5 e0       	ldi	r30, 0x05	; 5
    90aa:	de 06       	cpc	r13, r30
    90ac:	e2 e6       	ldi	r30, 0x62	; 98
    90ae:	ee 06       	cpc	r14, r30
    90b0:	e5 eb       	ldi	r30, 0xB5	; 181
    90b2:	fe 06       	cpc	r15, r30
    90b4:	49 f0       	breq	.+18     	; 0x90c8 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x8a>
	{
		return 0;
	}else if (status == 0 && currentFourBytes == nackHeaderID)
    90b6:	c1 14       	cp	r12, r1
    90b8:	f5 e0       	ldi	r31, 0x05	; 5
    90ba:	df 06       	cpc	r13, r31
    90bc:	f2 e6       	ldi	r31, 0x62	; 98
    90be:	ef 06       	cpc	r14, r31
    90c0:	f5 eb       	ldi	r31, 0xB5	; 181
    90c2:	ff 06       	cpc	r15, r31
    90c4:	11 f0       	breq	.+4      	; 0x90ca <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x8c>
    90c6:	2c c0       	rjmp	.+88     	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
    90c8:	2b c0       	rjmp	.+86     	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
	{
		return 1;
    90ca:	81 e0       	ldi	r24, 0x01	; 1
    90cc:	90 e0       	ldi	r25, 0x00	; 0
    90ce:	28 c0       	rjmp	.+80     	; 0x9120 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0xe2>
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != ackHeaderID && currentFourBytes != nackHeaderID)
	{
		status = serialDriver->receive(b);
    90d0:	d8 01       	movw	r26, r16
    90d2:	8d 91       	ld	r24, X+
    90d4:	9c 91       	ld	r25, X
    90d6:	dc 01       	movw	r26, r24
    90d8:	ed 91       	ld	r30, X+
    90da:	fc 91       	ld	r31, X
    90dc:	02 88       	ldd	r0, Z+18	; 0x12
    90de:	f3 89       	ldd	r31, Z+19	; 0x13
    90e0:	e0 2d       	mov	r30, r0
    90e2:	be 01       	movw	r22, r28
    90e4:	6f 5f       	subi	r22, 0xFF	; 255
    90e6:	7f 4f       	sbci	r23, 0xFF	; 255
    90e8:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    90ea:	fe 2c       	mov	r15, r14
    90ec:	ed 2c       	mov	r14, r13
    90ee:	dc 2c       	mov	r13, r12
    90f0:	cc 24       	eor	r12, r12
    90f2:	29 81       	ldd	r18, Y+1	; 0x01
    90f4:	c2 2a       	or	r12, r18
    90f6:	b7 cf       	rjmp	.-146    	; 0x9066 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x28>
		
	
		//while loop for reading data if status == 0
		for (unsigned int i = 4; i < sizeof(ackNackData) && status == 0; i++)
		{
			status = serialDriver->receive(b);
    90f8:	f8 01       	movw	r30, r16
    90fa:	80 81       	ld	r24, Z
    90fc:	91 81       	ldd	r25, Z+1	; 0x01
    90fe:	dc 01       	movw	r26, r24
    9100:	ed 91       	ld	r30, X+
    9102:	fc 91       	ld	r31, X
    9104:	02 88       	ldd	r0, Z+18	; 0x12
    9106:	f3 89       	ldd	r31, Z+19	; 0x13
    9108:	e0 2d       	mov	r30, r0
    910a:	be 01       	movw	r22, r28
    910c:	6f 5f       	subi	r22, 0xFF	; 255
    910e:	7f 4f       	sbci	r23, 0xFF	; 255
    9110:	19 95       	eicall
    9112:	bf cf       	rjmp	.-130    	; 0x9092 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x54>
bool GPSSensor::processing = false;


int GPSSensor::receiveAckNack() 
{
	int status = 0;
    9114:	0f 2e       	mov	r0, r31
    9116:	f7 e0       	ldi	r31, 0x07	; 7
    9118:	af 2e       	mov	r10, r31
    911a:	b1 2c       	mov	r11, r1
    911c:	f0 2d       	mov	r31, r0
    911e:	b9 cf       	rjmp	.-142    	; 0x9092 <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv+0x54>
	{
		return 1;
	}
		
	return status;
}
    9120:	0f 90       	pop	r0
    9122:	df 91       	pop	r29
    9124:	cf 91       	pop	r28
    9126:	1f 91       	pop	r17
    9128:	0f 91       	pop	r16
    912a:	ff 90       	pop	r15
    912c:	ef 90       	pop	r14
    912e:	df 90       	pop	r13
    9130:	cf 90       	pop	r12
    9132:	bf 90       	pop	r11
    9134:	af 90       	pop	r10
    9136:	08 95       	ret

00009138 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>:


int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
{
    9138:	4f 92       	push	r4
    913a:	5f 92       	push	r5
    913c:	6f 92       	push	r6
    913e:	7f 92       	push	r7
    9140:	8f 92       	push	r8
    9142:	9f 92       	push	r9
    9144:	af 92       	push	r10
    9146:	bf 92       	push	r11
    9148:	cf 92       	push	r12
    914a:	df 92       	push	r13
    914c:	ef 92       	push	r14
    914e:	ff 92       	push	r15
    9150:	0f 93       	push	r16
    9152:	1f 93       	push	r17
    9154:	cf 93       	push	r28
    9156:	df 93       	push	r29
    9158:	1f 92       	push	r1
    915a:	cd b7       	in	r28, 0x3d	; 61
    915c:	de b7       	in	r29, 0x3e	; 62
    915e:	6c 01       	movw	r12, r24
    9160:	2a 01       	movw	r4, r20
    9162:	3b 01       	movw	r6, r22
    9164:	79 01       	movw	r14, r18
	int status = 0;
	byte b = 0;
    9166:	19 82       	std	Y+1, r1	; 0x01
	
	unsigned long currentFourBytes = 0;
    9168:	81 2c       	mov	r8, r1
    916a:	91 2c       	mov	r9, r1
    916c:	54 01       	movw	r10, r8
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    916e:	84 14       	cp	r8, r4
    9170:	95 04       	cpc	r9, r5
    9172:	a6 04       	cpc	r10, r6
    9174:	b7 04       	cpc	r11, r7
    9176:	e1 f4       	brne	.+56     	; 0x91b0 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x78>
    9178:	07 c0       	rjmp	.+14     	; 0x9188 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x50>
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    917a:	a0 16       	cp	r10, r16
    917c:	b1 06       	cpc	r11, r17
    917e:	0c f0       	brlt	.+2      	; 0x9182 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x4a>
    9180:	42 c0       	rjmp	.+132    	; 0x9206 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
    9182:	00 97       	sbiw	r24, 0x00	; 0
    9184:	59 f1       	breq	.+86     	; 0x91dc <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xa4>
    9186:	3f c0       	rjmp	.+126    	; 0x9206 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
	if (status == 0)
	{
		/**
		* Populate the message array with the first four bytes.
		*/
		msgData[0] = 0xFF & (currentFourBytes >> 24);
    9188:	d7 01       	movw	r26, r14
    918a:	bc 92       	st	X, r11
		msgData[1] = 0xFF & (currentFourBytes >> 16);
    918c:	11 96       	adiw	r26, 0x01	; 1
    918e:	ac 92       	st	X, r10
    9190:	11 97       	sbiw	r26, 0x01	; 1
		msgData[2] = 0xFF & (currentFourBytes >> 8);
    9192:	12 96       	adiw	r26, 0x02	; 2
    9194:	9c 92       	st	X, r9
    9196:	12 97       	sbiw	r26, 0x02	; 2
		msgData[3] = 0xFF & currentFourBytes;
    9198:	13 96       	adiw	r26, 0x03	; 3
    919a:	8c 92       	st	X, r8
		
	return status;
}


int GPSSensor::receiveGpsData(unsigned long desiredHeaderID, byte * msgData, int msgDataSize ) 
    919c:	b4 e0       	ldi	r27, 0x04	; 4
    919e:	eb 0e       	add	r14, r27
    91a0:	f1 1c       	adc	r15, r1
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    91a2:	68 94       	set
    91a4:	aa 24       	eor	r10, r10
    91a6:	a2 f8       	bld	r10, 2
    91a8:	b1 2c       	mov	r11, r1
    91aa:	80 e0       	ldi	r24, 0x00	; 0
    91ac:	90 e0       	ldi	r25, 0x00	; 0
    91ae:	e5 cf       	rjmp	.-54     	; 0x917a <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x42>
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
	{
		status = serialDriver->receive(b);
    91b0:	f6 01       	movw	r30, r12
    91b2:	80 81       	ld	r24, Z
    91b4:	91 81       	ldd	r25, Z+1	; 0x01
    91b6:	dc 01       	movw	r26, r24
    91b8:	ed 91       	ld	r30, X+
    91ba:	fc 91       	ld	r31, X
    91bc:	02 88       	ldd	r0, Z+18	; 0x12
    91be:	f3 89       	ldd	r31, Z+19	; 0x13
    91c0:	e0 2d       	mov	r30, r0
    91c2:	be 01       	movw	r22, r28
    91c4:	6f 5f       	subi	r22, 0xFF	; 255
    91c6:	7f 4f       	sbci	r23, 0xFF	; 255
    91c8:	19 95       	eicall
		currentFourBytes = currentFourBytes << 8 | b;
    91ca:	ba 2c       	mov	r11, r10
    91cc:	a9 2c       	mov	r10, r9
    91ce:	98 2c       	mov	r9, r8
    91d0:	88 24       	eor	r8, r8
    91d2:	29 81       	ldd	r18, Y+1	; 0x01
    91d4:	82 2a       	or	r8, r18
	* GPS was canceled half way, the next message send would result in
	* an nack half way through the next message transmission, so you have
	* to ensure that the message that is being read, is the desired message.
	* Ignore status = -2 because if you get one byte overrun, you might not ever 'catch up' to receive new data.
	*/
	while (status == 0 && currentFourBytes != desiredHeaderID)
    91d6:	00 97       	sbiw	r24, 0x00	; 0
    91d8:	b1 f4       	brne	.+44     	; 0x9206 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0xce>
    91da:	c9 cf       	rjmp	.-110    	; 0x916e <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x36>
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
		{
			status = serialDriver->receive(b);
    91dc:	f6 01       	movw	r30, r12
    91de:	80 81       	ld	r24, Z
    91e0:	91 81       	ldd	r25, Z+1	; 0x01
    91e2:	dc 01       	movw	r26, r24
    91e4:	ed 91       	ld	r30, X+
    91e6:	fc 91       	ld	r31, X
    91e8:	02 88       	ldd	r0, Z+18	; 0x12
    91ea:	f3 89       	ldd	r31, Z+19	; 0x13
    91ec:	e0 2d       	mov	r30, r0
    91ee:	be 01       	movw	r22, r28
    91f0:	6f 5f       	subi	r22, 0xFF	; 255
    91f2:	7f 4f       	sbci	r23, 0xFF	; 255
    91f4:	19 95       	eicall
		
			msgData[i] = b;
    91f6:	29 81       	ldd	r18, Y+1	; 0x01
    91f8:	f7 01       	movw	r30, r14
    91fa:	21 93       	st	Z+, r18
    91fc:	7f 01       	movw	r14, r30
		msgData[3] = 0xFF & currentFourBytes;
		
		
	
		//while loop for reading data if status == 0
		for (int i = 4; i < msgDataSize && status == 0; i++)
    91fe:	ff ef       	ldi	r31, 0xFF	; 255
    9200:	af 1a       	sub	r10, r31
    9202:	bf 0a       	sbc	r11, r31
    9204:	ba cf       	rjmp	.-140    	; 0x917a <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi+0x42>
			msgData[i] = b;
		}
	}	
		
	return status;
}
    9206:	0f 90       	pop	r0
    9208:	df 91       	pop	r29
    920a:	cf 91       	pop	r28
    920c:	1f 91       	pop	r17
    920e:	0f 91       	pop	r16
    9210:	ff 90       	pop	r15
    9212:	ef 90       	pop	r14
    9214:	df 90       	pop	r13
    9216:	cf 90       	pop	r12
    9218:	bf 90       	pop	r11
    921a:	af 90       	pop	r10
    921c:	9f 90       	pop	r9
    921e:	8f 90       	pop	r8
    9220:	7f 90       	pop	r7
    9222:	6f 90       	pop	r6
    9224:	5f 90       	pop	r5
    9226:	4f 90       	pop	r4
    9228:	08 95       	ret

0000922a <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>:

int GPSSensor::readSensor(byte *pollMsg, int pollMsgSize, byte *msgData, int msgDataSize )
{
    922a:	af 92       	push	r10
    922c:	bf 92       	push	r11
    922e:	cf 92       	push	r12
    9230:	df 92       	push	r13
    9232:	ef 92       	push	r14
    9234:	ff 92       	push	r15
    9236:	0f 93       	push	r16
    9238:	1f 93       	push	r17
    923a:	cf 93       	push	r28
    923c:	df 93       	push	r29
    923e:	ec 01       	movw	r28, r24
    9240:	6b 01       	movw	r12, r22
    9242:	5a 01       	movw	r10, r20
    9244:	79 01       	movw	r14, r18
	
	//Clear the serial driver's buffer of any existing data.
	//serialDriver->clearBuffer();
	
	//Start timer
	serialDriver->startTimer();
    9246:	88 81       	ld	r24, Y
    9248:	99 81       	ldd	r25, Y+1	; 0x01
    924a:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <_ZN10helicopter7drivers12SerialDriver10startTimerEv>
	
	
	//Send poll command
	status = serialDriver->transmit((const char*)pollMsg, pollMsgSize);
    924e:	a5 01       	movw	r20, r10
    9250:	b6 01       	movw	r22, r12
    9252:	88 81       	ld	r24, Y
    9254:	99 81       	ldd	r25, Y+1	; 0x01
    9256:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
    925a:	5c 01       	movw	r10, r24
	
	if (status == 0)
    925c:	00 97       	sbiw	r24, 0x00	; 0
    925e:	99 f4       	brne	.+38     	; 0x9286 <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i+0x5c>
		 * against the incoming header and ID field.
		 */
		unsigned long desiredHeaderID = (unsigned long) pollMsg[0] << 24 | 
										(unsigned long) pollMsg[1] << 16 | 
										(unsigned long) pollMsg[2] << 8 | 
										(unsigned long) pollMsg[3];
    9260:	f6 01       	movw	r30, r12
    9262:	80 81       	ld	r24, Z
    9264:	41 81       	ldd	r20, Z+1	; 0x01
    9266:	50 e0       	ldi	r21, 0x00	; 0
    9268:	60 e0       	ldi	r22, 0x00	; 0
    926a:	70 e0       	ldi	r23, 0x00	; 0
    926c:	ba 01       	movw	r22, r20
    926e:	55 27       	eor	r21, r21
    9270:	44 27       	eor	r20, r20
    9272:	78 2b       	or	r23, r24
    9274:	83 81       	ldd	r24, Z+3	; 0x03
    9276:	48 2b       	or	r20, r24
    9278:	82 81       	ldd	r24, Z+2	; 0x02
    927a:	58 2b       	or	r21, r24
										
		status = receiveGpsData(desiredHeaderID, msgData, msgDataSize);
    927c:	97 01       	movw	r18, r14
    927e:	ce 01       	movw	r24, r28
    9280:	0e 94 9c 48 	call	0x9138	; 0x9138 <_ZN10helicopter7sensors9GPSSensor14receiveGpsDataEmPhi>
    9284:	5c 01       	movw	r10, r24

	}
	

	//Stop timer
	serialDriver->stopTimer();
    9286:	88 81       	ld	r24, Y
    9288:	99 81       	ldd	r25, Y+1	; 0x01
    928a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_ZN10helicopter7drivers12SerialDriver9stopTimerEv>
	
	return status;
}
    928e:	8a 2d       	mov	r24, r10
    9290:	9b 2d       	mov	r25, r11
    9292:	df 91       	pop	r29
    9294:	cf 91       	pop	r28
    9296:	1f 91       	pop	r17
    9298:	0f 91       	pop	r16
    929a:	ff 90       	pop	r15
    929c:	ef 90       	pop	r14
    929e:	df 90       	pop	r13
    92a0:	cf 90       	pop	r12
    92a2:	bf 90       	pop	r11
    92a4:	af 90       	pop	r10
    92a6:	08 95       	ret

000092a8 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>:
	return status;
}


int GPSSensor::processSensorSolution()
{
    92a8:	fc 01       	movw	r30, r24
	int status = 0;
	
	if (navSolMsgReceived)
    92aa:	80 91 aa 03 	lds	r24, 0x03AA
    92ae:	88 23       	and	r24, r24
    92b0:	09 f4       	brne	.+2      	; 0x92b4 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0xc>
    92b2:	bd c0       	rjmp	.+378    	; 0x942e <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x186>
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];		
		*/
		

		positionFixStatus =  navSolMsgBuffer2[16] >= 3 ? VALID : INVALID;
    92b4:	80 91 bd 03 	lds	r24, 0x03BD
    92b8:	83 30       	cpi	r24, 0x03	; 3
    92ba:	10 f0       	brcs	.+4      	; 0x92c0 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18>
    92bc:	82 e0       	ldi	r24, 0x02	; 2
    92be:	01 c0       	rjmp	.+2      	; 0x92c2 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x1a>
    92c0:	81 e0       	ldi	r24, 0x01	; 1
    92c2:	82 a7       	std	Z+42, r24	; 0x2a

		//Parse position info
		xEcefCm =  ((long)navSolMsgBuffer2[21] << 24) | ((long)navSolMsgBuffer2[20] << 16) | ((long)navSolMsgBuffer2[19] << 8) | (long) navSolMsgBuffer2[18];
    92c4:	20 91 c2 03 	lds	r18, 0x03C2
    92c8:	80 91 c1 03 	lds	r24, 0x03C1
    92cc:	90 e0       	ldi	r25, 0x00	; 0
    92ce:	a0 e0       	ldi	r26, 0x00	; 0
    92d0:	b0 e0       	ldi	r27, 0x00	; 0
    92d2:	dc 01       	movw	r26, r24
    92d4:	99 27       	eor	r25, r25
    92d6:	88 27       	eor	r24, r24
    92d8:	b2 2b       	or	r27, r18
    92da:	20 91 bf 03 	lds	r18, 0x03BF
    92de:	82 2b       	or	r24, r18
    92e0:	20 91 c0 03 	lds	r18, 0x03C0
    92e4:	92 2b       	or	r25, r18
    92e6:	82 87       	std	Z+10, r24	; 0x0a
    92e8:	93 87       	std	Z+11, r25	; 0x0b
    92ea:	a4 87       	std	Z+12, r26	; 0x0c
    92ec:	b5 87       	std	Z+13, r27	; 0x0d
		yEcefCm =  ((long)navSolMsgBuffer2[25] << 24) | ((long)navSolMsgBuffer2[24] << 16) | ((long)navSolMsgBuffer2[23] << 8) | (long) navSolMsgBuffer2[22];
    92ee:	20 91 c6 03 	lds	r18, 0x03C6
    92f2:	80 91 c5 03 	lds	r24, 0x03C5
    92f6:	90 e0       	ldi	r25, 0x00	; 0
    92f8:	a0 e0       	ldi	r26, 0x00	; 0
    92fa:	b0 e0       	ldi	r27, 0x00	; 0
    92fc:	dc 01       	movw	r26, r24
    92fe:	99 27       	eor	r25, r25
    9300:	88 27       	eor	r24, r24
    9302:	b2 2b       	or	r27, r18
    9304:	20 91 c3 03 	lds	r18, 0x03C3
    9308:	82 2b       	or	r24, r18
    930a:	20 91 c4 03 	lds	r18, 0x03C4
    930e:	92 2b       	or	r25, r18
    9310:	86 87       	std	Z+14, r24	; 0x0e
    9312:	97 87       	std	Z+15, r25	; 0x0f
    9314:	a0 8b       	std	Z+16, r26	; 0x10
    9316:	b1 8b       	std	Z+17, r27	; 0x11
		zEcefCm =  ((long)navSolMsgBuffer2[29] << 24) | ((long)navSolMsgBuffer2[28] << 16) | ((long)navSolMsgBuffer2[27] << 8) | (long) navSolMsgBuffer2[26];
    9318:	20 91 ca 03 	lds	r18, 0x03CA
    931c:	80 91 c9 03 	lds	r24, 0x03C9
    9320:	90 e0       	ldi	r25, 0x00	; 0
    9322:	a0 e0       	ldi	r26, 0x00	; 0
    9324:	b0 e0       	ldi	r27, 0x00	; 0
    9326:	dc 01       	movw	r26, r24
    9328:	99 27       	eor	r25, r25
    932a:	88 27       	eor	r24, r24
    932c:	b2 2b       	or	r27, r18
    932e:	20 91 c7 03 	lds	r18, 0x03C7
    9332:	82 2b       	or	r24, r18
    9334:	20 91 c8 03 	lds	r18, 0x03C8
    9338:	92 2b       	or	r25, r18
    933a:	82 8b       	std	Z+18, r24	; 0x12
    933c:	93 8b       	std	Z+19, r25	; 0x13
    933e:	a4 8b       	std	Z+20, r26	; 0x14
    9340:	b5 8b       	std	Z+21, r27	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsgBuffer2[33] << 24) | ((long)navSolMsgBuffer2[32] << 16) | ((long)navSolMsgBuffer2[31] << 8) | (long) navSolMsgBuffer2[30];
    9342:	20 91 ce 03 	lds	r18, 0x03CE
    9346:	80 91 cd 03 	lds	r24, 0x03CD
    934a:	90 e0       	ldi	r25, 0x00	; 0
    934c:	a0 e0       	ldi	r26, 0x00	; 0
    934e:	b0 e0       	ldi	r27, 0x00	; 0
    9350:	dc 01       	movw	r26, r24
    9352:	99 27       	eor	r25, r25
    9354:	88 27       	eor	r24, r24
    9356:	b2 2b       	or	r27, r18
    9358:	20 91 cb 03 	lds	r18, 0x03CB
    935c:	82 2b       	or	r24, r18
    935e:	20 91 cc 03 	lds	r18, 0x03CC
    9362:	92 2b       	or	r25, r18
    9364:	86 8b       	std	Z+22, r24	; 0x16
    9366:	97 8b       	std	Z+23, r25	; 0x17
    9368:	a0 8f       	std	Z+24, r26	; 0x18
    936a:	b1 8f       	std	Z+25, r27	; 0x19

		//Parse velocity info
		xVEcefCms =  ((long)navSolMsgBuffer2[37] << 24) | ((long)navSolMsgBuffer2[36] << 16) | ((long)navSolMsgBuffer2[35] << 8) | (long) navSolMsgBuffer2[34];
    936c:	20 91 d2 03 	lds	r18, 0x03D2
    9370:	80 91 d1 03 	lds	r24, 0x03D1
    9374:	90 e0       	ldi	r25, 0x00	; 0
    9376:	a0 e0       	ldi	r26, 0x00	; 0
    9378:	b0 e0       	ldi	r27, 0x00	; 0
    937a:	dc 01       	movw	r26, r24
    937c:	99 27       	eor	r25, r25
    937e:	88 27       	eor	r24, r24
    9380:	b2 2b       	or	r27, r18
    9382:	20 91 cf 03 	lds	r18, 0x03CF
    9386:	82 2b       	or	r24, r18
    9388:	20 91 d0 03 	lds	r18, 0x03D0
    938c:	92 2b       	or	r25, r18
    938e:	82 8f       	std	Z+26, r24	; 0x1a
    9390:	93 8f       	std	Z+27, r25	; 0x1b
    9392:	a4 8f       	std	Z+28, r26	; 0x1c
    9394:	b5 8f       	std	Z+29, r27	; 0x1d
		yVEcefCms =  ((long)navSolMsgBuffer2[41] << 24) | ((long)navSolMsgBuffer2[40] << 16) | ((long)navSolMsgBuffer2[39] << 8) | (long) navSolMsgBuffer2[38];
    9396:	20 91 d6 03 	lds	r18, 0x03D6
    939a:	80 91 d5 03 	lds	r24, 0x03D5
    939e:	90 e0       	ldi	r25, 0x00	; 0
    93a0:	a0 e0       	ldi	r26, 0x00	; 0
    93a2:	b0 e0       	ldi	r27, 0x00	; 0
    93a4:	dc 01       	movw	r26, r24
    93a6:	99 27       	eor	r25, r25
    93a8:	88 27       	eor	r24, r24
    93aa:	b2 2b       	or	r27, r18
    93ac:	20 91 d3 03 	lds	r18, 0x03D3
    93b0:	82 2b       	or	r24, r18
    93b2:	20 91 d4 03 	lds	r18, 0x03D4
    93b6:	92 2b       	or	r25, r18
    93b8:	86 8f       	std	Z+30, r24	; 0x1e
    93ba:	97 8f       	std	Z+31, r25	; 0x1f
    93bc:	a0 a3       	std	Z+32, r26	; 0x20
    93be:	b1 a3       	std	Z+33, r27	; 0x21
		zVEcefCms =  ((long)navSolMsgBuffer2[45] << 24) | ((long)navSolMsgBuffer2[44] << 16) | ((long)navSolMsgBuffer2[43] << 8) | (long) navSolMsgBuffer2[42];
    93c0:	20 91 da 03 	lds	r18, 0x03DA
    93c4:	80 91 d9 03 	lds	r24, 0x03D9
    93c8:	90 e0       	ldi	r25, 0x00	; 0
    93ca:	a0 e0       	ldi	r26, 0x00	; 0
    93cc:	b0 e0       	ldi	r27, 0x00	; 0
    93ce:	dc 01       	movw	r26, r24
    93d0:	99 27       	eor	r25, r25
    93d2:	88 27       	eor	r24, r24
    93d4:	b2 2b       	or	r27, r18
    93d6:	20 91 d7 03 	lds	r18, 0x03D7
    93da:	82 2b       	or	r24, r18
    93dc:	20 91 d8 03 	lds	r18, 0x03D8
    93e0:	92 2b       	or	r25, r18
    93e2:	82 a3       	std	Z+34, r24	; 0x22
    93e4:	93 a3       	std	Z+35, r25	; 0x23
    93e6:	a4 a3       	std	Z+36, r26	; 0x24
    93e8:	b5 a3       	std	Z+37, r27	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsgBuffer2[49] << 24) | ((long)navSolMsgBuffer2[48] << 16) | ((long)navSolMsgBuffer2[47] << 8) | (long) navSolMsgBuffer2[46];
    93ea:	80 91 de 03 	lds	r24, 0x03DE
    93ee:	40 91 dd 03 	lds	r20, 0x03DD
    93f2:	50 e0       	ldi	r21, 0x00	; 0
    93f4:	60 e0       	ldi	r22, 0x00	; 0
    93f6:	70 e0       	ldi	r23, 0x00	; 0
    93f8:	ba 01       	movw	r22, r20
    93fa:	55 27       	eor	r21, r21
    93fc:	44 27       	eor	r20, r20
    93fe:	78 2b       	or	r23, r24
    9400:	80 91 db 03 	lds	r24, 0x03DB
    9404:	48 2b       	or	r20, r24
    9406:	80 91 dc 03 	lds	r24, 0x03DC
    940a:	58 2b       	or	r21, r24
    940c:	46 a3       	std	Z+38, r20	; 0x26
    940e:	57 a3       	std	Z+39, r21	; 0x27
    9410:	60 a7       	std	Z+40, r22	; 0x28
    9412:	71 a7       	std	Z+41, r23	; 0x29

		
		navSolMsgReceived = false;
    9414:	10 92 aa 03 	sts	0x03AA, r1
		processing = false;
    9418:	10 92 a8 03 	sts	0x03A8, r1
		
		
		if (crcError)
    941c:	80 91 a9 03 	lds	r24, 0x03A9
    9420:	88 23       	and	r24, r24
    9422:	41 f0       	breq	.+16     	; 0x9434 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x18c>
		{
			status = -1;
			crcError = false;
    9424:	10 92 a9 03 	sts	0x03A9, r1
		processing = false;
		
		
		if (crcError)
		{
			status = -1;
    9428:	2f ef       	ldi	r18, 0xFF	; 255
    942a:	3f ef       	ldi	r19, 0xFF	; 255
    942c:	05 c0       	rjmp	.+10     	; 0x9438 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x190>
}


int GPSSensor::processSensorSolution()
{
	int status = 0;
    942e:	20 e0       	ldi	r18, 0x00	; 0
    9430:	30 e0       	ldi	r19, 0x00	; 0
    9432:	02 c0       	rjmp	.+4      	; 0x9438 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv+0x190>
    9434:	20 e0       	ldi	r18, 0x00	; 0
    9436:	30 e0       	ldi	r19, 0x00	; 0
		
		
	}
	
	return status;
}
    9438:	82 2f       	mov	r24, r18
    943a:	93 2f       	mov	r25, r19
    943c:	08 95       	ret

0000943e <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv>:

int GPSSensor::readSensorSolution()
{
    943e:	ef 92       	push	r14
    9440:	ff 92       	push	r15
    9442:	0f 93       	push	r16
    9444:	1f 93       	push	r17
    9446:	cf 93       	push	r28
    9448:	df 93       	push	r29
    944a:	cd b7       	in	r28, 0x3d	; 61
    944c:	de b7       	in	r29, 0x3e	; 62
    944e:	ec 97       	sbiw	r28, 0x3c	; 60
    9450:	0f b6       	in	r0, 0x3f	; 63
    9452:	f8 94       	cli
    9454:	de bf       	out	0x3e, r29	; 62
    9456:	0f be       	out	0x3f, r0	; 63
    9458:	cd bf       	out	0x3d, r28	; 61
    945a:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte navSolMsg[60] = {0};
    945c:	9e 01       	movw	r18, r28
    945e:	2f 5f       	subi	r18, 0xFF	; 255
    9460:	3f 4f       	sbci	r19, 0xFF	; 255
    9462:	8c e3       	ldi	r24, 0x3C	; 60
    9464:	f9 01       	movw	r30, r18
    9466:	11 92       	st	Z+, r1
    9468:	8a 95       	dec	r24
    946a:	e9 f7       	brne	.-6      	; 0x9466 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x28>
	
	status = readSensor((byte *)NAV_SOL_POLLMSG, sizeof(NAV_SOL_POLLMSG), navSolMsg, sizeof(navSolMsg));
    946c:	0c e3       	ldi	r16, 0x3C	; 60
    946e:	10 e0       	ldi	r17, 0x00	; 0
    9470:	48 e0       	ldi	r20, 0x08	; 8
    9472:	50 e0       	ldi	r21, 0x00	; 0
    9474:	66 ed       	ldi	r22, 0xD6	; 214
    9476:	72 e0       	ldi	r23, 0x02	; 2
    9478:	c7 01       	movw	r24, r14
    947a:	0e 94 15 49 	call	0x922a	; 0x922a <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    947e:	9c 01       	movw	r18, r24
	
	if (status == 0)
    9480:	00 97       	sbiw	r24, 0x00	; 0
    9482:	09 f0       	breq	.+2      	; 0x9486 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x48>
    9484:	90 c0       	rjmp	.+288    	; 0x95a6 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x168>
	{
		//Parse status info 
		positionFixStatus =  navSolMsg[16] >= 3 ? VALID : INVALID;
    9486:	89 89       	ldd	r24, Y+17	; 0x11
    9488:	83 30       	cpi	r24, 0x03	; 3
    948a:	10 f0       	brcs	.+4      	; 0x9490 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x52>
    948c:	82 e0       	ldi	r24, 0x02	; 2
    948e:	01 c0       	rjmp	.+2      	; 0x9492 <_ZN10helicopter7sensors9GPSSensor18readSensorSolutionEv+0x54>
    9490:	81 e0       	ldi	r24, 0x01	; 1
    9492:	f7 01       	movw	r30, r14
    9494:	82 a7       	std	Z+42, r24	; 0x2a
		
		//Parse position info
		xEcefCm =  ((long)navSolMsg[21] << 24) | ((long)navSolMsg[20] << 16) | ((long)navSolMsg[19] << 8) | (long) navSolMsg[18];
    9496:	4e 89       	ldd	r20, Y+22	; 0x16
    9498:	8d 89       	ldd	r24, Y+21	; 0x15
    949a:	90 e0       	ldi	r25, 0x00	; 0
    949c:	a0 e0       	ldi	r26, 0x00	; 0
    949e:	b0 e0       	ldi	r27, 0x00	; 0
    94a0:	dc 01       	movw	r26, r24
    94a2:	99 27       	eor	r25, r25
    94a4:	88 27       	eor	r24, r24
    94a6:	b4 2b       	or	r27, r20
    94a8:	4b 89       	ldd	r20, Y+19	; 0x13
    94aa:	84 2b       	or	r24, r20
    94ac:	4c 89       	ldd	r20, Y+20	; 0x14
    94ae:	94 2b       	or	r25, r20
    94b0:	82 87       	std	Z+10, r24	; 0x0a
    94b2:	93 87       	std	Z+11, r25	; 0x0b
    94b4:	a4 87       	std	Z+12, r26	; 0x0c
    94b6:	b5 87       	std	Z+13, r27	; 0x0d
		yEcefCm =  ((long)navSolMsg[25] << 24) | ((long)navSolMsg[24] << 16) | ((long)navSolMsg[23] << 8) | (long) navSolMsg[22];
    94b8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    94ba:	89 8d       	ldd	r24, Y+25	; 0x19
    94bc:	90 e0       	ldi	r25, 0x00	; 0
    94be:	a0 e0       	ldi	r26, 0x00	; 0
    94c0:	b0 e0       	ldi	r27, 0x00	; 0
    94c2:	dc 01       	movw	r26, r24
    94c4:	99 27       	eor	r25, r25
    94c6:	88 27       	eor	r24, r24
    94c8:	b4 2b       	or	r27, r20
    94ca:	4f 89       	ldd	r20, Y+23	; 0x17
    94cc:	84 2b       	or	r24, r20
    94ce:	48 8d       	ldd	r20, Y+24	; 0x18
    94d0:	94 2b       	or	r25, r20
    94d2:	86 87       	std	Z+14, r24	; 0x0e
    94d4:	97 87       	std	Z+15, r25	; 0x0f
    94d6:	a0 8b       	std	Z+16, r26	; 0x10
    94d8:	b1 8b       	std	Z+17, r27	; 0x11
		zEcefCm =  ((long)navSolMsg[29] << 24) | ((long)navSolMsg[28] << 16) | ((long)navSolMsg[27] << 8) | (long) navSolMsg[26];
    94da:	4e 8d       	ldd	r20, Y+30	; 0x1e
    94dc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    94de:	90 e0       	ldi	r25, 0x00	; 0
    94e0:	a0 e0       	ldi	r26, 0x00	; 0
    94e2:	b0 e0       	ldi	r27, 0x00	; 0
    94e4:	dc 01       	movw	r26, r24
    94e6:	99 27       	eor	r25, r25
    94e8:	88 27       	eor	r24, r24
    94ea:	b4 2b       	or	r27, r20
    94ec:	4b 8d       	ldd	r20, Y+27	; 0x1b
    94ee:	84 2b       	or	r24, r20
    94f0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    94f2:	94 2b       	or	r25, r20
    94f4:	82 8b       	std	Z+18, r24	; 0x12
    94f6:	93 8b       	std	Z+19, r25	; 0x13
    94f8:	a4 8b       	std	Z+20, r26	; 0x14
    94fa:	b5 8b       	std	Z+21, r27	; 0x15
		positionAccuracyEstimateEcefCm =  ((long)navSolMsg[33] << 24) | ((long)navSolMsg[32] << 16) | ((long)navSolMsg[31] << 8) | (long) navSolMsg[30];
    94fc:	4a a1       	ldd	r20, Y+34	; 0x22
    94fe:	89 a1       	ldd	r24, Y+33	; 0x21
    9500:	90 e0       	ldi	r25, 0x00	; 0
    9502:	a0 e0       	ldi	r26, 0x00	; 0
    9504:	b0 e0       	ldi	r27, 0x00	; 0
    9506:	dc 01       	movw	r26, r24
    9508:	99 27       	eor	r25, r25
    950a:	88 27       	eor	r24, r24
    950c:	b4 2b       	or	r27, r20
    950e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    9510:	84 2b       	or	r24, r20
    9512:	48 a1       	ldd	r20, Y+32	; 0x20
    9514:	94 2b       	or	r25, r20
    9516:	86 8b       	std	Z+22, r24	; 0x16
    9518:	97 8b       	std	Z+23, r25	; 0x17
    951a:	a0 8f       	std	Z+24, r26	; 0x18
    951c:	b1 8f       	std	Z+25, r27	; 0x19
		
		//Parse velocity info
		xVEcefCms =  ((long)navSolMsg[37] << 24) | ((long)navSolMsg[36] << 16) | ((long)navSolMsg[35] << 8) | (long) navSolMsg[34];
    951e:	4e a1       	ldd	r20, Y+38	; 0x26
    9520:	8d a1       	ldd	r24, Y+37	; 0x25
    9522:	90 e0       	ldi	r25, 0x00	; 0
    9524:	a0 e0       	ldi	r26, 0x00	; 0
    9526:	b0 e0       	ldi	r27, 0x00	; 0
    9528:	dc 01       	movw	r26, r24
    952a:	99 27       	eor	r25, r25
    952c:	88 27       	eor	r24, r24
    952e:	b4 2b       	or	r27, r20
    9530:	4b a1       	ldd	r20, Y+35	; 0x23
    9532:	84 2b       	or	r24, r20
    9534:	4c a1       	ldd	r20, Y+36	; 0x24
    9536:	94 2b       	or	r25, r20
    9538:	82 8f       	std	Z+26, r24	; 0x1a
    953a:	93 8f       	std	Z+27, r25	; 0x1b
    953c:	a4 8f       	std	Z+28, r26	; 0x1c
    953e:	b5 8f       	std	Z+29, r27	; 0x1d
		yVEcefCms =  ((long)navSolMsg[41] << 24) | ((long)navSolMsg[40] << 16) | ((long)navSolMsg[39] << 8) | (long) navSolMsg[38];
    9540:	4a a5       	ldd	r20, Y+42	; 0x2a
    9542:	89 a5       	ldd	r24, Y+41	; 0x29
    9544:	90 e0       	ldi	r25, 0x00	; 0
    9546:	a0 e0       	ldi	r26, 0x00	; 0
    9548:	b0 e0       	ldi	r27, 0x00	; 0
    954a:	dc 01       	movw	r26, r24
    954c:	99 27       	eor	r25, r25
    954e:	88 27       	eor	r24, r24
    9550:	b4 2b       	or	r27, r20
    9552:	4f a1       	ldd	r20, Y+39	; 0x27
    9554:	84 2b       	or	r24, r20
    9556:	48 a5       	ldd	r20, Y+40	; 0x28
    9558:	94 2b       	or	r25, r20
    955a:	86 8f       	std	Z+30, r24	; 0x1e
    955c:	97 8f       	std	Z+31, r25	; 0x1f
    955e:	a0 a3       	std	Z+32, r26	; 0x20
    9560:	b1 a3       	std	Z+33, r27	; 0x21
		zVEcefCms =  ((long)navSolMsg[45] << 24) | ((long)navSolMsg[44] << 16) | ((long)navSolMsg[43] << 8) | (long) navSolMsg[42];
    9562:	4e a5       	ldd	r20, Y+46	; 0x2e
    9564:	8d a5       	ldd	r24, Y+45	; 0x2d
    9566:	90 e0       	ldi	r25, 0x00	; 0
    9568:	a0 e0       	ldi	r26, 0x00	; 0
    956a:	b0 e0       	ldi	r27, 0x00	; 0
    956c:	dc 01       	movw	r26, r24
    956e:	99 27       	eor	r25, r25
    9570:	88 27       	eor	r24, r24
    9572:	b4 2b       	or	r27, r20
    9574:	4b a5       	ldd	r20, Y+43	; 0x2b
    9576:	84 2b       	or	r24, r20
    9578:	4c a5       	ldd	r20, Y+44	; 0x2c
    957a:	94 2b       	or	r25, r20
    957c:	82 a3       	std	Z+34, r24	; 0x22
    957e:	93 a3       	std	Z+35, r25	; 0x23
    9580:	a4 a3       	std	Z+36, r26	; 0x24
    9582:	b5 a3       	std	Z+37, r27	; 0x25
		velocityAccuracyEstimateEcefCms =  ((long)navSolMsg[49] << 24) | ((long)navSolMsg[48] << 16) | ((long)navSolMsg[47] << 8) | (long) navSolMsg[46];
    9584:	8a a9       	ldd	r24, Y+50	; 0x32
    9586:	49 a9       	ldd	r20, Y+49	; 0x31
    9588:	50 e0       	ldi	r21, 0x00	; 0
    958a:	60 e0       	ldi	r22, 0x00	; 0
    958c:	70 e0       	ldi	r23, 0x00	; 0
    958e:	ba 01       	movw	r22, r20
    9590:	55 27       	eor	r21, r21
    9592:	44 27       	eor	r20, r20
    9594:	78 2b       	or	r23, r24
    9596:	8f a5       	ldd	r24, Y+47	; 0x2f
    9598:	48 2b       	or	r20, r24
    959a:	88 a9       	ldd	r24, Y+48	; 0x30
    959c:	58 2b       	or	r21, r24
    959e:	46 a3       	std	Z+38, r20	; 0x26
    95a0:	57 a3       	std	Z+39, r21	; 0x27
    95a2:	60 a7       	std	Z+40, r22	; 0x28
    95a4:	71 a7       	std	Z+41, r23	; 0x29
		
	}

	return status;
}
    95a6:	82 2f       	mov	r24, r18
    95a8:	93 2f       	mov	r25, r19
    95aa:	ec 96       	adiw	r28, 0x3c	; 60
    95ac:	0f b6       	in	r0, 0x3f	; 63
    95ae:	f8 94       	cli
    95b0:	de bf       	out	0x3e, r29	; 62
    95b2:	0f be       	out	0x3f, r0	; 63
    95b4:	cd bf       	out	0x3d, r28	; 61
    95b6:	df 91       	pop	r29
    95b8:	cf 91       	pop	r28
    95ba:	1f 91       	pop	r17
    95bc:	0f 91       	pop	r16
    95be:	ff 90       	pop	r15
    95c0:	ef 90       	pop	r14
    95c2:	08 95       	ret

000095c4 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv>:


int GPSSensor::readSensorNavStatus()
{
    95c4:	ef 92       	push	r14
    95c6:	ff 92       	push	r15
    95c8:	0f 93       	push	r16
    95ca:	1f 93       	push	r17
    95cc:	cf 93       	push	r28
    95ce:	df 93       	push	r29
    95d0:	cd b7       	in	r28, 0x3d	; 61
    95d2:	de b7       	in	r29, 0x3e	; 62
    95d4:	66 97       	sbiw	r28, 0x16	; 22
    95d6:	0f b6       	in	r0, 0x3f	; 63
    95d8:	f8 94       	cli
    95da:	de bf       	out	0x3e, r29	; 62
    95dc:	0f be       	out	0x3f, r0	; 63
    95de:	cd bf       	out	0x3d, r28	; 61
    95e0:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte statusMsg[22] = {0};
    95e2:	9e 01       	movw	r18, r28
    95e4:	2f 5f       	subi	r18, 0xFF	; 255
    95e6:	3f 4f       	sbci	r19, 0xFF	; 255
    95e8:	86 e1       	ldi	r24, 0x16	; 22
    95ea:	f9 01       	movw	r30, r18
    95ec:	11 92       	st	Z+, r1
    95ee:	8a 95       	dec	r24
    95f0:	e9 f7       	brne	.-6      	; 0x95ec <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x28>
	
	status = readSensor((byte *)NAV_STATUS_POLLMSG, sizeof(NAV_STATUS_POLLMSG), statusMsg, sizeof(statusMsg));
    95f2:	06 e1       	ldi	r16, 0x16	; 22
    95f4:	10 e0       	ldi	r17, 0x00	; 0
    95f6:	48 e0       	ldi	r20, 0x08	; 8
    95f8:	50 e0       	ldi	r21, 0x00	; 0
    95fa:	6e ec       	ldi	r22, 0xCE	; 206
    95fc:	72 e0       	ldi	r23, 0x02	; 2
    95fe:	c7 01       	movw	r24, r14
    9600:	0e 94 15 49 	call	0x922a	; 0x922a <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    9604:	9c 01       	movw	r18, r24
	
	if (status == 0)
    9606:	00 97       	sbiw	r24, 0x00	; 0
    9608:	41 f4       	brne	.+16     	; 0x961a <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x56>
	{
		//parse results
		positionFixStatus =  statusMsg[10] >= 3 ? VALID : INVALID;
    960a:	8b 85       	ldd	r24, Y+11	; 0x0b
    960c:	83 30       	cpi	r24, 0x03	; 3
    960e:	10 f0       	brcs	.+4      	; 0x9614 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x50>
    9610:	82 e0       	ldi	r24, 0x02	; 2
    9612:	01 c0       	rjmp	.+2      	; 0x9616 <_ZN10helicopter7sensors9GPSSensor19readSensorNavStatusEv+0x52>
    9614:	81 e0       	ldi	r24, 0x01	; 1
    9616:	f7 01       	movw	r30, r14
    9618:	82 a7       	std	Z+42, r24	; 0x2a
	}

	return status;
}
    961a:	82 2f       	mov	r24, r18
    961c:	93 2f       	mov	r25, r19
    961e:	66 96       	adiw	r28, 0x16	; 22
    9620:	0f b6       	in	r0, 0x3f	; 63
    9622:	f8 94       	cli
    9624:	de bf       	out	0x3e, r29	; 62
    9626:	0f be       	out	0x3f, r0	; 63
    9628:	cd bf       	out	0x3d, r28	; 61
    962a:	df 91       	pop	r29
    962c:	cf 91       	pop	r28
    962e:	1f 91       	pop	r17
    9630:	0f 91       	pop	r16
    9632:	ff 90       	pop	r15
    9634:	ef 90       	pop	r14
    9636:	08 95       	ret

00009638 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv>:

	return status;
}

int GPSSensor::readSensorLLH()
{
    9638:	ef 92       	push	r14
    963a:	ff 92       	push	r15
    963c:	0f 93       	push	r16
    963e:	1f 93       	push	r17
    9640:	cf 93       	push	r28
    9642:	df 93       	push	r29
    9644:	cd b7       	in	r28, 0x3d	; 61
    9646:	de b7       	in	r29, 0x3e	; 62
    9648:	a2 97       	sbiw	r28, 0x22	; 34
    964a:	0f b6       	in	r0, 0x3f	; 63
    964c:	f8 94       	cli
    964e:	de bf       	out	0x3e, r29	; 62
    9650:	0f be       	out	0x3f, r0	; 63
    9652:	cd bf       	out	0x3d, r28	; 61
    9654:	7c 01       	movw	r14, r24
	int status = 0;
	
	byte llhMsg[34] = {0};
    9656:	9e 01       	movw	r18, r28
    9658:	2f 5f       	subi	r18, 0xFF	; 255
    965a:	3f 4f       	sbci	r19, 0xFF	; 255
    965c:	82 e2       	ldi	r24, 0x22	; 34
    965e:	f9 01       	movw	r30, r18
    9660:	11 92       	st	Z+, r1
    9662:	8a 95       	dec	r24
    9664:	e9 f7       	brne	.-6      	; 0x9660 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x28>
	
	status = readSensor((byte *)NAV_POSLLH_POLLMSG, sizeof(NAV_POSLLH_POLLMSG), llhMsg, sizeof(llhMsg));
    9666:	02 e2       	ldi	r16, 0x22	; 34
    9668:	10 e0       	ldi	r17, 0x00	; 0
    966a:	48 e0       	ldi	r20, 0x08	; 8
    966c:	50 e0       	ldi	r21, 0x00	; 0
    966e:	6e ed       	ldi	r22, 0xDE	; 222
    9670:	72 e0       	ldi	r23, 0x02	; 2
    9672:	c7 01       	movw	r24, r14
    9674:	0e 94 15 49 	call	0x922a	; 0x922a <_ZN10helicopter7sensors9GPSSensor10readSensorEPhiS2_i>
    9678:	9c 01       	movw	r18, r24

	if (status == 0)
    967a:	00 97       	sbiw	r24, 0x00	; 0
    967c:	19 f5       	brne	.+70     	; 0x96c4 <_ZN10helicopter7sensors9GPSSensor13readSensorLLHEv+0x8c>
	{
		//parse results
		longitudeDegE7 =  ((long)llhMsg[13] << 24) | ((long)llhMsg[12] << 16) | ((long)llhMsg[11] << 8) | (long)llhMsg[10];
    967e:	4e 85       	ldd	r20, Y+14	; 0x0e
    9680:	8d 85       	ldd	r24, Y+13	; 0x0d
    9682:	90 e0       	ldi	r25, 0x00	; 0
    9684:	a0 e0       	ldi	r26, 0x00	; 0
    9686:	b0 e0       	ldi	r27, 0x00	; 0
    9688:	dc 01       	movw	r26, r24
    968a:	99 27       	eor	r25, r25
    968c:	88 27       	eor	r24, r24
    968e:	b4 2b       	or	r27, r20
    9690:	4b 85       	ldd	r20, Y+11	; 0x0b
    9692:	84 2b       	or	r24, r20
    9694:	4c 85       	ldd	r20, Y+12	; 0x0c
    9696:	94 2b       	or	r25, r20
    9698:	f7 01       	movw	r30, r14
    969a:	86 83       	std	Z+6, r24	; 0x06
    969c:	97 83       	std	Z+7, r25	; 0x07
    969e:	a0 87       	std	Z+8, r26	; 0x08
    96a0:	b1 87       	std	Z+9, r27	; 0x09
		latitudeDegE7 =  ((long)llhMsg[17] << 24) | ((long)llhMsg[16] << 16) | ((long)llhMsg[15] << 8) | (long) llhMsg[14];		
    96a2:	8a 89       	ldd	r24, Y+18	; 0x12
    96a4:	49 89       	ldd	r20, Y+17	; 0x11
    96a6:	50 e0       	ldi	r21, 0x00	; 0
    96a8:	60 e0       	ldi	r22, 0x00	; 0
    96aa:	70 e0       	ldi	r23, 0x00	; 0
    96ac:	ba 01       	movw	r22, r20
    96ae:	55 27       	eor	r21, r21
    96b0:	44 27       	eor	r20, r20
    96b2:	78 2b       	or	r23, r24
    96b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    96b6:	48 2b       	or	r20, r24
    96b8:	88 89       	ldd	r24, Y+16	; 0x10
    96ba:	58 2b       	or	r21, r24
    96bc:	42 83       	std	Z+2, r20	; 0x02
    96be:	53 83       	std	Z+3, r21	; 0x03
    96c0:	64 83       	std	Z+4, r22	; 0x04
    96c2:	75 83       	std	Z+5, r23	; 0x05
	}

	return status;
}
    96c4:	82 2f       	mov	r24, r18
    96c6:	93 2f       	mov	r25, r19
    96c8:	a2 96       	adiw	r28, 0x22	; 34
    96ca:	0f b6       	in	r0, 0x3f	; 63
    96cc:	f8 94       	cli
    96ce:	de bf       	out	0x3e, r29	; 62
    96d0:	0f be       	out	0x3f, r0	; 63
    96d2:	cd bf       	out	0x3d, r28	; 61
    96d4:	df 91       	pop	r29
    96d6:	cf 91       	pop	r28
    96d8:	1f 91       	pop	r17
    96da:	0f 91       	pop	r16
    96dc:	ff 90       	pop	r15
    96de:	ef 90       	pop	r14
    96e0:	08 95       	ret

000096e2 <_ZN10helicopter7sensors9GPSSensor4initEv>:

int GPSSensor::init()
{
    96e2:	cf 93       	push	r28
    96e4:	df 93       	push	r29
    96e6:	ec 01       	movw	r28, r24
	
	/**
	 * Transmit a hotstart reset and then clear the buffers so that if the gps is still periodically
	 * sending data, it doesn't cause an overflow of the serial drivers buffer. 
	 */
	serialDriver->clearBuffer();
    96e8:	88 81       	ld	r24, Y
    96ea:	99 81       	ldd	r25, Y+1	; 0x01
    96ec:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <_ZN10helicopter7drivers12SerialDriver11clearBufferEv>
	serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    96f0:	4c e0       	ldi	r20, 0x0C	; 12
    96f2:	50 e0       	ldi	r21, 0x00	; 0
    96f4:	68 e8       	ldi	r22, 0x88	; 136
    96f6:	72 e0       	ldi	r23, 0x02	; 2
    96f8:	88 81       	ld	r24, Y
    96fa:	99 81       	ldd	r25, Y+1	; 0x01
    96fc:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	/**
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
    9700:	ce 01       	movw	r24, r28
    9702:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    9706:	00 97       	sbiw	r24, 0x00	; 0
    9708:	79 f0       	breq	.+30     	; 0x9728 <_ZN10helicopter7sensors9GPSSensor4initEv+0x46>
	{
		//Nack received, so resend command
		if (status == 1)
    970a:	01 97       	sbiw	r24, 0x01	; 1
    970c:	41 f4       	brne	.+16     	; 0x971e <_ZN10helicopter7sensors9GPSSensor4initEv+0x3c>
		{
			serialDriver->transmit((const char*)CFG_RST, sizeof(CFG_RST));
    970e:	4c e0       	ldi	r20, 0x0C	; 12
    9710:	50 e0       	ldi	r21, 0x00	; 0
    9712:	68 e8       	ldi	r22, 0x88	; 136
    9714:	72 e0       	ldi	r23, 0x02	; 2
    9716:	88 81       	ld	r24, Y
    9718:	99 81       	ldd	r25, Y+1	; 0x01
    971a:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    971e:	ce 01       	movw	r24, r28
    9720:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * There might have been old overflowed data on the buffer so keep reading
	 * until we receive the ack.
	 */
	//while(receiveGpsData(desiredHeaderID, ACK, sizeof(ACK)) != 0)
	status = receiveAckNack();
	while(status != 0)
    9724:	00 97       	sbiw	r24, 0x00	; 0
    9726:	89 f7       	brne	.-30     	; 0x970a <_ZN10helicopter7sensors9GPSSensor4initEv+0x28>
    9728:	2f ef       	ldi	r18, 0xFF	; 255
    972a:	8e e9       	ldi	r24, 0x9E	; 158
    972c:	94 e2       	ldi	r25, 0x24	; 36
    972e:	21 50       	subi	r18, 0x01	; 1
    9730:	80 40       	sbci	r24, 0x00	; 0
    9732:	90 40       	sbci	r25, 0x00	; 0
    9734:	e1 f7       	brne	.-8      	; 0x972e <_ZN10helicopter7sensors9GPSSensor4initEv+0x4c>
    9736:	00 c0       	rjmp	.+0      	; 0x9738 <_ZN10helicopter7sensors9GPSSensor4initEv+0x56>
    9738:	00 00       	nop
	
	
	/**
	* Configure the GPS's port to use, protocol, and speed.
	*/
	serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    973a:	4c e1       	ldi	r20, 0x1C	; 28
    973c:	50 e0       	ldi	r21, 0x00	; 0
    973e:	62 ea       	ldi	r22, 0xA2	; 162
    9740:	72 e0       	ldi	r23, 0x02	; 2
    9742:	88 81       	ld	r24, Y
    9744:	99 81       	ldd	r25, Y+1	; 0x01
    9746:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	 * byte and discard each byte of the ack message because if we don't read ALL the bytes
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
    974a:	ce 01       	movw	r24, r28
    974c:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	while(status != 0)
    9750:	00 97       	sbiw	r24, 0x00	; 0
    9752:	79 f0       	breq	.+30     	; 0x9772 <_ZN10helicopter7sensors9GPSSensor4initEv+0x90>
	{
		//Nack received, so resend command
		if (status == 1)
    9754:	01 97       	sbiw	r24, 0x01	; 1
    9756:	41 f4       	brne	.+16     	; 0x9768 <_ZN10helicopter7sensors9GPSSensor4initEv+0x86>
		{
			serialDriver->transmit((const char*)CFG_PRT, sizeof(CFG_PRT));
    9758:	4c e1       	ldi	r20, 0x1C	; 28
    975a:	50 e0       	ldi	r21, 0x00	; 0
    975c:	62 ea       	ldi	r22, 0xA2	; 162
    975e:	72 e0       	ldi	r23, 0x02	; 2
    9760:	88 81       	ld	r24, Y
    9762:	99 81       	ldd	r25, Y+1	; 0x01
    9764:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    9768:	ce 01       	movw	r24, r28
    976a:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
	 * the GPS will be completely unresponsive. It will not receive other messages
	 * unless all bytes of the ack message are received. 
	 * might fail to receive ack if there was a previous buffer overrun.
	 */
	status = receiveAckNack();
	while(status != 0)
    976e:	00 97       	sbiw	r24, 0x00	; 0
    9770:	89 f7       	brne	.-30     	; 0x9754 <_ZN10helicopter7sensors9GPSSensor4initEv+0x72>
			
		}
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    9772:	4e e0       	ldi	r20, 0x0E	; 14
    9774:	50 e0       	ldi	r21, 0x00	; 0
    9776:	64 e9       	ldi	r22, 0x94	; 148
    9778:	72 e0       	ldi	r23, 0x02	; 2
    977a:	88 81       	ld	r24, Y
    977c:	99 81       	ldd	r25, Y+1	; 0x01
    977e:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
	status = receiveAckNack();
    9782:	ce 01       	movw	r24, r28
    9784:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    9788:	9c 01       	movw	r18, r24
	while(status != 0)
    978a:	00 97       	sbiw	r24, 0x00	; 0
    978c:	89 f0       	breq	.+34     	; 0x97b0 <_ZN10helicopter7sensors9GPSSensor4initEv+0xce>
	{
		//Nack received, so resend command
		if (status == 1)
    978e:	21 30       	cpi	r18, 0x01	; 1
    9790:	31 05       	cpc	r19, r1
    9792:	41 f4       	brne	.+16     	; 0x97a4 <_ZN10helicopter7sensors9GPSSensor4initEv+0xc2>
		{
			serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
    9794:	4e e0       	ldi	r20, 0x0E	; 14
    9796:	50 e0       	ldi	r21, 0x00	; 0
    9798:	64 e9       	ldi	r22, 0x94	; 148
    979a:	72 e0       	ldi	r23, 0x02	; 2
    979c:	88 81       	ld	r24, Y
    979e:	99 81       	ldd	r25, Y+1	; 0x01
    97a0:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    97a4:	ce 01       	movw	r24, r28
    97a6:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    97aa:	9c 01       	movw	r18, r24
		status = receiveAckNack();
	}
	
	serialDriver->transmit((const char*)CFG_RATE, sizeof(CFG_RATE));
	status = receiveAckNack();
	while(status != 0)
    97ac:	00 97       	sbiw	r24, 0x00	; 0
    97ae:	79 f7       	brne	.-34     	; 0x978e <_ZN10helicopter7sensors9GPSSensor4initEv+0xac>
		status = receiveAckNack();
	}


	return status;
}
    97b0:	82 2f       	mov	r24, r18
    97b2:	93 2f       	mov	r25, r19
    97b4:	df 91       	pop	r29
    97b6:	cf 91       	pop	r28
    97b8:	08 95       	ret

000097ba <_ZN10helicopter7sensors9GPSSensor5startEv>:


int GPSSensor::start()
{
    97ba:	cf 93       	push	r28
    97bc:	df 93       	push	r29
    97be:	ec 01       	movw	r28, r24
	cli();
    97c0:	f8 94       	cli
	/**
	* Hack to setup the serial driver to interrupt when data is received.
	*/
	UCSR1B |= (1<<RXCIE1);
    97c2:	e9 ec       	ldi	r30, 0xC9	; 201
    97c4:	f0 e0       	ldi	r31, 0x00	; 0
    97c6:	80 81       	ld	r24, Z
    97c8:	80 68       	ori	r24, 0x80	; 128
    97ca:	80 83       	st	Z, r24
	

	/**
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    97cc:	40 e1       	ldi	r20, 0x10	; 16
    97ce:	50 e0       	ldi	r21, 0x00	; 0
    97d0:	6e eb       	ldi	r22, 0xBE	; 190
    97d2:	72 e0       	ldi	r23, 0x02	; 2
    97d4:	88 81       	ld	r24, Y
    97d6:	99 81       	ldd	r25, Y+1	; 0x01
    97d8:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
		
	int status = receiveAckNack();
    97dc:	ce 01       	movw	r24, r28
    97de:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    97e2:	9c 01       	movw	r18, r24
	while(status != 0)
    97e4:	00 97       	sbiw	r24, 0x00	; 0
    97e6:	89 f0       	breq	.+34     	; 0x980a <_ZN10helicopter7sensors9GPSSensor5startEv+0x50>
	{
		//Nack received, so resend command
		if (status == 1)
    97e8:	21 30       	cpi	r18, 0x01	; 1
    97ea:	31 05       	cpc	r19, r1
    97ec:	41 f4       	brne	.+16     	; 0x97fe <_ZN10helicopter7sensors9GPSSensor5startEv+0x44>
		{
			serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
    97ee:	40 e1       	ldi	r20, 0x10	; 16
    97f0:	50 e0       	ldi	r21, 0x00	; 0
    97f2:	6e eb       	ldi	r22, 0xBE	; 190
    97f4:	72 e0       	ldi	r23, 0x02	; 2
    97f6:	88 81       	ld	r24, Y
    97f8:	99 81       	ldd	r25, Y+1	; 0x01
    97fa:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <_ZN10helicopter7drivers12SerialDriver8transmitEPKci>
			
		}
		status = receiveAckNack();
    97fe:	ce 01       	movw	r24, r28
    9800:	0e 94 1f 48 	call	0x903e	; 0x903e <_ZN10helicopter7sensors9GPSSensor14receiveAckNackEv>
    9804:	9c 01       	movw	r18, r24
	* Setup gps for polling navigation solution.
	*/
	serialDriver->transmit((const char*)CFG_MSG_CONFIG_PERIODIC_SOL, sizeof(CFG_MSG_CONFIG_PERIODIC_SOL));
		
	int status = receiveAckNack();
	while(status != 0)
    9806:	00 97       	sbiw	r24, 0x00	; 0
    9808:	79 f7       	brne	.-34     	; 0x97e8 <_ZN10helicopter7sensors9GPSSensor5startEv+0x2e>
			
		}
		status = receiveAckNack();
	}

	sei();	
    980a:	78 94       	sei
	
	return status;
}
    980c:	82 2f       	mov	r24, r18
    980e:	93 2f       	mov	r25, r19
    9810:	df 91       	pop	r29
    9812:	cf 91       	pop	r28
    9814:	08 95       	ret

00009816 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv>:
				
bool GPSSensor::isGpsReady()
{
	return positionFixStatus == VALID;;
    9816:	21 e0       	ldi	r18, 0x01	; 1
    9818:	fc 01       	movw	r30, r24
    981a:	82 a5       	ldd	r24, Z+42	; 0x2a
    981c:	82 30       	cpi	r24, 0x02	; 2
    981e:	09 f0       	breq	.+2      	; 0x9822 <_ZN10helicopter7sensors9GPSSensor10isGpsReadyEv+0xc>
    9820:	20 e0       	ldi	r18, 0x00	; 0
}
    9822:	82 2f       	mov	r24, r18
    9824:	08 95       	ret

00009826 <__vector_36>:



//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART1_RX_vect)
{
    9826:	1f 92       	push	r1
    9828:	0f 92       	push	r0
    982a:	0f b6       	in	r0, 0x3f	; 63
    982c:	0f 92       	push	r0
    982e:	11 24       	eor	r1, r1
    9830:	0b b6       	in	r0, 0x3b	; 59
    9832:	0f 92       	push	r0
    9834:	2f 93       	push	r18
    9836:	3f 93       	push	r19
    9838:	4f 93       	push	r20
    983a:	8f 93       	push	r24
    983c:	9f 93       	push	r25
    983e:	af 93       	push	r26
    9840:	bf 93       	push	r27
    9842:	ef 93       	push	r30
    9844:	ff 93       	push	r31

	byte msgByte = UDR1;
    9846:	20 91 ce 00 	lds	r18, 0x00CE
	

	if (GPSSensor::navSolBufferCounter < GPSSensor::navSolBufferSize)
    984a:	80 91 ab 03 	lds	r24, 0x03AB
    984e:	90 91 ac 03 	lds	r25, 0x03AC
    9852:	8c 33       	cpi	r24, 0x3C	; 60
    9854:	91 05       	cpc	r25, r1
    9856:	0c f0       	brlt	.+2      	; 0x985a <__vector_36+0x34>
    9858:	50 c0       	rjmp	.+160    	; 0x98fa <__vector_36+0xd4>
		/**
		* if the first data values don't match header values and id values, then the msg has been corrupted
		* so ignore the message. 0xB5 is the first header byte, 0x62 is the second header byte,
		* 0x01 is the first ID byte for the nav_sol msg and 0x06 is the second header byte.
		*/
		if ((GPSSensor::navSolBufferCounter == 0 && msgByte != 0xB5) ||
    985a:	00 97       	sbiw	r24, 0x00	; 0
    985c:	21 f4       	brne	.+8      	; 0x9866 <__vector_36+0x40>
    985e:	25 3b       	cpi	r18, 0xB5	; 181
    9860:	09 f0       	breq	.+2      	; 0x9864 <__vector_36+0x3e>
    9862:	64 c0       	rjmp	.+200    	; 0x992c <__vector_36+0x106>
    9864:	0e c0       	rjmp	.+28     	; 0x9882 <__vector_36+0x5c>
    9866:	81 30       	cpi	r24, 0x01	; 1
    9868:	91 05       	cpc	r25, r1
    986a:	21 f4       	brne	.+8      	; 0x9874 <__vector_36+0x4e>
    986c:	22 36       	cpi	r18, 0x62	; 98
    986e:	09 f0       	breq	.+2      	; 0x9872 <__vector_36+0x4c>
    9870:	5d c0       	rjmp	.+186    	; 0x992c <__vector_36+0x106>
    9872:	4a c0       	rjmp	.+148    	; 0x9908 <__vector_36+0xe2>
    9874:	82 30       	cpi	r24, 0x02	; 2
    9876:	91 05       	cpc	r25, r1
    9878:	21 f4       	brne	.+8      	; 0x9882 <__vector_36+0x5c>
    987a:	21 30       	cpi	r18, 0x01	; 1
    987c:	09 f0       	breq	.+2      	; 0x9880 <__vector_36+0x5a>
    987e:	56 c0       	rjmp	.+172    	; 0x992c <__vector_36+0x106>
    9880:	5c c0       	rjmp	.+184    	; 0x993a <__vector_36+0x114>
    9882:	83 30       	cpi	r24, 0x03	; 3
    9884:	91 05       	cpc	r25, r1
    9886:	09 f0       	breq	.+2      	; 0x988a <__vector_36+0x64>
    9888:	3f c0       	rjmp	.+126    	; 0x9908 <__vector_36+0xe2>
    988a:	26 30       	cpi	r18, 0x06	; 6
    988c:	09 f0       	breq	.+2      	; 0x9890 <__vector_36+0x6a>
    988e:	4e c0       	rjmp	.+156    	; 0x992c <__vector_36+0x106>
    9890:	54 c0       	rjmp	.+168    	; 0x993a <__vector_36+0x114>
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
    9892:	41 91       	ld	r20, Z+
    9894:	24 0f       	add	r18, r20
					ckB = ckB + ckA;
    9896:	32 0f       	add	r19, r18
			{
				//8-bit fletcher algorithm defined on page 86 of gps pdf.
				unsigned char ckA = 0;
				unsigned char ckB = 0;
				
				for (int i = 0; i < GPSSensor::navSolBufferSize - 4; i++)
    9898:	e8 17       	cp	r30, r24
    989a:	f9 07       	cpc	r31, r25
    989c:	d1 f7       	brne	.-12     	; 0x9892 <__vector_36+0x6c>
				{
					ckA = ckA + GPSSensor::navSolMsgBuffer[i+2];
					ckB = ckB + ckA;
				}
				
				if (GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 2] == ckA && 
    989e:	80 91 23 04 	lds	r24, 0x0423
    98a2:	28 13       	cpse	r18, r24
    98a4:	20 c0       	rjmp	.+64     	; 0x98e6 <__vector_36+0xc0>
    98a6:	80 91 24 04 	lds	r24, 0x0424
    98aa:	38 13       	cpse	r19, r24
    98ac:	1c c0       	rjmp	.+56     	; 0x98e6 <__vector_36+0xc0>
					GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferSize - 1] == ckB)
				{
					//Don't change the buffer data if the system is currently processing the buffer.
					if (GPSSensor::processing == false)
    98ae:	80 91 a8 03 	lds	r24, 0x03A8
    98b2:	81 11       	cpse	r24, r1
    98b4:	11 c0       	rjmp	.+34     	; 0x98d8 <__vector_36+0xb2>
					{
						memcpy(GPSSensor::navSolMsgBuffer2,GPSSensor::navSolMsgBuffer, GPSSensor::navSolBufferSize);
    98b6:	8c e3       	ldi	r24, 0x3C	; 60
    98b8:	e9 ee       	ldi	r30, 0xE9	; 233
    98ba:	f3 e0       	ldi	r31, 0x03	; 3
    98bc:	ad ea       	ldi	r26, 0xAD	; 173
    98be:	b3 e0       	ldi	r27, 0x03	; 3
    98c0:	01 90       	ld	r0, Z+
    98c2:	0d 92       	st	X+, r0
    98c4:	8a 95       	dec	r24
    98c6:	e1 f7       	brne	.-8      	; 0x98c0 <__vector_36+0x9a>
						GPSSensor::navSolMsgReceived = true;
    98c8:	81 e0       	ldi	r24, 0x01	; 1
    98ca:	80 93 aa 03 	sts	0x03AA, r24
						GPSSensor::navSolBufferCounter = 0;						
    98ce:	10 92 ac 03 	sts	0x03AC, r1
    98d2:	10 92 ab 03 	sts	0x03AB, r1
    98d6:	3a c0       	rjmp	.+116    	; 0x994c <__vector_36+0x126>
					{
						//Reset for a new message and drop this message because the system was processing the current message
						//when the new message came in. 
						//This could be bad because if the timing planets aligned, and this kept happening and the gps messages
						//kept getting dropped, then that would be bad. 
						GPSSensor::navSolMsgReceived = false;
    98d8:	10 92 aa 03 	sts	0x03AA, r1
						GPSSensor::navSolBufferCounter = 0;
    98dc:	10 92 ac 03 	sts	0x03AC, r1
    98e0:	10 92 ab 03 	sts	0x03AB, r1
    98e4:	33 c0       	rjmp	.+102    	; 0x994c <__vector_36+0x126>
					}
			
				}else
				{
					//GPS checksum didn't match. 
					GPSSensor::navSolMsgReceived = false;
    98e6:	10 92 aa 03 	sts	0x03AA, r1
					GPSSensor::navSolBufferCounter = 0;
    98ea:	10 92 ac 03 	sts	0x03AC, r1
    98ee:	10 92 ab 03 	sts	0x03AB, r1
					GPSSensor::crcError = true;
    98f2:	81 e0       	ldi	r24, 0x01	; 1
    98f4:	80 93 a9 03 	sts	0x03A9, r24
    98f8:	29 c0       	rjmp	.+82     	; 0x994c <__vector_36+0x126>
			}			
		}
	}else
	{
		//Theres been some kind of error and the buffer overran, so reset.
		GPSSensor::navSolMsgReceived = false;
    98fa:	10 92 aa 03 	sts	0x03AA, r1
		GPSSensor::navSolBufferCounter = 0;
    98fe:	10 92 ac 03 	sts	0x03AC, r1
    9902:	10 92 ab 03 	sts	0x03AB, r1
    9906:	22 c0       	rjmp	.+68     	; 0x994c <__vector_36+0x126>
		{
			GPSSensor::navSolMsgReceived = false;
			GPSSensor::navSolBufferCounter = 0;
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    9908:	fc 01       	movw	r30, r24
    990a:	e7 51       	subi	r30, 0x17	; 23
    990c:	fc 4f       	sbci	r31, 0xFC	; 252
    990e:	20 83       	st	Z, r18
    9910:	01 96       	adiw	r24, 0x01	; 1
    9912:	90 93 ac 03 	sts	0x03AC, r25
    9916:	80 93 ab 03 	sts	0x03AB, r24
			
			if (GPSSensor::navSolBufferCounter >= GPSSensor::navSolBufferSize)
    991a:	cc 97       	sbiw	r24, 0x3c	; 60
    991c:	bc f0       	brlt	.+46     	; 0x994c <__vector_36+0x126>
    991e:	eb ee       	ldi	r30, 0xEB	; 235
    9920:	f3 e0       	ldi	r31, 0x03	; 3




//ISR for receiving serial data from the gps when an interrupt occurs
ISR(USART1_RX_vect)
    9922:	83 e2       	ldi	r24, 0x23	; 35
    9924:	94 e0       	ldi	r25, 0x04	; 4
    9926:	30 e0       	ldi	r19, 0x00	; 0
    9928:	20 e0       	ldi	r18, 0x00	; 0
    992a:	b3 cf       	rjmp	.-154    	; 0x9892 <__vector_36+0x6c>
			isCorrupted = true;
		}
		
		if (isCorrupted)
		{
			GPSSensor::navSolMsgReceived = false;
    992c:	10 92 aa 03 	sts	0x03AA, r1
			GPSSensor::navSolBufferCounter = 0;
    9930:	10 92 ac 03 	sts	0x03AC, r1
    9934:	10 92 ab 03 	sts	0x03AB, r1
    9938:	09 c0       	rjmp	.+18     	; 0x994c <__vector_36+0x126>
		}else
		{
			GPSSensor::navSolMsgBuffer[GPSSensor::navSolBufferCounter++] = msgByte;
    993a:	fc 01       	movw	r30, r24
    993c:	e7 51       	subi	r30, 0x17	; 23
    993e:	fc 4f       	sbci	r31, 0xFC	; 252
    9940:	20 83       	st	Z, r18
    9942:	01 96       	adiw	r24, 0x01	; 1
    9944:	90 93 ac 03 	sts	0x03AC, r25
    9948:	80 93 ab 03 	sts	0x03AB, r24

	
	//I'll want to make sure I do a memcpy on the buffer when i start working on it
	//to ensure it's not adjusted while I'm working on it.
	//and I'll want to set variable to false first.
    994c:	ff 91       	pop	r31
    994e:	ef 91       	pop	r30
    9950:	bf 91       	pop	r27
    9952:	af 91       	pop	r26
    9954:	9f 91       	pop	r25
    9956:	8f 91       	pop	r24
    9958:	4f 91       	pop	r20
    995a:	3f 91       	pop	r19
    995c:	2f 91       	pop	r18
    995e:	0f 90       	pop	r0
    9960:	0b be       	out	0x3b, r0	; 59
    9962:	0f 90       	pop	r0
    9964:	0f be       	out	0x3f, r0	; 63
    9966:	0f 90       	pop	r0
    9968:	1f 90       	pop	r1
    996a:	18 95       	reti

0000996c <_ZN10helicopter7sensors9IMUSensor10readSensorEv>:
	this->gyroOffsets[2] = offsetz;
	
}

void IMUSensor::readSensor()
{
    996c:	8f 92       	push	r8
    996e:	9f 92       	push	r9
    9970:	af 92       	push	r10
    9972:	bf 92       	push	r11
    9974:	cf 92       	push	r12
    9976:	df 92       	push	r13
    9978:	ef 92       	push	r14
    997a:	ff 92       	push	r15
    997c:	cf 93       	push	r28
    997e:	df 93       	push	r29
    9980:	ec 01       	movw	r28, r24
	if (!hasBeenRead)
    9982:	fc 01       	movw	r30, r24
    9984:	e6 5b       	subi	r30, 0xB6	; 182
    9986:	ff 4f       	sbci	r31, 0xFF	; 255
    9988:	80 81       	ld	r24, Z
    998a:	81 11       	cpse	r24, r1
    998c:	05 c0       	rjmp	.+10     	; 0x9998 <_ZN10helicopter7sensors9IMUSensor10readSensorEv+0x2c>
	{
		missedRead = true;
    998e:	fe 01       	movw	r30, r28
    9990:	e5 5b       	subi	r30, 0xB5	; 181
    9992:	ff 4f       	sbci	r31, 0xFF	; 255
    9994:	81 e0       	ldi	r24, 0x01	; 1
    9996:	80 83       	st	Z, r24
	}
	
	hasBeenRead = false;
    9998:	fe 01       	movw	r30, r28
    999a:	e6 5b       	subi	r30, 0xB6	; 182
    999c:	ff 4f       	sbci	r31, 0xFF	; 255
    999e:	10 82       	st	Z, r1
	
	//indicate that this device is about to begin communicating with the sensor.
	spiDriver->beginTransaction();
    99a0:	8c a1       	ldd	r24, Y+36	; 0x24
    99a2:	9d a1       	ldd	r25, Y+37	; 0x25
    99a4:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <_ZN10helicopter7drivers9SPIDriver16beginTransactionEv>
	 * is now pointing to.
	 * The address is 'or'ed by the 'readcommand' to indicate to the
	 * sensor that the subsequent commands should read data
	 * from the sensor.
	 */	
	spiDriver->write(REG_ACCEL_XOUT_H | readCommand);
    99a8:	6b eb       	ldi	r22, 0xBB	; 187
    99aa:	8c a1       	ldd	r24, Y+36	; 0x24
    99ac:	9d a1       	ldd	r25, Y+37	; 0x25
    99ae:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <_ZN10helicopter7drivers9SPIDriver5writeEh>

	rawAccX = spiDriver->readInt();
    99b2:	8c a1       	ldd	r24, Y+36	; 0x24
    99b4:	9d a1       	ldd	r25, Y+37	; 0x25
    99b6:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99ba:	9f a3       	std	Y+39, r25	; 0x27
    99bc:	8e a3       	std	Y+38, r24	; 0x26
	rawAccY = spiDriver->readInt();
    99be:	8c a1       	ldd	r24, Y+36	; 0x24
    99c0:	9d a1       	ldd	r25, Y+37	; 0x25
    99c2:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99c6:	99 a7       	std	Y+41, r25	; 0x29
    99c8:	88 a7       	std	Y+40, r24	; 0x28
	rawAccZ = spiDriver->readInt();
    99ca:	8c a1       	ldd	r24, Y+36	; 0x24
    99cc:	9d a1       	ldd	r25, Y+37	; 0x25
    99ce:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99d2:	9b a7       	std	Y+43, r25	; 0x2b
    99d4:	8a a7       	std	Y+42, r24	; 0x2a
	
	//read the temp data, and ignore it since it isn't used.
	spiDriver->readInt();
    99d6:	8c a1       	ldd	r24, Y+36	; 0x24
    99d8:	9d a1       	ldd	r25, Y+37	; 0x25
    99da:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
	
	rawGyroX = spiDriver->readInt();
    99de:	8c a1       	ldd	r24, Y+36	; 0x24
    99e0:	9d a1       	ldd	r25, Y+37	; 0x25
    99e2:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99e6:	9d a7       	std	Y+45, r25	; 0x2d
    99e8:	8c a7       	std	Y+44, r24	; 0x2c
	rawGyroY = spiDriver->readInt();
    99ea:	8c a1       	ldd	r24, Y+36	; 0x24
    99ec:	9d a1       	ldd	r25, Y+37	; 0x25
    99ee:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99f2:	9f a7       	std	Y+47, r25	; 0x2f
    99f4:	8e a7       	std	Y+46, r24	; 0x2e
	rawGyroZ = spiDriver->readInt();
    99f6:	8c a1       	ldd	r24, Y+36	; 0x24
    99f8:	9d a1       	ldd	r25, Y+37	; 0x25
    99fa:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <_ZN10helicopter7drivers9SPIDriver7readIntEv>
    99fe:	99 ab       	std	Y+49, r25	; 0x31
    9a00:	88 ab       	std	Y+48, r24	; 0x30
	
	/**
	 * The master (this CPU) then pulls the slave select line low indicating
	 * that it is done communicating.
	 */
	spiDriver->endTransaction();
    9a02:	8c a1       	ldd	r24, Y+36	; 0x24
    9a04:	9d a1       	ldd	r25, Y+37	; 0x25
    9a06:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <_ZN10helicopter7drivers9SPIDriver14endTransactionEv>
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a0a:	6e a1       	ldd	r22, Y+38	; 0x26
    9a0c:	7f a1       	ldd	r23, Y+39	; 0x27
    9a0e:	88 27       	eor	r24, r24
    9a10:	77 fd       	sbrc	r23, 7
    9a12:	80 95       	com	r24
    9a14:	98 2f       	mov	r25, r24
    9a16:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9a1a:	2a e0       	ldi	r18, 0x0A	; 10
    9a1c:	38 ee       	ldi	r19, 0xE8	; 232
    9a1e:	4c e9       	ldi	r20, 0x9C	; 156
    9a20:	5a e3       	ldi	r21, 0x3A	; 58
    9a22:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    9a26:	46 2f       	mov	r20, r22
    9a28:	57 2f       	mov	r21, r23
    9a2a:	68 2f       	mov	r22, r24
    9a2c:	79 2f       	mov	r23, r25
    9a2e:	4a 01       	movw	r8, r20
    9a30:	5b 01       	movw	r10, r22
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a32:	6a a5       	ldd	r22, Y+42	; 0x2a
    9a34:	7b a5       	ldd	r23, Y+43	; 0x2b
    9a36:	71 95       	neg	r23
    9a38:	61 95       	neg	r22
    9a3a:	71 09       	sbc	r23, r1
    9a3c:	88 27       	eor	r24, r24
    9a3e:	77 fd       	sbrc	r23, 7
    9a40:	80 95       	com	r24
    9a42:	98 2f       	mov	r25, r24
    9a44:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9a48:	2a e0       	ldi	r18, 0x0A	; 10
    9a4a:	38 ee       	ldi	r19, 0xE8	; 232
    9a4c:	4c e9       	ldi	r20, 0x9C	; 156
    9a4e:	5a e3       	ldi	r21, 0x3A	; 58
    9a50:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    9a54:	46 2f       	mov	r20, r22
    9a56:	57 2f       	mov	r21, r23
    9a58:	68 2f       	mov	r22, r24
    9a5a:	79 2f       	mov	r23, r25
    9a5c:	6a 01       	movw	r12, r20
    9a5e:	7b 01       	movw	r14, r22
	
	/*
	* manually rotate sensor data since rotation method is to slow. 
	*/
	
	frdAccXMss = rawAccY * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
    9a60:	68 a5       	ldd	r22, Y+40	; 0x28
    9a62:	79 a5       	ldd	r23, Y+41	; 0x29
    9a64:	88 27       	eor	r24, r24
    9a66:	77 fd       	sbrc	r23, 7
    9a68:	80 95       	com	r24
    9a6a:	98 2f       	mov	r25, r24
    9a6c:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9a70:	2a e0       	ldi	r18, 0x0A	; 10
    9a72:	38 ee       	ldi	r19, 0xE8	; 232
    9a74:	4c e9       	ldi	r20, 0x9C	; 156
    9a76:	5a e3       	ldi	r21, 0x3A	; 58
    9a78:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
	frdAccYMss = rawAccX * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	frdAccZMss = -rawAccZ * RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER;
	//Multiplying by negative 1 because technically the gravity vector is what we want to be
	//FRD, not the acceleration vector. so since gravity is -9.8 we want to convert it to 9.8.
	frdAccXMss *= -1;
    9a7c:	dc 01       	movw	r26, r24
    9a7e:	cb 01       	movw	r24, r22
    9a80:	b0 58       	subi	r27, 0x80	; 128
    9a82:	8a ab       	std	Y+50, r24	; 0x32
    9a84:	9b ab       	std	Y+51, r25	; 0x33
    9a86:	ac ab       	std	Y+52, r26	; 0x34
    9a88:	bd ab       	std	Y+53, r27	; 0x35
	frdAccYMss *= -1;
    9a8a:	b7 fa       	bst	r11, 7
    9a8c:	b0 94       	com	r11
    9a8e:	b7 f8       	bld	r11, 7
    9a90:	b0 94       	com	r11
    9a92:	8e aa       	std	Y+54, r8	; 0x36
    9a94:	9f aa       	std	Y+55, r9	; 0x37
    9a96:	a8 ae       	std	Y+56, r10	; 0x38
    9a98:	b9 ae       	std	Y+57, r11	; 0x39
	frdAccZMss *= -1;
    9a9a:	f7 fa       	bst	r15, 7
    9a9c:	f0 94       	com	r15
    9a9e:	f7 f8       	bld	r15, 7
    9aa0:	f0 94       	com	r15
    9aa2:	ca ae       	std	Y+58, r12	; 0x3a
    9aa4:	db ae       	std	Y+59, r13	; 0x3b
    9aa6:	ec ae       	std	Y+60, r14	; 0x3c
    9aa8:	fd ae       	std	Y+61, r15	; 0x3d
	
	frdGyroXRs = (rawGyroY - gyroOffsets[1]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9aaa:	7e 01       	movw	r14, r28
    9aac:	8e e3       	ldi	r24, 0x3E	; 62
    9aae:	e8 0e       	add	r14, r24
    9ab0:	f1 1c       	adc	r15, r1
    9ab2:	6e a5       	ldd	r22, Y+46	; 0x2e
    9ab4:	7f a5       	ldd	r23, Y+47	; 0x2f
    9ab6:	88 27       	eor	r24, r24
    9ab8:	77 fd       	sbrc	r23, 7
    9aba:	80 95       	com	r24
    9abc:	98 2f       	mov	r25, r24
    9abe:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9ac2:	fe 01       	movw	r30, r28
    9ac4:	e0 5b       	subi	r30, 0xB0	; 176
    9ac6:	ff 4f       	sbci	r31, 0xFF	; 255
    9ac8:	20 81       	ld	r18, Z
    9aca:	31 81       	ldd	r19, Z+1	; 0x01
    9acc:	42 81       	ldd	r20, Z+2	; 0x02
    9ace:	53 81       	ldd	r21, Z+3	; 0x03
    9ad0:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    9ad4:	25 ea       	ldi	r18, 0xA5	; 165
    9ad6:	39 ee       	ldi	r19, 0xE9	; 233
    9ad8:	4a e6       	ldi	r20, 0x6A	; 106
    9ada:	54 e4       	ldi	r21, 0x44	; 68
    9adc:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9ae0:	f7 01       	movw	r30, r14
    9ae2:	60 83       	st	Z, r22
    9ae4:	71 83       	std	Z+1, r23	; 0x01
    9ae6:	82 83       	std	Z+2, r24	; 0x02
    9ae8:	93 83       	std	Z+3, r25	; 0x03
	frdGyroYRs = (rawGyroX - gyroOffsets[0]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9aea:	7e 01       	movw	r14, r28
    9aec:	f2 e4       	ldi	r31, 0x42	; 66
    9aee:	ef 0e       	add	r14, r31
    9af0:	f1 1c       	adc	r15, r1
    9af2:	6c a5       	ldd	r22, Y+44	; 0x2c
    9af4:	7d a5       	ldd	r23, Y+45	; 0x2d
    9af6:	88 27       	eor	r24, r24
    9af8:	77 fd       	sbrc	r23, 7
    9afa:	80 95       	com	r24
    9afc:	98 2f       	mov	r25, r24
    9afe:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9b02:	fe 01       	movw	r30, r28
    9b04:	e4 5b       	subi	r30, 0xB4	; 180
    9b06:	ff 4f       	sbci	r31, 0xFF	; 255
    9b08:	20 81       	ld	r18, Z
    9b0a:	31 81       	ldd	r19, Z+1	; 0x01
    9b0c:	42 81       	ldd	r20, Z+2	; 0x02
    9b0e:	53 81       	ldd	r21, Z+3	; 0x03
    9b10:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    9b14:	25 ea       	ldi	r18, 0xA5	; 165
    9b16:	39 ee       	ldi	r19, 0xE9	; 233
    9b18:	4a e6       	ldi	r20, 0x6A	; 106
    9b1a:	54 e4       	ldi	r21, 0x44	; 68
    9b1c:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9b20:	f7 01       	movw	r30, r14
    9b22:	60 83       	st	Z, r22
    9b24:	71 83       	std	Z+1, r23	; 0x01
    9b26:	82 83       	std	Z+2, r24	; 0x02
    9b28:	93 83       	std	Z+3, r25	; 0x03
	frdGyroZRs = -(rawGyroZ - gyroOffsets[2]) / RAW_GYRO_TO_RADS_PER_SECOND_CONVERTER;
    9b2a:	7e 01       	movw	r14, r28
    9b2c:	f6 e4       	ldi	r31, 0x46	; 70
    9b2e:	ef 0e       	add	r14, r31
    9b30:	f1 1c       	adc	r15, r1
    9b32:	68 a9       	ldd	r22, Y+48	; 0x30
    9b34:	79 a9       	ldd	r23, Y+49	; 0x31
    9b36:	88 27       	eor	r24, r24
    9b38:	77 fd       	sbrc	r23, 7
    9b3a:	80 95       	com	r24
    9b3c:	98 2f       	mov	r25, r24
    9b3e:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9b42:	cc 5a       	subi	r28, 0xAC	; 172
    9b44:	df 4f       	sbci	r29, 0xFF	; 255
    9b46:	28 81       	ld	r18, Y
    9b48:	39 81       	ldd	r19, Y+1	; 0x01
    9b4a:	4a 81       	ldd	r20, Y+2	; 0x02
    9b4c:	5b 81       	ldd	r21, Y+3	; 0x03
    9b4e:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    9b52:	90 58       	subi	r25, 0x80	; 128
    9b54:	25 ea       	ldi	r18, 0xA5	; 165
    9b56:	39 ee       	ldi	r19, 0xE9	; 233
    9b58:	4a e6       	ldi	r20, 0x6A	; 106
    9b5a:	54 e4       	ldi	r21, 0x44	; 68
    9b5c:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9b60:	f7 01       	movw	r30, r14
    9b62:	60 83       	st	Z, r22
    9b64:	71 83       	std	Z+1, r23	; 0x01
    9b66:	82 83       	std	Z+2, r24	; 0x02
    9b68:	93 83       	std	Z+3, r25	; 0x03
	
	
}
    9b6a:	df 91       	pop	r29
    9b6c:	cf 91       	pop	r28
    9b6e:	ff 90       	pop	r15
    9b70:	ef 90       	pop	r14
    9b72:	df 90       	pop	r13
    9b74:	cf 90       	pop	r12
    9b76:	bf 90       	pop	r11
    9b78:	af 90       	pop	r10
    9b7a:	9f 90       	pop	r9
    9b7c:	8f 90       	pop	r8
    9b7e:	08 95       	ret

00009b80 <_ZN10helicopter7sensors9IMUSensor4initEv>:
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 8192;



void IMUSensor::init()
{
    9b80:	2f 92       	push	r2
    9b82:	3f 92       	push	r3
    9b84:	4f 92       	push	r4
    9b86:	5f 92       	push	r5
    9b88:	6f 92       	push	r6
    9b8a:	7f 92       	push	r7
    9b8c:	8f 92       	push	r8
    9b8e:	9f 92       	push	r9
    9b90:	af 92       	push	r10
    9b92:	bf 92       	push	r11
    9b94:	cf 92       	push	r12
    9b96:	df 92       	push	r13
    9b98:	ef 92       	push	r14
    9b9a:	ff 92       	push	r15
    9b9c:	0f 93       	push	r16
    9b9e:	1f 93       	push	r17
    9ba0:	cf 93       	push	r28
    9ba2:	df 93       	push	r29
    9ba4:	cd b7       	in	r28, 0x3d	; 61
    9ba6:	de b7       	in	r29, 0x3e	; 62
    9ba8:	ac 97       	sbiw	r28, 0x2c	; 44
    9baa:	0f b6       	in	r0, 0x3f	; 63
    9bac:	f8 94       	cli
    9bae:	de bf       	out	0x3e, r29	; 62
    9bb0:	0f be       	out	0x3f, r0	; 63
    9bb2:	cd bf       	out	0x3d, r28	; 61
    9bb4:	9e 83       	std	Y+6, r25	; 0x06
    9bb6:	8d 83       	std	Y+5, r24	; 0x05
	
	//Reset the sensor in case of a soft reset the sensor
	//might still have had power and thus not reset.
	//End the transaction. If I don't close and restart a new
	//transaction, accelerometer data doesn't seem to be able to be read.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_DEVICE_RESET);
    9bb8:	40 e8       	ldi	r20, 0x80	; 128
    9bba:	6b e6       	ldi	r22, 0x6B	; 107
    9bbc:	dc 01       	movw	r26, r24
    9bbe:	94 96       	adiw	r26, 0x24	; 36
    9bc0:	8d 91       	ld	r24, X+
    9bc2:	9c 91       	ld	r25, X
    9bc4:	95 97       	sbiw	r26, 0x25	; 37
    9bc6:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9bca:	bf ef       	ldi	r27, 0xFF	; 255
    9bcc:	e1 ee       	ldi	r30, 0xE1	; 225
    9bce:	f4 e0       	ldi	r31, 0x04	; 4
    9bd0:	b1 50       	subi	r27, 0x01	; 1
    9bd2:	e0 40       	sbci	r30, 0x00	; 0
    9bd4:	f0 40       	sbci	r31, 0x00	; 0
    9bd6:	e1 f7       	brne	.-8      	; 0x9bd0 <_ZN10helicopter7sensors9IMUSensor4initEv+0x50>
    9bd8:	00 c0       	rjmp	.+0      	; 0x9bda <_ZN10helicopter7sensors9IMUSensor4initEv+0x5a>
    9bda:	00 00       	nop
	//wait for device reset
	_delay_ms(100);

	//Select Gyro Z as the reference clock. Selecting a gyro clock
	//is recommended in pag 41 of RM-MPU-6000A.pdf for improved stability.
	spiDriver->transactionWrite(REG_PWR_MGMT_1,BITS_CLKSEL_GYROZ);
    9bdc:	43 e0       	ldi	r20, 0x03	; 3
    9bde:	6b e6       	ldi	r22, 0x6B	; 107
    9be0:	ad 81       	ldd	r26, Y+5	; 0x05
    9be2:	be 81       	ldd	r27, Y+6	; 0x06
    9be4:	94 96       	adiw	r26, 0x24	; 36
    9be6:	8d 91       	ld	r24, X+
    9be8:	9c 91       	ld	r25, X
    9bea:	95 97       	sbiw	r26, 0x25	; 37
    9bec:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9bf0:	bf ef       	ldi	r27, 0xFF	; 255
    9bf2:	e1 ee       	ldi	r30, 0xE1	; 225
    9bf4:	f4 e0       	ldi	r31, 0x04	; 4
    9bf6:	b1 50       	subi	r27, 0x01	; 1
    9bf8:	e0 40       	sbci	r30, 0x00	; 0
    9bfa:	f0 40       	sbci	r31, 0x00	; 0
    9bfc:	e1 f7       	brne	.-8      	; 0x9bf6 <_ZN10helicopter7sensors9IMUSensor4initEv+0x76>
    9bfe:	00 c0       	rjmp	.+0      	; 0x9c00 <_ZN10helicopter7sensors9IMUSensor4initEv+0x80>
    9c00:	00 00       	nop
	//takes a long time and reading accelerometer data
	//returns 0 unless this is done.
	_delay_ms(100);

	//Enable SPI Interface / disable i2c.
	spiDriver->transactionWrite(REG_USER_CTRL,BITS_I2C_IF_DIS);
    9c02:	40 e1       	ldi	r20, 0x10	; 16
    9c04:	6a e6       	ldi	r22, 0x6A	; 106
    9c06:	ad 81       	ldd	r26, Y+5	; 0x05
    9c08:	be 81       	ldd	r27, Y+6	; 0x06
    9c0a:	94 96       	adiw	r26, 0x24	; 36
    9c0c:	8d 91       	ld	r24, X+
    9c0e:	9c 91       	ld	r25, X
    9c10:	95 97       	sbiw	r26, 0x25	; 37
    9c12:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Set the sampling rate to 1kHz.
	spiDriver->transactionWrite(REG_SMPLRT_DIV,BITS_SMPLRT_DIV);
    9c16:	40 e0       	ldi	r20, 0x00	; 0
    9c18:	69 e1       	ldi	r22, 0x19	; 25
    9c1a:	ed 81       	ldd	r30, Y+5	; 0x05
    9c1c:	fe 81       	ldd	r31, Y+6	; 0x06
    9c1e:	84 a1       	ldd	r24, Z+36	; 0x24
    9c20:	95 a1       	ldd	r25, Z+37	; 0x25
    9c22:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	
	//Configures the Digital Low Pass Filter. This is how frequently the sensor readings are updated
	//for accelerometers and gyroscopes.
	spiDriver->transactionWrite(REG_CONFIG,BITS_DLPF_CFG);
    9c26:	42 e0       	ldi	r20, 0x02	; 2
    9c28:	6a e1       	ldi	r22, 0x1A	; 26
    9c2a:	ad 81       	ldd	r26, Y+5	; 0x05
    9c2c:	be 81       	ldd	r27, Y+6	; 0x06
    9c2e:	94 96       	adiw	r26, 0x24	; 36
    9c30:	8d 91       	ld	r24, X+
    9c32:	9c 91       	ld	r25, X
    9c34:	95 97       	sbiw	r26, 0x25	; 37
    9c36:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//Configures the sensitivity / scale range of the gyroscope
	spiDriver->transactionWrite(REG_GYRO_CONFIG,BITS_FS_SEL);
    9c3a:	48 e1       	ldi	r20, 0x18	; 24
    9c3c:	6b e1       	ldi	r22, 0x1B	; 27
    9c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    9c40:	fe 81       	ldd	r31, Y+6	; 0x06
    9c42:	84 a1       	ldd	r24, Z+36	; 0x24
    9c44:	95 a1       	ldd	r25, Z+37	; 0x25
    9c46:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
	
	//configure the sensitivity / scale range of the accelerometer
	spiDriver->transactionWrite(REG_ACCEL_CONFIG,BITS_AFS_SEL);
    9c4a:	48 e0       	ldi	r20, 0x08	; 8
    9c4c:	6c e1       	ldi	r22, 0x1C	; 28
    9c4e:	ad 81       	ldd	r26, Y+5	; 0x05
    9c50:	be 81       	ldd	r27, Y+6	; 0x06
    9c52:	94 96       	adiw	r26, 0x24	; 36
    9c54:	8d 91       	ld	r24, X+
    9c56:	9c 91       	ld	r25, X
    9c58:	95 97       	sbiw	r26, 0x25	; 37
    9c5a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <_ZN10helicopter7drivers9SPIDriver16transactionWriteEhh>
    9c5e:	dd c1       	rjmp	.+954    	; 0xa01a <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
		{
			this->readSensor();
    9c60:	c8 01       	movw	r24, r16
    9c62:	0e 94 b6 4c 	call	0x996c	; 0x996c <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
    9c66:	b1 e0       	ldi	r27, 0x01	; 1
    9c68:	eb 1a       	sub	r14, r27
    9c6a:	f1 08       	sbc	r15, r1
		offsety = 0.0f;
		offsetz = 0.0f;
		
		//read the sensor a few times before start taking the average. 
		//The first gyro reads can be radically different. 
		for (int i = 0; i < 20; i++)
    9c6c:	c9 f7       	brne	.-14     	; 0x9c60 <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			this->readSensor();
		}
		


		float minoffsetx = this->rawGyroX;
    9c6e:	ed 81       	ldd	r30, Y+5	; 0x05
    9c70:	fe 81       	ldd	r31, Y+6	; 0x06
    9c72:	64 a5       	ldd	r22, Z+44	; 0x2c
    9c74:	75 a5       	ldd	r23, Z+45	; 0x2d
    9c76:	88 27       	eor	r24, r24
    9c78:	77 fd       	sbrc	r23, 7
    9c7a:	80 95       	com	r24
    9c7c:	98 2f       	mov	r25, r24
    9c7e:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9c82:	06 2f       	mov	r16, r22
    9c84:	17 2f       	mov	r17, r23
    9c86:	a8 2e       	mov	r10, r24
    9c88:	b9 2e       	mov	r11, r25
    9c8a:	6b 8b       	std	Y+19, r22	; 0x13
    9c8c:	7c 8b       	std	Y+20, r23	; 0x14
    9c8e:	8d 8b       	std	Y+21, r24	; 0x15
    9c90:	9e 8b       	std	Y+22, r25	; 0x16
		float minoffsety = this->rawGyroY;
    9c92:	ad 81       	ldd	r26, Y+5	; 0x05
    9c94:	be 81       	ldd	r27, Y+6	; 0x06
    9c96:	9e 96       	adiw	r26, 0x2e	; 46
    9c98:	6d 91       	ld	r22, X+
    9c9a:	7c 91       	ld	r23, X
    9c9c:	9f 97       	sbiw	r26, 0x2f	; 47
    9c9e:	88 27       	eor	r24, r24
    9ca0:	77 fd       	sbrc	r23, 7
    9ca2:	80 95       	com	r24
    9ca4:	98 2f       	mov	r25, r24
    9ca6:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9caa:	c6 2e       	mov	r12, r22
    9cac:	d7 2e       	mov	r13, r23
    9cae:	e8 2e       	mov	r14, r24
    9cb0:	f9 2e       	mov	r15, r25
    9cb2:	6b 8f       	std	Y+27, r22	; 0x1b
    9cb4:	7c 8f       	std	Y+28, r23	; 0x1c
    9cb6:	8d 8f       	std	Y+29, r24	; 0x1d
    9cb8:	9e 8f       	std	Y+30, r25	; 0x1e
		float minoffsetz = this->rawGyroZ;
    9cba:	ed 81       	ldd	r30, Y+5	; 0x05
    9cbc:	fe 81       	ldd	r31, Y+6	; 0x06
    9cbe:	60 a9       	ldd	r22, Z+48	; 0x30
    9cc0:	71 a9       	ldd	r23, Z+49	; 0x31
    9cc2:	88 27       	eor	r24, r24
    9cc4:	77 fd       	sbrc	r23, 7
    9cc6:	80 95       	com	r24
    9cc8:	98 2f       	mov	r25, r24
    9cca:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9cce:	6b a3       	std	Y+35, r22	; 0x23
    9cd0:	7c a3       	std	Y+36, r23	; 0x24
    9cd2:	8d a3       	std	Y+37, r24	; 0x25
    9cd4:	9e a3       	std	Y+38, r25	; 0x26
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
    9cd6:	6f a3       	std	Y+39, r22	; 0x27
    9cd8:	78 a7       	std	Y+40, r23	; 0x28
    9cda:	89 a7       	std	Y+41, r24	; 0x29
    9cdc:	9a a7       	std	Y+42, r25	; 0x2a
		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
    9cde:	cf 8e       	std	Y+31, r12	; 0x1f
    9ce0:	d8 a2       	std	Y+32, r13	; 0x20
    9ce2:	e9 a2       	std	Y+33, r14	; 0x21
    9ce4:	fa a2       	std	Y+34, r15	; 0x22

		float minoffsetx = this->rawGyroX;
		float minoffsety = this->rawGyroY;
		float minoffsetz = this->rawGyroZ;
		
		float maxoffsetx = this->rawGyroX;
    9ce6:	0f 8b       	std	Y+23, r16	; 0x17
    9ce8:	18 8f       	std	Y+24, r17	; 0x18
    9cea:	a9 8e       	std	Y+25, r10	; 0x19
    9cec:	ba 8e       	std	Y+26, r11	; 0x1a
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    9cee:	61 2c       	mov	r6, r1
    9cf0:	71 2c       	mov	r7, r1
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
		offsetz = 0.0f;
    9cf2:	1f 86       	std	Y+15, r1	; 0x0f
    9cf4:	18 8a       	std	Y+16, r1	; 0x10
    9cf6:	19 8a       	std	Y+17, r1	; 0x11
    9cf8:	1a 8a       	std	Y+18, r1	; 0x12
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
		offsety = 0.0f;
    9cfa:	1b 86       	std	Y+11, r1	; 0x0b
    9cfc:	1c 86       	std	Y+12, r1	; 0x0c
    9cfe:	1d 86       	std	Y+13, r1	; 0x0d
    9d00:	1e 86       	std	Y+14, r1	; 0x0e
	
	bool isStable = false;
	
	while (!isStable)
	{
		offsetx = 0.0f;
    9d02:	1f 82       	std	Y+7, r1	; 0x07
    9d04:	18 86       	std	Y+8, r1	; 0x08
    9d06:	19 86       	std	Y+9, r1	; 0x09
    9d08:	1a 86       	std	Y+10, r1	; 0x0a
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
		{
			this->readSensor();
    9d0a:	8d 81       	ldd	r24, Y+5	; 0x05
    9d0c:	9e 81       	ldd	r25, Y+6	; 0x06
    9d0e:	0e 94 b6 4c 	call	0x996c	; 0x996c <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
		
			offsetx = (this->rawGyroX + i*offsetx) / (i+1);
    9d12:	ad 81       	ldd	r26, Y+5	; 0x05
    9d14:	be 81       	ldd	r27, Y+6	; 0x06
    9d16:	9c 96       	adiw	r26, 0x2c	; 44
    9d18:	6d 91       	ld	r22, X+
    9d1a:	7c 91       	ld	r23, X
    9d1c:	9d 97       	sbiw	r26, 0x2d	; 45
    9d1e:	88 27       	eor	r24, r24
    9d20:	77 fd       	sbrc	r23, 7
    9d22:	80 95       	com	r24
    9d24:	98 2f       	mov	r25, r24
    9d26:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9d2a:	26 2e       	mov	r2, r22
    9d2c:	37 2e       	mov	r3, r23
    9d2e:	89 83       	std	Y+1, r24	; 0x01
    9d30:	9a 83       	std	Y+2, r25	; 0x02
    9d32:	b3 01       	movw	r22, r6
    9d34:	88 27       	eor	r24, r24
    9d36:	77 fd       	sbrc	r23, 7
    9d38:	80 95       	com	r24
    9d3a:	98 2f       	mov	r25, r24
    9d3c:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9d40:	4b 01       	movw	r8, r22
    9d42:	5c 01       	movw	r10, r24
    9d44:	7f 81       	ldd	r23, Y+7	; 0x07
    9d46:	68 85       	ldd	r22, Y+8	; 0x08
    9d48:	99 85       	ldd	r25, Y+9	; 0x09
    9d4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    9d4c:	27 2f       	mov	r18, r23
    9d4e:	36 2f       	mov	r19, r22
    9d50:	49 2f       	mov	r20, r25
    9d52:	58 2f       	mov	r21, r24
    9d54:	c5 01       	movw	r24, r10
    9d56:	b4 01       	movw	r22, r8
    9d58:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    9d5c:	9b 01       	movw	r18, r22
    9d5e:	ac 01       	movw	r20, r24
    9d60:	e9 81       	ldd	r30, Y+1	; 0x01
    9d62:	1a 81       	ldd	r17, Y+2	; 0x02
    9d64:	62 2d       	mov	r22, r2
    9d66:	73 2d       	mov	r23, r3
    9d68:	8e 2f       	mov	r24, r30
    9d6a:	91 2f       	mov	r25, r17
    9d6c:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    9d70:	06 2f       	mov	r16, r22
    9d72:	17 2f       	mov	r17, r23
    9d74:	48 2e       	mov	r4, r24
    9d76:	59 2e       	mov	r5, r25
    9d78:	bf ef       	ldi	r27, 0xFF	; 255
    9d7a:	6b 1a       	sub	r6, r27
    9d7c:	7b 0a       	sbc	r7, r27
    9d7e:	b3 01       	movw	r22, r6
    9d80:	88 27       	eor	r24, r24
    9d82:	77 fd       	sbrc	r23, 7
    9d84:	80 95       	com	r24
    9d86:	98 2f       	mov	r25, r24
    9d88:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9d8c:	6b 01       	movw	r12, r22
    9d8e:	7c 01       	movw	r14, r24
    9d90:	9b 01       	movw	r18, r22
    9d92:	ac 01       	movw	r20, r24
    9d94:	60 2f       	mov	r22, r16
    9d96:	71 2f       	mov	r23, r17
    9d98:	84 2d       	mov	r24, r4
    9d9a:	95 2d       	mov	r25, r5
    9d9c:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9da0:	6f 83       	std	Y+7, r22	; 0x07
    9da2:	78 87       	std	Y+8, r23	; 0x08
    9da4:	89 87       	std	Y+9, r24	; 0x09
    9da6:	9a 87       	std	Y+10, r25	; 0x0a
			offsety = (this->rawGyroY + i*offsety) / (i+1);
    9da8:	ed 81       	ldd	r30, Y+5	; 0x05
    9daa:	fe 81       	ldd	r31, Y+6	; 0x06
    9dac:	66 a5       	ldd	r22, Z+46	; 0x2e
    9dae:	77 a5       	ldd	r23, Z+47	; 0x2f
    9db0:	88 27       	eor	r24, r24
    9db2:	77 fd       	sbrc	r23, 7
    9db4:	80 95       	com	r24
    9db6:	98 2f       	mov	r25, r24
    9db8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9dbc:	46 2e       	mov	r4, r22
    9dbe:	57 2e       	mov	r5, r23
    9dc0:	8b 83       	std	Y+3, r24	; 0x03
    9dc2:	9c 83       	std	Y+4, r25	; 0x04
    9dc4:	a5 01       	movw	r20, r10
    9dc6:	94 01       	movw	r18, r8
    9dc8:	bb 85       	ldd	r27, Y+11	; 0x0b
    9dca:	ac 85       	ldd	r26, Y+12	; 0x0c
    9dcc:	ed 85       	ldd	r30, Y+13	; 0x0d
    9dce:	1e 85       	ldd	r17, Y+14	; 0x0e
    9dd0:	6b 2f       	mov	r22, r27
    9dd2:	7a 2f       	mov	r23, r26
    9dd4:	8e 2f       	mov	r24, r30
    9dd6:	91 2f       	mov	r25, r17
    9dd8:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    9ddc:	9b 01       	movw	r18, r22
    9dde:	ac 01       	movw	r20, r24
    9de0:	eb 81       	ldd	r30, Y+3	; 0x03
    9de2:	1c 81       	ldd	r17, Y+4	; 0x04
    9de4:	64 2d       	mov	r22, r4
    9de6:	75 2d       	mov	r23, r5
    9de8:	8e 2f       	mov	r24, r30
    9dea:	91 2f       	mov	r25, r17
    9dec:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    9df0:	a7 01       	movw	r20, r14
    9df2:	96 01       	movw	r18, r12
    9df4:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9df8:	6b 87       	std	Y+11, r22	; 0x0b
    9dfa:	7c 87       	std	Y+12, r23	; 0x0c
    9dfc:	8d 87       	std	Y+13, r24	; 0x0d
    9dfe:	9e 87       	std	Y+14, r25	; 0x0e
			offsetz = (this->rawGyroZ + i*offsetz) / (i+1);
    9e00:	ad 81       	ldd	r26, Y+5	; 0x05
    9e02:	be 81       	ldd	r27, Y+6	; 0x06
    9e04:	d0 96       	adiw	r26, 0x30	; 48
    9e06:	6d 91       	ld	r22, X+
    9e08:	7c 91       	ld	r23, X
    9e0a:	d1 97       	sbiw	r26, 0x31	; 49
    9e0c:	88 27       	eor	r24, r24
    9e0e:	77 fd       	sbrc	r23, 7
    9e10:	80 95       	com	r24
    9e12:	98 2f       	mov	r25, r24
    9e14:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    9e18:	06 2f       	mov	r16, r22
    9e1a:	17 2f       	mov	r17, r23
    9e1c:	8c a7       	std	Y+44, r24	; 0x2c
    9e1e:	9b a7       	std	Y+43, r25	; 0x2b
    9e20:	a5 01       	movw	r20, r10
    9e22:	94 01       	movw	r18, r8
    9e24:	bf 85       	ldd	r27, Y+15	; 0x0f
    9e26:	a8 89       	ldd	r26, Y+16	; 0x10
    9e28:	b9 88       	ldd	r11, Y+17	; 0x11
    9e2a:	aa 88       	ldd	r10, Y+18	; 0x12
    9e2c:	6b 2f       	mov	r22, r27
    9e2e:	7a 2f       	mov	r23, r26
    9e30:	8b 2d       	mov	r24, r11
    9e32:	9a 2d       	mov	r25, r10
    9e34:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    9e38:	9b 01       	movw	r18, r22
    9e3a:	ac 01       	movw	r20, r24
    9e3c:	fc a5       	ldd	r31, Y+44	; 0x2c
    9e3e:	eb a5       	ldd	r30, Y+43	; 0x2b
    9e40:	60 2f       	mov	r22, r16
    9e42:	71 2f       	mov	r23, r17
    9e44:	8f 2f       	mov	r24, r31
    9e46:	9e 2f       	mov	r25, r30
    9e48:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    9e4c:	a7 01       	movw	r20, r14
    9e4e:	96 01       	movw	r18, r12
    9e50:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    9e54:	6f 87       	std	Y+15, r22	; 0x0f
    9e56:	78 8b       	std	Y+16, r23	; 0x10
    9e58:	89 8b       	std	Y+17, r24	; 0x11
    9e5a:	9a 8b       	std	Y+18, r25	; 0x12
			
			minoffsetx = this->rawGyroX < minoffsetx ? this->rawGyroX : minoffsetx;
    9e5c:	7b 89       	ldd	r23, Y+19	; 0x13
    9e5e:	6c 89       	ldd	r22, Y+20	; 0x14
    9e60:	9d 89       	ldd	r25, Y+21	; 0x15
    9e62:	8e 89       	ldd	r24, Y+22	; 0x16
    9e64:	27 2f       	mov	r18, r23
    9e66:	36 2f       	mov	r19, r22
    9e68:	49 2f       	mov	r20, r25
    9e6a:	58 2f       	mov	r21, r24
    9e6c:	f9 80       	ldd	r15, Y+1	; 0x01
    9e6e:	ea 80       	ldd	r14, Y+2	; 0x02
    9e70:	62 2d       	mov	r22, r2
    9e72:	73 2d       	mov	r23, r3
    9e74:	8f 2d       	mov	r24, r15
    9e76:	9e 2d       	mov	r25, r14
    9e78:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    9e7c:	88 23       	and	r24, r24
    9e7e:	24 f4       	brge	.+8      	; 0x9e88 <_ZN10helicopter7sensors9IMUSensor4initEv+0x308>
    9e80:	2b 8a       	std	Y+19, r2	; 0x13
    9e82:	3c 8a       	std	Y+20, r3	; 0x14
    9e84:	fd 8a       	std	Y+21, r15	; 0x15
    9e86:	ee 8a       	std	Y+22, r14	; 0x16
			minoffsety = this->rawGyroY < minoffsety ? this->rawGyroY : minoffsety;
    9e88:	7b 8d       	ldd	r23, Y+27	; 0x1b
    9e8a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9e8c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    9e8e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9e90:	27 2f       	mov	r18, r23
    9e92:	36 2f       	mov	r19, r22
    9e94:	49 2f       	mov	r20, r25
    9e96:	58 2f       	mov	r21, r24
    9e98:	fb 80       	ldd	r15, Y+3	; 0x03
    9e9a:	ec 80       	ldd	r14, Y+4	; 0x04
    9e9c:	64 2d       	mov	r22, r4
    9e9e:	75 2d       	mov	r23, r5
    9ea0:	8f 2d       	mov	r24, r15
    9ea2:	9e 2d       	mov	r25, r14
    9ea4:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    9ea8:	88 23       	and	r24, r24
    9eaa:	24 f4       	brge	.+8      	; 0x9eb4 <_ZN10helicopter7sensors9IMUSensor4initEv+0x334>
    9eac:	4b 8e       	std	Y+27, r4	; 0x1b
    9eae:	5c 8e       	std	Y+28, r5	; 0x1c
    9eb0:	fd 8e       	std	Y+29, r15	; 0x1d
    9eb2:	ee 8e       	std	Y+30, r14	; 0x1e
			minoffsetz = this->rawGyroZ < minoffsetz ? this->rawGyroZ : minoffsetz;
    9eb4:	7b a1       	ldd	r23, Y+35	; 0x23
    9eb6:	6c a1       	ldd	r22, Y+36	; 0x24
    9eb8:	9d a1       	ldd	r25, Y+37	; 0x25
    9eba:	8e a1       	ldd	r24, Y+38	; 0x26
    9ebc:	27 2f       	mov	r18, r23
    9ebe:	36 2f       	mov	r19, r22
    9ec0:	49 2f       	mov	r20, r25
    9ec2:	58 2f       	mov	r21, r24
    9ec4:	fc a5       	ldd	r31, Y+44	; 0x2c
    9ec6:	eb a5       	ldd	r30, Y+43	; 0x2b
    9ec8:	60 2f       	mov	r22, r16
    9eca:	71 2f       	mov	r23, r17
    9ecc:	8f 2f       	mov	r24, r31
    9ece:	9e 2f       	mov	r25, r30
    9ed0:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    9ed4:	88 23       	and	r24, r24
    9ed6:	34 f4       	brge	.+12     	; 0x9ee4 <_ZN10helicopter7sensors9IMUSensor4initEv+0x364>
    9ed8:	0b a3       	std	Y+35, r16	; 0x23
    9eda:	1c a3       	std	Y+36, r17	; 0x24
    9edc:	8c a5       	ldd	r24, Y+44	; 0x2c
    9ede:	8d a3       	std	Y+37, r24	; 0x25
    9ee0:	9b a5       	ldd	r25, Y+43	; 0x2b
    9ee2:	9e a3       	std	Y+38, r25	; 0x26
			
			maxoffsetx = this->rawGyroX > maxoffsetx ? this->rawGyroX : maxoffsetx;
    9ee4:	7f 89       	ldd	r23, Y+23	; 0x17
    9ee6:	68 8d       	ldd	r22, Y+24	; 0x18
    9ee8:	99 8d       	ldd	r25, Y+25	; 0x19
    9eea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9eec:	27 2f       	mov	r18, r23
    9eee:	36 2f       	mov	r19, r22
    9ef0:	49 2f       	mov	r20, r25
    9ef2:	58 2f       	mov	r21, r24
    9ef4:	f9 80       	ldd	r15, Y+1	; 0x01
    9ef6:	ea 80       	ldd	r14, Y+2	; 0x02
    9ef8:	62 2d       	mov	r22, r2
    9efa:	73 2d       	mov	r23, r3
    9efc:	8f 2d       	mov	r24, r15
    9efe:	9e 2d       	mov	r25, r14
    9f00:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    9f04:	18 16       	cp	r1, r24
    9f06:	24 f4       	brge	.+8      	; 0x9f10 <_ZN10helicopter7sensors9IMUSensor4initEv+0x390>
    9f08:	2f 8a       	std	Y+23, r2	; 0x17
    9f0a:	38 8e       	std	Y+24, r3	; 0x18
    9f0c:	f9 8e       	std	Y+25, r15	; 0x19
    9f0e:	ea 8e       	std	Y+26, r14	; 0x1a
			maxoffsety = this->rawGyroY > maxoffsety ? this->rawGyroY : maxoffsety;
    9f10:	7f 8d       	ldd	r23, Y+31	; 0x1f
    9f12:	68 a1       	ldd	r22, Y+32	; 0x20
    9f14:	99 a1       	ldd	r25, Y+33	; 0x21
    9f16:	8a a1       	ldd	r24, Y+34	; 0x22
    9f18:	27 2f       	mov	r18, r23
    9f1a:	36 2f       	mov	r19, r22
    9f1c:	49 2f       	mov	r20, r25
    9f1e:	58 2f       	mov	r21, r24
    9f20:	fb 80       	ldd	r15, Y+3	; 0x03
    9f22:	ec 80       	ldd	r14, Y+4	; 0x04
    9f24:	64 2d       	mov	r22, r4
    9f26:	75 2d       	mov	r23, r5
    9f28:	8f 2d       	mov	r24, r15
    9f2a:	9e 2d       	mov	r25, r14
    9f2c:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    9f30:	18 16       	cp	r1, r24
    9f32:	24 f4       	brge	.+8      	; 0x9f3c <_ZN10helicopter7sensors9IMUSensor4initEv+0x3bc>
    9f34:	4f 8e       	std	Y+31, r4	; 0x1f
    9f36:	58 a2       	std	Y+32, r5	; 0x20
    9f38:	f9 a2       	std	Y+33, r15	; 0x21
    9f3a:	ea a2       	std	Y+34, r14	; 0x22
			maxoffsetz = this->rawGyroZ > maxoffsetz ? this->rawGyroZ : maxoffsetz;
    9f3c:	7f a1       	ldd	r23, Y+39	; 0x27
    9f3e:	68 a5       	ldd	r22, Y+40	; 0x28
    9f40:	99 a5       	ldd	r25, Y+41	; 0x29
    9f42:	8a a5       	ldd	r24, Y+42	; 0x2a
    9f44:	27 2f       	mov	r18, r23
    9f46:	36 2f       	mov	r19, r22
    9f48:	49 2f       	mov	r20, r25
    9f4a:	58 2f       	mov	r21, r24
    9f4c:	fc a5       	ldd	r31, Y+44	; 0x2c
    9f4e:	eb a5       	ldd	r30, Y+43	; 0x2b
    9f50:	60 2f       	mov	r22, r16
    9f52:	71 2f       	mov	r23, r17
    9f54:	8f 2f       	mov	r24, r31
    9f56:	9e 2f       	mov	r25, r30
    9f58:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    9f5c:	18 16       	cp	r1, r24
    9f5e:	34 f4       	brge	.+12     	; 0x9f6c <_ZN10helicopter7sensors9IMUSensor4initEv+0x3ec>
    9f60:	0f a3       	std	Y+39, r16	; 0x27
    9f62:	18 a7       	std	Y+40, r17	; 0x28
    9f64:	2c a5       	ldd	r18, Y+44	; 0x2c
    9f66:	29 a7       	std	Y+41, r18	; 0x29
    9f68:	8b a5       	ldd	r24, Y+43	; 0x2b
    9f6a:	8a a7       	std	Y+42, r24	; 0x2a
		float maxoffsetx = this->rawGyroX;
		float maxoffsety = this->rawGyroY;
		float maxoffsetz = this->rawGyroZ;	
	
		//determine offsets for the gyroscopes by calculating the rolling average
		for (int i = 0; i < 1000; i++)
    9f6c:	98 ee       	ldi	r25, 0xE8	; 232
    9f6e:	69 16       	cp	r6, r25
    9f70:	93 e0       	ldi	r25, 0x03	; 3
    9f72:	79 06       	cpc	r7, r25
    9f74:	09 f0       	breq	.+2      	; 0x9f78 <_ZN10helicopter7sensors9IMUSensor4initEv+0x3f8>
    9f76:	c9 ce       	rjmp	.-622    	; 0x9d0a <_ZN10helicopter7sensors9IMUSensor4initEv+0x18a>
			
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
    9f78:	7b 89       	ldd	r23, Y+19	; 0x13
    9f7a:	6c 89       	ldd	r22, Y+20	; 0x14
    9f7c:	9d 89       	ldd	r25, Y+21	; 0x15
    9f7e:	8e 89       	ldd	r24, Y+22	; 0x16
    9f80:	27 2f       	mov	r18, r23
    9f82:	36 2f       	mov	r19, r22
    9f84:	49 2f       	mov	r20, r25
    9f86:	58 2f       	mov	r21, r24
    9f88:	bf 89       	ldd	r27, Y+23	; 0x17
    9f8a:	a8 8d       	ldd	r26, Y+24	; 0x18
    9f8c:	e9 8d       	ldd	r30, Y+25	; 0x19
    9f8e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    9f90:	6b 2f       	mov	r22, r27
    9f92:	7a 2f       	mov	r23, r26
    9f94:	8e 2f       	mov	r24, r30
    9f96:	91 2f       	mov	r25, r17
    9f98:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    9f9c:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    9f9e:	20 e0       	ldi	r18, 0x00	; 0
    9fa0:	30 e0       	ldi	r19, 0x00	; 0
    9fa2:	40 e2       	ldi	r20, 0x20	; 32
    9fa4:	51 e4       	ldi	r21, 0x41	; 65
    9fa6:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    9faa:	88 23       	and	r24, r24
    9fac:	b4 f5       	brge	.+108    	; 0xa01a <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
			
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
    9fae:	7b 8d       	ldd	r23, Y+27	; 0x1b
    9fb0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9fb2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    9fb4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9fb6:	27 2f       	mov	r18, r23
    9fb8:	36 2f       	mov	r19, r22
    9fba:	49 2f       	mov	r20, r25
    9fbc:	58 2f       	mov	r21, r24
    9fbe:	bf 8d       	ldd	r27, Y+31	; 0x1f
    9fc0:	a8 a1       	ldd	r26, Y+32	; 0x20
    9fc2:	e9 a1       	ldd	r30, Y+33	; 0x21
    9fc4:	1a a1       	ldd	r17, Y+34	; 0x22
    9fc6:	6b 2f       	mov	r22, r27
    9fc8:	7a 2f       	mov	r23, r26
    9fca:	8e 2f       	mov	r24, r30
    9fcc:	91 2f       	mov	r25, r17
    9fce:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    9fd2:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    9fd4:	20 e0       	ldi	r18, 0x00	; 0
    9fd6:	30 e0       	ldi	r19, 0x00	; 0
    9fd8:	40 e2       	ldi	r20, 0x20	; 32
    9fda:	51 e4       	ldi	r21, 0x41	; 65
    9fdc:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    9fe0:	88 23       	and	r24, r24
    9fe2:	dc f4       	brge	.+54     	; 0xa01a <_ZN10helicopter7sensors9IMUSensor4initEv+0x49a>
		}

		
		float differenceX = fabs(maxoffsetx - minoffsetx);
		float differenceY = fabs(maxoffsety - minoffsety);
		float differenceZ = fabs(maxoffsetz - minoffsetz);
    9fe4:	7b a1       	ldd	r23, Y+35	; 0x23
    9fe6:	6c a1       	ldd	r22, Y+36	; 0x24
    9fe8:	9d a1       	ldd	r25, Y+37	; 0x25
    9fea:	8e a1       	ldd	r24, Y+38	; 0x26
    9fec:	27 2f       	mov	r18, r23
    9fee:	36 2f       	mov	r19, r22
    9ff0:	49 2f       	mov	r20, r25
    9ff2:	58 2f       	mov	r21, r24
    9ff4:	bf a1       	ldd	r27, Y+39	; 0x27
    9ff6:	a8 a5       	ldd	r26, Y+40	; 0x28
    9ff8:	e9 a5       	ldd	r30, Y+41	; 0x29
    9ffa:	1a a5       	ldd	r17, Y+42	; 0x2a
    9ffc:	6b 2f       	mov	r22, r27
    9ffe:	7a 2f       	mov	r23, r26
    a000:	8e 2f       	mov	r24, r30
    a002:	91 2f       	mov	r25, r17
    a004:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    a008:	9f 77       	andi	r25, 0x7F	; 127
		 * Ensure that the difference between the amximum gyro reading and min gyro reading
		 * is below a threshold. This is so that if the heli is moving when it starts up,
		 * the system doesn't start up with a huge gyro offset which would cause the helicopter
		 * to think that it's moving constantly. 
		 */
		if (differenceX < 10 && differenceY < 10 && differenceZ < 10)
    a00a:	20 e0       	ldi	r18, 0x00	; 0
    a00c:	30 e0       	ldi	r19, 0x00	; 0
    a00e:	40 e2       	ldi	r20, 0x20	; 32
    a010:	51 e4       	ldi	r21, 0x41	; 65
    a012:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    a016:	88 23       	and	r24, r24
    a018:	44 f0       	brlt	.+16     	; 0xa02a <_ZN10helicopter7sensors9IMUSensor4initEv+0x4aa>
const float IMUSensor::RAW_ACC_TO_RADS_PER_SECOND_SECOND_CONVERTER = GRAVITY_MSS / 8192;



void IMUSensor::init()
{
    a01a:	0f 2e       	mov	r0, r31
    a01c:	f4 e1       	ldi	r31, 0x14	; 20
    a01e:	ef 2e       	mov	r14, r31
    a020:	f1 2c       	mov	r15, r1
    a022:	f0 2d       	mov	r31, r0
    a024:	0d 81       	ldd	r16, Y+5	; 0x05
    a026:	1e 81       	ldd	r17, Y+6	; 0x06
    a028:	1b ce       	rjmp	.-970    	; 0x9c60 <_ZN10helicopter7sensors9IMUSensor4initEv+0xe0>
			isStable = true;
		}
		
	}
	
	this->gyroOffsets[0] = offsetx;
    a02a:	ed 81       	ldd	r30, Y+5	; 0x05
    a02c:	fe 81       	ldd	r31, Y+6	; 0x06
    a02e:	e4 5b       	subi	r30, 0xB4	; 180
    a030:	ff 4f       	sbci	r31, 0xFF	; 255
    a032:	5f 81       	ldd	r21, Y+7	; 0x07
    a034:	48 85       	ldd	r20, Y+8	; 0x08
    a036:	39 85       	ldd	r19, Y+9	; 0x09
    a038:	2a 85       	ldd	r18, Y+10	; 0x0a
    a03a:	85 2f       	mov	r24, r21
    a03c:	94 2f       	mov	r25, r20
    a03e:	a3 2f       	mov	r26, r19
    a040:	b2 2f       	mov	r27, r18
    a042:	80 83       	st	Z, r24
    a044:	91 83       	std	Z+1, r25	; 0x01
    a046:	a2 83       	std	Z+2, r26	; 0x02
    a048:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[1] = offsety;
    a04a:	ed 81       	ldd	r30, Y+5	; 0x05
    a04c:	fe 81       	ldd	r31, Y+6	; 0x06
    a04e:	e0 5b       	subi	r30, 0xB0	; 176
    a050:	ff 4f       	sbci	r31, 0xFF	; 255
    a052:	5b 85       	ldd	r21, Y+11	; 0x0b
    a054:	4c 85       	ldd	r20, Y+12	; 0x0c
    a056:	3d 85       	ldd	r19, Y+13	; 0x0d
    a058:	2e 85       	ldd	r18, Y+14	; 0x0e
    a05a:	85 2f       	mov	r24, r21
    a05c:	94 2f       	mov	r25, r20
    a05e:	a3 2f       	mov	r26, r19
    a060:	b2 2f       	mov	r27, r18
    a062:	80 83       	st	Z, r24
    a064:	91 83       	std	Z+1, r25	; 0x01
    a066:	a2 83       	std	Z+2, r26	; 0x02
    a068:	b3 83       	std	Z+3, r27	; 0x03
	this->gyroOffsets[2] = offsetz;
    a06a:	ed 81       	ldd	r30, Y+5	; 0x05
    a06c:	fe 81       	ldd	r31, Y+6	; 0x06
    a06e:	ec 5a       	subi	r30, 0xAC	; 172
    a070:	ff 4f       	sbci	r31, 0xFF	; 255
    a072:	5f 85       	ldd	r21, Y+15	; 0x0f
    a074:	48 89       	ldd	r20, Y+16	; 0x10
    a076:	39 89       	ldd	r19, Y+17	; 0x11
    a078:	2a 89       	ldd	r18, Y+18	; 0x12
    a07a:	85 2f       	mov	r24, r21
    a07c:	94 2f       	mov	r25, r20
    a07e:	a3 2f       	mov	r26, r19
    a080:	b2 2f       	mov	r27, r18
    a082:	80 83       	st	Z, r24
    a084:	91 83       	std	Z+1, r25	; 0x01
    a086:	a2 83       	std	Z+2, r26	; 0x02
    a088:	b3 83       	std	Z+3, r27	; 0x03
	
}
    a08a:	ac 96       	adiw	r28, 0x2c	; 44
    a08c:	0f b6       	in	r0, 0x3f	; 63
    a08e:	f8 94       	cli
    a090:	de bf       	out	0x3e, r29	; 62
    a092:	0f be       	out	0x3f, r0	; 63
    a094:	cd bf       	out	0x3d, r28	; 61
    a096:	df 91       	pop	r29
    a098:	cf 91       	pop	r28
    a09a:	1f 91       	pop	r17
    a09c:	0f 91       	pop	r16
    a09e:	ff 90       	pop	r15
    a0a0:	ef 90       	pop	r14
    a0a2:	df 90       	pop	r13
    a0a4:	cf 90       	pop	r12
    a0a6:	bf 90       	pop	r11
    a0a8:	af 90       	pop	r10
    a0aa:	9f 90       	pop	r9
    a0ac:	8f 90       	pop	r8
    a0ae:	7f 90       	pop	r7
    a0b0:	6f 90       	pop	r6
    a0b2:	5f 90       	pop	r5
    a0b4:	4f 90       	pop	r4
    a0b6:	3f 90       	pop	r3
    a0b8:	2f 90       	pop	r2
    a0ba:	08 95       	ret

0000a0bc <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE>:
		_offset[1] = new_offsets[1];
		_offset[2] = new_offsets[2];
	
}

MagnetometerSensor::MagnetometerSensor(TWIDriver *driver):
    a0bc:	cf 92       	push	r12
    a0be:	df 92       	push	r13
    a0c0:	ef 92       	push	r14
    a0c2:	ff 92       	push	r15
    a0c4:	0f 93       	push	r16
    a0c6:	1f 93       	push	r17
    a0c8:	fc 01       	movw	r30, r24
	rawMagY(0),
	rawMagZ(0),
	frdMagX(0),
	frdMagY(0),
	frdMagZ(0),
	driver(driver)
    a0ca:	11 82       	std	Z+1, r1	; 0x01
    a0cc:	10 82       	st	Z, r1
    a0ce:	13 82       	std	Z+3, r1	; 0x03
    a0d0:	12 82       	std	Z+2, r1	; 0x02
    a0d2:	15 82       	std	Z+5, r1	; 0x05
    a0d4:	14 82       	std	Z+4, r1	; 0x04
    a0d6:	16 82       	std	Z+6, r1	; 0x06
    a0d8:	17 82       	std	Z+7, r1	; 0x07
    a0da:	10 86       	std	Z+8, r1	; 0x08
    a0dc:	11 86       	std	Z+9, r1	; 0x09
    a0de:	12 86       	std	Z+10, r1	; 0x0a
    a0e0:	13 86       	std	Z+11, r1	; 0x0b
    a0e2:	14 86       	std	Z+12, r1	; 0x0c
    a0e4:	15 86       	std	Z+13, r1	; 0x0d
    a0e6:	16 86       	std	Z+14, r1	; 0x0e
    a0e8:	17 86       	std	Z+15, r1	; 0x0f
    a0ea:	10 8a       	std	Z+16, r1	; 0x10
    a0ec:	11 8a       	std	Z+17, r1	; 0x11
    a0ee:	77 ab       	std	Z+55, r23	; 0x37
    a0f0:	66 ab       	std	Z+54, r22	; 0x36
	/**
		* Create a rotation matrix to rotate the magnetometer sensor data by
		* 180 degrees on the x axis, then 0 degrees on the y axis, then 90 degrees 
		* counterclockwise on the Z axis.
		*/
	memset(magLBUToFRDRotationMatrix,0,sizeof(magLBUToFRDRotationMatrix));
    a0f2:	6c 01       	movw	r12, r24
    a0f4:	82 e1       	ldi	r24, 0x12	; 18
    a0f6:	c8 0e       	add	r12, r24
    a0f8:	d1 1c       	adc	r13, r1
    a0fa:	84 e2       	ldi	r24, 0x24	; 36
    a0fc:	f6 01       	movw	r30, r12
    a0fe:	11 92       	st	Z+, r1
    a100:	8a 95       	dec	r24
    a102:	e9 f7       	brne	.-6      	; 0xa0fe <_ZN10helicopter7sensors18MagnetometerSensorC1EPNS_7drivers9TWIDriverE+0x42>
					
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
	MatrixUtil::CreateRotationMatrix(0.0f, 0.0f, (M_PI/2.0f), magLBUToFRDRotationMatrix);
    a104:	1b ed       	ldi	r17, 0xDB	; 219
    a106:	e1 2e       	mov	r14, r17
    a108:	1f e0       	ldi	r17, 0x0F	; 15
    a10a:	f1 2e       	mov	r15, r17
    a10c:	09 ec       	ldi	r16, 0xC9	; 201
    a10e:	1f e3       	ldi	r17, 0x3F	; 63
    a110:	20 e0       	ldi	r18, 0x00	; 0
    a112:	30 e0       	ldi	r19, 0x00	; 0
    a114:	a9 01       	movw	r20, r18
    a116:	ca 01       	movw	r24, r20
    a118:	b9 01       	movw	r22, r18
    a11a:	0e 94 17 67 	call	0xce2e	; 0xce2e <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>
	//MatrixUtil::CreateRotationMatrix(M_PI, 0.0f, -1 * (M_PI/2), magLBUToFRDRotationMatrix);
}
    a11e:	1f 91       	pop	r17
    a120:	0f 91       	pop	r16
    a122:	ff 90       	pop	r15
    a124:	ef 90       	pop	r14
    a126:	df 90       	pop	r13
    a128:	cf 90       	pop	r12
    a12a:	08 95       	ret

0000a12c <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>:


float _offsets2[3] = {0};
float previousMag[3] = {.001, .001, .001};
int MagnetometerSensor::readSensor()
{
    a12c:	0f 93       	push	r16
    a12e:	1f 93       	push	r17
    a130:	cf 93       	push	r28
    a132:	df 93       	push	r29
    a134:	cd b7       	in	r28, 0x3d	; 61
    a136:	de b7       	in	r29, 0x3e	; 62
    a138:	64 97       	sbiw	r28, 0x14	; 20
    a13a:	0f b6       	in	r0, 0x3f	; 63
    a13c:	f8 94       	cli
    a13e:	de bf       	out	0x3e, r29	; 62
    a140:	0f be       	out	0x3f, r0	; 63
    a142:	cd bf       	out	0x3d, r28	; 61
    a144:	8c 01       	movw	r16, r24
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    a146:	fc 01       	movw	r30, r24
    a148:	86 a9       	ldd	r24, Z+54	; 0x36
    a14a:	97 a9       	ldd	r25, Z+55	; 0x37
    a14c:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a150:	81 11       	cpse	r24, r1
    a152:	08 c0       	rjmp	.+16     	; 0xa164 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x38>
    a154:	f8 01       	movw	r30, r16
    a156:	86 a9       	ldd	r24, Z+54	; 0x36
    a158:	97 a9       	ldd	r25, Z+55	; 0x37
    a15a:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a15e:	2f ef       	ldi	r18, 0xFF	; 255
    a160:	3f ef       	ldi	r19, 0xFF	; 255
    a162:	61 c1       	rjmp	.+706    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		driver->stop();
		return -1;
	}*/		
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK));
    a164:	48 e1       	ldi	r20, 0x18	; 24
    a166:	6c e3       	ldi	r22, 0x3C	; 60
    a168:	f8 01       	movw	r30, r16
    a16a:	86 a9       	ldd	r24, Z+54	; 0x36
    a16c:	97 a9       	ldd	r25, Z+55	; 0x37
    a16e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a172:	81 11       	cpse	r24, r1
    a174:	08 c0       	rjmp	.+16     	; 0xa186 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x5a>
    a176:	f8 01       	movw	r30, r16
    a178:	86 a9       	ldd	r24, Z+54	; 0x36
    a17a:	97 a9       	ldd	r25, Z+55	; 0x37
    a17c:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a180:	2f ef       	ldi	r18, 0xFF	; 255
    a182:	3f ef       	ldi	r19, 0xFF	; 255
    a184:	50 c1       	rjmp	.+672    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(DATA_OUTPUT_X_MSG_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK));
    a186:	48 e2       	ldi	r20, 0x28	; 40
    a188:	63 e0       	ldi	r22, 0x03	; 3
    a18a:	f8 01       	movw	r30, r16
    a18c:	86 a9       	ldd	r24, Z+54	; 0x36
    a18e:	97 a9       	ldd	r25, Z+55	; 0x37
    a190:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a194:	81 11       	cpse	r24, r1
    a196:	08 c0       	rjmp	.+16     	; 0xa1a8 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x7c>
    a198:	f8 01       	movw	r30, r16
    a19a:	86 a9       	ldd	r24, Z+54	; 0x36
    a19c:	97 a9       	ldd	r25, Z+55	; 0x37
    a19e:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1a2:	2f ef       	ldi	r18, 0xFF	; 255
    a1a4:	3f ef       	ldi	r19, 0xFF	; 255
    a1a6:	3f c1       	rjmp	.+638    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->start())
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->start());
    a1a8:	f8 01       	movw	r30, r16
    a1aa:	86 a9       	ldd	r24, Z+54	; 0x36
    a1ac:	97 a9       	ldd	r25, Z+55	; 0x37
    a1ae:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a1b2:	81 11       	cpse	r24, r1
    a1b4:	08 c0       	rjmp	.+16     	; 0xa1c6 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x9a>
    a1b6:	f8 01       	movw	r30, r16
    a1b8:	86 a9       	ldd	r24, Z+54	; 0x36
    a1ba:	97 a9       	ldd	r25, Z+55	; 0x37
    a1bc:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1c0:	2f ef       	ldi	r18, 0xFF	; 255
    a1c2:	3f ef       	ldi	r19, 0xFF	; 255
    a1c4:	30 c1       	rjmp	.+608    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	/*if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK))
	{
		driver->stop();
		return -1;
	}*/
	CHECK(driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | READ_OPERATION, TWIDriver::MASTERRECEIVER_SLAVE_READ_ACK));
    a1c6:	40 e4       	ldi	r20, 0x40	; 64
    a1c8:	6d e3       	ldi	r22, 0x3D	; 61
    a1ca:	f8 01       	movw	r30, r16
    a1cc:	86 a9       	ldd	r24, Z+54	; 0x36
    a1ce:	97 a9       	ldd	r25, Z+55	; 0x37
    a1d0:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a1d4:	81 11       	cpse	r24, r1
    a1d6:	08 c0       	rjmp	.+16     	; 0xa1e8 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xbc>
    a1d8:	f8 01       	movw	r30, r16
    a1da:	86 a9       	ldd	r24, Z+54	; 0x36
    a1dc:	97 a9       	ldd	r25, Z+55	; 0x37
    a1de:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a1e2:	2f ef       	ldi	r18, 0xFF	; 255
    a1e4:	3f ef       	ldi	r19, 0xFF	; 255
    a1e6:	1f c1       	rjmp	.+574    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	
	
		
	byte highByte = 0;
    a1e8:	1c 8a       	std	Y+20, r1	; 0x14
	byte lowByte = 0;
    a1ea:	1b 8a       	std	Y+19, r1	; 0x13
		
	CHECK(driver->readByte(true, highByte));
    a1ec:	ae 01       	movw	r20, r28
    a1ee:	4c 5e       	subi	r20, 0xEC	; 236
    a1f0:	5f 4f       	sbci	r21, 0xFF	; 255
    a1f2:	61 e0       	ldi	r22, 0x01	; 1
    a1f4:	f8 01       	movw	r30, r16
    a1f6:	86 a9       	ldd	r24, Z+54	; 0x36
    a1f8:	97 a9       	ldd	r25, Z+55	; 0x37
    a1fa:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a1fe:	81 11       	cpse	r24, r1
    a200:	08 c0       	rjmp	.+16     	; 0xa212 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0xe6>
    a202:	f8 01       	movw	r30, r16
    a204:	86 a9       	ldd	r24, Z+54	; 0x36
    a206:	97 a9       	ldd	r25, Z+55	; 0x37
    a208:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a20c:	2f ef       	ldi	r18, 0xFF	; 255
    a20e:	3f ef       	ldi	r19, 0xFF	; 255
    a210:	0a c1       	rjmp	.+532    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	CHECK(driver->readByte(true, lowByte));
    a212:	ae 01       	movw	r20, r28
    a214:	4d 5e       	subi	r20, 0xED	; 237
    a216:	5f 4f       	sbci	r21, 0xFF	; 255
    a218:	61 e0       	ldi	r22, 0x01	; 1
    a21a:	f8 01       	movw	r30, r16
    a21c:	86 a9       	ldd	r24, Z+54	; 0x36
    a21e:	97 a9       	ldd	r25, Z+55	; 0x37
    a220:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a224:	81 11       	cpse	r24, r1
    a226:	08 c0       	rjmp	.+16     	; 0xa238 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x10c>
    a228:	f8 01       	movw	r30, r16
    a22a:	86 a9       	ldd	r24, Z+54	; 0x36
    a22c:	97 a9       	ldd	r25, Z+55	; 0x37
    a22e:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a232:	2f ef       	ldi	r18, 0xFF	; 255
    a234:	3f ef       	ldi	r19, 0xFF	; 255
    a236:	f7 c0       	rjmp	.+494    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagX = (highByte << 8) | (lowByte);
    a238:	9c 89       	ldd	r25, Y+20	; 0x14
    a23a:	80 e0       	ldi	r24, 0x00	; 0
    a23c:	2b 89       	ldd	r18, Y+19	; 0x13
    a23e:	82 2b       	or	r24, r18
    a240:	f8 01       	movw	r30, r16
    a242:	91 83       	std	Z+1, r25	; 0x01
    a244:	80 83       	st	Z, r24
		
	CHECK(driver->readByte(true, highByte));
    a246:	ae 01       	movw	r20, r28
    a248:	4c 5e       	subi	r20, 0xEC	; 236
    a24a:	5f 4f       	sbci	r21, 0xFF	; 255
    a24c:	61 e0       	ldi	r22, 0x01	; 1
    a24e:	86 a9       	ldd	r24, Z+54	; 0x36
    a250:	97 a9       	ldd	r25, Z+55	; 0x37
    a252:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a256:	81 11       	cpse	r24, r1
    a258:	08 c0       	rjmp	.+16     	; 0xa26a <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x13e>
    a25a:	f8 01       	movw	r30, r16
    a25c:	86 a9       	ldd	r24, Z+54	; 0x36
    a25e:	97 a9       	ldd	r25, Z+55	; 0x37
    a260:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a264:	2f ef       	ldi	r18, 0xFF	; 255
    a266:	3f ef       	ldi	r19, 0xFF	; 255
    a268:	de c0       	rjmp	.+444    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	CHECK(driver->readByte(true, lowByte));
    a26a:	ae 01       	movw	r20, r28
    a26c:	4d 5e       	subi	r20, 0xED	; 237
    a26e:	5f 4f       	sbci	r21, 0xFF	; 255
    a270:	61 e0       	ldi	r22, 0x01	; 1
    a272:	f8 01       	movw	r30, r16
    a274:	86 a9       	ldd	r24, Z+54	; 0x36
    a276:	97 a9       	ldd	r25, Z+55	; 0x37
    a278:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a27c:	81 11       	cpse	r24, r1
    a27e:	08 c0       	rjmp	.+16     	; 0xa290 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x164>
    a280:	f8 01       	movw	r30, r16
    a282:	86 a9       	ldd	r24, Z+54	; 0x36
    a284:	97 a9       	ldd	r25, Z+55	; 0x37
    a286:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a28a:	2f ef       	ldi	r18, 0xFF	; 255
    a28c:	3f ef       	ldi	r19, 0xFF	; 255
    a28e:	cb c0       	rjmp	.+406    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagZ = (highByte << 8) | (lowByte);
    a290:	9c 89       	ldd	r25, Y+20	; 0x14
    a292:	80 e0       	ldi	r24, 0x00	; 0
    a294:	2b 89       	ldd	r18, Y+19	; 0x13
    a296:	82 2b       	or	r24, r18
    a298:	f8 01       	movw	r30, r16
    a29a:	95 83       	std	Z+5, r25	; 0x05
    a29c:	84 83       	std	Z+4, r24	; 0x04
		
	CHECK(driver->readByte(true, highByte));
    a29e:	ae 01       	movw	r20, r28
    a2a0:	4c 5e       	subi	r20, 0xEC	; 236
    a2a2:	5f 4f       	sbci	r21, 0xFF	; 255
    a2a4:	61 e0       	ldi	r22, 0x01	; 1
    a2a6:	86 a9       	ldd	r24, Z+54	; 0x36
    a2a8:	97 a9       	ldd	r25, Z+55	; 0x37
    a2aa:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a2ae:	81 11       	cpse	r24, r1
    a2b0:	08 c0       	rjmp	.+16     	; 0xa2c2 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x196>
    a2b2:	f8 01       	movw	r30, r16
    a2b4:	86 a9       	ldd	r24, Z+54	; 0x36
    a2b6:	97 a9       	ldd	r25, Z+55	; 0x37
    a2b8:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a2bc:	2f ef       	ldi	r18, 0xFF	; 255
    a2be:	3f ef       	ldi	r19, 0xFF	; 255
    a2c0:	b2 c0       	rjmp	.+356    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
		
	//We don't send an acknowledgment on the last byte to be read (the magnetic Y values low byte) because of an apparent undocumented requirement by the device
	//that the nack needs to be sent to have the internal pointer go back to the magnetic X variable.
	//According to wikipedia, when in masterreceive mode, the master sends an ack bit after every byte read except for the last one. 
	CHECK(driver->readByte(false, lowByte));
    a2c2:	ae 01       	movw	r20, r28
    a2c4:	4d 5e       	subi	r20, 0xED	; 237
    a2c6:	5f 4f       	sbci	r21, 0xFF	; 255
    a2c8:	60 e0       	ldi	r22, 0x00	; 0
    a2ca:	f8 01       	movw	r30, r16
    a2cc:	86 a9       	ldd	r24, Z+54	; 0x36
    a2ce:	97 a9       	ldd	r25, Z+55	; 0x37
    a2d0:	0e 94 47 10 	call	0x208e	; 0x208e <_ZN10helicopter7drivers9TWIDriver8readByteEbRh>
    a2d4:	81 11       	cpse	r24, r1
    a2d6:	08 c0       	rjmp	.+16     	; 0xa2e8 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1bc>
    a2d8:	f8 01       	movw	r30, r16
    a2da:	86 a9       	ldd	r24, Z+54	; 0x36
    a2dc:	97 a9       	ldd	r25, Z+55	; 0x37
    a2de:	0e 94 17 10 	call	0x202e	; 0x202e <_ZN10helicopter7drivers9TWIDriver5resetEv>
    a2e2:	2f ef       	ldi	r18, 0xFF	; 255
    a2e4:	3f ef       	ldi	r19, 0xFF	; 255
    a2e6:	9f c0       	rjmp	.+318    	; 0xa426 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x2fa>
	rawMagY = (highByte << 8) | (lowByte);		
    a2e8:	9c 89       	ldd	r25, Y+20	; 0x14
    a2ea:	80 e0       	ldi	r24, 0x00	; 0
    a2ec:	2b 89       	ldd	r18, Y+19	; 0x13
    a2ee:	82 2b       	or	r24, r18
    a2f0:	f8 01       	movw	r30, r16
    a2f2:	93 83       	std	Z+3, r25	; 0x03
    a2f4:	82 83       	std	Z+2, r24	; 0x02
	
	//transmit stop condition
	driver->stop();
    a2f6:	86 a9       	ldd	r24, Z+54	; 0x36
    a2f8:	97 a9       	ldd	r25, Z+55	; 0x37
    a2fa:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
		
	/**
	 * correct for magnetic interference. Code from ardupilot file found here:
	 * https://github.com/diydrones/ardupilot/blob/6af705d4554defc27aa475dab99f918b26de3ce1/libraries/AP_Compass/Compass_learn.cpp
	 */
	if (readyForOffsets)
    a2fe:	80 91 25 04 	lds	r24, 0x0425
    a302:	88 23       	and	r24, r24
    a304:	09 f4       	brne	.+2      	; 0xa308 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x1dc>
    a306:	46 c0       	rjmp	.+140    	; 0xa394 <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x268>
	{
		rawMagX *= calibration[0];
    a308:	f8 01       	movw	r30, r16
    a30a:	60 81       	ld	r22, Z
    a30c:	71 81       	ldd	r23, Z+1	; 0x01
    a30e:	88 27       	eor	r24, r24
    a310:	77 fd       	sbrc	r23, 7
    a312:	80 95       	com	r24
    a314:	98 2f       	mov	r25, r24
    a316:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a31a:	20 91 26 04 	lds	r18, 0x0426
    a31e:	30 91 27 04 	lds	r19, 0x0427
    a322:	40 91 28 04 	lds	r20, 0x0428
    a326:	50 91 29 04 	lds	r21, 0x0429
    a32a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    a32e:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    a332:	f8 01       	movw	r30, r16
    a334:	71 83       	std	Z+1, r23	; 0x01
    a336:	60 83       	st	Z, r22
		rawMagY *= calibration[1];
    a338:	62 81       	ldd	r22, Z+2	; 0x02
    a33a:	73 81       	ldd	r23, Z+3	; 0x03
    a33c:	88 27       	eor	r24, r24
    a33e:	77 fd       	sbrc	r23, 7
    a340:	80 95       	com	r24
    a342:	98 2f       	mov	r25, r24
    a344:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a348:	20 91 2a 04 	lds	r18, 0x042A
    a34c:	30 91 2b 04 	lds	r19, 0x042B
    a350:	40 91 2c 04 	lds	r20, 0x042C
    a354:	50 91 2d 04 	lds	r21, 0x042D
    a358:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    a35c:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    a360:	f8 01       	movw	r30, r16
    a362:	73 83       	std	Z+3, r23	; 0x03
    a364:	62 83       	std	Z+2, r22	; 0x02
		rawMagZ *= calibration[2];
    a366:	64 81       	ldd	r22, Z+4	; 0x04
    a368:	75 81       	ldd	r23, Z+5	; 0x05
    a36a:	88 27       	eor	r24, r24
    a36c:	77 fd       	sbrc	r23, 7
    a36e:	80 95       	com	r24
    a370:	98 2f       	mov	r25, r24
    a372:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a376:	20 91 2e 04 	lds	r18, 0x042E
    a37a:	30 91 2f 04 	lds	r19, 0x042F
    a37e:	40 91 30 04 	lds	r20, 0x0430
    a382:	50 91 31 04 	lds	r21, 0x0431
    a386:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    a38a:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    a38e:	f8 01       	movw	r30, r16
    a390:	75 83       	std	Z+5, r23	; 0x05
    a392:	64 83       	std	Z+4, r22	; 0x04
		
		
		
	
	//Convert the raw values to FRD values.
	float rotatedValues[3] = {0};
    a394:	ae 01       	movw	r20, r28
    a396:	4f 5f       	subi	r20, 0xFF	; 255
    a398:	5f 4f       	sbci	r21, 0xFF	; 255
    a39a:	8c e0       	ldi	r24, 0x0C	; 12
    a39c:	fa 01       	movw	r30, r20
    a39e:	11 92       	st	Z+, r1
    a3a0:	8a 95       	dec	r24
    a3a2:	e9 f7       	brne	.-6      	; 0xa39e <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv+0x272>
	int values[3] = {rawMagX, rawMagY, rawMagZ};
    a3a4:	f8 01       	movw	r30, r16
    a3a6:	80 81       	ld	r24, Z
    a3a8:	91 81       	ldd	r25, Z+1	; 0x01
    a3aa:	9e 87       	std	Y+14, r25	; 0x0e
    a3ac:	8d 87       	std	Y+13, r24	; 0x0d
    a3ae:	82 81       	ldd	r24, Z+2	; 0x02
    a3b0:	93 81       	ldd	r25, Z+3	; 0x03
    a3b2:	98 8b       	std	Y+16, r25	; 0x10
    a3b4:	8f 87       	std	Y+15, r24	; 0x0f
    a3b6:	84 81       	ldd	r24, Z+4	; 0x04
    a3b8:	95 81       	ldd	r25, Z+5	; 0x05
    a3ba:	9a 8b       	std	Y+18, r25	; 0x12
    a3bc:	89 8b       	std	Y+17, r24	; 0x11
	
	MatrixUtil::RotateMatrix(magLBUToFRDRotationMatrix, values, rotatedValues);
    a3be:	be 01       	movw	r22, r28
    a3c0:	63 5f       	subi	r22, 0xF3	; 243
    a3c2:	7f 4f       	sbci	r23, 0xFF	; 255
    a3c4:	c8 01       	movw	r24, r16
    a3c6:	42 96       	adiw	r24, 0x12	; 18
    a3c8:	0e 94 bb 68 	call	0xd176	; 0xd176 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>

	//Manually rotate in order to reduce processing
	
	/*frdMagX = rawMagY;
	frdMagY = -rawMagX;*/
	frdMagX = -rawMagY;
    a3cc:	f8 01       	movw	r30, r16
    a3ce:	62 81       	ldd	r22, Z+2	; 0x02
    a3d0:	73 81       	ldd	r23, Z+3	; 0x03
    a3d2:	71 95       	neg	r23
    a3d4:	61 95       	neg	r22
    a3d6:	71 09       	sbc	r23, r1
    a3d8:	88 27       	eor	r24, r24
    a3da:	77 fd       	sbrc	r23, 7
    a3dc:	80 95       	com	r24
    a3de:	98 2f       	mov	r25, r24
    a3e0:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a3e4:	f8 01       	movw	r30, r16
    a3e6:	66 83       	std	Z+6, r22	; 0x06
    a3e8:	77 83       	std	Z+7, r23	; 0x07
    a3ea:	80 87       	std	Z+8, r24	; 0x08
    a3ec:	91 87       	std	Z+9, r25	; 0x09
	frdMagY = rawMagX;
    a3ee:	60 81       	ld	r22, Z
    a3f0:	71 81       	ldd	r23, Z+1	; 0x01
    a3f2:	88 27       	eor	r24, r24
    a3f4:	77 fd       	sbrc	r23, 7
    a3f6:	80 95       	com	r24
    a3f8:	98 2f       	mov	r25, r24
    a3fa:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a3fe:	f8 01       	movw	r30, r16
    a400:	62 87       	std	Z+10, r22	; 0x0a
    a402:	73 87       	std	Z+11, r23	; 0x0b
    a404:	84 87       	std	Z+12, r24	; 0x0c
    a406:	95 87       	std	Z+13, r25	; 0x0d
	frdMagZ = rawMagZ;
    a408:	64 81       	ldd	r22, Z+4	; 0x04
    a40a:	75 81       	ldd	r23, Z+5	; 0x05
    a40c:	88 27       	eor	r24, r24
    a40e:	77 fd       	sbrc	r23, 7
    a410:	80 95       	com	r24
    a412:	98 2f       	mov	r25, r24
    a414:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a418:	f8 01       	movw	r30, r16
    a41a:	66 87       	std	Z+14, r22	; 0x0e
    a41c:	77 87       	std	Z+15, r23	; 0x0f
    a41e:	80 8b       	std	Z+16, r24	; 0x10
    a420:	91 8b       	std	Z+17, r25	; 0x11
		
		
		
		
		
	return 0;
    a422:	20 e0       	ldi	r18, 0x00	; 0
    a424:	30 e0       	ldi	r19, 0x00	; 0
    a426:	82 2f       	mov	r24, r18
    a428:	93 2f       	mov	r25, r19
    a42a:	64 96       	adiw	r28, 0x14	; 20
    a42c:	0f b6       	in	r0, 0x3f	; 63
    a42e:	f8 94       	cli
    a430:	de bf       	out	0x3e, r29	; 62
    a432:	0f be       	out	0x3f, r0	; 63
    a434:	cd bf       	out	0x3d, r28	; 61
    a436:	df 91       	pop	r29
    a438:	cf 91       	pop	r28
    a43a:	1f 91       	pop	r17
    a43c:	0f 91       	pop	r16
    a43e:	08 95       	ret

0000a440 <_ZN10helicopter7sensors18MagnetometerSensor4initEv>:

float calibration[3] = {};
bool readyForOffsets = false;

bool MagnetometerSensor::init()
{
    a440:	2f 92       	push	r2
    a442:	3f 92       	push	r3
    a444:	4f 92       	push	r4
    a446:	5f 92       	push	r5
    a448:	6f 92       	push	r6
    a44a:	7f 92       	push	r7
    a44c:	8f 92       	push	r8
    a44e:	9f 92       	push	r9
    a450:	af 92       	push	r10
    a452:	bf 92       	push	r11
    a454:	cf 92       	push	r12
    a456:	df 92       	push	r13
    a458:	ef 92       	push	r14
    a45a:	ff 92       	push	r15
    a45c:	0f 93       	push	r16
    a45e:	1f 93       	push	r17
    a460:	cf 93       	push	r28
    a462:	df 93       	push	r29
    a464:	ec 01       	movw	r28, r24
	* Configure the output rate of the sensor, and number of samples that are averaged
	* per measurement output
	*/
	
	//Start a two wire transaction
	if(!driver->start())
    a466:	8e a9       	ldd	r24, Y+54	; 0x36
    a468:	9f a9       	ldd	r25, Y+55	; 0x37
    a46a:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a46e:	88 23       	and	r24, r24
    a470:	09 f4       	brne	.+2      	; 0xa474 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x34>
    a472:	6f c2       	rjmp	.+1246   	; 0xa952 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x512>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation 
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a474:	48 e1       	ldi	r20, 0x18	; 24
    a476:	6c e3       	ldi	r22, 0x3C	; 60
    a478:	8e a9       	ldd	r24, Y+54	; 0x36
    a47a:	9f a9       	ldd	r25, Y+55	; 0x37
    a47c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a480:	88 23       	and	r24, r24
    a482:	09 f4       	brne	.+2      	; 0xa486 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x46>
    a484:	68 c2       	rjmp	.+1232   	; 0xa956 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x516>
	{
		return false;
	}
		
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a486:	48 e2       	ldi	r20, 0x28	; 40
    a488:	60 e0       	ldi	r22, 0x00	; 0
    a48a:	8e a9       	ldd	r24, Y+54	; 0x36
    a48c:	9f a9       	ldd	r25, Y+55	; 0x37
    a48e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a492:	88 23       	and	r24, r24
    a494:	09 f4       	brne	.+2      	; 0xa498 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58>
    a496:	61 c2       	rjmp	.+1218   	; 0xa95a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x51a>
	{
		return false;
	}
		
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a498:	48 e2       	ldi	r20, 0x28	; 40
    a49a:	68 e7       	ldi	r22, 0x78	; 120
    a49c:	8e a9       	ldd	r24, Y+54	; 0x36
    a49e:	9f a9       	ldd	r25, Y+55	; 0x37
    a4a0:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4a4:	88 23       	and	r24, r24
    a4a6:	09 f4       	brne	.+2      	; 0xa4aa <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x6a>
    a4a8:	5a c2       	rjmp	.+1204   	; 0xa95e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x51e>
	{
		return false;
	}	

	//end the transaction
	driver->stop();
    a4aa:	8e a9       	ldd	r24, Y+54	; 0x36
    a4ac:	9f a9       	ldd	r25, Y+55	; 0x37
    a4ae:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    a4b2:	8e a9       	ldd	r24, Y+54	; 0x36
    a4b4:	9f a9       	ldd	r25, Y+55	; 0x37
    a4b6:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a4ba:	88 23       	and	r24, r24
    a4bc:	09 f4       	brne	.+2      	; 0xa4c0 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x80>
    a4be:	51 c2       	rjmp	.+1186   	; 0xa962 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x522>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a4c0:	48 e1       	ldi	r20, 0x18	; 24
    a4c2:	6c e3       	ldi	r22, 0x3C	; 60
    a4c4:	8e a9       	ldd	r24, Y+54	; 0x36
    a4c6:	9f a9       	ldd	r25, Y+55	; 0x37
    a4c8:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4cc:	88 23       	and	r24, r24
    a4ce:	09 f4       	brne	.+2      	; 0xa4d2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x92>
    a4d0:	4a c2       	rjmp	.+1172   	; 0xa966 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x526>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a4d2:	48 e2       	ldi	r20, 0x28	; 40
    a4d4:	61 e0       	ldi	r22, 0x01	; 1
    a4d6:	8e a9       	ldd	r24, Y+54	; 0x36
    a4d8:	9f a9       	ldd	r25, Y+55	; 0x37
    a4da:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4de:	88 23       	and	r24, r24
    a4e0:	09 f4       	brne	.+2      	; 0xa4e4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xa4>
    a4e2:	43 c2       	rjmp	.+1158   	; 0xa96a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x52a>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(REGISTER_B_CONFIGURATION_660_GAIN, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a4e4:	48 e2       	ldi	r20, 0x28	; 40
    a4e6:	60 e6       	ldi	r22, 0x60	; 96
    a4e8:	8e a9       	ldd	r24, Y+54	; 0x36
    a4ea:	9f a9       	ldd	r25, Y+55	; 0x37
    a4ec:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a4f0:	88 23       	and	r24, r24
    a4f2:	09 f4       	brne	.+2      	; 0xa4f6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xb6>
    a4f4:	3c c2       	rjmp	.+1144   	; 0xa96e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x52e>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    a4f6:	8e a9       	ldd	r24, Y+54	; 0x36
    a4f8:	9f a9       	ldd	r25, Y+55	; 0x37
    a4fa:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	    int numAttempts = 0, good_count = 0;
	    bool success = false;
		byte PositiveBiasConfig = 0x11;
		byte calibration_gain = 0x60;
	
	calibration[0] = 0;
    a4fe:	10 92 26 04 	sts	0x0426, r1
    a502:	10 92 27 04 	sts	0x0427, r1
    a506:	10 92 28 04 	sts	0x0428, r1
    a50a:	10 92 29 04 	sts	0x0429, r1
	calibration[1] = 0;
    a50e:	10 92 2a 04 	sts	0x042A, r1
    a512:	10 92 2b 04 	sts	0x042B, r1
    a516:	10 92 2c 04 	sts	0x042C, r1
    a51a:	10 92 2d 04 	sts	0x042D, r1
	calibration[2] = 0;
    a51e:	10 92 2e 04 	sts	0x042E, r1
    a522:	10 92 2f 04 	sts	0x042F, r1
    a526:	10 92 30 04 	sts	0x0430, r1
    a52a:	10 92 31 04 	sts	0x0431, r1
	//
	float expected_x = -713;//766;
	float expected_y = 766;//713;
	float expected_z = 713;
	
	    int numAttempts = 0, good_count = 0;
    a52e:	21 2c       	mov	r2, r1
    a530:	31 2c       	mov	r3, r1
    a532:	00 e0       	ldi	r16, 0x00	; 0
    a534:	10 e0       	ldi	r17, 0x00	; 0
	
	calibration[0] = 0;
	calibration[1] = 0;
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    a536:	37 c1       	rjmp	.+622    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a538:	48 e1       	ldi	r20, 0x18	; 24
    a53a:	6c e3       	ldi	r22, 0x3C	; 60
    a53c:	8e a9       	ldd	r24, Y+54	; 0x36
    a53e:	9f a9       	ldd	r25, Y+55	; 0x37
    a540:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a544:	88 23       	and	r24, r24
    a546:	09 f4       	brne	.+2      	; 0xa54a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x10a>
    a548:	14 c2       	rjmp	.+1064   	; 0xa972 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x532>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a54a:	48 e2       	ldi	r20, 0x28	; 40
    a54c:	60 e0       	ldi	r22, 0x00	; 0
    a54e:	8e a9       	ldd	r24, Y+54	; 0x36
    a550:	9f a9       	ldd	r25, Y+55	; 0x37
    a552:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a556:	88 23       	and	r24, r24
    a558:	09 f4       	brne	.+2      	; 0xa55c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x11c>
    a55a:	0d c2       	rjmp	.+1050   	; 0xa976 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x536>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(PositiveBiasConfig, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a55c:	48 e2       	ldi	r20, 0x28	; 40
    a55e:	61 e1       	ldi	r22, 0x11	; 17
    a560:	8e a9       	ldd	r24, Y+54	; 0x36
    a562:	9f a9       	ldd	r25, Y+55	; 0x37
    a564:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a568:	88 23       	and	r24, r24
    a56a:	09 f4       	brne	.+2      	; 0xa56e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x12e>
    a56c:	06 c2       	rjmp	.+1036   	; 0xa97a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x53a>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    a56e:	8e a9       	ldd	r24, Y+54	; 0x36
    a570:	9f a9       	ldd	r25, Y+55	; 0x37
    a572:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a576:	2f ef       	ldi	r18, 0xFF	; 255
    a578:	80 e7       	ldi	r24, 0x70	; 112
    a57a:	92 e0       	ldi	r25, 0x02	; 2
    a57c:	21 50       	subi	r18, 0x01	; 1
    a57e:	80 40       	sbci	r24, 0x00	; 0
    a580:	90 40       	sbci	r25, 0x00	; 0
    a582:	e1 f7       	brne	.-8      	; 0xa57c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x13c>
    a584:	00 c0       	rjmp	.+0      	; 0xa586 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x146>
    a586:	00 00       	nop

        
        _delay_ms(50);

        // set gains
	if(!driver->start())
    a588:	8e a9       	ldd	r24, Y+54	; 0x36
    a58a:	9f a9       	ldd	r25, Y+55	; 0x37
    a58c:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a590:	88 23       	and	r24, r24
    a592:	09 f4       	brne	.+2      	; 0xa596 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x156>
    a594:	f4 c1       	rjmp	.+1000   	; 0xa97e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x53e>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a596:	48 e1       	ldi	r20, 0x18	; 24
    a598:	6c e3       	ldi	r22, 0x3C	; 60
    a59a:	8e a9       	ldd	r24, Y+54	; 0x36
    a59c:	9f a9       	ldd	r25, Y+55	; 0x37
    a59e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5a2:	88 23       	and	r24, r24
    a5a4:	09 f4       	brne	.+2      	; 0xa5a8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x168>
    a5a6:	ed c1       	rjmp	.+986    	; 0xa982 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x542>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a5a8:	48 e2       	ldi	r20, 0x28	; 40
    a5aa:	61 e0       	ldi	r22, 0x01	; 1
    a5ac:	8e a9       	ldd	r24, Y+54	; 0x36
    a5ae:	9f a9       	ldd	r25, Y+55	; 0x37
    a5b0:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5b4:	88 23       	and	r24, r24
    a5b6:	09 f4       	brne	.+2      	; 0xa5ba <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x17a>
    a5b8:	e6 c1       	rjmp	.+972    	; 0xa986 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x546>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(calibration_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a5ba:	48 e2       	ldi	r20, 0x28	; 40
    a5bc:	60 e6       	ldi	r22, 0x60	; 96
    a5be:	8e a9       	ldd	r24, Y+54	; 0x36
    a5c0:	9f a9       	ldd	r25, Y+55	; 0x37
    a5c2:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a5c6:	88 23       	and	r24, r24
    a5c8:	09 f4       	brne	.+2      	; 0xa5cc <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x18c>
    a5ca:	df c1       	rjmp	.+958    	; 0xa98a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x54a>
	{
		return false;
	}

	//end the transaction
	driver->stop();		
    a5cc:	8e a9       	ldd	r24, Y+54	; 0x36
    a5ce:	9f a9       	ldd	r25, Y+55	; 0x37
    a5d0:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a5d4:	ef ef       	ldi	r30, 0xFF	; 255
    a5d6:	f0 e7       	ldi	r31, 0x70	; 112
    a5d8:	22 e0       	ldi	r18, 0x02	; 2
    a5da:	e1 50       	subi	r30, 0x01	; 1
    a5dc:	f0 40       	sbci	r31, 0x00	; 0
    a5de:	20 40       	sbci	r18, 0x00	; 0
    a5e0:	e1 f7       	brne	.-8      	; 0xa5da <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x19a>
    a5e2:	00 c0       	rjmp	.+0      	; 0xa5e4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1a4>
    a5e4:	00 00       	nop
	
	
	        _delay_ms(50);

	        // set gains
	        if(!driver->start())
    a5e6:	8e a9       	ldd	r24, Y+54	; 0x36
    a5e8:	9f a9       	ldd	r25, Y+55	; 0x37
    a5ea:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a5ee:	88 23       	and	r24, r24
    a5f0:	09 f4       	brne	.+2      	; 0xa5f4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1b4>
    a5f2:	cd c1       	rjmp	.+922    	; 0xa98e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x54e>
	        {
		        return false;
	        }
	        
	        //Indicate that the next value is a write operation
	        if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a5f4:	48 e1       	ldi	r20, 0x18	; 24
    a5f6:	6c e3       	ldi	r22, 0x3C	; 60
    a5f8:	8e a9       	ldd	r24, Y+54	; 0x36
    a5fa:	9f a9       	ldd	r25, Y+55	; 0x37
    a5fc:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a600:	88 23       	and	r24, r24
    a602:	09 f4       	brne	.+2      	; 0xa606 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1c6>
    a604:	c6 c1       	rjmp	.+908    	; 0xa992 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x552>
		        return false;
	        }
	        
			
	        //Write to the device so that the 'pointer' moves to register B
	        if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a606:	48 e2       	ldi	r20, 0x28	; 40
    a608:	62 e0       	ldi	r22, 0x02	; 2
    a60a:	8e a9       	ldd	r24, Y+54	; 0x36
    a60c:	9f a9       	ldd	r25, Y+55	; 0x37
    a60e:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a612:	88 23       	and	r24, r24
    a614:	09 f4       	brne	.+2      	; 0xa618 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1d8>
    a616:	bf c1       	rjmp	.+894    	; 0xa996 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x556>
	        {
		        return false;
	        }
	        byte singleConversion = 0x01;
	        //Write the configuration value to register B
	        if (!driver->write(singleConversion, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a618:	48 e2       	ldi	r20, 0x28	; 40
    a61a:	61 e0       	ldi	r22, 0x01	; 1
    a61c:	8e a9       	ldd	r24, Y+54	; 0x36
    a61e:	9f a9       	ldd	r25, Y+55	; 0x37
    a620:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a624:	88 23       	and	r24, r24
    a626:	09 f4       	brne	.+2      	; 0xa62a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1ea>
    a628:	b8 c1       	rjmp	.+880    	; 0xa99a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x55a>
	        {
		        return false;
	        }

	        //end the transaction
	        driver->stop();
    a62a:	8e a9       	ldd	r24, Y+54	; 0x36
    a62c:	9f a9       	ldd	r25, Y+55	; 0x37
    a62e:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
    a632:	8f ef       	ldi	r24, 0xFF	; 255
    a634:	90 e7       	ldi	r25, 0x70	; 112
    a636:	e2 e0       	ldi	r30, 0x02	; 2
    a638:	81 50       	subi	r24, 0x01	; 1
    a63a:	90 40       	sbci	r25, 0x00	; 0
    a63c:	e0 40       	sbci	r30, 0x00	; 0
    a63e:	e1 f7       	brne	.-8      	; 0xa638 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x1f8>
    a640:	00 c0       	rjmp	.+0      	; 0xa642 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x202>
    a642:	00 00       	nop
	
		
		_delay_ms(50);
		
        // read values from the compass
       readSensor();
    a644:	ce 01       	movw	r24, r28
    a646:	0e 94 96 50 	call	0xa12c	; 0xa12c <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    a64a:	ff ef       	ldi	r31, 0xFF	; 255
    a64c:	20 e7       	ldi	r18, 0x70	; 112
    a64e:	82 e0       	ldi	r24, 0x02	; 2
    a650:	f1 50       	subi	r31, 0x01	; 1
    a652:	20 40       	sbci	r18, 0x00	; 0
    a654:	80 40       	sbci	r24, 0x00	; 0
    a656:	e1 f7       	brne	.-8      	; 0xa650 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x210>
    a658:	00 c0       	rjmp	.+0      	; 0xa65a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x21a>
    a65a:	00 00       	nop
		_delay_ms(50);

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
    a65c:	2e 81       	ldd	r18, Y+6	; 0x06
    a65e:	3f 81       	ldd	r19, Y+7	; 0x07
    a660:	48 85       	ldd	r20, Y+8	; 0x08
    a662:	59 85       	ldd	r21, Y+9	; 0x09
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a664:	8a 84       	ldd	r8, Y+10	; 0x0a
    a666:	9b 84       	ldd	r9, Y+11	; 0x0b
    a668:	ac 84       	ldd	r10, Y+12	; 0x0c
    a66a:	bd 84       	ldd	r11, Y+13	; 0x0d
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a66c:	ce 84       	ldd	r12, Y+14	; 0x0e
    a66e:	df 84       	ldd	r13, Y+15	; 0x0f
    a670:	e8 88       	ldd	r14, Y+16	; 0x10
    a672:	f9 88       	ldd	r15, Y+17	; 0x11

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a674:	03 30       	cpi	r16, 0x03	; 3
    a676:	11 05       	cpc	r17, r1
    a678:	0c f4       	brge	.+2      	; 0xa67c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x23c>
    a67a:	95 c0       	rjmp	.+298    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
		_delay_ms(50);

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
    a67c:	60 e0       	ldi	r22, 0x00	; 0
    a67e:	70 e4       	ldi	r23, 0x40	; 64
    a680:	82 e3       	ldi	r24, 0x32	; 50
    a682:	94 ec       	ldi	r25, 0xC4	; 196
    a684:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a688:	2b 01       	movw	r4, r22
    a68a:	3c 01       	movw	r6, r24
    a68c:	e8 94       	clt
    a68e:	77 f8       	bld	r7, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a690:	23 e3       	ldi	r18, 0x33	; 51
    a692:	33 e3       	ldi	r19, 0x33	; 51
    a694:	43 e3       	ldi	r20, 0x33	; 51
    a696:	5f e3       	ldi	r21, 0x3F	; 63
    a698:	c3 01       	movw	r24, r6
    a69a:	b2 01       	movw	r22, r4
    a69c:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    a6a0:	18 16       	cp	r1, r24
    a6a2:	0c f0       	brlt	.+2      	; 0xa6a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x266>
    a6a4:	80 c0       	rjmp	.+256    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a6a6:	2d ec       	ldi	r18, 0xCD	; 205
    a6a8:	3c ec       	ldi	r19, 0xCC	; 204
    a6aa:	4c ea       	ldi	r20, 0xAC	; 172
    a6ac:	5f e3       	ldi	r21, 0x3F	; 63
    a6ae:	c3 01       	movw	r24, r6
    a6b0:	b2 01       	movw	r22, r4
    a6b2:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    a6b6:	88 23       	and	r24, r24
    a6b8:	0c f0       	brlt	.+2      	; 0xa6bc <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x27c>
    a6ba:	75 c0       	rjmp	.+234    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>

        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
    a6bc:	a5 01       	movw	r20, r10
    a6be:	94 01       	movw	r18, r8
    a6c0:	60 e0       	ldi	r22, 0x00	; 0
    a6c2:	70 e8       	ldi	r23, 0x80	; 128
    a6c4:	8f e3       	ldi	r24, 0x3F	; 63
    a6c6:	94 e4       	ldi	r25, 0x44	; 68
    a6c8:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a6cc:	4b 01       	movw	r8, r22
    a6ce:	5c 01       	movw	r10, r24
    a6d0:	e8 94       	clt
    a6d2:	b7 f8       	bld	r11, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a6d4:	23 e3       	ldi	r18, 0x33	; 51
    a6d6:	33 e3       	ldi	r19, 0x33	; 51
    a6d8:	43 e3       	ldi	r20, 0x33	; 51
    a6da:	5f e3       	ldi	r21, 0x3F	; 63
    a6dc:	c5 01       	movw	r24, r10
    a6de:	b4 01       	movw	r22, r8
    a6e0:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    a6e4:	18 16       	cp	r1, r24
    a6e6:	0c f0       	brlt	.+2      	; 0xa6ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2aa>
    a6e8:	5e c0       	rjmp	.+188    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a6ea:	2d ec       	ldi	r18, 0xCD	; 205
    a6ec:	3c ec       	ldi	r19, 0xCC	; 204
    a6ee:	4c ea       	ldi	r20, 0xAC	; 172
    a6f0:	5f e3       	ldi	r21, 0x3F	; 63
    a6f2:	c5 01       	movw	r24, r10
    a6f4:	b4 01       	movw	r22, r8
    a6f6:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    a6fa:	88 23       	and	r24, r24
    a6fc:	0c f0       	brlt	.+2      	; 0xa700 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x2c0>
    a6fe:	53 c0       	rjmp	.+166    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
        float cal[3];

        // hal.console->printf_P(PSTR("mag %d %d %d\n"), _mag_x, _mag_y, _mag_z);
        cal[0] = fabsf(expected_x / (float)frdMagX);
        cal[1] = fabsf(expected_y / (float)frdMagY);
        cal[2] = fabsf(expected_z / (float)frdMagZ);
    a700:	a7 01       	movw	r20, r14
    a702:	96 01       	movw	r18, r12
    a704:	60 e0       	ldi	r22, 0x00	; 0
    a706:	70 e4       	ldi	r23, 0x40	; 64
    a708:	82 e3       	ldi	r24, 0x32	; 50
    a70a:	94 e4       	ldi	r25, 0x44	; 68
    a70c:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a710:	6b 01       	movw	r12, r22
    a712:	7c 01       	movw	r14, r24
    a714:	e8 94       	clt
    a716:	f7 f8       	bld	r15, 7

        // we throw away the first two samples as the compass may
        // still be changing its state from the application of the
        // strap excitation. After that we accept values in a
        // reasonable range
        if (numAttempts > 2 &&
    a718:	23 e3       	ldi	r18, 0x33	; 51
    a71a:	33 e3       	ldi	r19, 0x33	; 51
    a71c:	43 e3       	ldi	r20, 0x33	; 51
    a71e:	5f e3       	ldi	r21, 0x3F	; 63
    a720:	c7 01       	movw	r24, r14
    a722:	b6 01       	movw	r22, r12
    a724:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    a728:	18 16       	cp	r1, r24
    a72a:	ec f5       	brge	.+122    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
    a72c:	2d ec       	ldi	r18, 0xCD	; 205
    a72e:	3c ec       	ldi	r19, 0xCC	; 204
    a730:	4c ea       	ldi	r20, 0xAC	; 172
    a732:	5f e3       	ldi	r21, 0x3F	; 63
    a734:	c7 01       	movw	r24, r14
    a736:	b6 01       	movw	r22, r12
    a738:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    a73c:	88 23       	and	r24, r24
    a73e:	9c f5       	brge	.+102    	; 0xa7a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x366>
            cal[0] > 0.7f && cal[0] < 1.35f &&
            cal[1] > 0.7f && cal[1] < 1.35f &&
            cal[2] > 0.7f && cal[2] < 1.35f) {
//        if (numAttempts > 2 ) {				
            // hal.console->printf_P(PSTR("cal=%.2f %.2f %.2f good\n"), cal[0], cal[1], cal[2]);
            good_count++;
    a740:	9f ef       	ldi	r25, 0xFF	; 255
    a742:	29 1a       	sub	r2, r25
    a744:	39 0a       	sbc	r3, r25
            calibration[0] += cal[0];
    a746:	e6 e2       	ldi	r30, 0x26	; 38
    a748:	f4 e0       	ldi	r31, 0x04	; 4
    a74a:	20 81       	ld	r18, Z
    a74c:	31 81       	ldd	r19, Z+1	; 0x01
    a74e:	42 81       	ldd	r20, Z+2	; 0x02
    a750:	53 81       	ldd	r21, Z+3	; 0x03
    a752:	c3 01       	movw	r24, r6
    a754:	b2 01       	movw	r22, r4
    a756:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    a75a:	e6 e2       	ldi	r30, 0x26	; 38
    a75c:	f4 e0       	ldi	r31, 0x04	; 4
    a75e:	60 83       	st	Z, r22
    a760:	71 83       	std	Z+1, r23	; 0x01
    a762:	82 83       	std	Z+2, r24	; 0x02
    a764:	93 83       	std	Z+3, r25	; 0x03
            calibration[1] += cal[1];
    a766:	ea e2       	ldi	r30, 0x2A	; 42
    a768:	f4 e0       	ldi	r31, 0x04	; 4
    a76a:	20 81       	ld	r18, Z
    a76c:	31 81       	ldd	r19, Z+1	; 0x01
    a76e:	42 81       	ldd	r20, Z+2	; 0x02
    a770:	53 81       	ldd	r21, Z+3	; 0x03
    a772:	c5 01       	movw	r24, r10
    a774:	b4 01       	movw	r22, r8
    a776:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    a77a:	ea e2       	ldi	r30, 0x2A	; 42
    a77c:	f4 e0       	ldi	r31, 0x04	; 4
    a77e:	60 83       	st	Z, r22
    a780:	71 83       	std	Z+1, r23	; 0x01
    a782:	82 83       	std	Z+2, r24	; 0x02
    a784:	93 83       	std	Z+3, r25	; 0x03
            calibration[2] += cal[2];
    a786:	ee e2       	ldi	r30, 0x2E	; 46
    a788:	f4 e0       	ldi	r31, 0x04	; 4
    a78a:	20 81       	ld	r18, Z
    a78c:	31 81       	ldd	r19, Z+1	; 0x01
    a78e:	42 81       	ldd	r20, Z+2	; 0x02
    a790:	53 81       	ldd	r21, Z+3	; 0x03
    a792:	c7 01       	movw	r24, r14
    a794:	b6 01       	movw	r22, r12
    a796:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    a79a:	ee e2       	ldi	r30, 0x2E	; 46
    a79c:	f4 e0       	ldi	r31, 0x04	; 4
    a79e:	60 83       	st	Z, r22
    a7a0:	71 83       	std	Z+1, r23	; 0x01
    a7a2:	82 83       	std	Z+2, r24	; 0x02
    a7a4:	93 83       	std	Z+3, r25	; 0x03
	
	calibration[0] = 0;
	calibration[1] = 0;
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    a7a6:	09 31       	cpi	r16, 0x19	; 25
    a7a8:	11 05       	cpc	r17, r1
    a7aa:	09 f4       	brne	.+2      	; 0xa7ae <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x36e>
    a7ac:	10 c1       	rjmp	.+544    	; 0xa9ce <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58e>
    a7ae:	f5 e0       	ldi	r31, 0x05	; 5
    a7b0:	2f 16       	cp	r2, r31
    a7b2:	31 04       	cpc	r3, r1
    a7b4:	0c f4       	brge	.+2      	; 0xa7b8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x378>
    a7b6:	11 c1       	rjmp	.+546    	; 0xa9da <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x59a>
          impact is that the values we report on APM1/APM2 are lower
          than they should be (by a multiple of about 0.6). This
          doesn't have any impact other than the learned compass
          offsets
         */
        calibration[0] = calibration[0]  / good_count;
    a7b8:	b1 01       	movw	r22, r2
    a7ba:	88 27       	eor	r24, r24
    a7bc:	77 fd       	sbrc	r23, 7
    a7be:	80 95       	com	r24
    a7c0:	98 2f       	mov	r25, r24
    a7c2:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    a7c6:	6b 01       	movw	r12, r22
    a7c8:	7c 01       	movw	r14, r24
    a7ca:	06 e2       	ldi	r16, 0x26	; 38
    a7cc:	14 e0       	ldi	r17, 0x04	; 4
    a7ce:	9b 01       	movw	r18, r22
    a7d0:	ac 01       	movw	r20, r24
    a7d2:	f8 01       	movw	r30, r16
    a7d4:	60 81       	ld	r22, Z
    a7d6:	71 81       	ldd	r23, Z+1	; 0x01
    a7d8:	82 81       	ldd	r24, Z+2	; 0x02
    a7da:	93 81       	ldd	r25, Z+3	; 0x03
    a7dc:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a7e0:	f8 01       	movw	r30, r16
    a7e2:	60 83       	st	Z, r22
    a7e4:	71 83       	std	Z+1, r23	; 0x01
    a7e6:	82 83       	std	Z+2, r24	; 0x02
    a7e8:	93 83       	std	Z+3, r25	; 0x03
        calibration[1] = calibration[1]  / good_count;
    a7ea:	0a e2       	ldi	r16, 0x2A	; 42
    a7ec:	14 e0       	ldi	r17, 0x04	; 4
    a7ee:	a7 01       	movw	r20, r14
    a7f0:	96 01       	movw	r18, r12
    a7f2:	f8 01       	movw	r30, r16
    a7f4:	60 81       	ld	r22, Z
    a7f6:	71 81       	ldd	r23, Z+1	; 0x01
    a7f8:	82 81       	ldd	r24, Z+2	; 0x02
    a7fa:	93 81       	ldd	r25, Z+3	; 0x03
    a7fc:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a800:	f8 01       	movw	r30, r16
    a802:	60 83       	st	Z, r22
    a804:	71 83       	std	Z+1, r23	; 0x01
    a806:	82 83       	std	Z+2, r24	; 0x02
    a808:	93 83       	std	Z+3, r25	; 0x03
        calibration[2] = calibration[2]  / good_count;
    a80a:	0e e2       	ldi	r16, 0x2E	; 46
    a80c:	14 e0       	ldi	r17, 0x04	; 4
    a80e:	a7 01       	movw	r20, r14
    a810:	96 01       	movw	r18, r12
    a812:	f8 01       	movw	r30, r16
    a814:	60 81       	ld	r22, Z
    a816:	71 81       	ldd	r23, Z+1	; 0x01
    a818:	82 81       	ldd	r24, Z+2	; 0x02
    a81a:	93 81       	ldd	r25, Z+3	; 0x03
    a81c:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    a820:	f8 01       	movw	r30, r16
    a822:	60 83       	st	Z, r22
    a824:	71 83       	std	Z+1, r23	; 0x01
    a826:	82 83       	std	Z+2, r24	; 0x02
    a828:	93 83       	std	Z+3, r25	; 0x03
    a82a:	1c c0       	rjmp	.+56     	; 0xa864 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x424>
        success = true;
    } else {
        /* best guess */
        calibration[0] = 1.0;
    a82c:	80 e0       	ldi	r24, 0x00	; 0
    a82e:	90 e0       	ldi	r25, 0x00	; 0
    a830:	a0 e8       	ldi	r26, 0x80	; 128
    a832:	bf e3       	ldi	r27, 0x3F	; 63
    a834:	80 93 26 04 	sts	0x0426, r24
    a838:	90 93 27 04 	sts	0x0427, r25
    a83c:	a0 93 28 04 	sts	0x0428, r26
    a840:	b0 93 29 04 	sts	0x0429, r27
        calibration[1] = 1.0;
    a844:	80 93 2a 04 	sts	0x042A, r24
    a848:	90 93 2b 04 	sts	0x042B, r25
    a84c:	a0 93 2c 04 	sts	0x042C, r26
    a850:	b0 93 2d 04 	sts	0x042D, r27
        calibration[2] = 1.0;
    a854:	80 93 2e 04 	sts	0x042E, r24
    a858:	90 93 2f 04 	sts	0x042F, r25
    a85c:	a0 93 30 04 	sts	0x0430, r26
    a860:	b0 93 31 04 	sts	0x0431, r27
	
	
	
	
	
	readyForOffsets = true;
    a864:	81 e0       	ldi	r24, 0x01	; 1
    a866:	80 93 25 04 	sts	0x0425, r24
	
	
	
	
	//Start a two wire transaction
	if(!driver->start())
    a86a:	8e a9       	ldd	r24, Y+54	; 0x36
    a86c:	9f a9       	ldd	r25, Y+55	; 0x37
    a86e:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a872:	88 23       	and	r24, r24
    a874:	09 f4       	brne	.+2      	; 0xa878 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x438>
    a876:	93 c0       	rjmp	.+294    	; 0xa99e <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x55e>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a878:	48 e1       	ldi	r20, 0x18	; 24
    a87a:	6c e3       	ldi	r22, 0x3C	; 60
    a87c:	8e a9       	ldd	r24, Y+54	; 0x36
    a87e:	9f a9       	ldd	r25, Y+55	; 0x37
    a880:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a884:	88 23       	and	r24, r24
    a886:	09 f4       	brne	.+2      	; 0xa88a <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x44a>
    a888:	8c c0       	rjmp	.+280    	; 0xa9a2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x562>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a88a:	48 e2       	ldi	r20, 0x28	; 40
    a88c:	60 e0       	ldi	r22, 0x00	; 0
    a88e:	8e a9       	ldd	r24, Y+54	; 0x36
    a890:	9f a9       	ldd	r25, Y+55	; 0x37
    a892:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a896:	88 23       	and	r24, r24
    a898:	09 f4       	brne	.+2      	; 0xa89c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x45c>
    a89a:	85 c0       	rjmp	.+266    	; 0xa9a6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x566>
	{
		return false;
	}
	
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a89c:	48 e2       	ldi	r20, 0x28	; 40
    a89e:	68 e7       	ldi	r22, 0x78	; 120
    a8a0:	8e a9       	ldd	r24, Y+54	; 0x36
    a8a2:	9f a9       	ldd	r25, Y+55	; 0x37
    a8a4:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8a8:	88 23       	and	r24, r24
    a8aa:	09 f4       	brne	.+2      	; 0xa8ae <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x46e>
    a8ac:	7e c0       	rjmp	.+252    	; 0xa9aa <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x56a>
	{
		return false;
	}

	//end the transaction
	driver->stop();	
    a8ae:	8e a9       	ldd	r24, Y+54	; 0x36
    a8b0:	9f a9       	ldd	r25, Y+55	; 0x37
    a8b2:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	
	byte primary_gain = 0x20;
	       // set gains
	       if(!driver->start())
    a8b6:	8e a9       	ldd	r24, Y+54	; 0x36
    a8b8:	9f a9       	ldd	r25, Y+55	; 0x37
    a8ba:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a8be:	88 23       	and	r24, r24
    a8c0:	09 f4       	brne	.+2      	; 0xa8c4 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x484>
    a8c2:	75 c0       	rjmp	.+234    	; 0xa9ae <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x56e>
	       {
		       return false;
	       }
	       
	       //Indicate that the next value is a write operation
	       if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a8c4:	48 e1       	ldi	r20, 0x18	; 24
    a8c6:	6c e3       	ldi	r22, 0x3C	; 60
    a8c8:	8e a9       	ldd	r24, Y+54	; 0x36
    a8ca:	9f a9       	ldd	r25, Y+55	; 0x37
    a8cc:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8d0:	88 23       	and	r24, r24
    a8d2:	09 f4       	brne	.+2      	; 0xa8d6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x496>
    a8d4:	6e c0       	rjmp	.+220    	; 0xa9b2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x572>
	       {
		       return false;
	       }
	       
	       //Write to the device so that the 'pointer' moves to register B
	       if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a8d6:	48 e2       	ldi	r20, 0x28	; 40
    a8d8:	61 e0       	ldi	r22, 0x01	; 1
    a8da:	8e a9       	ldd	r24, Y+54	; 0x36
    a8dc:	9f a9       	ldd	r25, Y+55	; 0x37
    a8de:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8e2:	88 23       	and	r24, r24
    a8e4:	09 f4       	brne	.+2      	; 0xa8e8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4a8>
    a8e6:	67 c0       	rjmp	.+206    	; 0xa9b6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x576>
	       {
		       return false;
	       }
	       
	       //Write the configuration value to register B
	       if (!driver->write(primary_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a8e8:	48 e2       	ldi	r20, 0x28	; 40
    a8ea:	60 e2       	ldi	r22, 0x20	; 32
    a8ec:	8e a9       	ldd	r24, Y+54	; 0x36
    a8ee:	9f a9       	ldd	r25, Y+55	; 0x37
    a8f0:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a8f4:	88 23       	and	r24, r24
    a8f6:	09 f4       	brne	.+2      	; 0xa8fa <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4ba>
    a8f8:	60 c0       	rjmp	.+192    	; 0xa9ba <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x57a>
	       {
		       return false;
	       }

	       //end the transaction
	       driver->stop();
    a8fa:	8e a9       	ldd	r24, Y+54	; 0x36
    a8fc:	9f a9       	ldd	r25, Y+55	; 0x37
    a8fe:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>

	/**
	* Set the compass mode for continuous measurement
	*/
	//start a transaction
	if(!driver->start())
    a902:	8e a9       	ldd	r24, Y+54	; 0x36
    a904:	9f a9       	ldd	r25, Y+55	; 0x37
    a906:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a90a:	88 23       	and	r24, r24
    a90c:	09 f4       	brne	.+2      	; 0xa910 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4d0>
    a90e:	57 c0       	rjmp	.+174    	; 0xa9be <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x57e>
	{
		return false;
	}
		
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a910:	48 e1       	ldi	r20, 0x18	; 24
    a912:	6c e3       	ldi	r22, 0x3C	; 60
    a914:	8e a9       	ldd	r24, Y+54	; 0x36
    a916:	9f a9       	ldd	r25, Y+55	; 0x37
    a918:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a91c:	88 23       	and	r24, r24
    a91e:	09 f4       	brne	.+2      	; 0xa922 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4e2>
    a920:	50 c0       	rjmp	.+160    	; 0xa9c2 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x582>
	{
		return false;
	}		
		
	//Write to the device so that the 'pointer' moves to the mode register
	if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a922:	48 e2       	ldi	r20, 0x28	; 40
    a924:	62 e0       	ldi	r22, 0x02	; 2
    a926:	8e a9       	ldd	r24, Y+54	; 0x36
    a928:	9f a9       	ldd	r25, Y+55	; 0x37
    a92a:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a92e:	88 23       	and	r24, r24
    a930:	09 f4       	brne	.+2      	; 0xa934 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x4f4>
    a932:	49 c0       	rjmp	.+146    	; 0xa9c6 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x586>
	{
		return false;
	}

	//Write the configuration value to the mode register
	if (!driver->write(COMPASS_MODE_CONTINUOUS_MEASUREMENT_MODE, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a934:	48 e2       	ldi	r20, 0x28	; 40
    a936:	60 e0       	ldi	r22, 0x00	; 0
    a938:	8e a9       	ldd	r24, Y+54	; 0x36
    a93a:	9f a9       	ldd	r25, Y+55	; 0x37
    a93c:	0e 94 1f 10 	call	0x203e	; 0x203e <_ZN10helicopter7drivers9TWIDriver5writeEhh>
    a940:	88 23       	and	r24, r24
    a942:	09 f4       	brne	.+2      	; 0xa946 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x506>
    a944:	42 c0       	rjmp	.+132    	; 0xa9ca <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x58a>
	{
		return false;
	}

	//end the transaction
	driver->stop();
    a946:	8e a9       	ldd	r24, Y+54	; 0x36
    a948:	9f a9       	ldd	r25, Y+55	; 0x37
    a94a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN10helicopter7drivers9TWIDriver4stopEv>
	
	return true;
    a94e:	81 e0       	ldi	r24, 0x01	; 1
    a950:	4c c0       	rjmp	.+152    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	*/
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a952:	80 e0       	ldi	r24, 0x00	; 0
    a954:	4a c0       	rjmp	.+148    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation 
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a956:	80 e0       	ldi	r24, 0x00	; 0
    a958:	48 c0       	rjmp	.+144    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a95a:	80 e0       	ldi	r24, 0x00	; 0
    a95c:	46 c0       	rjmp	.+140    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a95e:	80 e0       	ldi	r24, 0x00	; 0
    a960:	44 c0       	rjmp	.+136    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a962:	80 e0       	ldi	r24, 0x00	; 0
    a964:	42 c0       	rjmp	.+132    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a966:	80 e0       	ldi	r24, 0x00	; 0
    a968:	40 c0       	rjmp	.+128    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a96a:	80 e0       	ldi	r24, 0x00	; 0
    a96c:	3e c0       	rjmp	.+124    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write the configuration value to register B
	if (!driver->write(REGISTER_B_CONFIGURATION_660_GAIN, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a96e:	80 e0       	ldi	r24, 0x00	; 0
    a970:	3c c0       	rjmp	.+120    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a972:	80 e0       	ldi	r24, 0x00	; 0
    a974:	3a c0       	rjmp	.+116    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a976:	80 e0       	ldi	r24, 0x00	; 0
    a978:	38 c0       	rjmp	.+112    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(PositiveBiasConfig, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a97a:	80 e0       	ldi	r24, 0x00	; 0
    a97c:	36 c0       	rjmp	.+108    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>

        
        _delay_ms(50);

        // set gains
	if(!driver->start())
    a97e:	80 e0       	ldi	r24, 0x00	; 0
    a980:	34 c0       	rjmp	.+104    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a982:	80 e0       	ldi	r24, 0x00	; 0
    a984:	32 c0       	rjmp	.+100    	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write to the device so that the 'pointer' moves to register B
	if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a986:	80 e0       	ldi	r24, 0x00	; 0
    a988:	30 c0       	rjmp	.+96     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	{
		return false;
	}
	
	//Write the configuration value to register B
	if (!driver->write(calibration_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a98a:	80 e0       	ldi	r24, 0x00	; 0
    a98c:	2e c0       	rjmp	.+92     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	        _delay_ms(50);

	        // set gains
	        if(!driver->start())
    a98e:	80 e0       	ldi	r24, 0x00	; 0
    a990:	2c c0       	rjmp	.+88     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	        {
		        return false;
	        }
	        
	        //Indicate that the next value is a write operation
	        if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
    a992:	80 e0       	ldi	r24, 0x00	; 0
    a994:	2a c0       	rjmp	.+84     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
		        return false;
	        }
	        
			
	        //Write to the device so that the 'pointer' moves to register B
	        if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a996:	80 e0       	ldi	r24, 0x00	; 0
    a998:	28 c0       	rjmp	.+80     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	        {
		        return false;
	        }
	        byte singleConversion = 0x01;
	        //Write the configuration value to register B
	        if (!driver->write(singleConversion, TWIDriver::MASTERTRANSMIT_DATA_ACK))
    a99a:	80 e0       	ldi	r24, 0x00	; 0
    a99c:	26 c0       	rjmp	.+76     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	
	//Start a two wire transaction
	if(!driver->start())
	{
		return false;
    a99e:	80 e0       	ldi	r24, 0x00	; 0
    a9a0:	24 c0       	rjmp	.+72     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a9a2:	80 e0       	ldi	r24, 0x00	; 0
    a9a4:	22 c0       	rjmp	.+68     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write to the device so that the 'pointer' moves to register A
	if (!driver->write(CONFIGURATION_REGISTER_A, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9a6:	80 e0       	ldi	r24, 0x00	; 0
    a9a8:	20 c0       	rjmp	.+64     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
	
	//Write the configuration value to register A
	if (!driver->write(REGISTER_A_CONFIGURATION_75HZ_8AVG, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9aa:	80 e0       	ldi	r24, 0x00	; 0
    a9ac:	1e c0       	rjmp	.+60     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	
	byte primary_gain = 0x20;
	       // set gains
	       if(!driver->start())
	       {
		       return false;
    a9ae:	80 e0       	ldi	r24, 0x00	; 0
    a9b0:	1c c0       	rjmp	.+56     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Indicate that the next value is a write operation
	       if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	       {
		       return false;
    a9b2:	80 e0       	ldi	r24, 0x00	; 0
    a9b4:	1a c0       	rjmp	.+52     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Write to the device so that the 'pointer' moves to register B
	       if (!driver->write(CONFIGURATION_REGISTER_B, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	       {
		       return false;
    a9b6:	80 e0       	ldi	r24, 0x00	; 0
    a9b8:	18 c0       	rjmp	.+48     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	       }
	       
	       //Write the configuration value to register B
	       if (!driver->write(primary_gain, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	       {
		       return false;
    a9ba:	80 e0       	ldi	r24, 0x00	; 0
    a9bc:	16 c0       	rjmp	.+44     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	* Set the compass mode for continuous measurement
	*/
	//start a transaction
	if(!driver->start())
	{
		return false;
    a9be:	80 e0       	ldi	r24, 0x00	; 0
    a9c0:	14 c0       	rjmp	.+40     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}
		
	//Indicate that the next value is a write operation
	if (!driver->write(MAGNETOMETER_TWOWIRE_SENSOR_ADDRESS | WRITE_OPERATION, TWIDriver::MASTERTRANSMIT_SLAVE_WRITE_ACK))
	{
		return false;
    a9c2:	80 e0       	ldi	r24, 0x00	; 0
    a9c4:	12 c0       	rjmp	.+36     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}		
		
	//Write to the device so that the 'pointer' moves to the mode register
	if (!driver->write(MODE_REGISTER, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9c6:	80 e0       	ldi	r24, 0x00	; 0
    a9c8:	10 c0       	rjmp	.+32     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
	}

	//Write the configuration value to the mode register
	if (!driver->write(COMPASS_MODE_CONTINUOUS_MEASUREMENT_MODE, TWIDriver::MASTERTRANSMIT_DATA_ACK))
	{
		return false;
    a9ca:	80 e0       	ldi	r24, 0x00	; 0
    a9cc:	0e c0       	rjmp	.+28     	; 0xa9ea <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x5aa>
        }


    }

    if (good_count >= 5) {
    a9ce:	f5 e0       	ldi	r31, 0x05	; 5
    a9d0:	2f 16       	cp	r2, r31
    a9d2:	31 04       	cpc	r3, r1
    a9d4:	0c f4       	brge	.+2      	; 0xa9d8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x598>
    a9d6:	2a cf       	rjmp	.-428    	; 0xa82c <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x3ec>
    a9d8:	ef ce       	rjmp	.-546    	; 0xa7b8 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0x378>
	calibration[2] = 0;

    while ( success == 0 && numAttempts < 25 && good_count < 5)
    {
        // record number of attempts at initialisation
        numAttempts++;
    a9da:	0f 5f       	subi	r16, 0xFF	; 255
    a9dc:	1f 4f       	sbci	r17, 0xFF	; 255



// force positiveBias (compass should return 715 for all channels)
	//Start a two wire transaction
	if(!driver->start())
    a9de:	8e a9       	ldd	r24, Y+54	; 0x36
    a9e0:	9f a9       	ldd	r25, Y+55	; 0x37
    a9e2:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <_ZN10helicopter7drivers9TWIDriver5startEv>
    a9e6:	81 11       	cpse	r24, r1
    a9e8:	a7 cd       	rjmp	.-1202   	; 0xa538 <_ZN10helicopter7sensors18MagnetometerSensor4initEv+0xf8>

	//end the transaction
	driver->stop();
	
	return true;
}
    a9ea:	df 91       	pop	r29
    a9ec:	cf 91       	pop	r28
    a9ee:	1f 91       	pop	r17
    a9f0:	0f 91       	pop	r16
    a9f2:	ff 90       	pop	r15
    a9f4:	ef 90       	pop	r14
    a9f6:	df 90       	pop	r13
    a9f8:	cf 90       	pop	r12
    a9fa:	bf 90       	pop	r11
    a9fc:	af 90       	pop	r10
    a9fe:	9f 90       	pop	r9
    aa00:	8f 90       	pop	r8
    aa02:	7f 90       	pop	r7
    aa04:	6f 90       	pop	r6
    aa06:	5f 90       	pop	r5
    aa08:	4f 90       	pop	r4
    aa0a:	3f 90       	pop	r3
    aa0c:	2f 90       	pop	r2
    aa0e:	08 95       	ret

0000aa10 <_ZN10helicopter5tasks4Task4initEv>:
				virtual ~Task(){}
				
				/**
				 * Function to initialize the task before execution.
				 */
				virtual void init(){;}
    aa10:	08 95       	ret

0000aa12 <_ZN10helicopter5tasks14NavigationTaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    aa12:	26 e7       	ldi	r18, 0x76	; 118
    aa14:	33 e0       	ldi	r19, 0x03	; 3
    aa16:	fc 01       	movw	r30, r24
    aa18:	31 83       	std	Z+1, r19	; 0x01
    aa1a:	20 83       	st	Z, r18
    aa1c:	08 95       	ret

0000aa1e <_ZN10helicopter5tasks14NavigationTaskD0Ev>:
    aa1e:	26 e7       	ldi	r18, 0x76	; 118
    aa20:	33 e0       	ldi	r19, 0x03	; 3
    aa22:	fc 01       	movw	r30, r24
    aa24:	31 83       	std	Z+1, r19	; 0x01
    aa26:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class NavigationTask : public Task
    aa28:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    aa2c:	08 95       	ret

0000aa2e <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv>:
{
	
}

void NavigationTask::runTaskImpl()
{
    aa2e:	6f 92       	push	r6
    aa30:	7f 92       	push	r7
    aa32:	8f 92       	push	r8
    aa34:	9f 92       	push	r9
    aa36:	af 92       	push	r10
    aa38:	bf 92       	push	r11
    aa3a:	cf 92       	push	r12
    aa3c:	df 92       	push	r13
    aa3e:	ef 92       	push	r14
    aa40:	ff 92       	push	r15
    aa42:	0f 93       	push	r16
    aa44:	1f 93       	push	r17
    aa46:	cf 93       	push	r28
    aa48:	df 93       	push	r29
    aa4a:	ec 01       	movw	r28, r24
	//avoid oversampling by only calculating a new ahrs value if we have new gyro data (since our AHRS is most sensitive to gyro data).
	if (model->RollAngularVelocityRadsPerSecond() != oldrollAngularVelocityRs || 
    aa4c:	6d 84       	ldd	r6, Y+13	; 0x0d
    aa4e:	7e 84       	ldd	r7, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    aa50:	f3 01       	movw	r30, r6
    aa52:	e2 52       	subi	r30, 0x22	; 34
    aa54:	ff 4f       	sbci	r31, 0xFF	; 255
    aa56:	80 80       	ld	r8, Z
    aa58:	91 80       	ldd	r9, Z+1	; 0x01
    aa5a:	a2 80       	ldd	r10, Z+2	; 0x02
    aa5c:	b3 80       	ldd	r11, Z+3	; 0x03
    aa5e:	a5 01       	movw	r20, r10
    aa60:	94 01       	movw	r18, r8
    aa62:	6b 89       	ldd	r22, Y+19	; 0x13
    aa64:	7c 89       	ldd	r23, Y+20	; 0x14
    aa66:	8d 89       	ldd	r24, Y+21	; 0x15
    aa68:	9e 89       	ldd	r25, Y+22	; 0x16
    aa6a:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    aa6e:	81 11       	cpse	r24, r1
    aa70:	1f c0       	rjmp	.+62     	; 0xaab0 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    aa72:	f3 01       	movw	r30, r6
    aa74:	e6 52       	subi	r30, 0x26	; 38
    aa76:	ff 4f       	sbci	r31, 0xFF	; 255
    aa78:	20 81       	ld	r18, Z
    aa7a:	31 81       	ldd	r19, Z+1	; 0x01
    aa7c:	42 81       	ldd	r20, Z+2	; 0x02
    aa7e:	53 81       	ldd	r21, Z+3	; 0x03
    aa80:	6f 85       	ldd	r22, Y+15	; 0x0f
    aa82:	78 89       	ldd	r23, Y+16	; 0x10
    aa84:	89 89       	ldd	r24, Y+17	; 0x11
    aa86:	9a 89       	ldd	r25, Y+18	; 0x12
    aa88:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    aa8c:	81 11       	cpse	r24, r1
    aa8e:	10 c0       	rjmp	.+32     	; 0xaab0 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    aa90:	f3 01       	movw	r30, r6
    aa92:	ee 51       	subi	r30, 0x1E	; 30
    aa94:	ff 4f       	sbci	r31, 0xFF	; 255
    aa96:	20 81       	ld	r18, Z
    aa98:	31 81       	ldd	r19, Z+1	; 0x01
    aa9a:	42 81       	ldd	r20, Z+2	; 0x02
    aa9c:	53 81       	ldd	r21, Z+3	; 0x03
    aa9e:	6f 89       	ldd	r22, Y+23	; 0x17
    aaa0:	78 8d       	ldd	r23, Y+24	; 0x18
    aaa2:	89 8d       	ldd	r24, Y+25	; 0x19
    aaa4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    aaa6:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    aaaa:	88 23       	and	r24, r24
    aaac:	09 f4       	brne	.+2      	; 0xaab0 <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x82>
    aaae:	9f c0       	rjmp	.+318    	; 0xabee <_ZN10helicopter5tasks14NavigationTask11runTaskImplEv+0x1c0>
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    aab0:	f3 01       	movw	r30, r6
    aab2:	e2 51       	subi	r30, 0x12	; 18
    aab4:	ff 4f       	sbci	r31, 0xFF	; 255
		/**
		 * Update the AHRS
		 */
		ahrs->update(model->XAccelFrdMss(), model->YAccelFrdMss(), model->ZAccelFrdMss(),
					model->RollAngularVelocityRadsPerSecond(), model->PitchAngularVelocityRadsPerSecond(), model->YawAngularVelocityRadsPerSecond(),
					model->XMagFrd(), model->YMagFrd(), model->ZMagFrd());
    aab6:	c0 80       	ld	r12, Z
    aab8:	d1 80       	ldd	r13, Z+1	; 0x01
    aaba:	e2 80       	ldd	r14, Z+2	; 0x02
    aabc:	f3 80       	ldd	r15, Z+3	; 0x03
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    aabe:	f3 01       	movw	r30, r6
    aac0:	e6 51       	subi	r30, 0x16	; 22
    aac2:	ff 4f       	sbci	r31, 0xFF	; 255
    aac4:	00 81       	ld	r16, Z
    aac6:	11 81       	ldd	r17, Z+1	; 0x01
    aac8:	22 81       	ldd	r18, Z+2	; 0x02
    aaca:	33 81       	ldd	r19, Z+3	; 0x03

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    aacc:	f3 01       	movw	r30, r6
    aace:	ea 51       	subi	r30, 0x1A	; 26
    aad0:	ff 4f       	sbci	r31, 0xFF	; 255
    aad2:	40 81       	ld	r20, Z
    aad4:	51 81       	ldd	r21, Z+1	; 0x01
    aad6:	62 81       	ldd	r22, Z+2	; 0x02
    aad8:	73 81       	ldd	r23, Z+3	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    aada:	f3 01       	movw	r30, r6
    aadc:	e6 50       	subi	r30, 0x06	; 6
    aade:	ff 4f       	sbci	r31, 0xFF	; 255
    aae0:	83 81       	ldd	r24, Z+3	; 0x03
    aae2:	8f 93       	push	r24
    aae4:	82 81       	ldd	r24, Z+2	; 0x02
    aae6:	8f 93       	push	r24
    aae8:	81 81       	ldd	r24, Z+1	; 0x01
    aaea:	8f 93       	push	r24
    aaec:	e0 81       	ld	r30, Z
    aaee:	ef 93       	push	r30
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    aaf0:	f3 01       	movw	r30, r6
    aaf2:	ea 50       	subi	r30, 0x0A	; 10
    aaf4:	ff 4f       	sbci	r31, 0xFF	; 255
    aaf6:	83 81       	ldd	r24, Z+3	; 0x03
    aaf8:	8f 93       	push	r24
    aafa:	82 81       	ldd	r24, Z+2	; 0x02
    aafc:	8f 93       	push	r24
    aafe:	81 81       	ldd	r24, Z+1	; 0x01
    ab00:	8f 93       	push	r24
    ab02:	e0 81       	ld	r30, Z
    ab04:	ef 93       	push	r30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    ab06:	f3 01       	movw	r30, r6
    ab08:	ee 50       	subi	r30, 0x0E	; 14
    ab0a:	ff 4f       	sbci	r31, 0xFF	; 255
    ab0c:	83 81       	ldd	r24, Z+3	; 0x03
    ab0e:	8f 93       	push	r24
    ab10:	82 81       	ldd	r24, Z+2	; 0x02
    ab12:	8f 93       	push	r24
    ab14:	81 81       	ldd	r24, Z+1	; 0x01
    ab16:	8f 93       	push	r24
    ab18:	e0 81       	ld	r30, Z
    ab1a:	ef 93       	push	r30
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    ab1c:	f3 01       	movw	r30, r6
    ab1e:	ee 51       	subi	r30, 0x1E	; 30
    ab20:	ff 4f       	sbci	r31, 0xFF	; 255
    ab22:	83 81       	ldd	r24, Z+3	; 0x03
    ab24:	8f 93       	push	r24
    ab26:	82 81       	ldd	r24, Z+2	; 0x02
    ab28:	8f 93       	push	r24
    ab2a:	81 81       	ldd	r24, Z+1	; 0x01
    ab2c:	8f 93       	push	r24
    ab2e:	e0 81       	ld	r30, Z
    ab30:	ef 93       	push	r30
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    ab32:	f3 01       	movw	r30, r6
    ab34:	e6 52       	subi	r30, 0x26	; 38
    ab36:	ff 4f       	sbci	r31, 0xFF	; 255
    ab38:	83 81       	ldd	r24, Z+3	; 0x03
    ab3a:	8f 93       	push	r24
    ab3c:	82 81       	ldd	r24, Z+2	; 0x02
    ab3e:	8f 93       	push	r24
    ab40:	81 81       	ldd	r24, Z+1	; 0x01
    ab42:	8f 93       	push	r24
    ab44:	e0 81       	ld	r30, Z
    ab46:	ef 93       	push	r30
    ab48:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab4a:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab4c:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <_ZN10helicopter10navigation4AHRS6updateEfffffffff>
				
		model->YawRads(ahrs->getYawRads());
    ab50:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab52:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab54:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <_ZN10helicopter10navigation4AHRS10getYawRadsEv>
    ab58:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab5a:	fe 85       	ldd	r31, Y+14	; 0x0e

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
    ab5c:	ea 52       	subi	r30, 0x2A	; 42
    ab5e:	ff 4f       	sbci	r31, 0xFF	; 255
    ab60:	60 83       	st	Z, r22
    ab62:	71 83       	std	Z+1, r23	; 0x01
    ab64:	82 83       	std	Z+2, r24	; 0x02
    ab66:	93 83       	std	Z+3, r25	; 0x03
		model->PitchRads(ahrs->getPitchRads());
    ab68:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab6a:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab6c:	0e 94 fd 41 	call	0x83fa	; 0x83fa <_ZN10helicopter10navigation4AHRS12getPitchRadsEv>
    ab70:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab72:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
    ab74:	ee 52       	subi	r30, 0x2E	; 46
    ab76:	ff 4f       	sbci	r31, 0xFF	; 255
    ab78:	60 83       	st	Z, r22
    ab7a:	71 83       	std	Z+1, r23	; 0x01
    ab7c:	82 83       	std	Z+2, r24	; 0x02
    ab7e:	93 83       	std	Z+3, r25	; 0x03
		model->RollRads(ahrs->getRollRads());
    ab80:	8b 85       	ldd	r24, Y+11	; 0x0b
    ab82:	9c 85       	ldd	r25, Y+12	; 0x0c
    ab84:	0e 94 07 42 	call	0x840e	; 0x840e <_ZN10helicopter10navigation4AHRS11getRollRadsEv>
    ab88:	ed 85       	ldd	r30, Y+13	; 0x0d
    ab8a:	fe 85       	ldd	r31, Y+14	; 0x0e
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	
    ab8c:	e2 53       	subi	r30, 0x32	; 50
    ab8e:	ff 4f       	sbci	r31, 0xFF	; 255
    ab90:	60 83       	st	Z, r22
    ab92:	71 83       	std	Z+1, r23	; 0x01
    ab94:	82 83       	std	Z+2, r24	; 0x02
    ab96:	93 83       	std	Z+3, r25	; 0x03
		
		oldrollAngularVelocityRs = model->RollAngularVelocityRadsPerSecond();
    ab98:	2d 85       	ldd	r18, Y+13	; 0x0d
    ab9a:	3e 85       	ldd	r19, Y+14	; 0x0e
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    ab9c:	f9 01       	movw	r30, r18
    ab9e:	e2 52       	subi	r30, 0x22	; 34
    aba0:	ff 4f       	sbci	r31, 0xFF	; 255
    aba2:	80 81       	ld	r24, Z
    aba4:	91 81       	ldd	r25, Z+1	; 0x01
    aba6:	a2 81       	ldd	r26, Z+2	; 0x02
    aba8:	b3 81       	ldd	r27, Z+3	; 0x03
    abaa:	8b 8b       	std	Y+19, r24	; 0x13
    abac:	9c 8b       	std	Y+20, r25	; 0x14
    abae:	ad 8b       	std	Y+21, r26	; 0x15
    abb0:	be 8b       	std	Y+22, r27	; 0x16
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    abb2:	f9 01       	movw	r30, r18
    abb4:	e6 52       	subi	r30, 0x26	; 38
    abb6:	ff 4f       	sbci	r31, 0xFF	; 255
    abb8:	80 81       	ld	r24, Z
    abba:	91 81       	ldd	r25, Z+1	; 0x01
    abbc:	a2 81       	ldd	r26, Z+2	; 0x02
    abbe:	b3 81       	ldd	r27, Z+3	; 0x03
		oldpitchAngularVelocityRs = model->PitchAngularVelocityRadsPerSecond();
    abc0:	8f 87       	std	Y+15, r24	; 0x0f
    abc2:	98 8b       	std	Y+16, r25	; 0x10
    abc4:	a9 8b       	std	Y+17, r26	; 0x11
    abc6:	ba 8b       	std	Y+18, r27	; 0x12
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    abc8:	f9 01       	movw	r30, r18
    abca:	ee 51       	subi	r30, 0x1E	; 30
    abcc:	ff 4f       	sbci	r31, 0xFF	; 255
    abce:	80 81       	ld	r24, Z
    abd0:	91 81       	ldd	r25, Z+1	; 0x01
    abd2:	a2 81       	ldd	r26, Z+2	; 0x02
    abd4:	b3 81       	ldd	r27, Z+3	; 0x03
		oldyawAngularVelocityRs = model->YawAngularVelocityRadsPerSecond();
    abd6:	8f 8b       	std	Y+23, r24	; 0x17
    abd8:	98 8f       	std	Y+24, r25	; 0x18
    abda:	a9 8f       	std	Y+25, r26	; 0x19
    abdc:	ba 8f       	std	Y+26, r27	; 0x1a
    abde:	8d b7       	in	r24, 0x3d	; 61
    abe0:	9e b7       	in	r25, 0x3e	; 62
    abe2:	44 96       	adiw	r24, 0x14	; 20
    abe4:	0f b6       	in	r0, 0x3f	; 63
    abe6:	f8 94       	cli
    abe8:	9e bf       	out	0x3e, r25	; 62
    abea:	0f be       	out	0x3f, r0	; 63
    abec:	8d bf       	out	0x3d, r24	; 61
	//model->YNEDLocalFrameCm(localNEDY);
	////model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	//
	//
	
}
    abee:	df 91       	pop	r29
    abf0:	cf 91       	pop	r28
    abf2:	1f 91       	pop	r17
    abf4:	0f 91       	pop	r16
    abf6:	ff 90       	pop	r15
    abf8:	ef 90       	pop	r14
    abfa:	df 90       	pop	r13
    abfc:	cf 90       	pop	r12
    abfe:	bf 90       	pop	r11
    ac00:	af 90       	pop	r10
    ac02:	9f 90       	pop	r9
    ac04:	8f 90       	pop	r8
    ac06:	7f 90       	pop	r7
    ac08:	6f 90       	pop	r6
    ac0a:	08 95       	ret

0000ac0c <_ZN10helicopter5tasks14NavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float NavigationTask::WEIGHT = .15;


NavigationTask::NavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    ac0c:	4f 92       	push	r4
    ac0e:	5f 92       	push	r5
    ac10:	6f 92       	push	r6
    ac12:	7f 92       	push	r7
    ac14:	af 92       	push	r10
    ac16:	bf 92       	push	r11
    ac18:	cf 92       	push	r12
    ac1a:	df 92       	push	r13
    ac1c:	ef 92       	push	r14
    ac1e:	ff 92       	push	r15
    ac20:	0f 93       	push	r16
    ac22:	1f 93       	push	r17
    ac24:	cf 93       	push	r28
    ac26:	df 93       	push	r29
    ac28:	ec 01       	movw	r28, r24
    ac2a:	2a 01       	movw	r4, r20
    ac2c:	3b 01       	movw	r6, r22
    ac2e:	59 01       	movw	r10, r18
    ac30:	b7 01       	movw	r22, r14
    ac32:	a6 01       	movw	r20, r12
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model),
oldpitchAngularVelocityRs(0),
oldrollAngularVelocityRs(0),
oldyawAngularVelocityRs(0)
    ac34:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    ac38:	8a ee       	ldi	r24, 0xEA	; 234
    ac3a:	92 e0       	ldi	r25, 0x02	; 2
    ac3c:	99 83       	std	Y+1, r25	; 0x01
    ac3e:	88 83       	st	Y, r24
    ac40:	4f 82       	std	Y+7, r4	; 0x07
    ac42:	58 86       	std	Y+8, r5	; 0x08
    ac44:	69 86       	std	Y+9, r6	; 0x09
    ac46:	7a 86       	std	Y+10, r7	; 0x0a
    ac48:	bc 86       	std	Y+12, r11	; 0x0c
    ac4a:	ab 86       	std	Y+11, r10	; 0x0b
    ac4c:	1e 87       	std	Y+14, r17	; 0x0e
    ac4e:	0d 87       	std	Y+13, r16	; 0x0d
    ac50:	1f 86       	std	Y+15, r1	; 0x0f
    ac52:	18 8a       	std	Y+16, r1	; 0x10
    ac54:	19 8a       	std	Y+17, r1	; 0x11
    ac56:	1a 8a       	std	Y+18, r1	; 0x12
    ac58:	1b 8a       	std	Y+19, r1	; 0x13
    ac5a:	1c 8a       	std	Y+20, r1	; 0x14
    ac5c:	1d 8a       	std	Y+21, r1	; 0x15
    ac5e:	1e 8a       	std	Y+22, r1	; 0x16
    ac60:	1f 8a       	std	Y+23, r1	; 0x17
    ac62:	18 8e       	std	Y+24, r1	; 0x18
    ac64:	19 8e       	std	Y+25, r1	; 0x19
    ac66:	1a 8e       	std	Y+26, r1	; 0x1a
{
	
}
    ac68:	df 91       	pop	r29
    ac6a:	cf 91       	pop	r28
    ac6c:	1f 91       	pop	r17
    ac6e:	0f 91       	pop	r16
    ac70:	ff 90       	pop	r15
    ac72:	ef 90       	pop	r14
    ac74:	df 90       	pop	r13
    ac76:	cf 90       	pop	r12
    ac78:	bf 90       	pop	r11
    ac7a:	af 90       	pop	r10
    ac7c:	7f 90       	pop	r7
    ac7e:	6f 90       	pop	r6
    ac80:	5f 90       	pop	r5
    ac82:	4f 90       	pop	r4
    ac84:	08 95       	ret

0000ac86 <_ZN10helicopter5tasks16PIDInnerLoopTaskD1Ev>:
    ac86:	26 e7       	ldi	r18, 0x76	; 118
    ac88:	33 e0       	ldi	r19, 0x03	; 3
    ac8a:	fc 01       	movw	r30, r24
    ac8c:	31 83       	std	Z+1, r19	; 0x01
    ac8e:	20 83       	st	Z, r18
    ac90:	08 95       	ret

0000ac92 <_ZN10helicopter5tasks16PIDInnerLoopTaskD0Ev>:
    ac92:	26 e7       	ldi	r18, 0x76	; 118
    ac94:	33 e0       	ldi	r19, 0x03	; 3
    ac96:	fc 01       	movw	r30, r24
    ac98:	31 83       	std	Z+1, r19	; 0x01
    ac9a:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDInnerLoopTask : public Task
    ac9c:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    aca0:	08 95       	ret

0000aca2 <_ZN10helicopter5tasks16PIDInnerLoopTask11runTaskImplEv>:
{
	
}

void PIDInnerLoopTask::runTaskImpl()
{
    aca2:	cf 93       	push	r28
    aca4:	df 93       	push	r29
    aca6:	ec 01       	movw	r28, r24
	pidController->cyclicLateralInnerLoopUpdate();
    aca8:	8f 81       	ldd	r24, Y+7	; 0x07
    acaa:	98 85       	ldd	r25, Y+8	; 0x08
    acac:	0e 94 0b 0a 	call	0x1416	; 0x1416 <_ZN10helicopter10controller13PIDController28cyclicLateralInnerLoopUpdateEv>
	pidController->cyclicLongitudeInnerLoopUpdate();
    acb0:	8f 81       	ldd	r24, Y+7	; 0x07
    acb2:	98 85       	ldd	r25, Y+8	; 0x08
    acb4:	0e 94 9b 09 	call	0x1336	; 0x1336 <_ZN10helicopter10controller13PIDController30cyclicLongitudeInnerLoopUpdateEv>
}
    acb8:	df 91       	pop	r29
    acba:	cf 91       	pop	r28
    acbc:	08 95       	ret

0000acbe <_ZN10helicopter5tasks16PIDInnerLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDInnerLoopTask.h"

using namespace helicopter::tasks;

PIDInnerLoopTask::PIDInnerLoopTask (PIDController *pidController, int delay, int period) :
    acbe:	0f 93       	push	r16
    acc0:	1f 93       	push	r17
    acc2:	cf 93       	push	r28
    acc4:	df 93       	push	r29
    acc6:	ec 01       	movw	r28, r24
    acc8:	8b 01       	movw	r16, r22
    acca:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    accc:	a9 01       	movw	r20, r18
    acce:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    acd2:	88 ef       	ldi	r24, 0xF8	; 248
    acd4:	92 e0       	ldi	r25, 0x02	; 2
    acd6:	99 83       	std	Y+1, r25	; 0x01
    acd8:	88 83       	st	Y, r24
    acda:	18 87       	std	Y+8, r17	; 0x08
    acdc:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    acde:	df 91       	pop	r29
    ace0:	cf 91       	pop	r28
    ace2:	1f 91       	pop	r17
    ace4:	0f 91       	pop	r16
    ace6:	08 95       	ret

0000ace8 <_ZN10helicopter5tasks16PIDOuterLoopTaskD1Ev>:
    ace8:	26 e7       	ldi	r18, 0x76	; 118
    acea:	33 e0       	ldi	r19, 0x03	; 3
    acec:	fc 01       	movw	r30, r24
    acee:	31 83       	std	Z+1, r19	; 0x01
    acf0:	20 83       	st	Z, r18
    acf2:	08 95       	ret

0000acf4 <_ZN10helicopter5tasks16PIDOuterLoopTaskD0Ev>:
    acf4:	26 e7       	ldi	r18, 0x76	; 118
    acf6:	33 e0       	ldi	r19, 0x03	; 3
    acf8:	fc 01       	movw	r30, r24
    acfa:	31 83       	std	Z+1, r19	; 0x01
    acfc:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PIDOuterLoopTask : public Task
    acfe:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    ad02:	08 95       	ret

0000ad04 <_ZN10helicopter5tasks16PIDOuterLoopTask11runTaskImplEv>:
	
}

void PIDOuterLoopTask::runTaskImpl()
{
	pidController->outerLoopUpdate();
    ad04:	fc 01       	movw	r30, r24
    ad06:	87 81       	ldd	r24, Z+7	; 0x07
    ad08:	90 85       	ldd	r25, Z+8	; 0x08
    ad0a:	0e 94 e7 08 	call	0x11ce	; 0x11ce <_ZN10helicopter10controller13PIDController15outerLoopUpdateEv>
    ad0e:	08 95       	ret

0000ad10 <_ZN10helicopter5tasks16PIDOuterLoopTaskC1EPNS_10controller13PIDControllerEii>:
 */ 
#include "PIDOuterLoopTask.h"

using namespace helicopter::tasks;

PIDOuterLoopTask::PIDOuterLoopTask (PIDController *pidController, int delay, int period) :
    ad10:	0f 93       	push	r16
    ad12:	1f 93       	push	r17
    ad14:	cf 93       	push	r28
    ad16:	df 93       	push	r29
    ad18:	ec 01       	movw	r28, r24
    ad1a:	8b 01       	movw	r16, r22
    ad1c:	ba 01       	movw	r22, r20
Task(delay, period),
pidController(pidController)
    ad1e:	a9 01       	movw	r20, r18
    ad20:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    ad24:	86 e0       	ldi	r24, 0x06	; 6
    ad26:	93 e0       	ldi	r25, 0x03	; 3
    ad28:	99 83       	std	Y+1, r25	; 0x01
    ad2a:	88 83       	st	Y, r24
    ad2c:	18 87       	std	Y+8, r17	; 0x08
    ad2e:	0f 83       	std	Y+7, r16	; 0x07
{
	
}
    ad30:	df 91       	pop	r29
    ad32:	cf 91       	pop	r28
    ad34:	1f 91       	pop	r17
    ad36:	0f 91       	pop	r16
    ad38:	08 95       	ret

0000ad3a <_ZN10helicopter5tasks16PVNavigationTaskD1Ev>:
    ad3a:	26 e7       	ldi	r18, 0x76	; 118
    ad3c:	33 e0       	ldi	r19, 0x03	; 3
    ad3e:	fc 01       	movw	r30, r24
    ad40:	31 83       	std	Z+1, r19	; 0x01
    ad42:	20 83       	st	Z, r18
    ad44:	08 95       	ret

0000ad46 <_ZN10helicopter5tasks16PVNavigationTaskD0Ev>:
    ad46:	26 e7       	ldi	r18, 0x76	; 118
    ad48:	33 e0       	ldi	r19, 0x03	; 3
    ad4a:	fc 01       	movw	r30, r24
    ad4c:	31 83       	std	Z+1, r19	; 0x01
    ad4e:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class PVNavigationTask : public Task
    ad50:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    ad54:	08 95       	ret

0000ad56 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv>:
{
	
}

void PVNavigationTask::runTaskImpl()
{	
    ad56:	2f 92       	push	r2
    ad58:	3f 92       	push	r3
    ad5a:	4f 92       	push	r4
    ad5c:	5f 92       	push	r5
    ad5e:	6f 92       	push	r6
    ad60:	7f 92       	push	r7
    ad62:	8f 92       	push	r8
    ad64:	9f 92       	push	r9
    ad66:	af 92       	push	r10
    ad68:	bf 92       	push	r11
    ad6a:	cf 92       	push	r12
    ad6c:	df 92       	push	r13
    ad6e:	ef 92       	push	r14
    ad70:	ff 92       	push	r15
    ad72:	0f 93       	push	r16
    ad74:	1f 93       	push	r17
    ad76:	cf 93       	push	r28
    ad78:	df 93       	push	r29
    ad7a:	cd b7       	in	r28, 0x3d	; 61
    ad7c:	de b7       	in	r29, 0x3e	; 62
    ad7e:	e4 97       	sbiw	r28, 0x34	; 52
    ad80:	0f b6       	in	r0, 0x3f	; 63
    ad82:	f8 94       	cli
    ad84:	de bf       	out	0x3e, r29	; 62
    ad86:	0f be       	out	0x3f, r0	; 63
    ad88:	cd bf       	out	0x3d, r28	; 61
    ad8a:	4c 01       	movw	r8, r24
	/**
	 * Process GPS data into NED position and velocity. 
	 */
	float rotatedVelocityMatrix[3] = {};
    ad8c:	8c e0       	ldi	r24, 0x0C	; 12
    ad8e:	7e 01       	movw	r14, r28
    ad90:	99 e1       	ldi	r25, 0x19	; 25
    ad92:	e9 0e       	add	r14, r25
    ad94:	f1 1c       	adc	r15, r1
    ad96:	d7 01       	movw	r26, r14
    ad98:	e8 2f       	mov	r30, r24
    ad9a:	1d 92       	st	X+, r1
    ad9c:	ea 95       	dec	r30
    ad9e:	e9 f7       	brne	.-6      	; 0xad9a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x44>
	float velocityBodyFrame[3] = {};
    ada0:	6e 01       	movw	r12, r28
    ada2:	fd e0       	ldi	r31, 0x0D	; 13
    ada4:	cf 0e       	add	r12, r31
    ada6:	d1 1c       	adc	r13, r1
    ada8:	d6 01       	movw	r26, r12
    adaa:	1d 92       	st	X+, r1
    adac:	8a 95       	dec	r24
    adae:	e9 f7       	brne	.-6      	; 0xadaa <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x54>
		
	float velocityMatrix[3] = {(float)model->XVEcefCms(), (float)model->YVEcefCms(), (float)model->ZVEcefCms()};
    adb0:	f4 01       	movw	r30, r8
    adb2:	05 85       	ldd	r16, Z+13	; 0x0d
    adb4:	16 85       	ldd	r17, Z+14	; 0x0e
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    adb6:	f8 01       	movw	r30, r16
    adb8:	e6 5f       	subi	r30, 0xF6	; 246
    adba:	fe 4f       	sbci	r31, 0xFE	; 254
    adbc:	60 81       	ld	r22, Z
    adbe:	71 81       	ldd	r23, Z+1	; 0x01
    adc0:	82 81       	ldd	r24, Z+2	; 0x02
    adc2:	93 81       	ldd	r25, Z+3	; 0x03
    adc4:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    adc8:	69 83       	std	Y+1, r22	; 0x01
    adca:	7a 83       	std	Y+2, r23	; 0x02
    adcc:	8b 83       	std	Y+3, r24	; 0x03
    adce:	9c 83       	std	Y+4, r25	; 0x04
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    add0:	f8 01       	movw	r30, r16
    add2:	e2 5f       	subi	r30, 0xF2	; 242
    add4:	fe 4f       	sbci	r31, 0xFE	; 254
    add6:	60 81       	ld	r22, Z
    add8:	71 81       	ldd	r23, Z+1	; 0x01
    adda:	82 81       	ldd	r24, Z+2	; 0x02
    addc:	93 81       	ldd	r25, Z+3	; 0x03
    adde:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    ade2:	6d 83       	std	Y+5, r22	; 0x05
    ade4:	7e 83       	std	Y+6, r23	; 0x06
    ade6:	8f 83       	std	Y+7, r24	; 0x07
    ade8:	98 87       	std	Y+8, r25	; 0x08
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    adea:	f8 01       	movw	r30, r16
    adec:	ee 5e       	subi	r30, 0xEE	; 238
    adee:	fe 4f       	sbci	r31, 0xFE	; 254
    adf0:	60 81       	ld	r22, Z
    adf2:	71 81       	ldd	r23, Z+1	; 0x01
    adf4:	82 81       	ldd	r24, Z+2	; 0x02
    adf6:	93 81       	ldd	r25, Z+3	; 0x03
    adf8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    adfc:	69 87       	std	Y+9, r22	; 0x09
    adfe:	7a 87       	std	Y+10, r23	; 0x0a
    ae00:	8b 87       	std	Y+11, r24	; 0x0b
    ae02:	9c 87       	std	Y+12, r25	; 0x0c
	MatrixUtil::RotateMatrix(model->EcefToLocalNEDRotationMatrix,velocityMatrix,rotatedVelocityMatrix);
    ae04:	a7 01       	movw	r20, r14
    ae06:	be 01       	movw	r22, r28
    ae08:	6f 5f       	subi	r22, 0xFF	; 255
    ae0a:	7f 4f       	sbci	r23, 0xFF	; 255
    ae0c:	c8 01       	movw	r24, r16
    ae0e:	82 5e       	subi	r24, 0xE2	; 226
    ae10:	9e 4f       	sbci	r25, 0xFE	; 254
    ae12:	0e 94 3a 69 	call	0xd274	; 0xd274 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
			void AuxChannelValue(float val) {auxChannelValue = val;}

			AHRS* Ahrs() const {return ahrs;}
    ae16:	d4 01       	movw	r26, r8
    ae18:	1d 96       	adiw	r26, 0x0d	; 13
    ae1a:	ed 91       	ld	r30, X+
    ae1c:	fc 91       	ld	r31, X
    ae1e:	1e 97       	sbiw	r26, 0x0e	; 14
	/*
	MatrixUtil::CreateRotationMatrixTransposed(ahrs->getRollRads(), ahrs->getPitchRads(), ahrs->getYawRads(), nedToBodyFrameMatrix);
	MatrixUtil::RotateMatrix(nedToBodyFrameMatrix,rotatedVelocityMatrix, velocityBodyFrame);
	*/
	
	MatrixUtil::RotateMatrixT(model->Ahrs()->dcm,rotatedVelocityMatrix, velocityBodyFrame);	
    ae20:	80 81       	ld	r24, Z
    ae22:	91 81       	ldd	r25, Z+1	; 0x01
    ae24:	a6 01       	movw	r20, r12
    ae26:	b7 01       	movw	r22, r14
    ae28:	80 5c       	subi	r24, 0xC0	; 192
    ae2a:	9f 4f       	sbci	r25, 0xFF	; 255
    ae2c:	0e 94 57 68 	call	0xd0ae	; 0xd0ae <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>
	
	model->XVelocityFRDCms(velocityBodyFrame[0]);
    ae30:	d4 01       	movw	r26, r8
    ae32:	1d 96       	adiw	r26, 0x0d	; 13
    ae34:	ed 91       	ld	r30, X+
    ae36:	fc 91       	ld	r31, X
    ae38:	1e 97       	sbiw	r26, 0x0e	; 14

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
			void XVelocityFRDCms(float val) { xVelocityFRDCms = val;}
    ae3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    ae3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    ae3e:	af 85       	ldd	r26, Y+15	; 0x0f
    ae40:	b8 89       	ldd	r27, Y+16	; 0x10
    ae42:	82 ab       	std	Z+50, r24	; 0x32
    ae44:	93 ab       	std	Z+51, r25	; 0x33
    ae46:	a4 ab       	std	Z+52, r26	; 0x34
    ae48:	b5 ab       	std	Z+53, r27	; 0x35
	model->YVelocityFRDCms(velocityBodyFrame[1]);
    ae4a:	d4 01       	movw	r26, r8
    ae4c:	1d 96       	adiw	r26, 0x0d	; 13
    ae4e:	ed 91       	ld	r30, X+
    ae50:	fc 91       	ld	r31, X
    ae52:	1e 97       	sbiw	r26, 0x0e	; 14

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
			void YVelocityFRDCms(float val) { yVelocityFRDCms = val;}
    ae54:	e2 5a       	subi	r30, 0xA2	; 162
    ae56:	ff 4f       	sbci	r31, 0xFF	; 255
    ae58:	89 89       	ldd	r24, Y+17	; 0x11
    ae5a:	9a 89       	ldd	r25, Y+18	; 0x12
    ae5c:	ab 89       	ldd	r26, Y+19	; 0x13
    ae5e:	bc 89       	ldd	r27, Y+20	; 0x14
    ae60:	80 83       	st	Z, r24
    ae62:	91 83       	std	Z+1, r25	; 0x01
    ae64:	a2 83       	std	Z+2, r26	; 0x02
    ae66:	b3 83       	std	Z+3, r27	; 0x03
	

	
	
	if (model->HasNewPressureReading == true)
    ae68:	f4 01       	movw	r30, r8
    ae6a:	05 85       	ldd	r16, Z+13	; 0x0d
    ae6c:	16 85       	ldd	r17, Z+14	; 0x0e
    ae6e:	f8 01       	movw	r30, r16
    ae70:	ee 5b       	subi	r30, 0xBE	; 190
    ae72:	fe 4f       	sbci	r31, 0xFE	; 254
    ae74:	80 81       	ld	r24, Z
    ae76:	88 23       	and	r24, r24
    ae78:	09 f4       	brne	.+2      	; 0xae7c <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x126>
    ae7a:	77 c0       	rjmp	.+238    	; 0xaf6a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x214>
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    ae7c:	f8 01       	movw	r30, r16
    ae7e:	ea 5e       	subi	r30, 0xEA	; 234
    ae80:	fe 4f       	sbci	r31, 0xFE	; 254
		 * Multiply by -100 because in NED, 'down' is positive. And to convert meters to cm.
		 * -0.00000687535 = -6.8755856 * 10^-6
		 */
		//float altitudeMslCm = (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		//4433228.712 is a number I came up with from simplifying the expression (((pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1)/ (-0.00000687535)) / 3.28084) * -100.0f;
		float altitudeMslCm = (pow(10,log10(model->PressureMillibars()/1013.25) / 5.2558797) - 1) * 4433228.712; 
    ae82:	20 e0       	ldi	r18, 0x00	; 0
    ae84:	30 e5       	ldi	r19, 0x50	; 80
    ae86:	4d e7       	ldi	r20, 0x7D	; 125
    ae88:	54 e4       	ldi	r21, 0x44	; 68
    ae8a:	60 81       	ld	r22, Z
    ae8c:	71 81       	ldd	r23, Z+1	; 0x01
    ae8e:	82 81       	ldd	r24, Z+2	; 0x02
    ae90:	93 81       	ldd	r25, Z+3	; 0x03
    ae92:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    ae96:	0e 94 82 6d 	call	0xdb04	; 0xdb04 <log10>
    ae9a:	2b e2       	ldi	r18, 0x2B	; 43
    ae9c:	30 e3       	ldi	r19, 0x30	; 48
    ae9e:	48 ea       	ldi	r20, 0xA8	; 168
    aea0:	50 e4       	ldi	r21, 0x40	; 64
    aea2:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    aea6:	9b 01       	movw	r18, r22
    aea8:	ac 01       	movw	r20, r24
    aeaa:	60 e0       	ldi	r22, 0x00	; 0
    aeac:	70 e0       	ldi	r23, 0x00	; 0
    aeae:	80 e2       	ldi	r24, 0x20	; 32
    aeb0:	91 e4       	ldi	r25, 0x41	; 65
    aeb2:	0e 94 30 6e 	call	0xdc60	; 0xdc60 <pow>
    aeb6:	20 e0       	ldi	r18, 0x00	; 0
    aeb8:	30 e0       	ldi	r19, 0x00	; 0
    aeba:	40 e8       	ldi	r20, 0x80	; 128
    aebc:	5f e3       	ldi	r21, 0x3F	; 63
    aebe:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    aec2:	29 e9       	ldi	r18, 0x99	; 153
    aec4:	3a e4       	ldi	r19, 0x4A	; 74
    aec6:	47 e8       	ldi	r20, 0x87	; 135
    aec8:	5a e4       	ldi	r21, 0x4A	; 74
    aeca:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    aece:	c6 2e       	mov	r12, r22
    aed0:	d7 2e       	mov	r13, r23
    aed2:	e8 2e       	mov	r14, r24
    aed4:	f9 2e       	mov	r15, r25
		//bool hasGoodAltitude = true;
	
		//model->ZNEDLocalFrameCm((float) (altitudeMslCm - model->InitialAltitudeCm()));
	
	
		if (!isnanf(altitudeMslCm) && 
    aed6:	76 2f       	mov	r23, r22
    aed8:	27 2f       	mov	r18, r23
    aeda:	3d 2d       	mov	r19, r13
    aedc:	4e 2d       	mov	r20, r14
    aede:	5f 2d       	mov	r21, r15
    aee0:	6c 2d       	mov	r22, r12
    aee2:	7d 2d       	mov	r23, r13
    aee4:	8e 2d       	mov	r24, r14
    aee6:	9f 2d       	mov	r25, r15
    aee8:	0e 94 c7 6e 	call	0xdd8e	; 0xdd8e <__unordsf2>
    aeec:	81 11       	cpse	r24, r1
    aeee:	35 c0       	rjmp	.+106    	; 0xaf5a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
    aef0:	f8 01       	movw	r30, r16
    aef2:	e6 53       	subi	r30, 0x36	; 54
    aef4:	ff 4f       	sbci	r31, 0xFF	; 255
    aef6:	20 81       	ld	r18, Z
    aef8:	31 81       	ldd	r19, Z+1	; 0x01
    aefa:	42 81       	ldd	r20, Z+2	; 0x02
    aefc:	53 81       	ldd	r21, Z+3	; 0x03
    aefe:	6c 2d       	mov	r22, r12
    af00:	7d 2d       	mov	r23, r13
    af02:	8e 2d       	mov	r24, r14
    af04:	9f 2d       	mov	r25, r15
    af06:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    af0a:	26 2e       	mov	r2, r22
    af0c:	37 2e       	mov	r3, r23
    af0e:	e8 2e       	mov	r14, r24
    af10:	f9 2e       	mov	r15, r25
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    af12:	f8 01       	movw	r30, r16
    af14:	e2 58       	subi	r30, 0x82	; 130
    af16:	ff 4f       	sbci	r31, 0xFF	; 255
    af18:	40 80       	ld	r4, Z
    af1a:	51 80       	ldd	r5, Z+1	; 0x01
    af1c:	62 80       	ldd	r6, Z+2	; 0x02
    af1e:	73 80       	ldd	r7, Z+3	; 0x03
    af20:	a3 01       	movw	r20, r6
    af22:	92 01       	movw	r18, r4
    af24:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    af28:	a6 2e       	mov	r10, r22
    af2a:	b7 2e       	mov	r11, r23
    af2c:	c8 2e       	mov	r12, r24
    af2e:	d9 2e       	mov	r13, r25
    af30:	20 e0       	ldi	r18, 0x00	; 0
    af32:	30 e0       	ldi	r19, 0x00	; 0
    af34:	48 e4       	ldi	r20, 0x48	; 72
    af36:	54 e4       	ldi	r21, 0x44	; 68
    af38:	0e 94 48 6b 	call	0xd690	; 0xd690 <__cmpsf2>
    af3c:	88 23       	and	r24, r24
    af3e:	6c f4       	brge	.+26     	; 0xaf5a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
    af40:	20 e0       	ldi	r18, 0x00	; 0
    af42:	30 e0       	ldi	r19, 0x00	; 0
    af44:	48 e4       	ldi	r20, 0x48	; 72
    af46:	54 ec       	ldi	r21, 0xC4	; 196
    af48:	6a 2d       	mov	r22, r10
    af4a:	7b 2d       	mov	r23, r11
    af4c:	8c 2d       	mov	r24, r12
    af4e:	9d 2d       	mov	r25, r13
    af50:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__gesf2>
    af54:	18 16       	cp	r1, r24
    af56:	0c f4       	brge	.+2      	; 0xaf5a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
    af58:	93 c0       	rjmp	.+294    	; 0xb080 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x32a>
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
		}
					
		
		model->HasNewPressureReading = false;
    af5a:	d4 01       	movw	r26, r8
    af5c:	1d 96       	adiw	r26, 0x0d	; 13
    af5e:	ed 91       	ld	r30, X+
    af60:	fc 91       	ld	r31, X
    af62:	1e 97       	sbiw	r26, 0x0e	; 14
    af64:	ee 5b       	subi	r30, 0xBE	; 190
    af66:	fe 4f       	sbci	r31, 0xFE	; 254
    af68:	10 82       	st	Z, r1
	
				
	/**
	* Convert position to local NED
	*/
	float localNEDX = 0.0;
    af6a:	1d a6       	std	Y+45, r1	; 0x2d
    af6c:	1e a6       	std	Y+46, r1	; 0x2e
    af6e:	1f a6       	std	Y+47, r1	; 0x2f
    af70:	18 aa       	std	Y+48, r1	; 0x30
	float localNEDY = 0.0;
    af72:	19 a6       	std	Y+41, r1	; 0x29
    af74:	1a a6       	std	Y+42, r1	; 0x2a
    af76:	1b a6       	std	Y+43, r1	; 0x2b
    af78:	1c a6       	std	Y+44, r1	; 0x2c
	float localNEDZ = 0.0;
    af7a:	1d a2       	std	Y+37, r1	; 0x25
    af7c:	1e a2       	std	Y+38, r1	; 0x26
    af7e:	1f a2       	std	Y+39, r1	; 0x27
    af80:	18 a6       	std	Y+40, r1	; 0x28
	
	CoordinateUtil::ConvertFromECEFToLocalNED(model->InitialXPositionEcef(), model->InitialYPositionEcef(), model->InitialZPositionEcef(),
		model->XEcefCm(), model->YEcefCm(), model->ZEcefCm(), model->EcefToLocalNEDRotationMatrix,
		localNEDX, localNEDY, localNEDZ);
    af82:	f4 01       	movw	r30, r8
    af84:	05 85       	ldd	r16, Z+13	; 0x0d
    af86:	16 85       	ldd	r17, Z+14	; 0x0e
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    af88:	f8 01       	movw	r30, r16
    af8a:	e2 50       	subi	r30, 0x02	; 2
    af8c:	ff 4f       	sbci	r31, 0xFF	; 255
    af8e:	a0 80       	ld	r10, Z
    af90:	b1 80       	ldd	r11, Z+1	; 0x01
    af92:	c2 80       	ldd	r12, Z+2	; 0x02
    af94:	d3 80       	ldd	r13, Z+3	; 0x03
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
			void InitialYPositionEcef( long val ) { initialYPositionEcef = val;}

			long  InitialZPositionEcef() const {return initialZPositionEcef;}
    af96:	f8 01       	movw	r30, r16
    af98:	ea 53       	subi	r30, 0x3A	; 58
    af9a:	ff 4f       	sbci	r31, 0xFF	; 255
    af9c:	60 81       	ld	r22, Z
    af9e:	71 81       	ldd	r23, Z+1	; 0x01
    afa0:	82 81       	ldd	r24, Z+2	; 0x02
    afa2:	93 81       	ldd	r25, Z+3	; 0x03
    afa4:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    afa8:	69 ab       	std	Y+49, r22	; 0x31
    afaa:	7a ab       	std	Y+50, r23	; 0x32
    afac:	8b ab       	std	Y+51, r24	; 0x33
    afae:	9c ab       	std	Y+52, r25	; 0x34
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
			void InitialXPositionEcef( long val ) { initialXPositionEcef = val;}			

			long  InitialYPositionEcef() const {return initialYPositionEcef;}
    afb0:	f8 01       	movw	r30, r16
    afb2:	ee 53       	subi	r30, 0x3E	; 62
    afb4:	ff 4f       	sbci	r31, 0xFF	; 255
    afb6:	60 81       	ld	r22, Z
    afb8:	71 81       	ldd	r23, Z+1	; 0x01
    afba:	82 81       	ldd	r24, Z+2	; 0x02
    afbc:	93 81       	ldd	r25, Z+3	; 0x03
    afbe:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    afc2:	2b 01       	movw	r4, r22
    afc4:	3c 01       	movw	r6, r24
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				

			long  InitialXPositionEcef() const {return initialXPositionEcef;}
    afc6:	f8 01       	movw	r30, r16
    afc8:	e2 54       	subi	r30, 0x42	; 66
    afca:	ff 4f       	sbci	r31, 0xFF	; 255
    afcc:	60 81       	ld	r22, Z
    afce:	71 81       	ldd	r23, Z+1	; 0x01
    afd0:	82 81       	ldd	r24, Z+2	; 0x02
    afd2:	93 81       	ldd	r25, Z+3	; 0x03
    afd4:	0e 94 b7 6b 	call	0xd76e	; 0xd76e <__fixsfsi>
    afd8:	9e 01       	movw	r18, r28
    afda:	2b 5d       	subi	r18, 0xDB	; 219
    afdc:	3f 4f       	sbci	r19, 0xFF	; 255
    afde:	3f 93       	push	r19
    afe0:	2f 93       	push	r18
    afe2:	9e 01       	movw	r18, r28
    afe4:	27 5d       	subi	r18, 0xD7	; 215
    afe6:	3f 4f       	sbci	r19, 0xFF	; 255
    afe8:	3f 93       	push	r19
    afea:	2f 93       	push	r18
    afec:	9e 01       	movw	r18, r28
    afee:	23 5d       	subi	r18, 0xD3	; 211
    aff0:	3f 4f       	sbci	r19, 0xFF	; 255
    aff2:	3f 93       	push	r19
    aff4:	2f 93       	push	r18
    aff6:	98 01       	movw	r18, r16
    aff8:	22 5e       	subi	r18, 0xE2	; 226
    affa:	3e 4f       	sbci	r19, 0xFE	; 254
    affc:	3f 93       	push	r19
    affe:	2f 93       	push	r18
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    b000:	f8 01       	movw	r30, r16
    b002:	ea 5f       	subi	r30, 0xFA	; 250
    b004:	fe 4f       	sbci	r31, 0xFE	; 254
    b006:	23 81       	ldd	r18, Z+3	; 0x03
    b008:	2f 93       	push	r18
    b00a:	22 81       	ldd	r18, Z+2	; 0x02
    b00c:	2f 93       	push	r18
    b00e:	21 81       	ldd	r18, Z+1	; 0x01
    b010:	2f 93       	push	r18
    b012:	20 81       	ld	r18, Z
    b014:	2f 93       	push	r18
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    b016:	f8 01       	movw	r30, r16
    b018:	ee 5f       	subi	r30, 0xFE	; 254
    b01a:	fe 4f       	sbci	r31, 0xFE	; 254
    b01c:	23 81       	ldd	r18, Z+3	; 0x03
    b01e:	2f 93       	push	r18
    b020:	22 81       	ldd	r18, Z+2	; 0x02
    b022:	2f 93       	push	r18
    b024:	21 81       	ldd	r18, Z+1	; 0x01
    b026:	2f 93       	push	r18
    b028:	20 81       	ld	r18, Z
    b02a:	2f 93       	push	r18
    b02c:	e9 a8       	ldd	r14, Y+49	; 0x31
    b02e:	fa a8       	ldd	r15, Y+50	; 0x32
    b030:	0b a9       	ldd	r16, Y+51	; 0x33
    b032:	1c a9       	ldd	r17, Y+52	; 0x34
    b034:	a3 01       	movw	r20, r6
    b036:	92 01       	movw	r18, r4
    b038:	0e 94 48 65 	call	0xca90	; 0xca90 <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>
	
	model->XNEDLocalFrameCm(localNEDX);
    b03c:	d4 01       	movw	r26, r8
    b03e:	1d 96       	adiw	r26, 0x0d	; 13
    b040:	ed 91       	ld	r30, X+
    b042:	fc 91       	ld	r31, X
    b044:	1e 97       	sbiw	r26, 0x0e	; 14
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
    b046:	8d a5       	ldd	r24, Y+45	; 0x2d
    b048:	9e a5       	ldd	r25, Y+46	; 0x2e
    b04a:	af a5       	ldd	r26, Y+47	; 0x2f
    b04c:	b8 a9       	ldd	r27, Y+48	; 0x30
    b04e:	82 a3       	std	Z+34, r24	; 0x22
    b050:	93 a3       	std	Z+35, r25	; 0x23
    b052:	a4 a3       	std	Z+36, r26	; 0x24
    b054:	b5 a3       	std	Z+37, r27	; 0x25
	model->YNEDLocalFrameCm(localNEDY);
    b056:	d4 01       	movw	r26, r8
    b058:	1d 96       	adiw	r26, 0x0d	; 13
    b05a:	ed 91       	ld	r30, X+
    b05c:	fc 91       	ld	r31, X
    b05e:	1e 97       	sbiw	r26, 0x0e	; 14
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}
    b060:	e2 5b       	subi	r30, 0xB2	; 178
    b062:	ff 4f       	sbci	r31, 0xFF	; 255
    b064:	89 a5       	ldd	r24, Y+41	; 0x29
    b066:	9a a5       	ldd	r25, Y+42	; 0x2a
    b068:	ab a5       	ldd	r26, Y+43	; 0x2b
    b06a:	bc a5       	ldd	r27, Y+44	; 0x2c
    b06c:	80 83       	st	Z, r24
    b06e:	91 83       	std	Z+1, r25	; 0x01
    b070:	a2 83       	std	Z+2, r26	; 0x02
    b072:	b3 83       	std	Z+3, r27	; 0x03
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    b074:	0f b6       	in	r0, 0x3f	; 63
    b076:	f8 94       	cli
    b078:	de bf       	out	0x3e, r29	; 62
    b07a:	0f be       	out	0x3f, r0	; 63
    b07c:	cd bf       	out	0x3d, r28	; 61
    b07e:	42 c0       	rjmp	.+132    	; 0xb104 <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x3ae>
	
			//exponential smoothing. http://en.wikipedia.org/wiki/Exponential_smoothing
			//St = aX + (1-a)St-1
			float altitudeCmAglTemp = (float) (altitudeMslCm - model->InitialAltitudeCm());
			float previousAltitudeCmAgl = model->ZNEDLocalFrameCm();
			float currentAltitudeCmAgl = WEIGHT * (altitudeCmAglTemp) + (1 - WEIGHT)*previousAltitudeCmAgl;
    b080:	2a e9       	ldi	r18, 0x9A	; 154
    b082:	39 e9       	ldi	r19, 0x99	; 153
    b084:	49 e1       	ldi	r20, 0x19	; 25
    b086:	5e e3       	ldi	r21, 0x3E	; 62
    b088:	62 2d       	mov	r22, r2
    b08a:	73 2d       	mov	r23, r3
    b08c:	8e 2d       	mov	r24, r14
    b08e:	9f 2d       	mov	r25, r15
    b090:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    b094:	6b 01       	movw	r12, r22
    b096:	7c 01       	movw	r14, r24
    b098:	2a e9       	ldi	r18, 0x9A	; 154
    b09a:	39 e9       	ldi	r19, 0x99	; 153
    b09c:	49 e5       	ldi	r20, 0x59	; 89
    b09e:	5f e3       	ldi	r21, 0x3F	; 63
    b0a0:	c3 01       	movw	r24, r6
    b0a2:	b2 01       	movw	r22, r4
    b0a4:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    b0a8:	9b 01       	movw	r18, r22
    b0aa:	ac 01       	movw	r20, r24
    b0ac:	c7 01       	movw	r24, r14
    b0ae:	b6 01       	movw	r22, r12
    b0b0:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    b0b4:	c6 2e       	mov	r12, r22
    b0b6:	d7 2e       	mov	r13, r23
    b0b8:	e8 2e       	mov	r14, r24
    b0ba:	f9 2e       	mov	r15, r25

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
			void ZVelocityFRDCms(float val) { zVelocityMetersPerSecond = val;}
    b0bc:	02 57       	subi	r16, 0x72	; 114
    b0be:	1f 4f       	sbci	r17, 0xFF	; 255
			//model->AltitudeMetersAgl(currentAltitudeMetersAgl);
	
			//Calculate altitude speed.
			//model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) * BAROMETER_SENSOR_READ_PERIOD));
			model->ZVelocityFRDCms(((currentAltitudeCmAgl - previousAltitudeCmAgl) / barometerSensorReadPeriod));
    b0c0:	a3 01       	movw	r20, r6
    b0c2:	92 01       	movw	r18, r4
    b0c4:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    b0c8:	d4 01       	movw	r26, r8
    b0ca:	17 96       	adiw	r26, 0x07	; 7
    b0cc:	2d 91       	ld	r18, X+
    b0ce:	3d 91       	ld	r19, X+
    b0d0:	4d 91       	ld	r20, X+
    b0d2:	5c 91       	ld	r21, X
    b0d4:	1a 97       	sbiw	r26, 0x0a	; 10
    b0d6:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    b0da:	f8 01       	movw	r30, r16
    b0dc:	60 83       	st	Z, r22
    b0de:	71 83       	std	Z+1, r23	; 0x01
    b0e0:	82 83       	std	Z+2, r24	; 0x02
    b0e2:	93 83       	std	Z+3, r25	; 0x03
	
		
			model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
    b0e4:	d4 01       	movw	r26, r8
    b0e6:	1d 96       	adiw	r26, 0x0d	; 13
    b0e8:	ed 91       	ld	r30, X+
    b0ea:	fc 91       	ld	r31, X
    b0ec:	1e 97       	sbiw	r26, 0x0e	; 14
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }
    b0ee:	e2 58       	subi	r30, 0x82	; 130
    b0f0:	ff 4f       	sbci	r31, 0xFF	; 255
    b0f2:	8c 2d       	mov	r24, r12
    b0f4:	9d 2d       	mov	r25, r13
    b0f6:	ae 2d       	mov	r26, r14
    b0f8:	bf 2d       	mov	r27, r15
    b0fa:	80 83       	st	Z, r24
    b0fc:	91 83       	std	Z+1, r25	; 0x01
    b0fe:	a2 83       	std	Z+2, r26	; 0x02
    b100:	b3 83       	std	Z+3, r27	; 0x03
    b102:	2b cf       	rjmp	.-426    	; 0xaf5a <_ZN10helicopter5tasks16PVNavigationTask11runTaskImplEv+0x204>
	model->YNEDLocalFrameCm(localNEDY);
	//model->ZNEDLocalFrameCm(currentAltitudeCmAgl); //don't use localnedz as the z value because the altitude from barometer is more accurate
	
	
	
}
    b104:	e4 96       	adiw	r28, 0x34	; 52
    b106:	0f b6       	in	r0, 0x3f	; 63
    b108:	f8 94       	cli
    b10a:	de bf       	out	0x3e, r29	; 62
    b10c:	0f be       	out	0x3f, r0	; 63
    b10e:	cd bf       	out	0x3d, r28	; 61
    b110:	df 91       	pop	r29
    b112:	cf 91       	pop	r28
    b114:	1f 91       	pop	r17
    b116:	0f 91       	pop	r16
    b118:	ff 90       	pop	r15
    b11a:	ef 90       	pop	r14
    b11c:	df 90       	pop	r13
    b11e:	cf 90       	pop	r12
    b120:	bf 90       	pop	r11
    b122:	af 90       	pop	r10
    b124:	9f 90       	pop	r9
    b126:	8f 90       	pop	r8
    b128:	7f 90       	pop	r7
    b12a:	6f 90       	pop	r6
    b12c:	5f 90       	pop	r5
    b12e:	4f 90       	pop	r4
    b130:	3f 90       	pop	r3
    b132:	2f 90       	pop	r2
    b134:	08 95       	ret

0000b136 <_ZN10helicopter5tasks16PVNavigationTaskC1EfPNS_10navigation4AHRSEPNS_5model11SystemModelEii>:
using namespace helicopter::util;

const float PVNavigationTask::WEIGHT = .15;


PVNavigationTask::PVNavigationTask (float barometerSensorReadPeriod, AHRS *ahrs, SystemModel *model, int delay, int period) :
    b136:	4f 92       	push	r4
    b138:	5f 92       	push	r5
    b13a:	6f 92       	push	r6
    b13c:	7f 92       	push	r7
    b13e:	af 92       	push	r10
    b140:	bf 92       	push	r11
    b142:	cf 92       	push	r12
    b144:	df 92       	push	r13
    b146:	ef 92       	push	r14
    b148:	ff 92       	push	r15
    b14a:	0f 93       	push	r16
    b14c:	1f 93       	push	r17
    b14e:	cf 93       	push	r28
    b150:	df 93       	push	r29
    b152:	ec 01       	movw	r28, r24
    b154:	2a 01       	movw	r4, r20
    b156:	3b 01       	movw	r6, r22
    b158:	59 01       	movw	r10, r18
    b15a:	b7 01       	movw	r22, r14
    b15c:	a6 01       	movw	r20, r12
Task(delay, period),
barometerSensorReadPeriod(barometerSensorReadPeriod),
ahrs(ahrs),
model(model)
    b15e:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b162:	84 e1       	ldi	r24, 0x14	; 20
    b164:	93 e0       	ldi	r25, 0x03	; 3
    b166:	99 83       	std	Y+1, r25	; 0x01
    b168:	88 83       	st	Y, r24
    b16a:	4f 82       	std	Y+7, r4	; 0x07
    b16c:	58 86       	std	Y+8, r5	; 0x08
    b16e:	69 86       	std	Y+9, r6	; 0x09
    b170:	7a 86       	std	Y+10, r7	; 0x0a
    b172:	bc 86       	std	Y+12, r11	; 0x0c
    b174:	ab 86       	std	Y+11, r10	; 0x0b
    b176:	1e 87       	std	Y+14, r17	; 0x0e
    b178:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    b17a:	df 91       	pop	r29
    b17c:	cf 91       	pop	r28
    b17e:	1f 91       	pop	r17
    b180:	0f 91       	pop	r16
    b182:	ff 90       	pop	r15
    b184:	ef 90       	pop	r14
    b186:	df 90       	pop	r13
    b188:	cf 90       	pop	r12
    b18a:	bf 90       	pop	r11
    b18c:	af 90       	pop	r10
    b18e:	7f 90       	pop	r7
    b190:	6f 90       	pop	r6
    b192:	5f 90       	pop	r5
    b194:	4f 90       	pop	r4
    b196:	08 95       	ret

0000b198 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD1Ev>:
    b198:	26 e7       	ldi	r18, 0x76	; 118
    b19a:	33 e0       	ldi	r19, 0x03	; 3
    b19c:	fc 01       	movw	r30, r24
    b19e:	31 83       	std	Z+1, r19	; 0x01
    b1a0:	20 83       	st	Z, r18
    b1a2:	08 95       	ret

0000b1a4 <_ZN10helicopter5tasks23ReadBarometerSensorTaskD0Ev>:
    b1a4:	26 e7       	ldi	r18, 0x76	; 118
    b1a6:	33 e0       	ldi	r19, 0x03	; 3
    b1a8:	fc 01       	movw	r30, r24
    b1aa:	31 83       	std	Z+1, r19	; 0x01
    b1ac:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadBarometerSensorTask : public Task
    b1ae:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b1b2:	08 95       	ret

0000b1b4 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv>:
	
}


void ReadBarometerSensorTask::runTaskImpl()
{
    b1b4:	0f 93       	push	r16
    b1b6:	1f 93       	push	r17
    b1b8:	cf 93       	push	r28
    b1ba:	df 93       	push	r29
    b1bc:	ec 01       	movw	r28, r24
	//barometerSensor->readSensor();
	
	switch(step++)
    b1be:	8b 85       	ldd	r24, Y+11	; 0x0b
    b1c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    b1c2:	9c 01       	movw	r18, r24
    b1c4:	2f 5f       	subi	r18, 0xFF	; 255
    b1c6:	3f 4f       	sbci	r19, 0xFF	; 255
    b1c8:	3c 87       	std	Y+12, r19	; 0x0c
    b1ca:	2b 87       	std	Y+11, r18	; 0x0b
    b1cc:	81 30       	cpi	r24, 0x01	; 1
    b1ce:	91 05       	cpc	r25, r1
    b1d0:	51 f0       	breq	.+20     	; 0xb1e6 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x32>
    b1d2:	82 30       	cpi	r24, 0x02	; 2
    b1d4:	91 05       	cpc	r25, r1
    b1d6:	81 f0       	breq	.+32     	; 0xb1f8 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x44>
    b1d8:	89 2b       	or	r24, r25
    b1da:	d1 f5       	brne	.+116    	; 0xb250 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x9c>
	{
		
		case 0:
			barometerSensor->sendD1Command();
    b1dc:	89 85       	ldd	r24, Y+9	; 0x09
    b1de:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1e0:	0e 94 50 44 	call	0x88a0	; 0x88a0 <_ZN10helicopter7sensors15BarometerSensor13sendD1CommandEv>
		break;
    b1e4:	37 c0       	rjmp	.+110    	; 0xb254 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 1:
			barometerSensor->readD1Data();
    b1e6:	89 85       	ldd	r24, Y+9	; 0x09
    b1e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1ea:	0e 94 57 44 	call	0x88ae	; 0x88ae <_ZN10helicopter7sensors15BarometerSensor10readD1DataEv>
			barometerSensor->sendD2Command();
    b1ee:	89 85       	ldd	r24, Y+9	; 0x09
    b1f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1f2:	0e 94 98 44 	call	0x8930	; 0x8930 <_ZN10helicopter7sensors15BarometerSensor13sendD2CommandEv>
		break;
    b1f6:	2e c0       	rjmp	.+92     	; 0xb254 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		case 2:
			barometerSensor->readD2Data();
    b1f8:	89 85       	ldd	r24, Y+9	; 0x09
    b1fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    b1fc:	0e 94 9f 44 	call	0x893e	; 0x893e <_ZN10helicopter7sensors15BarometerSensor10readD2DataEv>
			barometerSensor->processBaroData();
    b200:	89 85       	ldd	r24, Y+9	; 0x09
    b202:	9a 85       	ldd	r25, Y+10	; 0x0a
    b204:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <_ZN10helicopter7sensors15BarometerSensor15processBaroDataEv>
			
			if (model->SensorInput() == SystemModel::RealSensors)
    b208:	ef 81       	ldd	r30, Y+7	; 0x07
    b20a:	f8 85       	ldd	r31, Y+8	; 0x08
    b20c:	84 81       	ldd	r24, Z+4	; 0x04
    b20e:	81 30       	cpi	r24, 0x01	; 1
    b210:	e1 f4       	brne	.+56     	; 0xb24a <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0x96>
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    b212:	8f 01       	movw	r16, r30
    b214:	0a 5e       	subi	r16, 0xEA	; 234
    b216:	1e 4f       	sbci	r17, 0xFE	; 254
					return temperatureCelcius;
				}
				
				long getPressureMillibars()
				{
					return pressureMillibars;
    b218:	e9 85       	ldd	r30, Y+9	; 0x09
    b21a:	fa 85       	ldd	r31, Y+10	; 0x0a
			{
				model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
    b21c:	66 85       	ldd	r22, Z+14	; 0x0e
    b21e:	77 85       	ldd	r23, Z+15	; 0x0f
    b220:	80 89       	ldd	r24, Z+16	; 0x10
    b222:	91 89       	ldd	r25, Z+17	; 0x11
    b224:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    b228:	20 e0       	ldi	r18, 0x00	; 0
    b22a:	30 e0       	ldi	r19, 0x00	; 0
    b22c:	48 ec       	ldi	r20, 0xC8	; 200
    b22e:	52 e4       	ldi	r21, 0x42	; 66
    b230:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    b234:	f8 01       	movw	r30, r16
    b236:	60 83       	st	Z, r22
    b238:	71 83       	std	Z+1, r23	; 0x01
    b23a:	82 83       	std	Z+2, r24	; 0x02
    b23c:	93 83       	std	Z+3, r25	; 0x03
				model->HasNewPressureReading = true;
    b23e:	ef 81       	ldd	r30, Y+7	; 0x07
    b240:	f8 85       	ldd	r31, Y+8	; 0x08
    b242:	ee 5b       	subi	r30, 0xBE	; 190
    b244:	fe 4f       	sbci	r31, 0xFE	; 254
    b246:	81 e0       	ldi	r24, 0x01	; 1
    b248:	80 83       	st	Z, r24
			}
			
			
			step = 0;
    b24a:	1c 86       	std	Y+12, r1	; 0x0c
    b24c:	1b 86       	std	Y+11, r1	; 0x0b
		break;
    b24e:	02 c0       	rjmp	.+4      	; 0xb254 <_ZN10helicopter5tasks23ReadBarometerSensorTask11runTaskImplEv+0xa0>
		default:
			step = 0;
    b250:	1c 86       	std	Y+12, r1	; 0x0c
    b252:	1b 86       	std	Y+11, r1	; 0x0b
		*/
	}
	
	
	//model->PressureMillibars(barometerSensor->getPressureMillibars() / 100.0f);
}
    b254:	df 91       	pop	r29
    b256:	cf 91       	pop	r28
    b258:	1f 91       	pop	r17
    b25a:	0f 91       	pop	r16
    b25c:	08 95       	ret

0000b25e <_ZN10helicopter5tasks23ReadBarometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors15BarometerSensorEii>:
 */ 
#include "ReadBarometerSensorTask.h"

using namespace helicopter::tasks;

ReadBarometerSensorTask::ReadBarometerSensorTask (SystemModel *model, BarometerSensor *barometerSensor, int delay, int period) :
    b25e:	cf 92       	push	r12
    b260:	df 92       	push	r13
    b262:	ef 92       	push	r14
    b264:	ff 92       	push	r15
    b266:	0f 93       	push	r16
    b268:	1f 93       	push	r17
    b26a:	cf 93       	push	r28
    b26c:	df 93       	push	r29
    b26e:	ec 01       	movw	r28, r24
    b270:	6b 01       	movw	r12, r22
    b272:	7a 01       	movw	r14, r20
    b274:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
barometerSensor(barometerSensor),
step(0)
    b276:	b9 01       	movw	r22, r18
    b278:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b27c:	82 e2       	ldi	r24, 0x22	; 34
    b27e:	93 e0       	ldi	r25, 0x03	; 3
    b280:	99 83       	std	Y+1, r25	; 0x01
    b282:	88 83       	st	Y, r24
    b284:	d8 86       	std	Y+8, r13	; 0x08
    b286:	cf 82       	std	Y+7, r12	; 0x07
    b288:	fa 86       	std	Y+10, r15	; 0x0a
    b28a:	e9 86       	std	Y+9, r14	; 0x09
    b28c:	1c 86       	std	Y+12, r1	; 0x0c
    b28e:	1b 86       	std	Y+11, r1	; 0x0b
{
	
}
    b290:	df 91       	pop	r29
    b292:	cf 91       	pop	r28
    b294:	1f 91       	pop	r17
    b296:	0f 91       	pop	r16
    b298:	ff 90       	pop	r15
    b29a:	ef 90       	pop	r14
    b29c:	df 90       	pop	r13
    b29e:	cf 90       	pop	r12
    b2a0:	08 95       	ret

0000b2a2 <_ZN10helicopter5tasks17ReadGPSSensorTaskD1Ev>:
    b2a2:	26 e7       	ldi	r18, 0x76	; 118
    b2a4:	33 e0       	ldi	r19, 0x03	; 3
    b2a6:	fc 01       	movw	r30, r24
    b2a8:	31 83       	std	Z+1, r19	; 0x01
    b2aa:	20 83       	st	Z, r18
    b2ac:	08 95       	ret

0000b2ae <_ZN10helicopter5tasks17ReadGPSSensorTaskD0Ev>:
    b2ae:	26 e7       	ldi	r18, 0x76	; 118
    b2b0:	33 e0       	ldi	r19, 0x03	; 3
    b2b2:	fc 01       	movw	r30, r24
    b2b4:	31 83       	std	Z+1, r19	; 0x01
    b2b6:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadGPSSensorTask : public Task
    b2b8:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b2bc:	08 95       	ret

0000b2be <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv>:
	
}


void ReadGPSSensorTask::runTaskImpl()
{
    b2be:	cf 93       	push	r28
    b2c0:	df 93       	push	r29
    b2c2:	ec 01       	movw	r28, r24
	
	int status = gpsSensor->processSensorSolution();
    b2c4:	89 85       	ldd	r24, Y+9	; 0x09
    b2c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    b2c8:	0e 94 54 49 	call	0x92a8	; 0x92a8 <_ZN10helicopter7sensors9GPSSensor21processSensorSolutionEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b2cc:	ef 81       	ldd	r30, Y+7	; 0x07
    b2ce:	f8 85       	ldd	r31, Y+8	; 0x08
    b2d0:	24 81       	ldd	r18, Z+4	; 0x04
    b2d2:	21 30       	cpi	r18, 0x01	; 1
    b2d4:	09 f0       	breq	.+2      	; 0xb2d8 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0x1a>
    b2d6:	65 c0       	rjmp	.+202    	; 0xb3a2 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
					return longitudeDegE7;
				}			
					
				long getXEcefCm()
				{
					return xEcefCm;
    b2d8:	a9 85       	ldd	r26, Y+9	; 0x09
    b2da:	ba 85       	ldd	r27, Y+10	; 0x0a
    b2dc:	1a 96       	adiw	r26, 0x0a	; 10
    b2de:	4d 91       	ld	r20, X+
    b2e0:	5d 91       	ld	r21, X+
    b2e2:	6d 91       	ld	r22, X+
    b2e4:	7c 91       	ld	r23, X
    b2e6:	1d 97       	sbiw	r26, 0x0d	; 13
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    b2e8:	e2 50       	subi	r30, 0x02	; 2
    b2ea:	ff 4f       	sbci	r31, 0xFF	; 255
    b2ec:	40 83       	st	Z, r20
    b2ee:	51 83       	std	Z+1, r21	; 0x01
    b2f0:	62 83       	std	Z+2, r22	; 0x02
    b2f2:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYEcefCm()
				{
					return yEcefCm;
    b2f4:	e9 85       	ldd	r30, Y+9	; 0x09
    b2f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    b2f8:	46 85       	ldd	r20, Z+14	; 0x0e
    b2fa:	57 85       	ldd	r21, Z+15	; 0x0f
    b2fc:	60 89       	ldd	r22, Z+16	; 0x10
    b2fe:	71 89       	ldd	r23, Z+17	; 0x11
	{
		model->XEcefCm(gpsSensor->getXEcefCm());
		model->YEcefCm(gpsSensor->getYEcefCm());
    b300:	ef 81       	ldd	r30, Y+7	; 0x07
    b302:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    b304:	ee 5f       	subi	r30, 0xFE	; 254
    b306:	fe 4f       	sbci	r31, 0xFE	; 254
    b308:	40 83       	st	Z, r20
    b30a:	51 83       	std	Z+1, r21	; 0x01
    b30c:	62 83       	std	Z+2, r22	; 0x02
    b30e:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZEcefCm()
				{
					return zEcefCm;
    b310:	e9 85       	ldd	r30, Y+9	; 0x09
    b312:	fa 85       	ldd	r31, Y+10	; 0x0a
    b314:	42 89       	ldd	r20, Z+18	; 0x12
    b316:	53 89       	ldd	r21, Z+19	; 0x13
    b318:	64 89       	ldd	r22, Z+20	; 0x14
    b31a:	75 89       	ldd	r23, Z+21	; 0x15
		model->ZEcefCm(gpsSensor->getZEcefCm());
    b31c:	ef 81       	ldd	r30, Y+7	; 0x07
    b31e:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    b320:	ea 5f       	subi	r30, 0xFA	; 250
    b322:	fe 4f       	sbci	r31, 0xFE	; 254
    b324:	40 83       	st	Z, r20
    b326:	51 83       	std	Z+1, r21	; 0x01
    b328:	62 83       	std	Z+2, r22	; 0x02
    b32a:	73 83       	std	Z+3, r23	; 0x03
				
				
				
				long getXVEcefCms()
				{
					return xVEcefCms;
    b32c:	e9 85       	ldd	r30, Y+9	; 0x09
    b32e:	fa 85       	ldd	r31, Y+10	; 0x0a
    b330:	42 8d       	ldd	r20, Z+26	; 0x1a
    b332:	53 8d       	ldd	r21, Z+27	; 0x1b
    b334:	64 8d       	ldd	r22, Z+28	; 0x1c
    b336:	75 8d       	ldd	r23, Z+29	; 0x1d
		
		model->XVEcefCms(gpsSensor->getXVEcefCms());
    b338:	ef 81       	ldd	r30, Y+7	; 0x07
    b33a:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    b33c:	e6 5f       	subi	r30, 0xF6	; 246
    b33e:	fe 4f       	sbci	r31, 0xFE	; 254
    b340:	40 83       	st	Z, r20
    b342:	51 83       	std	Z+1, r21	; 0x01
    b344:	62 83       	std	Z+2, r22	; 0x02
    b346:	73 83       	std	Z+3, r23	; 0x03
				}

				long getYVEcefCms()
				{
					return yVEcefCms;
    b348:	e9 85       	ldd	r30, Y+9	; 0x09
    b34a:	fa 85       	ldd	r31, Y+10	; 0x0a
    b34c:	46 8d       	ldd	r20, Z+30	; 0x1e
    b34e:	57 8d       	ldd	r21, Z+31	; 0x1f
    b350:	60 a1       	ldd	r22, Z+32	; 0x20
    b352:	71 a1       	ldd	r23, Z+33	; 0x21
		model->YVEcefCms(gpsSensor->getYVEcefCms());
    b354:	ef 81       	ldd	r30, Y+7	; 0x07
    b356:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    b358:	e2 5f       	subi	r30, 0xF2	; 242
    b35a:	fe 4f       	sbci	r31, 0xFE	; 254
    b35c:	40 83       	st	Z, r20
    b35e:	51 83       	std	Z+1, r21	; 0x01
    b360:	62 83       	std	Z+2, r22	; 0x02
    b362:	73 83       	std	Z+3, r23	; 0x03
				}
				
				long getZVEcefCms()
				{
					return zVEcefCms;
    b364:	e9 85       	ldd	r30, Y+9	; 0x09
    b366:	fa 85       	ldd	r31, Y+10	; 0x0a
    b368:	42 a1       	ldd	r20, Z+34	; 0x22
    b36a:	53 a1       	ldd	r21, Z+35	; 0x23
    b36c:	64 a1       	ldd	r22, Z+36	; 0x24
    b36e:	75 a1       	ldd	r23, Z+37	; 0x25
		model->ZVEcefCms(gpsSensor->getZVEcefCms());
    b370:	ef 81       	ldd	r30, Y+7	; 0x07
    b372:	f8 85       	ldd	r31, Y+8	; 0x08
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    b374:	ee 5e       	subi	r30, 0xEE	; 238
    b376:	fe 4f       	sbci	r31, 0xFE	; 254
    b378:	40 83       	st	Z, r20
    b37a:	51 83       	std	Z+1, r21	; 0x01
    b37c:	62 83       	std	Z+2, r22	; 0x02
    b37e:	73 83       	std	Z+3, r23	; 0x03
		
		if (status == -1)
    b380:	01 96       	adiw	r24, 0x01	; 1
    b382:	79 f4       	brne	.+30     	; 0xb3a2 <_ZN10helicopter5tasks17ReadGPSSensorTask11runTaskImplEv+0xe4>
		{
			model->ChecksumErrors(model->ChecksumErrors() + 1);
    b384:	ef 81       	ldd	r30, Y+7	; 0x07
    b386:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    b388:	ee 54       	subi	r30, 0x4E	; 78
    b38a:	ff 4f       	sbci	r31, 0xFF	; 255
    b38c:	80 81       	ld	r24, Z
    b38e:	91 81       	ldd	r25, Z+1	; 0x01
    b390:	a2 81       	ldd	r26, Z+2	; 0x02
    b392:	b3 81       	ldd	r27, Z+3	; 0x03
    b394:	01 96       	adiw	r24, 0x01	; 1
    b396:	a1 1d       	adc	r26, r1
    b398:	b1 1d       	adc	r27, r1
    b39a:	80 83       	st	Z, r24
    b39c:	91 83       	std	Z+1, r25	; 0x01
    b39e:	a2 83       	std	Z+2, r26	; 0x02
    b3a0:	b3 83       	std	Z+3, r27	; 0x03
	model->XVEcefCms(gpsSensor->getXVEcefCms());
	model->YVEcefCms(gpsSensor->getYVEcefCms());
	model->ZVEcefCms(gpsSensor->getZVEcefCms());
	*/
	
}
    b3a2:	df 91       	pop	r29
    b3a4:	cf 91       	pop	r28
    b3a6:	08 95       	ret

0000b3a8 <_ZN10helicopter5tasks17ReadGPSSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9GPSSensorEii>:
 */ 
#include "ReadGPSSensorTask.h"

using namespace helicopter::tasks;

ReadGPSSensorTask::ReadGPSSensorTask (SystemModel *model, GPSSensor *gpsSensor, int delay, int period) :
    b3a8:	cf 92       	push	r12
    b3aa:	df 92       	push	r13
    b3ac:	ef 92       	push	r14
    b3ae:	ff 92       	push	r15
    b3b0:	0f 93       	push	r16
    b3b2:	1f 93       	push	r17
    b3b4:	cf 93       	push	r28
    b3b6:	df 93       	push	r29
    b3b8:	ec 01       	movw	r28, r24
    b3ba:	6b 01       	movw	r12, r22
    b3bc:	7a 01       	movw	r14, r20
    b3be:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
gpsSensor(gpsSensor),
sendReadCommand(true)
    b3c0:	b9 01       	movw	r22, r18
    b3c2:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b3c6:	80 e3       	ldi	r24, 0x30	; 48
    b3c8:	93 e0       	ldi	r25, 0x03	; 3
    b3ca:	99 83       	std	Y+1, r25	; 0x01
    b3cc:	88 83       	st	Y, r24
    b3ce:	d8 86       	std	Y+8, r13	; 0x08
    b3d0:	cf 82       	std	Y+7, r12	; 0x07
    b3d2:	fa 86       	std	Y+10, r15	; 0x0a
    b3d4:	e9 86       	std	Y+9, r14	; 0x09
    b3d6:	81 e0       	ldi	r24, 0x01	; 1
    b3d8:	8b 87       	std	Y+11, r24	; 0x0b
{
	
}
    b3da:	df 91       	pop	r29
    b3dc:	cf 91       	pop	r28
    b3de:	1f 91       	pop	r17
    b3e0:	0f 91       	pop	r16
    b3e2:	ff 90       	pop	r15
    b3e4:	ef 90       	pop	r14
    b3e6:	df 90       	pop	r13
    b3e8:	cf 90       	pop	r12
    b3ea:	08 95       	ret

0000b3ec <_ZN10helicopter5tasks17ReadIMUSensorTaskD1Ev>:
    b3ec:	26 e7       	ldi	r18, 0x76	; 118
    b3ee:	33 e0       	ldi	r19, 0x03	; 3
    b3f0:	fc 01       	movw	r30, r24
    b3f2:	31 83       	std	Z+1, r19	; 0x01
    b3f4:	20 83       	st	Z, r18
    b3f6:	08 95       	ret

0000b3f8 <_ZN10helicopter5tasks17ReadIMUSensorTaskD0Ev>:
    b3f8:	26 e7       	ldi	r18, 0x76	; 118
    b3fa:	33 e0       	ldi	r19, 0x03	; 3
    b3fc:	fc 01       	movw	r30, r24
    b3fe:	31 83       	std	Z+1, r19	; 0x01
    b400:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadIMUSensorTask : public Task
    b402:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b406:	08 95       	ret

0000b408 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv>:
	
}


void ReadIMUSensorTask::runTaskImpl()
{
    b408:	cf 93       	push	r28
    b40a:	df 93       	push	r29
    b40c:	ec 01       	movw	r28, r24
	//Read the sensor values from the IMU Sensor.
	imuSensor->readSensor();
    b40e:	89 85       	ldd	r24, Y+9	; 0x09
    b410:	9a 85       	ldd	r25, Y+10	; 0x0a
    b412:	0e 94 b6 4c 	call	0x996c	; 0x996c <_ZN10helicopter7sensors9IMUSensor10readSensorEv>
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b416:	ef 81       	ldd	r30, Y+7	; 0x07
    b418:	f8 85       	ldd	r31, Y+8	; 0x08
    b41a:	84 81       	ldd	r24, Z+4	; 0x04
    b41c:	81 30       	cpi	r24, 0x01	; 1
    b41e:	09 f0       	breq	.+2      	; 0xb422 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0x1a>
    b420:	59 c0       	rjmp	.+178    	; 0xb4d4 <_ZN10helicopter5tasks17ReadIMUSensorTask11runTaskImplEv+0xcc>
				int getRawGyroZ() { return rawGyroZ;}					
				
				/**
				 * Returns the acceleration in meters per second per second in the X direction in Front (X) Right (Y) Down (Z) coordinate system
				 */
				float getFRDAccXMss() { return frdAccXMss;}
    b422:	a9 85       	ldd	r26, Y+9	; 0x09
    b424:	ba 85       	ldd	r27, Y+10	; 0x0a
    b426:	d2 96       	adiw	r26, 0x32	; 50
    b428:	8d 91       	ld	r24, X+
    b42a:	9d 91       	ld	r25, X+
    b42c:	0d 90       	ld	r0, X+
    b42e:	bc 91       	ld	r27, X
    b430:	a0 2d       	mov	r26, r0
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    b432:	ea 51       	subi	r30, 0x1A	; 26
    b434:	ff 4f       	sbci	r31, 0xFF	; 255
    b436:	80 83       	st	Z, r24
    b438:	91 83       	std	Z+1, r25	; 0x01
    b43a:	a2 83       	std	Z+2, r26	; 0x02
    b43c:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Y direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccYMss() { return frdAccYMss;}
    b43e:	e9 85       	ldd	r30, Y+9	; 0x09
    b440:	fa 85       	ldd	r31, Y+10	; 0x0a
    b442:	86 a9       	ldd	r24, Z+54	; 0x36
    b444:	97 a9       	ldd	r25, Z+55	; 0x37
    b446:	a0 ad       	ldd	r26, Z+56	; 0x38
    b448:	b1 ad       	ldd	r27, Z+57	; 0x39
	{
		model->XAccelFrdMss(imuSensor->getFRDAccXMss());
		model->YAccelFrdMss(imuSensor->getFRDAccYMss());
    b44a:	ef 81       	ldd	r30, Y+7	; 0x07
    b44c:	f8 85       	ldd	r31, Y+8	; 0x08

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    b44e:	e6 51       	subi	r30, 0x16	; 22
    b450:	ff 4f       	sbci	r31, 0xFF	; 255
    b452:	80 83       	st	Z, r24
    b454:	91 83       	std	Z+1, r25	; 0x01
    b456:	a2 83       	std	Z+2, r26	; 0x02
    b458:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the acceleration in meters per second per second in the Z direction in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDAccZMss() { return frdAccZMss;}
    b45a:	e9 85       	ldd	r30, Y+9	; 0x09
    b45c:	fa 85       	ldd	r31, Y+10	; 0x0a
    b45e:	82 ad       	ldd	r24, Z+58	; 0x3a
    b460:	93 ad       	ldd	r25, Z+59	; 0x3b
    b462:	a4 ad       	ldd	r26, Z+60	; 0x3c
    b464:	b5 ad       	ldd	r27, Z+61	; 0x3d
		model->ZAccelFrdMss(imuSensor->getFRDAccZMss());
    b466:	ef 81       	ldd	r30, Y+7	; 0x07
    b468:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    b46a:	e2 51       	subi	r30, 0x12	; 18
    b46c:	ff 4f       	sbci	r31, 0xFF	; 255
    b46e:	80 83       	st	Z, r24
    b470:	91 83       	std	Z+1, r25	; 0x01
    b472:	a2 83       	std	Z+2, r26	; 0x02
    b474:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the X axis in Front (X) Right (Y) Down (Z) coordinate system
				 */					
				float getFRDGyroXRs() { return frdGyroXRs;}
    b476:	e9 85       	ldd	r30, Y+9	; 0x09
    b478:	fa 85       	ldd	r31, Y+10	; 0x0a
    b47a:	fe 96       	adiw	r30, 0x3e	; 62
    b47c:	80 81       	ld	r24, Z
    b47e:	91 81       	ldd	r25, Z+1	; 0x01
    b480:	a2 81       	ldd	r26, Z+2	; 0x02
    b482:	b3 81       	ldd	r27, Z+3	; 0x03
		
		model->RollAngularVelocityRadsPerSecond(imuSensor->getFRDGyroXRs());
    b484:	ef 81       	ldd	r30, Y+7	; 0x07
    b486:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    b488:	e2 52       	subi	r30, 0x22	; 34
    b48a:	ff 4f       	sbci	r31, 0xFF	; 255
    b48c:	80 83       	st	Z, r24
    b48e:	91 83       	std	Z+1, r25	; 0x01
    b490:	a2 83       	std	Z+2, r26	; 0x02
    b492:	b3 83       	std	Z+3, r27	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Y axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroYRs() { return frdGyroYRs;}
    b494:	e9 85       	ldd	r30, Y+9	; 0x09
    b496:	fa 85       	ldd	r31, Y+10	; 0x0a
    b498:	ee 5b       	subi	r30, 0xBE	; 190
    b49a:	ff 4f       	sbci	r31, 0xFF	; 255
    b49c:	40 81       	ld	r20, Z
    b49e:	51 81       	ldd	r21, Z+1	; 0x01
    b4a0:	62 81       	ldd	r22, Z+2	; 0x02
    b4a2:	73 81       	ldd	r23, Z+3	; 0x03
		model->PitchAngularVelocityRadsPerSecond(imuSensor->getFRDGyroYRs());
    b4a4:	ef 81       	ldd	r30, Y+7	; 0x07
    b4a6:	f8 85       	ldd	r31, Y+8	; 0x08
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    b4a8:	e6 52       	subi	r30, 0x26	; 38
    b4aa:	ff 4f       	sbci	r31, 0xFF	; 255
    b4ac:	40 83       	st	Z, r20
    b4ae:	51 83       	std	Z+1, r21	; 0x01
    b4b0:	62 83       	std	Z+2, r22	; 0x02
    b4b2:	73 83       	std	Z+3, r23	; 0x03
					
				/**
				 * Returns the angular velocity in rads per second about the Z axis in Front (X) Right (Y) Down (Z) coordinate system
				 */							
				float getFRDGyroZRs() { return frdGyroZRs;}	
    b4b4:	e9 85       	ldd	r30, Y+9	; 0x09
    b4b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    b4b8:	ea 5b       	subi	r30, 0xBA	; 186
    b4ba:	ff 4f       	sbci	r31, 0xFF	; 255
    b4bc:	40 81       	ld	r20, Z
    b4be:	51 81       	ldd	r21, Z+1	; 0x01
    b4c0:	62 81       	ldd	r22, Z+2	; 0x02
    b4c2:	73 81       	ldd	r23, Z+3	; 0x03
		model->YawAngularVelocityRadsPerSecond(imuSensor->getFRDGyroZRs());		
    b4c4:	ef 81       	ldd	r30, Y+7	; 0x07
    b4c6:	f8 85       	ldd	r31, Y+8	; 0x08
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    b4c8:	ee 51       	subi	r30, 0x1E	; 30
    b4ca:	ff 4f       	sbci	r31, 0xFF	; 255
    b4cc:	40 83       	st	Z, r20
    b4ce:	51 83       	std	Z+1, r21	; 0x01
    b4d0:	62 83       	std	Z+2, r22	; 0x02
    b4d2:	73 83       	std	Z+3, r23	; 0x03
				
	}
}
    b4d4:	df 91       	pop	r29
    b4d6:	cf 91       	pop	r28
    b4d8:	08 95       	ret

0000b4da <_ZN10helicopter5tasks17ReadIMUSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors9IMUSensorEii>:
#include "ReadIMUSensorTask.h"

using namespace helicopter::tasks;

ReadIMUSensorTask::ReadIMUSensorTask (SystemModel *model, IMUSensor *imuSensor, int delay, int period) :
    b4da:	cf 92       	push	r12
    b4dc:	df 92       	push	r13
    b4de:	ef 92       	push	r14
    b4e0:	ff 92       	push	r15
    b4e2:	0f 93       	push	r16
    b4e4:	1f 93       	push	r17
    b4e6:	cf 93       	push	r28
    b4e8:	df 93       	push	r29
    b4ea:	ec 01       	movw	r28, r24
    b4ec:	6b 01       	movw	r12, r22
    b4ee:	7a 01       	movw	r14, r20
    b4f0:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
imuSensor(imuSensor)
    b4f2:	b9 01       	movw	r22, r18
    b4f4:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b4f8:	8e e3       	ldi	r24, 0x3E	; 62
    b4fa:	93 e0       	ldi	r25, 0x03	; 3
    b4fc:	99 83       	std	Y+1, r25	; 0x01
    b4fe:	88 83       	st	Y, r24
    b500:	d8 86       	std	Y+8, r13	; 0x08
    b502:	cf 82       	std	Y+7, r12	; 0x07
    b504:	fa 86       	std	Y+10, r15	; 0x0a
    b506:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b508:	df 91       	pop	r29
    b50a:	cf 91       	pop	r28
    b50c:	1f 91       	pop	r17
    b50e:	0f 91       	pop	r16
    b510:	ff 90       	pop	r15
    b512:	ef 90       	pop	r14
    b514:	df 90       	pop	r13
    b516:	cf 90       	pop	r12
    b518:	08 95       	ret

0000b51a <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD1Ev>:
    b51a:	26 e7       	ldi	r18, 0x76	; 118
    b51c:	33 e0       	ldi	r19, 0x03	; 3
    b51e:	fc 01       	movw	r30, r24
    b520:	31 83       	std	Z+1, r19	; 0x01
    b522:	20 83       	st	Z, r18
    b524:	08 95       	ret

0000b526 <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskD0Ev>:
    b526:	26 e7       	ldi	r18, 0x76	; 118
    b528:	33 e0       	ldi	r19, 0x03	; 3
    b52a:	fc 01       	movw	r30, r24
    b52c:	31 83       	std	Z+1, r19	; 0x01
    b52e:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ReadMagnetometerSensorTask : public Task
    b530:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b534:	08 95       	ret

0000b536 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv>:
	
}


void ReadMagnetometerSensorTask::runTaskImpl()
{
    b536:	cf 93       	push	r28
    b538:	df 93       	push	r29
    b53a:	ec 01       	movw	r28, r24


	if (magnetometerSensor->readSensor() != 0)
    b53c:	89 85       	ldd	r24, Y+9	; 0x09
    b53e:	9a 85       	ldd	r25, Y+10	; 0x0a
    b540:	0e 94 96 50 	call	0xa12c	; 0xa12c <_ZN10helicopter7sensors18MagnetometerSensor10readSensorEv>
    b544:	89 2b       	or	r24, r25
    b546:	81 f0       	breq	.+32     	; 0xb568 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x32>
	{
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    b548:	ef 81       	ldd	r30, Y+7	; 0x07
    b54a:	f8 85       	ldd	r31, Y+8	; 0x08
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    b54c:	ee 54       	subi	r30, 0x4E	; 78
    b54e:	ff 4f       	sbci	r31, 0xFF	; 255
    b550:	80 81       	ld	r24, Z
    b552:	91 81       	ldd	r25, Z+1	; 0x01
    b554:	a2 81       	ldd	r26, Z+2	; 0x02
    b556:	b3 81       	ldd	r27, Z+3	; 0x03
    b558:	01 96       	adiw	r24, 0x01	; 1
    b55a:	a1 1d       	adc	r26, r1
    b55c:	b1 1d       	adc	r27, r1
    b55e:	80 83       	st	Z, r24
    b560:	91 83       	std	Z+1, r25	; 0x01
    b562:	a2 83       	std	Z+2, r26	; 0x02
    b564:	b3 83       	std	Z+3, r27	; 0x03
    b566:	2f c0       	rjmp	.+94     	; 0xb5c6 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
		return;
	}
	
	if(model->SensorInput() == SystemModel::RealSensors)
    b568:	ef 81       	ldd	r30, Y+7	; 0x07
    b56a:	f8 85       	ldd	r31, Y+8	; 0x08
    b56c:	84 81       	ldd	r24, Z+4	; 0x04
    b56e:	81 30       	cpi	r24, 0x01	; 1
    b570:	51 f5       	brne	.+84     	; 0xb5c6 <_ZN10helicopter5tasks26ReadMagnetometerSensorTask11runTaskImplEv+0x90>
				 * Retrieves the X sensor reading converted so that
				 * it points out the front of the CPU
				 */				
				float getFRDX()
				{
					return frdMagX;
    b572:	a9 85       	ldd	r26, Y+9	; 0x09
    b574:	ba 85       	ldd	r27, Y+10	; 0x0a
    b576:	16 96       	adiw	r26, 0x06	; 6
    b578:	8d 91       	ld	r24, X+
    b57a:	9d 91       	ld	r25, X+
    b57c:	0d 90       	ld	r0, X+
    b57e:	bc 91       	ld	r27, X
    b580:	a0 2d       	mov	r26, r0
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    b582:	ee 50       	subi	r30, 0x0E	; 14
    b584:	ff 4f       	sbci	r31, 0xFF	; 255
    b586:	80 83       	st	Z, r24
    b588:	91 83       	std	Z+1, r25	; 0x01
    b58a:	a2 83       	std	Z+2, r26	; 0x02
    b58c:	b3 83       	std	Z+3, r27	; 0x03
				 * Retrieves the Y sensor reading converted so that
				 * it points out the right of the CPU
				 */	
				float getFRDY()
				{
					return frdMagY;
    b58e:	e9 85       	ldd	r30, Y+9	; 0x09
    b590:	fa 85       	ldd	r31, Y+10	; 0x0a
    b592:	82 85       	ldd	r24, Z+10	; 0x0a
    b594:	93 85       	ldd	r25, Z+11	; 0x0b
    b596:	a4 85       	ldd	r26, Z+12	; 0x0c
    b598:	b5 85       	ldd	r27, Z+13	; 0x0d
	{
		model->XMagFrd(magnetometerSensor->getFRDX());
		model->YMagFrd(magnetometerSensor->getFRDY());
    b59a:	ef 81       	ldd	r30, Y+7	; 0x07
    b59c:	f8 85       	ldd	r31, Y+8	; 0x08

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    b59e:	ea 50       	subi	r30, 0x0A	; 10
    b5a0:	ff 4f       	sbci	r31, 0xFF	; 255
    b5a2:	80 83       	st	Z, r24
    b5a4:	91 83       	std	Z+1, r25	; 0x01
    b5a6:	a2 83       	std	Z+2, r26	; 0x02
    b5a8:	b3 83       	std	Z+3, r27	; 0x03
				 * Retrieves the Z sensor reading converted so that
				 * it points down out of the CPU
				 */					
				float getFRDZ()
				{
					return frdMagZ;
    b5aa:	e9 85       	ldd	r30, Y+9	; 0x09
    b5ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    b5ae:	46 85       	ldd	r20, Z+14	; 0x0e
    b5b0:	57 85       	ldd	r21, Z+15	; 0x0f
    b5b2:	60 89       	ldd	r22, Z+16	; 0x10
    b5b4:	71 89       	ldd	r23, Z+17	; 0x11
		model->ZMagFrd(magnetometerSensor->getFRDZ());
    b5b6:	ef 81       	ldd	r30, Y+7	; 0x07
    b5b8:	f8 85       	ldd	r31, Y+8	; 0x08

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    b5ba:	e6 50       	subi	r30, 0x06	; 6
    b5bc:	ff 4f       	sbci	r31, 0xFF	; 255
    b5be:	40 83       	st	Z, r20
    b5c0:	51 83       	std	Z+1, r21	; 0x01
    b5c2:	62 83       	std	Z+2, r22	; 0x02
    b5c4:	73 83       	std	Z+3, r23	; 0x03
model->off3(magnetometerSensor->debug[2]);
*/

	}
	
}
    b5c6:	df 91       	pop	r29
    b5c8:	cf 91       	pop	r28
    b5ca:	08 95       	ret

0000b5cc <_ZN10helicopter5tasks26ReadMagnetometerSensorTaskC1EPNS_5model11SystemModelEPNS_7sensors18MagnetometerSensorEii>:
#include "ReadMagnetometerSensorTask.h"
#include <avr/io.h>

using namespace helicopter::tasks;

ReadMagnetometerSensorTask::ReadMagnetometerSensorTask (SystemModel *model, MagnetometerSensor *magnetometerSensor, int delay, int period) :
    b5cc:	cf 92       	push	r12
    b5ce:	df 92       	push	r13
    b5d0:	ef 92       	push	r14
    b5d2:	ff 92       	push	r15
    b5d4:	0f 93       	push	r16
    b5d6:	1f 93       	push	r17
    b5d8:	cf 93       	push	r28
    b5da:	df 93       	push	r29
    b5dc:	ec 01       	movw	r28, r24
    b5de:	6b 01       	movw	r12, r22
    b5e0:	7a 01       	movw	r14, r20
    b5e2:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
magnetometerSensor(magnetometerSensor)
    b5e4:	b9 01       	movw	r22, r18
    b5e6:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b5ea:	8c e4       	ldi	r24, 0x4C	; 76
    b5ec:	93 e0       	ldi	r25, 0x03	; 3
    b5ee:	99 83       	std	Y+1, r25	; 0x01
    b5f0:	88 83       	st	Y, r24
    b5f2:	d8 86       	std	Y+8, r13	; 0x08
    b5f4:	cf 82       	std	Y+7, r12	; 0x07
    b5f6:	fa 86       	std	Y+10, r15	; 0x0a
    b5f8:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b5fa:	df 91       	pop	r29
    b5fc:	cf 91       	pop	r28
    b5fe:	1f 91       	pop	r17
    b600:	0f 91       	pop	r16
    b602:	ff 90       	pop	r15
    b604:	ef 90       	pop	r14
    b606:	df 90       	pop	r13
    b608:	cf 90       	pop	r12
    b60a:	08 95       	ret

0000b60c <_ZN10helicopter5tasks16ServoControlTaskD1Ev>:
    b60c:	26 e7       	ldi	r18, 0x76	; 118
    b60e:	33 e0       	ldi	r19, 0x03	; 3
    b610:	fc 01       	movw	r30, r24
    b612:	31 83       	std	Z+1, r19	; 0x01
    b614:	20 83       	st	Z, r18
    b616:	08 95       	ret

0000b618 <_ZN10helicopter5tasks16ServoControlTaskD0Ev>:
    b618:	26 e7       	ldi	r18, 0x76	; 118
    b61a:	33 e0       	ldi	r19, 0x03	; 3
    b61c:	fc 01       	movw	r30, r24
    b61e:	31 83       	std	Z+1, r19	; 0x01
    b620:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class executes the outer loop of the PID controller
		 */
		class ServoControlTask : public Task
    b622:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b626:	08 95       	ret

0000b628 <_ZN10helicopter5tasks16ServoControlTask11runTaskImplEv>:
	
}


void ServoControlTask::runTaskImpl()
{
    b628:	8f 92       	push	r8
    b62a:	9f 92       	push	r9
    b62c:	af 92       	push	r10
    b62e:	bf 92       	push	r11
    b630:	cf 92       	push	r12
    b632:	df 92       	push	r13
    b634:	ef 92       	push	r14
    b636:	ff 92       	push	r15
    b638:	0f 93       	push	r16
    b63a:	1f 93       	push	r17

	radioControllerInterface->controlServos(model->LateralControl(), model->LongitudeControl(), model->MainRotorCollectiveControl(), model->YawControl(), model->AuxChannelValue());
    b63c:	dc 01       	movw	r26, r24
    b63e:	17 96       	adiw	r26, 0x07	; 7
    b640:	ed 91       	ld	r30, X+
    b642:	fc 91       	ld	r31, X
    b644:	18 97       	sbiw	r26, 0x08	; 8
    b646:	82 84       	ldd	r8, Z+10	; 0x0a
    b648:	93 84       	ldd	r9, Z+11	; 0x0b
    b64a:	a4 84       	ldd	r10, Z+12	; 0x0c
    b64c:	b5 84       	ldd	r11, Z+13	; 0x0d

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    b64e:	df 01       	movw	r26, r30
    b650:	aa 57       	subi	r26, 0x7A	; 122
    b652:	bf 4f       	sbci	r27, 0xFF	; 255
    b654:	cd 90       	ld	r12, X+
    b656:	dd 90       	ld	r13, X+
    b658:	ed 90       	ld	r14, X+
    b65a:	fc 90       	ld	r15, X
    b65c:	06 a5       	ldd	r16, Z+46	; 0x2e
    b65e:	17 a5       	ldd	r17, Z+47	; 0x2f
    b660:	20 a9       	ldd	r18, Z+48	; 0x30
    b662:	31 a9       	ldd	r19, Z+49	; 0x31
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    b664:	df 01       	movw	r26, r30
    b666:	a6 5a       	subi	r26, 0xA6	; 166
    b668:	bf 4f       	sbci	r27, 0xFF	; 255
    b66a:	4d 91       	ld	r20, X+
    b66c:	5d 91       	ld	r21, X+
    b66e:	6d 91       	ld	r22, X+
    b670:	7c 91       	ld	r23, X
			void PressureMillibars(float val) {pressureMillibars = val;}
								
			float InitialAltitudeCm() const {return initialAltitudeCm;}
			void InitialAltitudeCm(float val) {initialAltitudeCm = val;}		
															
			float AuxChannelValue() const {return auxChannelValue;}
    b672:	e6 5e       	subi	r30, 0xE6	; 230
    b674:	fe 4f       	sbci	r31, 0xFE	; 254
    b676:	a3 81       	ldd	r26, Z+3	; 0x03
    b678:	af 93       	push	r26
    b67a:	a2 81       	ldd	r26, Z+2	; 0x02
    b67c:	af 93       	push	r26
    b67e:	a1 81       	ldd	r26, Z+1	; 0x01
    b680:	af 93       	push	r26
    b682:	e0 81       	ld	r30, Z
    b684:	ef 93       	push	r30
    b686:	fc 01       	movw	r30, r24
    b688:	81 85       	ldd	r24, Z+9	; 0x09
    b68a:	92 85       	ldd	r25, Z+10	; 0x0a
    b68c:	0e 94 8b 21 	call	0x4316	; 0x4316 <_ZN10helicopter10interfaces24RadioControllerInterface13controlServosEfffff>
    b690:	0f 90       	pop	r0
    b692:	0f 90       	pop	r0
    b694:	0f 90       	pop	r0
    b696:	0f 90       	pop	r0
		
		
		
		
	}*/
}
    b698:	1f 91       	pop	r17
    b69a:	0f 91       	pop	r16
    b69c:	ff 90       	pop	r15
    b69e:	ef 90       	pop	r14
    b6a0:	df 90       	pop	r13
    b6a2:	cf 90       	pop	r12
    b6a4:	bf 90       	pop	r11
    b6a6:	af 90       	pop	r10
    b6a8:	9f 90       	pop	r9
    b6aa:	8f 90       	pop	r8
    b6ac:	08 95       	ret

0000b6ae <_ZN10helicopter5tasks16ServoControlTaskC1EPNS_5model11SystemModelEPNS_10interfaces24RadioControllerInterfaceEii>:
 */ 
#include "ServoControlTask.h"

using namespace helicopter::tasks;

ServoControlTask::ServoControlTask (SystemModel *model, RadioControllerInterface *radioControllerInterface,int delay, int period) :
    b6ae:	cf 92       	push	r12
    b6b0:	df 92       	push	r13
    b6b2:	ef 92       	push	r14
    b6b4:	ff 92       	push	r15
    b6b6:	0f 93       	push	r16
    b6b8:	1f 93       	push	r17
    b6ba:	cf 93       	push	r28
    b6bc:	df 93       	push	r29
    b6be:	ec 01       	movw	r28, r24
    b6c0:	6b 01       	movw	r12, r22
    b6c2:	7a 01       	movw	r14, r20
    b6c4:	a8 01       	movw	r20, r16
Task(delay, period),
model(model),
radioControllerInterface(radioControllerInterface)
    b6c6:	b9 01       	movw	r22, r18
    b6c8:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    b6cc:	8a e5       	ldi	r24, 0x5A	; 90
    b6ce:	93 e0       	ldi	r25, 0x03	; 3
    b6d0:	99 83       	std	Y+1, r25	; 0x01
    b6d2:	88 83       	st	Y, r24
    b6d4:	d8 86       	std	Y+8, r13	; 0x08
    b6d6:	cf 82       	std	Y+7, r12	; 0x07
    b6d8:	fa 86       	std	Y+10, r15	; 0x0a
    b6da:	e9 86       	std	Y+9, r14	; 0x09
{
	
}
    b6dc:	df 91       	pop	r29
    b6de:	cf 91       	pop	r28
    b6e0:	1f 91       	pop	r17
    b6e2:	0f 91       	pop	r16
    b6e4:	ff 90       	pop	r15
    b6e6:	ef 90       	pop	r14
    b6e8:	df 90       	pop	r13
    b6ea:	cf 90       	pop	r12
    b6ec:	08 95       	ret

0000b6ee <_ZN10helicopter5tasks16SimTelemetryTaskD1Ev>:
    b6ee:	26 e7       	ldi	r18, 0x76	; 118
    b6f0:	33 e0       	ldi	r19, 0x03	; 3
    b6f2:	fc 01       	movw	r30, r24
    b6f4:	31 83       	std	Z+1, r19	; 0x01
    b6f6:	20 83       	st	Z, r18
    b6f8:	08 95       	ret

0000b6fa <_ZN10helicopter5tasks16SimTelemetryTaskD0Ev>:
    b6fa:	26 e7       	ldi	r18, 0x76	; 118
    b6fc:	33 e0       	ldi	r19, 0x03	; 3
    b6fe:	fc 01       	movw	r30, r24
    b700:	31 83       	std	Z+1, r19	; 0x01
    b702:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * Task to receive simulator telemetry data from the ground control station.
		 */
		class SimTelemetryTask : public Task
    b704:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    b708:	08 95       	ret

0000b70a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv>:
//}
//


void SimTelemetryTask::runTaskImpl()
{
    b70a:	cf 92       	push	r12
    b70c:	df 92       	push	r13
    b70e:	ef 92       	push	r14
    b710:	ff 92       	push	r15
    b712:	0f 93       	push	r16
    b714:	1f 93       	push	r17
    b716:	cf 93       	push	r28
    b718:	df 93       	push	r29
    b71a:	cd b7       	in	r28, 0x3d	; 61
    b71c:	de b7       	in	r29, 0x3e	; 62
    b71e:	28 97       	sbiw	r28, 0x08	; 8
    b720:	0f b6       	in	r0, 0x3f	; 63
    b722:	f8 94       	cli
    b724:	de bf       	out	0x3e, r29	; 62
    b726:	0f be       	out	0x3f, r0	; 63
    b728:	cd bf       	out	0x3d, r28	; 61
    b72a:	8c 01       	movw	r16, r24
	int status = 0;

	//Use the radio interface to get the telemetry message from the simulator
	Message *message = NULL;
    b72c:	18 86       	std	Y+8, r1	; 0x08
    b72e:	1f 82       	std	Y+7, r1	; 0x07
		
	status = radioInterface->receive(message);
    b730:	be 01       	movw	r22, r28
    b732:	69 5f       	subi	r22, 0xF9	; 249
    b734:	7f 4f       	sbci	r23, 0xFF	; 255
    b736:	dc 01       	movw	r26, r24
    b738:	17 96       	adiw	r26, 0x07	; 7
    b73a:	8d 91       	ld	r24, X+
    b73c:	9c 91       	ld	r25, X
    b73e:	18 97       	sbiw	r26, 0x08	; 8
    b740:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <_ZN10helicopter10interfaces29GroundControlStationInterface7receiveERPNS_8messages7MessageE>
    b744:	7c 01       	movw	r14, r24
		
	if (status == 0 && message != NULL)
    b746:	00 97       	sbiw	r24, 0x00	; 0
    b748:	09 f0       	breq	.+2      	; 0xb74c <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x42>
    b74a:	40 c4       	rjmp	.+2176   	; 0xbfcc <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8c2>
    b74c:	cf 80       	ldd	r12, Y+7	; 0x07
    b74e:	d8 84       	ldd	r13, Y+8	; 0x08
    b750:	c1 14       	cp	r12, r1
    b752:	d1 04       	cpc	r13, r1
    b754:	09 f4       	brne	.+2      	; 0xb758 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4e>
    b756:	11 c4       	rjmp	.+2082   	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
				/**
				 * Returns the identifier of this message.
				 */
				byte getType()
				{
					return msgType;
    b758:	f6 01       	movw	r30, r12
    b75a:	82 81       	ldd	r24, Z+2	; 0x02
	{
		if (message->getType() == SystemTelemetryMessage::MessageType)
    b75c:	82 30       	cpi	r24, 0x02	; 2
    b75e:	09 f0       	breq	.+2      	; 0xb762 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x58>
    b760:	3f c1       	rjmp	.+638    	; 0xb9e0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2d6>
		{
			SystemTelemetryMessage *telemMsg = (SystemTelemetryMessage*) message;
				
			//Update the model using the new data received from the simulator.
			telemMsg->updateModelFromMessageFromSimulator(model);
    b762:	d8 01       	movw	r26, r16
    b764:	19 96       	adiw	r26, 0x09	; 9
    b766:	6d 91       	ld	r22, X+
    b768:	7c 91       	ld	r23, X
    b76a:	1a 97       	sbiw	r26, 0x0a	; 10
    b76c:	c6 01       	movw	r24, r12
    b76e:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <_ZN10helicopter8messages22SystemTelemetryMessage35updateModelFromMessageFromSimulatorEPNS_5model11SystemModelE>
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    b772:	f6 01       	movw	r30, r12
    b774:	85 89       	ldd	r24, Z+21	; 0x15
    b776:	96 89       	ldd	r25, Z+22	; 0x16
    b778:	a7 89       	ldd	r26, Z+23	; 0x17
    b77a:	b0 8d       	ldd	r27, Z+24	; 0x18
    b77c:	f8 01       	movw	r30, r16
    b77e:	23 85       	ldd	r18, Z+11	; 0x0b
    b780:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    b782:	f9 01       	movw	r30, r18
    b784:	82 83       	std	Z+2, r24	; 0x02
    b786:	93 83       	std	Z+3, r25	; 0x03
    b788:	a4 83       	std	Z+4, r26	; 0x04
    b78a:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    b78c:	f6 01       	movw	r30, r12
    b78e:	81 8d       	ldd	r24, Z+25	; 0x19
    b790:	92 8d       	ldd	r25, Z+26	; 0x1a
    b792:	a3 8d       	ldd	r26, Z+27	; 0x1b
    b794:	b4 8d       	ldd	r27, Z+28	; 0x1c
    b796:	f8 01       	movw	r30, r16
    b798:	23 85       	ldd	r18, Z+11	; 0x0b
    b79a:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    b79c:	f9 01       	movw	r30, r18
    b79e:	86 83       	std	Z+6, r24	; 0x06
    b7a0:	97 83       	std	Z+7, r25	; 0x07
    b7a2:	a0 87       	std	Z+8, r26	; 0x08
    b7a4:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    b7a6:	f6 01       	movw	r30, r12
    b7a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    b7aa:	96 8d       	ldd	r25, Z+30	; 0x1e
    b7ac:	a7 8d       	ldd	r26, Z+31	; 0x1f
    b7ae:	b0 a1       	ldd	r27, Z+32	; 0x20
    b7b0:	f8 01       	movw	r30, r16
    b7b2:	23 85       	ldd	r18, Z+11	; 0x0b
    b7b4:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    b7b6:	f9 01       	movw	r30, r18
    b7b8:	82 87       	std	Z+10, r24	; 0x0a
    b7ba:	93 87       	std	Z+11, r25	; 0x0b
    b7bc:	a4 87       	std	Z+12, r26	; 0x0c
    b7be:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    b7c0:	f6 01       	movw	r30, r12
    b7c2:	81 a1       	ldd	r24, Z+33	; 0x21
    b7c4:	92 a1       	ldd	r25, Z+34	; 0x22
    b7c6:	a3 a1       	ldd	r26, Z+35	; 0x23
    b7c8:	b4 a1       	ldd	r27, Z+36	; 0x24
    b7ca:	f8 01       	movw	r30, r16
    b7cc:	23 85       	ldd	r18, Z+11	; 0x0b
    b7ce:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    b7d0:	f9 01       	movw	r30, r18
    b7d2:	86 87       	std	Z+14, r24	; 0x0e
    b7d4:	97 87       	std	Z+15, r25	; 0x0f
    b7d6:	a0 8b       	std	Z+16, r26	; 0x10
    b7d8:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    b7da:	f6 01       	movw	r30, r12
    b7dc:	ef 5b       	subi	r30, 0xBF	; 191
    b7de:	ff 4f       	sbci	r31, 0xFF	; 255
    b7e0:	80 81       	ld	r24, Z
    b7e2:	91 81       	ldd	r25, Z+1	; 0x01
    b7e4:	a2 81       	ldd	r26, Z+2	; 0x02
    b7e6:	b3 81       	ldd	r27, Z+3	; 0x03
    b7e8:	f8 01       	movw	r30, r16
    b7ea:	23 85       	ldd	r18, Z+11	; 0x0b
    b7ec:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    b7ee:	f9 01       	movw	r30, r18
    b7f0:	82 8b       	std	Z+18, r24	; 0x12
    b7f2:	93 8b       	std	Z+19, r25	; 0x13
    b7f4:	a4 8b       	std	Z+20, r26	; 0x14
    b7f6:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    b7f8:	f6 01       	movw	r30, r12
    b7fa:	eb 5b       	subi	r30, 0xBB	; 187
    b7fc:	ff 4f       	sbci	r31, 0xFF	; 255
    b7fe:	80 81       	ld	r24, Z
    b800:	91 81       	ldd	r25, Z+1	; 0x01
    b802:	a2 81       	ldd	r26, Z+2	; 0x02
    b804:	b3 81       	ldd	r27, Z+3	; 0x03
    b806:	f8 01       	movw	r30, r16
    b808:	23 85       	ldd	r18, Z+11	; 0x0b
    b80a:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    b80c:	f9 01       	movw	r30, r18
    b80e:	86 8b       	std	Z+22, r24	; 0x16
    b810:	97 8b       	std	Z+23, r25	; 0x17
    b812:	a0 8f       	std	Z+24, r26	; 0x18
    b814:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    b816:	f6 01       	movw	r30, r12
    b818:	e7 5b       	subi	r30, 0xB7	; 183
    b81a:	ff 4f       	sbci	r31, 0xFF	; 255
    b81c:	80 81       	ld	r24, Z
    b81e:	91 81       	ldd	r25, Z+1	; 0x01
    b820:	a2 81       	ldd	r26, Z+2	; 0x02
    b822:	b3 81       	ldd	r27, Z+3	; 0x03
    b824:	f8 01       	movw	r30, r16
    b826:	23 85       	ldd	r18, Z+11	; 0x0b
    b828:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    b82a:	f9 01       	movw	r30, r18
    b82c:	82 8f       	std	Z+26, r24	; 0x1a
    b82e:	93 8f       	std	Z+27, r25	; 0x1b
    b830:	a4 8f       	std	Z+28, r26	; 0x1c
    b832:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    b834:	f6 01       	movw	r30, r12
    b836:	e3 5b       	subi	r30, 0xB3	; 179
    b838:	ff 4f       	sbci	r31, 0xFF	; 255
    b83a:	80 81       	ld	r24, Z
    b83c:	91 81       	ldd	r25, Z+1	; 0x01
    b83e:	a2 81       	ldd	r26, Z+2	; 0x02
    b840:	b3 81       	ldd	r27, Z+3	; 0x03
    b842:	f8 01       	movw	r30, r16
    b844:	23 85       	ldd	r18, Z+11	; 0x0b
    b846:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    b848:	f9 01       	movw	r30, r18
    b84a:	86 8f       	std	Z+30, r24	; 0x1e
    b84c:	97 8f       	std	Z+31, r25	; 0x1f
    b84e:	a0 a3       	std	Z+32, r26	; 0x20
    b850:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    b852:	f6 01       	movw	r30, r12
    b854:	ef 5a       	subi	r30, 0xAF	; 175
    b856:	ff 4f       	sbci	r31, 0xFF	; 255
    b858:	80 81       	ld	r24, Z
    b85a:	91 81       	ldd	r25, Z+1	; 0x01
    b85c:	a2 81       	ldd	r26, Z+2	; 0x02
    b85e:	b3 81       	ldd	r27, Z+3	; 0x03
    b860:	f8 01       	movw	r30, r16
    b862:	23 85       	ldd	r18, Z+11	; 0x0b
    b864:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    b866:	f9 01       	movw	r30, r18
    b868:	82 a3       	std	Z+34, r24	; 0x22
    b86a:	93 a3       	std	Z+35, r25	; 0x23
    b86c:	a4 a3       	std	Z+36, r26	; 0x24
    b86e:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    b870:	f6 01       	movw	r30, r12
    b872:	e7 5a       	subi	r30, 0xA7	; 167
    b874:	ff 4f       	sbci	r31, 0xFF	; 255
    b876:	80 81       	ld	r24, Z
    b878:	91 81       	ldd	r25, Z+1	; 0x01
    b87a:	a2 81       	ldd	r26, Z+2	; 0x02
    b87c:	b3 81       	ldd	r27, Z+3	; 0x03
    b87e:	f8 01       	movw	r30, r16
    b880:	23 85       	ldd	r18, Z+11	; 0x0b
    b882:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    b884:	f9 01       	movw	r30, r18
    b886:	86 a3       	std	Z+38, r24	; 0x26
    b888:	97 a3       	std	Z+39, r25	; 0x27
    b88a:	a0 a7       	std	Z+40, r26	; 0x28
    b88c:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    b88e:	f6 01       	movw	r30, r12
    b890:	e7 58       	subi	r30, 0x87	; 135
    b892:	ff 4f       	sbci	r31, 0xFF	; 255
    b894:	80 81       	ld	r24, Z
    b896:	91 81       	ldd	r25, Z+1	; 0x01
    b898:	a2 81       	ldd	r26, Z+2	; 0x02
    b89a:	b3 81       	ldd	r27, Z+3	; 0x03
    b89c:	f8 01       	movw	r30, r16
    b89e:	23 85       	ldd	r18, Z+11	; 0x0b
    b8a0:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    b8a2:	f9 01       	movw	r30, r18
    b8a4:	82 a7       	std	Z+42, r24	; 0x2a
    b8a6:	93 a7       	std	Z+43, r25	; 0x2b
    b8a8:	a4 a7       	std	Z+44, r26	; 0x2c
    b8aa:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    b8ac:	f6 01       	movw	r30, r12
    b8ae:	e3 58       	subi	r30, 0x83	; 131
    b8b0:	ff 4f       	sbci	r31, 0xFF	; 255
    b8b2:	80 81       	ld	r24, Z
    b8b4:	91 81       	ldd	r25, Z+1	; 0x01
    b8b6:	a2 81       	ldd	r26, Z+2	; 0x02
    b8b8:	b3 81       	ldd	r27, Z+3	; 0x03
    b8ba:	f8 01       	movw	r30, r16
    b8bc:	23 85       	ldd	r18, Z+11	; 0x0b
    b8be:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    b8c0:	f9 01       	movw	r30, r18
    b8c2:	86 a7       	std	Z+46, r24	; 0x2e
    b8c4:	97 a7       	std	Z+47, r25	; 0x2f
    b8c6:	a0 ab       	std	Z+48, r26	; 0x30
    b8c8:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    b8ca:	f6 01       	movw	r30, r12
    b8cc:	ef 57       	subi	r30, 0x7F	; 127
    b8ce:	ff 4f       	sbci	r31, 0xFF	; 255
    b8d0:	80 81       	ld	r24, Z
    b8d2:	91 81       	ldd	r25, Z+1	; 0x01
    b8d4:	a2 81       	ldd	r26, Z+2	; 0x02
    b8d6:	b3 81       	ldd	r27, Z+3	; 0x03
    b8d8:	f8 01       	movw	r30, r16
    b8da:	23 85       	ldd	r18, Z+11	; 0x0b
    b8dc:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    b8de:	f9 01       	movw	r30, r18
    b8e0:	82 ab       	std	Z+50, r24	; 0x32
    b8e2:	93 ab       	std	Z+51, r25	; 0x33
    b8e4:	a4 ab       	std	Z+52, r26	; 0x34
    b8e6:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    b8e8:	f6 01       	movw	r30, r12
    b8ea:	eb 57       	subi	r30, 0x7B	; 123
    b8ec:	ff 4f       	sbci	r31, 0xFF	; 255
    b8ee:	80 81       	ld	r24, Z
    b8f0:	91 81       	ldd	r25, Z+1	; 0x01
    b8f2:	a2 81       	ldd	r26, Z+2	; 0x02
    b8f4:	b3 81       	ldd	r27, Z+3	; 0x03
    b8f6:	f8 01       	movw	r30, r16
    b8f8:	23 85       	ldd	r18, Z+11	; 0x0b
    b8fa:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    b8fc:	f9 01       	movw	r30, r18
    b8fe:	86 ab       	std	Z+54, r24	; 0x36
    b900:	97 ab       	std	Z+55, r25	; 0x37
    b902:	a0 af       	std	Z+56, r26	; 0x38
    b904:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    b906:	f6 01       	movw	r30, r12
    b908:	e7 57       	subi	r30, 0x77	; 119
    b90a:	ff 4f       	sbci	r31, 0xFF	; 255
    b90c:	80 81       	ld	r24, Z
    b90e:	91 81       	ldd	r25, Z+1	; 0x01
    b910:	a2 81       	ldd	r26, Z+2	; 0x02
    b912:	b3 81       	ldd	r27, Z+3	; 0x03
    b914:	f8 01       	movw	r30, r16
    b916:	23 85       	ldd	r18, Z+11	; 0x0b
    b918:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    b91a:	f9 01       	movw	r30, r18
    b91c:	82 af       	std	Z+58, r24	; 0x3a
    b91e:	93 af       	std	Z+59, r25	; 0x3b
    b920:	a4 af       	std	Z+60, r26	; 0x3c
    b922:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    b924:	f6 01       	movw	r30, r12
    b926:	ef 56       	subi	r30, 0x6F	; 111
    b928:	ff 4f       	sbci	r31, 0xFF	; 255
    b92a:	80 81       	ld	r24, Z
    b92c:	91 81       	ldd	r25, Z+1	; 0x01
    b92e:	a2 81       	ldd	r26, Z+2	; 0x02
    b930:	b3 81       	ldd	r27, Z+3	; 0x03
    b932:	f8 01       	movw	r30, r16
    b934:	23 85       	ldd	r18, Z+11	; 0x0b
    b936:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    b938:	f9 01       	movw	r30, r18
    b93a:	fe 96       	adiw	r30, 0x3e	; 62
    b93c:	80 83       	st	Z, r24
    b93e:	91 83       	std	Z+1, r25	; 0x01
    b940:	a2 83       	std	Z+2, r26	; 0x02
    b942:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    b944:	f6 01       	movw	r30, r12
    b946:	ef 54       	subi	r30, 0x4F	; 79
    b948:	ff 4f       	sbci	r31, 0xFF	; 255
    b94a:	80 81       	ld	r24, Z
    b94c:	91 81       	ldd	r25, Z+1	; 0x01
    b94e:	a2 81       	ldd	r26, Z+2	; 0x02
    b950:	b3 81       	ldd	r27, Z+3	; 0x03
    b952:	f8 01       	movw	r30, r16
    b954:	23 85       	ldd	r18, Z+11	; 0x0b
    b956:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    b958:	f9 01       	movw	r30, r18
    b95a:	ee 5b       	subi	r30, 0xBE	; 190
    b95c:	ff 4f       	sbci	r31, 0xFF	; 255
    b95e:	80 83       	st	Z, r24
    b960:	91 83       	std	Z+1, r25	; 0x01
    b962:	a2 83       	std	Z+2, r26	; 0x02
    b964:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    b966:	f6 01       	movw	r30, r12
    b968:	eb 54       	subi	r30, 0x4B	; 75
    b96a:	ff 4f       	sbci	r31, 0xFF	; 255
    b96c:	80 81       	ld	r24, Z
    b96e:	91 81       	ldd	r25, Z+1	; 0x01
    b970:	a2 81       	ldd	r26, Z+2	; 0x02
    b972:	b3 81       	ldd	r27, Z+3	; 0x03
    b974:	f8 01       	movw	r30, r16
    b976:	23 85       	ldd	r18, Z+11	; 0x0b
    b978:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    b97a:	f9 01       	movw	r30, r18
    b97c:	ea 5b       	subi	r30, 0xBA	; 186
    b97e:	ff 4f       	sbci	r31, 0xFF	; 255
    b980:	80 83       	st	Z, r24
    b982:	91 83       	std	Z+1, r25	; 0x01
    b984:	a2 83       	std	Z+2, r26	; 0x02
    b986:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    b988:	f6 01       	movw	r30, r12
    b98a:	e7 54       	subi	r30, 0x47	; 71
    b98c:	ff 4f       	sbci	r31, 0xFF	; 255
    b98e:	80 81       	ld	r24, Z
    b990:	91 81       	ldd	r25, Z+1	; 0x01
    b992:	a2 81       	ldd	r26, Z+2	; 0x02
    b994:	b3 81       	ldd	r27, Z+3	; 0x03
    b996:	f8 01       	movw	r30, r16
    b998:	23 85       	ldd	r18, Z+11	; 0x0b
    b99a:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    b99c:	f9 01       	movw	r30, r18
    b99e:	e6 5b       	subi	r30, 0xB6	; 182
    b9a0:	ff 4f       	sbci	r31, 0xFF	; 255
    b9a2:	80 83       	st	Z, r24
    b9a4:	91 83       	std	Z+1, r25	; 0x01
    b9a6:	a2 83       	std	Z+2, r26	; 0x02
    b9a8:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    b9aa:	f6 01       	movw	r30, r12
    b9ac:	e3 54       	subi	r30, 0x43	; 67
    b9ae:	ff 4f       	sbci	r31, 0xFF	; 255
    b9b0:	80 81       	ld	r24, Z
    b9b2:	91 81       	ldd	r25, Z+1	; 0x01
    b9b4:	a2 81       	ldd	r26, Z+2	; 0x02
    b9b6:	b3 81       	ldd	r27, Z+3	; 0x03
    b9b8:	f8 01       	movw	r30, r16
    b9ba:	23 85       	ldd	r18, Z+11	; 0x0b
    b9bc:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    b9be:	f9 01       	movw	r30, r18
    b9c0:	e2 5b       	subi	r30, 0xB2	; 178
    b9c2:	ff 4f       	sbci	r31, 0xFF	; 255
    b9c4:	80 83       	st	Z, r24
    b9c6:	91 83       	std	Z+1, r25	; 0x01
    b9c8:	a2 83       	std	Z+2, r26	; 0x02
    b9ca:	b3 83       	std	Z+3, r27	; 0x03
			
			model->HasNewPressureReading = true;
    b9cc:	d8 01       	movw	r26, r16
    b9ce:	19 96       	adiw	r26, 0x09	; 9
    b9d0:	ed 91       	ld	r30, X+
    b9d2:	fc 91       	ld	r31, X
    b9d4:	1a 97       	sbiw	r26, 0x0a	; 10
    b9d6:	ee 5b       	subi	r30, 0xBE	; 190
    b9d8:	fe 4f       	sbci	r31, 0xFE	; 254
    b9da:	81 e0       	ldi	r24, 0x01	; 1
    b9dc:	80 83       	st	Z, r24
    b9de:	5b c2       	rjmp	.+1206   	; 0xbe96 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
		}else if (message->getType() == SensorDataMessage::MessageType)
    b9e0:	84 30       	cpi	r24, 0x04	; 4
    b9e2:	09 f0       	breq	.+2      	; 0xb9e6 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x2dc>
    b9e4:	fd c0       	rjmp	.+506    	; 0xbbe0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4d6>
		{
			SensorDataMessage *sensorMsg = (SensorDataMessage*) message;
			model->XAccelFrdMss(sensorMsg->XAccelFrdMss);
    b9e6:	f6 01       	movw	r30, r12
    b9e8:	85 81       	ldd	r24, Z+5	; 0x05
    b9ea:	96 81       	ldd	r25, Z+6	; 0x06
    b9ec:	a7 81       	ldd	r26, Z+7	; 0x07
    b9ee:	b0 85       	ldd	r27, Z+8	; 0x08
    b9f0:	f8 01       	movw	r30, r16
    b9f2:	21 85       	ldd	r18, Z+9	; 0x09
    b9f4:	32 85       	ldd	r19, Z+10	; 0x0a
			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}
    b9f6:	f9 01       	movw	r30, r18
    b9f8:	ea 51       	subi	r30, 0x1A	; 26
    b9fa:	ff 4f       	sbci	r31, 0xFF	; 255
    b9fc:	80 83       	st	Z, r24
    b9fe:	91 83       	std	Z+1, r25	; 0x01
    ba00:	a2 83       	std	Z+2, r26	; 0x02
    ba02:	b3 83       	std	Z+3, r27	; 0x03
			model->YAccelFrdMss(sensorMsg->YAccelFrdMss);
    ba04:	f6 01       	movw	r30, r12
    ba06:	81 85       	ldd	r24, Z+9	; 0x09
    ba08:	92 85       	ldd	r25, Z+10	; 0x0a
    ba0a:	a3 85       	ldd	r26, Z+11	; 0x0b
    ba0c:	b4 85       	ldd	r27, Z+12	; 0x0c
    ba0e:	f8 01       	movw	r30, r16
    ba10:	21 85       	ldd	r18, Z+9	; 0x09
    ba12:	32 85       	ldd	r19, Z+10	; 0x0a

			float YAccelFrdMss() const {return yAccelFrdMss;}
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
    ba14:	f9 01       	movw	r30, r18
    ba16:	e6 51       	subi	r30, 0x16	; 22
    ba18:	ff 4f       	sbci	r31, 0xFF	; 255
    ba1a:	80 83       	st	Z, r24
    ba1c:	91 83       	std	Z+1, r25	; 0x01
    ba1e:	a2 83       	std	Z+2, r26	; 0x02
    ba20:	b3 83       	std	Z+3, r27	; 0x03
			model->ZAccelFrdMss(sensorMsg->ZAccelFrdMss);
    ba22:	f6 01       	movw	r30, r12
    ba24:	85 85       	ldd	r24, Z+13	; 0x0d
    ba26:	96 85       	ldd	r25, Z+14	; 0x0e
    ba28:	a7 85       	ldd	r26, Z+15	; 0x0f
    ba2a:	b0 89       	ldd	r27, Z+16	; 0x10
    ba2c:	f8 01       	movw	r30, r16
    ba2e:	21 85       	ldd	r18, Z+9	; 0x09
    ba30:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
    ba32:	f9 01       	movw	r30, r18
    ba34:	e2 51       	subi	r30, 0x12	; 18
    ba36:	ff 4f       	sbci	r31, 0xFF	; 255
    ba38:	80 83       	st	Z, r24
    ba3a:	91 83       	std	Z+1, r25	; 0x01
    ba3c:	a2 83       	std	Z+2, r26	; 0x02
    ba3e:	b3 83       	std	Z+3, r27	; 0x03
			model->YawAngularVelocityRadsPerSecond(sensorMsg->YawAngularVelocityRadsPerSecond);
    ba40:	f6 01       	movw	r30, r12
    ba42:	81 89       	ldd	r24, Z+17	; 0x11
    ba44:	92 89       	ldd	r25, Z+18	; 0x12
    ba46:	a3 89       	ldd	r26, Z+19	; 0x13
    ba48:	b4 89       	ldd	r27, Z+20	; 0x14
    ba4a:	f8 01       	movw	r30, r16
    ba4c:	21 85       	ldd	r18, Z+9	; 0x09
    ba4e:	32 85       	ldd	r19, Z+10	; 0x0a
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
    ba50:	f9 01       	movw	r30, r18
    ba52:	ee 51       	subi	r30, 0x1E	; 30
    ba54:	ff 4f       	sbci	r31, 0xFF	; 255
    ba56:	80 83       	st	Z, r24
    ba58:	91 83       	std	Z+1, r25	; 0x01
    ba5a:	a2 83       	std	Z+2, r26	; 0x02
    ba5c:	b3 83       	std	Z+3, r27	; 0x03
			model->PitchAngularVelocityRadsPerSecond(sensorMsg->PitchAngularVelocityRadsPerSecond);
    ba5e:	f6 01       	movw	r30, r12
    ba60:	85 89       	ldd	r24, Z+21	; 0x15
    ba62:	96 89       	ldd	r25, Z+22	; 0x16
    ba64:	a7 89       	ldd	r26, Z+23	; 0x17
    ba66:	b0 8d       	ldd	r27, Z+24	; 0x18
    ba68:	f8 01       	movw	r30, r16
    ba6a:	21 85       	ldd	r18, Z+9	; 0x09
    ba6c:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}
    ba6e:	f9 01       	movw	r30, r18
    ba70:	e6 52       	subi	r30, 0x26	; 38
    ba72:	ff 4f       	sbci	r31, 0xFF	; 255
    ba74:	80 83       	st	Z, r24
    ba76:	91 83       	std	Z+1, r25	; 0x01
    ba78:	a2 83       	std	Z+2, r26	; 0x02
    ba7a:	b3 83       	std	Z+3, r27	; 0x03
			model->RollAngularVelocityRadsPerSecond(sensorMsg->RollAngularVelocityRadsPerSecond);
    ba7c:	f6 01       	movw	r30, r12
    ba7e:	81 8d       	ldd	r24, Z+25	; 0x19
    ba80:	92 8d       	ldd	r25, Z+26	; 0x1a
    ba82:	a3 8d       	ldd	r26, Z+27	; 0x1b
    ba84:	b4 8d       	ldd	r27, Z+28	; 0x1c
    ba86:	f8 01       	movw	r30, r16
    ba88:	21 85       	ldd	r18, Z+9	; 0x09
    ba8a:	32 85       	ldd	r19, Z+10	; 0x0a

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
    ba8c:	f9 01       	movw	r30, r18
    ba8e:	e2 52       	subi	r30, 0x22	; 34
    ba90:	ff 4f       	sbci	r31, 0xFF	; 255
    ba92:	80 83       	st	Z, r24
    ba94:	91 83       	std	Z+1, r25	; 0x01
    ba96:	a2 83       	std	Z+2, r26	; 0x02
    ba98:	b3 83       	std	Z+3, r27	; 0x03
			model->XMagFrd(sensorMsg->XMagFrd);
    ba9a:	f6 01       	movw	r30, r12
    ba9c:	85 8d       	ldd	r24, Z+29	; 0x1d
    ba9e:	96 8d       	ldd	r25, Z+30	; 0x1e
    baa0:	a7 8d       	ldd	r26, Z+31	; 0x1f
    baa2:	b0 a1       	ldd	r27, Z+32	; 0x20
    baa4:	f8 01       	movw	r30, r16
    baa6:	21 85       	ldd	r18, Z+9	; 0x09
    baa8:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
			void XMagFrd(float val) {xMagFrd = val;}
    baaa:	f9 01       	movw	r30, r18
    baac:	ee 50       	subi	r30, 0x0E	; 14
    baae:	ff 4f       	sbci	r31, 0xFF	; 255
    bab0:	80 83       	st	Z, r24
    bab2:	91 83       	std	Z+1, r25	; 0x01
    bab4:	a2 83       	std	Z+2, r26	; 0x02
    bab6:	b3 83       	std	Z+3, r27	; 0x03
			model->YMagFrd(sensorMsg->YMagFrd);
    bab8:	f6 01       	movw	r30, r12
    baba:	81 a1       	ldd	r24, Z+33	; 0x21
    babc:	92 a1       	ldd	r25, Z+34	; 0x22
    babe:	a3 a1       	ldd	r26, Z+35	; 0x23
    bac0:	b4 a1       	ldd	r27, Z+36	; 0x24
    bac2:	f8 01       	movw	r30, r16
    bac4:	21 85       	ldd	r18, Z+9	; 0x09
    bac6:	32 85       	ldd	r19, Z+10	; 0x0a

			float YMagFrd() const {return yMagFrd;}
			void YMagFrd(float val) {yMagFrd = val;}
    bac8:	f9 01       	movw	r30, r18
    baca:	ea 50       	subi	r30, 0x0A	; 10
    bacc:	ff 4f       	sbci	r31, 0xFF	; 255
    bace:	80 83       	st	Z, r24
    bad0:	91 83       	std	Z+1, r25	; 0x01
    bad2:	a2 83       	std	Z+2, r26	; 0x02
    bad4:	b3 83       	std	Z+3, r27	; 0x03
			model->ZMagFrd(sensorMsg->ZMagFrd);
    bad6:	f6 01       	movw	r30, r12
    bad8:	85 a1       	ldd	r24, Z+37	; 0x25
    bada:	96 a1       	ldd	r25, Z+38	; 0x26
    badc:	a7 a1       	ldd	r26, Z+39	; 0x27
    bade:	b0 a5       	ldd	r27, Z+40	; 0x28
    bae0:	f8 01       	movw	r30, r16
    bae2:	21 85       	ldd	r18, Z+9	; 0x09
    bae4:	32 85       	ldd	r19, Z+10	; 0x0a

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
    bae6:	f9 01       	movw	r30, r18
    bae8:	e6 50       	subi	r30, 0x06	; 6
    baea:	ff 4f       	sbci	r31, 0xFF	; 255
    baec:	80 83       	st	Z, r24
    baee:	91 83       	std	Z+1, r25	; 0x01
    baf0:	a2 83       	std	Z+2, r26	; 0x02
    baf2:	b3 83       	std	Z+3, r27	; 0x03
			model->XEcefCm(sensorMsg->XEcefCm);
    baf4:	f6 01       	movw	r30, r12
    baf6:	81 a5       	ldd	r24, Z+41	; 0x29
    baf8:	92 a5       	ldd	r25, Z+42	; 0x2a
    bafa:	a3 a5       	ldd	r26, Z+43	; 0x2b
    bafc:	b4 a5       	ldd	r27, Z+44	; 0x2c
    bafe:	f8 01       	movw	r30, r16
    bb00:	21 85       	ldd	r18, Z+9	; 0x09
    bb02:	32 85       	ldd	r19, Z+10	; 0x0a
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
			void XEcefCm(long val) {xEcefCm = val;}
    bb04:	f9 01       	movw	r30, r18
    bb06:	e2 50       	subi	r30, 0x02	; 2
    bb08:	ff 4f       	sbci	r31, 0xFF	; 255
    bb0a:	80 83       	st	Z, r24
    bb0c:	91 83       	std	Z+1, r25	; 0x01
    bb0e:	a2 83       	std	Z+2, r26	; 0x02
    bb10:	b3 83       	std	Z+3, r27	; 0x03
			model->YEcefCm(sensorMsg->YEcefCm);
    bb12:	f6 01       	movw	r30, r12
    bb14:	85 a5       	ldd	r24, Z+45	; 0x2d
    bb16:	96 a5       	ldd	r25, Z+46	; 0x2e
    bb18:	a7 a5       	ldd	r26, Z+47	; 0x2f
    bb1a:	b0 a9       	ldd	r27, Z+48	; 0x30
    bb1c:	f8 01       	movw	r30, r16
    bb1e:	21 85       	ldd	r18, Z+9	; 0x09
    bb20:	32 85       	ldd	r19, Z+10	; 0x0a
			
			long YEcefCm() const {return yEcefCm;}
			void YEcefCm(long val) {yEcefCm = val;}
    bb22:	f9 01       	movw	r30, r18
    bb24:	ee 5f       	subi	r30, 0xFE	; 254
    bb26:	fe 4f       	sbci	r31, 0xFE	; 254
    bb28:	80 83       	st	Z, r24
    bb2a:	91 83       	std	Z+1, r25	; 0x01
    bb2c:	a2 83       	std	Z+2, r26	; 0x02
    bb2e:	b3 83       	std	Z+3, r27	; 0x03
			model->ZEcefCm(sensorMsg->ZEcefCm);
    bb30:	f6 01       	movw	r30, r12
    bb32:	81 a9       	ldd	r24, Z+49	; 0x31
    bb34:	92 a9       	ldd	r25, Z+50	; 0x32
    bb36:	a3 a9       	ldd	r26, Z+51	; 0x33
    bb38:	b4 a9       	ldd	r27, Z+52	; 0x34
    bb3a:	f8 01       	movw	r30, r16
    bb3c:	21 85       	ldd	r18, Z+9	; 0x09
    bb3e:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long ZEcefCm() const {return zEcefCm;}
			void ZEcefCm(long val) {zEcefCm = val;}				
    bb40:	f9 01       	movw	r30, r18
    bb42:	ea 5f       	subi	r30, 0xFA	; 250
    bb44:	fe 4f       	sbci	r31, 0xFE	; 254
    bb46:	80 83       	st	Z, r24
    bb48:	91 83       	std	Z+1, r25	; 0x01
    bb4a:	a2 83       	std	Z+2, r26	; 0x02
    bb4c:	b3 83       	std	Z+3, r27	; 0x03
			model->XVEcefCms(sensorMsg->XVEcefCms);
    bb4e:	f6 01       	movw	r30, r12
    bb50:	85 a9       	ldd	r24, Z+53	; 0x35
    bb52:	96 a9       	ldd	r25, Z+54	; 0x36
    bb54:	a7 a9       	ldd	r26, Z+55	; 0x37
    bb56:	b0 ad       	ldd	r27, Z+56	; 0x38
    bb58:	f8 01       	movw	r30, r16
    bb5a:	21 85       	ldd	r18, Z+9	; 0x09
    bb5c:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long XVEcefCms() const {return xVEcefCms;}
			void XVEcefCms(long val) {xVEcefCms = val;}	
    bb5e:	f9 01       	movw	r30, r18
    bb60:	e6 5f       	subi	r30, 0xF6	; 246
    bb62:	fe 4f       	sbci	r31, 0xFE	; 254
    bb64:	80 83       	st	Z, r24
    bb66:	91 83       	std	Z+1, r25	; 0x01
    bb68:	a2 83       	std	Z+2, r26	; 0x02
    bb6a:	b3 83       	std	Z+3, r27	; 0x03
			model->YVEcefCms(sensorMsg->YVEcefCms);
    bb6c:	f6 01       	movw	r30, r12
    bb6e:	81 ad       	ldd	r24, Z+57	; 0x39
    bb70:	92 ad       	ldd	r25, Z+58	; 0x3a
    bb72:	a3 ad       	ldd	r26, Z+59	; 0x3b
    bb74:	b4 ad       	ldd	r27, Z+60	; 0x3c
    bb76:	f8 01       	movw	r30, r16
    bb78:	21 85       	ldd	r18, Z+9	; 0x09
    bb7a:	32 85       	ldd	r19, Z+10	; 0x0a
				
			long YVEcefCms() const {return yVEcefCms;}
			void YVEcefCms(long val) {yVEcefCms = val;}
    bb7c:	f9 01       	movw	r30, r18
    bb7e:	e2 5f       	subi	r30, 0xF2	; 242
    bb80:	fe 4f       	sbci	r31, 0xFE	; 254
    bb82:	80 83       	st	Z, r24
    bb84:	91 83       	std	Z+1, r25	; 0x01
    bb86:	a2 83       	std	Z+2, r26	; 0x02
    bb88:	b3 83       	std	Z+3, r27	; 0x03
			model->ZVEcefCms(sensorMsg->ZVEcefCms);
    bb8a:	f6 01       	movw	r30, r12
    bb8c:	fd 96       	adiw	r30, 0x3d	; 61
    bb8e:	40 81       	ld	r20, Z
    bb90:	51 81       	ldd	r21, Z+1	; 0x01
    bb92:	62 81       	ldd	r22, Z+2	; 0x02
    bb94:	73 81       	ldd	r23, Z+3	; 0x03
    bb96:	d8 01       	movw	r26, r16
    bb98:	19 96       	adiw	r26, 0x09	; 9
    bb9a:	ed 91       	ld	r30, X+
    bb9c:	fc 91       	ld	r31, X
    bb9e:	1a 97       	sbiw	r26, 0x0a	; 10
				
			long ZVEcefCms() const {return zVEcefCms;}
			void ZVEcefCms(long val) {zVEcefCms = val;}		
    bba0:	ee 5e       	subi	r30, 0xEE	; 238
    bba2:	fe 4f       	sbci	r31, 0xFE	; 254
    bba4:	40 83       	st	Z, r20
    bba6:	51 83       	std	Z+1, r21	; 0x01
    bba8:	62 83       	std	Z+2, r22	; 0x02
    bbaa:	73 83       	std	Z+3, r23	; 0x03
			model->PressureMillibars(sensorMsg->PressureMillibars);
    bbac:	f6 01       	movw	r30, r12
    bbae:	ef 5b       	subi	r30, 0xBF	; 191
    bbb0:	ff 4f       	sbci	r31, 0xFF	; 255
    bbb2:	40 81       	ld	r20, Z
    bbb4:	51 81       	ldd	r21, Z+1	; 0x01
    bbb6:	62 81       	ldd	r22, Z+2	; 0x02
    bbb8:	73 81       	ldd	r23, Z+3	; 0x03
    bbba:	19 96       	adiw	r26, 0x09	; 9
    bbbc:	ed 91       	ld	r30, X+
    bbbe:	fc 91       	ld	r31, X
    bbc0:	1a 97       	sbiw	r26, 0x0a	; 10
				
			float PressureMillibars() const {return pressureMillibars;}
			void PressureMillibars(float val) {pressureMillibars = val;}
    bbc2:	ea 5e       	subi	r30, 0xEA	; 234
    bbc4:	fe 4f       	sbci	r31, 0xFE	; 254
    bbc6:	40 83       	st	Z, r20
    bbc8:	51 83       	std	Z+1, r21	; 0x01
    bbca:	62 83       	std	Z+2, r22	; 0x02
    bbcc:	73 83       	std	Z+3, r23	; 0x03
			
			model->HasNewPressureReading = true;
    bbce:	19 96       	adiw	r26, 0x09	; 9
    bbd0:	ed 91       	ld	r30, X+
    bbd2:	fc 91       	ld	r31, X
    bbd4:	1a 97       	sbiw	r26, 0x0a	; 10
    bbd6:	ee 5b       	subi	r30, 0xBE	; 190
    bbd8:	fe 4f       	sbci	r31, 0xFE	; 254
    bbda:	81 e0       	ldi	r24, 0x01	; 1
    bbdc:	80 83       	st	Z, r24
    bbde:	5b c1       	rjmp	.+694    	; 0xbe96 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x78c>
				
		}else if (message->getType() == GainsMessage::MessageType)
    bbe0:	87 30       	cpi	r24, 0x07	; 7
    bbe2:	09 f0       	breq	.+2      	; 0xbbe6 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x4dc>
    bbe4:	5e c1       	rjmp	.+700    	; 0xbea2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
		{
			GainsMessage *telemMsg = (GainsMessage*) message;
				
			pidController->setYawIntegralGain(telemMsg->YawIntegralGain);
    bbe6:	f6 01       	movw	r30, r12
    bbe8:	85 81       	ldd	r24, Z+5	; 0x05
    bbea:	96 81       	ldd	r25, Z+6	; 0x06
    bbec:	a7 81       	ldd	r26, Z+7	; 0x07
    bbee:	b0 85       	ldd	r27, Z+8	; 0x08
    bbf0:	f8 01       	movw	r30, r16
    bbf2:	23 85       	ldd	r18, Z+11	; 0x0b
    bbf4:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw integral
				 */
				void setYawIntegralGain(float yawIntegralGain)
				{
					this->yawIntegralGain = yawIntegralGain;
    bbf6:	f9 01       	movw	r30, r18
    bbf8:	82 83       	std	Z+2, r24	; 0x02
    bbfa:	93 83       	std	Z+3, r25	; 0x03
    bbfc:	a4 83       	std	Z+4, r26	; 0x04
    bbfe:	b5 83       	std	Z+5, r27	; 0x05
			pidController->setYawDerivativeGain(telemMsg->YawDerivativeGain);
    bc00:	f6 01       	movw	r30, r12
    bc02:	81 85       	ldd	r24, Z+9	; 0x09
    bc04:	92 85       	ldd	r25, Z+10	; 0x0a
    bc06:	a3 85       	ldd	r26, Z+11	; 0x0b
    bc08:	b4 85       	ldd	r27, Z+12	; 0x0c
    bc0a:	f8 01       	movw	r30, r16
    bc0c:	23 85       	ldd	r18, Z+11	; 0x0b
    bc0e:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the derivative
				 */
				void setYawDerivativeGain(float yawDerivativeGain)
				{
					this->yawDerivativeGain = yawDerivativeGain;
    bc10:	f9 01       	movw	r30, r18
    bc12:	86 83       	std	Z+6, r24	; 0x06
    bc14:	97 83       	std	Z+7, r25	; 0x07
    bc16:	a0 87       	std	Z+8, r26	; 0x08
    bc18:	b1 87       	std	Z+9, r27	; 0x09
			pidController->setYawProportionalGain(telemMsg->YawProportionalGain);
    bc1a:	f6 01       	movw	r30, r12
    bc1c:	85 85       	ldd	r24, Z+13	; 0x0d
    bc1e:	96 85       	ldd	r25, Z+14	; 0x0e
    bc20:	a7 85       	ldd	r26, Z+15	; 0x0f
    bc22:	b0 89       	ldd	r27, Z+16	; 0x10
    bc24:	f8 01       	movw	r30, r16
    bc26:	23 85       	ldd	r18, Z+11	; 0x0b
    bc28:	34 85       	ldd	r19, Z+12	; 0x0c
				/**
				 * Gain value applied to the yaw proportional error
				 */
				void setYawProportionalGain(float yawProportionalGain)
				{
					this->yawProportionalGain = yawProportionalGain;
    bc2a:	f9 01       	movw	r30, r18
    bc2c:	82 87       	std	Z+10, r24	; 0x0a
    bc2e:	93 87       	std	Z+11, r25	; 0x0b
    bc30:	a4 87       	std	Z+12, r26	; 0x0c
    bc32:	b5 87       	std	Z+13, r27	; 0x0d
			pidController->setYawAntiWindupGain(telemMsg->YawAntiWindupGain);
    bc34:	f6 01       	movw	r30, r12
    bc36:	81 89       	ldd	r24, Z+17	; 0x11
    bc38:	92 89       	ldd	r25, Z+18	; 0x12
    bc3a:	a3 89       	ldd	r26, Z+19	; 0x13
    bc3c:	b4 89       	ldd	r27, Z+20	; 0x14
    bc3e:	f8 01       	movw	r30, r16
    bc40:	23 85       	ldd	r18, Z+11	; 0x0b
    bc42:	34 85       	ldd	r19, Z+12	; 0x0c
				 * go back to 0 when the servos are saturated.
				 * Some simple rule that have been suggested for the tracking time are ~ Tt = TiTd and Tt = (Ti + Td)/2.
				 */
				void setYawAntiWindupGain(float yawAntiWindupGain)
				{
					this->yawAntiWindupGain = yawAntiWindupGain;
    bc44:	f9 01       	movw	r30, r18
    bc46:	86 87       	std	Z+14, r24	; 0x0e
    bc48:	97 87       	std	Z+15, r25	; 0x0f
    bc4a:	a0 8b       	std	Z+16, r26	; 0x10
    bc4c:	b1 8b       	std	Z+17, r27	; 0x11
				
			pidController->setXIntegralGain(telemMsg->XIntegralGain);
    bc4e:	f6 01       	movw	r30, r12
    bc50:	85 89       	ldd	r24, Z+21	; 0x15
    bc52:	96 89       	ldd	r25, Z+22	; 0x16
    bc54:	a7 89       	ldd	r26, Z+23	; 0x17
    bc56:	b0 8d       	ldd	r27, Z+24	; 0x18
    bc58:	f8 01       	movw	r30, r16
    bc5a:	23 85       	ldd	r18, Z+11	; 0x0b
    bc5c:	34 85       	ldd	r19, Z+12	; 0x0c
					
				~PIDController();
				
				void setXIntegralGain(float val)
				{
					xIntegralGain = val;
    bc5e:	f9 01       	movw	r30, r18
    bc60:	82 8b       	std	Z+18, r24	; 0x12
    bc62:	93 8b       	std	Z+19, r25	; 0x13
    bc64:	a4 8b       	std	Z+20, r26	; 0x14
    bc66:	b5 8b       	std	Z+21, r27	; 0x15
			pidController->setXDerivativeGain(telemMsg->XDerivativeGain);
    bc68:	f6 01       	movw	r30, r12
    bc6a:	81 8d       	ldd	r24, Z+25	; 0x19
    bc6c:	92 8d       	ldd	r25, Z+26	; 0x1a
    bc6e:	a3 8d       	ldd	r26, Z+27	; 0x1b
    bc70:	b4 8d       	ldd	r27, Z+28	; 0x1c
    bc72:	f8 01       	movw	r30, r16
    bc74:	23 85       	ldd	r18, Z+11	; 0x0b
    bc76:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXDerivativeGain(float val)
				{
					xDerivativeGain = val;
    bc78:	f9 01       	movw	r30, r18
    bc7a:	86 8b       	std	Z+22, r24	; 0x16
    bc7c:	97 8b       	std	Z+23, r25	; 0x17
    bc7e:	a0 8f       	std	Z+24, r26	; 0x18
    bc80:	b1 8f       	std	Z+25, r27	; 0x19
			pidController->setXProportionalGain(telemMsg->XProportionalGain);
    bc82:	f6 01       	movw	r30, r12
    bc84:	85 8d       	ldd	r24, Z+29	; 0x1d
    bc86:	96 8d       	ldd	r25, Z+30	; 0x1e
    bc88:	a7 8d       	ldd	r26, Z+31	; 0x1f
    bc8a:	b0 a1       	ldd	r27, Z+32	; 0x20
    bc8c:	f8 01       	movw	r30, r16
    bc8e:	23 85       	ldd	r18, Z+11	; 0x0b
    bc90:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXProportionalGain(float val)
				{
					xProportionalGain = val;
    bc92:	f9 01       	movw	r30, r18
    bc94:	82 8f       	std	Z+26, r24	; 0x1a
    bc96:	93 8f       	std	Z+27, r25	; 0x1b
    bc98:	a4 8f       	std	Z+28, r26	; 0x1c
    bc9a:	b5 8f       	std	Z+29, r27	; 0x1d
			pidController->setXAntiWindupGain(telemMsg->XAntiWindupGain);
    bc9c:	f6 01       	movw	r30, r12
    bc9e:	81 a1       	ldd	r24, Z+33	; 0x21
    bca0:	92 a1       	ldd	r25, Z+34	; 0x22
    bca2:	a3 a1       	ldd	r26, Z+35	; 0x23
    bca4:	b4 a1       	ldd	r27, Z+36	; 0x24
    bca6:	f8 01       	movw	r30, r16
    bca8:	23 85       	ldd	r18, Z+11	; 0x0b
    bcaa:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setXAntiWindupGain(float val)
				{
					xAntiWindupGain = val;
    bcac:	f9 01       	movw	r30, r18
    bcae:	86 8f       	std	Z+30, r24	; 0x1e
    bcb0:	97 8f       	std	Z+31, r25	; 0x1f
    bcb2:	a0 a3       	std	Z+32, r26	; 0x20
    bcb4:	b1 a3       	std	Z+33, r27	; 0x21
			pidController->setLongitudeInnerLoopGain(telemMsg->LongitudeInnerLoopGain);
    bcb6:	f6 01       	movw	r30, r12
    bcb8:	85 a1       	ldd	r24, Z+37	; 0x25
    bcba:	96 a1       	ldd	r25, Z+38	; 0x26
    bcbc:	a7 a1       	ldd	r26, Z+39	; 0x27
    bcbe:	b0 a5       	ldd	r27, Z+40	; 0x28
    bcc0:	f8 01       	movw	r30, r16
    bcc2:	23 85       	ldd	r18, Z+11	; 0x0b
    bcc4:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLongitudeInnerLoopGain(float val)
				{
					longitudeInnerLoopGain = val;
    bcc6:	f9 01       	movw	r30, r18
    bcc8:	82 a3       	std	Z+34, r24	; 0x22
    bcca:	93 a3       	std	Z+35, r25	; 0x23
    bccc:	a4 a3       	std	Z+36, r26	; 0x24
    bcce:	b5 a3       	std	Z+37, r27	; 0x25
			pidController->setPitchAngularVelocityGain(telemMsg->PitchAngularVelocityGain);
    bcd0:	f6 01       	movw	r30, r12
    bcd2:	81 a5       	ldd	r24, Z+41	; 0x29
    bcd4:	92 a5       	ldd	r25, Z+42	; 0x2a
    bcd6:	a3 a5       	ldd	r26, Z+43	; 0x2b
    bcd8:	b4 a5       	ldd	r27, Z+44	; 0x2c
    bcda:	f8 01       	movw	r30, r16
    bcdc:	23 85       	ldd	r18, Z+11	; 0x0b
    bcde:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setPitchAngularVelocityGain(float val)
				{
					pitchAngularVelocityGain = val;
    bce0:	f9 01       	movw	r30, r18
    bce2:	86 a3       	std	Z+38, r24	; 0x26
    bce4:	97 a3       	std	Z+39, r25	; 0x27
    bce6:	a0 a7       	std	Z+40, r26	; 0x28
    bce8:	b1 a7       	std	Z+41, r27	; 0x29
				
			pidController->setYIntegralGain(telemMsg->YIntegralGain);
    bcea:	f6 01       	movw	r30, r12
    bcec:	85 a5       	ldd	r24, Z+45	; 0x2d
    bcee:	96 a5       	ldd	r25, Z+46	; 0x2e
    bcf0:	a7 a5       	ldd	r26, Z+47	; 0x2f
    bcf2:	b0 a9       	ldd	r27, Z+48	; 0x30
    bcf4:	f8 01       	movw	r30, r16
    bcf6:	23 85       	ldd	r18, Z+11	; 0x0b
    bcf8:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setYIntegralGain(float val)
				{
					yIntegralGain = val;
    bcfa:	f9 01       	movw	r30, r18
    bcfc:	82 a7       	std	Z+42, r24	; 0x2a
    bcfe:	93 a7       	std	Z+43, r25	; 0x2b
    bd00:	a4 a7       	std	Z+44, r26	; 0x2c
    bd02:	b5 a7       	std	Z+45, r27	; 0x2d
			pidController->setYDerivativeGain(telemMsg->YDerivativeGain);
    bd04:	f6 01       	movw	r30, r12
    bd06:	81 a9       	ldd	r24, Z+49	; 0x31
    bd08:	92 a9       	ldd	r25, Z+50	; 0x32
    bd0a:	a3 a9       	ldd	r26, Z+51	; 0x33
    bd0c:	b4 a9       	ldd	r27, Z+52	; 0x34
    bd0e:	f8 01       	movw	r30, r16
    bd10:	23 85       	ldd	r18, Z+11	; 0x0b
    bd12:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYDerivativeGain(float val)
				{
					yDerivativeGain = val;
    bd14:	f9 01       	movw	r30, r18
    bd16:	86 a7       	std	Z+46, r24	; 0x2e
    bd18:	97 a7       	std	Z+47, r25	; 0x2f
    bd1a:	a0 ab       	std	Z+48, r26	; 0x30
    bd1c:	b1 ab       	std	Z+49, r27	; 0x31
			pidController->setYProportionalGain(telemMsg->YProportionalGain);
    bd1e:	f6 01       	movw	r30, r12
    bd20:	85 a9       	ldd	r24, Z+53	; 0x35
    bd22:	96 a9       	ldd	r25, Z+54	; 0x36
    bd24:	a7 a9       	ldd	r26, Z+55	; 0x37
    bd26:	b0 ad       	ldd	r27, Z+56	; 0x38
    bd28:	f8 01       	movw	r30, r16
    bd2a:	23 85       	ldd	r18, Z+11	; 0x0b
    bd2c:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYProportionalGain(float val)
				{
					yProportionalGain = val;
    bd2e:	f9 01       	movw	r30, r18
    bd30:	82 ab       	std	Z+50, r24	; 0x32
    bd32:	93 ab       	std	Z+51, r25	; 0x33
    bd34:	a4 ab       	std	Z+52, r26	; 0x34
    bd36:	b5 ab       	std	Z+53, r27	; 0x35
			pidController->setYAntiWindupGain(telemMsg->YAntiWindupGain);
    bd38:	f6 01       	movw	r30, r12
    bd3a:	81 ad       	ldd	r24, Z+57	; 0x39
    bd3c:	92 ad       	ldd	r25, Z+58	; 0x3a
    bd3e:	a3 ad       	ldd	r26, Z+59	; 0x3b
    bd40:	b4 ad       	ldd	r27, Z+60	; 0x3c
    bd42:	f8 01       	movw	r30, r16
    bd44:	23 85       	ldd	r18, Z+11	; 0x0b
    bd46:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setYAntiWindupGain(float val)
				{
					yAntiWindupGain = val;
    bd48:	f9 01       	movw	r30, r18
    bd4a:	86 ab       	std	Z+54, r24	; 0x36
    bd4c:	97 ab       	std	Z+55, r25	; 0x37
    bd4e:	a0 af       	std	Z+56, r26	; 0x38
    bd50:	b1 af       	std	Z+57, r27	; 0x39
			pidController->setLateralInnerLoopGain(telemMsg->LateralInnerLoopGain);
    bd52:	f6 01       	movw	r30, r12
    bd54:	fd 96       	adiw	r30, 0x3d	; 61
    bd56:	80 81       	ld	r24, Z
    bd58:	91 81       	ldd	r25, Z+1	; 0x01
    bd5a:	a2 81       	ldd	r26, Z+2	; 0x02
    bd5c:	b3 81       	ldd	r27, Z+3	; 0x03
    bd5e:	f8 01       	movw	r30, r16
    bd60:	23 85       	ldd	r18, Z+11	; 0x0b
    bd62:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setLateralInnerLoopGain(float val)
				{
					lateralInnerLoopGain = val;
    bd64:	f9 01       	movw	r30, r18
    bd66:	82 af       	std	Z+58, r24	; 0x3a
    bd68:	93 af       	std	Z+59, r25	; 0x3b
    bd6a:	a4 af       	std	Z+60, r26	; 0x3c
    bd6c:	b5 af       	std	Z+61, r27	; 0x3d
			pidController->setRollAngularVelocityGain(telemMsg->RollAngularVelocityGain);
    bd6e:	f6 01       	movw	r30, r12
    bd70:	ef 5b       	subi	r30, 0xBF	; 191
    bd72:	ff 4f       	sbci	r31, 0xFF	; 255
    bd74:	80 81       	ld	r24, Z
    bd76:	91 81       	ldd	r25, Z+1	; 0x01
    bd78:	a2 81       	ldd	r26, Z+2	; 0x02
    bd7a:	b3 81       	ldd	r27, Z+3	; 0x03
    bd7c:	f8 01       	movw	r30, r16
    bd7e:	23 85       	ldd	r18, Z+11	; 0x0b
    bd80:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setRollAngularVelocityGain(float val)
				{
					rollAngularVelocityGain = val;
    bd82:	f9 01       	movw	r30, r18
    bd84:	fe 96       	adiw	r30, 0x3e	; 62
    bd86:	80 83       	st	Z, r24
    bd88:	91 83       	std	Z+1, r25	; 0x01
    bd8a:	a2 83       	std	Z+2, r26	; 0x02
    bd8c:	b3 83       	std	Z+3, r27	; 0x03
				
			pidController->setZIntegralGain(telemMsg->ZIntegralGain);
    bd8e:	f6 01       	movw	r30, r12
    bd90:	eb 5b       	subi	r30, 0xBB	; 187
    bd92:	ff 4f       	sbci	r31, 0xFF	; 255
    bd94:	80 81       	ld	r24, Z
    bd96:	91 81       	ldd	r25, Z+1	; 0x01
    bd98:	a2 81       	ldd	r26, Z+2	; 0x02
    bd9a:	b3 81       	ldd	r27, Z+3	; 0x03
    bd9c:	f8 01       	movw	r30, r16
    bd9e:	23 85       	ldd	r18, Z+11	; 0x0b
    bda0:	34 85       	ldd	r19, Z+12	; 0x0c
				
				
				
				void setZIntegralGain(float val)
				{
					zIntegralGain = val;
    bda2:	f9 01       	movw	r30, r18
    bda4:	ee 5b       	subi	r30, 0xBE	; 190
    bda6:	ff 4f       	sbci	r31, 0xFF	; 255
    bda8:	80 83       	st	Z, r24
    bdaa:	91 83       	std	Z+1, r25	; 0x01
    bdac:	a2 83       	std	Z+2, r26	; 0x02
    bdae:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZDerivativeGain(telemMsg->ZDerivativeGain);
    bdb0:	f6 01       	movw	r30, r12
    bdb2:	e7 5b       	subi	r30, 0xB7	; 183
    bdb4:	ff 4f       	sbci	r31, 0xFF	; 255
    bdb6:	80 81       	ld	r24, Z
    bdb8:	91 81       	ldd	r25, Z+1	; 0x01
    bdba:	a2 81       	ldd	r26, Z+2	; 0x02
    bdbc:	b3 81       	ldd	r27, Z+3	; 0x03
    bdbe:	f8 01       	movw	r30, r16
    bdc0:	23 85       	ldd	r18, Z+11	; 0x0b
    bdc2:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZDerivativeGain(float val)
				{
					zDerivativeGain = val;
    bdc4:	f9 01       	movw	r30, r18
    bdc6:	ea 5b       	subi	r30, 0xBA	; 186
    bdc8:	ff 4f       	sbci	r31, 0xFF	; 255
    bdca:	80 83       	st	Z, r24
    bdcc:	91 83       	std	Z+1, r25	; 0x01
    bdce:	a2 83       	std	Z+2, r26	; 0x02
    bdd0:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZProportionalGain(telemMsg->ZProportionalGain);
    bdd2:	f6 01       	movw	r30, r12
    bdd4:	e3 5b       	subi	r30, 0xB3	; 179
    bdd6:	ff 4f       	sbci	r31, 0xFF	; 255
    bdd8:	80 81       	ld	r24, Z
    bdda:	91 81       	ldd	r25, Z+1	; 0x01
    bddc:	a2 81       	ldd	r26, Z+2	; 0x02
    bdde:	b3 81       	ldd	r27, Z+3	; 0x03
    bde0:	f8 01       	movw	r30, r16
    bde2:	23 85       	ldd	r18, Z+11	; 0x0b
    bde4:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZProportionalGain(float val)
				{
					zProportionalGain = val;
    bde6:	f9 01       	movw	r30, r18
    bde8:	e6 5b       	subi	r30, 0xB6	; 182
    bdea:	ff 4f       	sbci	r31, 0xFF	; 255
    bdec:	80 83       	st	Z, r24
    bdee:	91 83       	std	Z+1, r25	; 0x01
    bdf0:	a2 83       	std	Z+2, r26	; 0x02
    bdf2:	b3 83       	std	Z+3, r27	; 0x03
			pidController->setZAntiWindupGain(telemMsg->ZAntiWindupGain);
    bdf4:	f6 01       	movw	r30, r12
    bdf6:	ef 5a       	subi	r30, 0xAF	; 175
    bdf8:	ff 4f       	sbci	r31, 0xFF	; 255
    bdfa:	80 81       	ld	r24, Z
    bdfc:	91 81       	ldd	r25, Z+1	; 0x01
    bdfe:	a2 81       	ldd	r26, Z+2	; 0x02
    be00:	b3 81       	ldd	r27, Z+3	; 0x03
    be02:	f8 01       	movw	r30, r16
    be04:	23 85       	ldd	r18, Z+11	; 0x0b
    be06:	34 85       	ldd	r19, Z+12	; 0x0c
				}
				
				void setZAntiWindupGain(float val)
				{
					zAntiWindupGain = val;
    be08:	f9 01       	movw	r30, r18
    be0a:	e2 5b       	subi	r30, 0xB2	; 178
    be0c:	ff 4f       	sbci	r31, 0xFF	; 255
    be0e:	80 83       	st	Z, r24
    be10:	91 83       	std	Z+1, r25	; 0x01
    be12:	a2 83       	std	Z+2, r26	; 0x02
    be14:	b3 83       	std	Z+3, r27	; 0x03
				
			model->ReferenceMagYawRads(telemMsg->YawRefSetpoint);
    be16:	f6 01       	movw	r30, r12
    be18:	ef 59       	subi	r30, 0x9F	; 159
    be1a:	ff 4f       	sbci	r31, 0xFF	; 255
    be1c:	80 81       	ld	r24, Z
    be1e:	91 81       	ldd	r25, Z+1	; 0x01
    be20:	a2 81       	ldd	r26, Z+2	; 0x02
    be22:	b3 81       	ldd	r27, Z+3	; 0x03
    be24:	f8 01       	movw	r30, r16
    be26:	21 85       	ldd	r18, Z+9	; 0x09
    be28:	32 85       	ldd	r19, Z+10	; 0x0a
				EcefToLocalNEDRotationMatrix[2][1] = 0;
				EcefToLocalNEDRotationMatrix[2][2] = 0;								
			}
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
    be2a:	f9 01       	movw	r30, r18
    be2c:	86 83       	std	Z+6, r24	; 0x06
    be2e:	97 83       	std	Z+7, r25	; 0x07
    be30:	a0 87       	std	Z+8, r26	; 0x08
    be32:	b1 87       	std	Z+9, r27	; 0x09
			model->ReferenceXNEDLocalFrameCm(telemMsg->XRefSetpoint);
    be34:	f6 01       	movw	r30, r12
    be36:	eb 5a       	subi	r30, 0xAB	; 171
    be38:	ff 4f       	sbci	r31, 0xFF	; 255
    be3a:	80 81       	ld	r24, Z
    be3c:	91 81       	ldd	r25, Z+1	; 0x01
    be3e:	a2 81       	ldd	r26, Z+2	; 0x02
    be40:	b3 81       	ldd	r27, Z+3	; 0x03
    be42:	f8 01       	movw	r30, r16
    be44:	21 85       	ldd	r18, Z+9	; 0x09
    be46:	32 85       	ldd	r19, Z+10	; 0x0a
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
			void XNEDLocalFrameCm(float val) { xNEDLocalFrame = val;}
						
			float ReferenceXNEDLocalFrameCm() const {return referenceXNEDLocalFrame;}
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}
    be48:	f9 01       	movw	r30, r18
    be4a:	86 a3       	std	Z+38, r24	; 0x26
    be4c:	97 a3       	std	Z+39, r25	; 0x27
    be4e:	a0 a7       	std	Z+40, r26	; 0x28
    be50:	b1 a7       	std	Z+41, r27	; 0x29
			model->ReferenceYNEDLocalFrameCm(telemMsg->YRefSetpoint);
    be52:	f6 01       	movw	r30, r12
    be54:	e7 5a       	subi	r30, 0xA7	; 167
    be56:	ff 4f       	sbci	r31, 0xFF	; 255
    be58:	80 81       	ld	r24, Z
    be5a:	91 81       	ldd	r25, Z+1	; 0x01
    be5c:	a2 81       	ldd	r26, Z+2	; 0x02
    be5e:	b3 81       	ldd	r27, Z+3	; 0x03
    be60:	f8 01       	movw	r30, r16
    be62:	21 85       	ldd	r18, Z+9	; 0x09
    be64:	32 85       	ldd	r19, Z+10	; 0x0a

			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
			void YNEDLocalFrameCm(float val) { yNEDLocalFrame = val;}

			float ReferenceYNEDLocalFrameCm() const {return referenceYNEDLocalFrame;}
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}
    be66:	f9 01       	movw	r30, r18
    be68:	ee 5a       	subi	r30, 0xAE	; 174
    be6a:	ff 4f       	sbci	r31, 0xFF	; 255
    be6c:	80 83       	st	Z, r24
    be6e:	91 83       	std	Z+1, r25	; 0x01
    be70:	a2 83       	std	Z+2, r26	; 0x02
    be72:	b3 83       	std	Z+3, r27	; 0x03
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
    be74:	f6 01       	movw	r30, r12
    be76:	e3 5a       	subi	r30, 0xA3	; 163
    be78:	ff 4f       	sbci	r31, 0xFF	; 255
    be7a:	80 81       	ld	r24, Z
    be7c:	91 81       	ldd	r25, Z+1	; 0x01
    be7e:	a2 81       	ldd	r26, Z+2	; 0x02
    be80:	b3 81       	ldd	r27, Z+3	; 0x03
    be82:	f8 01       	movw	r30, r16
    be84:	21 85       	ldd	r18, Z+9	; 0x09
    be86:	32 85       	ldd	r19, Z+10	; 0x0a
			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
			void ZNEDLocalFrameCm(float val) { zNEDLocalFrame = val; }


			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}
    be88:	f9 01       	movw	r30, r18
    be8a:	ee 57       	subi	r30, 0x7E	; 126
    be8c:	ff 4f       	sbci	r31, 0xFF	; 255
    be8e:	80 83       	st	Z, r24
    be90:	91 83       	std	Z+1, r25	; 0x01
    be92:	a2 83       	std	Z+2, r26	; 0x02
    be94:	b3 83       	std	Z+3, r27	; 0x03
		}
			
	}
		
	if (message != NULL)
    be96:	cf 80       	ldd	r12, Y+7	; 0x07
    be98:	d8 84       	ldd	r13, Y+8	; 0x08
    be9a:	c1 14       	cp	r12, r1
    be9c:	d1 04       	cpc	r13, r1
    be9e:	09 f4       	brne	.+2      	; 0xbea2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    bea0:	6c c0       	rjmp	.+216    	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		delete message;
    bea2:	d6 01       	movw	r26, r12
    bea4:	ed 91       	ld	r30, X+
    bea6:	fc 91       	ld	r31, X
    bea8:	02 80       	ldd	r0, Z+2	; 0x02
    beaa:	f3 81       	ldd	r31, Z+3	; 0x03
    beac:	e0 2d       	mov	r30, r0
    beae:	c6 01       	movw	r24, r12
    beb0:	19 95       	eicall
		message = NULL;
    beb2:	18 86       	std	Y+8, r1	; 0x08
    beb4:	1f 82       	std	Y+7, r1	; 0x07
	}

	
	//Update instrumentation fields
	switch (status)
    beb6:	bd ef       	ldi	r27, 0xFD	; 253
    beb8:	eb 16       	cp	r14, r27
    beba:	bf ef       	ldi	r27, 0xFF	; 255
    bebc:	fb 06       	cpc	r15, r27
    bebe:	b9 f1       	breq	.+110    	; 0xbf2e <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x824>
    bec0:	3c f4       	brge	.+14     	; 0xbed0 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c6>
    bec2:	fc ef       	ldi	r31, 0xFC	; 252
    bec4:	ef 16       	cp	r14, r31
    bec6:	ff ef       	ldi	r31, 0xFF	; 255
    bec8:	ff 06       	cpc	r15, r31
    beca:	09 f0       	breq	.+2      	; 0xbece <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7c4>
    becc:	56 c0       	rjmp	.+172    	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
    bece:	42 c0       	rjmp	.+132    	; 0xbf54 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x84a>
    bed0:	8e ef       	ldi	r24, 0xFE	; 254
    bed2:	e8 16       	cp	r14, r24
    bed4:	8f ef       	ldi	r24, 0xFF	; 255
    bed6:	f8 06       	cpc	r15, r24
    bed8:	b9 f0       	breq	.+46     	; 0xbf08 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7fe>
    beda:	ef 20       	and	r14, r15
    bedc:	e0 94       	com	r14
    bede:	09 f0       	breq	.+2      	; 0xbee2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7d8>
    bee0:	4c c0       	rjmp	.+152    	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
	{
		case 0:
		break;
		case -1:
		model->Timeouts(model->Timeouts() + 1);
    bee2:	d8 01       	movw	r26, r16
    bee4:	19 96       	adiw	r26, 0x09	; 9
    bee6:	ed 91       	ld	r30, X+
    bee8:	fc 91       	ld	r31, X
    beea:	1a 97       	sbiw	r26, 0x0a	; 10
			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
    beec:	e6 55       	subi	r30, 0x56	; 86
    beee:	ff 4f       	sbci	r31, 0xFF	; 255
    bef0:	80 81       	ld	r24, Z
    bef2:	91 81       	ldd	r25, Z+1	; 0x01
    bef4:	a2 81       	ldd	r26, Z+2	; 0x02
    bef6:	b3 81       	ldd	r27, Z+3	; 0x03
    bef8:	01 96       	adiw	r24, 0x01	; 1
    befa:	a1 1d       	adc	r26, r1
    befc:	b1 1d       	adc	r27, r1
    befe:	80 83       	st	Z, r24
    bf00:	91 83       	std	Z+1, r25	; 0x01
    bf02:	a2 83       	std	Z+2, r26	; 0x02
    bf04:	b3 83       	std	Z+3, r27	; 0x03
    bf06:	39 c0       	rjmp	.+114    	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -2:
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns() + 1);
    bf08:	d8 01       	movw	r26, r16
    bf0a:	19 96       	adiw	r26, 0x09	; 9
    bf0c:	ed 91       	ld	r30, X+
    bf0e:	fc 91       	ld	r31, X
    bf10:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    bf12:	e6 54       	subi	r30, 0x46	; 70
    bf14:	ff 4f       	sbci	r31, 0xFF	; 255
    bf16:	80 81       	ld	r24, Z
    bf18:	91 81       	ldd	r25, Z+1	; 0x01
    bf1a:	a2 81       	ldd	r26, Z+2	; 0x02
    bf1c:	b3 81       	ldd	r27, Z+3	; 0x03
    bf1e:	01 96       	adiw	r24, 0x01	; 1
    bf20:	a1 1d       	adc	r26, r1
    bf22:	b1 1d       	adc	r27, r1
    bf24:	80 83       	st	Z, r24
    bf26:	91 83       	std	Z+1, r25	; 0x01
    bf28:	a2 83       	std	Z+2, r26	; 0x02
    bf2a:	b3 83       	std	Z+3, r27	; 0x03
    bf2c:	26 c0       	rjmp	.+76     	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -3:
		model->UnrecognizedMsgTypes(model->UnrecognizedMsgTypes() + 1);
    bf2e:	d8 01       	movw	r26, r16
    bf30:	19 96       	adiw	r26, 0x09	; 9
    bf32:	ed 91       	ld	r30, X+
    bf34:	fc 91       	ld	r31, X
    bf36:	1a 97       	sbiw	r26, 0x0a	; 10
						
			long Timeouts() const {return timeouts; }
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
    bf38:	e2 55       	subi	r30, 0x52	; 82
    bf3a:	ff 4f       	sbci	r31, 0xFF	; 255
    bf3c:	80 81       	ld	r24, Z
    bf3e:	91 81       	ldd	r25, Z+1	; 0x01
    bf40:	a2 81       	ldd	r26, Z+2	; 0x02
    bf42:	b3 81       	ldd	r27, Z+3	; 0x03
    bf44:	01 96       	adiw	r24, 0x01	; 1
    bf46:	a1 1d       	adc	r26, r1
    bf48:	b1 1d       	adc	r27, r1
    bf4a:	80 83       	st	Z, r24
    bf4c:	91 83       	std	Z+1, r25	; 0x01
    bf4e:	a2 83       	std	Z+2, r26	; 0x02
    bf50:	b3 83       	std	Z+3, r27	; 0x03
    bf52:	13 c0       	rjmp	.+38     	; 0xbf7a <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x870>
		break;
		case -4:
		model->ChecksumErrors(model->ChecksumErrors() + 1);
    bf54:	d8 01       	movw	r26, r16
    bf56:	19 96       	adiw	r26, 0x09	; 9
    bf58:	ed 91       	ld	r30, X+
    bf5a:	fc 91       	ld	r31, X
    bf5c:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
    bf5e:	ee 54       	subi	r30, 0x4E	; 78
    bf60:	ff 4f       	sbci	r31, 0xFF	; 255
    bf62:	40 81       	ld	r20, Z
    bf64:	51 81       	ldd	r21, Z+1	; 0x01
    bf66:	62 81       	ldd	r22, Z+2	; 0x02
    bf68:	73 81       	ldd	r23, Z+3	; 0x03
    bf6a:	4f 5f       	subi	r20, 0xFF	; 255
    bf6c:	5f 4f       	sbci	r21, 0xFF	; 255
    bf6e:	6f 4f       	sbci	r22, 0xFF	; 255
    bf70:	7f 4f       	sbci	r23, 0xFF	; 255
    bf72:	40 83       	st	Z, r20
    bf74:	51 83       	std	Z+1, r21	; 0x01
    bf76:	62 83       	std	Z+2, r22	; 0x02
    bf78:	73 83       	std	Z+3, r23	; 0x03
	
	
	//Send sync message to indicate to the ground control station that we are ready to receive data.
	//Without this sync message, the GCS could send data while the FC is asleep, which would cause the data
	//to overflow the usart buffer.
	SyncMessage syncMsg(dataToReceive);
    bf7a:	f8 01       	movw	r30, r16
    bf7c:	25 85       	ldd	r18, Z+13	; 0x0d
				/**
				 * @param msgType The identifier of this message
				 * @param msgSize The size in bytes of this message
				 */
				Message (byte msgType, int msgSize):
					msgType(msgType), msgSize(msgSize)
    bf7e:	83 e0       	ldi	r24, 0x03	; 3
    bf80:	8b 83       	std	Y+3, r24	; 0x03
    bf82:	82 e0       	ldi	r24, 0x02	; 2
    bf84:	90 e0       	ldi	r25, 0x00	; 0
    bf86:	9d 83       	std	Y+5, r25	; 0x05
    bf88:	8c 83       	std	Y+4, r24	; 0x04
				byte RequestedMessage;
							
				static const byte MessageSize =
					sizeof(msgType) + sizeof(RequestedMessage);
							
				SyncMessage(byte requestedMessage): Message(MessageType,MessageSize), RequestedMessage(requestedMessage)
    bf8a:	84 e7       	ldi	r24, 0x74	; 116
    bf8c:	92 e0       	ldi	r25, 0x02	; 2
    bf8e:	9a 83       	std	Y+2, r25	; 0x02
    bf90:	89 83       	std	Y+1, r24	; 0x01
    bf92:	2e 83       	std	Y+6, r18	; 0x06
	
	//Send this out after receiving data so if there is asynchronous processing, the system doesn't try to
	//read a partial message that might have actually been transmitted just after sending the transmit message.
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
    bf94:	be 01       	movw	r22, r28
    bf96:	6f 5f       	subi	r22, 0xFF	; 255
    bf98:	7f 4f       	sbci	r23, 0xFF	; 255
    bf9a:	87 81       	ldd	r24, Z+7	; 0x07
    bf9c:	90 85       	ldd	r25, Z+8	; 0x08
    bf9e:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    bfa2:	89 2b       	or	r24, r25
    bfa4:	d1 f0       	breq	.+52     	; 0xbfda <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    bfa6:	d8 01       	movw	r26, r16
    bfa8:	19 96       	adiw	r26, 0x09	; 9
    bfaa:	ed 91       	ld	r30, X+
    bfac:	fc 91       	ld	r31, X
    bfae:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    bfb0:	e6 54       	subi	r30, 0x46	; 70
    bfb2:	ff 4f       	sbci	r31, 0xFF	; 255
    bfb4:	80 81       	ld	r24, Z
    bfb6:	91 81       	ldd	r25, Z+1	; 0x01
    bfb8:	a2 81       	ldd	r26, Z+2	; 0x02
    bfba:	b3 81       	ldd	r27, Z+3	; 0x03
    bfbc:	01 96       	adiw	r24, 0x01	; 1
    bfbe:	a1 1d       	adc	r26, r1
    bfc0:	b1 1d       	adc	r27, r1
    bfc2:	80 83       	st	Z, r24
    bfc4:	91 83       	std	Z+1, r25	; 0x01
    bfc6:	a2 83       	std	Z+2, r26	; 0x02
    bfc8:	b3 83       	std	Z+3, r27	; 0x03
    bfca:	07 c0       	rjmp	.+14     	; 0xbfda <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8d0>
			model->ReferenceZNEDLocalFrameCm(telemMsg->ZRefSetpoint);
		}
			
	}
		
	if (message != NULL)
    bfcc:	cf 80       	ldd	r12, Y+7	; 0x07
    bfce:	d8 84       	ldd	r13, Y+8	; 0x08
    bfd0:	c1 14       	cp	r12, r1
    bfd2:	d1 04       	cpc	r13, r1
    bfd4:	09 f0       	breq	.+2      	; 0xbfd8 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x8ce>
    bfd6:	65 cf       	rjmp	.-310    	; 0xbea2 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x798>
    bfd8:	6e cf       	rjmp	.-292    	; 0xbeb6 <_ZN10helicopter5tasks16SimTelemetryTask11runTaskImplEv+0x7ac>
	//radioInterface->transmit(&syncMsg);	
	if (radioInterface->transmit(&syncMsg) != 0)
	{
		model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
	}
}
    bfda:	28 96       	adiw	r28, 0x08	; 8
    bfdc:	0f b6       	in	r0, 0x3f	; 63
    bfde:	f8 94       	cli
    bfe0:	de bf       	out	0x3e, r29	; 62
    bfe2:	0f be       	out	0x3f, r0	; 63
    bfe4:	cd bf       	out	0x3d, r28	; 61
    bfe6:	df 91       	pop	r29
    bfe8:	cf 91       	pop	r28
    bfea:	1f 91       	pop	r17
    bfec:	0f 91       	pop	r16
    bfee:	ff 90       	pop	r15
    bff0:	ef 90       	pop	r14
    bff2:	df 90       	pop	r13
    bff4:	cf 90       	pop	r12
    bff6:	08 95       	ret

0000bff8 <_ZN10helicopter5tasks16SimTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelEPNS_10controller13PIDControllerENS1_13DATATORECEIVEEii>:
#include "GainsMessage.h"

using namespace helicopter::tasks;
using namespace helicopter::messages;

SimTelemetryTask::SimTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, PIDController *pidController,  DATATORECEIVE dataToReceive, int delay, int period) :
    bff8:	6f 92       	push	r6
    bffa:	7f 92       	push	r7
    bffc:	8f 92       	push	r8
    bffe:	9f 92       	push	r9
    c000:	af 92       	push	r10
    c002:	bf 92       	push	r11
    c004:	cf 92       	push	r12
    c006:	df 92       	push	r13
    c008:	ef 92       	push	r14
    c00a:	ff 92       	push	r15
    c00c:	0f 93       	push	r16
    c00e:	cf 93       	push	r28
    c010:	df 93       	push	r29
    c012:	ec 01       	movw	r28, r24
    c014:	3b 01       	movw	r6, r22
    c016:	4a 01       	movw	r8, r20
    c018:	59 01       	movw	r10, r18
    c01a:	b7 01       	movw	r22, r14
    c01c:	a6 01       	movw	r20, r12
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	pidController(pidController),
	dataToReceive(dataToReceive)
    c01e:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    c022:	88 e6       	ldi	r24, 0x68	; 104
    c024:	93 e0       	ldi	r25, 0x03	; 3
    c026:	99 83       	std	Y+1, r25	; 0x01
    c028:	88 83       	st	Y, r24
    c02a:	78 86       	std	Y+8, r7	; 0x08
    c02c:	6f 82       	std	Y+7, r6	; 0x07
    c02e:	9a 86       	std	Y+10, r9	; 0x0a
    c030:	89 86       	std	Y+9, r8	; 0x09
    c032:	bc 86       	std	Y+12, r11	; 0x0c
    c034:	ab 86       	std	Y+11, r10	; 0x0b
    c036:	0d 87       	std	Y+13, r16	; 0x0d
{
	
}
    c038:	df 91       	pop	r29
    c03a:	cf 91       	pop	r28
    c03c:	0f 91       	pop	r16
    c03e:	ff 90       	pop	r15
    c040:	ef 90       	pop	r14
    c042:	df 90       	pop	r13
    c044:	cf 90       	pop	r12
    c046:	bf 90       	pop	r11
    c048:	af 90       	pop	r10
    c04a:	9f 90       	pop	r9
    c04c:	8f 90       	pop	r8
    c04e:	7f 90       	pop	r7
    c050:	6f 90       	pop	r6
    c052:	08 95       	ret

0000c054 <_ZN10helicopter5tasks4Task11runTaskImplEv>:
				
			protected:
				/**
				* Implemented by subclasses for the actual logic to execute
				*/
				virtual void runTaskImpl(){;}
    c054:	08 95       	ret

0000c056 <_ZN10helicopter5tasks4TaskD1Ev>:
				 * @param period The number of scheduler 'ticks' to be executed before
				 * this task is ready to run.
				 */
				Task (int delay, int period);
				
				virtual ~Task(){}
    c056:	26 e7       	ldi	r18, 0x76	; 118
    c058:	33 e0       	ldi	r19, 0x03	; 3
    c05a:	fc 01       	movw	r30, r24
    c05c:	31 83       	std	Z+1, r19	; 0x01
    c05e:	20 83       	st	Z, r18
    c060:	08 95       	ret

0000c062 <_ZN10helicopter5tasks4Task7runTaskEv>:
{
	//Disable interrupts 
	//cli(); //removed because gps serial driver will miss a lot of bytes notifications if a task runs for a long time.
	
	//run task
	this->runTaskImpl();
    c062:	dc 01       	movw	r26, r24
    c064:	ed 91       	ld	r30, X+
    c066:	fc 91       	ld	r31, X
    c068:	01 90       	ld	r0, Z+
    c06a:	f0 81       	ld	r31, Z
    c06c:	e0 2d       	mov	r30, r0
    c06e:	19 95       	eicall
    c070:	08 95       	ret

0000c072 <_ZN10helicopter5tasks4TaskD0Ev>:
    c072:	26 e7       	ldi	r18, 0x76	; 118
    c074:	33 e0       	ldi	r19, 0x03	; 3
    c076:	fc 01       	movw	r30, r24
    c078:	31 83       	std	Z+1, r19	; 0x01
    c07a:	20 83       	st	Z, r18
    c07c:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    c080:	08 95       	ret

0000c082 <_ZN10helicopter5tasks4TaskC1Eii>:
#include <avr/interrupt.h>
#include "Task.h"

using namespace helicopter::tasks;

Task::Task(int delay, int period)
    c082:	fc 01       	movw	r30, r24
    c084:	86 e7       	ldi	r24, 0x76	; 118
    c086:	93 e0       	ldi	r25, 0x03	; 3
    c088:	91 83       	std	Z+1, r25	; 0x01
    c08a:	80 83       	st	Z, r24
{
	this->delay = delay;
    c08c:	73 83       	std	Z+3, r23	; 0x03
    c08e:	62 83       	std	Z+2, r22	; 0x02
	this->period = period;
    c090:	55 83       	std	Z+5, r21	; 0x05
    c092:	44 83       	std	Z+4, r20	; 0x04
	this->isReadyToRun = false;
    c094:	16 82       	std	Z+6, r1	; 0x06
    c096:	08 95       	ret

0000c098 <_ZN10helicopter5tasks21TransmitTelemetryTaskD1Ev>:
    c098:	26 e7       	ldi	r18, 0x76	; 118
    c09a:	33 e0       	ldi	r19, 0x03	; 3
    c09c:	fc 01       	movw	r30, r24
    c09e:	31 83       	std	Z+1, r19	; 0x01
    c0a0:	20 83       	st	Z, r18
    c0a2:	08 95       	ret

0000c0a4 <_ZN10helicopter5tasks21TransmitTelemetryTaskD0Ev>:
    c0a4:	26 e7       	ldi	r18, 0x76	; 118
    c0a6:	33 e0       	ldi	r19, 0x03	; 3
    c0a8:	fc 01       	movw	r30, r24
    c0aa:	31 83       	std	Z+1, r19	; 0x01
    c0ac:	20 83       	st	Z, r18
	namespace tasks
	{
		/**
		 * This class transmits flight computer telemetry information to the ground control station.
		 */
		class TransmitTelemetryTask : public Task
    c0ae:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <_ZdlPv>
    c0b2:	08 95       	ret

0000c0b4 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv>:
	
}


void TransmitTelemetryTask::runTaskImpl()
{
    c0b4:	2f 92       	push	r2
    c0b6:	3f 92       	push	r3
    c0b8:	4f 92       	push	r4
    c0ba:	5f 92       	push	r5
    c0bc:	6f 92       	push	r6
    c0be:	7f 92       	push	r7
    c0c0:	8f 92       	push	r8
    c0c2:	9f 92       	push	r9
    c0c4:	af 92       	push	r10
    c0c6:	bf 92       	push	r11
    c0c8:	cf 92       	push	r12
    c0ca:	df 92       	push	r13
    c0cc:	ef 92       	push	r14
    c0ce:	ff 92       	push	r15
    c0d0:	0f 93       	push	r16
    c0d2:	1f 93       	push	r17
    c0d4:	cf 93       	push	r28
    c0d6:	df 93       	push	r29
    c0d8:	cd b7       	in	r28, 0x3d	; 61
    c0da:	de b7       	in	r29, 0x3e	; 62
    c0dc:	60 97       	sbiw	r28, 0x10	; 16
    c0de:	0f b6       	in	r0, 0x3f	; 63
    c0e0:	f8 94       	cli
    c0e2:	de bf       	out	0x3e, r29	; 62
    c0e4:	0f be       	out	0x3f, r0	; 63
    c0e6:	cd bf       	out	0x3d, r28	; 61
    c0e8:	9c 87       	std	Y+12, r25	; 0x0c
    c0ea:	8b 87       	std	Y+11, r24	; 0x0b
		model->YawRads(yawRads);
		model->PitchRads(-asin(model->Ahrs()->dcm[2][0]));
		model->RollRads(atan2(model->Ahrs()->dcm[2][1], model->Ahrs()->dcm[2][2]));
	}*/
	
	if (dataToSend == ALLDATA)
    c0ec:	dc 01       	movw	r26, r24
    c0ee:	1b 96       	adiw	r26, 0x0b	; 11
    c0f0:	8c 91       	ld	r24, X
    c0f2:	1b 97       	sbiw	r26, 0x0b	; 11
    c0f4:	81 11       	cpse	r24, r1
    c0f6:	31 c0       	rjmp	.+98     	; 0xc15a <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xa6>
	{
		//SystemTelemetryMessage *message = model->CreateTelemetryMessage();
		SystemTelemetryMessage *message = SystemTelemetryMessage::buildMessageFromModel(model);
    c0f8:	19 96       	adiw	r26, 0x09	; 9
    c0fa:	8d 91       	ld	r24, X+
    c0fc:	9c 91       	ld	r25, X
    c0fe:	1a 97       	sbiw	r26, 0x0a	; 10
    c100:	0e 94 1c 37 	call	0x6e38	; 0x6e38 <_ZN10helicopter8messages22SystemTelemetryMessage21buildMessageFromModelEPNS_5model11SystemModelE>
    c104:	8c 01       	movw	r16, r24
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();
*/	
	
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    c106:	bc 01       	movw	r22, r24
    c108:	eb 85       	ldd	r30, Y+11	; 0x0b
    c10a:	fc 85       	ldd	r31, Y+12	; 0x0c
    c10c:	87 81       	ldd	r24, Z+7	; 0x07
    c10e:	90 85       	ldd	r25, Z+8	; 0x08
    c110:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c114:	89 2b       	or	r24, r25
    c116:	a1 f0       	breq	.+40     	; 0xc140 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x8c>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c118:	ab 85       	ldd	r26, Y+11	; 0x0b
    c11a:	bc 85       	ldd	r27, Y+12	; 0x0c
    c11c:	19 96       	adiw	r26, 0x09	; 9
    c11e:	ed 91       	ld	r30, X+
    c120:	fc 91       	ld	r31, X
    c122:	1a 97       	sbiw	r26, 0x0a	; 10
    c124:	e6 54       	subi	r30, 0x46	; 70
    c126:	ff 4f       	sbci	r31, 0xFF	; 255
    c128:	40 81       	ld	r20, Z
    c12a:	51 81       	ldd	r21, Z+1	; 0x01
    c12c:	62 81       	ldd	r22, Z+2	; 0x02
    c12e:	73 81       	ldd	r23, Z+3	; 0x03
    c130:	4f 5f       	subi	r20, 0xFF	; 255
    c132:	5f 4f       	sbci	r21, 0xFF	; 255
    c134:	6f 4f       	sbci	r22, 0xFF	; 255
    c136:	7f 4f       	sbci	r23, 0xFF	; 255
    c138:	40 83       	st	Z, r20
    c13a:	51 83       	std	Z+1, r21	; 0x01
    c13c:	62 83       	std	Z+2, r22	; 0x02
    c13e:	73 83       	std	Z+3, r23	; 0x03
		}
	
		delete message;
    c140:	01 15       	cp	r16, r1
    c142:	11 05       	cpc	r17, r1
    c144:	09 f4       	brne	.+2      	; 0xc148 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x94>
    c146:	97 c3       	rjmp	.+1838   	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c148:	d8 01       	movw	r26, r16
    c14a:	ed 91       	ld	r30, X+
    c14c:	fc 91       	ld	r31, X
    c14e:	02 80       	ldd	r0, Z+2	; 0x02
    c150:	f3 81       	ldd	r31, Z+3	; 0x03
    c152:	e0 2d       	mov	r30, r0
    c154:	c8 01       	movw	r24, r16
    c156:	19 95       	eicall
    c158:	8e c3       	rjmp	.+1820   	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
	}else if (dataToSend == CONTROLDATA)
    c15a:	81 30       	cpi	r24, 0x01	; 1
    c15c:	09 f0       	breq	.+2      	; 0xc160 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0xac>
    c15e:	89 c0       	rjmp	.+274    	; 0xc272 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1be>
	{
		ControlMessage *message = new ControlMessage();
    c160:	85 e1       	ldi	r24, 0x15	; 21
    c162:	90 e0       	ldi	r25, 0x00	; 0
    c164:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    c168:	8c 01       	movw	r16, r24
    c16a:	85 e0       	ldi	r24, 0x05	; 5
    c16c:	f8 01       	movw	r30, r16
    c16e:	82 83       	std	Z+2, r24	; 0x02
    c170:	81 e1       	ldi	r24, 0x11	; 17
    c172:	90 e0       	ldi	r25, 0x00	; 0
    c174:	94 83       	std	Z+4, r25	; 0x04
    c176:	83 83       	std	Z+3, r24	; 0x03
				
				ControlMessage(): Message(MessageType,MessageSize),
					MainRotorCollectiveControl(0),
					YawControl(0),
					LongitudeControl(0),
					LateralControl(0)
    c178:	88 e3       	ldi	r24, 0x38	; 56
    c17a:	92 e0       	ldi	r25, 0x02	; 2
    c17c:	91 83       	std	Z+1, r25	; 0x01
    c17e:	80 83       	st	Z, r24
    c180:	15 82       	std	Z+5, r1	; 0x05
    c182:	16 82       	std	Z+6, r1	; 0x06
    c184:	17 82       	std	Z+7, r1	; 0x07
    c186:	10 86       	std	Z+8, r1	; 0x08
    c188:	11 86       	std	Z+9, r1	; 0x09
    c18a:	12 86       	std	Z+10, r1	; 0x0a
    c18c:	13 86       	std	Z+11, r1	; 0x0b
    c18e:	14 86       	std	Z+12, r1	; 0x0c
    c190:	15 86       	std	Z+13, r1	; 0x0d
    c192:	16 86       	std	Z+14, r1	; 0x0e
    c194:	17 86       	std	Z+15, r1	; 0x0f
    c196:	10 8a       	std	Z+16, r1	; 0x10
    c198:	11 8a       	std	Z+17, r1	; 0x11
    c19a:	12 8a       	std	Z+18, r1	; 0x12
    c19c:	13 8a       	std	Z+19, r1	; 0x13
    c19e:	14 8a       	std	Z+20, r1	; 0x14
			void ReferenceYNEDLocalFrameCm(float val) { referenceYNEDLocalFrame = val;}

			float LateralControlBeforeServoLimitsAdjustment() const {return lateralControlBeforeServoLimitsAdjustment;}
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
    c1a0:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1a2:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1a4:	19 96       	adiw	r26, 0x09	; 9
    c1a6:	ed 91       	ld	r30, X+
    c1a8:	fc 91       	ld	r31, X
    c1aa:	1a 97       	sbiw	r26, 0x0a	; 10
    c1ac:	e6 5a       	subi	r30, 0xA6	; 166
    c1ae:	ff 4f       	sbci	r31, 0xFF	; 255
    c1b0:	80 81       	ld	r24, Z
    c1b2:	91 81       	ldd	r25, Z+1	; 0x01
    c1b4:	a2 81       	ldd	r26, Z+2	; 0x02
    c1b6:	b3 81       	ldd	r27, Z+3	; 0x03
		message->LateralControl = model->LateralControl();
    c1b8:	f8 01       	movw	r30, r16
    c1ba:	81 8b       	std	Z+17, r24	; 0x11
    c1bc:	92 8b       	std	Z+18, r25	; 0x12
    c1be:	a3 8b       	std	Z+19, r26	; 0x13
    c1c0:	b4 8b       	std	Z+20, r27	; 0x14
			void ReferenceXNEDLocalFrameCm(float val) { referenceXNEDLocalFrame = val;}

			float LongitudeControlBeforeServoLimitsAdjustment() const {return longitudeControlBeforeServoLimitsAdjustment;}
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
    c1c2:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1c4:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1c6:	19 96       	adiw	r26, 0x09	; 9
    c1c8:	ed 91       	ld	r30, X+
    c1ca:	fc 91       	ld	r31, X
    c1cc:	1a 97       	sbiw	r26, 0x0a	; 10
    c1ce:	86 a5       	ldd	r24, Z+46	; 0x2e
    c1d0:	97 a5       	ldd	r25, Z+47	; 0x2f
    c1d2:	a0 a9       	ldd	r26, Z+48	; 0x30
    c1d4:	b1 a9       	ldd	r27, Z+49	; 0x31
		message->LongitudeControl = model->LongitudeControl();
    c1d6:	f8 01       	movw	r30, r16
    c1d8:	85 87       	std	Z+13, r24	; 0x0d
    c1da:	96 87       	std	Z+14, r25	; 0x0e
    c1dc:	a7 87       	std	Z+15, r26	; 0x0f
    c1de:	b0 8b       	std	Z+16, r27	; 0x10

			float ReferenceZNEDLocalFrameCm() const {return referenceAltitudeMeters;}
			void ReferenceZNEDLocalFrameCm(float val) { referenceAltitudeMeters = val;}


			float MainRotorCollectiveControl() const {return mainRotorControl;}
    c1e0:	ab 85       	ldd	r26, Y+11	; 0x0b
    c1e2:	bc 85       	ldd	r27, Y+12	; 0x0c
    c1e4:	19 96       	adiw	r26, 0x09	; 9
    c1e6:	ed 91       	ld	r30, X+
    c1e8:	fc 91       	ld	r31, X
    c1ea:	1a 97       	sbiw	r26, 0x0a	; 10
    c1ec:	ea 57       	subi	r30, 0x7A	; 122
    c1ee:	ff 4f       	sbci	r31, 0xFF	; 255
    c1f0:	80 81       	ld	r24, Z
    c1f2:	91 81       	ldd	r25, Z+1	; 0x01
    c1f4:	a2 81       	ldd	r26, Z+2	; 0x02
    c1f6:	b3 81       	ldd	r27, Z+3	; 0x03
		message->MainRotorCollectiveControl = model->MainRotorCollectiveControl();
    c1f8:	f8 01       	movw	r30, r16
    c1fa:	85 83       	std	Z+5, r24	; 0x05
    c1fc:	96 83       	std	Z+6, r25	; 0x06
    c1fe:	a7 83       	std	Z+7, r26	; 0x07
    c200:	b0 87       	std	Z+8, r27	; 0x08
			
			float ReferenceMagYawRads() const {return referenceMagYawRads;}
			void ReferenceMagYawRads(float val) { referenceMagYawRads = val;}
				
				
			float YawControl() const {return yawControl;}
    c202:	ab 85       	ldd	r26, Y+11	; 0x0b
    c204:	bc 85       	ldd	r27, Y+12	; 0x0c
    c206:	19 96       	adiw	r26, 0x09	; 9
    c208:	ed 91       	ld	r30, X+
    c20a:	fc 91       	ld	r31, X
    c20c:	1a 97       	sbiw	r26, 0x0a	; 10
    c20e:	42 85       	ldd	r20, Z+10	; 0x0a
    c210:	53 85       	ldd	r21, Z+11	; 0x0b
    c212:	64 85       	ldd	r22, Z+12	; 0x0c
    c214:	75 85       	ldd	r23, Z+13	; 0x0d
		message->YawControl = model->YawControl();
    c216:	f8 01       	movw	r30, r16
    c218:	41 87       	std	Z+9, r20	; 0x09
    c21a:	52 87       	std	Z+10, r21	; 0x0a
    c21c:	63 87       	std	Z+11, r22	; 0x0b
    c21e:	74 87       	std	Z+12, r23	; 0x0c
		
		//TODO add some error handling in here
		if (radioInterface->transmit(message) != 0)
    c220:	b8 01       	movw	r22, r16
    c222:	17 96       	adiw	r26, 0x07	; 7
    c224:	8d 91       	ld	r24, X+
    c226:	9c 91       	ld	r25, X
    c228:	18 97       	sbiw	r26, 0x08	; 8
    c22a:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c22e:	89 2b       	or	r24, r25
    c230:	99 f0       	breq	.+38     	; 0xc258 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1a4>
		{
			model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c232:	ab 85       	ldd	r26, Y+11	; 0x0b
    c234:	bc 85       	ldd	r27, Y+12	; 0x0c
    c236:	19 96       	adiw	r26, 0x09	; 9
    c238:	ed 91       	ld	r30, X+
    c23a:	fc 91       	ld	r31, X
    c23c:	1a 97       	sbiw	r26, 0x0a	; 10
			
			long BlownFrames() const {return numOfFramesBlown;}
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    c23e:	e6 54       	subi	r30, 0x46	; 70
    c240:	ff 4f       	sbci	r31, 0xFF	; 255
    c242:	80 81       	ld	r24, Z
    c244:	91 81       	ldd	r25, Z+1	; 0x01
    c246:	a2 81       	ldd	r26, Z+2	; 0x02
    c248:	b3 81       	ldd	r27, Z+3	; 0x03
    c24a:	01 96       	adiw	r24, 0x01	; 1
    c24c:	a1 1d       	adc	r26, r1
    c24e:	b1 1d       	adc	r27, r1
    c250:	80 83       	st	Z, r24
    c252:	91 83       	std	Z+1, r25	; 0x01
    c254:	a2 83       	std	Z+2, r26	; 0x02
    c256:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		delete message;		
    c258:	01 15       	cp	r16, r1
    c25a:	11 05       	cpc	r17, r1
    c25c:	09 f4       	brne	.+2      	; 0xc260 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1ac>
    c25e:	0b c3       	rjmp	.+1558   	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c260:	d8 01       	movw	r26, r16
    c262:	ed 91       	ld	r30, X+
    c264:	fc 91       	ld	r31, X
    c266:	02 80       	ldd	r0, Z+2	; 0x02
    c268:	f3 81       	ldd	r31, Z+3	; 0x03
    c26a:	e0 2d       	mov	r30, r0
    c26c:	c8 01       	movw	r24, r16
    c26e:	19 95       	eicall
    c270:	02 c3       	rjmp	.+1540   	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
		}else if (dataToSend == SIMPLEDATA)
    c272:	82 30       	cpi	r24, 0x02	; 2
    c274:	09 f0       	breq	.+2      	; 0xc278 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x1c4>
    c276:	ff c2       	rjmp	.+1534   	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
		{
			SimpleTelemetryMessage *message = new SimpleTelemetryMessage();
    c278:	8d e7       	ldi	r24, 0x7D	; 125
    c27a:	90 e0       	ldi	r25, 0x00	; 0
    c27c:	0e 94 7c 64 	call	0xc8f8	; 0xc8f8 <_Znwj>
    c280:	8c 01       	movw	r16, r24
    c282:	86 e0       	ldi	r24, 0x06	; 6
    c284:	f8 01       	movw	r30, r16
    c286:	82 83       	std	Z+2, r24	; 0x02
    c288:	89 e7       	ldi	r24, 0x79	; 121
    c28a:	90 e0       	ldi	r25, 0x00	; 0
    c28c:	94 83       	std	Z+4, r25	; 0x04
    c28e:	83 83       	std	Z+3, r24	; 0x03
    c290:	88 e6       	ldi	r24, 0x68	; 104
    c292:	92 e0       	ldi	r25, 0x02	; 2
    c294:	91 83       	std	Z+1, r25	; 0x01
    c296:	80 83       	st	Z, r24
    c298:	15 82       	std	Z+5, r1	; 0x05
    c29a:	16 82       	std	Z+6, r1	; 0x06
    c29c:	17 82       	std	Z+7, r1	; 0x07
    c29e:	10 86       	std	Z+8, r1	; 0x08
    c2a0:	11 86       	std	Z+9, r1	; 0x09
    c2a2:	12 86       	std	Z+10, r1	; 0x0a
    c2a4:	13 86       	std	Z+11, r1	; 0x0b
    c2a6:	14 86       	std	Z+12, r1	; 0x0c
    c2a8:	15 86       	std	Z+13, r1	; 0x0d
    c2aa:	16 86       	std	Z+14, r1	; 0x0e
    c2ac:	17 86       	std	Z+15, r1	; 0x0f
    c2ae:	10 8a       	std	Z+16, r1	; 0x10
    c2b0:	11 8a       	std	Z+17, r1	; 0x11
    c2b2:	12 8a       	std	Z+18, r1	; 0x12
    c2b4:	13 8a       	std	Z+19, r1	; 0x13
    c2b6:	14 8a       	std	Z+20, r1	; 0x14
    c2b8:	15 8a       	std	Z+21, r1	; 0x15
    c2ba:	16 8a       	std	Z+22, r1	; 0x16
    c2bc:	17 8a       	std	Z+23, r1	; 0x17
    c2be:	10 8e       	std	Z+24, r1	; 0x18
    c2c0:	11 8e       	std	Z+25, r1	; 0x19
    c2c2:	12 8e       	std	Z+26, r1	; 0x1a
    c2c4:	13 8e       	std	Z+27, r1	; 0x1b
    c2c6:	14 8e       	std	Z+28, r1	; 0x1c
    c2c8:	15 8e       	std	Z+29, r1	; 0x1d
    c2ca:	16 8e       	std	Z+30, r1	; 0x1e
    c2cc:	17 8e       	std	Z+31, r1	; 0x1f
    c2ce:	10 a2       	std	Z+32, r1	; 0x20
    c2d0:	11 a2       	std	Z+33, r1	; 0x21
    c2d2:	12 a2       	std	Z+34, r1	; 0x22
    c2d4:	13 a2       	std	Z+35, r1	; 0x23
    c2d6:	14 a2       	std	Z+36, r1	; 0x24
    c2d8:	15 a2       	std	Z+37, r1	; 0x25
    c2da:	16 a2       	std	Z+38, r1	; 0x26
    c2dc:	17 a2       	std	Z+39, r1	; 0x27
    c2de:	10 a6       	std	Z+40, r1	; 0x28
    c2e0:	11 a6       	std	Z+41, r1	; 0x29
    c2e2:	12 a6       	std	Z+42, r1	; 0x2a
    c2e4:	13 a6       	std	Z+43, r1	; 0x2b
    c2e6:	14 a6       	std	Z+44, r1	; 0x2c
    c2e8:	15 a6       	std	Z+45, r1	; 0x2d
    c2ea:	16 a6       	std	Z+46, r1	; 0x2e
    c2ec:	17 a6       	std	Z+47, r1	; 0x2f
    c2ee:	10 aa       	std	Z+48, r1	; 0x30
    c2f0:	11 aa       	std	Z+49, r1	; 0x31
    c2f2:	12 aa       	std	Z+50, r1	; 0x32
    c2f4:	13 aa       	std	Z+51, r1	; 0x33
    c2f6:	14 aa       	std	Z+52, r1	; 0x34
    c2f8:	15 aa       	std	Z+53, r1	; 0x35
    c2fa:	16 aa       	std	Z+54, r1	; 0x36
    c2fc:	17 aa       	std	Z+55, r1	; 0x37
    c2fe:	10 ae       	std	Z+56, r1	; 0x38
    c300:	11 ae       	std	Z+57, r1	; 0x39
    c302:	12 ae       	std	Z+58, r1	; 0x3a
    c304:	13 ae       	std	Z+59, r1	; 0x3b
    c306:	14 ae       	std	Z+60, r1	; 0x3c
    c308:	c8 01       	movw	r24, r16
    c30a:	cd 96       	adiw	r24, 0x3d	; 61
    c30c:	9a 83       	std	Y+2, r25	; 0x02
    c30e:	89 83       	std	Y+1, r24	; 0x01
    c310:	dc 01       	movw	r26, r24
    c312:	1d 92       	st	X+, r1
    c314:	1d 92       	st	X+, r1
    c316:	1d 92       	st	X+, r1
    c318:	1c 92       	st	X, r1
    c31a:	13 97       	sbiw	r26, 0x03	; 3
    c31c:	b8 01       	movw	r22, r16
    c31e:	6f 5b       	subi	r22, 0xBF	; 191
    c320:	7f 4f       	sbci	r23, 0xFF	; 255
    c322:	fb 01       	movw	r30, r22
    c324:	10 82       	st	Z, r1
    c326:	11 82       	std	Z+1, r1	; 0x01
    c328:	12 82       	std	Z+2, r1	; 0x02
    c32a:	13 82       	std	Z+3, r1	; 0x03
    c32c:	a8 01       	movw	r20, r16
    c32e:	4b 5b       	subi	r20, 0xBB	; 187
    c330:	5f 4f       	sbci	r21, 0xFF	; 255
    c332:	da 01       	movw	r26, r20
    c334:	1d 92       	st	X+, r1
    c336:	1d 92       	st	X+, r1
    c338:	1d 92       	st	X+, r1
    c33a:	1c 92       	st	X, r1
    c33c:	13 97       	sbiw	r26, 0x03	; 3
    c33e:	98 01       	movw	r18, r16
    c340:	27 5b       	subi	r18, 0xB7	; 183
    c342:	3f 4f       	sbci	r19, 0xFF	; 255
    c344:	f9 01       	movw	r30, r18
    c346:	10 82       	st	Z, r1
    c348:	11 82       	std	Z+1, r1	; 0x01
    c34a:	12 82       	std	Z+2, r1	; 0x02
    c34c:	13 82       	std	Z+3, r1	; 0x03
    c34e:	c8 01       	movw	r24, r16
    c350:	83 5b       	subi	r24, 0xB3	; 179
    c352:	9f 4f       	sbci	r25, 0xFF	; 255
    c354:	9e 87       	std	Y+14, r25	; 0x0e
    c356:	8d 87       	std	Y+13, r24	; 0x0d
    c358:	dc 01       	movw	r26, r24
    c35a:	1d 92       	st	X+, r1
    c35c:	1d 92       	st	X+, r1
    c35e:	1d 92       	st	X+, r1
    c360:	1c 92       	st	X, r1
    c362:	13 97       	sbiw	r26, 0x03	; 3
    c364:	d8 01       	movw	r26, r16
    c366:	af 5a       	subi	r26, 0xAF	; 175
    c368:	bf 4f       	sbci	r27, 0xFF	; 255
    c36a:	1d 92       	st	X+, r1
    c36c:	1d 92       	st	X+, r1
    c36e:	1d 92       	st	X+, r1
    c370:	1c 92       	st	X, r1
    c372:	13 97       	sbiw	r26, 0x03	; 3
    c374:	f8 01       	movw	r30, r16
    c376:	eb 5a       	subi	r30, 0xAB	; 171
    c378:	ff 4f       	sbci	r31, 0xFF	; 255
    c37a:	f8 8b       	std	Y+16, r31	; 0x10
    c37c:	ef 87       	std	Y+15, r30	; 0x0f
    c37e:	10 82       	st	Z, r1
    c380:	11 82       	std	Z+1, r1	; 0x01
    c382:	12 82       	std	Z+2, r1	; 0x02
    c384:	13 82       	std	Z+3, r1	; 0x03
    c386:	58 01       	movw	r10, r16
    c388:	f9 e5       	ldi	r31, 0x59	; 89
    c38a:	af 0e       	add	r10, r31
    c38c:	b1 1c       	adc	r11, r1
    c38e:	f5 01       	movw	r30, r10
    c390:	10 82       	st	Z, r1
    c392:	11 82       	std	Z+1, r1	; 0x01
    c394:	12 82       	std	Z+2, r1	; 0x02
    c396:	13 82       	std	Z+3, r1	; 0x03
    c398:	48 01       	movw	r8, r16
    c39a:	fd e5       	ldi	r31, 0x5D	; 93
    c39c:	8f 0e       	add	r8, r31
    c39e:	91 1c       	adc	r9, r1
    c3a0:	f4 01       	movw	r30, r8
    c3a2:	10 82       	st	Z, r1
    c3a4:	11 82       	std	Z+1, r1	; 0x01
    c3a6:	12 82       	std	Z+2, r1	; 0x02
    c3a8:	13 82       	std	Z+3, r1	; 0x03
    c3aa:	38 01       	movw	r6, r16
    c3ac:	f1 e6       	ldi	r31, 0x61	; 97
    c3ae:	6f 0e       	add	r6, r31
    c3b0:	71 1c       	adc	r7, r1
    c3b2:	f3 01       	movw	r30, r6
    c3b4:	10 82       	st	Z, r1
    c3b6:	11 82       	std	Z+1, r1	; 0x01
    c3b8:	12 82       	std	Z+2, r1	; 0x02
    c3ba:	13 82       	std	Z+3, r1	; 0x03
    c3bc:	28 01       	movw	r4, r16
    c3be:	f5 e6       	ldi	r31, 0x65	; 101
    c3c0:	4f 0e       	add	r4, r31
    c3c2:	51 1c       	adc	r5, r1
    c3c4:	f2 01       	movw	r30, r4
    c3c6:	10 82       	st	Z, r1
    c3c8:	11 82       	std	Z+1, r1	; 0x01
    c3ca:	12 82       	std	Z+2, r1	; 0x02
    c3cc:	13 82       	std	Z+3, r1	; 0x03
    c3ce:	c8 01       	movw	r24, r16
    c3d0:	87 59       	subi	r24, 0x97	; 151
    c3d2:	9f 4f       	sbci	r25, 0xFF	; 255
    c3d4:	9c 83       	std	Y+4, r25	; 0x04
    c3d6:	8b 83       	std	Y+3, r24	; 0x03
    c3d8:	fc 01       	movw	r30, r24
    c3da:	10 82       	st	Z, r1
    c3dc:	11 82       	std	Z+1, r1	; 0x01
    c3de:	12 82       	std	Z+2, r1	; 0x02
    c3e0:	13 82       	std	Z+3, r1	; 0x03
    c3e2:	c8 01       	movw	r24, r16
    c3e4:	83 59       	subi	r24, 0x93	; 147
    c3e6:	9f 4f       	sbci	r25, 0xFF	; 255
    c3e8:	9e 83       	std	Y+6, r25	; 0x06
    c3ea:	8d 83       	std	Y+5, r24	; 0x05
    c3ec:	fc 01       	movw	r30, r24
    c3ee:	10 82       	st	Z, r1
    c3f0:	11 82       	std	Z+1, r1	; 0x01
    c3f2:	12 82       	std	Z+2, r1	; 0x02
    c3f4:	13 82       	std	Z+3, r1	; 0x03
    c3f6:	18 01       	movw	r2, r16
    c3f8:	f1 e7       	ldi	r31, 0x71	; 113
    c3fa:	2f 0e       	add	r2, r31
    c3fc:	31 1c       	adc	r3, r1
    c3fe:	f1 01       	movw	r30, r2
    c400:	10 82       	st	Z, r1
    c402:	11 82       	std	Z+1, r1	; 0x01
    c404:	12 82       	std	Z+2, r1	; 0x02
    c406:	13 82       	std	Z+3, r1	; 0x03
    c408:	c8 01       	movw	r24, r16
    c40a:	8b 58       	subi	r24, 0x8B	; 139
    c40c:	9f 4f       	sbci	r25, 0xFF	; 255
    c40e:	98 87       	std	Y+8, r25	; 0x08
    c410:	8f 83       	std	Y+7, r24	; 0x07
    c412:	fc 01       	movw	r30, r24
    c414:	10 82       	st	Z, r1
    c416:	11 82       	std	Z+1, r1	; 0x01
    c418:	12 82       	std	Z+2, r1	; 0x02
    c41a:	13 82       	std	Z+3, r1	; 0x03
    c41c:	c8 01       	movw	r24, r16
    c41e:	87 58       	subi	r24, 0x87	; 135
    c420:	9f 4f       	sbci	r25, 0xFF	; 255
    c422:	9a 87       	std	Y+10, r25	; 0x0a
    c424:	89 87       	std	Y+9, r24	; 0x09
    c426:	fc 01       	movw	r30, r24
    c428:	10 82       	st	Z, r1
    c42a:	11 82       	std	Z+1, r1	; 0x01
    c42c:	12 82       	std	Z+2, r1	; 0x02
    c42e:	13 82       	std	Z+3, r1	; 0x03
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
    c430:	eb 85       	ldd	r30, Y+11	; 0x0b
    c432:	fc 85       	ldd	r31, Y+12	; 0x0c
    c434:	c1 84       	ldd	r12, Z+9	; 0x09
    c436:	d2 84       	ldd	r13, Z+10	; 0x0a
    c438:	f2 ed       	ldi	r31, 0xD2	; 210
    c43a:	cf 0e       	add	r12, r31
    c43c:	d1 1c       	adc	r13, r1
    c43e:	f6 01       	movw	r30, r12
    c440:	c0 80       	ld	r12, Z
    c442:	d1 80       	ldd	r13, Z+1	; 0x01
    c444:	e2 80       	ldd	r14, Z+2	; 0x02
    c446:	f3 80       	ldd	r15, Z+3	; 0x03
			
			message->PitchRads = model->PitchRads();
    c448:	f8 01       	movw	r30, r16
    c44a:	c5 86       	std	Z+13, r12	; 0x0d
    c44c:	d6 86       	std	Z+14, r13	; 0x0e
    c44e:	e7 86       	std	Z+15, r14	; 0x0f
    c450:	f0 8a       	std	Z+16, r15	; 0x10
			void YawDerivativeError(float val) { yawDerivativeError = val;}								
																							
		
		
		
			float XNEDLocalFrameCm() const {return xNEDLocalFrame;}
    c452:	eb 85       	ldd	r30, Y+11	; 0x0b
    c454:	fc 85       	ldd	r31, Y+12	; 0x0c
    c456:	c1 84       	ldd	r12, Z+9	; 0x09
    c458:	d2 84       	ldd	r13, Z+10	; 0x0a
    c45a:	f6 01       	movw	r30, r12
    c45c:	c2 a0       	ldd	r12, Z+34	; 0x22
    c45e:	d3 a0       	ldd	r13, Z+35	; 0x23
    c460:	e4 a0       	ldd	r14, Z+36	; 0x24
    c462:	f5 a0       	ldd	r15, Z+37	; 0x25
			message->XNEDLocalFrame = model->XNEDLocalFrameCm();
    c464:	f8 01       	movw	r30, r16
    c466:	c5 82       	std	Z+5, r12	; 0x05
    c468:	d6 82       	std	Z+6, r13	; 0x06
    c46a:	e7 82       	std	Z+7, r14	; 0x07
    c46c:	f0 86       	std	Z+8, r15	; 0x08
			void LongitudeControlBeforeServoLimitsAdjustment(float val) { longitudeControlBeforeServoLimitsAdjustment = val;}

			float LongitudeControl() const {return longitudeControl;}
			void LongitudeControl(float val) { longitudeControl = val;}
				
			float XVelocityFRDCms() const {return xVelocityFRDCms;}
    c46e:	eb 85       	ldd	r30, Y+11	; 0x0b
    c470:	fc 85       	ldd	r31, Y+12	; 0x0c
    c472:	c1 84       	ldd	r12, Z+9	; 0x09
    c474:	d2 84       	ldd	r13, Z+10	; 0x0a
    c476:	f6 01       	movw	r30, r12
    c478:	c2 a8       	ldd	r12, Z+50	; 0x32
    c47a:	d3 a8       	ldd	r13, Z+51	; 0x33
    c47c:	e4 a8       	ldd	r14, Z+52	; 0x34
    c47e:	f5 a8       	ldd	r15, Z+53	; 0x35
//message->XNEDLocalFrame = model->LateralControl();			
			message->XVelocityFRDCms = model->XVelocityFRDCms();
    c480:	f8 01       	movw	r30, r16
    c482:	c1 86       	std	Z+9, r12	; 0x09
    c484:	d2 86       	std	Z+10, r13	; 0x0a
    c486:	e3 86       	std	Z+11, r14	; 0x0b
    c488:	f4 86       	std	Z+12, r15	; 0x0c
			void YawRads(float val) {yawRads = val;}	
				
			float PitchRads() const {return pitchRads;}
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
    c48a:	eb 85       	ldd	r30, Y+11	; 0x0b
    c48c:	fc 85       	ldd	r31, Y+12	; 0x0c
    c48e:	c1 84       	ldd	r12, Z+9	; 0x09
    c490:	d2 84       	ldd	r13, Z+10	; 0x0a
    c492:	fe ec       	ldi	r31, 0xCE	; 206
    c494:	cf 0e       	add	r12, r31
    c496:	d1 1c       	adc	r13, r1
    c498:	f6 01       	movw	r30, r12
    c49a:	c0 80       	ld	r12, Z
    c49c:	d1 80       	ldd	r13, Z+1	; 0x01
    c49e:	e2 80       	ldd	r14, Z+2	; 0x02
    c4a0:	f3 80       	ldd	r15, Z+3	; 0x03

			
			message->RollRads = model->RollRads();
    c4a2:	f8 01       	movw	r30, r16
    c4a4:	c1 8e       	std	Z+25, r12	; 0x19
    c4a6:	d2 8e       	std	Z+26, r13	; 0x1a
    c4a8:	e3 8e       	std	Z+27, r14	; 0x1b
    c4aa:	f4 8e       	std	Z+28, r15	; 0x1c
						
						
						


			float YNEDLocalFrameCm() const {return yNEDLocalFrame;}
    c4ac:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4ae:	fc 85       	ldd	r31, Y+12	; 0x0c
    c4b0:	c1 84       	ldd	r12, Z+9	; 0x09
    c4b2:	d2 84       	ldd	r13, Z+10	; 0x0a
    c4b4:	fe e4       	ldi	r31, 0x4E	; 78
    c4b6:	cf 0e       	add	r12, r31
    c4b8:	d1 1c       	adc	r13, r1
    c4ba:	f6 01       	movw	r30, r12
    c4bc:	c0 80       	ld	r12, Z
    c4be:	d1 80       	ldd	r13, Z+1	; 0x01
    c4c0:	e2 80       	ldd	r14, Z+2	; 0x02
    c4c2:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YNEDLocalFrame = model->YNEDLocalFrameCm();
    c4c4:	f8 01       	movw	r30, r16
    c4c6:	c1 8a       	std	Z+17, r12	; 0x11
    c4c8:	d2 8a       	std	Z+18, r13	; 0x12
    c4ca:	e3 8a       	std	Z+19, r14	; 0x13
    c4cc:	f4 8a       	std	Z+20, r15	; 0x14
			void LateralControlBeforeServoLimitsAdjustment(float val) { lateralControlBeforeServoLimitsAdjustment = val;}

			float LateralControl() const {return lateralControl;}
			void LateralControl(float val) { lateralControl = val;}

			float YVelocityFRDCms() const {return yVelocityFRDCms;}
    c4ce:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4d0:	fc 85       	ldd	r31, Y+12	; 0x0c
    c4d2:	c1 84       	ldd	r12, Z+9	; 0x09
    c4d4:	d2 84       	ldd	r13, Z+10	; 0x0a
    c4d6:	fe e5       	ldi	r31, 0x5E	; 94
    c4d8:	cf 0e       	add	r12, r31
    c4da:	d1 1c       	adc	r13, r1
    c4dc:	f6 01       	movw	r30, r12
    c4de:	c0 80       	ld	r12, Z
    c4e0:	d1 80       	ldd	r13, Z+1	; 0x01
    c4e2:	e2 80       	ldd	r14, Z+2	; 0x02
    c4e4:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YVelocityFRDCms = model->YVelocityFRDCms();
    c4e6:	f8 01       	movw	r30, r16
    c4e8:	c5 8a       	std	Z+21, r12	; 0x15
    c4ea:	d6 8a       	std	Z+22, r13	; 0x16
    c4ec:	e7 8a       	std	Z+23, r14	; 0x17
    c4ee:	f0 8e       	std	Z+24, r15	; 0x18
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
			void ZMagFrd(float val) {zMagFrd = val;}	
				
			float YawRads() const {return yawRads;}
    c4f0:	eb 85       	ldd	r30, Y+11	; 0x0b
    c4f2:	fc 85       	ldd	r31, Y+12	; 0x0c
    c4f4:	c1 84       	ldd	r12, Z+9	; 0x09
    c4f6:	d2 84       	ldd	r13, Z+10	; 0x0a
    c4f8:	f6 ed       	ldi	r31, 0xD6	; 214
    c4fa:	cf 0e       	add	r12, r31
    c4fc:	d1 1c       	adc	r13, r1
    c4fe:	f6 01       	movw	r30, r12
    c500:	c0 80       	ld	r12, Z
    c502:	d1 80       	ldd	r13, Z+1	; 0x01
    c504:	e2 80       	ldd	r14, Z+2	; 0x02
    c506:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			
			message->YawRads = model->YawRads();
    c508:	f8 01       	movw	r30, r16
    c50a:	c1 a2       	std	Z+33, r12	; 0x21
    c50c:	d2 a2       	std	Z+34, r13	; 0x22
    c50e:	e3 a2       	std	Z+35, r14	; 0x23
    c510:	f4 a2       	std	Z+36, r15	; 0x24
			void MainRotorCollectiveControl(float val) { mainRotorControl = val;}

			float MainRotorControlBeforeServoLimitsAdjustment() const {return mainRotorControlBeforeServoLimitsAdjustment;}
			void MainRotorControlBeforeServoLimitsAdjustment(float val) { mainRotorControlBeforeServoLimitsAdjustment = val;}

			float ZVelocityFRDCms() const {return zVelocityMetersPerSecond;}
    c512:	eb 85       	ldd	r30, Y+11	; 0x0b
    c514:	fc 85       	ldd	r31, Y+12	; 0x0c
    c516:	c1 84       	ldd	r12, Z+9	; 0x09
    c518:	d2 84       	ldd	r13, Z+10	; 0x0a
    c51a:	fe e8       	ldi	r31, 0x8E	; 142
    c51c:	cf 0e       	add	r12, r31
    c51e:	d1 1c       	adc	r13, r1
    c520:	f6 01       	movw	r30, r12
    c522:	c0 80       	ld	r12, Z
    c524:	d1 80       	ldd	r13, Z+1	; 0x01
    c526:	e2 80       	ldd	r14, Z+2	; 0x02
    c528:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZVelocityFRDCms = (model->ZVelocityFRDCms());
    c52a:	f8 01       	movw	r30, r16
    c52c:	c5 8e       	std	Z+29, r12	; 0x1d
    c52e:	d6 8e       	std	Z+30, r13	; 0x1e
    c530:	e7 8e       	std	Z+31, r14	; 0x1f
    c532:	f0 a2       	std	Z+32, r15	; 0x20
			/*
			float AltitudeMetersAgl() const { return altitudeMetersAgl; }
			void AltitudeMetersAgl(float val) { altitudeMetersAgl = val; }
			*/

			float ZNEDLocalFrameCm() const { return zNEDLocalFrame; }
    c534:	eb 85       	ldd	r30, Y+11	; 0x0b
    c536:	fc 85       	ldd	r31, Y+12	; 0x0c
    c538:	c1 84       	ldd	r12, Z+9	; 0x09
    c53a:	d2 84       	ldd	r13, Z+10	; 0x0a
    c53c:	fe e7       	ldi	r31, 0x7E	; 126
    c53e:	cf 0e       	add	r12, r31
    c540:	d1 1c       	adc	r13, r1
    c542:	f6 01       	movw	r30, r12
    c544:	c0 80       	ld	r12, Z
    c546:	d1 80       	ldd	r13, Z+1	; 0x01
    c548:	e2 80       	ldd	r14, Z+2	; 0x02
    c54a:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZNEDLocalFrame = model->ZNEDLocalFrameCm();
    c54c:	f8 01       	movw	r30, r16
    c54e:	c5 a2       	std	Z+37, r12	; 0x25
    c550:	d6 a2       	std	Z+38, r13	; 0x26
    c552:	e7 a2       	std	Z+39, r14	; 0x27
    c554:	f0 a6       	std	Z+40, r15	; 0x28

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
			void RollAngularVelocityRadsPerSecond(float val) {rollAngularVelocityRs = val;}		
				
				
			float XAccelFrdMss() const {return xAccelFrdMss;}
    c556:	eb 85       	ldd	r30, Y+11	; 0x0b
    c558:	fc 85       	ldd	r31, Y+12	; 0x0c
    c55a:	c1 84       	ldd	r12, Z+9	; 0x09
    c55c:	d2 84       	ldd	r13, Z+10	; 0x0a
    c55e:	f6 ee       	ldi	r31, 0xE6	; 230
    c560:	cf 0e       	add	r12, r31
    c562:	d1 1c       	adc	r13, r1
    c564:	f6 01       	movw	r30, r12
    c566:	c0 80       	ld	r12, Z
    c568:	d1 80       	ldd	r13, Z+1	; 0x01
    c56a:	e2 80       	ldd	r14, Z+2	; 0x02
    c56c:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			
			message->XAccelFrdMss = model->XAccelFrdMss();
    c56e:	f8 01       	movw	r30, r16
    c570:	c1 a6       	std	Z+41, r12	; 0x29
    c572:	d2 a6       	std	Z+42, r13	; 0x2a
    c574:	e3 a6       	std	Z+43, r14	; 0x2b
    c576:	f4 a6       	std	Z+44, r15	; 0x2c
			void XAccelFrdMss(float val) {xAccelFrdMss = val;}

			float YAccelFrdMss() const {return yAccelFrdMss;}
    c578:	eb 85       	ldd	r30, Y+11	; 0x0b
    c57a:	fc 85       	ldd	r31, Y+12	; 0x0c
    c57c:	c1 84       	ldd	r12, Z+9	; 0x09
    c57e:	d2 84       	ldd	r13, Z+10	; 0x0a
    c580:	fa ee       	ldi	r31, 0xEA	; 234
    c582:	cf 0e       	add	r12, r31
    c584:	d1 1c       	adc	r13, r1
    c586:	f6 01       	movw	r30, r12
    c588:	c0 80       	ld	r12, Z
    c58a:	d1 80       	ldd	r13, Z+1	; 0x01
    c58c:	e2 80       	ldd	r14, Z+2	; 0x02
    c58e:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YAccelFrdMss = model->YAccelFrdMss();
    c590:	f8 01       	movw	r30, r16
    c592:	c5 a6       	std	Z+45, r12	; 0x2d
    c594:	d6 a6       	std	Z+46, r13	; 0x2e
    c596:	e7 a6       	std	Z+47, r14	; 0x2f
    c598:	f0 aa       	std	Z+48, r15	; 0x30
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
    c59a:	eb 85       	ldd	r30, Y+11	; 0x0b
    c59c:	fc 85       	ldd	r31, Y+12	; 0x0c
    c59e:	c1 84       	ldd	r12, Z+9	; 0x09
    c5a0:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5a2:	fe ee       	ldi	r31, 0xEE	; 238
    c5a4:	cf 0e       	add	r12, r31
    c5a6:	d1 1c       	adc	r13, r1
    c5a8:	f6 01       	movw	r30, r12
    c5aa:	c0 80       	ld	r12, Z
    c5ac:	d1 80       	ldd	r13, Z+1	; 0x01
    c5ae:	e2 80       	ldd	r14, Z+2	; 0x02
    c5b0:	f3 80       	ldd	r15, Z+3	; 0x03
			message->ZAccelFrdMss = model->ZAccelFrdMss();
    c5b2:	f8 01       	movw	r30, r16
    c5b4:	c1 aa       	std	Z+49, r12	; 0x31
    c5b6:	d2 aa       	std	Z+50, r13	; 0x32
    c5b8:	e3 aa       	std	Z+51, r14	; 0x33
    c5ba:	f4 aa       	std	Z+52, r15	; 0x34
			CommunicationMethods  CommunicationMethod() const {return communicationMethod;}
			void CommunicationMethod( CommunicationMethods val ) { communicationMethod = val;}				
				
				
				
			float YawAngularVelocityRadsPerSecond() const {return yawAngularVelocityRs;}
    c5bc:	eb 85       	ldd	r30, Y+11	; 0x0b
    c5be:	fc 85       	ldd	r31, Y+12	; 0x0c
    c5c0:	c1 84       	ldd	r12, Z+9	; 0x09
    c5c2:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5c4:	f2 ee       	ldi	r31, 0xE2	; 226
    c5c6:	cf 0e       	add	r12, r31
    c5c8:	d1 1c       	adc	r13, r1
    c5ca:	f6 01       	movw	r30, r12
    c5cc:	c0 80       	ld	r12, Z
    c5ce:	d1 80       	ldd	r13, Z+1	; 0x01
    c5d0:	e2 80       	ldd	r14, Z+2	; 0x02
    c5d2:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YawAngularVelocityRadsPerSecond = model->YawAngularVelocityRadsPerSecond();
    c5d4:	f8 01       	movw	r30, r16
    c5d6:	c5 aa       	std	Z+53, r12	; 0x35
    c5d8:	d6 aa       	std	Z+54, r13	; 0x36
    c5da:	e7 aa       	std	Z+55, r14	; 0x37
    c5dc:	f0 ae       	std	Z+56, r15	; 0x38
			void YawAngularVelocityRadsPerSecond(float val) {yawAngularVelocityRs = val;}
				
			float PitchAngularVelocityRadsPerSecond() const {return pitchAngularVelocityRs;}
    c5de:	eb 85       	ldd	r30, Y+11	; 0x0b
    c5e0:	fc 85       	ldd	r31, Y+12	; 0x0c
    c5e2:	c1 84       	ldd	r12, Z+9	; 0x09
    c5e4:	d2 84       	ldd	r13, Z+10	; 0x0a
    c5e6:	fa ed       	ldi	r31, 0xDA	; 218
    c5e8:	cf 0e       	add	r12, r31
    c5ea:	d1 1c       	adc	r13, r1
    c5ec:	f6 01       	movw	r30, r12
    c5ee:	c0 80       	ld	r12, Z
    c5f0:	d1 80       	ldd	r13, Z+1	; 0x01
    c5f2:	e2 80       	ldd	r14, Z+2	; 0x02
    c5f4:	f3 80       	ldd	r15, Z+3	; 0x03
			message->PitchAngularVelocityRadsPerSecond = model->PitchAngularVelocityRadsPerSecond();
    c5f6:	f8 01       	movw	r30, r16
    c5f8:	c1 ae       	std	Z+57, r12	; 0x39
    c5fa:	d2 ae       	std	Z+58, r13	; 0x3a
    c5fc:	e3 ae       	std	Z+59, r14	; 0x3b
    c5fe:	f4 ae       	std	Z+60, r15	; 0x3c
			void PitchAngularVelocityRadsPerSecond(float val) {pitchAngularVelocityRs = val;}

			float RollAngularVelocityRadsPerSecond() const {return rollAngularVelocityRs;}
    c600:	eb 85       	ldd	r30, Y+11	; 0x0b
    c602:	fc 85       	ldd	r31, Y+12	; 0x0c
    c604:	c1 84       	ldd	r12, Z+9	; 0x09
    c606:	d2 84       	ldd	r13, Z+10	; 0x0a
    c608:	fe ed       	ldi	r31, 0xDE	; 222
    c60a:	cf 0e       	add	r12, r31
    c60c:	d1 1c       	adc	r13, r1
    c60e:	f6 01       	movw	r30, r12
    c610:	c0 80       	ld	r12, Z
    c612:	d1 80       	ldd	r13, Z+1	; 0x01
    c614:	e2 80       	ldd	r14, Z+2	; 0x02
    c616:	f3 80       	ldd	r15, Z+3	; 0x03
			message->RollAngularVelocityRadsPerSecond = model->RollAngularVelocityRadsPerSecond();
    c618:	e9 81       	ldd	r30, Y+1	; 0x01
    c61a:	fa 81       	ldd	r31, Y+2	; 0x02
    c61c:	c0 82       	st	Z, r12
    c61e:	d1 82       	std	Z+1, r13	; 0x01
    c620:	e2 82       	std	Z+2, r14	; 0x02
    c622:	f3 82       	std	Z+3, r15	; 0x03
			void YAccelFrdMss(float val) {yAccelFrdMss = val;}
				
			float ZAccelFrdMss() const {return zAccelFrdMss;}
			void ZAccelFrdMss(float val) {zAccelFrdMss = val;}	
				
			float XMagFrd() const {return xMagFrd;}
    c624:	eb 85       	ldd	r30, Y+11	; 0x0b
    c626:	fc 85       	ldd	r31, Y+12	; 0x0c
    c628:	e1 84       	ldd	r14, Z+9	; 0x09
    c62a:	f2 84       	ldd	r15, Z+10	; 0x0a
    c62c:	f2 ef       	ldi	r31, 0xF2	; 242
    c62e:	ef 0e       	add	r14, r31
    c630:	f1 1c       	adc	r15, r1
    c632:	f7 01       	movw	r30, r14
    c634:	c0 80       	ld	r12, Z
    c636:	d1 80       	ldd	r13, Z+1	; 0x01
    c638:	e2 80       	ldd	r14, Z+2	; 0x02
    c63a:	f3 80       	ldd	r15, Z+3	; 0x03
			
			
			message->XMagFrd = model->XMagFrd();
    c63c:	fb 01       	movw	r30, r22
    c63e:	c0 82       	st	Z, r12
    c640:	d1 82       	std	Z+1, r13	; 0x01
    c642:	e2 82       	std	Z+2, r14	; 0x02
    c644:	f3 82       	std	Z+3, r15	; 0x03
			void XMagFrd(float val) {xMagFrd = val;}

			float YMagFrd() const {return yMagFrd;}
    c646:	eb 85       	ldd	r30, Y+11	; 0x0b
    c648:	fc 85       	ldd	r31, Y+12	; 0x0c
    c64a:	61 85       	ldd	r22, Z+9	; 0x09
    c64c:	72 85       	ldd	r23, Z+10	; 0x0a
    c64e:	6a 50       	subi	r22, 0x0A	; 10
    c650:	7f 4f       	sbci	r23, 0xFF	; 255
    c652:	fb 01       	movw	r30, r22
    c654:	c0 80       	ld	r12, Z
    c656:	d1 80       	ldd	r13, Z+1	; 0x01
    c658:	e2 80       	ldd	r14, Z+2	; 0x02
    c65a:	f3 80       	ldd	r15, Z+3	; 0x03
			message->YMagFrd = model->YMagFrd();
    c65c:	fa 01       	movw	r30, r20
    c65e:	c0 82       	st	Z, r12
    c660:	d1 82       	std	Z+1, r13	; 0x01
    c662:	e2 82       	std	Z+2, r14	; 0x02
    c664:	f3 82       	std	Z+3, r15	; 0x03
			void YMagFrd(float val) {yMagFrd = val;}

			float ZMagFrd() const {return zMagFrd;}
    c666:	eb 85       	ldd	r30, Y+11	; 0x0b
    c668:	fc 85       	ldd	r31, Y+12	; 0x0c
    c66a:	41 85       	ldd	r20, Z+9	; 0x09
    c66c:	52 85       	ldd	r21, Z+10	; 0x0a
    c66e:	46 50       	subi	r20, 0x06	; 6
    c670:	5f 4f       	sbci	r21, 0xFF	; 255
    c672:	fa 01       	movw	r30, r20
    c674:	40 81       	ld	r20, Z
    c676:	51 81       	ldd	r21, Z+1	; 0x01
    c678:	62 81       	ldd	r22, Z+2	; 0x02
    c67a:	73 81       	ldd	r23, Z+3	; 0x03
			message->ZMagFrd = model->ZMagFrd();
    c67c:	f9 01       	movw	r30, r18
    c67e:	40 83       	st	Z, r20
    c680:	51 83       	std	Z+1, r21	; 0x01
    c682:	62 83       	std	Z+2, r22	; 0x02
    c684:	73 83       	std	Z+3, r23	; 0x03
			void PitchRads(float val) {pitchRads = val;}
				
			float RollRads() const {return rollRads;}
			void RollRads(float val) {rollRads = val;}	

			long XEcefCm() const {return xEcefCm;}
    c686:	eb 85       	ldd	r30, Y+11	; 0x0b
    c688:	fc 85       	ldd	r31, Y+12	; 0x0c
    c68a:	21 85       	ldd	r18, Z+9	; 0x09
    c68c:	32 85       	ldd	r19, Z+10	; 0x0a
    c68e:	22 50       	subi	r18, 0x02	; 2
    c690:	3f 4f       	sbci	r19, 0xFF	; 255
    c692:	f9 01       	movw	r30, r18
    c694:	40 81       	ld	r20, Z
    c696:	51 81       	ldd	r21, Z+1	; 0x01
    c698:	62 81       	ldd	r22, Z+2	; 0x02
    c69a:	73 81       	ldd	r23, Z+3	; 0x03
/*
message->XMagFrd = model->off1();
message->YMagFrd = model->off2();
message->ZMagFrd = model->off3();			
*/
			message->XEcefCm = model->XEcefCm();
    c69c:	ed 85       	ldd	r30, Y+13	; 0x0d
    c69e:	fe 85       	ldd	r31, Y+14	; 0x0e
    c6a0:	40 83       	st	Z, r20
    c6a2:	51 83       	std	Z+1, r21	; 0x01
    c6a4:	62 83       	std	Z+2, r22	; 0x02
    c6a6:	73 83       	std	Z+3, r23	; 0x03
			void XEcefCm(long val) {xEcefCm = val;}
			
			long YEcefCm() const {return yEcefCm;}
    c6a8:	eb 85       	ldd	r30, Y+11	; 0x0b
    c6aa:	fc 85       	ldd	r31, Y+12	; 0x0c
    c6ac:	81 85       	ldd	r24, Z+9	; 0x09
    c6ae:	92 85       	ldd	r25, Z+10	; 0x0a
    c6b0:	8e 5f       	subi	r24, 0xFE	; 254
    c6b2:	9e 4f       	sbci	r25, 0xFE	; 254
    c6b4:	fc 01       	movw	r30, r24
    c6b6:	40 81       	ld	r20, Z
    c6b8:	51 81       	ldd	r21, Z+1	; 0x01
    c6ba:	62 81       	ldd	r22, Z+2	; 0x02
    c6bc:	73 81       	ldd	r23, Z+3	; 0x03
			message->YEcefCm = model->YEcefCm();
    c6be:	4d 93       	st	X+, r20
    c6c0:	5d 93       	st	X+, r21
    c6c2:	6d 93       	st	X+, r22
    c6c4:	7c 93       	st	X, r23
    c6c6:	13 97       	sbiw	r26, 0x03	; 3
			void YEcefCm(long val) {yEcefCm = val;}
				
			long ZEcefCm() const {return zEcefCm;}
    c6c8:	eb 85       	ldd	r30, Y+11	; 0x0b
    c6ca:	fc 85       	ldd	r31, Y+12	; 0x0c
    c6cc:	a1 85       	ldd	r26, Z+9	; 0x09
    c6ce:	b2 85       	ldd	r27, Z+10	; 0x0a
    c6d0:	aa 5f       	subi	r26, 0xFA	; 250
    c6d2:	be 4f       	sbci	r27, 0xFE	; 254
    c6d4:	8d 91       	ld	r24, X+
    c6d6:	9d 91       	ld	r25, X+
    c6d8:	0d 90       	ld	r0, X+
    c6da:	bc 91       	ld	r27, X
    c6dc:	a0 2d       	mov	r26, r0
			message->ZEcefCm = model->ZEcefCm();
    c6de:	ef 85       	ldd	r30, Y+15	; 0x0f
    c6e0:	f8 89       	ldd	r31, Y+16	; 0x10
    c6e2:	80 83       	st	Z, r24
    c6e4:	91 83       	std	Z+1, r25	; 0x01
    c6e6:	a2 83       	std	Z+2, r26	; 0x02
    c6e8:	b3 83       	std	Z+3, r27	; 0x03
			void ZEcefCm(long val) {zEcefCm = val;}				
				
			long XVEcefCms() const {return xVEcefCms;}
    c6ea:	ab 85       	ldd	r26, Y+11	; 0x0b
    c6ec:	bc 85       	ldd	r27, Y+12	; 0x0c
    c6ee:	19 96       	adiw	r26, 0x09	; 9
    c6f0:	ed 91       	ld	r30, X+
    c6f2:	fc 91       	ld	r31, X
    c6f4:	1a 97       	sbiw	r26, 0x0a	; 10
    c6f6:	e6 5f       	subi	r30, 0xF6	; 246
    c6f8:	fe 4f       	sbci	r31, 0xFE	; 254
    c6fa:	80 81       	ld	r24, Z
    c6fc:	91 81       	ldd	r25, Z+1	; 0x01
    c6fe:	a2 81       	ldd	r26, Z+2	; 0x02
    c700:	b3 81       	ldd	r27, Z+3	; 0x03
			message->XVEcefCms = model->XVEcefCms();
    c702:	f5 01       	movw	r30, r10
    c704:	80 83       	st	Z, r24
    c706:	91 83       	std	Z+1, r25	; 0x01
    c708:	a2 83       	std	Z+2, r26	; 0x02
    c70a:	b3 83       	std	Z+3, r27	; 0x03
			void XVEcefCms(long val) {xVEcefCms = val;}	
				
			long YVEcefCms() const {return yVEcefCms;}
    c70c:	ab 85       	ldd	r26, Y+11	; 0x0b
    c70e:	bc 85       	ldd	r27, Y+12	; 0x0c
    c710:	19 96       	adiw	r26, 0x09	; 9
    c712:	ed 91       	ld	r30, X+
    c714:	fc 91       	ld	r31, X
    c716:	1a 97       	sbiw	r26, 0x0a	; 10
    c718:	e2 5f       	subi	r30, 0xF2	; 242
    c71a:	fe 4f       	sbci	r31, 0xFE	; 254
    c71c:	80 81       	ld	r24, Z
    c71e:	91 81       	ldd	r25, Z+1	; 0x01
    c720:	a2 81       	ldd	r26, Z+2	; 0x02
    c722:	b3 81       	ldd	r27, Z+3	; 0x03
			message->YVEcefCms = model->YVEcefCms();
    c724:	f4 01       	movw	r30, r8
    c726:	80 83       	st	Z, r24
    c728:	91 83       	std	Z+1, r25	; 0x01
    c72a:	a2 83       	std	Z+2, r26	; 0x02
    c72c:	b3 83       	std	Z+3, r27	; 0x03
			void YVEcefCms(long val) {yVEcefCms = val;}
				
			long ZVEcefCms() const {return zVEcefCms;}
    c72e:	ab 85       	ldd	r26, Y+11	; 0x0b
    c730:	bc 85       	ldd	r27, Y+12	; 0x0c
    c732:	19 96       	adiw	r26, 0x09	; 9
    c734:	ed 91       	ld	r30, X+
    c736:	fc 91       	ld	r31, X
    c738:	1a 97       	sbiw	r26, 0x0a	; 10
    c73a:	ee 5e       	subi	r30, 0xEE	; 238
    c73c:	fe 4f       	sbci	r31, 0xFE	; 254
    c73e:	80 81       	ld	r24, Z
    c740:	91 81       	ldd	r25, Z+1	; 0x01
    c742:	a2 81       	ldd	r26, Z+2	; 0x02
    c744:	b3 81       	ldd	r27, Z+3	; 0x03
			message->ZVEcefCms = model->ZVEcefCms();
    c746:	f3 01       	movw	r30, r6
    c748:	80 83       	st	Z, r24
    c74a:	91 83       	std	Z+1, r25	; 0x01
    c74c:	a2 83       	std	Z+2, r26	; 0x02
    c74e:	b3 83       	std	Z+3, r27	; 0x03
			void ZVEcefCms(long val) {zVEcefCms = val;}		
				
			float PressureMillibars() const {return pressureMillibars;}
    c750:	ab 85       	ldd	r26, Y+11	; 0x0b
    c752:	bc 85       	ldd	r27, Y+12	; 0x0c
    c754:	19 96       	adiw	r26, 0x09	; 9
    c756:	ed 91       	ld	r30, X+
    c758:	fc 91       	ld	r31, X
    c75a:	1a 97       	sbiw	r26, 0x0a	; 10
    c75c:	ea 5e       	subi	r30, 0xEA	; 234
    c75e:	fe 4f       	sbci	r31, 0xFE	; 254
    c760:	80 81       	ld	r24, Z
    c762:	91 81       	ldd	r25, Z+1	; 0x01
    c764:	a2 81       	ldd	r26, Z+2	; 0x02
    c766:	b3 81       	ldd	r27, Z+3	; 0x03
			message->PressureMillibars = model->PressureMillibars();
    c768:	f2 01       	movw	r30, r4
    c76a:	80 83       	st	Z, r24
    c76c:	91 83       	std	Z+1, r25	; 0x01
    c76e:	a2 83       	std	Z+2, r26	; 0x02
    c770:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
    c772:	ab 85       	ldd	r26, Y+11	; 0x0b
    c774:	bc 85       	ldd	r27, Y+12	; 0x0c
    c776:	19 96       	adiw	r26, 0x09	; 9
    c778:	ed 91       	ld	r30, X+
    c77a:	fc 91       	ld	r31, X
    c77c:	1a 97       	sbiw	r26, 0x0a	; 10
    c77e:	ee 54       	subi	r30, 0x4E	; 78
    c780:	ff 4f       	sbci	r31, 0xFF	; 255
    c782:	80 81       	ld	r24, Z
    c784:	91 81       	ldd	r25, Z+1	; 0x01
    c786:	a2 81       	ldd	r26, Z+2	; 0x02
    c788:	b3 81       	ldd	r27, Z+3	; 0x03
			
			
			
			message->ChecksumErrors = model->ChecksumErrors();
    c78a:	f1 01       	movw	r30, r2
    c78c:	80 83       	st	Z, r24
    c78e:	91 83       	std	Z+1, r25	; 0x01
    c790:	a2 83       	std	Z+2, r26	; 0x02
    c792:	b3 83       	std	Z+3, r27	; 0x03

			float LongitudeDegrees() const {return longitudeDegrees;}
			void LongitudeDegrees(float val) { longitudeDegrees = val;}						
						
						
			long Timeouts() const {return timeouts; }
    c794:	ab 85       	ldd	r26, Y+11	; 0x0b
    c796:	bc 85       	ldd	r27, Y+12	; 0x0c
    c798:	19 96       	adiw	r26, 0x09	; 9
    c79a:	ed 91       	ld	r30, X+
    c79c:	fc 91       	ld	r31, X
    c79e:	1a 97       	sbiw	r26, 0x0a	; 10
    c7a0:	e6 55       	subi	r30, 0x56	; 86
    c7a2:	ff 4f       	sbci	r31, 0xFF	; 255
    c7a4:	80 81       	ld	r24, Z
    c7a6:	91 81       	ldd	r25, Z+1	; 0x01
    c7a8:	a2 81       	ldd	r26, Z+2	; 0x02
    c7aa:	b3 81       	ldd	r27, Z+3	; 0x03
			message->Timeouts = model->Timeouts();
    c7ac:	eb 81       	ldd	r30, Y+3	; 0x03
    c7ae:	fc 81       	ldd	r31, Y+4	; 0x04
    c7b0:	80 83       	st	Z, r24
    c7b2:	91 83       	std	Z+1, r25	; 0x01
    c7b4:	a2 83       	std	Z+2, r26	; 0x02
    c7b6:	b3 83       	std	Z+3, r27	; 0x03
			void Timeouts(long val) { timeouts = val; }
			
			long UnrecognizedMsgTypes() const {return unrecognizedMsgTypes; }
    c7b8:	ab 85       	ldd	r26, Y+11	; 0x0b
    c7ba:	bc 85       	ldd	r27, Y+12	; 0x0c
    c7bc:	19 96       	adiw	r26, 0x09	; 9
    c7be:	ed 91       	ld	r30, X+
    c7c0:	fc 91       	ld	r31, X
    c7c2:	1a 97       	sbiw	r26, 0x0a	; 10
    c7c4:	e2 55       	subi	r30, 0x52	; 82
    c7c6:	ff 4f       	sbci	r31, 0xFF	; 255
    c7c8:	80 81       	ld	r24, Z
    c7ca:	91 81       	ldd	r25, Z+1	; 0x01
    c7cc:	a2 81       	ldd	r26, Z+2	; 0x02
    c7ce:	b3 81       	ldd	r27, Z+3	; 0x03
			message->UnrecognizedMsgTypes = model->UnrecognizedMsgTypes();
    c7d0:	ed 81       	ldd	r30, Y+5	; 0x05
    c7d2:	fe 81       	ldd	r31, Y+6	; 0x06
    c7d4:	80 83       	st	Z, r24
    c7d6:	91 83       	std	Z+1, r25	; 0x01
    c7d8:	a2 83       	std	Z+2, r26	; 0x02
    c7da:	b3 83       	std	Z+3, r27	; 0x03
			void UnrecognizedMsgTypes(long val) { unrecognizedMsgTypes = val; }
			
			long ChecksumErrors() const {return checksumErrors; }
			void ChecksumErrors(long val) { checksumErrors = val; }
			
			long BlownFrames() const {return numOfFramesBlown;}
    c7dc:	ab 85       	ldd	r26, Y+11	; 0x0b
    c7de:	bc 85       	ldd	r27, Y+12	; 0x0c
    c7e0:	19 96       	adiw	r26, 0x09	; 9
    c7e2:	ed 91       	ld	r30, X+
    c7e4:	fc 91       	ld	r31, X
    c7e6:	1a 97       	sbiw	r26, 0x0a	; 10
    c7e8:	ea 54       	subi	r30, 0x4A	; 74
    c7ea:	ff 4f       	sbci	r31, 0xFF	; 255
    c7ec:	80 81       	ld	r24, Z
    c7ee:	91 81       	ldd	r25, Z+1	; 0x01
    c7f0:	a2 81       	ldd	r26, Z+2	; 0x02
    c7f2:	b3 81       	ldd	r27, Z+3	; 0x03
			message->NumOfBlownFrames = model->BlownFrames();
    c7f4:	ef 81       	ldd	r30, Y+7	; 0x07
    c7f6:	f8 85       	ldd	r31, Y+8	; 0x08
    c7f8:	80 83       	st	Z, r24
    c7fa:	91 83       	std	Z+1, r25	; 0x01
    c7fc:	a2 83       	std	Z+2, r26	; 0x02
    c7fe:	b3 83       	std	Z+3, r27	; 0x03
			void BlownFrames( long val ) { numOfFramesBlown = val;}
				
			long SerialCommunicationBufferOverruns() const {return serialCommunicationBufferOverruns;}
    c800:	ab 85       	ldd	r26, Y+11	; 0x0b
    c802:	bc 85       	ldd	r27, Y+12	; 0x0c
    c804:	19 96       	adiw	r26, 0x09	; 9
    c806:	ed 91       	ld	r30, X+
    c808:	fc 91       	ld	r31, X
    c80a:	1a 97       	sbiw	r26, 0x0a	; 10
    c80c:	e6 54       	subi	r30, 0x46	; 70
    c80e:	ff 4f       	sbci	r31, 0xFF	; 255
    c810:	80 81       	ld	r24, Z
    c812:	91 81       	ldd	r25, Z+1	; 0x01
    c814:	a2 81       	ldd	r26, Z+2	; 0x02
    c816:	b3 81       	ldd	r27, Z+3	; 0x03
			message->SerialCommunicationBufferOverruns = model->SerialCommunicationBufferOverruns();
    c818:	e9 85       	ldd	r30, Y+9	; 0x09
    c81a:	fa 85       	ldd	r31, Y+10	; 0x0a
    c81c:	80 83       	st	Z, r24
    c81e:	91 83       	std	Z+1, r25	; 0x01
    c820:	a2 83       	std	Z+2, r26	; 0x02
    c822:	b3 83       	std	Z+3, r27	; 0x03
			
			if (radioInterface->transmit(message) != 0)
    c824:	b8 01       	movw	r22, r16
    c826:	ab 85       	ldd	r26, Y+11	; 0x0b
    c828:	bc 85       	ldd	r27, Y+12	; 0x0c
    c82a:	17 96       	adiw	r26, 0x07	; 7
    c82c:	8d 91       	ld	r24, X+
    c82e:	9c 91       	ld	r25, X
    c830:	18 97       	sbiw	r26, 0x08	; 8
    c832:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <_ZN10helicopter10interfaces29GroundControlStationInterface8transmitEPNS_8messages7MessageE>
    c836:	89 2b       	or	r24, r25
    c838:	99 f0       	breq	.+38     	; 0xc860 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7ac>
			{
				model->SerialCommunicationBufferOverruns(model->SerialCommunicationBufferOverruns()+1);
    c83a:	ab 85       	ldd	r26, Y+11	; 0x0b
    c83c:	bc 85       	ldd	r27, Y+12	; 0x0c
    c83e:	19 96       	adiw	r26, 0x09	; 9
    c840:	ed 91       	ld	r30, X+
    c842:	fc 91       	ld	r31, X
    c844:	1a 97       	sbiw	r26, 0x0a	; 10
			void SerialCommunicationBufferOverruns( long val ) { serialCommunicationBufferOverruns = val;}				
    c846:	e6 54       	subi	r30, 0x46	; 70
    c848:	ff 4f       	sbci	r31, 0xFF	; 255
    c84a:	80 81       	ld	r24, Z
    c84c:	91 81       	ldd	r25, Z+1	; 0x01
    c84e:	a2 81       	ldd	r26, Z+2	; 0x02
    c850:	b3 81       	ldd	r27, Z+3	; 0x03
    c852:	01 96       	adiw	r24, 0x01	; 1
    c854:	a1 1d       	adc	r26, r1
    c856:	b1 1d       	adc	r27, r1
    c858:	80 83       	st	Z, r24
    c85a:	91 83       	std	Z+1, r25	; 0x01
    c85c:	a2 83       	std	Z+2, r26	; 0x02
    c85e:	b3 83       	std	Z+3, r27	; 0x03
			}
	
			delete message;
    c860:	01 15       	cp	r16, r1
    c862:	11 05       	cpc	r17, r1
    c864:	41 f0       	breq	.+16     	; 0xc876 <_ZN10helicopter5tasks21TransmitTelemetryTask11runTaskImplEv+0x7c2>
    c866:	d8 01       	movw	r26, r16
    c868:	ed 91       	ld	r30, X+
    c86a:	fc 91       	ld	r31, X
    c86c:	02 80       	ldd	r0, Z+2	; 0x02
    c86e:	f3 81       	ldd	r31, Z+3	; 0x03
    c870:	e0 2d       	mov	r30, r0
    c872:	c8 01       	movw	r24, r16
    c874:	19 95       	eicall
		}
    c876:	60 96       	adiw	r28, 0x10	; 16
    c878:	0f b6       	in	r0, 0x3f	; 63
    c87a:	f8 94       	cli
    c87c:	de bf       	out	0x3e, r29	; 62
    c87e:	0f be       	out	0x3f, r0	; 63
    c880:	cd bf       	out	0x3d, r28	; 61
    c882:	df 91       	pop	r29
    c884:	cf 91       	pop	r28
    c886:	1f 91       	pop	r17
    c888:	0f 91       	pop	r16
    c88a:	ff 90       	pop	r15
    c88c:	ef 90       	pop	r14
    c88e:	df 90       	pop	r13
    c890:	cf 90       	pop	r12
    c892:	bf 90       	pop	r11
    c894:	af 90       	pop	r10
    c896:	9f 90       	pop	r9
    c898:	8f 90       	pop	r8
    c89a:	7f 90       	pop	r7
    c89c:	6f 90       	pop	r6
    c89e:	5f 90       	pop	r5
    c8a0:	4f 90       	pop	r4
    c8a2:	3f 90       	pop	r3
    c8a4:	2f 90       	pop	r2
    c8a6:	08 95       	ret

0000c8a8 <_ZN10helicopter5tasks21TransmitTelemetryTaskC1EPNS_10interfaces29GroundControlStationInterfaceEPNS_5model11SystemModelENS1_10DATATOSENDEii>:

#include <math.h>
#include <avr/io.h>
using namespace helicopter::tasks;

TransmitTelemetryTask::TransmitTelemetryTask(GroundControlStationInterface *radioInterface, SystemModel *model, DATATOSEND dataToSend, int delay, int period) :
    c8a8:	9f 92       	push	r9
    c8aa:	af 92       	push	r10
    c8ac:	bf 92       	push	r11
    c8ae:	cf 92       	push	r12
    c8b0:	df 92       	push	r13
    c8b2:	ef 92       	push	r14
    c8b4:	ff 92       	push	r15
    c8b6:	0f 93       	push	r16
    c8b8:	1f 93       	push	r17
    c8ba:	cf 93       	push	r28
    c8bc:	df 93       	push	r29
    c8be:	ec 01       	movw	r28, r24
    c8c0:	5b 01       	movw	r10, r22
    c8c2:	6a 01       	movw	r12, r20
    c8c4:	92 2e       	mov	r9, r18
    c8c6:	b8 01       	movw	r22, r16
    c8c8:	a7 01       	movw	r20, r14
	Task(delay, period),
	radioInterface(radioInterface),
	model(model),
	dataToSend(dataToSend)
    c8ca:	0e 94 41 60 	call	0xc082	; 0xc082 <_ZN10helicopter5tasks4TaskC1Eii>
    c8ce:	84 e8       	ldi	r24, 0x84	; 132
    c8d0:	93 e0       	ldi	r25, 0x03	; 3
    c8d2:	99 83       	std	Y+1, r25	; 0x01
    c8d4:	88 83       	st	Y, r24
    c8d6:	b8 86       	std	Y+8, r11	; 0x08
    c8d8:	af 82       	std	Y+7, r10	; 0x07
    c8da:	da 86       	std	Y+10, r13	; 0x0a
    c8dc:	c9 86       	std	Y+9, r12	; 0x09
    c8de:	9b 86       	std	Y+11, r9	; 0x0b
{
	
}
    c8e0:	df 91       	pop	r29
    c8e2:	cf 91       	pop	r28
    c8e4:	1f 91       	pop	r17
    c8e6:	0f 91       	pop	r16
    c8e8:	ff 90       	pop	r15
    c8ea:	ef 90       	pop	r14
    c8ec:	df 90       	pop	r13
    c8ee:	cf 90       	pop	r12
    c8f0:	bf 90       	pop	r11
    c8f2:	af 90       	pop	r10
    c8f4:	9f 90       	pop	r9
    c8f6:	08 95       	ret

0000c8f8 <_Znwj>:
#include <CommonHeader.h>


void * operator new(size_t size)
{
	return malloc(size);
    c8f8:	0e 94 25 70 	call	0xe04a	; 0xe04a <malloc>
}
    c8fc:	08 95       	ret

0000c8fe <_ZdlPv>:

void operator delete(void * ptr)
{
	if (ptr != NULL)
    c8fe:	00 97       	sbiw	r24, 0x00	; 0
    c900:	11 f0       	breq	.+4      	; 0xc906 <_ZdlPv+0x8>
	{
		free(ptr);
    c902:	0e 94 c0 70 	call	0xe180	; 0xe180 <free>
    c906:	08 95       	ret

0000c908 <_Znaj>:
	}
}

void * operator new[](size_t size)
{
	return malloc(size);
    c908:	0e 94 25 70 	call	0xe04a	; 0xe04a <malloc>
}
    c90c:	08 95       	ret

0000c90e <_ZdaPv>:

void operator delete[](void * ptr)
{
	if(ptr != NULL)
    c90e:	00 97       	sbiw	r24, 0x00	; 0
    c910:	11 f0       	breq	.+4      	; 0xc916 <_ZdaPv+0x8>
	{
		free(ptr);
    c912:	0e 94 c0 70 	call	0xe180	; 0xe180 <free>
    c916:	08 95       	ret

0000c918 <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f>:


const float CoordinateUtil::PIOVER180 = M_PI / 180.0f;

void CoordinateUtil::CalculateECEFToLocalNEDRotationMatrix(float latitudeDegrees, float longitudeDegrees, float  (&ecefToLocalNEDRotationMatrix)[3][3])
{
    c918:	4f 92       	push	r4
    c91a:	5f 92       	push	r5
    c91c:	6f 92       	push	r6
    c91e:	7f 92       	push	r7
    c920:	8f 92       	push	r8
    c922:	9f 92       	push	r9
    c924:	af 92       	push	r10
    c926:	bf 92       	push	r11
    c928:	cf 92       	push	r12
    c92a:	df 92       	push	r13
    c92c:	ef 92       	push	r14
    c92e:	ff 92       	push	r15
    c930:	0f 93       	push	r16
    c932:	1f 93       	push	r17
    c934:	cf 93       	push	r28
    c936:	df 93       	push	r29
    c938:	00 d0       	rcall	.+0      	; 0xc93a <_ZN10helicopter4util14CoordinateUtil37CalculateECEFToLocalNEDRotationMatrixEffRA3_A3_f+0x22>
    c93a:	1f 92       	push	r1
    c93c:	cd b7       	in	r28, 0x3d	; 61
    c93e:	de b7       	in	r29, 0x3e	; 62
    c940:	49 01       	movw	r8, r18
    c942:	5a 01       	movw	r10, r20
				/**
				 * Converts degrees to radians
				 */
				inline static float DegreesToRad(float valueDegrees)
				{
					return valueDegrees * PIOVER180;
    c944:	25 e3       	ldi	r18, 0x35	; 53
    c946:	3a ef       	ldi	r19, 0xFA	; 250
    c948:	4e e8       	ldi	r20, 0x8E	; 142
    c94a:	5c e3       	ldi	r21, 0x3C	; 60
    c94c:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    c950:	c6 2e       	mov	r12, r22
    c952:	d7 2e       	mov	r13, r23
    c954:	e8 2e       	mov	r14, r24
    c956:	f9 2e       	mov	r15, r25
    c958:	25 e3       	ldi	r18, 0x35	; 53
    c95a:	3a ef       	ldi	r19, 0xFA	; 250
    c95c:	4e e8       	ldi	r20, 0x8E	; 142
    c95e:	5c e3       	ldi	r21, 0x3C	; 60
    c960:	c5 01       	movw	r24, r10
    c962:	b4 01       	movw	r22, r8
    c964:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    c968:	86 2e       	mov	r8, r22
    c96a:	97 2e       	mov	r9, r23
    c96c:	a8 2e       	mov	r10, r24
    c96e:	b9 2e       	mov	r11, r25
	float radLat = DegreesToRad(latitudeDegrees);
	float radLong = DegreesToRad(longitudeDegrees);
	
	float sinLat = sin(radLat);
    c970:	6c 2d       	mov	r22, r12
    c972:	7d 2d       	mov	r23, r13
    c974:	8e 2d       	mov	r24, r14
    c976:	9f 2d       	mov	r25, r15
    c978:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    c97c:	2b 01       	movw	r4, r22
    c97e:	3c 01       	movw	r6, r24
	float cosLat = cos(radLat);
    c980:	6c 2d       	mov	r22, r12
    c982:	7d 2d       	mov	r23, r13
    c984:	8e 2d       	mov	r24, r14
    c986:	9f 2d       	mov	r25, r15
    c988:	0e 94 4c 6b 	call	0xd698	; 0xd698 <cos>
    c98c:	69 83       	std	Y+1, r22	; 0x01
    c98e:	7a 83       	std	Y+2, r23	; 0x02
    c990:	8b 83       	std	Y+3, r24	; 0x03
    c992:	9c 83       	std	Y+4, r25	; 0x04
	
	float sinLong = sin(radLong);
    c994:	68 2d       	mov	r22, r8
    c996:	79 2d       	mov	r23, r9
    c998:	8a 2d       	mov	r24, r10
    c99a:	9b 2d       	mov	r25, r11
    c99c:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    c9a0:	6b 01       	movw	r12, r22
    c9a2:	7c 01       	movw	r14, r24
	float cosLong = cos(radLong);
    c9a4:	68 2d       	mov	r22, r8
    c9a6:	79 2d       	mov	r23, r9
    c9a8:	8a 2d       	mov	r24, r10
    c9aa:	9b 2d       	mov	r25, r11
    c9ac:	0e 94 4c 6b 	call	0xd698	; 0xd698 <cos>
    c9b0:	4b 01       	movw	r8, r22
    c9b2:	5c 01       	movw	r10, r24

	//Create a rotation matrix for rotating earth-centered-earth-fixed coordinates
	//into Local North-East-Down coordinates.
	ecefToLocalNEDRotationMatrix[0][0] = -1 * sinLat * cosLong;
    c9b4:	77 fa       	bst	r7, 7
    c9b6:	70 94       	com	r7
    c9b8:	77 f8       	bld	r7, 7
    c9ba:	70 94       	com	r7
    c9bc:	9b 01       	movw	r18, r22
    c9be:	ac 01       	movw	r20, r24
    c9c0:	c3 01       	movw	r24, r6
    c9c2:	b2 01       	movw	r22, r4
    c9c4:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    c9c8:	d8 01       	movw	r26, r16
    c9ca:	6d 93       	st	X+, r22
    c9cc:	7d 93       	st	X+, r23
    c9ce:	8d 93       	st	X+, r24
    c9d0:	9c 93       	st	X, r25
    c9d2:	13 97       	sbiw	r26, 0x03	; 3
	ecefToLocalNEDRotationMatrix[0][1] = -1 * sinLat * sinLong;
    c9d4:	a3 01       	movw	r20, r6
    c9d6:	92 01       	movw	r18, r4
    c9d8:	c7 01       	movw	r24, r14
    c9da:	b6 01       	movw	r22, r12
    c9dc:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    c9e0:	f8 01       	movw	r30, r16
    c9e2:	64 83       	std	Z+4, r22	; 0x04
    c9e4:	75 83       	std	Z+5, r23	; 0x05
    c9e6:	86 83       	std	Z+6, r24	; 0x06
    c9e8:	97 83       	std	Z+7, r25	; 0x07
	ecefToLocalNEDRotationMatrix[0][2] = cosLat;
    c9ea:	89 81       	ldd	r24, Y+1	; 0x01
    c9ec:	9a 81       	ldd	r25, Y+2	; 0x02
    c9ee:	ab 81       	ldd	r26, Y+3	; 0x03
    c9f0:	bc 81       	ldd	r27, Y+4	; 0x04
    c9f2:	80 87       	std	Z+8, r24	; 0x08
    c9f4:	91 87       	std	Z+9, r25	; 0x09
    c9f6:	a2 87       	std	Z+10, r26	; 0x0a
    c9f8:	b3 87       	std	Z+11, r27	; 0x0b
	ecefToLocalNEDRotationMatrix[1][0] = -1 * sinLong;
    c9fa:	d7 01       	movw	r26, r14
    c9fc:	c6 01       	movw	r24, r12
    c9fe:	b0 58       	subi	r27, 0x80	; 128
    ca00:	84 87       	std	Z+12, r24	; 0x0c
    ca02:	95 87       	std	Z+13, r25	; 0x0d
    ca04:	a6 87       	std	Z+14, r26	; 0x0e
    ca06:	b7 87       	std	Z+15, r27	; 0x0f
	ecefToLocalNEDRotationMatrix[1][1] = cosLong;
    ca08:	80 8a       	std	Z+16, r8	; 0x10
    ca0a:	91 8a       	std	Z+17, r9	; 0x11
    ca0c:	a2 8a       	std	Z+18, r10	; 0x12
    ca0e:	b3 8a       	std	Z+19, r11	; 0x13
	ecefToLocalNEDRotationMatrix[1][2] = 0;
    ca10:	14 8a       	std	Z+20, r1	; 0x14
    ca12:	15 8a       	std	Z+21, r1	; 0x15
    ca14:	16 8a       	std	Z+22, r1	; 0x16
    ca16:	17 8a       	std	Z+23, r1	; 0x17
	ecefToLocalNEDRotationMatrix[2][0] = -1 * cosLat * cosLong;
    ca18:	89 81       	ldd	r24, Y+1	; 0x01
    ca1a:	9a 81       	ldd	r25, Y+2	; 0x02
    ca1c:	ab 81       	ldd	r26, Y+3	; 0x03
    ca1e:	bc 81       	ldd	r27, Y+4	; 0x04
    ca20:	b0 58       	subi	r27, 0x80	; 128
    ca22:	89 83       	std	Y+1, r24	; 0x01
    ca24:	9a 83       	std	Y+2, r25	; 0x02
    ca26:	ab 83       	std	Y+3, r26	; 0x03
    ca28:	bc 83       	std	Y+4, r27	; 0x04
    ca2a:	a5 01       	movw	r20, r10
    ca2c:	94 01       	movw	r18, r8
    ca2e:	bc 01       	movw	r22, r24
    ca30:	cd 01       	movw	r24, r26
    ca32:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    ca36:	d8 01       	movw	r26, r16
    ca38:	58 96       	adiw	r26, 0x18	; 24
    ca3a:	6d 93       	st	X+, r22
    ca3c:	7d 93       	st	X+, r23
    ca3e:	8d 93       	st	X+, r24
    ca40:	9c 93       	st	X, r25
    ca42:	5b 97       	sbiw	r26, 0x1b	; 27
	ecefToLocalNEDRotationMatrix[2][1] = -1 * cosLat * sinLong;
    ca44:	29 81       	ldd	r18, Y+1	; 0x01
    ca46:	3a 81       	ldd	r19, Y+2	; 0x02
    ca48:	4b 81       	ldd	r20, Y+3	; 0x03
    ca4a:	5c 81       	ldd	r21, Y+4	; 0x04
    ca4c:	c7 01       	movw	r24, r14
    ca4e:	b6 01       	movw	r22, r12
    ca50:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    ca54:	f8 01       	movw	r30, r16
    ca56:	64 8f       	std	Z+28, r22	; 0x1c
    ca58:	75 8f       	std	Z+29, r23	; 0x1d
    ca5a:	86 8f       	std	Z+30, r24	; 0x1e
    ca5c:	97 8f       	std	Z+31, r25	; 0x1f
	ecefToLocalNEDRotationMatrix[2][2] = -1 * sinLat;
    ca5e:	40 a2       	std	Z+32, r4	; 0x20
    ca60:	51 a2       	std	Z+33, r5	; 0x21
    ca62:	62 a2       	std	Z+34, r6	; 0x22
    ca64:	73 a2       	std	Z+35, r7	; 0x23
}
    ca66:	0f 90       	pop	r0
    ca68:	0f 90       	pop	r0
    ca6a:	0f 90       	pop	r0
    ca6c:	0f 90       	pop	r0
    ca6e:	df 91       	pop	r29
    ca70:	cf 91       	pop	r28
    ca72:	1f 91       	pop	r17
    ca74:	0f 91       	pop	r16
    ca76:	ff 90       	pop	r15
    ca78:	ef 90       	pop	r14
    ca7a:	df 90       	pop	r13
    ca7c:	cf 90       	pop	r12
    ca7e:	bf 90       	pop	r11
    ca80:	af 90       	pop	r10
    ca82:	9f 90       	pop	r9
    ca84:	8f 90       	pop	r8
    ca86:	7f 90       	pop	r7
    ca88:	6f 90       	pop	r6
    ca8a:	5f 90       	pop	r5
    ca8c:	4f 90       	pop	r4
    ca8e:	08 95       	ret

0000ca90 <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_>:


void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
    ca90:	4f 92       	push	r4
    ca92:	5f 92       	push	r5
    ca94:	6f 92       	push	r6
    ca96:	7f 92       	push	r7
    ca98:	af 92       	push	r10
    ca9a:	bf 92       	push	r11
    ca9c:	cf 92       	push	r12
    ca9e:	df 92       	push	r13
    caa0:	ef 92       	push	r14
    caa2:	ff 92       	push	r15
    caa4:	0f 93       	push	r16
    caa6:	1f 93       	push	r17
    caa8:	cf 93       	push	r28
    caaa:	df 93       	push	r29
    caac:	cd b7       	in	r28, 0x3d	; 61
    caae:	de b7       	in	r29, 0x3e	; 62
    cab0:	6c 97       	sbiw	r28, 0x1c	; 28
    cab2:	0f b6       	in	r0, 0x3f	; 63
    cab4:	f8 94       	cli
    cab6:	de bf       	out	0x3e, r29	; 62
    cab8:	0f be       	out	0x3f, r0	; 63
    caba:	cd bf       	out	0x3d, r28	; 61
    cabc:	29 8f       	std	Y+25, r18	; 0x19
    cabe:	3a 8f       	std	Y+26, r19	; 0x1a
    cac0:	4b 8f       	std	Y+27, r20	; 0x1b
    cac2:	5c 8f       	std	Y+28, r21	; 0x1c
    cac4:	27 01       	movw	r4, r14
    cac6:	38 01       	movw	r6, r16
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
    cac8:	8e 01       	movw	r16, r28
    caca:	03 5f       	subi	r16, 0xF3	; 243
    cacc:	1f 4f       	sbci	r17, 0xFF	; 255
    cace:	2c e0       	ldi	r18, 0x0C	; 12
    cad0:	f8 01       	movw	r30, r16
    cad2:	11 92       	st	Z+, r1
    cad4:	2a 95       	dec	r18
    cad6:	e9 f7       	brne	.-6      	; 0xcad2 <_ZN10helicopter4util14CoordinateUtil25ConvertFromECEFToLocalNEDEllllllPA3_fRfS4_S4_+0x42>
void CoordinateUtil::ConvertFromECEFToLocalNED(long ecefReferenceX, long ecefReferenceY, long ecefReferenceZ,
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
    cad8:	a6 01       	movw	r20, r12
    cada:	95 01       	movw	r18, r10
    cadc:	26 1b       	sub	r18, r22
    cade:	37 0b       	sbc	r19, r23
    cae0:	48 0b       	sbc	r20, r24
    cae2:	59 0b       	sbc	r21, r25
    cae4:	ca 01       	movw	r24, r20
    cae6:	b9 01       	movw	r22, r18
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    cae8:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    caec:	69 83       	std	Y+1, r22	; 0x01
    caee:	7a 83       	std	Y+2, r23	; 0x02
    caf0:	8b 83       	std	Y+3, r24	; 0x03
    caf2:	9c 83       	std	Y+4, r25	; 0x04
	long ecefX, long ecefY, long ecefZ, float ecefToLocalNEDRotationMatrix[][3],
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
    caf4:	8e a5       	ldd	r24, Y+46	; 0x2e
    caf6:	9f a5       	ldd	r25, Y+47	; 0x2f
    caf8:	a8 a9       	ldd	r26, Y+48	; 0x30
    cafa:	b9 a9       	ldd	r27, Y+49	; 0x31
    cafc:	bc 01       	movw	r22, r24
    cafe:	cd 01       	movw	r24, r26
    cb00:	29 8d       	ldd	r18, Y+25	; 0x19
    cb02:	3a 8d       	ldd	r19, Y+26	; 0x1a
    cb04:	4b 8d       	ldd	r20, Y+27	; 0x1b
    cb06:	5c 8d       	ldd	r21, Y+28	; 0x1c
    cb08:	62 1b       	sub	r22, r18
    cb0a:	73 0b       	sbc	r23, r19
    cb0c:	84 0b       	sbc	r24, r20
    cb0e:	95 0b       	sbc	r25, r21
	long differenceZECEF = ecefZ - ecefReferenceZ;
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    cb10:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    cb14:	6d 83       	std	Y+5, r22	; 0x05
    cb16:	7e 83       	std	Y+6, r23	; 0x06
    cb18:	8f 83       	std	Y+7, r24	; 0x07
    cb1a:	98 87       	std	Y+8, r25	; 0x08
	float &localNEDX, float &localNEDY, float &localNEDZ)
{
	//Get the current helicopters position relative to it's starting point in ecef.
	long differenceXECEF = ecefX - ecefReferenceX;
	long differenceYECEF = ecefY - ecefReferenceY;
	long differenceZECEF = ecefZ - ecefReferenceZ;
    cb1c:	8a a9       	ldd	r24, Y+50	; 0x32
    cb1e:	9b a9       	ldd	r25, Y+51	; 0x33
    cb20:	ac a9       	ldd	r26, Y+52	; 0x34
    cb22:	bd a9       	ldd	r27, Y+53	; 0x35
    cb24:	bc 01       	movw	r22, r24
    cb26:	cd 01       	movw	r24, r26
    cb28:	64 19       	sub	r22, r4
    cb2a:	75 09       	sbc	r23, r5
    cb2c:	86 09       	sbc	r24, r6
    cb2e:	97 09       	sbc	r25, r7
	
	float rotatedMatrix[3] = {};
	float positionMatrix[3] = {(float)differenceXECEF, (float)differenceYECEF, (float)differenceZECEF};
    cb30:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    cb34:	69 87       	std	Y+9, r22	; 0x09
    cb36:	7a 87       	std	Y+10, r23	; 0x0a
    cb38:	8b 87       	std	Y+11, r24	; 0x0b
    cb3a:	9c 87       	std	Y+12, r25	; 0x0c
	
	//Rotate the current ecef position from earth centered earth fixed (ECEF) into North-East-Down(NED).
	//Iterate through the rows of the rotation matrix
	MatrixUtil::RotateMatrix(ecefToLocalNEDRotationMatrix,positionMatrix,rotatedMatrix);
    cb3c:	a8 01       	movw	r20, r16
    cb3e:	be 01       	movw	r22, r28
    cb40:	6f 5f       	subi	r22, 0xFF	; 255
    cb42:	7f 4f       	sbci	r23, 0xFF	; 255
    cb44:	8e a9       	ldd	r24, Y+54	; 0x36
    cb46:	9f a9       	ldd	r25, Y+55	; 0x37
    cb48:	0e 94 3a 69 	call	0xd274	; 0xd274 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>
	
	localNEDX = rotatedMatrix[0];
    cb4c:	8d 85       	ldd	r24, Y+13	; 0x0d
    cb4e:	9e 85       	ldd	r25, Y+14	; 0x0e
    cb50:	af 85       	ldd	r26, Y+15	; 0x0f
    cb52:	b8 89       	ldd	r27, Y+16	; 0x10
    cb54:	e8 ad       	ldd	r30, Y+56	; 0x38
    cb56:	f9 ad       	ldd	r31, Y+57	; 0x39
    cb58:	80 83       	st	Z, r24
    cb5a:	91 83       	std	Z+1, r25	; 0x01
    cb5c:	a2 83       	std	Z+2, r26	; 0x02
    cb5e:	b3 83       	std	Z+3, r27	; 0x03
	localNEDY = rotatedMatrix[1];
    cb60:	89 89       	ldd	r24, Y+17	; 0x11
    cb62:	9a 89       	ldd	r25, Y+18	; 0x12
    cb64:	ab 89       	ldd	r26, Y+19	; 0x13
    cb66:	bc 89       	ldd	r27, Y+20	; 0x14
    cb68:	ea ad       	ldd	r30, Y+58	; 0x3a
    cb6a:	fb ad       	ldd	r31, Y+59	; 0x3b
    cb6c:	80 83       	st	Z, r24
    cb6e:	91 83       	std	Z+1, r25	; 0x01
    cb70:	a2 83       	std	Z+2, r26	; 0x02
    cb72:	b3 83       	std	Z+3, r27	; 0x03
	localNEDZ = rotatedMatrix[2];
    cb74:	8d 89       	ldd	r24, Y+21	; 0x15
    cb76:	9e 89       	ldd	r25, Y+22	; 0x16
    cb78:	af 89       	ldd	r26, Y+23	; 0x17
    cb7a:	b8 8d       	ldd	r27, Y+24	; 0x18
    cb7c:	ec ad       	ldd	r30, Y+60	; 0x3c
    cb7e:	fd ad       	ldd	r31, Y+61	; 0x3d
    cb80:	80 83       	st	Z, r24
    cb82:	91 83       	std	Z+1, r25	; 0x01
    cb84:	a2 83       	std	Z+2, r26	; 0x02
    cb86:	b3 83       	std	Z+3, r27	; 0x03
}
    cb88:	6c 96       	adiw	r28, 0x1c	; 28
    cb8a:	0f b6       	in	r0, 0x3f	; 63
    cb8c:	f8 94       	cli
    cb8e:	de bf       	out	0x3e, r29	; 62
    cb90:	0f be       	out	0x3f, r0	; 63
    cb92:	cd bf       	out	0x3d, r28	; 61
    cb94:	df 91       	pop	r29
    cb96:	cf 91       	pop	r28
    cb98:	1f 91       	pop	r17
    cb9a:	0f 91       	pop	r16
    cb9c:	ff 90       	pop	r15
    cb9e:	ef 90       	pop	r14
    cba0:	df 90       	pop	r13
    cba2:	cf 90       	pop	r12
    cba4:	bf 90       	pop	r11
    cba6:	af 90       	pop	r10
    cba8:	7f 90       	pop	r7
    cbaa:	6f 90       	pop	r6
    cbac:	5f 90       	pop	r5
    cbae:	4f 90       	pop	r4
    cbb0:	08 95       	ret

0000cbb2 <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv>:
//float MatrixUtil::sinTable[91] = {0};
	
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
    cbb2:	0f 93       	push	r16
    cbb4:	1f 93       	push	r17
    cbb6:	cf 93       	push	r28
    cbb8:	df 93       	push	r29
    cbba:	02 e3       	ldi	r16, 0x32	; 50
    cbbc:	14 e0       	ldi	r17, 0x04	; 4
	
	for (int i = 0; i <= max; i++)
    cbbe:	c0 e0       	ldi	r28, 0x00	; 0
    cbc0:	d0 e0       	ldi	r29, 0x00	; 0
	{
		sinTable[i] = sin((float)i/(float)RESOLUTION);
    cbc2:	be 01       	movw	r22, r28
    cbc4:	88 27       	eor	r24, r24
    cbc6:	77 fd       	sbrc	r23, 7
    cbc8:	80 95       	com	r24
    cbca:	98 2f       	mov	r25, r24
    cbcc:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    cbd0:	20 e0       	ldi	r18, 0x00	; 0
    cbd2:	30 e0       	ldi	r19, 0x00	; 0
    cbd4:	4a ef       	ldi	r20, 0xFA	; 250
    cbd6:	53 e4       	ldi	r21, 0x43	; 67
    cbd8:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    cbdc:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    cbe0:	f8 01       	movw	r30, r16
    cbe2:	61 93       	st	Z+, r22
    cbe4:	71 93       	st	Z+, r23
    cbe6:	81 93       	st	Z+, r24
    cbe8:	91 93       	st	Z+, r25
    cbea:	8f 01       	movw	r16, r30
float MatrixUtil::sinTable[arrMax] = {0};

void MatrixUtil::createLookupTables()
{
	
	for (int i = 0; i <= max; i++)
    cbec:	21 96       	adiw	r28, 0x01	; 1
    cbee:	c2 31       	cpi	r28, 0x12	; 18
    cbf0:	f3 e0       	ldi	r31, 0x03	; 3
    cbf2:	df 07       	cpc	r29, r31
    cbf4:	31 f7       	brne	.-52     	; 0xcbc2 <_ZN10helicopter4util10MatrixUtil18createLookupTablesEv+0x10>
	for (int i = 1; i <= 1000; i++)
	{
		sinTable[i-1] = sin(M_PI * i / 1000.0);
	}
	*/
}
    cbf6:	df 91       	pop	r29
    cbf8:	cf 91       	pop	r28
    cbfa:	1f 91       	pop	r17
    cbfc:	0f 91       	pop	r16
    cbfe:	08 95       	ret

0000cc00 <_ZN10helicopter4util10MatrixUtil12CrossProductEPfS2_RA3_f>:
	*/
}


void MatrixUtil::CrossProduct(float vector1[3], float vector2[3], float (&crossProduct)[3])
{
    cc00:	af 92       	push	r10
    cc02:	bf 92       	push	r11
    cc04:	cf 92       	push	r12
    cc06:	df 92       	push	r13
    cc08:	ef 92       	push	r14
    cc0a:	ff 92       	push	r15
    cc0c:	0f 93       	push	r16
    cc0e:	1f 93       	push	r17
    cc10:	cf 93       	push	r28
    cc12:	df 93       	push	r29
    cc14:	ec 01       	movw	r28, r24
    cc16:	8b 01       	movw	r16, r22
    cc18:	5a 01       	movw	r10, r20
	crossProduct[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
    cc1a:	fb 01       	movw	r30, r22
    cc1c:	20 85       	ldd	r18, Z+8	; 0x08
    cc1e:	31 85       	ldd	r19, Z+9	; 0x09
    cc20:	42 85       	ldd	r20, Z+10	; 0x0a
    cc22:	53 85       	ldd	r21, Z+11	; 0x0b
    cc24:	6c 81       	ldd	r22, Y+4	; 0x04
    cc26:	7d 81       	ldd	r23, Y+5	; 0x05
    cc28:	8e 81       	ldd	r24, Y+6	; 0x06
    cc2a:	9f 81       	ldd	r25, Y+7	; 0x07
    cc2c:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cc30:	6b 01       	movw	r12, r22
    cc32:	7c 01       	movw	r14, r24
    cc34:	f8 01       	movw	r30, r16
    cc36:	24 81       	ldd	r18, Z+4	; 0x04
    cc38:	35 81       	ldd	r19, Z+5	; 0x05
    cc3a:	46 81       	ldd	r20, Z+6	; 0x06
    cc3c:	57 81       	ldd	r21, Z+7	; 0x07
    cc3e:	68 85       	ldd	r22, Y+8	; 0x08
    cc40:	79 85       	ldd	r23, Y+9	; 0x09
    cc42:	8a 85       	ldd	r24, Y+10	; 0x0a
    cc44:	9b 85       	ldd	r25, Y+11	; 0x0b
    cc46:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cc4a:	9b 01       	movw	r18, r22
    cc4c:	ac 01       	movw	r20, r24
    cc4e:	c7 01       	movw	r24, r14
    cc50:	b6 01       	movw	r22, r12
    cc52:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    cc56:	f5 01       	movw	r30, r10
    cc58:	60 83       	st	Z, r22
    cc5a:	71 83       	std	Z+1, r23	; 0x01
    cc5c:	82 83       	std	Z+2, r24	; 0x02
    cc5e:	93 83       	std	Z+3, r25	; 0x03
	crossProduct[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];//-1 * (vector1[0] * vector2[2] - vector1[2]*vector2[0]);
    cc60:	f8 01       	movw	r30, r16
    cc62:	20 81       	ld	r18, Z
    cc64:	31 81       	ldd	r19, Z+1	; 0x01
    cc66:	42 81       	ldd	r20, Z+2	; 0x02
    cc68:	53 81       	ldd	r21, Z+3	; 0x03
    cc6a:	68 85       	ldd	r22, Y+8	; 0x08
    cc6c:	79 85       	ldd	r23, Y+9	; 0x09
    cc6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    cc70:	9b 85       	ldd	r25, Y+11	; 0x0b
    cc72:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cc76:	6b 01       	movw	r12, r22
    cc78:	7c 01       	movw	r14, r24
    cc7a:	f8 01       	movw	r30, r16
    cc7c:	20 85       	ldd	r18, Z+8	; 0x08
    cc7e:	31 85       	ldd	r19, Z+9	; 0x09
    cc80:	42 85       	ldd	r20, Z+10	; 0x0a
    cc82:	53 85       	ldd	r21, Z+11	; 0x0b
    cc84:	68 81       	ld	r22, Y
    cc86:	79 81       	ldd	r23, Y+1	; 0x01
    cc88:	8a 81       	ldd	r24, Y+2	; 0x02
    cc8a:	9b 81       	ldd	r25, Y+3	; 0x03
    cc8c:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cc90:	9b 01       	movw	r18, r22
    cc92:	ac 01       	movw	r20, r24
    cc94:	c7 01       	movw	r24, r14
    cc96:	b6 01       	movw	r22, r12
    cc98:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    cc9c:	f5 01       	movw	r30, r10
    cc9e:	64 83       	std	Z+4, r22	; 0x04
    cca0:	75 83       	std	Z+5, r23	; 0x05
    cca2:	86 83       	std	Z+6, r24	; 0x06
    cca4:	97 83       	std	Z+7, r25	; 0x07
	crossProduct[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
    cca6:	f8 01       	movw	r30, r16
    cca8:	24 81       	ldd	r18, Z+4	; 0x04
    ccaa:	35 81       	ldd	r19, Z+5	; 0x05
    ccac:	46 81       	ldd	r20, Z+6	; 0x06
    ccae:	57 81       	ldd	r21, Z+7	; 0x07
    ccb0:	68 81       	ld	r22, Y
    ccb2:	79 81       	ldd	r23, Y+1	; 0x01
    ccb4:	8a 81       	ldd	r24, Y+2	; 0x02
    ccb6:	9b 81       	ldd	r25, Y+3	; 0x03
    ccb8:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    ccbc:	6b 01       	movw	r12, r22
    ccbe:	7c 01       	movw	r14, r24
    ccc0:	f8 01       	movw	r30, r16
    ccc2:	20 81       	ld	r18, Z
    ccc4:	31 81       	ldd	r19, Z+1	; 0x01
    ccc6:	42 81       	ldd	r20, Z+2	; 0x02
    ccc8:	53 81       	ldd	r21, Z+3	; 0x03
    ccca:	6c 81       	ldd	r22, Y+4	; 0x04
    cccc:	7d 81       	ldd	r23, Y+5	; 0x05
    ccce:	8e 81       	ldd	r24, Y+6	; 0x06
    ccd0:	9f 81       	ldd	r25, Y+7	; 0x07
    ccd2:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    ccd6:	9b 01       	movw	r18, r22
    ccd8:	ac 01       	movw	r20, r24
    ccda:	c7 01       	movw	r24, r14
    ccdc:	b6 01       	movw	r22, r12
    ccde:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    cce2:	f5 01       	movw	r30, r10
    cce4:	60 87       	std	Z+8, r22	; 0x08
    cce6:	71 87       	std	Z+9, r23	; 0x09
    cce8:	82 87       	std	Z+10, r24	; 0x0a
    ccea:	93 87       	std	Z+11, r25	; 0x0b
}
    ccec:	df 91       	pop	r29
    ccee:	cf 91       	pop	r28
    ccf0:	1f 91       	pop	r17
    ccf2:	0f 91       	pop	r16
    ccf4:	ff 90       	pop	r15
    ccf6:	ef 90       	pop	r14
    ccf8:	df 90       	pop	r13
    ccfa:	cf 90       	pop	r12
    ccfc:	bf 90       	pop	r11
    ccfe:	af 90       	pop	r10
    cd00:	08 95       	ret

0000cd02 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f>:

void MatrixUtil::Normalize(float (&vector)[3])
{
    cd02:	4f 92       	push	r4
    cd04:	5f 92       	push	r5
    cd06:	6f 92       	push	r6
    cd08:	7f 92       	push	r7
    cd0a:	8f 92       	push	r8
    cd0c:	9f 92       	push	r9
    cd0e:	af 92       	push	r10
    cd10:	bf 92       	push	r11
    cd12:	cf 92       	push	r12
    cd14:	df 92       	push	r13
    cd16:	ef 92       	push	r14
    cd18:	ff 92       	push	r15
    cd1a:	0f 93       	push	r16
    cd1c:	1f 93       	push	r17
    cd1e:	cf 93       	push	r28
    cd20:	df 93       	push	r29
    cd22:	00 d0       	rcall	.+0      	; 0xcd24 <_ZN10helicopter4util10MatrixUtil9NormalizeERA3_f+0x22>
    cd24:	1f 92       	push	r1
    cd26:	cd b7       	in	r28, 0x3d	; 61
    cd28:	de b7       	in	r29, 0x3e	; 62
    cd2a:	8c 01       	movw	r16, r24
	float magnitude = 0;
	
	//Square each vector value and add it to the magnitude
	for (int i = 0; i < 3; i++)
	{
		magnitude += vector[i] * vector[i];
    cd2c:	dc 01       	movw	r26, r24
    cd2e:	8d 91       	ld	r24, X+
    cd30:	9d 91       	ld	r25, X+
    cd32:	0d 90       	ld	r0, X+
    cd34:	bc 91       	ld	r27, X
    cd36:	a0 2d       	mov	r26, r0
    cd38:	89 83       	std	Y+1, r24	; 0x01
    cd3a:	9a 83       	std	Y+2, r25	; 0x02
    cd3c:	ab 83       	std	Y+3, r26	; 0x03
    cd3e:	bc 83       	std	Y+4, r27	; 0x04
    cd40:	9c 01       	movw	r18, r24
    cd42:	ad 01       	movw	r20, r26
    cd44:	bc 01       	movw	r22, r24
    cd46:	cd 01       	movw	r24, r26
    cd48:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cd4c:	20 e0       	ldi	r18, 0x00	; 0
    cd4e:	30 e0       	ldi	r19, 0x00	; 0
    cd50:	a9 01       	movw	r20, r18
    cd52:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    cd56:	c6 2e       	mov	r12, r22
    cd58:	d7 2e       	mov	r13, r23
    cd5a:	e8 2e       	mov	r14, r24
    cd5c:	f9 2e       	mov	r15, r25
    cd5e:	f8 01       	movw	r30, r16
    cd60:	44 80       	ldd	r4, Z+4	; 0x04
    cd62:	55 80       	ldd	r5, Z+5	; 0x05
    cd64:	66 80       	ldd	r6, Z+6	; 0x06
    cd66:	77 80       	ldd	r7, Z+7	; 0x07
    cd68:	a3 01       	movw	r20, r6
    cd6a:	92 01       	movw	r18, r4
    cd6c:	c3 01       	movw	r24, r6
    cd6e:	b2 01       	movw	r22, r4
    cd70:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cd74:	9b 01       	movw	r18, r22
    cd76:	ac 01       	movw	r20, r24
    cd78:	6c 2d       	mov	r22, r12
    cd7a:	7d 2d       	mov	r23, r13
    cd7c:	8e 2d       	mov	r24, r14
    cd7e:	9f 2d       	mov	r25, r15
    cd80:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    cd84:	86 2e       	mov	r8, r22
    cd86:	97 2e       	mov	r9, r23
    cd88:	a8 2e       	mov	r10, r24
    cd8a:	b9 2e       	mov	r11, r25
    cd8c:	d8 01       	movw	r26, r16
    cd8e:	18 96       	adiw	r26, 0x08	; 8
    cd90:	cd 90       	ld	r12, X+
    cd92:	dd 90       	ld	r13, X+
    cd94:	ed 90       	ld	r14, X+
    cd96:	fc 90       	ld	r15, X
    cd98:	1b 97       	sbiw	r26, 0x0b	; 11
    cd9a:	a7 01       	movw	r20, r14
    cd9c:	96 01       	movw	r18, r12
    cd9e:	c7 01       	movw	r24, r14
    cda0:	b6 01       	movw	r22, r12
    cda2:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cda6:	28 2d       	mov	r18, r8
    cda8:	39 2d       	mov	r19, r9
    cdaa:	4a 2d       	mov	r20, r10
    cdac:	5b 2d       	mov	r21, r11
    cdae:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
	}
	
	magnitude = sqrt(magnitude);
    cdb2:	0e 94 86 6e 	call	0xdd0c	; 0xdd0c <sqrt>
    cdb6:	4b 01       	movw	r8, r22
    cdb8:	5c 01       	movw	r10, r24
	
	for (int i = 0; i < 3; i++)
	{
		vector[i] = vector[i] / magnitude;
    cdba:	9b 01       	movw	r18, r22
    cdbc:	ac 01       	movw	r20, r24
    cdbe:	69 81       	ldd	r22, Y+1	; 0x01
    cdc0:	7a 81       	ldd	r23, Y+2	; 0x02
    cdc2:	8b 81       	ldd	r24, Y+3	; 0x03
    cdc4:	9c 81       	ldd	r25, Y+4	; 0x04
    cdc6:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    cdca:	f8 01       	movw	r30, r16
    cdcc:	60 83       	st	Z, r22
    cdce:	71 83       	std	Z+1, r23	; 0x01
    cdd0:	82 83       	std	Z+2, r24	; 0x02
    cdd2:	93 83       	std	Z+3, r25	; 0x03
    cdd4:	a5 01       	movw	r20, r10
    cdd6:	94 01       	movw	r18, r8
    cdd8:	c3 01       	movw	r24, r6
    cdda:	b2 01       	movw	r22, r4
    cddc:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    cde0:	d8 01       	movw	r26, r16
    cde2:	14 96       	adiw	r26, 0x04	; 4
    cde4:	6d 93       	st	X+, r22
    cde6:	7d 93       	st	X+, r23
    cde8:	8d 93       	st	X+, r24
    cdea:	9c 93       	st	X, r25
    cdec:	17 97       	sbiw	r26, 0x07	; 7
    cdee:	a5 01       	movw	r20, r10
    cdf0:	94 01       	movw	r18, r8
    cdf2:	c7 01       	movw	r24, r14
    cdf4:	b6 01       	movw	r22, r12
    cdf6:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divsf3>
    cdfa:	f8 01       	movw	r30, r16
    cdfc:	60 87       	std	Z+8, r22	; 0x08
    cdfe:	71 87       	std	Z+9, r23	; 0x09
    ce00:	82 87       	std	Z+10, r24	; 0x0a
    ce02:	93 87       	std	Z+11, r25	; 0x0b
	}
}
    ce04:	0f 90       	pop	r0
    ce06:	0f 90       	pop	r0
    ce08:	0f 90       	pop	r0
    ce0a:	0f 90       	pop	r0
    ce0c:	df 91       	pop	r29
    ce0e:	cf 91       	pop	r28
    ce10:	1f 91       	pop	r17
    ce12:	0f 91       	pop	r16
    ce14:	ff 90       	pop	r15
    ce16:	ef 90       	pop	r14
    ce18:	df 90       	pop	r13
    ce1a:	cf 90       	pop	r12
    ce1c:	bf 90       	pop	r11
    ce1e:	af 90       	pop	r10
    ce20:	9f 90       	pop	r9
    ce22:	8f 90       	pop	r8
    ce24:	7f 90       	pop	r7
    ce26:	6f 90       	pop	r6
    ce28:	5f 90       	pop	r5
    ce2a:	4f 90       	pop	r4
    ce2c:	08 95       	ret

0000ce2e <_ZN10helicopter4util10MatrixUtil20CreateRotationMatrixEfffRA3_A3_f>:
		}
	}
}

void MatrixUtil::CreateRotationMatrix( float phiRotationAboutXRads, float thetaRotationAboutYRads, float saiRotationAboutZRads, float (&rotationMatrix)[3][3] )
{
    ce2e:	2f 92       	push	r2
    ce30:	3f 92       	push	r3
    ce32:	4f 92       	push	r4
    ce34:	5f 92       	push	r5
    ce36:	6f 92       	push	r6
    ce38:	7f 92       	push	r7
    ce3a:	8f 92       	push	r8
    ce3c:	9f 92       	push	r9
    ce3e:	af 92       	push	r10
    ce40:	bf 92       	push	r11
    ce42:	cf 92       	push	r12
    ce44:	df 92       	push	r13
    ce46:	ef 92       	push	r14
    ce48:	ff 92       	push	r15
    ce4a:	0f 93       	push	r16
    ce4c:	1f 93       	push	r17
    ce4e:	cf 93       	push	r28
    ce50:	df 93       	push	r29
    ce52:	cd b7       	in	r28, 0x3d	; 61
    ce54:	de b7       	in	r29, 0x3e	; 62
    ce56:	66 97       	sbiw	r28, 0x16	; 22
    ce58:	0f b6       	in	r0, 0x3f	; 63
    ce5a:	f8 94       	cli
    ce5c:	de bf       	out	0x3e, r29	; 62
    ce5e:	0f be       	out	0x3f, r0	; 63
    ce60:	cd bf       	out	0x3d, r28	; 61
    ce62:	4b 01       	movw	r8, r22
    ce64:	5c 01       	movw	r10, r24
    ce66:	29 01       	movw	r4, r18
    ce68:	3a 01       	movw	r6, r20
    ce6a:	e9 82       	std	Y+1, r14	; 0x01
    ce6c:	fa 82       	std	Y+2, r15	; 0x02
    ce6e:	0b 83       	std	Y+3, r16	; 0x03
    ce70:	1c 83       	std	Y+4, r17	; 0x04
    ce72:	de 8a       	std	Y+22, r13	; 0x16
    ce74:	cd 8a       	std	Y+21, r12	; 0x15
	rotationMatrix[2][1] = sin(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	rotationMatrix[2][2] = cos(phiRotationAboutXRads)*cos(thetaRotationAboutYRads);
	*/
	
	
	float sinSai = sin(saiRotationAboutZRads);
    ce76:	c8 01       	movw	r24, r16
    ce78:	b7 01       	movw	r22, r14
    ce7a:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    ce7e:	6d 83       	std	Y+5, r22	; 0x05
    ce80:	7e 83       	std	Y+6, r23	; 0x06
    ce82:	8f 83       	std	Y+7, r24	; 0x07
    ce84:	98 87       	std	Y+8, r25	; 0x08
	float sinTheta = sin(thetaRotationAboutYRads);
    ce86:	c3 01       	movw	r24, r6
    ce88:	b2 01       	movw	r22, r4
    ce8a:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    ce8e:	6d 87       	std	Y+13, r22	; 0x0d
    ce90:	7e 87       	std	Y+14, r23	; 0x0e
    ce92:	8f 87       	std	Y+15, r24	; 0x0f
    ce94:	98 8b       	std	Y+16, r25	; 0x10
	float sinPhi = sin(phiRotationAboutXRads);
    ce96:	c5 01       	movw	r24, r10
    ce98:	b4 01       	movw	r22, r8
    ce9a:	0e 94 7c 6e 	call	0xdcf8	; 0xdcf8 <sin>
    ce9e:	69 87       	std	Y+9, r22	; 0x09
    cea0:	7a 87       	std	Y+10, r23	; 0x0a
    cea2:	8b 87       	std	Y+11, r24	; 0x0b
    cea4:	9c 87       	std	Y+12, r25	; 0x0c
	
	float cosSai = cos(saiRotationAboutZRads);
    cea6:	c8 01       	movw	r24, r16
    cea8:	b7 01       	movw	r22, r14
    ceaa:	0e 94 4c 6b 	call	0xd698	; 0xd698 <cos>
    ceae:	6b 01       	movw	r12, r22
    ceb0:	7c 01       	movw	r14, r24
	float cosTheta = cos(thetaRotationAboutYRads);
    ceb2:	c3 01       	movw	r24, r6
    ceb4:	b2 01       	movw	r22, r4
    ceb6:	0e 94 4c 6b 	call	0xd698	; 0xd698 <cos>
    ceba:	69 83       	std	Y+1, r22	; 0x01
    cebc:	7a 83       	std	Y+2, r23	; 0x02
    cebe:	8b 83       	std	Y+3, r24	; 0x03
    cec0:	9c 83       	std	Y+4, r25	; 0x04
	float cosPhi = cos(phiRotationAboutXRads);	
    cec2:	c5 01       	movw	r24, r10
    cec4:	b4 01       	movw	r22, r8
    cec6:	0e 94 4c 6b 	call	0xd698	; 0xd698 <cos>
    ceca:	4b 01       	movw	r8, r22
    cecc:	5c 01       	movw	r10, r24
	float cosTheta = fcos(thetaRotationAboutYRads);
	float cosPhi = fcos(phiRotationAboutXRads);
*/
	
	
	rotationMatrix[0][0] = cosTheta*cosSai;
    cece:	a7 01       	movw	r20, r14
    ced0:	96 01       	movw	r18, r12
    ced2:	69 81       	ldd	r22, Y+1	; 0x01
    ced4:	7a 81       	ldd	r23, Y+2	; 0x02
    ced6:	8b 81       	ldd	r24, Y+3	; 0x03
    ced8:	9c 81       	ldd	r25, Y+4	; 0x04
    ceda:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cede:	ed 89       	ldd	r30, Y+21	; 0x15
    cee0:	fe 89       	ldd	r31, Y+22	; 0x16
    cee2:	60 83       	st	Z, r22
    cee4:	71 83       	std	Z+1, r23	; 0x01
    cee6:	82 83       	std	Z+2, r24	; 0x02
    cee8:	93 83       	std	Z+3, r25	; 0x03
	rotationMatrix[0][1] = sinPhi*sinTheta*cosSai - cosPhi*sinSai;
    ceea:	2d 85       	ldd	r18, Y+13	; 0x0d
    ceec:	3e 85       	ldd	r19, Y+14	; 0x0e
    ceee:	4f 85       	ldd	r20, Y+15	; 0x0f
    cef0:	58 89       	ldd	r21, Y+16	; 0x10
    cef2:	69 85       	ldd	r22, Y+9	; 0x09
    cef4:	7a 85       	ldd	r23, Y+10	; 0x0a
    cef6:	8b 85       	ldd	r24, Y+11	; 0x0b
    cef8:	9c 85       	ldd	r25, Y+12	; 0x0c
    cefa:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cefe:	36 2e       	mov	r3, r22
    cf00:	27 2e       	mov	r2, r23
    cf02:	89 8b       	std	Y+17, r24	; 0x11
    cf04:	9a 8b       	std	Y+18, r25	; 0x12
    cf06:	a7 01       	movw	r20, r14
    cf08:	96 01       	movw	r18, r12
    cf0a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf0e:	2b 01       	movw	r4, r22
    cf10:	3c 01       	movw	r6, r24
    cf12:	2d 81       	ldd	r18, Y+5	; 0x05
    cf14:	3e 81       	ldd	r19, Y+6	; 0x06
    cf16:	4f 81       	ldd	r20, Y+7	; 0x07
    cf18:	58 85       	ldd	r21, Y+8	; 0x08
    cf1a:	c5 01       	movw	r24, r10
    cf1c:	b4 01       	movw	r22, r8
    cf1e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf22:	9b 01       	movw	r18, r22
    cf24:	ac 01       	movw	r20, r24
    cf26:	c3 01       	movw	r24, r6
    cf28:	b2 01       	movw	r22, r4
    cf2a:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    cf2e:	ed 89       	ldd	r30, Y+21	; 0x15
    cf30:	fe 89       	ldd	r31, Y+22	; 0x16
    cf32:	64 83       	std	Z+4, r22	; 0x04
    cf34:	75 83       	std	Z+5, r23	; 0x05
    cf36:	86 83       	std	Z+6, r24	; 0x06
    cf38:	97 83       	std	Z+7, r25	; 0x07
	rotationMatrix[0][2] = cosPhi*sinTheta*cosSai + sinPhi*sinSai;
    cf3a:	2d 85       	ldd	r18, Y+13	; 0x0d
    cf3c:	3e 85       	ldd	r19, Y+14	; 0x0e
    cf3e:	4f 85       	ldd	r20, Y+15	; 0x0f
    cf40:	58 89       	ldd	r21, Y+16	; 0x10
    cf42:	c5 01       	movw	r24, r10
    cf44:	b4 01       	movw	r22, r8
    cf46:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf4a:	06 2f       	mov	r16, r22
    cf4c:	17 2f       	mov	r17, r23
    cf4e:	8b 8b       	std	Y+19, r24	; 0x13
    cf50:	9c 8b       	std	Y+20, r25	; 0x14
    cf52:	a7 01       	movw	r20, r14
    cf54:	96 01       	movw	r18, r12
    cf56:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf5a:	2b 01       	movw	r4, r22
    cf5c:	3c 01       	movw	r6, r24
    cf5e:	2d 81       	ldd	r18, Y+5	; 0x05
    cf60:	3e 81       	ldd	r19, Y+6	; 0x06
    cf62:	4f 81       	ldd	r20, Y+7	; 0x07
    cf64:	58 85       	ldd	r21, Y+8	; 0x08
    cf66:	69 85       	ldd	r22, Y+9	; 0x09
    cf68:	7a 85       	ldd	r23, Y+10	; 0x0a
    cf6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    cf6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    cf6e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf72:	9b 01       	movw	r18, r22
    cf74:	ac 01       	movw	r20, r24
    cf76:	c3 01       	movw	r24, r6
    cf78:	b2 01       	movw	r22, r4
    cf7a:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    cf7e:	ed 89       	ldd	r30, Y+21	; 0x15
    cf80:	fe 89       	ldd	r31, Y+22	; 0x16
    cf82:	60 87       	std	Z+8, r22	; 0x08
    cf84:	71 87       	std	Z+9, r23	; 0x09
    cf86:	82 87       	std	Z+10, r24	; 0x0a
    cf88:	93 87       	std	Z+11, r25	; 0x0b
	rotationMatrix[1][0] = cosTheta*sinSai;
    cf8a:	2d 81       	ldd	r18, Y+5	; 0x05
    cf8c:	3e 81       	ldd	r19, Y+6	; 0x06
    cf8e:	4f 81       	ldd	r20, Y+7	; 0x07
    cf90:	58 85       	ldd	r21, Y+8	; 0x08
    cf92:	69 81       	ldd	r22, Y+1	; 0x01
    cf94:	7a 81       	ldd	r23, Y+2	; 0x02
    cf96:	8b 81       	ldd	r24, Y+3	; 0x03
    cf98:	9c 81       	ldd	r25, Y+4	; 0x04
    cf9a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cf9e:	ed 89       	ldd	r30, Y+21	; 0x15
    cfa0:	fe 89       	ldd	r31, Y+22	; 0x16
    cfa2:	64 87       	std	Z+12, r22	; 0x0c
    cfa4:	75 87       	std	Z+13, r23	; 0x0d
    cfa6:	86 87       	std	Z+14, r24	; 0x0e
    cfa8:	97 87       	std	Z+15, r25	; 0x0f
	rotationMatrix[1][1] = sinPhi*sinTheta*sinSai + cosPhi*cosSai;
    cfaa:	99 89       	ldd	r25, Y+17	; 0x11
    cfac:	8a 89       	ldd	r24, Y+18	; 0x12
    cfae:	23 2d       	mov	r18, r3
    cfb0:	32 2d       	mov	r19, r2
    cfb2:	49 2f       	mov	r20, r25
    cfb4:	58 2f       	mov	r21, r24
    cfb6:	6d 81       	ldd	r22, Y+5	; 0x05
    cfb8:	7e 81       	ldd	r23, Y+6	; 0x06
    cfba:	8f 81       	ldd	r24, Y+7	; 0x07
    cfbc:	98 85       	ldd	r25, Y+8	; 0x08
    cfbe:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cfc2:	2b 01       	movw	r4, r22
    cfc4:	3c 01       	movw	r6, r24
    cfc6:	a7 01       	movw	r20, r14
    cfc8:	96 01       	movw	r18, r12
    cfca:	c5 01       	movw	r24, r10
    cfcc:	b4 01       	movw	r22, r8
    cfce:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    cfd2:	9b 01       	movw	r18, r22
    cfd4:	ac 01       	movw	r20, r24
    cfd6:	c3 01       	movw	r24, r6
    cfd8:	b2 01       	movw	r22, r4
    cfda:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    cfde:	ed 89       	ldd	r30, Y+21	; 0x15
    cfe0:	fe 89       	ldd	r31, Y+22	; 0x16
    cfe2:	60 8b       	std	Z+16, r22	; 0x10
    cfe4:	71 8b       	std	Z+17, r23	; 0x11
    cfe6:	82 8b       	std	Z+18, r24	; 0x12
    cfe8:	93 8b       	std	Z+19, r25	; 0x13
	rotationMatrix[1][2] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
    cfea:	9b 89       	ldd	r25, Y+19	; 0x13
    cfec:	8c 89       	ldd	r24, Y+20	; 0x14
    cfee:	20 2f       	mov	r18, r16
    cff0:	31 2f       	mov	r19, r17
    cff2:	49 2f       	mov	r20, r25
    cff4:	58 2f       	mov	r21, r24
    cff6:	6d 81       	ldd	r22, Y+5	; 0x05
    cff8:	7e 81       	ldd	r23, Y+6	; 0x06
    cffa:	8f 81       	ldd	r24, Y+7	; 0x07
    cffc:	98 85       	ldd	r25, Y+8	; 0x08
    cffe:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d002:	2b 01       	movw	r4, r22
    d004:	3c 01       	movw	r6, r24
    d006:	a7 01       	movw	r20, r14
    d008:	96 01       	movw	r18, r12
    d00a:	69 85       	ldd	r22, Y+9	; 0x09
    d00c:	7a 85       	ldd	r23, Y+10	; 0x0a
    d00e:	8b 85       	ldd	r24, Y+11	; 0x0b
    d010:	9c 85       	ldd	r25, Y+12	; 0x0c
    d012:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d016:	9b 01       	movw	r18, r22
    d018:	ac 01       	movw	r20, r24
    d01a:	c3 01       	movw	r24, r6
    d01c:	b2 01       	movw	r22, r4
    d01e:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <__subsf3>
    d022:	ed 89       	ldd	r30, Y+21	; 0x15
    d024:	fe 89       	ldd	r31, Y+22	; 0x16
    d026:	64 8b       	std	Z+20, r22	; 0x14
    d028:	75 8b       	std	Z+21, r23	; 0x15
    d02a:	86 8b       	std	Z+22, r24	; 0x16
    d02c:	97 8b       	std	Z+23, r25	; 0x17
	rotationMatrix[2][0] = -sinTheta;
    d02e:	8d 85       	ldd	r24, Y+13	; 0x0d
    d030:	9e 85       	ldd	r25, Y+14	; 0x0e
    d032:	af 85       	ldd	r26, Y+15	; 0x0f
    d034:	b8 89       	ldd	r27, Y+16	; 0x10
    d036:	b0 58       	subi	r27, 0x80	; 128
    d038:	80 8f       	std	Z+24, r24	; 0x18
    d03a:	91 8f       	std	Z+25, r25	; 0x19
    d03c:	a2 8f       	std	Z+26, r26	; 0x1a
    d03e:	b3 8f       	std	Z+27, r27	; 0x1b
	rotationMatrix[2][1] = sinPhi*cosTheta;
    d040:	29 81       	ldd	r18, Y+1	; 0x01
    d042:	3a 81       	ldd	r19, Y+2	; 0x02
    d044:	4b 81       	ldd	r20, Y+3	; 0x03
    d046:	5c 81       	ldd	r21, Y+4	; 0x04
    d048:	69 85       	ldd	r22, Y+9	; 0x09
    d04a:	7a 85       	ldd	r23, Y+10	; 0x0a
    d04c:	8b 85       	ldd	r24, Y+11	; 0x0b
    d04e:	9c 85       	ldd	r25, Y+12	; 0x0c
    d050:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d054:	ed 89       	ldd	r30, Y+21	; 0x15
    d056:	fe 89       	ldd	r31, Y+22	; 0x16
    d058:	64 8f       	std	Z+28, r22	; 0x1c
    d05a:	75 8f       	std	Z+29, r23	; 0x1d
    d05c:	86 8f       	std	Z+30, r24	; 0x1e
    d05e:	97 8f       	std	Z+31, r25	; 0x1f
	rotationMatrix[2][2] = cosPhi*cosTheta;
    d060:	29 81       	ldd	r18, Y+1	; 0x01
    d062:	3a 81       	ldd	r19, Y+2	; 0x02
    d064:	4b 81       	ldd	r20, Y+3	; 0x03
    d066:	5c 81       	ldd	r21, Y+4	; 0x04
    d068:	c5 01       	movw	r24, r10
    d06a:	b4 01       	movw	r22, r8
    d06c:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d070:	ed 89       	ldd	r30, Y+21	; 0x15
    d072:	fe 89       	ldd	r31, Y+22	; 0x16
    d074:	60 a3       	std	Z+32, r22	; 0x20
    d076:	71 a3       	std	Z+33, r23	; 0x21
    d078:	82 a3       	std	Z+34, r24	; 0x22
    d07a:	93 a3       	std	Z+35, r25	; 0x23
}
    d07c:	66 96       	adiw	r28, 0x16	; 22
    d07e:	0f b6       	in	r0, 0x3f	; 63
    d080:	f8 94       	cli
    d082:	de bf       	out	0x3e, r29	; 62
    d084:	0f be       	out	0x3f, r0	; 63
    d086:	cd bf       	out	0x3d, r28	; 61
    d088:	df 91       	pop	r29
    d08a:	cf 91       	pop	r28
    d08c:	1f 91       	pop	r17
    d08e:	0f 91       	pop	r16
    d090:	ff 90       	pop	r15
    d092:	ef 90       	pop	r14
    d094:	df 90       	pop	r13
    d096:	cf 90       	pop	r12
    d098:	bf 90       	pop	r11
    d09a:	af 90       	pop	r10
    d09c:	9f 90       	pop	r9
    d09e:	8f 90       	pop	r8
    d0a0:	7f 90       	pop	r7
    d0a2:	6f 90       	pop	r6
    d0a4:	5f 90       	pop	r5
    d0a6:	4f 90       	pop	r4
    d0a8:	3f 90       	pop	r3
    d0aa:	2f 90       	pop	r2
    d0ac:	08 95       	ret

0000d0ae <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_>:
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d0ae:	4f 92       	push	r4
    d0b0:	5f 92       	push	r5
    d0b2:	6f 92       	push	r6
    d0b4:	7f 92       	push	r7
    d0b6:	8f 92       	push	r8
    d0b8:	9f 92       	push	r9
    d0ba:	af 92       	push	r10
    d0bc:	bf 92       	push	r11
    d0be:	cf 92       	push	r12
    d0c0:	df 92       	push	r13
    d0c2:	ef 92       	push	r14
    d0c4:	ff 92       	push	r15
    d0c6:	0f 93       	push	r16
    d0c8:	1f 93       	push	r17
    d0ca:	cf 93       	push	r28
    d0cc:	df 93       	push	r29
    d0ce:	4c 01       	movw	r8, r24
    d0d0:	46 2e       	mov	r4, r22
    d0d2:	57 2e       	mov	r5, r23
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d0d4:	e4 2f       	mov	r30, r20
    d0d6:	f5 2f       	mov	r31, r21
    d0d8:	8c e0       	ldi	r24, 0x0C	; 12
    d0da:	df 01       	movw	r26, r30
    d0dc:	1d 92       	st	X+, r1
    d0de:	8a 95       	dec	r24
    d0e0:	e9 f7       	brne	.-6      	; 0xd0dc <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x2e>
    d0e2:	e4 2e       	mov	r14, r20
    d0e4:	f5 2e       	mov	r15, r21
    d0e6:	c1 2c       	mov	r12, r1
    d0e8:	d1 2c       	mov	r13, r1
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d0ea:	61 2c       	mov	r6, r1
    d0ec:	71 2c       	mov	r7, r1
    d0ee:	2b c0       	rjmp	.+86     	; 0xd146 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x98>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
    d0f0:	f8 01       	movw	r30, r16
    d0f2:	61 91       	ld	r22, Z+
    d0f4:	71 91       	ld	r23, Z+
    d0f6:	81 91       	ld	r24, Z+
    d0f8:	91 91       	ld	r25, Z+
    d0fa:	8f 01       	movw	r16, r30
	rotationMatrix[2][1] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d0fc:	f5 01       	movw	r30, r10
    d0fe:	ec 0f       	add	r30, r28
    d100:	fd 1f       	adc	r31, r29
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
    d102:	20 81       	ld	r18, Z
    d104:	31 81       	ldd	r19, Z+1	; 0x01
    d106:	42 81       	ldd	r20, Z+2	; 0x02
    d108:	53 81       	ldd	r21, Z+3	; 0x03
    d10a:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d10e:	9b 01       	movw	r18, r22
    d110:	ac 01       	movw	r20, r24
    d112:	d7 01       	movw	r26, r14
    d114:	6d 91       	ld	r22, X+
    d116:	7d 91       	ld	r23, X+
    d118:	8d 91       	ld	r24, X+
    d11a:	9c 91       	ld	r25, X
    d11c:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    d120:	f7 01       	movw	r30, r14
    d122:	60 83       	st	Z, r22
    d124:	71 83       	std	Z+1, r23	; 0x01
    d126:	82 83       	std	Z+2, r24	; 0x02
    d128:	93 83       	std	Z+3, r25	; 0x03
    d12a:	2c 96       	adiw	r28, 0x0c	; 12
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d12c:	c4 32       	cpi	r28, 0x24	; 36
    d12e:	d1 05       	cpc	r29, r1
    d130:	f9 f6       	brne	.-66     	; 0xd0f0 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x42>
    d132:	f4 e0       	ldi	r31, 0x04	; 4
    d134:	cf 0e       	add	r12, r31
    d136:	d1 1c       	adc	r13, r1
    d138:	84 e0       	ldi	r24, 0x04	; 4
    d13a:	e8 0e       	add	r14, r24
    d13c:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d13e:	ac e0       	ldi	r26, 0x0C	; 12
    d140:	ca 16       	cp	r12, r26
    d142:	d1 04       	cpc	r13, r1
    d144:	39 f0       	breq	.+14     	; 0xd154 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0xa6>
    d146:	04 2d       	mov	r16, r4
    d148:	15 2d       	mov	r17, r5
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d14a:	e3 01       	movw	r28, r6
	rotationMatrix[2][1] = cosPhi*sinTheta*sinSai - sinPhi*cosSai;
	rotationMatrix[2][2] = cosPhi*cosTheta;
	
}

void MatrixUtil::RotateMatrixT( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d14c:	54 01       	movw	r10, r8
    d14e:	ac 0c       	add	r10, r12
    d150:	bd 1c       	adc	r11, r13
    d152:	ce cf       	rjmp	.-100    	; 0xd0f0 <_ZN10helicopter4util10MatrixUtil13RotateMatrixTEPA3_fPfRS2_+0x42>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}
    d154:	df 91       	pop	r29
    d156:	cf 91       	pop	r28
    d158:	1f 91       	pop	r17
    d15a:	0f 91       	pop	r16
    d15c:	ff 90       	pop	r15
    d15e:	ef 90       	pop	r14
    d160:	df 90       	pop	r13
    d162:	cf 90       	pop	r12
    d164:	bf 90       	pop	r11
    d166:	af 90       	pop	r10
    d168:	9f 90       	pop	r9
    d16a:	8f 90       	pop	r8
    d16c:	7f 90       	pop	r7
    d16e:	6f 90       	pop	r6
    d170:	5f 90       	pop	r5
    d172:	4f 90       	pop	r4
    d174:	08 95       	ret

0000d176 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
{
    d176:	2f 92       	push	r2
    d178:	3f 92       	push	r3
    d17a:	4f 92       	push	r4
    d17c:	5f 92       	push	r5
    d17e:	6f 92       	push	r6
    d180:	7f 92       	push	r7
    d182:	8f 92       	push	r8
    d184:	9f 92       	push	r9
    d186:	af 92       	push	r10
    d188:	bf 92       	push	r11
    d18a:	cf 92       	push	r12
    d18c:	df 92       	push	r13
    d18e:	ef 92       	push	r14
    d190:	ff 92       	push	r15
    d192:	0f 93       	push	r16
    d194:	1f 93       	push	r17
    d196:	cf 93       	push	r28
    d198:	df 93       	push	r29
    d19a:	00 d0       	rcall	.+0      	; 0xd19c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x26>
    d19c:	1f 92       	push	r1
    d19e:	cd b7       	in	r28, 0x3d	; 61
    d1a0:	de b7       	in	r29, 0x3e	; 62
    d1a2:	4c 01       	movw	r8, r24
    d1a4:	69 83       	std	Y+1, r22	; 0x01
    d1a6:	7a 83       	std	Y+2, r23	; 0x02
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d1a8:	e4 2f       	mov	r30, r20
    d1aa:	f5 2f       	mov	r31, r21
    d1ac:	8c e0       	ldi	r24, 0x0C	; 12
    d1ae:	df 01       	movw	r26, r30
    d1b0:	1d 92       	st	X+, r1
    d1b2:	8a 95       	dec	r24
    d1b4:	e9 f7       	brne	.-6      	; 0xd1b0 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x3a>
    d1b6:	e4 2e       	mov	r14, r20
    d1b8:	f5 2e       	mov	r15, r21
    d1ba:	a1 2c       	mov	r10, r1
    d1bc:	b1 2c       	mov	r11, r1
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
    d1be:	0f 2e       	mov	r0, r31
    d1c0:	f3 e0       	ldi	r31, 0x03	; 3
    d1c2:	2f 2e       	mov	r2, r31
    d1c4:	31 2c       	mov	r3, r1
    d1c6:	f0 2d       	mov	r31, r0
    d1c8:	36 c0       	rjmp	.+108    	; 0xd236 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xc0>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    d1ca:	f6 01       	movw	r30, r12
    d1cc:	41 90       	ld	r4, Z+
    d1ce:	51 90       	ld	r5, Z+
    d1d0:	61 90       	ld	r6, Z+
    d1d2:	71 90       	ld	r7, Z+
    d1d4:	6f 01       	movw	r12, r30
    d1d6:	d8 01       	movw	r26, r16
    d1d8:	6d 91       	ld	r22, X+
    d1da:	7d 91       	ld	r23, X+
    d1dc:	8d 01       	movw	r16, r26
    d1de:	88 27       	eor	r24, r24
    d1e0:	77 fd       	sbrc	r23, 7
    d1e2:	80 95       	com	r24
    d1e4:	98 2f       	mov	r25, r24
    d1e6:	0e 94 ea 6b 	call	0xd7d4	; 0xd7d4 <__floatsisf>
    d1ea:	9b 01       	movw	r18, r22
    d1ec:	ac 01       	movw	r20, r24
    d1ee:	c3 01       	movw	r24, r6
    d1f0:	b2 01       	movw	r22, r4
    d1f2:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d1f6:	9b 01       	movw	r18, r22
    d1f8:	ac 01       	movw	r20, r24
    d1fa:	f7 01       	movw	r30, r14
    d1fc:	60 81       	ld	r22, Z
    d1fe:	71 81       	ldd	r23, Z+1	; 0x01
    d200:	82 81       	ldd	r24, Z+2	; 0x02
    d202:	93 81       	ldd	r25, Z+3	; 0x03
    d204:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    d208:	d7 01       	movw	r26, r14
    d20a:	6d 93       	st	X+, r22
    d20c:	7d 93       	st	X+, r23
    d20e:	8d 93       	st	X+, r24
    d210:	9c 93       	st	X, r25
    d212:	13 97       	sbiw	r26, 0x03	; 3
    d214:	eb 81       	ldd	r30, Y+3	; 0x03
    d216:	fc 81       	ldd	r31, Y+4	; 0x04
    d218:	31 97       	sbiw	r30, 0x01	; 1
    d21a:	fc 83       	std	Y+4, r31	; 0x04
    d21c:	eb 83       	std	Y+3, r30	; 0x03
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d21e:	ef 2b       	or	r30, r31
    d220:	a1 f6       	brne	.-88     	; 0xd1ca <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x54>
    d222:	fc e0       	ldi	r31, 0x0C	; 12
    d224:	af 0e       	add	r10, r31
    d226:	b1 1c       	adc	r11, r1
    d228:	84 e0       	ldi	r24, 0x04	; 4
    d22a:	e8 0e       	add	r14, r24
    d22c:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d22e:	94 e2       	ldi	r25, 0x24	; 36
    d230:	a9 16       	cp	r10, r25
    d232:	b1 04       	cpc	r11, r1
    d234:	41 f0       	breq	.+16     	; 0xd246 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0xd0>
			rotatedValues[row] += rotationMatrix[column] [row] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], int valuesToRotate[3], float (&rotatedValues)[3] )
    d236:	64 01       	movw	r12, r8
    d238:	ca 0c       	add	r12, r10
    d23a:	db 1c       	adc	r13, r11
    d23c:	09 81       	ldd	r16, Y+1	; 0x01
    d23e:	1a 81       	ldd	r17, Y+2	; 0x02
    d240:	3c 82       	std	Y+4, r3	; 0x04
    d242:	2b 82       	std	Y+3, r2	; 0x03
    d244:	c2 cf       	rjmp	.-124    	; 0xd1ca <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPiRS2_+0x54>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    d246:	0f 90       	pop	r0
    d248:	0f 90       	pop	r0
    d24a:	0f 90       	pop	r0
    d24c:	0f 90       	pop	r0
    d24e:	df 91       	pop	r29
    d250:	cf 91       	pop	r28
    d252:	1f 91       	pop	r17
    d254:	0f 91       	pop	r16
    d256:	ff 90       	pop	r15
    d258:	ef 90       	pop	r14
    d25a:	df 90       	pop	r13
    d25c:	cf 90       	pop	r12
    d25e:	bf 90       	pop	r11
    d260:	af 90       	pop	r10
    d262:	9f 90       	pop	r9
    d264:	8f 90       	pop	r8
    d266:	7f 90       	pop	r7
    d268:	6f 90       	pop	r6
    d26a:	5f 90       	pop	r5
    d26c:	4f 90       	pop	r4
    d26e:	3f 90       	pop	r3
    d270:	2f 90       	pop	r2
    d272:	08 95       	ret

0000d274 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_>:

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
{
    d274:	4f 92       	push	r4
    d276:	5f 92       	push	r5
    d278:	6f 92       	push	r6
    d27a:	7f 92       	push	r7
    d27c:	8f 92       	push	r8
    d27e:	9f 92       	push	r9
    d280:	af 92       	push	r10
    d282:	bf 92       	push	r11
    d284:	cf 92       	push	r12
    d286:	df 92       	push	r13
    d288:	ef 92       	push	r14
    d28a:	ff 92       	push	r15
    d28c:	0f 93       	push	r16
    d28e:	1f 93       	push	r17
    d290:	cf 93       	push	r28
    d292:	df 93       	push	r29
    d294:	4c 01       	movw	r8, r24
    d296:	46 2e       	mov	r4, r22
    d298:	57 2e       	mov	r5, r23
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
    d29a:	e4 2f       	mov	r30, r20
    d29c:	f5 2f       	mov	r31, r21
    d29e:	8c e0       	ldi	r24, 0x0C	; 12
    d2a0:	df 01       	movw	r26, r30
    d2a2:	1d 92       	st	X+, r1
    d2a4:	8a 95       	dec	r24
    d2a6:	e9 f7       	brne	.-6      	; 0xd2a2 <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x2e>
    d2a8:	e4 2e       	mov	r14, r20
    d2aa:	f5 2e       	mov	r15, r21
    d2ac:	a1 2c       	mov	r10, r1
    d2ae:	b1 2c       	mov	r11, r1
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d2b0:	0f 2e       	mov	r0, r31
    d2b2:	f3 e0       	ldi	r31, 0x03	; 3
    d2b4:	6f 2e       	mov	r6, r31
    d2b6:	71 2c       	mov	r7, r1
    d2b8:	f0 2d       	mov	r31, r0
    d2ba:	29 c0       	rjmp	.+82     	; 0xd30e <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x9a>
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
    d2bc:	f6 01       	movw	r30, r12
    d2be:	61 91       	ld	r22, Z+
    d2c0:	71 91       	ld	r23, Z+
    d2c2:	81 91       	ld	r24, Z+
    d2c4:	91 91       	ld	r25, Z+
    d2c6:	6f 01       	movw	r12, r30
    d2c8:	d8 01       	movw	r26, r16
    d2ca:	2d 91       	ld	r18, X+
    d2cc:	3d 91       	ld	r19, X+
    d2ce:	4d 91       	ld	r20, X+
    d2d0:	5d 91       	ld	r21, X+
    d2d2:	8d 01       	movw	r16, r26
    d2d4:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d2d8:	9b 01       	movw	r18, r22
    d2da:	ac 01       	movw	r20, r24
    d2dc:	f7 01       	movw	r30, r14
    d2de:	60 81       	ld	r22, Z
    d2e0:	71 81       	ldd	r23, Z+1	; 0x01
    d2e2:	82 81       	ldd	r24, Z+2	; 0x02
    d2e4:	93 81       	ldd	r25, Z+3	; 0x03
    d2e6:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    d2ea:	d7 01       	movw	r26, r14
    d2ec:	6d 93       	st	X+, r22
    d2ee:	7d 93       	st	X+, r23
    d2f0:	8d 93       	st	X+, r24
    d2f2:	9c 93       	st	X, r25
    d2f4:	13 97       	sbiw	r26, 0x03	; 3
    d2f6:	21 97       	sbiw	r28, 0x01	; 1
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
	{
		//iterate through the columns of the rotation matrix
		for (int column = 0; column < 3; column++)
    d2f8:	09 f7       	brne	.-62     	; 0xd2bc <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x48>
    d2fa:	bc e0       	ldi	r27, 0x0C	; 12
    d2fc:	ab 0e       	add	r10, r27
    d2fe:	b1 1c       	adc	r11, r1
    d300:	e4 e0       	ldi	r30, 0x04	; 4
    d302:	ee 0e       	add	r14, r30
    d304:	f1 1c       	adc	r15, r1
{
	//clear out the rotated values list;
	memset(rotatedValues,0,ARRAYSIZE);
	
	//iterate through the rows of the rotation matrix.
	for (int row = 0; row < 3; row++)
    d306:	f4 e2       	ldi	r31, 0x24	; 36
    d308:	af 16       	cp	r10, r31
    d30a:	b1 04       	cpc	r11, r1
    d30c:	39 f0       	breq	.+14     	; 0xd31c <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0xa8>
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}

void MatrixUtil::RotateMatrix( float rotationMatrix[][3], float valuesToRotate[3], float (&rotatedValues)[3] )
    d30e:	64 01       	movw	r12, r8
    d310:	ca 0c       	add	r12, r10
    d312:	db 1c       	adc	r13, r11
    d314:	04 2d       	mov	r16, r4
    d316:	15 2d       	mov	r17, r5
    d318:	e3 01       	movw	r28, r6
    d31a:	d0 cf       	rjmp	.-96     	; 0xd2bc <_ZN10helicopter4util10MatrixUtil12RotateMatrixEPA3_fPfRS2_+0x48>
		{
			//technically the rotatedMatrix[row] is writing to a 'column' in the matrix, and valuesToRotate is actually the 'row'.
			rotatedValues[row] += rotationMatrix[row] [column] * valuesToRotate[column];
		}
	}
}
    d31c:	df 91       	pop	r29
    d31e:	cf 91       	pop	r28
    d320:	1f 91       	pop	r17
    d322:	0f 91       	pop	r16
    d324:	ff 90       	pop	r15
    d326:	ef 90       	pop	r14
    d328:	df 90       	pop	r13
    d32a:	cf 90       	pop	r12
    d32c:	bf 90       	pop	r11
    d32e:	af 90       	pop	r10
    d330:	9f 90       	pop	r9
    d332:	8f 90       	pop	r8
    d334:	7f 90       	pop	r7
    d336:	6f 90       	pop	r6
    d338:	5f 90       	pop	r5
    d33a:	4f 90       	pop	r4
    d33c:	08 95       	ret

0000d33e <_ZN10helicopter4util10MatrixUtil10DotProductEPfS2_>:
	RotateMatrix(rotationMatrix, valuesToRotate, rotatedValues);
}


float MatrixUtil::DotProduct( float vector1[3], float vector2[3] )
{
    d33e:	cf 92       	push	r12
    d340:	df 92       	push	r13
    d342:	ef 92       	push	r14
    d344:	ff 92       	push	r15
    d346:	0f 93       	push	r16
    d348:	1f 93       	push	r17
    d34a:	cf 93       	push	r28
    d34c:	df 93       	push	r29
    d34e:	ec 01       	movw	r28, r24
    d350:	8b 01       	movw	r16, r22
	return vector1[0]*vector2[0] + vector1[1]*vector2[1] + vector1[2]*vector2[2];
    d352:	fb 01       	movw	r30, r22
    d354:	20 81       	ld	r18, Z
    d356:	31 81       	ldd	r19, Z+1	; 0x01
    d358:	42 81       	ldd	r20, Z+2	; 0x02
    d35a:	53 81       	ldd	r21, Z+3	; 0x03
    d35c:	68 81       	ld	r22, Y
    d35e:	79 81       	ldd	r23, Y+1	; 0x01
    d360:	8a 81       	ldd	r24, Y+2	; 0x02
    d362:	9b 81       	ldd	r25, Y+3	; 0x03
    d364:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d368:	6b 01       	movw	r12, r22
    d36a:	7c 01       	movw	r14, r24
    d36c:	f8 01       	movw	r30, r16
    d36e:	24 81       	ldd	r18, Z+4	; 0x04
    d370:	35 81       	ldd	r19, Z+5	; 0x05
    d372:	46 81       	ldd	r20, Z+6	; 0x06
    d374:	57 81       	ldd	r21, Z+7	; 0x07
    d376:	6c 81       	ldd	r22, Y+4	; 0x04
    d378:	7d 81       	ldd	r23, Y+5	; 0x05
    d37a:	8e 81       	ldd	r24, Y+6	; 0x06
    d37c:	9f 81       	ldd	r25, Y+7	; 0x07
    d37e:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d382:	9b 01       	movw	r18, r22
    d384:	ac 01       	movw	r20, r24
    d386:	c7 01       	movw	r24, r14
    d388:	b6 01       	movw	r22, r12
    d38a:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
    d38e:	6b 01       	movw	r12, r22
    d390:	7c 01       	movw	r14, r24
    d392:	f8 01       	movw	r30, r16
    d394:	20 85       	ldd	r18, Z+8	; 0x08
    d396:	31 85       	ldd	r19, Z+9	; 0x09
    d398:	42 85       	ldd	r20, Z+10	; 0x0a
    d39a:	53 85       	ldd	r21, Z+11	; 0x0b
    d39c:	68 85       	ldd	r22, Y+8	; 0x08
    d39e:	79 85       	ldd	r23, Y+9	; 0x09
    d3a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    d3a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    d3a4:	0e 94 cd 6d 	call	0xdb9a	; 0xdb9a <__mulsf3>
    d3a8:	9b 01       	movw	r18, r22
    d3aa:	ac 01       	movw	r20, r24
    d3ac:	c7 01       	movw	r24, r14
    d3ae:	b6 01       	movw	r22, r12
    d3b0:	0e 94 6b 6a 	call	0xd4d6	; 0xd4d6 <__addsf3>
}
    d3b4:	df 91       	pop	r29
    d3b6:	cf 91       	pop	r28
    d3b8:	1f 91       	pop	r17
    d3ba:	0f 91       	pop	r16
    d3bc:	ff 90       	pop	r15
    d3be:	ef 90       	pop	r14
    d3c0:	df 90       	pop	r13
    d3c2:	cf 90       	pop	r12
    d3c4:	08 95       	ret

0000d3c6 <_ZN10helicopter4util5Timer11hasTimedoutEv>:
{
	//Check the Timer Interrupt Flags Register (TIFR) to determine if the flag was set indicating
	//that the timer has timed out.
	//return (TIFR0 & (1<<OCF0A)) != 0;
	
	return timeoutCounter>=numberOfTimeouts;
    d3c6:	61 e0       	ldi	r22, 0x01	; 1
    d3c8:	fc 01       	movw	r30, r24
    d3ca:	40 85       	ldd	r20, Z+8	; 0x08
    d3cc:	51 85       	ldd	r21, Z+9	; 0x09
    d3ce:	20 91 7a 10 	lds	r18, 0x107A
    d3d2:	30 91 7b 10 	lds	r19, 0x107B
    d3d6:	24 17       	cp	r18, r20
    d3d8:	35 07       	cpc	r19, r21
    d3da:	0c f4       	brge	.+2      	; 0xd3de <_ZN10helicopter4util5Timer11hasTimedoutEv+0x18>
    d3dc:	60 e0       	ldi	r22, 0x00	; 0
}
    d3de:	86 2f       	mov	r24, r22
    d3e0:	08 95       	ret

0000d3e2 <_ZN10helicopter4util5Timer9stopTimerEv>:

void Timer::stopTimer()
{
	//Disable interrupt.
	TIMSK0 &= ~(1 << OCIE0A);
    d3e2:	ee e6       	ldi	r30, 0x6E	; 110
    d3e4:	f0 e0       	ldi	r31, 0x00	; 0
    d3e6:	80 81       	ld	r24, Z
    d3e8:	8d 7f       	andi	r24, 0xFD	; 253
    d3ea:	80 83       	st	Z, r24
	
	//stop the timer
	TCCR0B = 0;
    d3ec:	15 bc       	out	0x25, r1	; 37
	
	//Then clear the timer counter (sets the count back to 0 so when the timer starts again, it starts from 0). 
	//Clear after stopping in order to avoid missing a compare match.
	TCNT0 = 0;
    d3ee:	16 bc       	out	0x26, r1	; 38
	
	//clear the timeout flag.
	TIFR0 |= (1<<OCF0A);
    d3f0:	a9 9a       	sbi	0x15, 1	; 21
	
	timeoutCounter = 0;
    d3f2:	10 92 7b 10 	sts	0x107B, r1
    d3f6:	10 92 7a 10 	sts	0x107A, r1
    d3fa:	08 95       	ret

0000d3fc <_ZN10helicopter4util5Timer10startTimerEv>:

int Timer::timeoutCounter = 0;


void Timer::startTimer()
{
    d3fc:	cf 93       	push	r28
    d3fe:	df 93       	push	r29
    d400:	ec 01       	movw	r28, r24
	//stop timer in case it was already started.
	stopTimer();
    d402:	0e 94 f1 69 	call	0xd3e2	; 0xd3e2 <_ZN10helicopter4util5Timer9stopTimerEv>
	//setup timer.
	//set the output compare register so that when the Timer Counter (TCNT) matches this output register
	//it indicates that the timer has timed out.
	OCR0A = ((cpuSpeed /  timerPrescaler) / frequency);
	*/ 
	OCR0A = ((cpuSpeed /  timerPrescaler) / 100); //fire off every 10 ms. 
    d406:	2c 81       	ldd	r18, Y+4	; 0x04
    d408:	3d 81       	ldd	r19, Y+5	; 0x05
    d40a:	44 27       	eor	r20, r20
    d40c:	37 fd       	sbrc	r19, 7
    d40e:	40 95       	com	r20
    d410:	54 2f       	mov	r21, r20
    d412:	68 81       	ld	r22, Y
    d414:	79 81       	ldd	r23, Y+1	; 0x01
    d416:	8a 81       	ldd	r24, Y+2	; 0x02
    d418:	9b 81       	ldd	r25, Y+3	; 0x03
    d41a:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    d41e:	ca 01       	movw	r24, r20
    d420:	b9 01       	movw	r22, r18
    d422:	24 e6       	ldi	r18, 0x64	; 100
    d424:	30 e0       	ldi	r19, 0x00	; 0
    d426:	40 e0       	ldi	r20, 0x00	; 0
    d428:	50 e0       	ldi	r21, 0x00	; 0
    d42a:	0e 94 6c 6f 	call	0xded8	; 0xded8 <__udivmodsi4>
    d42e:	27 bd       	out	0x27, r18	; 39
	timeoutCounter = 0;
    d430:	10 92 7b 10 	sts	0x107B, r1
    d434:	10 92 7a 10 	sts	0x107A, r1
		
	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
	//note, this is different than the 8 bit timer which sets wgmn1 on tccrna to set CTC.
	TCCR0A |= (1 << WGM01); 
    d438:	84 b5       	in	r24, 0x24	; 36
    d43a:	82 60       	ori	r24, 0x02	; 2
    d43c:	84 bd       	out	0x24, r24	; 36
		
	//TCCR3A |= (1 << WGM31);	//Configure timer 1 for Clear on Timer Compare (CTC) mode so that if there is a match, the TCNT goes back to 0.
		
	
	
	TIMSK0 |= (1 << OCIE0A); //enable ctc interrupt for OCR0A
    d43e:	ee e6       	ldi	r30, 0x6E	; 110
    d440:	f0 e0       	ldi	r31, 0x00	; 0
    d442:	80 81       	ld	r24, Z
    d444:	82 60       	ori	r24, 0x02	; 2
    d446:	80 83       	st	Z, r24
		
		
		
	//Set the Timer Counter Control Register (TCCR) with the appropriate prescaller
	//which causes the timer counter to start (i.e. the timer starts).
	switch(timerPrescaler)
    d448:	8c 81       	ldd	r24, Y+4	; 0x04
    d44a:	9d 81       	ldd	r25, Y+5	; 0x05
    d44c:	80 34       	cpi	r24, 0x40	; 64
    d44e:	91 05       	cpc	r25, r1
    d450:	b9 f0       	breq	.+46     	; 0xd480 <_ZN10helicopter4util5Timer10startTimerEv+0x84>
    d452:	34 f4       	brge	.+12     	; 0xd460 <_ZN10helicopter4util5Timer10startTimerEv+0x64>
    d454:	81 30       	cpi	r24, 0x01	; 1
    d456:	91 05       	cpc	r25, r1
    d458:	59 f0       	breq	.+22     	; 0xd470 <_ZN10helicopter4util5Timer10startTimerEv+0x74>
    d45a:	08 97       	sbiw	r24, 0x08	; 8
    d45c:	e9 f4       	brne	.+58     	; 0xd498 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
    d45e:	0c c0       	rjmp	.+24     	; 0xd478 <_ZN10helicopter4util5Timer10startTimerEv+0x7c>
    d460:	81 15       	cp	r24, r1
    d462:	21 e0       	ldi	r18, 0x01	; 1
    d464:	92 07       	cpc	r25, r18
    d466:	81 f0       	breq	.+32     	; 0xd488 <_ZN10helicopter4util5Timer10startTimerEv+0x8c>
    d468:	81 15       	cp	r24, r1
    d46a:	94 40       	sbci	r25, 0x04	; 4
    d46c:	a9 f4       	brne	.+42     	; 0xd498 <_ZN10helicopter4util5Timer10startTimerEv+0x9c>
    d46e:	10 c0       	rjmp	.+32     	; 0xd490 <_ZN10helicopter4util5Timer10startTimerEv+0x94>
	{
		case NO_PRESCALER:
		TCCR0B |= NoPrescaling;
    d470:	85 b5       	in	r24, 0x25	; 37
    d472:	81 60       	ori	r24, 0x01	; 1
    d474:	85 bd       	out	0x25, r24	; 37
		break;
    d476:	13 c0       	rjmp	.+38     	; 0xd49e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_EIGHT:
		TCCR0B |= PrescaleByEight;
    d478:	85 b5       	in	r24, 0x25	; 37
    d47a:	82 60       	ori	r24, 0x02	; 2
    d47c:	85 bd       	out	0x25, r24	; 37
		break;
    d47e:	0f c0       	rjmp	.+30     	; 0xd49e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_SIXTYFOUR:
		TCCR0B |= PrescaleBySixtyFour;
    d480:	85 b5       	in	r24, 0x25	; 37
    d482:	83 60       	ori	r24, 0x03	; 3
    d484:	85 bd       	out	0x25, r24	; 37
		break;
    d486:	0b c0       	rjmp	.+22     	; 0xd49e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TWOFIFTYSIX:
		TCCR0B |= PrescaleByTwofiftysix;
    d488:	85 b5       	in	r24, 0x25	; 37
    d48a:	84 60       	ori	r24, 0x04	; 4
    d48c:	85 bd       	out	0x25, r24	; 37
		break;
    d48e:	07 c0       	rjmp	.+14     	; 0xd49e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		case PRESCALE_BY_TENTWENTYFOUR:
		TCCR0B |= PrescaleByTentwentyfour;
    d490:	85 b5       	in	r24, 0x25	; 37
    d492:	85 60       	ori	r24, 0x05	; 5
    d494:	85 bd       	out	0x25, r24	; 37
		break;
    d496:	03 c0       	rjmp	.+6      	; 0xd49e <_ZN10helicopter4util5Timer10startTimerEv+0xa2>
		default:
		TCCR0B |= NoPrescaling;
    d498:	85 b5       	in	r24, 0x25	; 37
    d49a:	81 60       	ori	r24, 0x01	; 1
    d49c:	85 bd       	out	0x25, r24	; 37
	}
	
	sei();
    d49e:	78 94       	sei
}
    d4a0:	df 91       	pop	r29
    d4a2:	cf 91       	pop	r28
    d4a4:	08 95       	ret

0000d4a6 <__vector_21>:
	
	timeoutCounter = 0;
}

ISR(TIMER0_COMPA_vect)
{
    d4a6:	1f 92       	push	r1
    d4a8:	0f 92       	push	r0
    d4aa:	0f b6       	in	r0, 0x3f	; 63
    d4ac:	0f 92       	push	r0
    d4ae:	11 24       	eor	r1, r1
    d4b0:	8f 93       	push	r24
    d4b2:	9f 93       	push	r25
	Timer::timeoutCounter++;
    d4b4:	80 91 7a 10 	lds	r24, 0x107A
    d4b8:	90 91 7b 10 	lds	r25, 0x107B
    d4bc:	01 96       	adiw	r24, 0x01	; 1
    d4be:	90 93 7b 10 	sts	0x107B, r25
    d4c2:	80 93 7a 10 	sts	0x107A, r24
    d4c6:	9f 91       	pop	r25
    d4c8:	8f 91       	pop	r24
    d4ca:	0f 90       	pop	r0
    d4cc:	0f be       	out	0x3f, r0	; 63
    d4ce:	0f 90       	pop	r0
    d4d0:	1f 90       	pop	r1
    d4d2:	18 95       	reti

0000d4d4 <__subsf3>:
    d4d4:	50 58       	subi	r21, 0x80	; 128

0000d4d6 <__addsf3>:
    d4d6:	bb 27       	eor	r27, r27
    d4d8:	aa 27       	eor	r26, r26
    d4da:	0e d0       	rcall	.+28     	; 0xd4f8 <__addsf3x>
    d4dc:	a6 c2       	rjmp	.+1356   	; 0xda2a <__fp_round>
    d4de:	6f d2       	rcall	.+1246   	; 0xd9be <__fp_pscA>
    d4e0:	30 f0       	brcs	.+12     	; 0xd4ee <__addsf3+0x18>
    d4e2:	74 d2       	rcall	.+1256   	; 0xd9cc <__fp_pscB>
    d4e4:	20 f0       	brcs	.+8      	; 0xd4ee <__addsf3+0x18>
    d4e6:	31 f4       	brne	.+12     	; 0xd4f4 <__addsf3+0x1e>
    d4e8:	9f 3f       	cpi	r25, 0xFF	; 255
    d4ea:	11 f4       	brne	.+4      	; 0xd4f0 <__addsf3+0x1a>
    d4ec:	1e f4       	brtc	.+6      	; 0xd4f4 <__addsf3+0x1e>
    d4ee:	2e c2       	rjmp	.+1116   	; 0xd94c <__fp_nan>
    d4f0:	0e f4       	brtc	.+2      	; 0xd4f4 <__addsf3+0x1e>
    d4f2:	e0 95       	com	r30
    d4f4:	e7 fb       	bst	r30, 7
    d4f6:	fb c1       	rjmp	.+1014   	; 0xd8ee <__fp_inf>

0000d4f8 <__addsf3x>:
    d4f8:	e9 2f       	mov	r30, r25
    d4fa:	b9 d2       	rcall	.+1394   	; 0xda6e <__fp_split3>
    d4fc:	80 f3       	brcs	.-32     	; 0xd4de <__addsf3+0x8>
    d4fe:	ba 17       	cp	r27, r26
    d500:	62 07       	cpc	r22, r18
    d502:	73 07       	cpc	r23, r19
    d504:	84 07       	cpc	r24, r20
    d506:	95 07       	cpc	r25, r21
    d508:	18 f0       	brcs	.+6      	; 0xd510 <__addsf3x+0x18>
    d50a:	71 f4       	brne	.+28     	; 0xd528 <__addsf3x+0x30>
    d50c:	9e f5       	brtc	.+102    	; 0xd574 <__addsf3x+0x7c>
    d50e:	e8 c2       	rjmp	.+1488   	; 0xdae0 <__fp_zero>
    d510:	0e f4       	brtc	.+2      	; 0xd514 <__addsf3x+0x1c>
    d512:	e0 95       	com	r30
    d514:	0b 2e       	mov	r0, r27
    d516:	ba 2f       	mov	r27, r26
    d518:	a0 2d       	mov	r26, r0
    d51a:	0b 01       	movw	r0, r22
    d51c:	b9 01       	movw	r22, r18
    d51e:	90 01       	movw	r18, r0
    d520:	0c 01       	movw	r0, r24
    d522:	ca 01       	movw	r24, r20
    d524:	a0 01       	movw	r20, r0
    d526:	11 24       	eor	r1, r1
    d528:	ff 27       	eor	r31, r31
    d52a:	59 1b       	sub	r21, r25
    d52c:	99 f0       	breq	.+38     	; 0xd554 <__addsf3x+0x5c>
    d52e:	59 3f       	cpi	r21, 0xF9	; 249
    d530:	50 f4       	brcc	.+20     	; 0xd546 <__addsf3x+0x4e>
    d532:	50 3e       	cpi	r21, 0xE0	; 224
    d534:	68 f1       	brcs	.+90     	; 0xd590 <__addsf3x+0x98>
    d536:	1a 16       	cp	r1, r26
    d538:	f0 40       	sbci	r31, 0x00	; 0
    d53a:	a2 2f       	mov	r26, r18
    d53c:	23 2f       	mov	r18, r19
    d53e:	34 2f       	mov	r19, r20
    d540:	44 27       	eor	r20, r20
    d542:	58 5f       	subi	r21, 0xF8	; 248
    d544:	f3 cf       	rjmp	.-26     	; 0xd52c <__addsf3x+0x34>
    d546:	46 95       	lsr	r20
    d548:	37 95       	ror	r19
    d54a:	27 95       	ror	r18
    d54c:	a7 95       	ror	r26
    d54e:	f0 40       	sbci	r31, 0x00	; 0
    d550:	53 95       	inc	r21
    d552:	c9 f7       	brne	.-14     	; 0xd546 <__addsf3x+0x4e>
    d554:	7e f4       	brtc	.+30     	; 0xd574 <__addsf3x+0x7c>
    d556:	1f 16       	cp	r1, r31
    d558:	ba 0b       	sbc	r27, r26
    d55a:	62 0b       	sbc	r22, r18
    d55c:	73 0b       	sbc	r23, r19
    d55e:	84 0b       	sbc	r24, r20
    d560:	ba f0       	brmi	.+46     	; 0xd590 <__addsf3x+0x98>
    d562:	91 50       	subi	r25, 0x01	; 1
    d564:	a1 f0       	breq	.+40     	; 0xd58e <__addsf3x+0x96>
    d566:	ff 0f       	add	r31, r31
    d568:	bb 1f       	adc	r27, r27
    d56a:	66 1f       	adc	r22, r22
    d56c:	77 1f       	adc	r23, r23
    d56e:	88 1f       	adc	r24, r24
    d570:	c2 f7       	brpl	.-16     	; 0xd562 <__addsf3x+0x6a>
    d572:	0e c0       	rjmp	.+28     	; 0xd590 <__addsf3x+0x98>
    d574:	ba 0f       	add	r27, r26
    d576:	62 1f       	adc	r22, r18
    d578:	73 1f       	adc	r23, r19
    d57a:	84 1f       	adc	r24, r20
    d57c:	48 f4       	brcc	.+18     	; 0xd590 <__addsf3x+0x98>
    d57e:	87 95       	ror	r24
    d580:	77 95       	ror	r23
    d582:	67 95       	ror	r22
    d584:	b7 95       	ror	r27
    d586:	f7 95       	ror	r31
    d588:	9e 3f       	cpi	r25, 0xFE	; 254
    d58a:	08 f0       	brcs	.+2      	; 0xd58e <__addsf3x+0x96>
    d58c:	b3 cf       	rjmp	.-154    	; 0xd4f4 <__addsf3+0x1e>
    d58e:	93 95       	inc	r25
    d590:	88 0f       	add	r24, r24
    d592:	08 f0       	brcs	.+2      	; 0xd596 <__addsf3x+0x9e>
    d594:	99 27       	eor	r25, r25
    d596:	ee 0f       	add	r30, r30
    d598:	97 95       	ror	r25
    d59a:	87 95       	ror	r24
    d59c:	08 95       	ret

0000d59e <asin>:
    d59e:	9f 93       	push	r25
    d5a0:	9f 77       	andi	r25, 0x7F	; 127
    d5a2:	ee e3       	ldi	r30, 0x3E	; 62
    d5a4:	89 37       	cpi	r24, 0x79	; 121
    d5a6:	9e 07       	cpc	r25, r30
    d5a8:	20 f4       	brcc	.+8      	; 0xd5b2 <asin+0x14>
    d5aa:	e4 ee       	ldi	r30, 0xE4	; 228
    d5ac:	f0 e0       	ldi	r31, 0x00	; 0
    d5ae:	f6 d1       	rcall	.+1004   	; 0xd99c <__fp_powsodd>
    d5b0:	09 c0       	rjmp	.+18     	; 0xd5c4 <asin+0x26>
    d5b2:	5e d1       	rcall	.+700    	; 0xd870 <__fp_arccos>
    d5b4:	90 58       	subi	r25, 0x80	; 128
    d5b6:	a2 ea       	ldi	r26, 0xA2	; 162
    d5b8:	2a ed       	ldi	r18, 0xDA	; 218
    d5ba:	3f e0       	ldi	r19, 0x0F	; 15
    d5bc:	49 ec       	ldi	r20, 0xC9	; 201
    d5be:	5f e3       	ldi	r21, 0x3F	; 63
    d5c0:	9b df       	rcall	.-202    	; 0xd4f8 <__addsf3x>
    d5c2:	33 d2       	rcall	.+1126   	; 0xda2a <__fp_round>
    d5c4:	0f 90       	pop	r0
    d5c6:	07 fc       	sbrc	r0, 7
    d5c8:	90 58       	subi	r25, 0x80	; 128
    d5ca:	08 95       	ret
    d5cc:	f8 d1       	rcall	.+1008   	; 0xd9be <__fp_pscA>
    d5ce:	58 f0       	brcs	.+22     	; 0xd5e6 <asin+0x48>
    d5d0:	80 e8       	ldi	r24, 0x80	; 128
    d5d2:	91 e0       	ldi	r25, 0x01	; 1
    d5d4:	09 f4       	brne	.+2      	; 0xd5d8 <asin+0x3a>
    d5d6:	9e ef       	ldi	r25, 0xFE	; 254
    d5d8:	f9 d1       	rcall	.+1010   	; 0xd9cc <__fp_pscB>
    d5da:	28 f0       	brcs	.+10     	; 0xd5e6 <asin+0x48>
    d5dc:	40 e8       	ldi	r20, 0x80	; 128
    d5de:	51 e0       	ldi	r21, 0x01	; 1
    d5e0:	59 f4       	brne	.+22     	; 0xd5f8 <atan2+0xe>
    d5e2:	5e ef       	ldi	r21, 0xFE	; 254
    d5e4:	09 c0       	rjmp	.+18     	; 0xd5f8 <atan2+0xe>
    d5e6:	b2 c1       	rjmp	.+868    	; 0xd94c <__fp_nan>
    d5e8:	7b c2       	rjmp	.+1270   	; 0xdae0 <__fp_zero>

0000d5ea <atan2>:
    d5ea:	e9 2f       	mov	r30, r25
    d5ec:	e0 78       	andi	r30, 0x80	; 128
    d5ee:	3f d2       	rcall	.+1150   	; 0xda6e <__fp_split3>
    d5f0:	68 f3       	brcs	.-38     	; 0xd5cc <asin+0x2e>
    d5f2:	09 2e       	mov	r0, r25
    d5f4:	05 2a       	or	r0, r21
    d5f6:	c1 f3       	breq	.-16     	; 0xd5e8 <asin+0x4a>
    d5f8:	26 17       	cp	r18, r22
    d5fa:	37 07       	cpc	r19, r23
    d5fc:	48 07       	cpc	r20, r24
    d5fe:	59 07       	cpc	r21, r25
    d600:	38 f0       	brcs	.+14     	; 0xd610 <atan2+0x26>
    d602:	0e 2e       	mov	r0, r30
    d604:	07 f8       	bld	r0, 7
    d606:	e0 25       	eor	r30, r0
    d608:	69 f0       	breq	.+26     	; 0xd624 <atan2+0x3a>
    d60a:	e0 25       	eor	r30, r0
    d60c:	e0 64       	ori	r30, 0x40	; 64
    d60e:	0a c0       	rjmp	.+20     	; 0xd624 <atan2+0x3a>
    d610:	ef 63       	ori	r30, 0x3F	; 63
    d612:	07 f8       	bld	r0, 7
    d614:	00 94       	com	r0
    d616:	07 fa       	bst	r0, 7
    d618:	db 01       	movw	r26, r22
    d61a:	b9 01       	movw	r22, r18
    d61c:	9d 01       	movw	r18, r26
    d61e:	dc 01       	movw	r26, r24
    d620:	ca 01       	movw	r24, r20
    d622:	ad 01       	movw	r20, r26
    d624:	ef 93       	push	r30
    d626:	4a d0       	rcall	.+148    	; 0xd6bc <__divsf3_pse>
    d628:	00 d2       	rcall	.+1024   	; 0xda2a <__fp_round>
    d62a:	0a d0       	rcall	.+20     	; 0xd640 <atan>
    d62c:	5f 91       	pop	r21
    d62e:	55 23       	and	r21, r21
    d630:	31 f0       	breq	.+12     	; 0xd63e <atan2+0x54>
    d632:	2b ed       	ldi	r18, 0xDB	; 219
    d634:	3f e0       	ldi	r19, 0x0F	; 15
    d636:	49 e4       	ldi	r20, 0x49	; 73
    d638:	50 fd       	sbrc	r21, 0
    d63a:	49 ec       	ldi	r20, 0xC9	; 201
    d63c:	4c cf       	rjmp	.-360    	; 0xd4d6 <__addsf3>
    d63e:	08 95       	ret

0000d640 <atan>:
    d640:	df 93       	push	r29
    d642:	dd 27       	eor	r29, r29
    d644:	b9 2f       	mov	r27, r25
    d646:	bf 77       	andi	r27, 0x7F	; 127
    d648:	40 e8       	ldi	r20, 0x80	; 128
    d64a:	5f e3       	ldi	r21, 0x3F	; 63
    d64c:	16 16       	cp	r1, r22
    d64e:	17 06       	cpc	r1, r23
    d650:	48 07       	cpc	r20, r24
    d652:	5b 07       	cpc	r21, r27
    d654:	10 f4       	brcc	.+4      	; 0xd65a <atan+0x1a>
    d656:	d9 2f       	mov	r29, r25
    d658:	4e d2       	rcall	.+1180   	; 0xdaf6 <inverse>
    d65a:	9f 93       	push	r25
    d65c:	8f 93       	push	r24
    d65e:	7f 93       	push	r23
    d660:	6f 93       	push	r22
    d662:	92 d3       	rcall	.+1828   	; 0xdd88 <square>
    d664:	e8 ef       	ldi	r30, 0xF8	; 248
    d666:	f0 e0       	ldi	r31, 0x00	; 0
    d668:	74 d1       	rcall	.+744    	; 0xd952 <__fp_powser>
    d66a:	df d1       	rcall	.+958    	; 0xda2a <__fp_round>
    d66c:	2f 91       	pop	r18
    d66e:	3f 91       	pop	r19
    d670:	4f 91       	pop	r20
    d672:	5f 91       	pop	r21
    d674:	9e d2       	rcall	.+1340   	; 0xdbb2 <__mulsf3x>
    d676:	dd 23       	and	r29, r29
    d678:	49 f0       	breq	.+18     	; 0xd68c <atan+0x4c>
    d67a:	90 58       	subi	r25, 0x80	; 128
    d67c:	a2 ea       	ldi	r26, 0xA2	; 162
    d67e:	2a ed       	ldi	r18, 0xDA	; 218
    d680:	3f e0       	ldi	r19, 0x0F	; 15
    d682:	49 ec       	ldi	r20, 0xC9	; 201
    d684:	5f e3       	ldi	r21, 0x3F	; 63
    d686:	d0 78       	andi	r29, 0x80	; 128
    d688:	5d 27       	eor	r21, r29
    d68a:	36 df       	rcall	.-404    	; 0xd4f8 <__addsf3x>
    d68c:	df 91       	pop	r29
    d68e:	cd c1       	rjmp	.+922    	; 0xda2a <__fp_round>

0000d690 <__cmpsf2>:
    d690:	0a d1       	rcall	.+532    	; 0xd8a6 <__fp_cmp>
    d692:	08 f4       	brcc	.+2      	; 0xd696 <__cmpsf2+0x6>
    d694:	81 e0       	ldi	r24, 0x01	; 1
    d696:	08 95       	ret

0000d698 <cos>:
    d698:	a1 d1       	rcall	.+834    	; 0xd9dc <__fp_rempio2>
    d69a:	e3 95       	inc	r30
    d69c:	d7 c1       	rjmp	.+942    	; 0xda4c <__fp_sinus>

0000d69e <__divsf3>:
    d69e:	0c d0       	rcall	.+24     	; 0xd6b8 <__divsf3x>
    d6a0:	c4 c1       	rjmp	.+904    	; 0xda2a <__fp_round>
    d6a2:	94 d1       	rcall	.+808    	; 0xd9cc <__fp_pscB>
    d6a4:	40 f0       	brcs	.+16     	; 0xd6b6 <__divsf3+0x18>
    d6a6:	8b d1       	rcall	.+790    	; 0xd9be <__fp_pscA>
    d6a8:	30 f0       	brcs	.+12     	; 0xd6b6 <__divsf3+0x18>
    d6aa:	21 f4       	brne	.+8      	; 0xd6b4 <__divsf3+0x16>
    d6ac:	5f 3f       	cpi	r21, 0xFF	; 255
    d6ae:	19 f0       	breq	.+6      	; 0xd6b6 <__divsf3+0x18>
    d6b0:	1e c1       	rjmp	.+572    	; 0xd8ee <__fp_inf>
    d6b2:	51 11       	cpse	r21, r1
    d6b4:	16 c2       	rjmp	.+1068   	; 0xdae2 <__fp_szero>
    d6b6:	4a c1       	rjmp	.+660    	; 0xd94c <__fp_nan>

0000d6b8 <__divsf3x>:
    d6b8:	da d1       	rcall	.+948    	; 0xda6e <__fp_split3>
    d6ba:	98 f3       	brcs	.-26     	; 0xd6a2 <__divsf3+0x4>

0000d6bc <__divsf3_pse>:
    d6bc:	99 23       	and	r25, r25
    d6be:	c9 f3       	breq	.-14     	; 0xd6b2 <__divsf3+0x14>
    d6c0:	55 23       	and	r21, r21
    d6c2:	b1 f3       	breq	.-20     	; 0xd6b0 <__divsf3+0x12>
    d6c4:	95 1b       	sub	r25, r21
    d6c6:	55 0b       	sbc	r21, r21
    d6c8:	bb 27       	eor	r27, r27
    d6ca:	aa 27       	eor	r26, r26
    d6cc:	62 17       	cp	r22, r18
    d6ce:	73 07       	cpc	r23, r19
    d6d0:	84 07       	cpc	r24, r20
    d6d2:	38 f0       	brcs	.+14     	; 0xd6e2 <__divsf3_pse+0x26>
    d6d4:	9f 5f       	subi	r25, 0xFF	; 255
    d6d6:	5f 4f       	sbci	r21, 0xFF	; 255
    d6d8:	22 0f       	add	r18, r18
    d6da:	33 1f       	adc	r19, r19
    d6dc:	44 1f       	adc	r20, r20
    d6de:	aa 1f       	adc	r26, r26
    d6e0:	a9 f3       	breq	.-22     	; 0xd6cc <__divsf3_pse+0x10>
    d6e2:	33 d0       	rcall	.+102    	; 0xd74a <__divsf3_pse+0x8e>
    d6e4:	0e 2e       	mov	r0, r30
    d6e6:	3a f0       	brmi	.+14     	; 0xd6f6 <__divsf3_pse+0x3a>
    d6e8:	e0 e8       	ldi	r30, 0x80	; 128
    d6ea:	30 d0       	rcall	.+96     	; 0xd74c <__divsf3_pse+0x90>
    d6ec:	91 50       	subi	r25, 0x01	; 1
    d6ee:	50 40       	sbci	r21, 0x00	; 0
    d6f0:	e6 95       	lsr	r30
    d6f2:	00 1c       	adc	r0, r0
    d6f4:	ca f7       	brpl	.-14     	; 0xd6e8 <__divsf3_pse+0x2c>
    d6f6:	29 d0       	rcall	.+82     	; 0xd74a <__divsf3_pse+0x8e>
    d6f8:	fe 2f       	mov	r31, r30
    d6fa:	27 d0       	rcall	.+78     	; 0xd74a <__divsf3_pse+0x8e>
    d6fc:	66 0f       	add	r22, r22
    d6fe:	77 1f       	adc	r23, r23
    d700:	88 1f       	adc	r24, r24
    d702:	bb 1f       	adc	r27, r27
    d704:	26 17       	cp	r18, r22
    d706:	37 07       	cpc	r19, r23
    d708:	48 07       	cpc	r20, r24
    d70a:	ab 07       	cpc	r26, r27
    d70c:	b0 e8       	ldi	r27, 0x80	; 128
    d70e:	09 f0       	breq	.+2      	; 0xd712 <__divsf3_pse+0x56>
    d710:	bb 0b       	sbc	r27, r27
    d712:	80 2d       	mov	r24, r0
    d714:	bf 01       	movw	r22, r30
    d716:	ff 27       	eor	r31, r31
    d718:	93 58       	subi	r25, 0x83	; 131
    d71a:	5f 4f       	sbci	r21, 0xFF	; 255
    d71c:	2a f0       	brmi	.+10     	; 0xd728 <__divsf3_pse+0x6c>
    d71e:	9e 3f       	cpi	r25, 0xFE	; 254
    d720:	51 05       	cpc	r21, r1
    d722:	68 f0       	brcs	.+26     	; 0xd73e <__divsf3_pse+0x82>
    d724:	e4 c0       	rjmp	.+456    	; 0xd8ee <__fp_inf>
    d726:	dd c1       	rjmp	.+954    	; 0xdae2 <__fp_szero>
    d728:	5f 3f       	cpi	r21, 0xFF	; 255
    d72a:	ec f3       	brlt	.-6      	; 0xd726 <__divsf3_pse+0x6a>
    d72c:	98 3e       	cpi	r25, 0xE8	; 232
    d72e:	dc f3       	brlt	.-10     	; 0xd726 <__divsf3_pse+0x6a>
    d730:	86 95       	lsr	r24
    d732:	77 95       	ror	r23
    d734:	67 95       	ror	r22
    d736:	b7 95       	ror	r27
    d738:	f7 95       	ror	r31
    d73a:	9f 5f       	subi	r25, 0xFF	; 255
    d73c:	c9 f7       	brne	.-14     	; 0xd730 <__divsf3_pse+0x74>
    d73e:	88 0f       	add	r24, r24
    d740:	91 1d       	adc	r25, r1
    d742:	96 95       	lsr	r25
    d744:	87 95       	ror	r24
    d746:	97 f9       	bld	r25, 7
    d748:	08 95       	ret
    d74a:	e1 e0       	ldi	r30, 0x01	; 1
    d74c:	66 0f       	add	r22, r22
    d74e:	77 1f       	adc	r23, r23
    d750:	88 1f       	adc	r24, r24
    d752:	bb 1f       	adc	r27, r27
    d754:	62 17       	cp	r22, r18
    d756:	73 07       	cpc	r23, r19
    d758:	84 07       	cpc	r24, r20
    d75a:	ba 07       	cpc	r27, r26
    d75c:	20 f0       	brcs	.+8      	; 0xd766 <__divsf3_pse+0xaa>
    d75e:	62 1b       	sub	r22, r18
    d760:	73 0b       	sbc	r23, r19
    d762:	84 0b       	sbc	r24, r20
    d764:	ba 0b       	sbc	r27, r26
    d766:	ee 1f       	adc	r30, r30
    d768:	88 f7       	brcc	.-30     	; 0xd74c <__divsf3_pse+0x90>
    d76a:	e0 95       	com	r30
    d76c:	08 95       	ret

0000d76e <__fixsfsi>:
    d76e:	04 d0       	rcall	.+8      	; 0xd778 <__fixunssfsi>
    d770:	68 94       	set
    d772:	b1 11       	cpse	r27, r1
    d774:	b6 c1       	rjmp	.+876    	; 0xdae2 <__fp_szero>
    d776:	08 95       	ret

0000d778 <__fixunssfsi>:
    d778:	82 d1       	rcall	.+772    	; 0xda7e <__fp_splitA>
    d77a:	88 f0       	brcs	.+34     	; 0xd79e <__fixunssfsi+0x26>
    d77c:	9f 57       	subi	r25, 0x7F	; 127
    d77e:	90 f0       	brcs	.+36     	; 0xd7a4 <__fixunssfsi+0x2c>
    d780:	b9 2f       	mov	r27, r25
    d782:	99 27       	eor	r25, r25
    d784:	b7 51       	subi	r27, 0x17	; 23
    d786:	a0 f0       	brcs	.+40     	; 0xd7b0 <__fixunssfsi+0x38>
    d788:	d1 f0       	breq	.+52     	; 0xd7be <__fixunssfsi+0x46>
    d78a:	66 0f       	add	r22, r22
    d78c:	77 1f       	adc	r23, r23
    d78e:	88 1f       	adc	r24, r24
    d790:	99 1f       	adc	r25, r25
    d792:	1a f0       	brmi	.+6      	; 0xd79a <__fixunssfsi+0x22>
    d794:	ba 95       	dec	r27
    d796:	c9 f7       	brne	.-14     	; 0xd78a <__fixunssfsi+0x12>
    d798:	12 c0       	rjmp	.+36     	; 0xd7be <__fixunssfsi+0x46>
    d79a:	b1 30       	cpi	r27, 0x01	; 1
    d79c:	81 f0       	breq	.+32     	; 0xd7be <__fixunssfsi+0x46>
    d79e:	a0 d1       	rcall	.+832    	; 0xdae0 <__fp_zero>
    d7a0:	b1 e0       	ldi	r27, 0x01	; 1
    d7a2:	08 95       	ret
    d7a4:	9d c1       	rjmp	.+826    	; 0xdae0 <__fp_zero>
    d7a6:	67 2f       	mov	r22, r23
    d7a8:	78 2f       	mov	r23, r24
    d7aa:	88 27       	eor	r24, r24
    d7ac:	b8 5f       	subi	r27, 0xF8	; 248
    d7ae:	39 f0       	breq	.+14     	; 0xd7be <__fixunssfsi+0x46>
    d7b0:	b9 3f       	cpi	r27, 0xF9	; 249
    d7b2:	cc f3       	brlt	.-14     	; 0xd7a6 <__fixunssfsi+0x2e>
    d7b4:	86 95       	lsr	r24
    d7b6:	77 95       	ror	r23
    d7b8:	67 95       	ror	r22
    d7ba:	b3 95       	inc	r27
    d7bc:	d9 f7       	brne	.-10     	; 0xd7b4 <__fixunssfsi+0x3c>
    d7be:	3e f4       	brtc	.+14     	; 0xd7ce <__fixunssfsi+0x56>
    d7c0:	90 95       	com	r25
    d7c2:	80 95       	com	r24
    d7c4:	70 95       	com	r23
    d7c6:	61 95       	neg	r22
    d7c8:	7f 4f       	sbci	r23, 0xFF	; 255
    d7ca:	8f 4f       	sbci	r24, 0xFF	; 255
    d7cc:	9f 4f       	sbci	r25, 0xFF	; 255
    d7ce:	08 95       	ret

0000d7d0 <__floatunsisf>:
    d7d0:	e8 94       	clt
    d7d2:	09 c0       	rjmp	.+18     	; 0xd7e6 <__floatsisf+0x12>

0000d7d4 <__floatsisf>:
    d7d4:	97 fb       	bst	r25, 7
    d7d6:	3e f4       	brtc	.+14     	; 0xd7e6 <__floatsisf+0x12>
    d7d8:	90 95       	com	r25
    d7da:	80 95       	com	r24
    d7dc:	70 95       	com	r23
    d7de:	61 95       	neg	r22
    d7e0:	7f 4f       	sbci	r23, 0xFF	; 255
    d7e2:	8f 4f       	sbci	r24, 0xFF	; 255
    d7e4:	9f 4f       	sbci	r25, 0xFF	; 255
    d7e6:	99 23       	and	r25, r25
    d7e8:	a9 f0       	breq	.+42     	; 0xd814 <__floatsisf+0x40>
    d7ea:	f9 2f       	mov	r31, r25
    d7ec:	96 e9       	ldi	r25, 0x96	; 150
    d7ee:	bb 27       	eor	r27, r27
    d7f0:	93 95       	inc	r25
    d7f2:	f6 95       	lsr	r31
    d7f4:	87 95       	ror	r24
    d7f6:	77 95       	ror	r23
    d7f8:	67 95       	ror	r22
    d7fa:	b7 95       	ror	r27
    d7fc:	f1 11       	cpse	r31, r1
    d7fe:	f8 cf       	rjmp	.-16     	; 0xd7f0 <__floatsisf+0x1c>
    d800:	fa f4       	brpl	.+62     	; 0xd840 <__floatsisf+0x6c>
    d802:	bb 0f       	add	r27, r27
    d804:	11 f4       	brne	.+4      	; 0xd80a <__floatsisf+0x36>
    d806:	60 ff       	sbrs	r22, 0
    d808:	1b c0       	rjmp	.+54     	; 0xd840 <__floatsisf+0x6c>
    d80a:	6f 5f       	subi	r22, 0xFF	; 255
    d80c:	7f 4f       	sbci	r23, 0xFF	; 255
    d80e:	8f 4f       	sbci	r24, 0xFF	; 255
    d810:	9f 4f       	sbci	r25, 0xFF	; 255
    d812:	16 c0       	rjmp	.+44     	; 0xd840 <__floatsisf+0x6c>
    d814:	88 23       	and	r24, r24
    d816:	11 f0       	breq	.+4      	; 0xd81c <__floatsisf+0x48>
    d818:	96 e9       	ldi	r25, 0x96	; 150
    d81a:	11 c0       	rjmp	.+34     	; 0xd83e <__floatsisf+0x6a>
    d81c:	77 23       	and	r23, r23
    d81e:	21 f0       	breq	.+8      	; 0xd828 <__floatsisf+0x54>
    d820:	9e e8       	ldi	r25, 0x8E	; 142
    d822:	87 2f       	mov	r24, r23
    d824:	76 2f       	mov	r23, r22
    d826:	05 c0       	rjmp	.+10     	; 0xd832 <__floatsisf+0x5e>
    d828:	66 23       	and	r22, r22
    d82a:	71 f0       	breq	.+28     	; 0xd848 <__floatsisf+0x74>
    d82c:	96 e8       	ldi	r25, 0x86	; 134
    d82e:	86 2f       	mov	r24, r22
    d830:	70 e0       	ldi	r23, 0x00	; 0
    d832:	60 e0       	ldi	r22, 0x00	; 0
    d834:	2a f0       	brmi	.+10     	; 0xd840 <__floatsisf+0x6c>
    d836:	9a 95       	dec	r25
    d838:	66 0f       	add	r22, r22
    d83a:	77 1f       	adc	r23, r23
    d83c:	88 1f       	adc	r24, r24
    d83e:	da f7       	brpl	.-10     	; 0xd836 <__floatsisf+0x62>
    d840:	88 0f       	add	r24, r24
    d842:	96 95       	lsr	r25
    d844:	87 95       	ror	r24
    d846:	97 f9       	bld	r25, 7
    d848:	08 95       	ret

0000d84a <floor>:
    d84a:	33 d1       	rcall	.+614    	; 0xdab2 <__fp_trunc>
    d84c:	80 f0       	brcs	.+32     	; 0xd86e <floor+0x24>
    d84e:	9f 37       	cpi	r25, 0x7F	; 127
    d850:	40 f4       	brcc	.+16     	; 0xd862 <floor+0x18>
    d852:	91 11       	cpse	r25, r1
    d854:	0e f0       	brts	.+2      	; 0xd858 <floor+0xe>
    d856:	45 c1       	rjmp	.+650    	; 0xdae2 <__fp_szero>
    d858:	60 e0       	ldi	r22, 0x00	; 0
    d85a:	70 e0       	ldi	r23, 0x00	; 0
    d85c:	80 e8       	ldi	r24, 0x80	; 128
    d85e:	9f eb       	ldi	r25, 0xBF	; 191
    d860:	08 95       	ret
    d862:	26 f4       	brtc	.+8      	; 0xd86c <floor+0x22>
    d864:	1b 16       	cp	r1, r27
    d866:	61 1d       	adc	r22, r1
    d868:	71 1d       	adc	r23, r1
    d86a:	81 1d       	adc	r24, r1
    d86c:	46 c0       	rjmp	.+140    	; 0xd8fa <__fp_mintl>
    d86e:	60 c0       	rjmp	.+192    	; 0xd930 <__fp_mpack>

0000d870 <__fp_arccos>:
    d870:	df 93       	push	r29
    d872:	cf 93       	push	r28
    d874:	1f 93       	push	r17
    d876:	0f 93       	push	r16
    d878:	8b 01       	movw	r16, r22
    d87a:	ec 01       	movw	r28, r24
    d87c:	e5 e2       	ldi	r30, 0x25	; 37
    d87e:	f1 e0       	ldi	r31, 0x01	; 1
    d880:	68 d0       	rcall	.+208    	; 0xd952 <__fp_powser>
    d882:	d3 d0       	rcall	.+422    	; 0xda2a <__fp_round>
    d884:	98 01       	movw	r18, r16
    d886:	ae 01       	movw	r20, r28
    d888:	8b 01       	movw	r16, r22
    d88a:	ec 01       	movw	r28, r24
    d88c:	60 e0       	ldi	r22, 0x00	; 0
    d88e:	70 e0       	ldi	r23, 0x00	; 0
    d890:	80 e8       	ldi	r24, 0x80	; 128
    d892:	9f e3       	ldi	r25, 0x3F	; 63
    d894:	1f de       	rcall	.-962    	; 0xd4d4 <__subsf3>
    d896:	3a d2       	rcall	.+1140   	; 0xdd0c <sqrt>
    d898:	98 01       	movw	r18, r16
    d89a:	ae 01       	movw	r20, r28
    d89c:	0f 91       	pop	r16
    d89e:	1f 91       	pop	r17
    d8a0:	cf 91       	pop	r28
    d8a2:	df 91       	pop	r29
    d8a4:	86 c1       	rjmp	.+780    	; 0xdbb2 <__mulsf3x>

0000d8a6 <__fp_cmp>:
    d8a6:	99 0f       	add	r25, r25
    d8a8:	00 08       	sbc	r0, r0
    d8aa:	55 0f       	add	r21, r21
    d8ac:	aa 0b       	sbc	r26, r26
    d8ae:	e0 e8       	ldi	r30, 0x80	; 128
    d8b0:	fe ef       	ldi	r31, 0xFE	; 254
    d8b2:	16 16       	cp	r1, r22
    d8b4:	17 06       	cpc	r1, r23
    d8b6:	e8 07       	cpc	r30, r24
    d8b8:	f9 07       	cpc	r31, r25
    d8ba:	c0 f0       	brcs	.+48     	; 0xd8ec <__fp_cmp+0x46>
    d8bc:	12 16       	cp	r1, r18
    d8be:	13 06       	cpc	r1, r19
    d8c0:	e4 07       	cpc	r30, r20
    d8c2:	f5 07       	cpc	r31, r21
    d8c4:	98 f0       	brcs	.+38     	; 0xd8ec <__fp_cmp+0x46>
    d8c6:	62 1b       	sub	r22, r18
    d8c8:	73 0b       	sbc	r23, r19
    d8ca:	84 0b       	sbc	r24, r20
    d8cc:	95 0b       	sbc	r25, r21
    d8ce:	39 f4       	brne	.+14     	; 0xd8de <__fp_cmp+0x38>
    d8d0:	0a 26       	eor	r0, r26
    d8d2:	61 f0       	breq	.+24     	; 0xd8ec <__fp_cmp+0x46>
    d8d4:	23 2b       	or	r18, r19
    d8d6:	24 2b       	or	r18, r20
    d8d8:	25 2b       	or	r18, r21
    d8da:	21 f4       	brne	.+8      	; 0xd8e4 <__fp_cmp+0x3e>
    d8dc:	08 95       	ret
    d8de:	0a 26       	eor	r0, r26
    d8e0:	09 f4       	brne	.+2      	; 0xd8e4 <__fp_cmp+0x3e>
    d8e2:	a1 40       	sbci	r26, 0x01	; 1
    d8e4:	a6 95       	lsr	r26
    d8e6:	8f ef       	ldi	r24, 0xFF	; 255
    d8e8:	81 1d       	adc	r24, r1
    d8ea:	81 1d       	adc	r24, r1
    d8ec:	08 95       	ret

0000d8ee <__fp_inf>:
    d8ee:	97 f9       	bld	r25, 7
    d8f0:	9f 67       	ori	r25, 0x7F	; 127
    d8f2:	80 e8       	ldi	r24, 0x80	; 128
    d8f4:	70 e0       	ldi	r23, 0x00	; 0
    d8f6:	60 e0       	ldi	r22, 0x00	; 0
    d8f8:	08 95       	ret

0000d8fa <__fp_mintl>:
    d8fa:	88 23       	and	r24, r24
    d8fc:	71 f4       	brne	.+28     	; 0xd91a <__fp_mintl+0x20>
    d8fe:	77 23       	and	r23, r23
    d900:	21 f0       	breq	.+8      	; 0xd90a <__fp_mintl+0x10>
    d902:	98 50       	subi	r25, 0x08	; 8
    d904:	87 2b       	or	r24, r23
    d906:	76 2f       	mov	r23, r22
    d908:	07 c0       	rjmp	.+14     	; 0xd918 <__fp_mintl+0x1e>
    d90a:	66 23       	and	r22, r22
    d90c:	11 f4       	brne	.+4      	; 0xd912 <__fp_mintl+0x18>
    d90e:	99 27       	eor	r25, r25
    d910:	0d c0       	rjmp	.+26     	; 0xd92c <__fp_mintl+0x32>
    d912:	90 51       	subi	r25, 0x10	; 16
    d914:	86 2b       	or	r24, r22
    d916:	70 e0       	ldi	r23, 0x00	; 0
    d918:	60 e0       	ldi	r22, 0x00	; 0
    d91a:	2a f0       	brmi	.+10     	; 0xd926 <__fp_mintl+0x2c>
    d91c:	9a 95       	dec	r25
    d91e:	66 0f       	add	r22, r22
    d920:	77 1f       	adc	r23, r23
    d922:	88 1f       	adc	r24, r24
    d924:	da f7       	brpl	.-10     	; 0xd91c <__fp_mintl+0x22>
    d926:	88 0f       	add	r24, r24
    d928:	96 95       	lsr	r25
    d92a:	87 95       	ror	r24
    d92c:	97 f9       	bld	r25, 7
    d92e:	08 95       	ret

0000d930 <__fp_mpack>:
    d930:	9f 3f       	cpi	r25, 0xFF	; 255
    d932:	31 f0       	breq	.+12     	; 0xd940 <__fp_mpack_finite+0xc>

0000d934 <__fp_mpack_finite>:
    d934:	91 50       	subi	r25, 0x01	; 1
    d936:	20 f4       	brcc	.+8      	; 0xd940 <__fp_mpack_finite+0xc>
    d938:	87 95       	ror	r24
    d93a:	77 95       	ror	r23
    d93c:	67 95       	ror	r22
    d93e:	b7 95       	ror	r27
    d940:	88 0f       	add	r24, r24
    d942:	91 1d       	adc	r25, r1
    d944:	96 95       	lsr	r25
    d946:	87 95       	ror	r24
    d948:	97 f9       	bld	r25, 7
    d94a:	08 95       	ret

0000d94c <__fp_nan>:
    d94c:	9f ef       	ldi	r25, 0xFF	; 255
    d94e:	80 ec       	ldi	r24, 0xC0	; 192
    d950:	08 95       	ret

0000d952 <__fp_powser>:
    d952:	df 93       	push	r29
    d954:	cf 93       	push	r28
    d956:	1f 93       	push	r17
    d958:	0f 93       	push	r16
    d95a:	ff 92       	push	r15
    d95c:	ef 92       	push	r14
    d95e:	df 92       	push	r13
    d960:	7b 01       	movw	r14, r22
    d962:	8c 01       	movw	r16, r24
    d964:	68 94       	set
    d966:	05 c0       	rjmp	.+10     	; 0xd972 <__fp_powser+0x20>
    d968:	da 2e       	mov	r13, r26
    d96a:	ef 01       	movw	r28, r30
    d96c:	22 d1       	rcall	.+580    	; 0xdbb2 <__mulsf3x>
    d96e:	fe 01       	movw	r30, r28
    d970:	e8 94       	clt
    d972:	a5 91       	lpm	r26, Z+
    d974:	25 91       	lpm	r18, Z+
    d976:	35 91       	lpm	r19, Z+
    d978:	45 91       	lpm	r20, Z+
    d97a:	55 91       	lpm	r21, Z+
    d97c:	ae f3       	brts	.-22     	; 0xd968 <__fp_powser+0x16>
    d97e:	ef 01       	movw	r28, r30
    d980:	bb dd       	rcall	.-1162   	; 0xd4f8 <__addsf3x>
    d982:	fe 01       	movw	r30, r28
    d984:	97 01       	movw	r18, r14
    d986:	a8 01       	movw	r20, r16
    d988:	da 94       	dec	r13
    d98a:	79 f7       	brne	.-34     	; 0xd96a <__fp_powser+0x18>
    d98c:	df 90       	pop	r13
    d98e:	ef 90       	pop	r14
    d990:	ff 90       	pop	r15
    d992:	0f 91       	pop	r16
    d994:	1f 91       	pop	r17
    d996:	cf 91       	pop	r28
    d998:	df 91       	pop	r29
    d99a:	08 95       	ret

0000d99c <__fp_powsodd>:
    d99c:	9f 93       	push	r25
    d99e:	8f 93       	push	r24
    d9a0:	7f 93       	push	r23
    d9a2:	6f 93       	push	r22
    d9a4:	ff 93       	push	r31
    d9a6:	ef 93       	push	r30
    d9a8:	9b 01       	movw	r18, r22
    d9aa:	ac 01       	movw	r20, r24
    d9ac:	f6 d0       	rcall	.+492    	; 0xdb9a <__mulsf3>
    d9ae:	ef 91       	pop	r30
    d9b0:	ff 91       	pop	r31
    d9b2:	cf df       	rcall	.-98     	; 0xd952 <__fp_powser>
    d9b4:	2f 91       	pop	r18
    d9b6:	3f 91       	pop	r19
    d9b8:	4f 91       	pop	r20
    d9ba:	5f 91       	pop	r21
    d9bc:	ee c0       	rjmp	.+476    	; 0xdb9a <__mulsf3>

0000d9be <__fp_pscA>:
    d9be:	00 24       	eor	r0, r0
    d9c0:	0a 94       	dec	r0
    d9c2:	16 16       	cp	r1, r22
    d9c4:	17 06       	cpc	r1, r23
    d9c6:	18 06       	cpc	r1, r24
    d9c8:	09 06       	cpc	r0, r25
    d9ca:	08 95       	ret

0000d9cc <__fp_pscB>:
    d9cc:	00 24       	eor	r0, r0
    d9ce:	0a 94       	dec	r0
    d9d0:	12 16       	cp	r1, r18
    d9d2:	13 06       	cpc	r1, r19
    d9d4:	14 06       	cpc	r1, r20
    d9d6:	05 06       	cpc	r0, r21
    d9d8:	08 95       	ret
    d9da:	b8 cf       	rjmp	.-144    	; 0xd94c <__fp_nan>

0000d9dc <__fp_rempio2>:
    d9dc:	50 d0       	rcall	.+160    	; 0xda7e <__fp_splitA>
    d9de:	e8 f3       	brcs	.-6      	; 0xd9da <__fp_pscB+0xe>
    d9e0:	e8 94       	clt
    d9e2:	e0 e0       	ldi	r30, 0x00	; 0
    d9e4:	bb 27       	eor	r27, r27
    d9e6:	9f 57       	subi	r25, 0x7F	; 127
    d9e8:	f0 f0       	brcs	.+60     	; 0xda26 <__fp_rempio2+0x4a>
    d9ea:	2a ed       	ldi	r18, 0xDA	; 218
    d9ec:	3f e0       	ldi	r19, 0x0F	; 15
    d9ee:	49 ec       	ldi	r20, 0xC9	; 201
    d9f0:	06 c0       	rjmp	.+12     	; 0xd9fe <__fp_rempio2+0x22>
    d9f2:	ee 0f       	add	r30, r30
    d9f4:	bb 0f       	add	r27, r27
    d9f6:	66 1f       	adc	r22, r22
    d9f8:	77 1f       	adc	r23, r23
    d9fa:	88 1f       	adc	r24, r24
    d9fc:	28 f0       	brcs	.+10     	; 0xda08 <__fp_rempio2+0x2c>
    d9fe:	b2 3a       	cpi	r27, 0xA2	; 162
    da00:	62 07       	cpc	r22, r18
    da02:	73 07       	cpc	r23, r19
    da04:	84 07       	cpc	r24, r20
    da06:	28 f0       	brcs	.+10     	; 0xda12 <__fp_rempio2+0x36>
    da08:	b2 5a       	subi	r27, 0xA2	; 162
    da0a:	62 0b       	sbc	r22, r18
    da0c:	73 0b       	sbc	r23, r19
    da0e:	84 0b       	sbc	r24, r20
    da10:	e3 95       	inc	r30
    da12:	9a 95       	dec	r25
    da14:	72 f7       	brpl	.-36     	; 0xd9f2 <__fp_rempio2+0x16>
    da16:	80 38       	cpi	r24, 0x80	; 128
    da18:	30 f4       	brcc	.+12     	; 0xda26 <__fp_rempio2+0x4a>
    da1a:	9a 95       	dec	r25
    da1c:	bb 0f       	add	r27, r27
    da1e:	66 1f       	adc	r22, r22
    da20:	77 1f       	adc	r23, r23
    da22:	88 1f       	adc	r24, r24
    da24:	d2 f7       	brpl	.-12     	; 0xda1a <__fp_rempio2+0x3e>
    da26:	90 48       	sbci	r25, 0x80	; 128
    da28:	85 cf       	rjmp	.-246    	; 0xd934 <__fp_mpack_finite>

0000da2a <__fp_round>:
    da2a:	09 2e       	mov	r0, r25
    da2c:	03 94       	inc	r0
    da2e:	00 0c       	add	r0, r0
    da30:	11 f4       	brne	.+4      	; 0xda36 <__fp_round+0xc>
    da32:	88 23       	and	r24, r24
    da34:	52 f0       	brmi	.+20     	; 0xda4a <__fp_round+0x20>
    da36:	bb 0f       	add	r27, r27
    da38:	40 f4       	brcc	.+16     	; 0xda4a <__fp_round+0x20>
    da3a:	bf 2b       	or	r27, r31
    da3c:	11 f4       	brne	.+4      	; 0xda42 <__fp_round+0x18>
    da3e:	60 ff       	sbrs	r22, 0
    da40:	04 c0       	rjmp	.+8      	; 0xda4a <__fp_round+0x20>
    da42:	6f 5f       	subi	r22, 0xFF	; 255
    da44:	7f 4f       	sbci	r23, 0xFF	; 255
    da46:	8f 4f       	sbci	r24, 0xFF	; 255
    da48:	9f 4f       	sbci	r25, 0xFF	; 255
    da4a:	08 95       	ret

0000da4c <__fp_sinus>:
    da4c:	ef 93       	push	r30
    da4e:	e0 ff       	sbrs	r30, 0
    da50:	06 c0       	rjmp	.+12     	; 0xda5e <__fp_sinus+0x12>
    da52:	a2 ea       	ldi	r26, 0xA2	; 162
    da54:	2a ed       	ldi	r18, 0xDA	; 218
    da56:	3f e0       	ldi	r19, 0x0F	; 15
    da58:	49 ec       	ldi	r20, 0xC9	; 201
    da5a:	5f eb       	ldi	r21, 0xBF	; 191
    da5c:	4d dd       	rcall	.-1382   	; 0xd4f8 <__addsf3x>
    da5e:	e5 df       	rcall	.-54     	; 0xda2a <__fp_round>
    da60:	0f 90       	pop	r0
    da62:	03 94       	inc	r0
    da64:	01 fc       	sbrc	r0, 1
    da66:	90 58       	subi	r25, 0x80	; 128
    da68:	ed e4       	ldi	r30, 0x4D	; 77
    da6a:	f1 e0       	ldi	r31, 0x01	; 1
    da6c:	97 cf       	rjmp	.-210    	; 0xd99c <__fp_powsodd>

0000da6e <__fp_split3>:
    da6e:	57 fd       	sbrc	r21, 7
    da70:	90 58       	subi	r25, 0x80	; 128
    da72:	44 0f       	add	r20, r20
    da74:	55 1f       	adc	r21, r21
    da76:	59 f0       	breq	.+22     	; 0xda8e <__fp_splitA+0x10>
    da78:	5f 3f       	cpi	r21, 0xFF	; 255
    da7a:	71 f0       	breq	.+28     	; 0xda98 <__fp_splitA+0x1a>
    da7c:	47 95       	ror	r20

0000da7e <__fp_splitA>:
    da7e:	88 0f       	add	r24, r24
    da80:	97 fb       	bst	r25, 7
    da82:	99 1f       	adc	r25, r25
    da84:	61 f0       	breq	.+24     	; 0xda9e <__fp_splitA+0x20>
    da86:	9f 3f       	cpi	r25, 0xFF	; 255
    da88:	79 f0       	breq	.+30     	; 0xdaa8 <__fp_splitA+0x2a>
    da8a:	87 95       	ror	r24
    da8c:	08 95       	ret
    da8e:	12 16       	cp	r1, r18
    da90:	13 06       	cpc	r1, r19
    da92:	14 06       	cpc	r1, r20
    da94:	55 1f       	adc	r21, r21
    da96:	f2 cf       	rjmp	.-28     	; 0xda7c <__fp_split3+0xe>
    da98:	46 95       	lsr	r20
    da9a:	f1 df       	rcall	.-30     	; 0xda7e <__fp_splitA>
    da9c:	08 c0       	rjmp	.+16     	; 0xdaae <__fp_splitA+0x30>
    da9e:	16 16       	cp	r1, r22
    daa0:	17 06       	cpc	r1, r23
    daa2:	18 06       	cpc	r1, r24
    daa4:	99 1f       	adc	r25, r25
    daa6:	f1 cf       	rjmp	.-30     	; 0xda8a <__fp_splitA+0xc>
    daa8:	86 95       	lsr	r24
    daaa:	71 05       	cpc	r23, r1
    daac:	61 05       	cpc	r22, r1
    daae:	08 94       	sec
    dab0:	08 95       	ret

0000dab2 <__fp_trunc>:
    dab2:	e5 df       	rcall	.-54     	; 0xda7e <__fp_splitA>
    dab4:	a0 f0       	brcs	.+40     	; 0xdade <__fp_trunc+0x2c>
    dab6:	be e7       	ldi	r27, 0x7E	; 126
    dab8:	b9 17       	cp	r27, r25
    daba:	88 f4       	brcc	.+34     	; 0xdade <__fp_trunc+0x2c>
    dabc:	bb 27       	eor	r27, r27
    dabe:	9f 38       	cpi	r25, 0x8F	; 143
    dac0:	60 f4       	brcc	.+24     	; 0xdada <__fp_trunc+0x28>
    dac2:	16 16       	cp	r1, r22
    dac4:	b1 1d       	adc	r27, r1
    dac6:	67 2f       	mov	r22, r23
    dac8:	78 2f       	mov	r23, r24
    daca:	88 27       	eor	r24, r24
    dacc:	98 5f       	subi	r25, 0xF8	; 248
    dace:	f7 cf       	rjmp	.-18     	; 0xdabe <__fp_trunc+0xc>
    dad0:	86 95       	lsr	r24
    dad2:	77 95       	ror	r23
    dad4:	67 95       	ror	r22
    dad6:	b1 1d       	adc	r27, r1
    dad8:	93 95       	inc	r25
    dada:	96 39       	cpi	r25, 0x96	; 150
    dadc:	c8 f3       	brcs	.-14     	; 0xdad0 <__fp_trunc+0x1e>
    dade:	08 95       	ret

0000dae0 <__fp_zero>:
    dae0:	e8 94       	clt

0000dae2 <__fp_szero>:
    dae2:	bb 27       	eor	r27, r27
    dae4:	66 27       	eor	r22, r22
    dae6:	77 27       	eor	r23, r23
    dae8:	cb 01       	movw	r24, r22
    daea:	97 f9       	bld	r25, 7
    daec:	08 95       	ret

0000daee <__gesf2>:
    daee:	db de       	rcall	.-586    	; 0xd8a6 <__fp_cmp>
    daf0:	08 f4       	brcc	.+2      	; 0xdaf4 <__gesf2+0x6>
    daf2:	8f ef       	ldi	r24, 0xFF	; 255
    daf4:	08 95       	ret

0000daf6 <inverse>:
    daf6:	9b 01       	movw	r18, r22
    daf8:	ac 01       	movw	r20, r24
    dafa:	60 e0       	ldi	r22, 0x00	; 0
    dafc:	70 e0       	ldi	r23, 0x00	; 0
    dafe:	80 e8       	ldi	r24, 0x80	; 128
    db00:	9f e3       	ldi	r25, 0x3F	; 63
    db02:	cd cd       	rjmp	.-1126   	; 0xd69e <__divsf3>

0000db04 <log10>:
    db04:	0a d0       	rcall	.+20     	; 0xdb1a <log>
    db06:	29 ed       	ldi	r18, 0xD9	; 217
    db08:	3b e5       	ldi	r19, 0x5B	; 91
    db0a:	4e ed       	ldi	r20, 0xDE	; 222
    db0c:	5e e3       	ldi	r21, 0x3E	; 62
    db0e:	45 c0       	rjmp	.+138    	; 0xdb9a <__mulsf3>
    db10:	0e f0       	brts	.+2      	; 0xdb14 <log10+0x10>
    db12:	0e cf       	rjmp	.-484    	; 0xd930 <__fp_mpack>
    db14:	1b cf       	rjmp	.-458    	; 0xd94c <__fp_nan>
    db16:	68 94       	set
    db18:	ea ce       	rjmp	.-556    	; 0xd8ee <__fp_inf>

0000db1a <log>:
    db1a:	b1 df       	rcall	.-158    	; 0xda7e <__fp_splitA>
    db1c:	c8 f3       	brcs	.-14     	; 0xdb10 <log10+0xc>
    db1e:	99 23       	and	r25, r25
    db20:	d1 f3       	breq	.-12     	; 0xdb16 <log10+0x12>
    db22:	c6 f3       	brts	.-16     	; 0xdb14 <log10+0x10>
    db24:	df 93       	push	r29
    db26:	cf 93       	push	r28
    db28:	1f 93       	push	r17
    db2a:	0f 93       	push	r16
    db2c:	ff 92       	push	r15
    db2e:	c9 2f       	mov	r28, r25
    db30:	dd 27       	eor	r29, r29
    db32:	88 23       	and	r24, r24
    db34:	2a f0       	brmi	.+10     	; 0xdb40 <log+0x26>
    db36:	21 97       	sbiw	r28, 0x01	; 1
    db38:	66 0f       	add	r22, r22
    db3a:	77 1f       	adc	r23, r23
    db3c:	88 1f       	adc	r24, r24
    db3e:	da f7       	brpl	.-10     	; 0xdb36 <log+0x1c>
    db40:	20 e0       	ldi	r18, 0x00	; 0
    db42:	30 e0       	ldi	r19, 0x00	; 0
    db44:	40 e8       	ldi	r20, 0x80	; 128
    db46:	5f eb       	ldi	r21, 0xBF	; 191
    db48:	9f e3       	ldi	r25, 0x3F	; 63
    db4a:	88 39       	cpi	r24, 0x98	; 152
    db4c:	20 f0       	brcs	.+8      	; 0xdb56 <log+0x3c>
    db4e:	80 3e       	cpi	r24, 0xE0	; 224
    db50:	30 f0       	brcs	.+12     	; 0xdb5e <log+0x44>
    db52:	21 96       	adiw	r28, 0x01	; 1
    db54:	8f 77       	andi	r24, 0x7F	; 127
    db56:	bf dc       	rcall	.-1666   	; 0xd4d6 <__addsf3>
    db58:	eb e6       	ldi	r30, 0x6B	; 107
    db5a:	f1 e0       	ldi	r31, 0x01	; 1
    db5c:	03 c0       	rjmp	.+6      	; 0xdb64 <log+0x4a>
    db5e:	bb dc       	rcall	.-1674   	; 0xd4d6 <__addsf3>
    db60:	e8 e9       	ldi	r30, 0x98	; 152
    db62:	f1 e0       	ldi	r31, 0x01	; 1
    db64:	f6 de       	rcall	.-532    	; 0xd952 <__fp_powser>
    db66:	8b 01       	movw	r16, r22
    db68:	be 01       	movw	r22, r28
    db6a:	ec 01       	movw	r28, r24
    db6c:	fb 2e       	mov	r15, r27
    db6e:	6f 57       	subi	r22, 0x7F	; 127
    db70:	71 09       	sbc	r23, r1
    db72:	75 95       	asr	r23
    db74:	77 1f       	adc	r23, r23
    db76:	88 0b       	sbc	r24, r24
    db78:	99 0b       	sbc	r25, r25
    db7a:	2c de       	rcall	.-936    	; 0xd7d4 <__floatsisf>
    db7c:	28 e1       	ldi	r18, 0x18	; 24
    db7e:	32 e7       	ldi	r19, 0x72	; 114
    db80:	41 e3       	ldi	r20, 0x31	; 49
    db82:	5f e3       	ldi	r21, 0x3F	; 63
    db84:	16 d0       	rcall	.+44     	; 0xdbb2 <__mulsf3x>
    db86:	af 2d       	mov	r26, r15
    db88:	98 01       	movw	r18, r16
    db8a:	ae 01       	movw	r20, r28
    db8c:	ff 90       	pop	r15
    db8e:	0f 91       	pop	r16
    db90:	1f 91       	pop	r17
    db92:	cf 91       	pop	r28
    db94:	df 91       	pop	r29
    db96:	b0 dc       	rcall	.-1696   	; 0xd4f8 <__addsf3x>
    db98:	48 cf       	rjmp	.-368    	; 0xda2a <__fp_round>

0000db9a <__mulsf3>:
    db9a:	0b d0       	rcall	.+22     	; 0xdbb2 <__mulsf3x>
    db9c:	46 cf       	rjmp	.-372    	; 0xda2a <__fp_round>
    db9e:	0f df       	rcall	.-482    	; 0xd9be <__fp_pscA>
    dba0:	28 f0       	brcs	.+10     	; 0xdbac <__mulsf3+0x12>
    dba2:	14 df       	rcall	.-472    	; 0xd9cc <__fp_pscB>
    dba4:	18 f0       	brcs	.+6      	; 0xdbac <__mulsf3+0x12>
    dba6:	95 23       	and	r25, r21
    dba8:	09 f0       	breq	.+2      	; 0xdbac <__mulsf3+0x12>
    dbaa:	a1 ce       	rjmp	.-702    	; 0xd8ee <__fp_inf>
    dbac:	cf ce       	rjmp	.-610    	; 0xd94c <__fp_nan>
    dbae:	11 24       	eor	r1, r1
    dbb0:	98 cf       	rjmp	.-208    	; 0xdae2 <__fp_szero>

0000dbb2 <__mulsf3x>:
    dbb2:	5d df       	rcall	.-326    	; 0xda6e <__fp_split3>
    dbb4:	a0 f3       	brcs	.-24     	; 0xdb9e <__mulsf3+0x4>

0000dbb6 <__mulsf3_pse>:
    dbb6:	95 9f       	mul	r25, r21
    dbb8:	d1 f3       	breq	.-12     	; 0xdbae <__mulsf3+0x14>
    dbba:	95 0f       	add	r25, r21
    dbbc:	50 e0       	ldi	r21, 0x00	; 0
    dbbe:	55 1f       	adc	r21, r21
    dbc0:	62 9f       	mul	r22, r18
    dbc2:	f0 01       	movw	r30, r0
    dbc4:	72 9f       	mul	r23, r18
    dbc6:	bb 27       	eor	r27, r27
    dbc8:	f0 0d       	add	r31, r0
    dbca:	b1 1d       	adc	r27, r1
    dbcc:	63 9f       	mul	r22, r19
    dbce:	aa 27       	eor	r26, r26
    dbd0:	f0 0d       	add	r31, r0
    dbd2:	b1 1d       	adc	r27, r1
    dbd4:	aa 1f       	adc	r26, r26
    dbd6:	64 9f       	mul	r22, r20
    dbd8:	66 27       	eor	r22, r22
    dbda:	b0 0d       	add	r27, r0
    dbdc:	a1 1d       	adc	r26, r1
    dbde:	66 1f       	adc	r22, r22
    dbe0:	82 9f       	mul	r24, r18
    dbe2:	22 27       	eor	r18, r18
    dbe4:	b0 0d       	add	r27, r0
    dbe6:	a1 1d       	adc	r26, r1
    dbe8:	62 1f       	adc	r22, r18
    dbea:	73 9f       	mul	r23, r19
    dbec:	b0 0d       	add	r27, r0
    dbee:	a1 1d       	adc	r26, r1
    dbf0:	62 1f       	adc	r22, r18
    dbf2:	83 9f       	mul	r24, r19
    dbf4:	a0 0d       	add	r26, r0
    dbf6:	61 1d       	adc	r22, r1
    dbf8:	22 1f       	adc	r18, r18
    dbfa:	74 9f       	mul	r23, r20
    dbfc:	33 27       	eor	r19, r19
    dbfe:	a0 0d       	add	r26, r0
    dc00:	61 1d       	adc	r22, r1
    dc02:	23 1f       	adc	r18, r19
    dc04:	84 9f       	mul	r24, r20
    dc06:	60 0d       	add	r22, r0
    dc08:	21 1d       	adc	r18, r1
    dc0a:	82 2f       	mov	r24, r18
    dc0c:	76 2f       	mov	r23, r22
    dc0e:	6a 2f       	mov	r22, r26
    dc10:	11 24       	eor	r1, r1
    dc12:	9f 57       	subi	r25, 0x7F	; 127
    dc14:	50 40       	sbci	r21, 0x00	; 0
    dc16:	8a f0       	brmi	.+34     	; 0xdc3a <__mulsf3_pse+0x84>
    dc18:	e1 f0       	breq	.+56     	; 0xdc52 <__mulsf3_pse+0x9c>
    dc1a:	88 23       	and	r24, r24
    dc1c:	4a f0       	brmi	.+18     	; 0xdc30 <__mulsf3_pse+0x7a>
    dc1e:	ee 0f       	add	r30, r30
    dc20:	ff 1f       	adc	r31, r31
    dc22:	bb 1f       	adc	r27, r27
    dc24:	66 1f       	adc	r22, r22
    dc26:	77 1f       	adc	r23, r23
    dc28:	88 1f       	adc	r24, r24
    dc2a:	91 50       	subi	r25, 0x01	; 1
    dc2c:	50 40       	sbci	r21, 0x00	; 0
    dc2e:	a9 f7       	brne	.-22     	; 0xdc1a <__mulsf3_pse+0x64>
    dc30:	9e 3f       	cpi	r25, 0xFE	; 254
    dc32:	51 05       	cpc	r21, r1
    dc34:	70 f0       	brcs	.+28     	; 0xdc52 <__mulsf3_pse+0x9c>
    dc36:	5b ce       	rjmp	.-842    	; 0xd8ee <__fp_inf>
    dc38:	54 cf       	rjmp	.-344    	; 0xdae2 <__fp_szero>
    dc3a:	5f 3f       	cpi	r21, 0xFF	; 255
    dc3c:	ec f3       	brlt	.-6      	; 0xdc38 <__mulsf3_pse+0x82>
    dc3e:	98 3e       	cpi	r25, 0xE8	; 232
    dc40:	dc f3       	brlt	.-10     	; 0xdc38 <__mulsf3_pse+0x82>
    dc42:	86 95       	lsr	r24
    dc44:	77 95       	ror	r23
    dc46:	67 95       	ror	r22
    dc48:	b7 95       	ror	r27
    dc4a:	f7 95       	ror	r31
    dc4c:	e7 95       	ror	r30
    dc4e:	9f 5f       	subi	r25, 0xFF	; 255
    dc50:	c1 f7       	brne	.-16     	; 0xdc42 <__mulsf3_pse+0x8c>
    dc52:	fe 2b       	or	r31, r30
    dc54:	88 0f       	add	r24, r24
    dc56:	91 1d       	adc	r25, r1
    dc58:	96 95       	lsr	r25
    dc5a:	87 95       	ror	r24
    dc5c:	97 f9       	bld	r25, 7
    dc5e:	08 95       	ret

0000dc60 <pow>:
    dc60:	fa 01       	movw	r30, r20
    dc62:	ee 0f       	add	r30, r30
    dc64:	ff 1f       	adc	r31, r31
    dc66:	30 96       	adiw	r30, 0x00	; 0
    dc68:	21 05       	cpc	r18, r1
    dc6a:	31 05       	cpc	r19, r1
    dc6c:	99 f1       	breq	.+102    	; 0xdcd4 <pow+0x74>
    dc6e:	61 15       	cp	r22, r1
    dc70:	71 05       	cpc	r23, r1
    dc72:	61 f4       	brne	.+24     	; 0xdc8c <pow+0x2c>
    dc74:	80 38       	cpi	r24, 0x80	; 128
    dc76:	bf e3       	ldi	r27, 0x3F	; 63
    dc78:	9b 07       	cpc	r25, r27
    dc7a:	49 f1       	breq	.+82     	; 0xdcce <pow+0x6e>
    dc7c:	68 94       	set
    dc7e:	90 38       	cpi	r25, 0x80	; 128
    dc80:	81 05       	cpc	r24, r1
    dc82:	61 f0       	breq	.+24     	; 0xdc9c <pow+0x3c>
    dc84:	80 38       	cpi	r24, 0x80	; 128
    dc86:	bf ef       	ldi	r27, 0xFF	; 255
    dc88:	9b 07       	cpc	r25, r27
    dc8a:	41 f0       	breq	.+16     	; 0xdc9c <pow+0x3c>
    dc8c:	99 23       	and	r25, r25
    dc8e:	42 f5       	brpl	.+80     	; 0xdce0 <pow+0x80>
    dc90:	ff 3f       	cpi	r31, 0xFF	; 255
    dc92:	e1 05       	cpc	r30, r1
    dc94:	31 05       	cpc	r19, r1
    dc96:	21 05       	cpc	r18, r1
    dc98:	11 f1       	breq	.+68     	; 0xdcde <pow+0x7e>
    dc9a:	e8 94       	clt
    dc9c:	08 94       	sec
    dc9e:	e7 95       	ror	r30
    dca0:	d9 01       	movw	r26, r18
    dca2:	aa 23       	and	r26, r26
    dca4:	29 f4       	brne	.+10     	; 0xdcb0 <pow+0x50>
    dca6:	ab 2f       	mov	r26, r27
    dca8:	be 2f       	mov	r27, r30
    dcaa:	f8 5f       	subi	r31, 0xF8	; 248
    dcac:	d0 f3       	brcs	.-12     	; 0xdca2 <pow+0x42>
    dcae:	10 c0       	rjmp	.+32     	; 0xdcd0 <pow+0x70>
    dcb0:	ff 5f       	subi	r31, 0xFF	; 255
    dcb2:	70 f4       	brcc	.+28     	; 0xdcd0 <pow+0x70>
    dcb4:	a6 95       	lsr	r26
    dcb6:	e0 f7       	brcc	.-8      	; 0xdcb0 <pow+0x50>
    dcb8:	f7 39       	cpi	r31, 0x97	; 151
    dcba:	50 f0       	brcs	.+20     	; 0xdcd0 <pow+0x70>
    dcbc:	19 f0       	breq	.+6      	; 0xdcc4 <pow+0x64>
    dcbe:	ff 3a       	cpi	r31, 0xAF	; 175
    dcc0:	38 f4       	brcc	.+14     	; 0xdcd0 <pow+0x70>
    dcc2:	9f 77       	andi	r25, 0x7F	; 127
    dcc4:	9f 93       	push	r25
    dcc6:	0c d0       	rcall	.+24     	; 0xdce0 <pow+0x80>
    dcc8:	0f 90       	pop	r0
    dcca:	07 fc       	sbrc	r0, 7
    dccc:	90 58       	subi	r25, 0x80	; 128
    dcce:	08 95       	ret
    dcd0:	3e f0       	brts	.+14     	; 0xdce0 <pow+0x80>
    dcd2:	3c ce       	rjmp	.-904    	; 0xd94c <__fp_nan>
    dcd4:	60 e0       	ldi	r22, 0x00	; 0
    dcd6:	70 e0       	ldi	r23, 0x00	; 0
    dcd8:	80 e8       	ldi	r24, 0x80	; 128
    dcda:	9f e3       	ldi	r25, 0x3F	; 63
    dcdc:	08 95       	ret
    dcde:	4f e7       	ldi	r20, 0x7F	; 127
    dce0:	9f 77       	andi	r25, 0x7F	; 127
    dce2:	5f 93       	push	r21
    dce4:	4f 93       	push	r20
    dce6:	3f 93       	push	r19
    dce8:	2f 93       	push	r18
    dcea:	17 df       	rcall	.-466    	; 0xdb1a <log>
    dcec:	2f 91       	pop	r18
    dcee:	3f 91       	pop	r19
    dcf0:	4f 91       	pop	r20
    dcf2:	5f 91       	pop	r21
    dcf4:	52 df       	rcall	.-348    	; 0xdb9a <__mulsf3>
    dcf6:	54 c0       	rjmp	.+168    	; 0xdda0 <exp>

0000dcf8 <sin>:
    dcf8:	9f 93       	push	r25
    dcfa:	70 de       	rcall	.-800    	; 0xd9dc <__fp_rempio2>
    dcfc:	0f 90       	pop	r0
    dcfe:	07 fc       	sbrc	r0, 7
    dd00:	ee 5f       	subi	r30, 0xFE	; 254
    dd02:	a4 ce       	rjmp	.-696    	; 0xda4c <__fp_sinus>
    dd04:	11 f4       	brne	.+4      	; 0xdd0a <sin+0x12>
    dd06:	0e f4       	brtc	.+2      	; 0xdd0a <sin+0x12>
    dd08:	21 ce       	rjmp	.-958    	; 0xd94c <__fp_nan>
    dd0a:	12 ce       	rjmp	.-988    	; 0xd930 <__fp_mpack>

0000dd0c <sqrt>:
    dd0c:	b8 de       	rcall	.-656    	; 0xda7e <__fp_splitA>
    dd0e:	d0 f3       	brcs	.-12     	; 0xdd04 <sin+0xc>
    dd10:	99 23       	and	r25, r25
    dd12:	d9 f3       	breq	.-10     	; 0xdd0a <sin+0x12>
    dd14:	ce f3       	brts	.-14     	; 0xdd08 <sin+0x10>
    dd16:	9f 57       	subi	r25, 0x7F	; 127
    dd18:	55 0b       	sbc	r21, r21
    dd1a:	87 ff       	sbrs	r24, 7
    dd1c:	6d d0       	rcall	.+218    	; 0xddf8 <__fp_norm2>
    dd1e:	00 24       	eor	r0, r0
    dd20:	a0 e6       	ldi	r26, 0x60	; 96
    dd22:	40 ea       	ldi	r20, 0xA0	; 160
    dd24:	90 01       	movw	r18, r0
    dd26:	80 58       	subi	r24, 0x80	; 128
    dd28:	56 95       	lsr	r21
    dd2a:	97 95       	ror	r25
    dd2c:	28 f4       	brcc	.+10     	; 0xdd38 <sqrt+0x2c>
    dd2e:	80 5c       	subi	r24, 0xC0	; 192
    dd30:	66 0f       	add	r22, r22
    dd32:	77 1f       	adc	r23, r23
    dd34:	88 1f       	adc	r24, r24
    dd36:	20 f0       	brcs	.+8      	; 0xdd40 <sqrt+0x34>
    dd38:	26 17       	cp	r18, r22
    dd3a:	37 07       	cpc	r19, r23
    dd3c:	48 07       	cpc	r20, r24
    dd3e:	30 f4       	brcc	.+12     	; 0xdd4c <sqrt+0x40>
    dd40:	62 1b       	sub	r22, r18
    dd42:	73 0b       	sbc	r23, r19
    dd44:	84 0b       	sbc	r24, r20
    dd46:	20 29       	or	r18, r0
    dd48:	31 29       	or	r19, r1
    dd4a:	4a 2b       	or	r20, r26
    dd4c:	a6 95       	lsr	r26
    dd4e:	17 94       	ror	r1
    dd50:	07 94       	ror	r0
    dd52:	20 25       	eor	r18, r0
    dd54:	31 25       	eor	r19, r1
    dd56:	4a 27       	eor	r20, r26
    dd58:	58 f7       	brcc	.-42     	; 0xdd30 <sqrt+0x24>
    dd5a:	66 0f       	add	r22, r22
    dd5c:	77 1f       	adc	r23, r23
    dd5e:	88 1f       	adc	r24, r24
    dd60:	20 f0       	brcs	.+8      	; 0xdd6a <sqrt+0x5e>
    dd62:	26 17       	cp	r18, r22
    dd64:	37 07       	cpc	r19, r23
    dd66:	48 07       	cpc	r20, r24
    dd68:	30 f4       	brcc	.+12     	; 0xdd76 <sqrt+0x6a>
    dd6a:	62 0b       	sbc	r22, r18
    dd6c:	73 0b       	sbc	r23, r19
    dd6e:	84 0b       	sbc	r24, r20
    dd70:	20 0d       	add	r18, r0
    dd72:	31 1d       	adc	r19, r1
    dd74:	41 1d       	adc	r20, r1
    dd76:	a0 95       	com	r26
    dd78:	81 f7       	brne	.-32     	; 0xdd5a <sqrt+0x4e>
    dd7a:	b9 01       	movw	r22, r18
    dd7c:	84 2f       	mov	r24, r20
    dd7e:	91 58       	subi	r25, 0x81	; 129
    dd80:	88 0f       	add	r24, r24
    dd82:	96 95       	lsr	r25
    dd84:	87 95       	ror	r24
    dd86:	08 95       	ret

0000dd88 <square>:
    dd88:	9b 01       	movw	r18, r22
    dd8a:	ac 01       	movw	r20, r24
    dd8c:	06 cf       	rjmp	.-500    	; 0xdb9a <__mulsf3>

0000dd8e <__unordsf2>:
    dd8e:	8b dd       	rcall	.-1258   	; 0xd8a6 <__fp_cmp>
    dd90:	88 0b       	sbc	r24, r24
    dd92:	99 0b       	sbc	r25, r25
    dd94:	08 95       	ret
    dd96:	19 f4       	brne	.+6      	; 0xdd9e <__unordsf2+0x10>
    dd98:	0e f0       	brts	.+2      	; 0xdd9c <__unordsf2+0xe>
    dd9a:	a9 cd       	rjmp	.-1198   	; 0xd8ee <__fp_inf>
    dd9c:	a1 ce       	rjmp	.-702    	; 0xdae0 <__fp_zero>
    dd9e:	d6 cd       	rjmp	.-1108   	; 0xd94c <__fp_nan>

0000dda0 <exp>:
    dda0:	6e de       	rcall	.-804    	; 0xda7e <__fp_splitA>
    dda2:	c8 f3       	brcs	.-14     	; 0xdd96 <__unordsf2+0x8>
    dda4:	96 38       	cpi	r25, 0x86	; 134
    dda6:	c0 f7       	brcc	.-16     	; 0xdd98 <__unordsf2+0xa>
    dda8:	07 f8       	bld	r0, 7
    ddaa:	0f 92       	push	r0
    ddac:	e8 94       	clt
    ddae:	2b e3       	ldi	r18, 0x3B	; 59
    ddb0:	3a ea       	ldi	r19, 0xAA	; 170
    ddb2:	48 eb       	ldi	r20, 0xB8	; 184
    ddb4:	5f e7       	ldi	r21, 0x7F	; 127
    ddb6:	ff de       	rcall	.-514    	; 0xdbb6 <__mulsf3_pse>
    ddb8:	0f 92       	push	r0
    ddba:	0f 92       	push	r0
    ddbc:	0f 92       	push	r0
    ddbe:	4d b7       	in	r20, 0x3d	; 61
    ddc0:	5e b7       	in	r21, 0x3e	; 62
    ddc2:	0f 92       	push	r0
    ddc4:	56 d0       	rcall	.+172    	; 0xde72 <modf>
    ddc6:	e5 ec       	ldi	r30, 0xC5	; 197
    ddc8:	f1 e0       	ldi	r31, 0x01	; 1
    ddca:	c3 dd       	rcall	.-1146   	; 0xd952 <__fp_powser>
    ddcc:	4f 91       	pop	r20
    ddce:	5f 91       	pop	r21
    ddd0:	ef 91       	pop	r30
    ddd2:	ff 91       	pop	r31
    ddd4:	e5 95       	asr	r30
    ddd6:	ee 1f       	adc	r30, r30
    ddd8:	ff 1f       	adc	r31, r31
    ddda:	49 f0       	breq	.+18     	; 0xddee <exp+0x4e>
    dddc:	fe 57       	subi	r31, 0x7E	; 126
    ddde:	e0 68       	ori	r30, 0x80	; 128
    dde0:	44 27       	eor	r20, r20
    dde2:	ee 0f       	add	r30, r30
    dde4:	44 1f       	adc	r20, r20
    dde6:	fa 95       	dec	r31
    dde8:	e1 f7       	brne	.-8      	; 0xdde2 <exp+0x42>
    ddea:	41 95       	neg	r20
    ddec:	55 0b       	sbc	r21, r21
    ddee:	0d d0       	rcall	.+26     	; 0xde0a <ldexp>
    ddf0:	0f 90       	pop	r0
    ddf2:	07 fe       	sbrs	r0, 7
    ddf4:	80 ce       	rjmp	.-768    	; 0xdaf6 <inverse>
    ddf6:	08 95       	ret

0000ddf8 <__fp_norm2>:
    ddf8:	91 50       	subi	r25, 0x01	; 1
    ddfa:	50 40       	sbci	r21, 0x00	; 0
    ddfc:	66 0f       	add	r22, r22
    ddfe:	77 1f       	adc	r23, r23
    de00:	88 1f       	adc	r24, r24
    de02:	d2 f7       	brpl	.-12     	; 0xddf8 <__fp_norm2>
    de04:	08 95       	ret
    de06:	73 cd       	rjmp	.-1306   	; 0xd8ee <__fp_inf>
    de08:	93 cd       	rjmp	.-1242   	; 0xd930 <__fp_mpack>

0000de0a <ldexp>:
    de0a:	39 de       	rcall	.-910    	; 0xda7e <__fp_splitA>
    de0c:	e8 f3       	brcs	.-6      	; 0xde08 <__fp_norm2+0x10>
    de0e:	99 23       	and	r25, r25
    de10:	d9 f3       	breq	.-10     	; 0xde08 <__fp_norm2+0x10>
    de12:	94 0f       	add	r25, r20
    de14:	51 1d       	adc	r21, r1
    de16:	bb f3       	brvs	.-18     	; 0xde06 <__fp_norm2+0xe>
    de18:	91 50       	subi	r25, 0x01	; 1
    de1a:	50 40       	sbci	r21, 0x00	; 0
    de1c:	94 f0       	brlt	.+36     	; 0xde42 <ldexp+0x38>
    de1e:	59 f0       	breq	.+22     	; 0xde36 <ldexp+0x2c>
    de20:	88 23       	and	r24, r24
    de22:	32 f0       	brmi	.+12     	; 0xde30 <ldexp+0x26>
    de24:	66 0f       	add	r22, r22
    de26:	77 1f       	adc	r23, r23
    de28:	88 1f       	adc	r24, r24
    de2a:	91 50       	subi	r25, 0x01	; 1
    de2c:	50 40       	sbci	r21, 0x00	; 0
    de2e:	c1 f7       	brne	.-16     	; 0xde20 <ldexp+0x16>
    de30:	9e 3f       	cpi	r25, 0xFE	; 254
    de32:	51 05       	cpc	r21, r1
    de34:	44 f7       	brge	.-48     	; 0xde06 <__fp_norm2+0xe>
    de36:	88 0f       	add	r24, r24
    de38:	91 1d       	adc	r25, r1
    de3a:	96 95       	lsr	r25
    de3c:	87 95       	ror	r24
    de3e:	97 f9       	bld	r25, 7
    de40:	08 95       	ret
    de42:	5f 3f       	cpi	r21, 0xFF	; 255
    de44:	ac f0       	brlt	.+42     	; 0xde70 <ldexp+0x66>
    de46:	98 3e       	cpi	r25, 0xE8	; 232
    de48:	9c f0       	brlt	.+38     	; 0xde70 <ldexp+0x66>
    de4a:	bb 27       	eor	r27, r27
    de4c:	86 95       	lsr	r24
    de4e:	77 95       	ror	r23
    de50:	67 95       	ror	r22
    de52:	b7 95       	ror	r27
    de54:	08 f4       	brcc	.+2      	; 0xde58 <ldexp+0x4e>
    de56:	b1 60       	ori	r27, 0x01	; 1
    de58:	93 95       	inc	r25
    de5a:	c1 f7       	brne	.-16     	; 0xde4c <ldexp+0x42>
    de5c:	bb 0f       	add	r27, r27
    de5e:	58 f7       	brcc	.-42     	; 0xde36 <ldexp+0x2c>
    de60:	11 f4       	brne	.+4      	; 0xde66 <ldexp+0x5c>
    de62:	60 ff       	sbrs	r22, 0
    de64:	e8 cf       	rjmp	.-48     	; 0xde36 <ldexp+0x2c>
    de66:	6f 5f       	subi	r22, 0xFF	; 255
    de68:	7f 4f       	sbci	r23, 0xFF	; 255
    de6a:	8f 4f       	sbci	r24, 0xFF	; 255
    de6c:	9f 4f       	sbci	r25, 0xFF	; 255
    de6e:	e3 cf       	rjmp	.-58     	; 0xde36 <ldexp+0x2c>
    de70:	38 ce       	rjmp	.-912    	; 0xdae2 <__fp_szero>

0000de72 <modf>:
    de72:	fa 01       	movw	r30, r20
    de74:	dc 01       	movw	r26, r24
    de76:	aa 0f       	add	r26, r26
    de78:	bb 1f       	adc	r27, r27
    de7a:	9b 01       	movw	r18, r22
    de7c:	ac 01       	movw	r20, r24
    de7e:	bf 57       	subi	r27, 0x7F	; 127
    de80:	28 f4       	brcc	.+10     	; 0xde8c <modf+0x1a>
    de82:	22 27       	eor	r18, r18
    de84:	33 27       	eor	r19, r19
    de86:	44 27       	eor	r20, r20
    de88:	50 78       	andi	r21, 0x80	; 128
    de8a:	1f c0       	rjmp	.+62     	; 0xdeca <modf+0x58>
    de8c:	b7 51       	subi	r27, 0x17	; 23
    de8e:	88 f4       	brcc	.+34     	; 0xdeb2 <modf+0x40>
    de90:	ab 2f       	mov	r26, r27
    de92:	00 24       	eor	r0, r0
    de94:	46 95       	lsr	r20
    de96:	37 95       	ror	r19
    de98:	27 95       	ror	r18
    de9a:	01 1c       	adc	r0, r1
    de9c:	a3 95       	inc	r26
    de9e:	d2 f3       	brmi	.-12     	; 0xde94 <modf+0x22>
    dea0:	00 20       	and	r0, r0
    dea2:	69 f0       	breq	.+26     	; 0xdebe <modf+0x4c>
    dea4:	22 0f       	add	r18, r18
    dea6:	33 1f       	adc	r19, r19
    dea8:	44 1f       	adc	r20, r20
    deaa:	b3 95       	inc	r27
    deac:	da f3       	brmi	.-10     	; 0xdea4 <modf+0x32>
    deae:	0d d0       	rcall	.+26     	; 0xdeca <modf+0x58>
    deb0:	11 cb       	rjmp	.-2526   	; 0xd4d4 <__subsf3>
    deb2:	61 30       	cpi	r22, 0x01	; 1
    deb4:	71 05       	cpc	r23, r1
    deb6:	a0 e8       	ldi	r26, 0x80	; 128
    deb8:	8a 07       	cpc	r24, r26
    deba:	b9 46       	sbci	r27, 0x69	; 105
    debc:	30 f4       	brcc	.+12     	; 0xdeca <modf+0x58>
    debe:	9b 01       	movw	r18, r22
    dec0:	ac 01       	movw	r20, r24
    dec2:	66 27       	eor	r22, r22
    dec4:	77 27       	eor	r23, r23
    dec6:	88 27       	eor	r24, r24
    dec8:	90 78       	andi	r25, 0x80	; 128
    deca:	30 96       	adiw	r30, 0x00	; 0
    decc:	21 f0       	breq	.+8      	; 0xded6 <modf+0x64>
    dece:	20 83       	st	Z, r18
    ded0:	31 83       	std	Z+1, r19	; 0x01
    ded2:	42 83       	std	Z+2, r20	; 0x02
    ded4:	53 83       	std	Z+3, r21	; 0x03
    ded6:	08 95       	ret

0000ded8 <__udivmodsi4>:
    ded8:	a1 e2       	ldi	r26, 0x21	; 33
    deda:	1a 2e       	mov	r1, r26
    dedc:	aa 1b       	sub	r26, r26
    dede:	bb 1b       	sub	r27, r27
    dee0:	fd 01       	movw	r30, r26
    dee2:	0d c0       	rjmp	.+26     	; 0xdefe <__udivmodsi4_ep>

0000dee4 <__udivmodsi4_loop>:
    dee4:	aa 1f       	adc	r26, r26
    dee6:	bb 1f       	adc	r27, r27
    dee8:	ee 1f       	adc	r30, r30
    deea:	ff 1f       	adc	r31, r31
    deec:	a2 17       	cp	r26, r18
    deee:	b3 07       	cpc	r27, r19
    def0:	e4 07       	cpc	r30, r20
    def2:	f5 07       	cpc	r31, r21
    def4:	20 f0       	brcs	.+8      	; 0xdefe <__udivmodsi4_ep>
    def6:	a2 1b       	sub	r26, r18
    def8:	b3 0b       	sbc	r27, r19
    defa:	e4 0b       	sbc	r30, r20
    defc:	f5 0b       	sbc	r31, r21

0000defe <__udivmodsi4_ep>:
    defe:	66 1f       	adc	r22, r22
    df00:	77 1f       	adc	r23, r23
    df02:	88 1f       	adc	r24, r24
    df04:	99 1f       	adc	r25, r25
    df06:	1a 94       	dec	r1
    df08:	69 f7       	brne	.-38     	; 0xdee4 <__udivmodsi4_loop>
    df0a:	60 95       	com	r22
    df0c:	70 95       	com	r23
    df0e:	80 95       	com	r24
    df10:	90 95       	com	r25
    df12:	9b 01       	movw	r18, r22
    df14:	ac 01       	movw	r20, r24
    df16:	bd 01       	movw	r22, r26
    df18:	cf 01       	movw	r24, r30
    df1a:	08 95       	ret

0000df1c <__muldi3>:
    df1c:	df 93       	push	r29
    df1e:	cf 93       	push	r28
    df20:	1f 93       	push	r17
    df22:	0f 93       	push	r16
    df24:	9a 9d       	mul	r25, r10
    df26:	f0 2d       	mov	r31, r0
    df28:	21 9f       	mul	r18, r17
    df2a:	f0 0d       	add	r31, r0
    df2c:	8b 9d       	mul	r24, r11
    df2e:	f0 0d       	add	r31, r0
    df30:	8a 9d       	mul	r24, r10
    df32:	e0 2d       	mov	r30, r0
    df34:	f1 0d       	add	r31, r1
    df36:	03 9f       	mul	r16, r19
    df38:	f0 0d       	add	r31, r0
    df3a:	02 9f       	mul	r16, r18
    df3c:	e0 0d       	add	r30, r0
    df3e:	f1 1d       	adc	r31, r1
    df40:	4e 9d       	mul	r20, r14
    df42:	e0 0d       	add	r30, r0
    df44:	f1 1d       	adc	r31, r1
    df46:	5e 9d       	mul	r21, r14
    df48:	f0 0d       	add	r31, r0
    df4a:	4f 9d       	mul	r20, r15
    df4c:	f0 0d       	add	r31, r0
    df4e:	7f 93       	push	r23
    df50:	6f 93       	push	r22
    df52:	bf 92       	push	r11
    df54:	af 92       	push	r10
    df56:	5f 93       	push	r21
    df58:	4f 93       	push	r20
    df5a:	d5 01       	movw	r26, r10
    df5c:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    df60:	8b 01       	movw	r16, r22
    df62:	ac 01       	movw	r20, r24
    df64:	d7 01       	movw	r26, r14
    df66:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    df6a:	eb 01       	movw	r28, r22
    df6c:	e8 0f       	add	r30, r24
    df6e:	f9 1f       	adc	r31, r25
    df70:	d6 01       	movw	r26, r12
    df72:	22 d0       	rcall	.+68     	; 0xdfb8 <__muldi3_6>
    df74:	2f 91       	pop	r18
    df76:	3f 91       	pop	r19
    df78:	d6 01       	movw	r26, r12
    df7a:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    df7e:	c6 0f       	add	r28, r22
    df80:	d7 1f       	adc	r29, r23
    df82:	e8 1f       	adc	r30, r24
    df84:	f9 1f       	adc	r31, r25
    df86:	af 91       	pop	r26
    df88:	bf 91       	pop	r27
    df8a:	16 d0       	rcall	.+44     	; 0xdfb8 <__muldi3_6>
    df8c:	2f 91       	pop	r18
    df8e:	3f 91       	pop	r19
    df90:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    df94:	c6 0f       	add	r28, r22
    df96:	d7 1f       	adc	r29, r23
    df98:	e8 1f       	adc	r30, r24
    df9a:	f9 1f       	adc	r31, r25
    df9c:	d6 01       	movw	r26, r12
    df9e:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    dfa2:	e6 0f       	add	r30, r22
    dfa4:	f7 1f       	adc	r31, r23
    dfa6:	98 01       	movw	r18, r16
    dfa8:	be 01       	movw	r22, r28
    dfaa:	cf 01       	movw	r24, r30
    dfac:	11 24       	eor	r1, r1
    dfae:	0f 91       	pop	r16
    dfb0:	1f 91       	pop	r17
    dfb2:	cf 91       	pop	r28
    dfb4:	df 91       	pop	r29
    dfb6:	08 95       	ret

0000dfb8 <__muldi3_6>:
    dfb8:	0e 94 19 70 	call	0xe032	; 0xe032 <__umulhisi3>
    dfbc:	46 0f       	add	r20, r22
    dfbe:	57 1f       	adc	r21, r23
    dfc0:	c8 1f       	adc	r28, r24
    dfc2:	d9 1f       	adc	r29, r25
    dfc4:	08 f4       	brcc	.+2      	; 0xdfc8 <__muldi3_6+0x10>
    dfc6:	31 96       	adiw	r30, 0x01	; 1
    dfc8:	08 95       	ret

0000dfca <__tablejump_elpm__>:
    dfca:	07 90       	elpm	r0, Z+
    dfcc:	f6 91       	elpm	r31, Z
    dfce:	e0 2d       	mov	r30, r0
    dfd0:	19 94       	eijmp

0000dfd2 <__ashldi3>:
    dfd2:	0f 93       	push	r16
    dfd4:	0f 73       	andi	r16, 0x3F	; 63
    dfd6:	51 f0       	breq	.+20     	; 0xdfec <__ashldi3+0x1a>
    dfd8:	22 0f       	add	r18, r18
    dfda:	33 1f       	adc	r19, r19
    dfdc:	44 1f       	adc	r20, r20
    dfde:	55 1f       	adc	r21, r21
    dfe0:	66 1f       	adc	r22, r22
    dfe2:	77 1f       	adc	r23, r23
    dfe4:	88 1f       	adc	r24, r24
    dfe6:	99 1f       	adc	r25, r25
    dfe8:	0a 95       	dec	r16
    dfea:	b1 f7       	brne	.-20     	; 0xdfd8 <__ashldi3+0x6>
    dfec:	0f 91       	pop	r16
    dfee:	08 95       	ret

0000dff0 <__ashrdi3>:
    dff0:	0f 93       	push	r16
    dff2:	0f 73       	andi	r16, 0x3F	; 63
    dff4:	51 f0       	breq	.+20     	; 0xe00a <__ashrdi3+0x1a>
    dff6:	95 95       	asr	r25
    dff8:	87 95       	ror	r24
    dffa:	77 95       	ror	r23
    dffc:	67 95       	ror	r22
    dffe:	57 95       	ror	r21
    e000:	47 95       	ror	r20
    e002:	37 95       	ror	r19
    e004:	27 95       	ror	r18
    e006:	0a 95       	dec	r16
    e008:	b1 f7       	brne	.-20     	; 0xdff6 <__ashrdi3+0x6>
    e00a:	0f 91       	pop	r16
    e00c:	08 95       	ret

0000e00e <__adddi3>:
    e00e:	2a 0d       	add	r18, r10
    e010:	3b 1d       	adc	r19, r11
    e012:	4c 1d       	adc	r20, r12
    e014:	5d 1d       	adc	r21, r13
    e016:	6e 1d       	adc	r22, r14
    e018:	7f 1d       	adc	r23, r15
    e01a:	80 1f       	adc	r24, r16
    e01c:	91 1f       	adc	r25, r17
    e01e:	08 95       	ret

0000e020 <__subdi3>:
    e020:	2a 19       	sub	r18, r10
    e022:	3b 09       	sbc	r19, r11
    e024:	4c 09       	sbc	r20, r12
    e026:	5d 09       	sbc	r21, r13
    e028:	6e 09       	sbc	r22, r14
    e02a:	7f 09       	sbc	r23, r15
    e02c:	80 0b       	sbc	r24, r16
    e02e:	91 0b       	sbc	r25, r17
    e030:	08 95       	ret

0000e032 <__umulhisi3>:
    e032:	a2 9f       	mul	r26, r18
    e034:	b0 01       	movw	r22, r0
    e036:	b3 9f       	mul	r27, r19
    e038:	c0 01       	movw	r24, r0
    e03a:	a3 9f       	mul	r26, r19
    e03c:	01 d0       	rcall	.+2      	; 0xe040 <__umulhisi3+0xe>
    e03e:	b2 9f       	mul	r27, r18
    e040:	70 0d       	add	r23, r0
    e042:	81 1d       	adc	r24, r1
    e044:	11 24       	eor	r1, r1
    e046:	91 1d       	adc	r25, r1
    e048:	08 95       	ret

0000e04a <malloc>:
    e04a:	0f 93       	push	r16
    e04c:	1f 93       	push	r17
    e04e:	cf 93       	push	r28
    e050:	df 93       	push	r29
    e052:	82 30       	cpi	r24, 0x02	; 2
    e054:	91 05       	cpc	r25, r1
    e056:	10 f4       	brcc	.+4      	; 0xe05c <malloc+0x12>
    e058:	82 e0       	ldi	r24, 0x02	; 2
    e05a:	90 e0       	ldi	r25, 0x00	; 0
    e05c:	e0 91 7e 10 	lds	r30, 0x107E
    e060:	f0 91 7f 10 	lds	r31, 0x107F
    e064:	20 e0       	ldi	r18, 0x00	; 0
    e066:	30 e0       	ldi	r19, 0x00	; 0
    e068:	c0 e0       	ldi	r28, 0x00	; 0
    e06a:	d0 e0       	ldi	r29, 0x00	; 0
    e06c:	23 c0       	rjmp	.+70     	; 0xe0b4 <malloc+0x6a>
    e06e:	40 81       	ld	r20, Z
    e070:	51 81       	ldd	r21, Z+1	; 0x01
    e072:	48 17       	cp	r20, r24
    e074:	59 07       	cpc	r21, r25
    e076:	a8 f0       	brcs	.+42     	; 0xe0a2 <malloc+0x58>
    e078:	48 17       	cp	r20, r24
    e07a:	59 07       	cpc	r21, r25
    e07c:	61 f4       	brne	.+24     	; 0xe096 <malloc+0x4c>
    e07e:	82 81       	ldd	r24, Z+2	; 0x02
    e080:	93 81       	ldd	r25, Z+3	; 0x03
    e082:	20 97       	sbiw	r28, 0x00	; 0
    e084:	19 f0       	breq	.+6      	; 0xe08c <malloc+0x42>
    e086:	9b 83       	std	Y+3, r25	; 0x03
    e088:	8a 83       	std	Y+2, r24	; 0x02
    e08a:	2e c0       	rjmp	.+92     	; 0xe0e8 <malloc+0x9e>
    e08c:	90 93 7f 10 	sts	0x107F, r25
    e090:	80 93 7e 10 	sts	0x107E, r24
    e094:	29 c0       	rjmp	.+82     	; 0xe0e8 <malloc+0x9e>
    e096:	21 15       	cp	r18, r1
    e098:	31 05       	cpc	r19, r1
    e09a:	29 f0       	breq	.+10     	; 0xe0a6 <malloc+0x5c>
    e09c:	42 17       	cp	r20, r18
    e09e:	53 07       	cpc	r21, r19
    e0a0:	10 f0       	brcs	.+4      	; 0xe0a6 <malloc+0x5c>
    e0a2:	a9 01       	movw	r20, r18
    e0a4:	02 c0       	rjmp	.+4      	; 0xe0aa <malloc+0x60>
    e0a6:	be 01       	movw	r22, r28
    e0a8:	df 01       	movw	r26, r30
    e0aa:	02 81       	ldd	r16, Z+2	; 0x02
    e0ac:	13 81       	ldd	r17, Z+3	; 0x03
    e0ae:	ef 01       	movw	r28, r30
    e0b0:	9a 01       	movw	r18, r20
    e0b2:	f8 01       	movw	r30, r16
    e0b4:	30 97       	sbiw	r30, 0x00	; 0
    e0b6:	d9 f6       	brne	.-74     	; 0xe06e <malloc+0x24>
    e0b8:	21 15       	cp	r18, r1
    e0ba:	31 05       	cpc	r19, r1
    e0bc:	09 f1       	breq	.+66     	; 0xe100 <malloc+0xb6>
    e0be:	28 1b       	sub	r18, r24
    e0c0:	39 0b       	sbc	r19, r25
    e0c2:	24 30       	cpi	r18, 0x04	; 4
    e0c4:	31 05       	cpc	r19, r1
    e0c6:	90 f4       	brcc	.+36     	; 0xe0ec <malloc+0xa2>
    e0c8:	12 96       	adiw	r26, 0x02	; 2
    e0ca:	8d 91       	ld	r24, X+
    e0cc:	9c 91       	ld	r25, X
    e0ce:	13 97       	sbiw	r26, 0x03	; 3
    e0d0:	61 15       	cp	r22, r1
    e0d2:	71 05       	cpc	r23, r1
    e0d4:	21 f0       	breq	.+8      	; 0xe0de <malloc+0x94>
    e0d6:	fb 01       	movw	r30, r22
    e0d8:	93 83       	std	Z+3, r25	; 0x03
    e0da:	82 83       	std	Z+2, r24	; 0x02
    e0dc:	04 c0       	rjmp	.+8      	; 0xe0e6 <malloc+0x9c>
    e0de:	90 93 7f 10 	sts	0x107F, r25
    e0e2:	80 93 7e 10 	sts	0x107E, r24
    e0e6:	fd 01       	movw	r30, r26
    e0e8:	32 96       	adiw	r30, 0x02	; 2
    e0ea:	44 c0       	rjmp	.+136    	; 0xe174 <malloc+0x12a>
    e0ec:	fd 01       	movw	r30, r26
    e0ee:	e2 0f       	add	r30, r18
    e0f0:	f3 1f       	adc	r31, r19
    e0f2:	81 93       	st	Z+, r24
    e0f4:	91 93       	st	Z+, r25
    e0f6:	22 50       	subi	r18, 0x02	; 2
    e0f8:	31 09       	sbc	r19, r1
    e0fa:	2d 93       	st	X+, r18
    e0fc:	3c 93       	st	X, r19
    e0fe:	3a c0       	rjmp	.+116    	; 0xe174 <malloc+0x12a>
    e100:	20 91 7c 10 	lds	r18, 0x107C
    e104:	30 91 7d 10 	lds	r19, 0x107D
    e108:	23 2b       	or	r18, r19
    e10a:	41 f4       	brne	.+16     	; 0xe11c <malloc+0xd2>
    e10c:	20 91 02 02 	lds	r18, 0x0202
    e110:	30 91 03 02 	lds	r19, 0x0203
    e114:	30 93 7d 10 	sts	0x107D, r19
    e118:	20 93 7c 10 	sts	0x107C, r18
    e11c:	20 91 00 02 	lds	r18, 0x0200
    e120:	30 91 01 02 	lds	r19, 0x0201
    e124:	21 15       	cp	r18, r1
    e126:	31 05       	cpc	r19, r1
    e128:	41 f4       	brne	.+16     	; 0xe13a <malloc+0xf0>
    e12a:	2d b7       	in	r18, 0x3d	; 61
    e12c:	3e b7       	in	r19, 0x3e	; 62
    e12e:	40 91 04 02 	lds	r20, 0x0204
    e132:	50 91 05 02 	lds	r21, 0x0205
    e136:	24 1b       	sub	r18, r20
    e138:	35 0b       	sbc	r19, r21
    e13a:	e0 91 7c 10 	lds	r30, 0x107C
    e13e:	f0 91 7d 10 	lds	r31, 0x107D
    e142:	e2 17       	cp	r30, r18
    e144:	f3 07       	cpc	r31, r19
    e146:	a0 f4       	brcc	.+40     	; 0xe170 <malloc+0x126>
    e148:	2e 1b       	sub	r18, r30
    e14a:	3f 0b       	sbc	r19, r31
    e14c:	28 17       	cp	r18, r24
    e14e:	39 07       	cpc	r19, r25
    e150:	78 f0       	brcs	.+30     	; 0xe170 <malloc+0x126>
    e152:	ac 01       	movw	r20, r24
    e154:	4e 5f       	subi	r20, 0xFE	; 254
    e156:	5f 4f       	sbci	r21, 0xFF	; 255
    e158:	24 17       	cp	r18, r20
    e15a:	35 07       	cpc	r19, r21
    e15c:	48 f0       	brcs	.+18     	; 0xe170 <malloc+0x126>
    e15e:	4e 0f       	add	r20, r30
    e160:	5f 1f       	adc	r21, r31
    e162:	50 93 7d 10 	sts	0x107D, r21
    e166:	40 93 7c 10 	sts	0x107C, r20
    e16a:	81 93       	st	Z+, r24
    e16c:	91 93       	st	Z+, r25
    e16e:	02 c0       	rjmp	.+4      	; 0xe174 <malloc+0x12a>
    e170:	e0 e0       	ldi	r30, 0x00	; 0
    e172:	f0 e0       	ldi	r31, 0x00	; 0
    e174:	cf 01       	movw	r24, r30
    e176:	df 91       	pop	r29
    e178:	cf 91       	pop	r28
    e17a:	1f 91       	pop	r17
    e17c:	0f 91       	pop	r16
    e17e:	08 95       	ret

0000e180 <free>:
    e180:	ef 92       	push	r14
    e182:	ff 92       	push	r15
    e184:	0f 93       	push	r16
    e186:	1f 93       	push	r17
    e188:	cf 93       	push	r28
    e18a:	df 93       	push	r29
    e18c:	00 97       	sbiw	r24, 0x00	; 0
    e18e:	09 f4       	brne	.+2      	; 0xe192 <free+0x12>
    e190:	8f c0       	rjmp	.+286    	; 0xe2b0 <free+0x130>
    e192:	dc 01       	movw	r26, r24
    e194:	12 97       	sbiw	r26, 0x02	; 2
    e196:	13 96       	adiw	r26, 0x03	; 3
    e198:	1c 92       	st	X, r1
    e19a:	1e 92       	st	-X, r1
    e19c:	12 97       	sbiw	r26, 0x02	; 2
    e19e:	e0 90 7e 10 	lds	r14, 0x107E
    e1a2:	f0 90 7f 10 	lds	r15, 0x107F
    e1a6:	e1 14       	cp	r14, r1
    e1a8:	f1 04       	cpc	r15, r1
    e1aa:	89 f4       	brne	.+34     	; 0xe1ce <free+0x4e>
    e1ac:	2d 91       	ld	r18, X+
    e1ae:	3c 91       	ld	r19, X
    e1b0:	11 97       	sbiw	r26, 0x01	; 1
    e1b2:	28 0f       	add	r18, r24
    e1b4:	39 1f       	adc	r19, r25
    e1b6:	80 91 7c 10 	lds	r24, 0x107C
    e1ba:	90 91 7d 10 	lds	r25, 0x107D
    e1be:	82 17       	cp	r24, r18
    e1c0:	93 07       	cpc	r25, r19
    e1c2:	89 f5       	brne	.+98     	; 0xe226 <free+0xa6>
    e1c4:	b0 93 7d 10 	sts	0x107D, r27
    e1c8:	a0 93 7c 10 	sts	0x107C, r26
    e1cc:	71 c0       	rjmp	.+226    	; 0xe2b0 <free+0x130>
    e1ce:	e7 01       	movw	r28, r14
    e1d0:	20 e0       	ldi	r18, 0x00	; 0
    e1d2:	30 e0       	ldi	r19, 0x00	; 0
    e1d4:	01 c0       	rjmp	.+2      	; 0xe1d8 <free+0x58>
    e1d6:	ea 01       	movw	r28, r20
    e1d8:	ca 17       	cp	r28, r26
    e1da:	db 07       	cpc	r29, r27
    e1dc:	38 f4       	brcc	.+14     	; 0xe1ec <free+0x6c>
    e1de:	4a 81       	ldd	r20, Y+2	; 0x02
    e1e0:	5b 81       	ldd	r21, Y+3	; 0x03
    e1e2:	9e 01       	movw	r18, r28
    e1e4:	41 15       	cp	r20, r1
    e1e6:	51 05       	cpc	r21, r1
    e1e8:	b1 f7       	brne	.-20     	; 0xe1d6 <free+0x56>
    e1ea:	22 c0       	rjmp	.+68     	; 0xe230 <free+0xb0>
    e1ec:	bc 01       	movw	r22, r24
    e1ee:	62 50       	subi	r22, 0x02	; 2
    e1f0:	71 09       	sbc	r23, r1
    e1f2:	fb 01       	movw	r30, r22
    e1f4:	d3 83       	std	Z+3, r29	; 0x03
    e1f6:	c2 83       	std	Z+2, r28	; 0x02
    e1f8:	00 81       	ld	r16, Z
    e1fa:	11 81       	ldd	r17, Z+1	; 0x01
    e1fc:	ac 01       	movw	r20, r24
    e1fe:	40 0f       	add	r20, r16
    e200:	51 1f       	adc	r21, r17
    e202:	4c 17       	cp	r20, r28
    e204:	5d 07       	cpc	r21, r29
    e206:	61 f4       	brne	.+24     	; 0xe220 <free+0xa0>
    e208:	48 81       	ld	r20, Y
    e20a:	59 81       	ldd	r21, Y+1	; 0x01
    e20c:	40 0f       	add	r20, r16
    e20e:	51 1f       	adc	r21, r17
    e210:	4e 5f       	subi	r20, 0xFE	; 254
    e212:	5f 4f       	sbci	r21, 0xFF	; 255
    e214:	51 83       	std	Z+1, r21	; 0x01
    e216:	40 83       	st	Z, r20
    e218:	4a 81       	ldd	r20, Y+2	; 0x02
    e21a:	5b 81       	ldd	r21, Y+3	; 0x03
    e21c:	53 83       	std	Z+3, r21	; 0x03
    e21e:	42 83       	std	Z+2, r20	; 0x02
    e220:	21 15       	cp	r18, r1
    e222:	31 05       	cpc	r19, r1
    e224:	29 f4       	brne	.+10     	; 0xe230 <free+0xb0>
    e226:	b0 93 7f 10 	sts	0x107F, r27
    e22a:	a0 93 7e 10 	sts	0x107E, r26
    e22e:	40 c0       	rjmp	.+128    	; 0xe2b0 <free+0x130>
    e230:	f9 01       	movw	r30, r18
    e232:	b3 83       	std	Z+3, r27	; 0x03
    e234:	a2 83       	std	Z+2, r26	; 0x02
    e236:	e9 01       	movw	r28, r18
    e238:	69 91       	ld	r22, Y+
    e23a:	79 91       	ld	r23, Y+
    e23c:	c6 0f       	add	r28, r22
    e23e:	d7 1f       	adc	r29, r23
    e240:	ac 17       	cp	r26, r28
    e242:	bd 07       	cpc	r27, r29
    e244:	79 f4       	brne	.+30     	; 0xe264 <free+0xe4>
    e246:	dc 01       	movw	r26, r24
    e248:	5e 91       	ld	r21, -X
    e24a:	4e 91       	ld	r20, -X
    e24c:	46 0f       	add	r20, r22
    e24e:	57 1f       	adc	r21, r23
    e250:	4e 5f       	subi	r20, 0xFE	; 254
    e252:	5f 4f       	sbci	r21, 0xFF	; 255
    e254:	51 83       	std	Z+1, r21	; 0x01
    e256:	40 83       	st	Z, r20
    e258:	12 96       	adiw	r26, 0x02	; 2
    e25a:	8d 91       	ld	r24, X+
    e25c:	9c 91       	ld	r25, X
    e25e:	13 97       	sbiw	r26, 0x03	; 3
    e260:	93 83       	std	Z+3, r25	; 0x03
    e262:	82 83       	std	Z+2, r24	; 0x02
    e264:	a0 e0       	ldi	r26, 0x00	; 0
    e266:	b0 e0       	ldi	r27, 0x00	; 0
    e268:	02 c0       	rjmp	.+4      	; 0xe26e <free+0xee>
    e26a:	d7 01       	movw	r26, r14
    e26c:	7c 01       	movw	r14, r24
    e26e:	f7 01       	movw	r30, r14
    e270:	82 81       	ldd	r24, Z+2	; 0x02
    e272:	93 81       	ldd	r25, Z+3	; 0x03
    e274:	00 97       	sbiw	r24, 0x00	; 0
    e276:	c9 f7       	brne	.-14     	; 0xe26a <free+0xea>
    e278:	c7 01       	movw	r24, r14
    e27a:	02 96       	adiw	r24, 0x02	; 2
    e27c:	20 81       	ld	r18, Z
    e27e:	31 81       	ldd	r19, Z+1	; 0x01
    e280:	82 0f       	add	r24, r18
    e282:	93 1f       	adc	r25, r19
    e284:	20 91 7c 10 	lds	r18, 0x107C
    e288:	30 91 7d 10 	lds	r19, 0x107D
    e28c:	28 17       	cp	r18, r24
    e28e:	39 07       	cpc	r19, r25
    e290:	79 f4       	brne	.+30     	; 0xe2b0 <free+0x130>
    e292:	10 97       	sbiw	r26, 0x00	; 0
    e294:	29 f4       	brne	.+10     	; 0xe2a0 <free+0x120>
    e296:	10 92 7f 10 	sts	0x107F, r1
    e29a:	10 92 7e 10 	sts	0x107E, r1
    e29e:	04 c0       	rjmp	.+8      	; 0xe2a8 <free+0x128>
    e2a0:	13 96       	adiw	r26, 0x03	; 3
    e2a2:	1c 92       	st	X, r1
    e2a4:	1e 92       	st	-X, r1
    e2a6:	12 97       	sbiw	r26, 0x02	; 2
    e2a8:	f0 92 7d 10 	sts	0x107D, r15
    e2ac:	e0 92 7c 10 	sts	0x107C, r14
    e2b0:	df 91       	pop	r29
    e2b2:	cf 91       	pop	r28
    e2b4:	1f 91       	pop	r17
    e2b6:	0f 91       	pop	r16
    e2b8:	ff 90       	pop	r15
    e2ba:	ef 90       	pop	r14
    e2bc:	08 95       	ret

0000e2be <memcpy>:
    e2be:	fb 01       	movw	r30, r22
    e2c0:	dc 01       	movw	r26, r24
    e2c2:	02 c0       	rjmp	.+4      	; 0xe2c8 <memcpy+0xa>
    e2c4:	01 90       	ld	r0, Z+
    e2c6:	0d 92       	st	X+, r0
    e2c8:	41 50       	subi	r20, 0x01	; 1
    e2ca:	50 40       	sbci	r21, 0x00	; 0
    e2cc:	d8 f7       	brcc	.-10     	; 0xe2c4 <memcpy+0x6>
    e2ce:	08 95       	ret

0000e2d0 <memset>:
    e2d0:	dc 01       	movw	r26, r24
    e2d2:	01 c0       	rjmp	.+2      	; 0xe2d6 <memset+0x6>
    e2d4:	6d 93       	st	X+, r22
    e2d6:	41 50       	subi	r20, 0x01	; 1
    e2d8:	50 40       	sbci	r21, 0x00	; 0
    e2da:	e0 f7       	brcc	.-8      	; 0xe2d4 <memset+0x4>
    e2dc:	08 95       	ret

0000e2de <__do_global_dtors>:
    e2de:	13 e0       	ldi	r17, 0x03	; 3
    e2e0:	c8 e3       	ldi	r28, 0x38	; 56
    e2e2:	d3 e0       	ldi	r29, 0x03	; 3
    e2e4:	00 e0       	ldi	r16, 0x00	; 0
    e2e6:	06 c0       	rjmp	.+12     	; 0xe2f4 <__do_global_dtors+0x16>
    e2e8:	22 97       	sbiw	r28, 0x02	; 2
    e2ea:	01 09       	sbc	r16, r1
    e2ec:	fe 01       	movw	r30, r28
    e2ee:	0b bf       	out	0x3b, r16	; 59
    e2f0:	0e 94 e5 6f 	call	0xdfca	; 0xdfca <__tablejump_elpm__>
    e2f4:	ca 33       	cpi	r28, 0x3A	; 58
    e2f6:	d1 07       	cpc	r29, r17
    e2f8:	80 e0       	ldi	r24, 0x00	; 0
    e2fa:	08 07       	cpc	r16, r24
    e2fc:	a9 f7       	brne	.-22     	; 0xe2e8 <__do_global_dtors+0xa>
    e2fe:	f8 94       	cli

0000e300 <__stop_program>:
    e300:	ff cf       	rjmp	.-2      	; 0xe300 <__stop_program>
